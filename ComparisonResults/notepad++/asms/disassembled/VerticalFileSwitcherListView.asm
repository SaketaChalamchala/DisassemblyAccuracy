.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 15552FAEFBC8574F4E6A76D464E65896
.rdata:00000000 ; Input CRC32 : 11F0FAA7
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\VerticalFileSwitcherListView.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG129447
.rdata:00000000 $SG129447       dw 0                    ; DATA XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+62o
.rdata:00000002                 align 4
.rdata:00000004 ; const WCHAR _SG129448
.rdata:00000004 $SG129448:                              ; DATA XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+67o
.rdata:00000004                 unicode 0, <SysListView32>,0
.rdata:00000020 ; char _SG129452[]
.rdata:00000020 $SG129452       db 'VerticalFileSwitcherListView::init : CreateWindowEx() function re'
.rdata:00000020                                         ; DATA XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+83o
.rdata:00000020                 db 'turn null',0
.rdata:0000006B                 align 4
.rdata:0000006C $SG129510       db 'ColumnName',0       ; DATA XREF: VerticalFileSwitcherListView::initList(void)+111o
.rdata:00000077                 align 4
.rdata:00000078 $SG129511       db 'DocSwitcher',0      ; DATA XREF: VerticalFileSwitcherListView::initList(void)+116o
.rdata:00000084 $SG129512:                              ; DATA XREF: VerticalFileSwitcherListView::initList(void)+11Bo
.rdata:00000084                 unicode 0, <Name>,0
.rdata:0000008E                 align 10h
.rdata:00000090 $SG129516       db 'ColumnExt',0        ; DATA XREF: VerticalFileSwitcherListView::initList(void)+189o
.rdata:0000009A                 align 4
.rdata:0000009C $SG129517       db 'DocSwitcher',0      ; DATA XREF: VerticalFileSwitcherListView::initList(void)+18Eo
.rdata:000000A8 $SG129518:                              ; DATA XREF: VerticalFileSwitcherListView::initList(void)+193o
.rdata:000000A8                 unicode 0, <Ext.>,0
.rdata:000000B2                 align 4
.rdata:000000B4 ; wchar_t _SG129614
.rdata:000000B4 $SG129614       dw 0                    ; DATA XREF: VerticalFileSwitcherListView::getFullFilePath(uint):loc_B3Ao
.rdata:000000B6                 align 4
.rdata:000000B6 _rdata          ends
.rdata:000000B6
.bss:000000B8 ; ===========================================================================
.bss:000000B8
.bss:000000B8 ; Segment type: Uninitialized
.bss:000000B8 ; Segment permissions: Read/Write
.bss:000000B8 _bss            segment dword public 'BSS' use32
.bss:000000B8                 assume cs:_bss
.bss:000000B8                 ;org 0B8h
.bss:000000B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000000B8 _hWndServer     db    ? ;
.bss:000000B9                 db    ? ;
.bss:000000BA                 db    ? ;
.bss:000000BB                 db    ? ;
.bss:000000BC _hook           db    ? ;
.bss:000000BD                 db    ? ;
.bss:000000BE                 db    ? ;
.bss:000000BF                 db    ? ;
.bss:000000C0 _allocator_arg  db    ? ;
.bss:000000C1 _piecewise_construct db    ? ;
.bss:000000C2                 align 4
.bss:000000C2 _bss            ends
.bss:000000C2
.text$mn:000000C4 ; ===========================================================================
.text$mn:000000C4
.text$mn:000000C4 ; Segment type: Pure code
.text$mn:000000C4 ; Segment permissions: Read/Execute
.text$mn:000000C4 _text$mn        segment para public 'CODE' use32
.text$mn:000000C4                 assume cs:_text$mn
.text$mn:000000C4                 ;org 0C4h
.text$mn:000000C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000000C4
.text$mn:000000C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000000C4
.text$mn:000000C4 ; Attributes: bp-based frame
.text$mn:000000C4
.text$mn:000000C4 ; void __thiscall VerticalFileSwitcherListView::init(VerticalFileSwitcherListView *this, HINSTANCE hInstance, HWND, struct _IMAGELIST *)
.text$mn:000000C4                 public ?init@VerticalFileSwitcherListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@@Z
.text$mn:000000C4 ?init@VerticalFileSwitcherListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@@Z proc near
.text$mn:000000C4
.text$mn:000000C4 var_1C          = byte ptr -1Ch
.text$mn:000000C4 picce           = INITCOMMONCONTROLSEX ptr -10h
.text$mn:000000C4 var_8           = dword ptr -8
.text$mn:000000C4 dwNewLong       = dword ptr -4
.text$mn:000000C4 hInstance       = dword ptr  8
.text$mn:000000C4 arg_4           = dword ptr  0Ch
.text$mn:000000C4 arg_8           = dword ptr  10h
.text$mn:000000C4
.text$mn:000000C4                 push    ebp
.text$mn:000000C5                 mov     ebp, esp
.text$mn:000000C7                 sub     esp, 1Ch
.text$mn:000000CA                 mov     [ebp+dwNewLong], ecx
.text$mn:000000CD                 mov     eax, [ebp+arg_4]
.text$mn:000000D0                 push    eax             ; HWND
.text$mn:000000D1                 mov     ecx, [ebp+hInstance]
.text$mn:000000D4                 push    ecx             ; HINSTANCE
.text$mn:000000D5                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:000000D8                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:000000DD                 mov     edx, [ebp+dwNewLong]
.text$mn:000000E0                 mov     eax, [ebp+arg_8]
.text$mn:000000E3                 mov     [edx+10h], eax
.text$mn:000000E6                 mov     [ebp+picce.dwSize], 8
.text$mn:000000ED                 mov     [ebp+picce.dwICC], 1
.text$mn:000000F4                 lea     ecx, [ebp+picce]
.text$mn:000000F7                 push    ecx             ; picce
.text$mn:000000F8                 call    dword ptr ds:__imp__InitCommonControlsEx@4 ; InitCommonControlsEx(x)
.text$mn:000000FE                 mov     [ebp+var_8], 149h
.text$mn:00000105                 push    0               ; lpParam
.text$mn:00000107                 mov     edx, [ebp+hInstance]
.text$mn:0000010A                 push    edx             ; hInstance
.text$mn:0000010B                 push    0               ; hMenu
.text$mn:0000010D                 mov     eax, [ebp+dwNewLong]
.text$mn:00000110                 mov     ecx, [eax+8]
.text$mn:00000113                 push    ecx             ; hWndParent
.text$mn:00000114                 push    0               ; nHeight
.text$mn:00000116                 push    0               ; nWidth
.text$mn:00000118                 push    0               ; Y
.text$mn:0000011A                 push    0               ; X
.text$mn:0000011C                 mov     edx, [ebp+var_8]
.text$mn:0000011F                 or      edx, 40000000h
.text$mn:00000125                 push    edx             ; dwStyle
.text$mn:00000126                 push    offset $SG129447 ; lpWindowName
.text$mn:0000012B                 push    offset $SG129448 ; "SysListView32"
.text$mn:00000130                 push    0               ; dwExStyle
.text$mn:00000132                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:00000138                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000013B                 mov     [ecx+0Ch], eax
.text$mn:0000013E                 mov     edx, [ebp+dwNewLong]
.text$mn:00000141                 cmp     dword ptr [edx+0Ch], 0
.text$mn:00000145                 jnz     short loc_162
.text$mn:00000147                 push    offset $SG129452 ; "VerticalFileSwitcherListView::init : Cr"...
.text$mn:0000014C                 lea     ecx, [ebp+var_1C] ; this
.text$mn:0000014F                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000154                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000159                 lea     eax, [ebp+var_1C]
.text$mn:0000015C                 push    eax
.text$mn:0000015D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000162 ; ---------------------------------------------------------------------------
.text$mn:00000162
.text$mn:00000162 loc_162:                                ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+81j
.text$mn:00000162                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000165                 push    ecx             ; dwNewLong
.text$mn:00000166                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000168                 mov     edx, [ebp+dwNewLong]
.text$mn:0000016B                 mov     eax, [edx+0Ch]
.text$mn:0000016E                 push    eax             ; hWnd
.text$mn:0000016F                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000175                 push    offset ?staticProc@VerticalFileSwitcherListView@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:0000017A                 push    0FFFFFFFCh      ; nIndex
.text$mn:0000017C                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000017F                 mov     edx, [ecx+0Ch]
.text$mn:00000182                 push    edx             ; hWnd
.text$mn:00000183                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000189                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000018C                 mov     [ecx+14h], eax
.text$mn:0000018F                 push    8420h           ; lParam
.text$mn:00000194                 push    0               ; wParam
.text$mn:00000196                 push    1036h           ; Msg
.text$mn:0000019B                 mov     edx, [ebp+dwNewLong]
.text$mn:0000019E                 mov     eax, [edx+0Ch]
.text$mn:000001A1                 push    eax             ; hWnd
.text$mn:000001A2                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001A8                 push    2               ; lParam
.text$mn:000001AA                 push    32h ; '2'       ; wParam
.text$mn:000001AC                 push    102Fh           ; Msg
.text$mn:000001B1                 mov     ecx, [ebp+dwNewLong]
.text$mn:000001B4                 mov     edx, [ecx+0Ch]
.text$mn:000001B7                 push    edx             ; hWnd
.text$mn:000001B8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001BE                 mov     eax, [ebp+dwNewLong]
.text$mn:000001C1                 mov     ecx, [eax+10h]
.text$mn:000001C4                 push    ecx             ; lParam
.text$mn:000001C5                 push    1               ; wParam
.text$mn:000001C7                 push    1003h           ; Msg
.text$mn:000001CC                 mov     edx, [ebp+dwNewLong]
.text$mn:000001CF                 mov     eax, [edx+0Ch]
.text$mn:000001D2                 push    eax             ; hWnd
.text$mn:000001D3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001D9                 mov     esp, ebp
.text$mn:000001DB                 pop     ebp
.text$mn:000001DC                 retn    0Ch
.text$mn:000001DC ?init@VerticalFileSwitcherListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@@Z endp
.text$mn:000001DC
.text$mn:000001DC ; ---------------------------------------------------------------------------
.text$mn:000001DF                 db 5 dup(0CCh)
.text$mn:000001E4
.text$mn:000001E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000001E4
.text$mn:000001E4 ; Attributes: bp-based frame
.text$mn:000001E4
.text$mn:000001E4 ; void __thiscall VerticalFileSwitcherListView::destroy(VerticalFileSwitcherListView *__hidden this)
.text$mn:000001E4                 public ?destroy@VerticalFileSwitcherListView@@UAEXXZ
.text$mn:000001E4 ?destroy@VerticalFileSwitcherListView@@UAEXXZ proc near
.text$mn:000001E4
.text$mn:000001E4 lParam          = dword ptr -50h
.text$mn:000001E4 var_4C          = dword ptr -4Ch
.text$mn:000001E4 var_30          = dword ptr -30h
.text$mn:000001E4 var_1C          = dword ptr -1Ch
.text$mn:000001E4 var_18          = dword ptr -18h
.text$mn:000001E4 var_14          = dword ptr -14h
.text$mn:000001E4 var_10          = dword ptr -10h
.text$mn:000001E4 var_C           = dword ptr -0Ch
.text$mn:000001E4 var_8           = dword ptr -8
.text$mn:000001E4 var_4           = dword ptr -4
.text$mn:000001E4
.text$mn:000001E4                 push    ebp
.text$mn:000001E5                 mov     ebp, esp
.text$mn:000001E7                 sub     esp, 50h
.text$mn:000001EA                 mov     [ebp+var_8], ecx
.text$mn:000001ED                 mov     [ebp+lParam], 4
.text$mn:000001F4                 push    0               ; lParam
.text$mn:000001F6                 push    0               ; wParam
.text$mn:000001F8                 push    1004h           ; Msg
.text$mn:000001FD                 mov     eax, [ebp+var_8]
.text$mn:00000200                 mov     ecx, [eax+0Ch]
.text$mn:00000203                 push    ecx             ; hWnd
.text$mn:00000204                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000020A                 mov     [ebp+var_10], eax
.text$mn:0000020D                 mov     [ebp+var_4], 0
.text$mn:00000214                 jmp     short loc_21F
.text$mn:00000216 ; ---------------------------------------------------------------------------
.text$mn:00000216
.text$mn:00000216 loc_216:                                ; CODE XREF: VerticalFileSwitcherListView::destroy(void):loc_273j
.text$mn:00000216                 mov     edx, [ebp+var_4]
.text$mn:00000219                 add     edx, 1
.text$mn:0000021C                 mov     [ebp+var_4], edx
.text$mn:0000021F
.text$mn:0000021F loc_21F:                                ; CODE XREF: VerticalFileSwitcherListView::destroy(void)+30j
.text$mn:0000021F                 mov     eax, [ebp+var_4]
.text$mn:00000222                 cmp     eax, [ebp+var_10]
.text$mn:00000225                 jge     short loc_275
.text$mn:00000227                 mov     ecx, [ebp+var_4]
.text$mn:0000022A                 mov     [ebp+var_4C], ecx
.text$mn:0000022D                 lea     edx, [ebp+lParam]
.text$mn:00000230                 push    edx             ; lParam
.text$mn:00000231                 push    0               ; wParam
.text$mn:00000233                 push    104Bh           ; Msg
.text$mn:00000238                 mov     eax, [ebp+var_8]
.text$mn:0000023B                 mov     ecx, [eax+0Ch]
.text$mn:0000023E                 push    ecx             ; hWnd
.text$mn:0000023F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000245                 mov     edx, [ebp+var_30]
.text$mn:00000248                 mov     [ebp+var_14], edx
.text$mn:0000024B                 mov     eax, [ebp+var_14]
.text$mn:0000024E                 mov     [ebp+var_18], eax
.text$mn:00000251                 mov     ecx, [ebp+var_18]
.text$mn:00000254                 mov     [ebp+var_C], ecx
.text$mn:00000257                 cmp     [ebp+var_C], 0
.text$mn:0000025B                 jz      short loc_26C
.text$mn:0000025D                 push    1
.text$mn:0000025F                 mov     ecx, [ebp+var_C]
.text$mn:00000262                 call    ??_GTaskLstFnStatus@@QAEPAXI@Z ; TaskLstFnStatus::`scalar deleting destructor'(uint)
.text$mn:00000267                 mov     [ebp+var_1C], eax
.text$mn:0000026A                 jmp     short loc_273
.text$mn:0000026C ; ---------------------------------------------------------------------------
.text$mn:0000026C
.text$mn:0000026C loc_26C:                                ; CODE XREF: VerticalFileSwitcherListView::destroy(void)+77j
.text$mn:0000026C                 mov     [ebp+var_1C], 0
.text$mn:00000273
.text$mn:00000273 loc_273:                                ; CODE XREF: VerticalFileSwitcherListView::destroy(void)+86j
.text$mn:00000273                 jmp     short loc_216
.text$mn:00000275 ; ---------------------------------------------------------------------------
.text$mn:00000275
.text$mn:00000275 loc_275:                                ; CODE XREF: VerticalFileSwitcherListView::destroy(void)+41j
.text$mn:00000275                 mov     edx, [ebp+var_8]
.text$mn:00000278                 mov     eax, [edx+0Ch]
.text$mn:0000027B                 push    eax             ; hWnd
.text$mn:0000027C                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00000282                 mov     ecx, [ebp+var_8]
.text$mn:00000285                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000028C                 mov     esp, ebp
.text$mn:0000028E                 pop     ebp
.text$mn:0000028F                 retn
.text$mn:0000028F ?destroy@VerticalFileSwitcherListView@@UAEXXZ endp
.text$mn:0000028F
.text$mn:0000028F ; ---------------------------------------------------------------------------
.text$mn:00000290                 db 4 dup(0CCh)
.text$mn:00000294
.text$mn:00000294 ; =============== S U B R O U T I N E =======================================
.text$mn:00000294
.text$mn:00000294 ; Attributes: bp-based frame
.text$mn:00000294
.text$mn:00000294 ; void __thiscall VerticalFileSwitcherListView::initList(VerticalFileSwitcherListView *__hidden this)
.text$mn:00000294                 public ?initList@VerticalFileSwitcherListView@@QAEXXZ
.text$mn:00000294 ?initList@VerticalFileSwitcherListView@@QAEXXZ proc near
.text$mn:00000294                                         ; CODE XREF: VerticalFileSwitcherListView::reload(void)+12p
.text$mn:00000294
.text$mn:00000294 var_358         = dword ptr -358h
.text$mn:00000294 var_34C         = dword ptr -34Ch
.text$mn:00000294 var_348         = dword ptr -348h
.text$mn:00000294 var_324         = dword ptr -324h
.text$mn:00000294 var_31C         = dword ptr -31Ch
.text$mn:00000294 var_310         = dword ptr -310h
.text$mn:00000294 lParam          = dword ptr -2F0h
.text$mn:00000294 var_2EC         = dword ptr -2ECh
.text$mn:00000294 var_2E8         = dword ptr -2E8h
.text$mn:00000294 var_2DC         = dword ptr -2DCh
.text$mn:00000294 var_2D4         = dword ptr -2D4h
.text$mn:00000294 var_2D0         = dword ptr -2D0h
.text$mn:00000294 var_2BC         = dword ptr -2BCh
.text$mn:00000294 var_2B8         = dword ptr -2B8h
.text$mn:00000294 wParam          = dword ptr -2B4h
.text$mn:00000294 var_2A4         = dword ptr -2A4h
.text$mn:00000294 var_2A0         = dword ptr -2A0h
.text$mn:00000294 var_29C         = dword ptr -29Ch
.text$mn:00000294 var_298         = dword ptr -298h
.text$mn:00000294 var_294         = dword ptr -294h
.text$mn:00000294 var_290         = dword ptr -290h
.text$mn:00000294 var_28C         = dword ptr -28Ch
.text$mn:00000294 var_288         = dword ptr -288h
.text$mn:00000294 var_284         = dword ptr -284h
.text$mn:00000294 var_280         = dword ptr -280h
.text$mn:00000294 var_27C         = dword ptr -27Ch
.text$mn:00000294 var_278         = dword ptr -278h
.text$mn:00000294 var_274         = dword ptr -274h
.text$mn:00000294 var_270         = dword ptr -270h
.text$mn:00000294 var_26C         = dword ptr -26Ch
.text$mn:00000294 var_268         = dword ptr -268h
.text$mn:00000294 var_261         = byte ptr -261h
.text$mn:00000294 var_260         = byte ptr -260h
.text$mn:00000294 var_244         = byte ptr -244h
.text$mn:00000294 Rect            = tagRECT ptr -228h
.text$mn:00000294 String1         = word ptr -218h
.text$mn:00000294 var_10          = dword ptr -10h
.text$mn:00000294 var_C           = dword ptr -0Ch
.text$mn:00000294 var_4           = dword ptr -4
.text$mn:00000294
.text$mn:00000294                 push    ebp
.text$mn:00000295                 mov     ebp, esp
.text$mn:00000297                 push    0FFFFFFFFh
.text$mn:00000299                 push    offset __ehhandler$?initList@VerticalFileSwitcherListView@@QAEXXZ
.text$mn:0000029E                 mov     eax, large fs:0
.text$mn:000002A4                 push    eax
.text$mn:000002A5                 sub     esp, 34Ch
.text$mn:000002AB                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000002B0                 xor     eax, ebp
.text$mn:000002B2                 mov     [ebp+var_10], eax
.text$mn:000002B5                 push    eax
.text$mn:000002B6                 lea     eax, [ebp+var_C]
.text$mn:000002B9                 mov     large fs:0, eax
.text$mn:000002BF                 mov     [ebp+var_26C], ecx
.text$mn:000002C5                 lea     ecx, [ebp+wParam] ; this
.text$mn:000002CB                 call    ??0TaskListInfo@@QAE@XZ ; TaskListInfo::TaskListInfo(void)
.text$mn:000002D0                 mov     [ebp+var_4], 0
.text$mn:000002D7                 mov     eax, ds:?$S1@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4IA
.text$mn:000002DC                 and     eax, 1
.text$mn:000002DF                 jnz     short loc_30D
.text$mn:000002E1                 mov     ecx, ds:?$S1@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4IA
.text$mn:000002E7                 or      ecx, 1
.text$mn:000002EA                 mov     ds:?$S1@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4IA, ecx
.text$mn:000002F0                 mov     byte ptr [ebp+var_4], 1
.text$mn:000002F4                 mov     edx, [ebp+var_26C]
.text$mn:000002FA                 mov     eax, [edx+8]
.text$mn:000002FD                 push    eax             ; hWnd
.text$mn:000002FE                 call    dword ptr ds:__imp__GetParent@4 ; GetParent(x)
.text$mn:00000304                 mov     ds:?nppHwnd@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4PAUHWND__@@A, eax ; HWND__ * `VerticalFileSwitcherListView::initList(void)'::`2'::nppHwnd
.text$mn:00000309                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000030D
.text$mn:0000030D loc_30D:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+4Bj
.text$mn:0000030D                 push    1               ; lParam
.text$mn:0000030F                 lea     ecx, [ebp+wParam]
.text$mn:00000315                 push    ecx             ; wParam
.text$mn:00000316                 push    2341h           ; Msg
.text$mn:0000031B                 mov     edx, ds:?nppHwnd@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4PAUHWND__@@A ; HWND__ * `VerticalFileSwitcherListView::initList(void)'::`2'::nppHwnd
.text$mn:00000321                 push    edx             ; hWnd
.text$mn:00000322                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000328                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000032D                 mov     [ebp+var_284], eax
.text$mn:00000333                 mov     ecx, [ebp+var_284] ; this
.text$mn:00000339                 call    ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ ; NppParameters::getNativeLangSpeaker(void)
.text$mn:0000033E                 mov     [ebp+var_28C], eax
.text$mn:00000344                 mov     ecx, [ebp+var_284] ; this
.text$mn:0000034A                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:0000034F                 movzx   eax, byte ptr [eax+694h]
.text$mn:00000356                 test    eax, eax
.text$mn:00000358                 jnz     short loc_366
.text$mn:0000035A                 mov     [ebp+var_278], 1
.text$mn:00000364                 jmp     short loc_370
.text$mn:00000366 ; ---------------------------------------------------------------------------
.text$mn:00000366
.text$mn:00000366 loc_366:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+C4j
.text$mn:00000366                 mov     [ebp+var_278], 0
.text$mn:00000370
.text$mn:00000370 loc_370:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+D0j
.text$mn:00000370                 mov     cl, byte ptr [ebp+var_278]
.text$mn:00000376                 mov     [ebp+var_261], cl
.text$mn:0000037C                 lea     edx, [ebp+Rect]
.text$mn:00000382                 push    edx             ; lpRect
.text$mn:00000383                 mov     eax, [ebp+var_26C]
.text$mn:00000389                 mov     ecx, [eax+8]
.text$mn:0000038C                 push    ecx             ; hWnd
.text$mn:0000038D                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00000393                 mov     edx, [ebp+Rect.right]
.text$mn:00000399                 sub     edx, [ebp+Rect.left]
.text$mn:0000039F                 mov     [ebp+var_27C], edx
.text$mn:000003A5                 push    offset $SG129510 ; "ColumnName"
.text$mn:000003AA                 push    offset $SG129511 ; "DocSwitcher"
.text$mn:000003AF                 push    offset $SG129512 ; "Name"
.text$mn:000003B4                 lea     eax, [ebp+var_244]
.text$mn:000003BA                 push    eax
.text$mn:000003BB                 mov     ecx, [ebp+var_28C]
.text$mn:000003C1                 call    ?getAttrNameStr@NativeLangSpeaker@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WPBD1@Z ; NativeLangSpeaker::getAttrNameStr(wchar_t const *,char const *,char const *)
.text$mn:000003C6                 mov     byte ptr [ebp+var_4], 2
.text$mn:000003CA                 movzx   ecx, [ebp+var_261]
.text$mn:000003D1                 test    ecx, ecx
.text$mn:000003D3                 jz      short loc_3E6
.text$mn:000003D5                 mov     edx, [ebp+var_27C]
.text$mn:000003DB                 sub     edx, 32h ; '2'
.text$mn:000003DE                 mov     [ebp+var_274], edx
.text$mn:000003E4                 jmp     short loc_3F2
.text$mn:000003E6 ; ---------------------------------------------------------------------------
.text$mn:000003E6
.text$mn:000003E6 loc_3E6:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+13Fj
.text$mn:000003E6                 mov     eax, [ebp+var_27C]
.text$mn:000003EC                 mov     [ebp+var_274], eax
.text$mn:000003F2
.text$mn:000003F2 loc_3F2:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+150j
.text$mn:000003F2                 push    0               ; int
.text$mn:000003F4                 mov     ecx, [ebp+var_274]
.text$mn:000003FA                 push    ecx             ; int
.text$mn:000003FB                 lea     ecx, [ebp+var_244]
.text$mn:00000401                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000406                 push    eax             ; wchar_t *
.text$mn:00000407                 mov     ecx, [ebp+var_26C] ; this
.text$mn:0000040D                 call    ?insertColumn@VerticalFileSwitcherListView@@QAEXPB_WHH@Z ; VerticalFileSwitcherListView::insertColumn(wchar_t const *,int,int)
.text$mn:00000412                 movzx   edx, [ebp+var_261]
.text$mn:00000419                 test    edx, edx
.text$mn:0000041B                 jz      short loc_46C
.text$mn:0000041D                 push    offset $SG129516 ; "ColumnExt"
.text$mn:00000422                 push    offset $SG129517 ; "DocSwitcher"
.text$mn:00000427                 push    offset $SG129518 ; "Ext."
.text$mn:0000042C                 lea     eax, [ebp+var_260]
.text$mn:00000432                 push    eax
.text$mn:00000433                 mov     ecx, [ebp+var_28C]
.text$mn:00000439                 call    ?getAttrNameStr@NativeLangSpeaker@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WPBD1@Z ; NativeLangSpeaker::getAttrNameStr(wchar_t const *,char const *,char const *)
.text$mn:0000043E                 mov     byte ptr [ebp+var_4], 3
.text$mn:00000442                 push    1               ; int
.text$mn:00000444                 push    32h ; '2'       ; int
.text$mn:00000446                 lea     ecx, [ebp+var_260]
.text$mn:0000044C                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000451                 push    eax             ; wchar_t *
.text$mn:00000452                 mov     ecx, [ebp+var_26C] ; this
.text$mn:00000458                 call    ?insertColumn@VerticalFileSwitcherListView@@QAEXPB_WHH@Z ; VerticalFileSwitcherListView::insertColumn(wchar_t const *,int,int)
.text$mn:0000045D                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000461                 lea     ecx, [ebp+var_260]
.text$mn:00000467                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000046C
.text$mn:0000046C loc_46C:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+187j
.text$mn:0000046C                 mov     [ebp+var_270], 0
.text$mn:00000476                 lea     ecx, [ebp+wParam]
.text$mn:0000047C                 call    ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::size(void)
.text$mn:00000481                 mov     [ebp+var_29C], eax
.text$mn:00000487                 jmp     short loc_498
.text$mn:00000489 ; ---------------------------------------------------------------------------
.text$mn:00000489
.text$mn:00000489 loc_489:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void):loc_672j
.text$mn:00000489                 mov     ecx, [ebp+var_270]
.text$mn:0000048F                 add     ecx, 1
.text$mn:00000492                 mov     [ebp+var_270], ecx
.text$mn:00000498
.text$mn:00000498 loc_498:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+1F3j
.text$mn:00000498                 mov     edx, [ebp+var_270]
.text$mn:0000049E                 cmp     edx, [ebp+var_29C]
.text$mn:000004A4                 jnb     loc_677
.text$mn:000004AA                 mov     eax, [ebp+var_270]
.text$mn:000004B0                 push    eax
.text$mn:000004B1                 lea     ecx, [ebp+wParam]
.text$mn:000004B7                 call    ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)
.text$mn:000004BC                 mov     [ebp+var_268], eax
.text$mn:000004C2                 push    2Ch ; ','       ; unsigned int
.text$mn:000004C4                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000004C9                 add     esp, 4
.text$mn:000004CC                 mov     [ebp+var_288], eax
.text$mn:000004D2                 mov     byte ptr [ebp+var_4], 4
.text$mn:000004D6                 cmp     [ebp+var_288], 0
.text$mn:000004DD                 jz      short loc_559
.text$mn:000004DF                 mov     ecx, [ebp+var_268]
.text$mn:000004E5                 mov     edx, [ecx+28h]
.text$mn:000004E8                 push    edx
.text$mn:000004E9                 mov     eax, [ebp+var_268]
.text$mn:000004EF                 mov     ecx, [eax+24h]
.text$mn:000004F2                 push    ecx
.text$mn:000004F3                 mov     edx, [ebp+var_268]
.text$mn:000004F9                 add     edx, 8
.text$mn:000004FC                 sub     esp, 1Ch
.text$mn:000004FF                 mov     ecx, esp
.text$mn:00000501                 mov     [ebp+var_2BC], esp
.text$mn:00000507                 push    edx
.text$mn:00000508                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000050D                 mov     [ebp+var_290], eax
.text$mn:00000513                 mov     eax, [ebp+var_290]
.text$mn:00000519                 mov     [ebp+var_2B8], eax
.text$mn:0000051F                 mov     byte ptr [ebp+var_4], 5
.text$mn:00000523                 mov     ecx, [ebp+var_268]
.text$mn:00000529                 mov     edx, [ecx+4]
.text$mn:0000052C                 push    edx
.text$mn:0000052D                 mov     eax, [ebp+var_268]
.text$mn:00000533                 mov     ecx, [eax]
.text$mn:00000535                 push    ecx
.text$mn:00000536                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000053A                 mov     ecx, [ebp+var_288]
.text$mn:00000540                 call    ??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z ; TaskLstFnStatus::TaskLstFnStatus(int,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,int,void *)
.text$mn:00000545                 mov     [ebp+var_294], eax
.text$mn:0000054B                 mov     edx, [ebp+var_294]
.text$mn:00000551                 mov     [ebp+var_280], edx
.text$mn:00000557                 jmp     short loc_563
.text$mn:00000559 ; ---------------------------------------------------------------------------
.text$mn:00000559
.text$mn:00000559 loc_559:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+249j
.text$mn:00000559                 mov     [ebp+var_280], 0
.text$mn:00000563
.text$mn:00000563 loc_563:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+2C3j
.text$mn:00000563                 mov     eax, [ebp+var_280]
.text$mn:00000569                 mov     [ebp+var_298], eax
.text$mn:0000056F                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000573                 mov     ecx, [ebp+var_298]
.text$mn:00000579                 mov     [ebp+var_2A0], ecx
.text$mn:0000057F                 mov     ecx, [ebp+var_268]
.text$mn:00000585                 add     ecx, 8
.text$mn:00000588                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000058D                 push    eax             ; pszPath
.text$mn:0000058E                 call    dword ptr ds:__imp__PathFindFileNameW@4 ; PathFindFileNameW(x)
.text$mn:00000594                 push    eax             ; lpString2
.text$mn:00000595                 lea     edx, [ebp+String1]
.text$mn:0000059B                 push    edx             ; lpString1
.text$mn:0000059C                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:000005A2                 movzx   eax, [ebp+var_261]
.text$mn:000005A9                 test    eax, eax
.text$mn:000005AB                 jz      short loc_5BA
.text$mn:000005AD                 lea     ecx, [ebp+String1]
.text$mn:000005B3                 push    ecx             ; pszPath
.text$mn:000005B4                 call    dword ptr ds:__imp__PathRemoveExtensionW@4 ; PathRemoveExtensionW(x)
.text$mn:000005BA
.text$mn:000005BA loc_5BA:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+317j
.text$mn:000005BA                 mov     [ebp+lParam], 7
.text$mn:000005C4                 lea     edx, [ebp+String1]
.text$mn:000005CA                 mov     [ebp+var_2DC], edx
.text$mn:000005D0                 mov     eax, [ebp+var_270]
.text$mn:000005D6                 mov     [ebp+var_2EC], eax
.text$mn:000005DC                 mov     [ebp+var_2E8], 0
.text$mn:000005E6                 mov     ecx, [ebp+var_268]
.text$mn:000005EC                 mov     edx, [ecx+24h]
.text$mn:000005EF                 mov     [ebp+var_2D4], edx
.text$mn:000005F5                 mov     eax, [ebp+var_2A0]
.text$mn:000005FB                 mov     [ebp+var_2D0], eax
.text$mn:00000601                 lea     ecx, [ebp+lParam]
.text$mn:00000607                 push    ecx             ; lParam
.text$mn:00000608                 push    0               ; wParam
.text$mn:0000060A                 push    104Dh           ; Msg
.text$mn:0000060F                 mov     edx, [ebp+var_26C]
.text$mn:00000615                 mov     eax, [edx+0Ch]
.text$mn:00000618                 push    eax             ; hWnd
.text$mn:00000619                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000061F                 movzx   ecx, [ebp+var_261]
.text$mn:00000626                 test    ecx, ecx
.text$mn:00000628                 jz      short loc_672
.text$mn:0000062A                 mov     [ebp+var_31C], 1
.text$mn:00000634                 mov     ecx, [ebp+var_268]
.text$mn:0000063A                 add     ecx, 8
.text$mn:0000063D                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000642                 push    eax             ; pszPath
.text$mn:00000643                 call    dword ptr ds:__imp__PathFindExtensionW@4 ; PathFindExtensionW(x)
.text$mn:00000649                 mov     [ebp+var_310], eax
.text$mn:0000064F                 lea     edx, [ebp+var_324]
.text$mn:00000655                 push    edx             ; lParam
.text$mn:00000656                 mov     eax, [ebp+var_270]
.text$mn:0000065C                 push    eax             ; wParam
.text$mn:0000065D                 push    1074h           ; Msg
.text$mn:00000662                 mov     ecx, [ebp+var_26C]
.text$mn:00000668                 mov     edx, [ecx+0Ch]
.text$mn:0000066B                 push    edx             ; hWnd
.text$mn:0000066C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000672
.text$mn:00000672 loc_672:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+394j
.text$mn:00000672                 jmp     loc_489
.text$mn:00000677 ; ---------------------------------------------------------------------------
.text$mn:00000677
.text$mn:00000677 loc_677:                                ; CODE XREF: VerticalFileSwitcherListView::initList(void)+210j
.text$mn:00000677                 mov     [ebp+var_348], 3
.text$mn:00000681                 mov     [ebp+var_34C], 3
.text$mn:0000068B                 lea     eax, [ebp+var_358]
.text$mn:00000691                 push    eax             ; lParam
.text$mn:00000692                 mov     ecx, [ebp+var_2A4]
.text$mn:00000698                 push    ecx             ; wParam
.text$mn:00000699                 push    102Bh           ; Msg
.text$mn:0000069E                 mov     edx, [ebp+var_26C]
.text$mn:000006A4                 mov     eax, [edx+0Ch]
.text$mn:000006A7                 push    eax             ; hWnd
.text$mn:000006A8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006AE                 mov     byte ptr [ebp+var_4], 0
.text$mn:000006B2                 lea     ecx, [ebp+var_244]
.text$mn:000006B8                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000006BD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000006C4                 lea     ecx, [ebp+wParam] ; this
.text$mn:000006CA                 call    ??1TaskListInfo@@QAE@XZ ; TaskListInfo::~TaskListInfo(void)
.text$mn:000006CF                 mov     ecx, [ebp+var_C]
.text$mn:000006D2                 mov     large fs:0, ecx
.text$mn:000006D9                 pop     ecx
.text$mn:000006DA                 mov     ecx, [ebp+var_10]
.text$mn:000006DD                 xor     ecx, ebp
.text$mn:000006DF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000006E4                 mov     esp, ebp
.text$mn:000006E6                 pop     ebp
.text$mn:000006E7                 retn
.text$mn:000006E7 ?initList@VerticalFileSwitcherListView@@QAEXXZ endp
.text$mn:000006E7
.text$mn:000006E7 ; ---------------------------------------------------------------------------
.text$mn:000006E8                 db 0Ch dup(0CCh)
.text$mn:000006F4
.text$mn:000006F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000006F4
.text$mn:000006F4 ; Attributes: bp-based frame
.text$mn:000006F4
.text$mn:000006F4 ; int __thiscall VerticalFileSwitcherListView::getBufferInfoFromIndex(VerticalFileSwitcherListView *this, int, int *)
.text$mn:000006F4                 public ?getBufferInfoFromIndex@VerticalFileSwitcherListView@@QBEHHAAH@Z
.text$mn:000006F4 ?getBufferInfoFromIndex@VerticalFileSwitcherListView@@QBEHHAAH@Z proc near
.text$mn:000006F4
.text$mn:000006F4 lParam          = dword ptr -40h
.text$mn:000006F4 var_3C          = dword ptr -3Ch
.text$mn:000006F4 var_20          = dword ptr -20h
.text$mn:000006F4 var_C           = dword ptr -0Ch
.text$mn:000006F4 var_8           = dword ptr -8
.text$mn:000006F4 var_4           = dword ptr -4
.text$mn:000006F4 arg_0           = dword ptr  8
.text$mn:000006F4 arg_4           = dword ptr  0Ch
.text$mn:000006F4
.text$mn:000006F4                 push    ebp
.text$mn:000006F5                 mov     ebp, esp
.text$mn:000006F7                 sub     esp, 40h
.text$mn:000006FA                 mov     [ebp+var_4], ecx
.text$mn:000006FD                 push    0               ; lParam
.text$mn:000006FF                 push    0               ; wParam
.text$mn:00000701                 push    1004h           ; Msg
.text$mn:00000706                 mov     eax, [ebp+var_4]
.text$mn:00000709                 mov     ecx, [eax+0Ch]
.text$mn:0000070C                 push    ecx             ; hWnd
.text$mn:0000070D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000713                 mov     [ebp+var_C], eax
.text$mn:00000716                 cmp     [ebp+arg_0], 0
.text$mn:0000071A                 jl      short loc_724
.text$mn:0000071C                 mov     edx, [ebp+arg_0]
.text$mn:0000071F                 cmp     edx, [ebp+var_C]
.text$mn:00000722                 jl      short loc_729
.text$mn:00000724
.text$mn:00000724 loc_724:                                ; CODE XREF: VerticalFileSwitcherListView::getBufferInfoFromIndex(int,int &)+26j
.text$mn:00000724                 or      eax, 0FFFFFFFFh
.text$mn:00000727                 jmp     short loc_764
.text$mn:00000729 ; ---------------------------------------------------------------------------
.text$mn:00000729
.text$mn:00000729 loc_729:                                ; CODE XREF: VerticalFileSwitcherListView::getBufferInfoFromIndex(int,int &)+2Ej
.text$mn:00000729                 mov     [ebp+lParam], 4
.text$mn:00000730                 mov     eax, [ebp+arg_0]
.text$mn:00000733                 mov     [ebp+var_3C], eax
.text$mn:00000736                 lea     ecx, [ebp+lParam]
.text$mn:00000739                 push    ecx             ; lParam
.text$mn:0000073A                 push    0               ; wParam
.text$mn:0000073C                 push    104Bh           ; Msg
.text$mn:00000741                 mov     edx, [ebp+var_4]
.text$mn:00000744                 mov     eax, [edx+0Ch]
.text$mn:00000747                 push    eax             ; hWnd
.text$mn:00000748                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000074E                 mov     ecx, [ebp+var_20]
.text$mn:00000751                 mov     [ebp+var_8], ecx
.text$mn:00000754                 mov     edx, [ebp+arg_4]
.text$mn:00000757                 mov     eax, [ebp+var_8]
.text$mn:0000075A                 mov     ecx, [eax]
.text$mn:0000075C                 mov     [edx], ecx
.text$mn:0000075E                 mov     edx, [ebp+var_8]
.text$mn:00000761                 mov     eax, [edx+28h]
.text$mn:00000764
.text$mn:00000764 loc_764:                                ; CODE XREF: VerticalFileSwitcherListView::getBufferInfoFromIndex(int,int &)+33j
.text$mn:00000764                 mov     esp, ebp
.text$mn:00000766                 pop     ebp
.text$mn:00000767                 retn    8
.text$mn:00000767 ?getBufferInfoFromIndex@VerticalFileSwitcherListView@@QBEHHAAH@Z endp
.text$mn:00000767
.text$mn:00000767 ; ---------------------------------------------------------------------------
.text$mn:0000076A                 db 0Ah dup(0CCh)
.text$mn:00000774
.text$mn:00000774 ; =============== S U B R O U T I N E =======================================
.text$mn:00000774
.text$mn:00000774 ; Attributes: bp-based frame
.text$mn:00000774
.text$mn:00000774 ; int __thiscall VerticalFileSwitcherListView::newItem(VerticalFileSwitcherListView *this, int, int)
.text$mn:00000774                 public ?newItem@VerticalFileSwitcherListView@@QAEHHH@Z
.text$mn:00000774 ?newItem@VerticalFileSwitcherListView@@QAEHHH@Z proc near
.text$mn:00000774                                         ; CODE XREF: VerticalFileSwitcherListView::activateItem(int,int)+71p
.text$mn:00000774
.text$mn:00000774 var_8           = dword ptr -8
.text$mn:00000774 var_4           = dword ptr -4
.text$mn:00000774 arg_0           = dword ptr  8
.text$mn:00000774 arg_4           = dword ptr  0Ch
.text$mn:00000774
.text$mn:00000774                 push    ebp
.text$mn:00000775                 mov     ebp, esp
.text$mn:00000777                 sub     esp, 8
.text$mn:0000077A                 mov     [ebp+var_8], ecx
.text$mn:0000077D                 mov     eax, [ebp+arg_4]
.text$mn:00000780                 push    eax             ; int
.text$mn:00000781                 mov     ecx, [ebp+arg_0]
.text$mn:00000784                 push    ecx             ; int
.text$mn:00000785                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000788                 call    ?find@VerticalFileSwitcherListView@@IBEHHH@Z ; VerticalFileSwitcherListView::find(int,int)
.text$mn:0000078D                 mov     [ebp+var_4], eax
.text$mn:00000790                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000794                 jnz     short loc_7A9
.text$mn:00000796                 mov     edx, [ebp+arg_4]
.text$mn:00000799                 push    edx             ; int
.text$mn:0000079A                 mov     eax, [ebp+arg_0]
.text$mn:0000079D                 push    eax             ; int
.text$mn:0000079E                 mov     ecx, [ebp+var_8] ; this
.text$mn:000007A1                 call    ?add@VerticalFileSwitcherListView@@IAEHHH@Z ; VerticalFileSwitcherListView::add(int,int)
.text$mn:000007A6                 mov     [ebp+var_4], eax
.text$mn:000007A9
.text$mn:000007A9 loc_7A9:                                ; CODE XREF: VerticalFileSwitcherListView::newItem(int,int)+20j
.text$mn:000007A9                 mov     eax, [ebp+var_4]
.text$mn:000007AC                 mov     esp, ebp
.text$mn:000007AE                 pop     ebp
.text$mn:000007AF                 retn    8
.text$mn:000007AF ?newItem@VerticalFileSwitcherListView@@QAEHHH@Z endp
.text$mn:000007AF
.text$mn:000007AF ; ---------------------------------------------------------------------------
.text$mn:000007B2                 align 4
.text$mn:000007B4
.text$mn:000007B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000007B4
.text$mn:000007B4 ; Attributes: bp-based frame
.text$mn:000007B4
.text$mn:000007B4 ; int __thiscall VerticalFileSwitcherListView::closeItem(VerticalFileSwitcherListView *this, int, int)
.text$mn:000007B4                 public ?closeItem@VerticalFileSwitcherListView@@QAEHHH@Z
.text$mn:000007B4 ?closeItem@VerticalFileSwitcherListView@@QAEHHH@Z proc near
.text$mn:000007B4
.text$mn:000007B4 var_8           = dword ptr -8
.text$mn:000007B4 var_4           = dword ptr -4
.text$mn:000007B4 arg_0           = dword ptr  8
.text$mn:000007B4 arg_4           = dword ptr  0Ch
.text$mn:000007B4
.text$mn:000007B4                 push    ebp
.text$mn:000007B5                 mov     ebp, esp
.text$mn:000007B7                 sub     esp, 8
.text$mn:000007BA                 mov     [ebp+var_8], ecx
.text$mn:000007BD                 mov     eax, [ebp+arg_4]
.text$mn:000007C0                 push    eax             ; int
.text$mn:000007C1                 mov     ecx, [ebp+arg_0]
.text$mn:000007C4                 push    ecx             ; int
.text$mn:000007C5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000007C8                 call    ?find@VerticalFileSwitcherListView@@IBEHHH@Z ; VerticalFileSwitcherListView::find(int,int)
.text$mn:000007CD                 mov     [ebp+var_4], eax
.text$mn:000007D0                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007D4                 jz      short loc_7E2
.text$mn:000007D6                 mov     edx, [ebp+var_4]
.text$mn:000007D9                 push    edx             ; int
.text$mn:000007DA                 mov     ecx, [ebp+var_8] ; this
.text$mn:000007DD                 call    ?remove@VerticalFileSwitcherListView@@IAEXH@Z ; VerticalFileSwitcherListView::remove(int)
.text$mn:000007E2
.text$mn:000007E2 loc_7E2:                                ; CODE XREF: VerticalFileSwitcherListView::closeItem(int,int)+20j
.text$mn:000007E2                 mov     eax, [ebp+var_4]
.text$mn:000007E5                 mov     esp, ebp
.text$mn:000007E7                 pop     ebp
.text$mn:000007E8                 retn    8
.text$mn:000007E8 ?closeItem@VerticalFileSwitcherListView@@QAEHHH@Z endp
.text$mn:000007E8
.text$mn:000007E8 ; ---------------------------------------------------------------------------
.text$mn:000007EB                 db 9 dup(0CCh)
.text$mn:000007F4
.text$mn:000007F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000007F4
.text$mn:000007F4 ; Attributes: bp-based frame
.text$mn:000007F4
.text$mn:000007F4 ; void __thiscall VerticalFileSwitcherListView::activateItem(VerticalFileSwitcherListView *this, int, int)
.text$mn:000007F4                 public ?activateItem@VerticalFileSwitcherListView@@QAEXHH@Z
.text$mn:000007F4 ?activateItem@VerticalFileSwitcherListView@@QAEXHH@Z proc near
.text$mn:000007F4
.text$mn:000007F4 var_78          = dword ptr -78h
.text$mn:000007F4 var_6C          = dword ptr -6Ch
.text$mn:000007F4 var_68          = dword ptr -68h
.text$mn:000007F4 lParam          = dword ptr -44h
.text$mn:000007F4 var_38          = dword ptr -38h
.text$mn:000007F4 var_34          = dword ptr -34h
.text$mn:000007F4 var_10          = dword ptr -10h
.text$mn:000007F4 var_C           = dword ptr -0Ch
.text$mn:000007F4 var_8           = dword ptr -8
.text$mn:000007F4 wParam          = dword ptr -4
.text$mn:000007F4 arg_0           = dword ptr  8
.text$mn:000007F4 arg_4           = dword ptr  0Ch
.text$mn:000007F4
.text$mn:000007F4                 push    ebp
.text$mn:000007F5                 mov     ebp, esp
.text$mn:000007F7                 sub     esp, 78h
.text$mn:000007FA                 mov     [ebp+var_8], ecx
.text$mn:000007FD                 push    0               ; lParam
.text$mn:000007FF                 push    0               ; wParam
.text$mn:00000801                 push    1004h           ; Msg
.text$mn:00000806                 mov     eax, [ebp+var_8]
.text$mn:00000809                 mov     ecx, [eax+0Ch]
.text$mn:0000080C                 push    ecx             ; hWnd
.text$mn:0000080D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000813                 mov     [ebp+var_C], eax
.text$mn:00000816                 mov     [ebp+wParam], 0
.text$mn:0000081D                 jmp     short loc_828
.text$mn:0000081F ; ---------------------------------------------------------------------------
.text$mn:0000081F
.text$mn:0000081F loc_81F:                                ; CODE XREF: VerticalFileSwitcherListView::activateItem(int,int)+64j
.text$mn:0000081F                 mov     edx, [ebp+wParam]
.text$mn:00000822                 add     edx, 1
.text$mn:00000825                 mov     [ebp+wParam], edx
.text$mn:00000828
.text$mn:00000828 loc_828:                                ; CODE XREF: VerticalFileSwitcherListView::activateItem(int,int)+29j
.text$mn:00000828                 mov     eax, [ebp+wParam]
.text$mn:0000082B                 cmp     eax, [ebp+var_C]
.text$mn:0000082E                 jge     short loc_85A
.text$mn:00000830                 mov     [ebp+var_34], 3
.text$mn:00000837                 mov     [ebp+var_38], 0
.text$mn:0000083E                 lea     ecx, [ebp+lParam]
.text$mn:00000841                 push    ecx             ; lParam
.text$mn:00000842                 mov     edx, [ebp+wParam]
.text$mn:00000845                 push    edx             ; wParam
.text$mn:00000846                 push    102Bh           ; Msg
.text$mn:0000084B                 mov     eax, [ebp+var_8]
.text$mn:0000084E                 mov     ecx, [eax+0Ch]
.text$mn:00000851                 push    ecx             ; hWnd
.text$mn:00000852                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000858                 jmp     short loc_81F
.text$mn:0000085A ; ---------------------------------------------------------------------------
.text$mn:0000085A
.text$mn:0000085A loc_85A:                                ; CODE XREF: VerticalFileSwitcherListView::activateItem(int,int)+3Aj
.text$mn:0000085A                 mov     edx, [ebp+arg_4]
.text$mn:0000085D                 push    edx             ; int
.text$mn:0000085E                 mov     eax, [ebp+arg_0]
.text$mn:00000861                 push    eax             ; int
.text$mn:00000862                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000865                 call    ?newItem@VerticalFileSwitcherListView@@QAEHHH@Z ; VerticalFileSwitcherListView::newItem(int,int)
.text$mn:0000086A                 mov     [ebp+var_10], eax
.text$mn:0000086D                 mov     [ebp+var_68], 3
.text$mn:00000874                 mov     [ebp+var_6C], 3
.text$mn:0000087B                 lea     ecx, [ebp+var_78]
.text$mn:0000087E                 push    ecx             ; lParam
.text$mn:0000087F                 mov     edx, [ebp+var_10]
.text$mn:00000882                 push    edx             ; wParam
.text$mn:00000883                 push    102Bh           ; Msg
.text$mn:00000888                 mov     eax, [ebp+var_8]
.text$mn:0000088B                 mov     ecx, [eax+0Ch]
.text$mn:0000088E                 push    ecx             ; hWnd
.text$mn:0000088F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000895                 mov     esp, ebp
.text$mn:00000897                 pop     ebp
.text$mn:00000898                 retn    8
.text$mn:00000898 ?activateItem@VerticalFileSwitcherListView@@QAEXHH@Z endp
.text$mn:00000898
.text$mn:00000898 ; ---------------------------------------------------------------------------
.text$mn:0000089B                 db 9 dup(0CCh)
.text$mn:000008A4
.text$mn:000008A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008A4
.text$mn:000008A4 ; Attributes: bp-based frame
.text$mn:000008A4
.text$mn:000008A4 ; void __thiscall VerticalFileSwitcherListView::setItemIconStatus(VerticalFileSwitcherListView *this, int)
.text$mn:000008A4                 public ?setItemIconStatus@VerticalFileSwitcherListView@@QAEXH@Z
.text$mn:000008A4 ?setItemIconStatus@VerticalFileSwitcherListView@@QAEXH@Z proc near
.text$mn:000008A4
.text$mn:000008A4 var_298         = dword ptr -298h
.text$mn:000008A4 var_290         = dword ptr -290h
.text$mn:000008A4 var_284         = dword ptr -284h
.text$mn:000008A4 lParam          = dword ptr -264h
.text$mn:000008A4 var_260         = dword ptr -260h
.text$mn:000008A4 var_25C         = dword ptr -25Ch
.text$mn:000008A4 var_250         = dword ptr -250h
.text$mn:000008A4 var_248         = dword ptr -248h
.text$mn:000008A4 var_244         = dword ptr -244h
.text$mn:000008A4 var_230         = dword ptr -230h
.text$mn:000008A4 var_22C         = dword ptr -22Ch
.text$mn:000008A4 var_228         = dword ptr -228h
.text$mn:000008A4 var_224         = dword ptr -224h
.text$mn:000008A4 var_220         = dword ptr -220h
.text$mn:000008A4 var_21C         = dword ptr -21Ch
.text$mn:000008A4 var_218         = dword ptr -218h
.text$mn:000008A4 wParam          = dword ptr -214h
.text$mn:000008A4 var_20D         = byte ptr -20Dh
.text$mn:000008A4 String1         = word ptr -20Ch
.text$mn:000008A4 var_4           = dword ptr -4
.text$mn:000008A4 arg_0           = dword ptr  8
.text$mn:000008A4
.text$mn:000008A4                 push    ebp
.text$mn:000008A5                 mov     ebp, esp
.text$mn:000008A7                 sub     esp, 298h
.text$mn:000008AD                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008B2                 xor     eax, ebp
.text$mn:000008B4                 mov     [ebp+var_4], eax
.text$mn:000008B7                 mov     [ebp+var_21C], ecx
.text$mn:000008BD                 mov     eax, [ebp+arg_0]
.text$mn:000008C0                 mov     [ebp+var_218], eax
.text$mn:000008C6                 mov     ecx, [ebp+var_218] ; this
.text$mn:000008CC                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:000008D1                 push    eax             ; pszPath
.text$mn:000008D2                 call    dword ptr ds:__imp__PathFindFileNameW@4 ; PathFindFileNameW(x)
.text$mn:000008D8                 push    eax             ; lpString2
.text$mn:000008D9                 lea     ecx, [ebp+String1]
.text$mn:000008DF                 push    ecx             ; lpString1
.text$mn:000008E0                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:000008E6                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000008EB                 mov     ecx, eax        ; this
.text$mn:000008ED                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000008F2                 movzx   edx, byte ptr [eax+694h]
.text$mn:000008F9                 test    edx, edx
.text$mn:000008FB                 jnz     short loc_909
.text$mn:000008FD                 mov     [ebp+var_224], 1
.text$mn:00000907                 jmp     short loc_913
.text$mn:00000909 ; ---------------------------------------------------------------------------
.text$mn:00000909
.text$mn:00000909 loc_909:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+57j
.text$mn:00000909                 mov     [ebp+var_224], 0
.text$mn:00000913
.text$mn:00000913 loc_913:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+63j
.text$mn:00000913                 mov     al, byte ptr [ebp+var_224]
.text$mn:00000919                 mov     [ebp+var_20D], al
.text$mn:0000091F                 movzx   ecx, [ebp+var_20D]
.text$mn:00000926                 test    ecx, ecx
.text$mn:00000928                 jz      short loc_937
.text$mn:0000092A                 lea     edx, [ebp+String1]
.text$mn:00000930                 push    edx             ; pszPath
.text$mn:00000931                 call    dword ptr ds:__imp__PathRemoveExtensionW@4 ; PathRemoveExtensionW(x)
.text$mn:00000937
.text$mn:00000937 loc_937:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+84j
.text$mn:00000937                 lea     eax, [ebp+String1]
.text$mn:0000093D                 mov     [ebp+var_250], eax
.text$mn:00000943                 mov     [ebp+var_25C], 0
.text$mn:0000094D                 mov     ecx, [ebp+var_218] ; this
.text$mn:00000953                 call    ?getUserReadOnly@Buffer@@QBE_NXZ ; Buffer::getUserReadOnly(void)
.text$mn:00000958                 movzx   ecx, al
.text$mn:0000095B                 test    ecx, ecx
.text$mn:0000095D                 jnz     short loc_9A7
.text$mn:0000095F                 mov     ecx, [ebp+var_218] ; this
.text$mn:00000965                 call    ?getFileReadOnly@Buffer@@QBE_NXZ ; Buffer::getFileReadOnly(void)
.text$mn:0000096A                 movzx   edx, al
.text$mn:0000096D                 test    edx, edx
.text$mn:0000096F                 jnz     short loc_9A7
.text$mn:00000971                 mov     ecx, [ebp+var_218] ; this
.text$mn:00000977                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:0000097C                 movzx   eax, al
.text$mn:0000097F                 test    eax, eax
.text$mn:00000981                 jz      short loc_98F
.text$mn:00000983                 mov     [ebp+var_220], 1
.text$mn:0000098D                 jmp     short loc_999
.text$mn:0000098F ; ---------------------------------------------------------------------------
.text$mn:0000098F
.text$mn:0000098F loc_98F:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+DDj
.text$mn:0000098F                 mov     [ebp+var_220], 0
.text$mn:00000999
.text$mn:00000999 loc_999:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+E9j
.text$mn:00000999                 mov     ecx, [ebp+var_220]
.text$mn:0000099F                 mov     [ebp+var_228], ecx
.text$mn:000009A5                 jmp     short loc_9B1
.text$mn:000009A7 ; ---------------------------------------------------------------------------
.text$mn:000009A7
.text$mn:000009A7 loc_9A7:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+B9j
.text$mn:000009A7                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+CBj
.text$mn:000009A7                 mov     [ebp+var_228], 2
.text$mn:000009B1
.text$mn:000009B1 loc_9B1:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+101j
.text$mn:000009B1                 mov     edx, [ebp+var_228]
.text$mn:000009B7                 mov     [ebp+var_248], edx
.text$mn:000009BD                 push    0               ; lParam
.text$mn:000009BF                 push    0               ; wParam
.text$mn:000009C1                 push    1004h           ; Msg
.text$mn:000009C6                 mov     eax, [ebp+var_21C]
.text$mn:000009CC                 mov     ecx, [eax+0Ch]
.text$mn:000009CF                 push    ecx             ; hWnd
.text$mn:000009D0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000009D6                 mov     [ebp+var_230], eax
.text$mn:000009DC                 mov     [ebp+wParam], 0
.text$mn:000009E6                 jmp     short loc_9F7
.text$mn:000009E8 ; ---------------------------------------------------------------------------
.text$mn:000009E8
.text$mn:000009E8 loc_9E8:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int):loc_ACFj
.text$mn:000009E8                 mov     edx, [ebp+wParam]
.text$mn:000009EE                 add     edx, 1
.text$mn:000009F1                 mov     [ebp+wParam], edx
.text$mn:000009F7
.text$mn:000009F7 loc_9F7:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+142j
.text$mn:000009F7                 mov     eax, [ebp+wParam]
.text$mn:000009FD                 cmp     eax, [ebp+var_230]
.text$mn:00000A03                 jge     loc_AD4
.text$mn:00000A09                 mov     [ebp+lParam], 4
.text$mn:00000A13                 mov     ecx, [ebp+wParam]
.text$mn:00000A19                 mov     [ebp+var_260], ecx
.text$mn:00000A1F                 lea     edx, [ebp+lParam]
.text$mn:00000A25                 push    edx             ; lParam
.text$mn:00000A26                 push    0               ; wParam
.text$mn:00000A28                 push    104Bh           ; Msg
.text$mn:00000A2D                 mov     eax, [ebp+var_21C]
.text$mn:00000A33                 mov     ecx, [eax+0Ch]
.text$mn:00000A36                 push    ecx             ; hWnd
.text$mn:00000A37                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000A3D                 mov     edx, [ebp+var_244]
.text$mn:00000A43                 mov     [ebp+var_22C], edx
.text$mn:00000A49                 mov     eax, [ebp+var_22C]
.text$mn:00000A4F                 mov     ecx, [eax+28h]
.text$mn:00000A52                 cmp     ecx, [ebp+arg_0]
.text$mn:00000A55                 jnz     short loc_ACF
.text$mn:00000A57                 mov     [ebp+lParam], 3
.text$mn:00000A61                 lea     edx, [ebp+lParam]
.text$mn:00000A67                 push    edx             ; lParam
.text$mn:00000A68                 push    0               ; wParam
.text$mn:00000A6A                 push    104Ch           ; Msg
.text$mn:00000A6F                 mov     eax, [ebp+var_21C]
.text$mn:00000A75                 mov     ecx, [eax+0Ch]
.text$mn:00000A78                 push    ecx             ; hWnd
.text$mn:00000A79                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000A7F                 movzx   edx, [ebp+var_20D]
.text$mn:00000A86                 test    edx, edx
.text$mn:00000A88                 jz      short loc_ACF
.text$mn:00000A8A                 mov     [ebp+var_290], 1
.text$mn:00000A94                 mov     ecx, [ebp+var_218] ; this
.text$mn:00000A9A                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00000A9F                 push    eax             ; pszPath
.text$mn:00000AA0                 call    dword ptr ds:__imp__PathFindExtensionW@4 ; PathFindExtensionW(x)
.text$mn:00000AA6                 mov     [ebp+var_284], eax
.text$mn:00000AAC                 lea     eax, [ebp+var_298]
.text$mn:00000AB2                 push    eax             ; lParam
.text$mn:00000AB3                 mov     ecx, [ebp+wParam]
.text$mn:00000AB9                 push    ecx             ; wParam
.text$mn:00000ABA                 push    1074h           ; Msg
.text$mn:00000ABF                 mov     edx, [ebp+var_21C]
.text$mn:00000AC5                 mov     eax, [edx+0Ch]
.text$mn:00000AC8                 push    eax             ; hWnd
.text$mn:00000AC9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000ACF
.text$mn:00000ACF loc_ACF:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+1B1j
.text$mn:00000ACF                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+1E4j
.text$mn:00000ACF                 jmp     loc_9E8
.text$mn:00000AD4 ; ---------------------------------------------------------------------------
.text$mn:00000AD4
.text$mn:00000AD4 loc_AD4:                                ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+15Fj
.text$mn:00000AD4                 mov     ecx, [ebp+var_4]
.text$mn:00000AD7                 xor     ecx, ebp
.text$mn:00000AD9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000ADE                 mov     esp, ebp
.text$mn:00000AE0                 pop     ebp
.text$mn:00000AE1                 retn    4
.text$mn:00000AE1 ?setItemIconStatus@VerticalFileSwitcherListView@@QAEXH@Z endp
.text$mn:00000AE1
.text$mn:00000AE4
.text$mn:00000AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AE4
.text$mn:00000AE4 ; Attributes: bp-based frame
.text$mn:00000AE4
.text$mn:00000AE4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall VerticalFileSwitcherListView::getFullFilePath(unsigned int)const
.text$mn:00000AE4                 public ?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$mn:00000AE4 ?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z proc near
.text$mn:00000AE4
.text$mn:00000AE4 lParam          = dword ptr -50h
.text$mn:00000AE4 var_4C          = dword ptr -4Ch
.text$mn:00000AE4 var_30          = dword ptr -30h
.text$mn:00000AE4 var_1C          = dword ptr -1Ch
.text$mn:00000AE4 var_18          = dword ptr -18h
.text$mn:00000AE4 var_14          = dword ptr -14h
.text$mn:00000AE4 var_10          = dword ptr -10h
.text$mn:00000AE4 var_C           = dword ptr -0Ch
.text$mn:00000AE4 var_4           = dword ptr -4
.text$mn:00000AE4 arg_0           = dword ptr  8
.text$mn:00000AE4 arg_4           = dword ptr  0Ch
.text$mn:00000AE4
.text$mn:00000AE4                 push    ebp
.text$mn:00000AE5                 mov     ebp, esp
.text$mn:00000AE7                 push    0FFFFFFFFh
.text$mn:00000AE9                 push    offset __ehhandler$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$mn:00000AEE                 mov     eax, large fs:0
.text$mn:00000AF4                 push    eax
.text$mn:00000AF5                 sub     esp, 44h
.text$mn:00000AF8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AFD                 xor     eax, ebp
.text$mn:00000AFF                 push    eax
.text$mn:00000B00                 lea     eax, [ebp+var_C]
.text$mn:00000B03                 mov     large fs:0, eax
.text$mn:00000B09                 mov     [ebp+var_14], ecx
.text$mn:00000B0C                 mov     [ebp+var_10], 0
.text$mn:00000B13                 push    0               ; lParam
.text$mn:00000B15                 push    0               ; wParam
.text$mn:00000B17                 push    1004h           ; Msg
.text$mn:00000B1C                 mov     eax, [ebp+var_14]
.text$mn:00000B1F                 mov     ecx, [eax+0Ch]
.text$mn:00000B22                 push    ecx             ; hWnd
.text$mn:00000B23                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000B29                 mov     [ebp+var_18], eax
.text$mn:00000B2C                 cmp     [ebp+arg_4], 0
.text$mn:00000B30                 jb      short loc_B3A
.text$mn:00000B32                 mov     edx, [ebp+arg_4]
.text$mn:00000B35                 cmp     edx, [ebp+var_18]
.text$mn:00000B38                 jbe     short loc_B5C
.text$mn:00000B3A
.text$mn:00000B3A loc_B3A:                                ; CODE XREF: VerticalFileSwitcherListView::getFullFilePath(uint)+4Cj
.text$mn:00000B3A                 push    offset $SG129614 ; Str
.text$mn:00000B3F                 mov     ecx, [ebp+arg_0]
.text$mn:00000B42                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000B47                 mov     [ebp+var_4], 0
.text$mn:00000B4E                 mov     eax, [ebp+var_10]
.text$mn:00000B51                 or      eax, 1
.text$mn:00000B54                 mov     [ebp+var_10], eax
.text$mn:00000B57                 mov     eax, [ebp+arg_0]
.text$mn:00000B5A                 jmp     short loc_BA9
.text$mn:00000B5C ; ---------------------------------------------------------------------------
.text$mn:00000B5C
.text$mn:00000B5C loc_B5C:                                ; CODE XREF: VerticalFileSwitcherListView::getFullFilePath(uint)+54j
.text$mn:00000B5C                 mov     [ebp+lParam], 4
.text$mn:00000B63                 mov     ecx, [ebp+arg_4]
.text$mn:00000B66                 mov     [ebp+var_4C], ecx
.text$mn:00000B69                 lea     edx, [ebp+lParam]
.text$mn:00000B6C                 push    edx             ; lParam
.text$mn:00000B6D                 push    0               ; wParam
.text$mn:00000B6F                 push    104Bh           ; Msg
.text$mn:00000B74                 mov     eax, [ebp+var_14]
.text$mn:00000B77                 mov     ecx, [eax+0Ch]
.text$mn:00000B7A                 push    ecx             ; hWnd
.text$mn:00000B7B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000B81                 mov     edx, [ebp+var_30]
.text$mn:00000B84                 mov     [ebp+var_1C], edx
.text$mn:00000B87                 mov     eax, [ebp+var_1C]
.text$mn:00000B8A                 add     eax, 8
.text$mn:00000B8D                 push    eax
.text$mn:00000B8E                 mov     ecx, [ebp+arg_0]
.text$mn:00000B91                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000B96                 mov     [ebp+var_4], 0
.text$mn:00000B9D                 mov     ecx, [ebp+var_10]
.text$mn:00000BA0                 or      ecx, 1
.text$mn:00000BA3                 mov     [ebp+var_10], ecx
.text$mn:00000BA6                 mov     eax, [ebp+arg_0]
.text$mn:00000BA9
.text$mn:00000BA9 loc_BA9:                                ; CODE XREF: VerticalFileSwitcherListView::getFullFilePath(uint)+76j
.text$mn:00000BA9                 mov     ecx, [ebp+var_C]
.text$mn:00000BAC                 mov     large fs:0, ecx
.text$mn:00000BB3                 pop     ecx
.text$mn:00000BB4                 mov     esp, ebp
.text$mn:00000BB6                 pop     ebp
.text$mn:00000BB7                 retn    8
.text$mn:00000BB7 ?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z endp
.text$mn:00000BB7
.text$mn:00000BB7 ; ---------------------------------------------------------------------------
.text$mn:00000BBA                 db 0Ah dup(0CCh)
.text$mn:00000BC4
.text$mn:00000BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BC4
.text$mn:00000BC4 ; Attributes: bp-based frame
.text$mn:00000BC4
.text$mn:00000BC4 ; void __thiscall VerticalFileSwitcherListView::insertColumn(VerticalFileSwitcherListView *this, const wchar_t *, int, int)
.text$mn:00000BC4                 public ?insertColumn@VerticalFileSwitcherListView@@QAEXPB_WHH@Z
.text$mn:00000BC4 ?insertColumn@VerticalFileSwitcherListView@@QAEXPB_WHH@Z proc near
.text$mn:00000BC4                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+179p
.text$mn:00000BC4                                         ; VerticalFileSwitcherListView::initList(void)+1C4p
.text$mn:00000BC4
.text$mn:00000BC4 lParam          = dword ptr -24h
.text$mn:00000BC4 var_1C          = dword ptr -1Ch
.text$mn:00000BC4 var_18          = dword ptr -18h
.text$mn:00000BC4 var_4           = dword ptr -4
.text$mn:00000BC4 arg_0           = dword ptr  8
.text$mn:00000BC4 arg_4           = dword ptr  0Ch
.text$mn:00000BC4 wParam          = dword ptr  10h
.text$mn:00000BC4
.text$mn:00000BC4                 push    ebp
.text$mn:00000BC5                 mov     ebp, esp
.text$mn:00000BC7                 sub     esp, 24h
.text$mn:00000BCA                 mov     [ebp+var_4], ecx
.text$mn:00000BCD                 mov     [ebp+lParam], 6
.text$mn:00000BD4                 mov     eax, [ebp+arg_4]
.text$mn:00000BD7                 mov     [ebp+var_1C], eax
.text$mn:00000BDA                 mov     ecx, [ebp+arg_0]
.text$mn:00000BDD                 mov     [ebp+var_18], ecx
.text$mn:00000BE0                 lea     edx, [ebp+lParam]
.text$mn:00000BE3                 push    edx             ; lParam
.text$mn:00000BE4                 mov     eax, [ebp+wParam]
.text$mn:00000BE7                 push    eax             ; wParam
.text$mn:00000BE8                 push    1061h           ; Msg
.text$mn:00000BED                 mov     ecx, [ebp+var_4]
.text$mn:00000BF0                 mov     edx, [ecx+0Ch]
.text$mn:00000BF3                 push    edx             ; hWnd
.text$mn:00000BF4                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000BFA                 mov     esp, ebp
.text$mn:00000BFC                 pop     ebp
.text$mn:00000BFD                 retn    0Ch
.text$mn:00000BFD ?insertColumn@VerticalFileSwitcherListView@@QAEXPB_WHH@Z endp
.text$mn:00000BFD
.text$mn:00000BFD ; ---------------------------------------------------------------------------
.text$mn:00000C00                 db 4 dup(0CCh)
.text$mn:00000C04
.text$mn:00000C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C04
.text$mn:00000C04 ; Attributes: bp-based frame
.text$mn:00000C04
.text$mn:00000C04 ; void __thiscall VerticalFileSwitcherListView::resizeColumns(VerticalFileSwitcherListView *this, int)
.text$mn:00000C04                 public ?resizeColumns@VerticalFileSwitcherListView@@QAEXH@Z
.text$mn:00000C04 ?resizeColumns@VerticalFileSwitcherListView@@QAEXH@Z proc near
.text$mn:00000C04
.text$mn:00000C04 var_10          = dword ptr -10h
.text$mn:00000C04 var_C           = dword ptr -0Ch
.text$mn:00000C04 var_8           = dword ptr -8
.text$mn:00000C04 var_1           = byte ptr -1
.text$mn:00000C04 arg_0           = dword ptr  8
.text$mn:00000C04
.text$mn:00000C04                 push    ebp
.text$mn:00000C05                 mov     ebp, esp
.text$mn:00000C07                 sub     esp, 10h
.text$mn:00000C0A                 mov     [ebp+var_8], ecx
.text$mn:00000C0D                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000C12                 mov     [ebp+var_10], eax
.text$mn:00000C15                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C18                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00000C1D                 movzx   eax, byte ptr [eax+694h]
.text$mn:00000C24                 test    eax, eax
.text$mn:00000C26                 jnz     short loc_C31
.text$mn:00000C28                 mov     [ebp+var_C], 1
.text$mn:00000C2F                 jmp     short loc_C38
.text$mn:00000C31 ; ---------------------------------------------------------------------------
.text$mn:00000C31
.text$mn:00000C31 loc_C31:                                ; CODE XREF: VerticalFileSwitcherListView::resizeColumns(int)+22j
.text$mn:00000C31                 mov     [ebp+var_C], 0
.text$mn:00000C38
.text$mn:00000C38 loc_C38:                                ; CODE XREF: VerticalFileSwitcherListView::resizeColumns(int)+2Bj
.text$mn:00000C38                 mov     cl, byte ptr [ebp+var_C]
.text$mn:00000C3B                 mov     [ebp+var_1], cl
.text$mn:00000C3E                 movzx   edx, [ebp+var_1]
.text$mn:00000C42                 test    edx, edx
.text$mn:00000C44                 jz      short loc_C81
.text$mn:00000C46                 mov     eax, [ebp+arg_0]
.text$mn:00000C49                 sub     eax, 32h ; '2'
.text$mn:00000C4C                 and     eax, 0FFFFh
.text$mn:00000C51                 movzx   ecx, ax
.text$mn:00000C54                 push    ecx             ; lParam
.text$mn:00000C55                 push    0               ; wParam
.text$mn:00000C57                 push    101Eh           ; Msg
.text$mn:00000C5C                 mov     edx, [ebp+var_8]
.text$mn:00000C5F                 mov     eax, [edx+0Ch]
.text$mn:00000C62                 push    eax             ; hWnd
.text$mn:00000C63                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000C69                 push    32h ; '2'       ; lParam
.text$mn:00000C6B                 push    1               ; wParam
.text$mn:00000C6D                 push    101Eh           ; Msg
.text$mn:00000C72                 mov     ecx, [ebp+var_8]
.text$mn:00000C75                 mov     edx, [ecx+0Ch]
.text$mn:00000C78                 push    edx             ; hWnd
.text$mn:00000C79                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000C7F                 jmp     short loc_CA1
.text$mn:00000C81 ; ---------------------------------------------------------------------------
.text$mn:00000C81
.text$mn:00000C81 loc_C81:                                ; CODE XREF: VerticalFileSwitcherListView::resizeColumns(int)+40j
.text$mn:00000C81                 mov     eax, [ebp+arg_0]
.text$mn:00000C84                 and     eax, 0FFFFh
.text$mn:00000C89                 movzx   ecx, ax
.text$mn:00000C8C                 push    ecx             ; lParam
.text$mn:00000C8D                 push    0               ; wParam
.text$mn:00000C8F                 push    101Eh           ; Msg
.text$mn:00000C94                 mov     edx, [ebp+var_8]
.text$mn:00000C97                 mov     eax, [edx+0Ch]
.text$mn:00000C9A                 push    eax             ; hWnd
.text$mn:00000C9B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000CA1
.text$mn:00000CA1 loc_CA1:                                ; CODE XREF: VerticalFileSwitcherListView::resizeColumns(int)+7Bj
.text$mn:00000CA1                 mov     esp, ebp
.text$mn:00000CA3                 pop     ebp
.text$mn:00000CA4                 retn    4
.text$mn:00000CA4 ?resizeColumns@VerticalFileSwitcherListView@@QAEXH@Z endp
.text$mn:00000CA4
.text$mn:00000CA4 ; ---------------------------------------------------------------------------
.text$mn:00000CA7                 db 0Dh dup(0CCh)
.text$mn:00000CB4
.text$mn:00000CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CB4
.text$mn:00000CB4 ; Attributes: bp-based frame
.text$mn:00000CB4
.text$mn:00000CB4 ; public: class std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>> __thiscall VerticalFileSwitcherListView::getSelectedFiles(bool)const
.text$mn:00000CB4                 public ?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z
.text$mn:00000CB4 ?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z proc near
.text$mn:00000CB4
.text$mn:00000CB4 lParam          = dword ptr -80h
.text$mn:00000CB4 var_7C          = dword ptr -7Ch
.text$mn:00000CB4 var_60          = dword ptr -60h
.text$mn:00000CB4 var_4C          = byte ptr -4Ch
.text$mn:00000CB4 var_3C          = byte ptr -3Ch
.text$mn:00000CB4 var_34          = dword ptr -34h
.text$mn:00000CB4 var_30          = dword ptr -30h
.text$mn:00000CB4 var_2C          = dword ptr -2Ch
.text$mn:00000CB4 var_28          = dword ptr -28h
.text$mn:00000CB4 var_24          = dword ptr -24h
.text$mn:00000CB4 var_20          = dword ptr -20h
.text$mn:00000CB4 var_1C          = dword ptr -1Ch
.text$mn:00000CB4 var_18          = dword ptr -18h
.text$mn:00000CB4 wParam          = dword ptr -14h
.text$mn:00000CB4 var_D           = byte ptr -0Dh
.text$mn:00000CB4 var_C           = dword ptr -0Ch
.text$mn:00000CB4 var_4           = dword ptr -4
.text$mn:00000CB4 arg_0           = dword ptr  8
.text$mn:00000CB4 arg_4           = byte ptr  0Ch
.text$mn:00000CB4
.text$mn:00000CB4                 push    ebp
.text$mn:00000CB5                 mov     ebp, esp
.text$mn:00000CB7                 push    0FFFFFFFFh
.text$mn:00000CB9                 push    offset __ehhandler$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z
.text$mn:00000CBE                 mov     eax, large fs:0
.text$mn:00000CC4                 push    eax
.text$mn:00000CC5                 sub     esp, 74h
.text$mn:00000CC8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000CCD                 xor     eax, ebp
.text$mn:00000CCF                 push    eax
.text$mn:00000CD0                 lea     eax, [ebp+var_C]
.text$mn:00000CD3                 mov     large fs:0, eax
.text$mn:00000CD9                 mov     [ebp+var_18], ecx
.text$mn:00000CDC                 mov     [ebp+var_30], 0
.text$mn:00000CE3                 lea     ecx, [ebp+var_4C]
.text$mn:00000CE6                 call    ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)
.text$mn:00000CEB                 mov     [ebp+var_4], 1
.text$mn:00000CF2                 push    0               ; lParam
.text$mn:00000CF4                 push    0               ; wParam
.text$mn:00000CF6                 push    1004h           ; Msg
.text$mn:00000CFB                 mov     eax, [ebp+var_18]
.text$mn:00000CFE                 mov     ecx, [eax+0Ch]
.text$mn:00000D01                 push    ecx             ; hWnd
.text$mn:00000D02                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000D08                 mov     [ebp+var_34], eax
.text$mn:00000D0B                 mov     [ebp+wParam], 0
.text$mn:00000D12                 jmp     short loc_D1D
.text$mn:00000D14 ; ---------------------------------------------------------------------------
.text$mn:00000D14
.text$mn:00000D14 loc_D14:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool):loc_DDDj
.text$mn:00000D14                 mov     edx, [ebp+wParam]
.text$mn:00000D17                 add     edx, 1
.text$mn:00000D1A                 mov     [ebp+wParam], edx
.text$mn:00000D1D
.text$mn:00000D1D loc_D1D:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+5Ej
.text$mn:00000D1D                 mov     eax, [ebp+wParam]
.text$mn:00000D20                 cmp     eax, [ebp+var_34]
.text$mn:00000D23                 jge     loc_DE2
.text$mn:00000D29                 push    2               ; lParam
.text$mn:00000D2B                 mov     ecx, [ebp+wParam]
.text$mn:00000D2E                 push    ecx             ; wParam
.text$mn:00000D2F                 push    102Ch           ; Msg
.text$mn:00000D34                 mov     edx, [ebp+var_18]
.text$mn:00000D37                 mov     eax, [edx+0Ch]
.text$mn:00000D3A                 push    eax             ; hWnd
.text$mn:00000D3B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000D41                 mov     [ebp+var_20], eax
.text$mn:00000D44                 movzx   ecx, [ebp+arg_4]
.text$mn:00000D48                 test    ecx, ecx
.text$mn:00000D4A                 jz      short loc_D6A
.text$mn:00000D4C                 cmp     [ebp+var_20], 2
.text$mn:00000D50                 jz      short loc_D5B
.text$mn:00000D52                 mov     [ebp+var_1C], 1
.text$mn:00000D59                 jmp     short loc_D62
.text$mn:00000D5B ; ---------------------------------------------------------------------------
.text$mn:00000D5B
.text$mn:00000D5B loc_D5B:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+9Cj
.text$mn:00000D5B                 mov     [ebp+var_1C], 0
.text$mn:00000D62
.text$mn:00000D62 loc_D62:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+A5j
.text$mn:00000D62                 mov     edx, [ebp+var_1C]
.text$mn:00000D65                 mov     [ebp+var_28], edx
.text$mn:00000D68                 jmp     short loc_D86
.text$mn:00000D6A ; ---------------------------------------------------------------------------
.text$mn:00000D6A
.text$mn:00000D6A loc_D6A:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+96j
.text$mn:00000D6A                 cmp     [ebp+var_20], 2
.text$mn:00000D6E                 jnz     short loc_D79
.text$mn:00000D70                 mov     [ebp+var_24], 1
.text$mn:00000D77                 jmp     short loc_D80
.text$mn:00000D79 ; ---------------------------------------------------------------------------
.text$mn:00000D79
.text$mn:00000D79 loc_D79:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+BAj
.text$mn:00000D79                 mov     [ebp+var_24], 0
.text$mn:00000D80
.text$mn:00000D80 loc_D80:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+C3j
.text$mn:00000D80                 mov     eax, [ebp+var_24]
.text$mn:00000D83                 mov     [ebp+var_28], eax
.text$mn:00000D86
.text$mn:00000D86 loc_D86:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+B4j
.text$mn:00000D86                 mov     cl, byte ptr [ebp+var_28]
.text$mn:00000D89                 mov     [ebp+var_D], cl
.text$mn:00000D8C                 movzx   edx, [ebp+var_D]
.text$mn:00000D90                 test    edx, edx
.text$mn:00000D92                 jz      short loc_DDD
.text$mn:00000D94                 mov     [ebp+lParam], 4
.text$mn:00000D9B                 mov     eax, [ebp+wParam]
.text$mn:00000D9E                 mov     [ebp+var_7C], eax
.text$mn:00000DA1                 lea     ecx, [ebp+lParam]
.text$mn:00000DA4                 push    ecx             ; lParam
.text$mn:00000DA5                 push    0               ; wParam
.text$mn:00000DA7                 push    104Bh           ; Msg
.text$mn:00000DAC                 mov     edx, [ebp+var_18]
.text$mn:00000DAF                 mov     eax, [edx+0Ch]
.text$mn:00000DB2                 push    eax             ; hWnd
.text$mn:00000DB3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000DB9                 mov     ecx, [ebp+var_60]
.text$mn:00000DBC                 mov     [ebp+var_2C], ecx
.text$mn:00000DBF                 mov     edx, [ebp+var_2C]
.text$mn:00000DC2                 mov     eax, [edx]
.text$mn:00000DC4                 push    eax             ; int
.text$mn:00000DC5                 mov     ecx, [ebp+var_2C]
.text$mn:00000DC8                 mov     edx, [ecx+28h]
.text$mn:00000DCB                 push    edx             ; int
.text$mn:00000DCC                 lea     ecx, [ebp+var_3C] ; this
.text$mn:00000DCF                 call    ??0SwitcherFileInfo@@QAE@HH@Z ; SwitcherFileInfo::SwitcherFileInfo(int,int)
.text$mn:00000DD4                 push    eax
.text$mn:00000DD5                 lea     ecx, [ebp+var_4C]
.text$mn:00000DD8                 call    ?push_back@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAUSwitcherFileInfo@@@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)
.text$mn:00000DDD
.text$mn:00000DDD loc_DDD:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+DEj
.text$mn:00000DDD                 jmp     loc_D14
.text$mn:00000DE2 ; ---------------------------------------------------------------------------
.text$mn:00000DE2
.text$mn:00000DE2 loc_DE2:                                ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+6Fj
.text$mn:00000DE2                 lea     eax, [ebp+var_4C]
.text$mn:00000DE5                 push    eax
.text$mn:00000DE6                 mov     ecx, [ebp+arg_0]
.text$mn:00000DE9                 call    ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&)
.text$mn:00000DEE                 mov     ecx, [ebp+var_30]
.text$mn:00000DF1                 or      ecx, 1
.text$mn:00000DF4                 mov     [ebp+var_30], ecx
.text$mn:00000DF7                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000DFB                 lea     ecx, [ebp+var_4C]
.text$mn:00000DFE                 call    ??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::~vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)
.text$mn:00000E03                 mov     eax, [ebp+arg_0]
.text$mn:00000E06                 mov     ecx, [ebp+var_C]
.text$mn:00000E09                 mov     large fs:0, ecx
.text$mn:00000E10                 pop     ecx
.text$mn:00000E11                 mov     esp, ebp
.text$mn:00000E13                 pop     ebp
.text$mn:00000E14                 retn    8
.text$mn:00000E14 ?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z endp
.text$mn:00000E14
.text$mn:00000E14 ; ---------------------------------------------------------------------------
.text$mn:00000E17                 db 0Dh dup(0CCh)
.text$mn:00000E24
.text$mn:00000E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E24
.text$mn:00000E24 ; Attributes: bp-based frame
.text$mn:00000E24
.text$mn:00000E24 ; void __thiscall VerticalFileSwitcherListView::reload(VerticalFileSwitcherListView *__hidden this)
.text$mn:00000E24                 public ?reload@VerticalFileSwitcherListView@@QAEXXZ
.text$mn:00000E24 ?reload@VerticalFileSwitcherListView@@QAEXXZ proc near
.text$mn:00000E24
.text$mn:00000E24 var_4           = dword ptr -4
.text$mn:00000E24
.text$mn:00000E24                 push    ebp
.text$mn:00000E25                 mov     ebp, esp
.text$mn:00000E27                 push    ecx
.text$mn:00000E28                 mov     [ebp+var_4], ecx
.text$mn:00000E2B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E2E                 call    ?removeAll@VerticalFileSwitcherListView@@IAEXXZ ; VerticalFileSwitcherListView::removeAll(void)
.text$mn:00000E33                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E36                 call    ?initList@VerticalFileSwitcherListView@@QAEXXZ ; VerticalFileSwitcherListView::initList(void)
.text$mn:00000E3B                 mov     esp, ebp
.text$mn:00000E3D                 pop     ebp
.text$mn:00000E3E                 retn
.text$mn:00000E3E ?reload@VerticalFileSwitcherListView@@QAEXXZ endp
.text$mn:00000E3E
.text$mn:00000E3E ; ---------------------------------------------------------------------------
.text$mn:00000E3F                 db 5 dup(0CCh)
.text$mn:00000E44
.text$mn:00000E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E44
.text$mn:00000E44 ; Attributes: bp-based frame
.text$mn:00000E44
.text$mn:00000E44 ; __int32 __thiscall VerticalFileSwitcherListView::runProc(VerticalFileSwitcherListView *this, HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00000E44                 public ?runProc@VerticalFileSwitcherListView@@IAEJPAUHWND__@@IIJ@Z
.text$mn:00000E44 ?runProc@VerticalFileSwitcherListView@@IAEJPAUHWND__@@IIJ@Z proc near
.text$mn:00000E44                                         ; CODE XREF: VerticalFileSwitcherListView::staticProc(HWND__ *,uint,uint,long)+21p
.text$mn:00000E44
.text$mn:00000E44 var_4           = dword ptr -4
.text$mn:00000E44 hWnd            = dword ptr  8
.text$mn:00000E44 Msg             = dword ptr  0Ch
.text$mn:00000E44 wParam          = dword ptr  10h
.text$mn:00000E44 lParam          = dword ptr  14h
.text$mn:00000E44
.text$mn:00000E44                 push    ebp
.text$mn:00000E45                 mov     ebp, esp
.text$mn:00000E47                 push    ecx
.text$mn:00000E48                 mov     [ebp+var_4], ecx
.text$mn:00000E4B                 mov     eax, [ebp+lParam]
.text$mn:00000E4E                 push    eax             ; lParam
.text$mn:00000E4F                 mov     ecx, [ebp+wParam]
.text$mn:00000E52                 push    ecx             ; wParam
.text$mn:00000E53                 mov     edx, [ebp+Msg]
.text$mn:00000E56                 push    edx             ; Msg
.text$mn:00000E57                 mov     eax, [ebp+hWnd]
.text$mn:00000E5A                 push    eax             ; hWnd
.text$mn:00000E5B                 mov     ecx, [ebp+var_4]
.text$mn:00000E5E                 mov     edx, [ecx+14h]
.text$mn:00000E61                 push    edx             ; lpPrevWndFunc
.text$mn:00000E62                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:00000E68                 mov     esp, ebp
.text$mn:00000E6A                 pop     ebp
.text$mn:00000E6B                 retn    10h
.text$mn:00000E6B ?runProc@VerticalFileSwitcherListView@@IAEJPAUHWND__@@IIJ@Z endp
.text$mn:00000E6B
.text$mn:00000E6B ; ---------------------------------------------------------------------------
.text$mn:00000E6E                 db 6 dup(0CCh)
.text$mn:00000E74
.text$mn:00000E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E74
.text$mn:00000E74 ; Attributes: bp-based frame
.text$mn:00000E74
.text$mn:00000E74 ; int __thiscall VerticalFileSwitcherListView::find(VerticalFileSwitcherListView *this, int, int)
.text$mn:00000E74                 public ?find@VerticalFileSwitcherListView@@IBEHHH@Z
.text$mn:00000E74 ?find@VerticalFileSwitcherListView@@IBEHHH@Z proc near
.text$mn:00000E74                                         ; CODE XREF: VerticalFileSwitcherListView::newItem(int,int)+14p
.text$mn:00000E74                                         ; VerticalFileSwitcherListView::closeItem(int,int)+14p
.text$mn:00000E74
.text$mn:00000E74 lParam          = dword ptr -4Ch
.text$mn:00000E74 var_48          = dword ptr -48h
.text$mn:00000E74 var_2C          = dword ptr -2Ch
.text$mn:00000E74 var_18          = dword ptr -18h
.text$mn:00000E74 var_14          = dword ptr -14h
.text$mn:00000E74 var_10          = dword ptr -10h
.text$mn:00000E74 var_C           = dword ptr -0Ch
.text$mn:00000E74 var_8           = dword ptr -8
.text$mn:00000E74 var_1           = byte ptr -1
.text$mn:00000E74 arg_0           = dword ptr  8
.text$mn:00000E74 arg_4           = dword ptr  0Ch
.text$mn:00000E74
.text$mn:00000E74                 push    ebp
.text$mn:00000E75                 mov     ebp, esp
.text$mn:00000E77                 sub     esp, 4Ch
.text$mn:00000E7A                 mov     [ebp+var_C], ecx
.text$mn:00000E7D                 mov     [ebp+var_1], 0
.text$mn:00000E81                 push    0               ; lParam
.text$mn:00000E83                 push    0               ; wParam
.text$mn:00000E85                 push    1004h           ; Msg
.text$mn:00000E8A                 mov     eax, [ebp+var_C]
.text$mn:00000E8D                 mov     ecx, [eax+0Ch]
.text$mn:00000E90                 push    ecx             ; hWnd
.text$mn:00000E91                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E97                 mov     [ebp+var_18], eax
.text$mn:00000E9A                 mov     [ebp+var_8], 0
.text$mn:00000EA1                 jmp     short loc_EAC
.text$mn:00000EA3 ; ---------------------------------------------------------------------------
.text$mn:00000EA3
.text$mn:00000EA3 loc_EA3:                                ; CODE XREF: VerticalFileSwitcherListView::find(int,int):loc_EFAj
.text$mn:00000EA3                 mov     edx, [ebp+var_8]
.text$mn:00000EA6                 add     edx, 1
.text$mn:00000EA9                 mov     [ebp+var_8], edx
.text$mn:00000EAC
.text$mn:00000EAC loc_EAC:                                ; CODE XREF: VerticalFileSwitcherListView::find(int,int)+2Dj
.text$mn:00000EAC                 mov     eax, [ebp+var_8]
.text$mn:00000EAF                 cmp     eax, [ebp+var_18]
.text$mn:00000EB2                 jge     short loc_EFC
.text$mn:00000EB4                 mov     [ebp+lParam], 4
.text$mn:00000EBB                 mov     ecx, [ebp+var_8]
.text$mn:00000EBE                 mov     [ebp+var_48], ecx
.text$mn:00000EC1                 lea     edx, [ebp+lParam]
.text$mn:00000EC4                 push    edx             ; lParam
.text$mn:00000EC5                 push    0               ; wParam
.text$mn:00000EC7                 push    104Bh           ; Msg
.text$mn:00000ECC                 mov     eax, [ebp+var_C]
.text$mn:00000ECF                 mov     ecx, [eax+0Ch]
.text$mn:00000ED2                 push    ecx             ; hWnd
.text$mn:00000ED3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000ED9                 mov     edx, [ebp+var_2C]
.text$mn:00000EDC                 mov     [ebp+var_10], edx
.text$mn:00000EDF                 mov     eax, [ebp+var_10]
.text$mn:00000EE2                 mov     ecx, [eax+28h]
.text$mn:00000EE5                 cmp     ecx, [ebp+arg_0]
.text$mn:00000EE8                 jnz     short loc_EFA
.text$mn:00000EEA                 mov     edx, [ebp+var_10]
.text$mn:00000EED                 mov     eax, [edx]
.text$mn:00000EEF                 cmp     eax, [ebp+arg_4]
.text$mn:00000EF2                 jnz     short loc_EFA
.text$mn:00000EF4                 mov     [ebp+var_1], 1
.text$mn:00000EF8                 jmp     short loc_EFC
.text$mn:00000EFA ; ---------------------------------------------------------------------------
.text$mn:00000EFA
.text$mn:00000EFA loc_EFA:                                ; CODE XREF: VerticalFileSwitcherListView::find(int,int)+74j
.text$mn:00000EFA                                         ; VerticalFileSwitcherListView::find(int,int)+7Ej
.text$mn:00000EFA                 jmp     short loc_EA3
.text$mn:00000EFC ; ---------------------------------------------------------------------------
.text$mn:00000EFC
.text$mn:00000EFC loc_EFC:                                ; CODE XREF: VerticalFileSwitcherListView::find(int,int)+3Ej
.text$mn:00000EFC                                         ; VerticalFileSwitcherListView::find(int,int)+84j
.text$mn:00000EFC                 movzx   ecx, [ebp+var_1]
.text$mn:00000F00                 test    ecx, ecx
.text$mn:00000F02                 jz      short loc_F0C
.text$mn:00000F04                 mov     edx, [ebp+var_8]
.text$mn:00000F07                 mov     [ebp+var_14], edx
.text$mn:00000F0A                 jmp     short loc_F13
.text$mn:00000F0C ; ---------------------------------------------------------------------------
.text$mn:00000F0C
.text$mn:00000F0C loc_F0C:                                ; CODE XREF: VerticalFileSwitcherListView::find(int,int)+8Ej
.text$mn:00000F0C                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:00000F13
.text$mn:00000F13 loc_F13:                                ; CODE XREF: VerticalFileSwitcherListView::find(int,int)+96j
.text$mn:00000F13                 mov     eax, [ebp+var_14]
.text$mn:00000F16                 mov     esp, ebp
.text$mn:00000F18                 pop     ebp
.text$mn:00000F19                 retn    8
.text$mn:00000F19 ?find@VerticalFileSwitcherListView@@IBEHHH@Z endp
.text$mn:00000F19
.text$mn:00000F19 ; ---------------------------------------------------------------------------
.text$mn:00000F1C                 db 8 dup(0CCh)
.text$mn:00000F24
.text$mn:00000F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F24
.text$mn:00000F24 ; Attributes: bp-based frame
.text$mn:00000F24
.text$mn:00000F24 ; int __thiscall VerticalFileSwitcherListView::add(VerticalFileSwitcherListView *this, int, int)
.text$mn:00000F24                 public ?add@VerticalFileSwitcherListView@@IAEHHH@Z
.text$mn:00000F24 ?add@VerticalFileSwitcherListView@@IAEHHH@Z proc near
.text$mn:00000F24                                         ; CODE XREF: VerticalFileSwitcherListView::newItem(int,int)+2Dp
.text$mn:00000F24
.text$mn:00000F24 var_2F4         = dword ptr -2F4h
.text$mn:00000F24 var_2E8         = dword ptr -2E8h
.text$mn:00000F24 var_2E4         = dword ptr -2E4h
.text$mn:00000F24 var_2C0         = dword ptr -2C0h
.text$mn:00000F24 var_2B8         = dword ptr -2B8h
.text$mn:00000F24 var_2AC         = dword ptr -2ACh
.text$mn:00000F24 lParam          = dword ptr -28Ch
.text$mn:00000F24 var_288         = dword ptr -288h
.text$mn:00000F24 var_284         = dword ptr -284h
.text$mn:00000F24 var_278         = dword ptr -278h
.text$mn:00000F24 var_270         = dword ptr -270h
.text$mn:00000F24 var_26C         = dword ptr -26Ch
.text$mn:00000F24 var_258         = dword ptr -258h
.text$mn:00000F24 var_254         = dword ptr -254h
.text$mn:00000F24 var_250         = dword ptr -250h
.text$mn:00000F24 var_24C         = dword ptr -24Ch
.text$mn:00000F24 var_248         = dword ptr -248h
.text$mn:00000F24 var_244         = dword ptr -244h
.text$mn:00000F24 var_240         = dword ptr -240h
.text$mn:00000F24 var_23C         = dword ptr -23Ch
.text$mn:00000F24 var_238         = dword ptr -238h
.text$mn:00000F24 var_234         = dword ptr -234h
.text$mn:00000F24 var_230         = dword ptr -230h
.text$mn:00000F24 pszPath         = dword ptr -22Ch
.text$mn:00000F24 wParam          = dword ptr -228h
.text$mn:00000F24 var_224         = dword ptr -224h
.text$mn:00000F24 var_220         = dword ptr -220h
.text$mn:00000F24 var_219         = byte ptr -219h
.text$mn:00000F24 String1         = word ptr -218h
.text$mn:00000F24 var_10          = dword ptr -10h
.text$mn:00000F24 var_C           = dword ptr -0Ch
.text$mn:00000F24 var_4           = dword ptr -4
.text$mn:00000F24 arg_0           = dword ptr  8
.text$mn:00000F24 arg_4           = dword ptr  0Ch
.text$mn:00000F24
.text$mn:00000F24                 push    ebp
.text$mn:00000F25                 mov     ebp, esp
.text$mn:00000F27                 push    0FFFFFFFFh
.text$mn:00000F29                 push    offset __ehhandler$?add@VerticalFileSwitcherListView@@IAEHHH@Z
.text$mn:00000F2E                 mov     eax, large fs:0
.text$mn:00000F34                 push    eax
.text$mn:00000F35                 sub     esp, 2E8h
.text$mn:00000F3B                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F40                 xor     eax, ebp
.text$mn:00000F42                 mov     [ebp+var_10], eax
.text$mn:00000F45                 push    eax
.text$mn:00000F46                 lea     eax, [ebp+var_C]
.text$mn:00000F49                 mov     large fs:0, eax
.text$mn:00000F4F                 mov     [ebp+var_220], ecx
.text$mn:00000F55                 push    0               ; lParam
.text$mn:00000F57                 push    0               ; wParam
.text$mn:00000F59                 push    1004h           ; Msg
.text$mn:00000F5E                 mov     eax, [ebp+var_220]
.text$mn:00000F64                 mov     ecx, [eax+0Ch]
.text$mn:00000F67                 push    ecx             ; hWnd
.text$mn:00000F68                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000F6E                 mov     [ebp+wParam], eax
.text$mn:00000F74                 mov     edx, [ebp+arg_0]
.text$mn:00000F77                 mov     [ebp+var_224], edx
.text$mn:00000F7D                 mov     ecx, [ebp+var_224] ; this
.text$mn:00000F83                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00000F88                 mov     [ebp+pszPath], eax
.text$mn:00000F8E                 push    2Ch ; ','       ; unsigned int
.text$mn:00000F90                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000F95                 add     esp, 4
.text$mn:00000F98                 mov     [ebp+var_238], eax
.text$mn:00000F9E                 mov     [ebp+var_4], 0
.text$mn:00000FA5                 cmp     [ebp+var_238], 0
.text$mn:00000FAC                 jz      short loc_100A
.text$mn:00000FAE                 mov     eax, [ebp+arg_0]
.text$mn:00000FB1                 push    eax
.text$mn:00000FB2                 push    0
.text$mn:00000FB4                 sub     esp, 1Ch
.text$mn:00000FB7                 mov     ecx, esp
.text$mn:00000FB9                 mov     [ebp+var_258], esp
.text$mn:00000FBF                 mov     edx, [ebp+pszPath]
.text$mn:00000FC5                 push    edx             ; Str
.text$mn:00000FC6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000FCB                 mov     [ebp+var_248], eax
.text$mn:00000FD1                 mov     eax, [ebp+var_248]
.text$mn:00000FD7                 mov     [ebp+var_254], eax
.text$mn:00000FDD                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000FE1                 push    0
.text$mn:00000FE3                 mov     ecx, [ebp+arg_4]
.text$mn:00000FE6                 push    ecx
.text$mn:00000FE7                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000FEB                 mov     ecx, [ebp+var_238]
.text$mn:00000FF1                 call    ??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z ; TaskLstFnStatus::TaskLstFnStatus(int,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,int,void *)
.text$mn:00000FF6                 mov     [ebp+var_24C], eax
.text$mn:00000FFC                 mov     edx, [ebp+var_24C]
.text$mn:00001002                 mov     [ebp+var_23C], edx
.text$mn:00001008                 jmp     short loc_1014
.text$mn:0000100A ; ---------------------------------------------------------------------------
.text$mn:0000100A
.text$mn:0000100A loc_100A:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+88j
.text$mn:0000100A                 mov     [ebp+var_23C], 0
.text$mn:00001014
.text$mn:00001014 loc_1014:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+E4j
.text$mn:00001014                 mov     eax, [ebp+var_23C]
.text$mn:0000101A                 mov     [ebp+var_250], eax
.text$mn:00001020                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001027                 mov     ecx, [ebp+var_250]
.text$mn:0000102D                 mov     [ebp+var_244], ecx
.text$mn:00001033                 mov     edx, [ebp+pszPath]
.text$mn:00001039                 push    edx             ; pszPath
.text$mn:0000103A                 call    dword ptr ds:__imp__PathFindFileNameW@4 ; PathFindFileNameW(x)
.text$mn:00001040                 push    eax             ; lpString2
.text$mn:00001041                 lea     eax, [ebp+String1]
.text$mn:00001047                 push    eax             ; lpString1
.text$mn:00001048                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:0000104E                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001053                 mov     ecx, eax        ; this
.text$mn:00001055                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:0000105A                 movzx   ecx, byte ptr [eax+694h]
.text$mn:00001061                 test    ecx, ecx
.text$mn:00001063                 jnz     short loc_1071
.text$mn:00001065                 mov     [ebp+var_240], 1
.text$mn:0000106F                 jmp     short loc_107B
.text$mn:00001071 ; ---------------------------------------------------------------------------
.text$mn:00001071
.text$mn:00001071 loc_1071:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+13Fj
.text$mn:00001071                 mov     [ebp+var_240], 0
.text$mn:0000107B
.text$mn:0000107B loc_107B:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+14Bj
.text$mn:0000107B                 mov     dl, byte ptr [ebp+var_240]
.text$mn:00001081                 mov     [ebp+var_219], dl
.text$mn:00001087                 movzx   eax, [ebp+var_219]
.text$mn:0000108E                 test    eax, eax
.text$mn:00001090                 jz      short loc_109F
.text$mn:00001092                 lea     ecx, [ebp+String1]
.text$mn:00001098                 push    ecx             ; pszPath
.text$mn:00001099                 call    dword ptr ds:__imp__PathRemoveExtensionW@4 ; PathRemoveExtensionW(x)
.text$mn:0000109F
.text$mn:0000109F loc_109F:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+16Cj
.text$mn:0000109F                 mov     [ebp+lParam], 7
.text$mn:000010A9                 lea     edx, [ebp+String1]
.text$mn:000010AF                 mov     [ebp+var_278], edx
.text$mn:000010B5                 mov     eax, [ebp+wParam]
.text$mn:000010BB                 mov     [ebp+var_288], eax
.text$mn:000010C1                 mov     [ebp+var_284], 0
.text$mn:000010CB                 mov     ecx, [ebp+var_224] ; this
.text$mn:000010D1                 call    ?getUserReadOnly@Buffer@@QBE_NXZ ; Buffer::getUserReadOnly(void)
.text$mn:000010D6                 movzx   ecx, al
.text$mn:000010D9                 test    ecx, ecx
.text$mn:000010DB                 jnz     short loc_1125
.text$mn:000010DD                 mov     ecx, [ebp+var_224] ; this
.text$mn:000010E3                 call    ?getFileReadOnly@Buffer@@QBE_NXZ ; Buffer::getFileReadOnly(void)
.text$mn:000010E8                 movzx   edx, al
.text$mn:000010EB                 test    edx, edx
.text$mn:000010ED                 jnz     short loc_1125
.text$mn:000010EF                 mov     ecx, [ebp+var_224] ; this
.text$mn:000010F5                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:000010FA                 movzx   eax, al
.text$mn:000010FD                 test    eax, eax
.text$mn:000010FF                 jz      short loc_110D
.text$mn:00001101                 mov     [ebp+var_234], 1
.text$mn:0000110B                 jmp     short loc_1117
.text$mn:0000110D ; ---------------------------------------------------------------------------
.text$mn:0000110D
.text$mn:0000110D loc_110D:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+1DBj
.text$mn:0000110D                 mov     [ebp+var_234], 0
.text$mn:00001117
.text$mn:00001117 loc_1117:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+1E7j
.text$mn:00001117                 mov     ecx, [ebp+var_234]
.text$mn:0000111D                 mov     [ebp+var_230], ecx
.text$mn:00001123                 jmp     short loc_112F
.text$mn:00001125 ; ---------------------------------------------------------------------------
.text$mn:00001125
.text$mn:00001125 loc_1125:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+1B7j
.text$mn:00001125                                         ; VerticalFileSwitcherListView::add(int,int)+1C9j
.text$mn:00001125                 mov     [ebp+var_230], 2
.text$mn:0000112F
.text$mn:0000112F loc_112F:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+1FFj
.text$mn:0000112F                 mov     edx, [ebp+var_230]
.text$mn:00001135                 mov     [ebp+var_270], edx
.text$mn:0000113B                 mov     eax, [ebp+var_244]
.text$mn:00001141                 mov     [ebp+var_26C], eax
.text$mn:00001147                 lea     ecx, [ebp+lParam]
.text$mn:0000114D                 push    ecx             ; lParam
.text$mn:0000114E                 push    0               ; wParam
.text$mn:00001150                 push    104Dh           ; Msg
.text$mn:00001155                 mov     edx, [ebp+var_220]
.text$mn:0000115B                 mov     eax, [edx+0Ch]
.text$mn:0000115E                 push    eax             ; hWnd
.text$mn:0000115F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001165                 movzx   ecx, [ebp+var_219]
.text$mn:0000116C                 test    ecx, ecx
.text$mn:0000116E                 jz      short loc_11B0
.text$mn:00001170                 mov     [ebp+var_2B8], 1
.text$mn:0000117A                 mov     edx, [ebp+pszPath]
.text$mn:00001180                 push    edx             ; pszPath
.text$mn:00001181                 call    dword ptr ds:__imp__PathFindExtensionW@4 ; PathFindExtensionW(x)
.text$mn:00001187                 mov     [ebp+var_2AC], eax
.text$mn:0000118D                 lea     eax, [ebp+var_2C0]
.text$mn:00001193                 push    eax             ; lParam
.text$mn:00001194                 mov     ecx, [ebp+wParam]
.text$mn:0000119A                 push    ecx             ; wParam
.text$mn:0000119B                 push    1074h           ; Msg
.text$mn:000011A0                 mov     edx, [ebp+var_220]
.text$mn:000011A6                 mov     eax, [edx+0Ch]
.text$mn:000011A9                 push    eax             ; hWnd
.text$mn:000011AA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000011B0
.text$mn:000011B0 loc_11B0:                               ; CODE XREF: VerticalFileSwitcherListView::add(int,int)+24Aj
.text$mn:000011B0                 mov     [ebp+var_2E4], 3
.text$mn:000011BA                 mov     [ebp+var_2E8], 3
.text$mn:000011C4                 lea     ecx, [ebp+var_2F4]
.text$mn:000011CA                 push    ecx             ; lParam
.text$mn:000011CB                 mov     edx, [ebp+wParam]
.text$mn:000011D1                 push    edx             ; wParam
.text$mn:000011D2                 push    102Bh           ; Msg
.text$mn:000011D7                 mov     eax, [ebp+var_220]
.text$mn:000011DD                 mov     ecx, [eax+0Ch]
.text$mn:000011E0                 push    ecx             ; hWnd
.text$mn:000011E1                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000011E7                 mov     eax, [ebp+wParam]
.text$mn:000011ED                 mov     ecx, [ebp+var_C]
.text$mn:000011F0                 mov     large fs:0, ecx
.text$mn:000011F7                 pop     ecx
.text$mn:000011F8                 mov     ecx, [ebp+var_10]
.text$mn:000011FB                 xor     ecx, ebp
.text$mn:000011FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001202                 mov     esp, ebp
.text$mn:00001204                 pop     ebp
.text$mn:00001205                 retn    8
.text$mn:00001205 ?add@VerticalFileSwitcherListView@@IAEHHH@Z endp
.text$mn:00001205
.text$mn:00001205 ; ---------------------------------------------------------------------------
.text$mn:00001208                 db 0Ch dup(0CCh)
.text$mn:00001214
.text$mn:00001214 ; =============== S U B R O U T I N E =======================================
.text$mn:00001214
.text$mn:00001214 ; Attributes: bp-based frame
.text$mn:00001214
.text$mn:00001214 ; void __thiscall VerticalFileSwitcherListView::remove(VerticalFileSwitcherListView *this, int)
.text$mn:00001214                 public ?remove@VerticalFileSwitcherListView@@IAEXH@Z
.text$mn:00001214 ?remove@VerticalFileSwitcherListView@@IAEXH@Z proc near
.text$mn:00001214                                         ; CODE XREF: VerticalFileSwitcherListView::closeItem(int,int)+29p
.text$mn:00001214                                         ; VerticalFileSwitcherListView::removeAll(void)+43p
.text$mn:00001214
.text$mn:00001214 lParam          = dword ptr -48h
.text$mn:00001214 var_44          = dword ptr -44h
.text$mn:00001214 var_28          = dword ptr -28h
.text$mn:00001214 var_14          = dword ptr -14h
.text$mn:00001214 var_10          = dword ptr -10h
.text$mn:00001214 var_C           = dword ptr -0Ch
.text$mn:00001214 var_8           = dword ptr -8
.text$mn:00001214 var_4           = dword ptr -4
.text$mn:00001214 wParam          = dword ptr  8
.text$mn:00001214
.text$mn:00001214                 push    ebp
.text$mn:00001215                 mov     ebp, esp
.text$mn:00001217                 sub     esp, 48h
.text$mn:0000121A                 mov     [ebp+var_8], ecx
.text$mn:0000121D                 mov     [ebp+lParam], 4
.text$mn:00001224                 mov     eax, [ebp+wParam]
.text$mn:00001227                 mov     [ebp+var_44], eax
.text$mn:0000122A                 lea     ecx, [ebp+lParam]
.text$mn:0000122D                 push    ecx             ; lParam
.text$mn:0000122E                 push    0               ; wParam
.text$mn:00001230                 push    104Bh           ; Msg
.text$mn:00001235                 mov     edx, [ebp+var_8]
.text$mn:00001238                 mov     eax, [edx+0Ch]
.text$mn:0000123B                 push    eax             ; hWnd
.text$mn:0000123C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001242                 mov     ecx, [ebp+var_28]
.text$mn:00001245                 mov     [ebp+var_C], ecx
.text$mn:00001248                 mov     edx, [ebp+var_C]
.text$mn:0000124B                 mov     [ebp+var_10], edx
.text$mn:0000124E                 mov     eax, [ebp+var_10]
.text$mn:00001251                 mov     [ebp+var_4], eax
.text$mn:00001254                 cmp     [ebp+var_4], 0
.text$mn:00001258                 jz      short loc_1269
.text$mn:0000125A                 push    1
.text$mn:0000125C                 mov     ecx, [ebp+var_4]
.text$mn:0000125F                 call    ??_GTaskLstFnStatus@@QAEPAXI@Z ; TaskLstFnStatus::`scalar deleting destructor'(uint)
.text$mn:00001264                 mov     [ebp+var_14], eax
.text$mn:00001267                 jmp     short loc_1270
.text$mn:00001269 ; ---------------------------------------------------------------------------
.text$mn:00001269
.text$mn:00001269 loc_1269:                               ; CODE XREF: VerticalFileSwitcherListView::remove(int)+44j
.text$mn:00001269                 mov     [ebp+var_14], 0
.text$mn:00001270
.text$mn:00001270 loc_1270:                               ; CODE XREF: VerticalFileSwitcherListView::remove(int)+53j
.text$mn:00001270                 push    0               ; lParam
.text$mn:00001272                 mov     ecx, [ebp+wParam]
.text$mn:00001275                 push    ecx             ; wParam
.text$mn:00001276                 push    1008h           ; Msg
.text$mn:0000127B                 mov     edx, [ebp+var_8]
.text$mn:0000127E                 mov     eax, [edx+0Ch]
.text$mn:00001281                 push    eax             ; hWnd
.text$mn:00001282                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001288                 mov     esp, ebp
.text$mn:0000128A                 pop     ebp
.text$mn:0000128B                 retn    4
.text$mn:0000128B ?remove@VerticalFileSwitcherListView@@IAEXH@Z endp
.text$mn:0000128B
.text$mn:0000128B ; ---------------------------------------------------------------------------
.text$mn:0000128E                 db 6 dup(0CCh)
.text$mn:00001294
.text$mn:00001294 ; =============== S U B R O U T I N E =======================================
.text$mn:00001294
.text$mn:00001294 ; Attributes: bp-based frame
.text$mn:00001294
.text$mn:00001294 ; void __thiscall VerticalFileSwitcherListView::removeAll(VerticalFileSwitcherListView *__hidden this)
.text$mn:00001294                 public ?removeAll@VerticalFileSwitcherListView@@IAEXXZ
.text$mn:00001294 ?removeAll@VerticalFileSwitcherListView@@IAEXXZ proc near
.text$mn:00001294                                         ; CODE XREF: VerticalFileSwitcherListView::reload(void)+Ap
.text$mn:00001294
.text$mn:00001294 var_C           = dword ptr -0Ch
.text$mn:00001294 var_8           = dword ptr -8
.text$mn:00001294 var_4           = dword ptr -4
.text$mn:00001294
.text$mn:00001294                 push    ebp
.text$mn:00001295                 mov     ebp, esp
.text$mn:00001297                 sub     esp, 0Ch
.text$mn:0000129A                 mov     [ebp+var_8], ecx
.text$mn:0000129D                 push    0               ; lParam
.text$mn:0000129F                 push    0               ; wParam
.text$mn:000012A1                 push    1004h           ; Msg
.text$mn:000012A6                 mov     eax, [ebp+var_8]
.text$mn:000012A9                 mov     ecx, [eax+0Ch]
.text$mn:000012AC                 push    ecx             ; hWnd
.text$mn:000012AD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000012B3                 mov     [ebp+var_C], eax
.text$mn:000012B6                 mov     edx, [ebp+var_C]
.text$mn:000012B9                 sub     edx, 1
.text$mn:000012BC                 mov     [ebp+var_4], edx
.text$mn:000012BF                 jmp     short loc_12CA
.text$mn:000012C1 ; ---------------------------------------------------------------------------
.text$mn:000012C1
.text$mn:000012C1 loc_12C1:                               ; CODE XREF: VerticalFileSwitcherListView::removeAll(void)+48j
.text$mn:000012C1                 mov     eax, [ebp+var_4]
.text$mn:000012C4                 sub     eax, 1
.text$mn:000012C7                 mov     [ebp+var_4], eax
.text$mn:000012CA
.text$mn:000012CA loc_12CA:                               ; CODE XREF: VerticalFileSwitcherListView::removeAll(void)+2Bj
.text$mn:000012CA                 cmp     [ebp+var_4], 0
.text$mn:000012CE                 jl      short loc_12DE
.text$mn:000012D0                 mov     ecx, [ebp+var_4]
.text$mn:000012D3                 push    ecx             ; int
.text$mn:000012D4                 mov     ecx, [ebp+var_8] ; this
.text$mn:000012D7                 call    ?remove@VerticalFileSwitcherListView@@IAEXH@Z ; VerticalFileSwitcherListView::remove(int)
.text$mn:000012DC                 jmp     short loc_12C1
.text$mn:000012DE ; ---------------------------------------------------------------------------
.text$mn:000012DE
.text$mn:000012DE loc_12DE:                               ; CODE XREF: VerticalFileSwitcherListView::removeAll(void)+3Aj
.text$mn:000012DE                 mov     esp, ebp
.text$mn:000012E0                 pop     ebp
.text$mn:000012E1                 retn
.text$mn:000012E1 ?removeAll@VerticalFileSwitcherListView@@IAEXXZ endp
.text$mn:000012E1
.text$mn:000012E1 ; ---------------------------------------------------------------------------
.text$mn:000012E2                 align 4
.text$mn:000012E2 _text$mn        ends
.text$mn:000012E2
.text$x:000012E4 ; ===========================================================================
.text$x:000012E4
.text$x:000012E4 ; Segment type: Pure code
.text$x:000012E4 ; Segment permissions: Read/Execute
.text$x:000012E4 _text$x         segment para public 'CODE' use32
.text$x:000012E4                 assume cs:_text$x
.text$x:000012E4                 ;org 12E4h
.text$x:000012E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012E4
.text$x:000012E4 ; =============== S U B R O U T I N E =======================================
.text$x:000012E4
.text$x:000012E4
.text$x:000012E4 __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$0 proc near
.text$x:000012E4                                         ; DATA XREF: .xdata$x:000060C4o
.text$x:000012E4                 lea     ecx, [ebp-2B4h] ; this
.text$x:000012EA                 jmp     ??1TaskListInfo@@QAE@XZ ; TaskListInfo::~TaskListInfo(void)
.text$x:000012EA __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$0 endp
.text$x:000012EA
.text$x:000012EF
.text$x:000012EF ; =============== S U B R O U T I N E =======================================
.text$x:000012EF
.text$x:000012EF
.text$x:000012EF __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$1 proc near
.text$x:000012EF                                         ; DATA XREF: .xdata$x:000060CCo
.text$x:000012EF                 mov     eax, ds:?$S1@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4IA
.text$x:000012F4                 and     eax, 0FFFFFFFEh
.text$x:000012F7                 mov     ds:?$S1@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4IA, eax
.text$x:000012FC                 retn
.text$x:000012FC __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$1 endp
.text$x:000012FC
.text$x:000012FD
.text$x:000012FD ; =============== S U B R O U T I N E =======================================
.text$x:000012FD
.text$x:000012FD
.text$x:000012FD __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$2 proc near
.text$x:000012FD                                         ; DATA XREF: .xdata$x:000060D4o
.text$x:000012FD                 lea     ecx, [ebp-244h]
.text$x:00001303                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001303 __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$2 endp
.text$x:00001303
.text$x:00001308
.text$x:00001308 ; =============== S U B R O U T I N E =======================================
.text$x:00001308
.text$x:00001308
.text$x:00001308 __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$3 proc near
.text$x:00001308                                         ; DATA XREF: .xdata$x:000060DCo
.text$x:00001308                 lea     ecx, [ebp-260h]
.text$x:0000130E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000130E __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$3 endp
.text$x:0000130E
.text$x:00001313
.text$x:00001313 ; =============== S U B R O U T I N E =======================================
.text$x:00001313
.text$x:00001313
.text$x:00001313 __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$4 proc near
.text$x:00001313                                         ; DATA XREF: .xdata$x:000060E4o
.text$x:00001313                 mov     eax, [ebp-288h]
.text$x:00001319                 push    eax             ; void *
.text$x:0000131A                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000131F                 pop     ecx
.text$x:00001320                 retn
.text$x:00001320 __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$4 endp
.text$x:00001320
.text$x:00001321
.text$x:00001321 ; =============== S U B R O U T I N E =======================================
.text$x:00001321
.text$x:00001321
.text$x:00001321 __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$5 proc near
.text$x:00001321                                         ; DATA XREF: .xdata$x:000060ECo
.text$x:00001321                 mov     ecx, [ebp-2BCh]
.text$x:00001327                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001327 __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$5 endp
.text$x:00001327
.text$x:0000132C
.text$x:0000132C ; =============== S U B R O U T I N E =======================================
.text$x:0000132C
.text$x:0000132C
.text$x:0000132C __ehhandler$?initList@VerticalFileSwitcherListView@@QAEXXZ proc near
.text$x:0000132C                                         ; DATA XREF: VerticalFileSwitcherListView::initList(void)+5o
.text$x:0000132C
.text$x:0000132C arg_4           = dword ptr  8
.text$x:0000132C
.text$x:0000132C                 mov     edx, [esp+arg_4]
.text$x:00001330                 lea     eax, [edx+0Ch]
.text$x:00001333                 mov     ecx, [edx-350h]
.text$x:00001339                 xor     ecx, eax
.text$x:0000133B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001340                 mov     ecx, [edx-4]
.text$x:00001343                 xor     ecx, eax
.text$x:00001345                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000134A                 mov     eax, offset __ehfuncinfo$?initList@VerticalFileSwitcherListView@@QAEXXZ
.text$x:0000134F                 jmp     ___CxxFrameHandler3
.text$x:0000134F __ehhandler$?initList@VerticalFileSwitcherListView@@QAEXXZ endp
.text$x:0000134F
.text$x:00001354
.text$x:00001354 ; =============== S U B R O U T I N E =======================================
.text$x:00001354
.text$x:00001354
.text$x:00001354 __unwindfunclet$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0 proc near
.text$x:00001354                                         ; DATA XREF: .xdata$x:0000600Co
.text$x:00001354                 mov     eax, [ebp-10h]
.text$x:00001357                 and     eax, 1
.text$x:0000135A                 jz      locret_136C
.text$x:00001360                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001364                 mov     ecx, [ebp+8]
.text$x:00001367                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000136C ; ---------------------------------------------------------------------------
.text$x:0000136C
.text$x:0000136C locret_136C:                            ; CODE XREF: __unwindfunclet$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0+6j
.text$x:0000136C                 retn
.text$x:0000136C __unwindfunclet$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0 endp
.text$x:0000136C
.text$x:0000136D
.text$x:0000136D ; =============== S U B R O U T I N E =======================================
.text$x:0000136D
.text$x:0000136D
.text$x:0000136D __ehhandler$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z proc near
.text$x:0000136D                                         ; DATA XREF: VerticalFileSwitcherListView::getFullFilePath(uint)+5o
.text$x:0000136D
.text$x:0000136D arg_4           = dword ptr  8
.text$x:0000136D
.text$x:0000136D                 mov     edx, [esp+arg_4]
.text$x:00001371                 lea     eax, [edx+0Ch]
.text$x:00001374                 mov     ecx, [edx-48h]
.text$x:00001377                 xor     ecx, eax
.text$x:00001379                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000137E                 mov     eax, offset __ehfuncinfo$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$x:00001383                 jmp     ___CxxFrameHandler3
.text$x:00001383 __ehhandler$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z endp
.text$x:00001383
.text$x:00001388
.text$x:00001388 ; =============== S U B R O U T I N E =======================================
.text$x:00001388
.text$x:00001388
.text$x:00001388 __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$0 proc near
.text$x:00001388                                         ; DATA XREF: .xdata$x:0000602Co
.text$x:00001388                 lea     ecx, [ebp-4Ch]
.text$x:0000138B                 jmp     ??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::~vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)
.text$x:0000138B __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$0 endp
.text$x:0000138B
.text$x:00001390
.text$x:00001390 ; =============== S U B R O U T I N E =======================================
.text$x:00001390
.text$x:00001390
.text$x:00001390 __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$1 proc near
.text$x:00001390                                         ; DATA XREF: .xdata$x:00006024o
.text$x:00001390                 mov     eax, [ebp-30h]
.text$x:00001393                 and     eax, 1
.text$x:00001396                 jz      locret_13A8
.text$x:0000139C                 and     dword ptr [ebp-30h], 0FFFFFFFEh
.text$x:000013A0                 mov     ecx, [ebp+8]
.text$x:000013A3                 jmp     ??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::~vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)
.text$x:000013A8 ; ---------------------------------------------------------------------------
.text$x:000013A8
.text$x:000013A8 locret_13A8:                            ; CODE XREF: __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$1+6j
.text$x:000013A8                 retn
.text$x:000013A8 __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$1 endp
.text$x:000013A8
.text$x:000013A9
.text$x:000013A9 ; =============== S U B R O U T I N E =======================================
.text$x:000013A9
.text$x:000013A9
.text$x:000013A9 __ehhandler$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z proc near
.text$x:000013A9                                         ; DATA XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+5o
.text$x:000013A9
.text$x:000013A9 arg_4           = dword ptr  8
.text$x:000013A9
.text$x:000013A9                 mov     edx, [esp+arg_4]
.text$x:000013AD                 lea     eax, [edx+0Ch]
.text$x:000013B0                 mov     ecx, [edx-78h]
.text$x:000013B3                 xor     ecx, eax
.text$x:000013B5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013BA                 mov     eax, offset __ehfuncinfo$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z
.text$x:000013BF                 jmp     ___CxxFrameHandler3
.text$x:000013BF __ehhandler$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z endp
.text$x:000013BF
.text$x:000013C4
.text$x:000013C4 ; =============== S U B R O U T I N E =======================================
.text$x:000013C4
.text$x:000013C4
.text$x:000013C4 __unwindfunclet$?add@VerticalFileSwitcherListView@@IAEHHH@Z$0 proc near
.text$x:000013C4                                         ; DATA XREF: .xdata$x:00006014o
.text$x:000013C4                 mov     eax, [ebp-238h]
.text$x:000013CA                 push    eax             ; void *
.text$x:000013CB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000013D0                 pop     ecx
.text$x:000013D1                 retn
.text$x:000013D1 __unwindfunclet$?add@VerticalFileSwitcherListView@@IAEHHH@Z$0 endp
.text$x:000013D1
.text$x:000013D2
.text$x:000013D2 ; =============== S U B R O U T I N E =======================================
.text$x:000013D2
.text$x:000013D2
.text$x:000013D2 __unwindfunclet$?add@VerticalFileSwitcherListView@@IAEHHH@Z$1 proc near
.text$x:000013D2                                         ; DATA XREF: .xdata$x:0000601Co
.text$x:000013D2                 mov     ecx, [ebp-258h]
.text$x:000013D8                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000013D8 __unwindfunclet$?add@VerticalFileSwitcherListView@@IAEHHH@Z$1 endp
.text$x:000013D8
.text$x:000013DD
.text$x:000013DD ; =============== S U B R O U T I N E =======================================
.text$x:000013DD
.text$x:000013DD
.text$x:000013DD __ehhandler$?add@VerticalFileSwitcherListView@@IAEHHH@Z proc near
.text$x:000013DD                                         ; DATA XREF: VerticalFileSwitcherListView::add(int,int)+5o
.text$x:000013DD
.text$x:000013DD arg_4           = dword ptr  8
.text$x:000013DD
.text$x:000013DD                 mov     edx, [esp+arg_4]
.text$x:000013E1                 lea     eax, [edx+0Ch]
.text$x:000013E4                 mov     ecx, [edx-2ECh]
.text$x:000013EA                 xor     ecx, eax
.text$x:000013EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013F1                 mov     ecx, [edx-4]
.text$x:000013F4                 xor     ecx, eax
.text$x:000013F6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013FB                 mov     eax, offset __ehfuncinfo$?add@VerticalFileSwitcherListView@@IAEHHH@Z
.text$x:00001400                 jmp     ___CxxFrameHandler3
.text$x:00001400 __ehhandler$?add@VerticalFileSwitcherListView@@IAEHHH@Z endp
.text$x:00001400
.text$x:00001400 ; ---------------------------------------------------------------------------
.text$x:00001405                 align 4
.text$x:00001405 _text$x         ends
.text$x:00001405
.text$mn:00001408 ; ===========================================================================
.text$mn:00001408
.text$mn:00001408 ; Segment type: Pure code
.text$mn:00001408 ; Segment permissions: Read/Execute
.text$mn:00001408 _text$mn        segment para public 'CODE' use32
.text$mn:00001408                 assume cs:_text$mn
.text$mn:00001408                 ;org 1408h
.text$mn:00001408 ; COMDAT (pick any)
.text$mn:00001408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001408
.text$mn:00001408 ; =============== S U B R O U T I N E =======================================
.text$mn:00001408
.text$mn:00001408 ; Attributes: bp-based frame
.text$mn:00001408
.text$mn:00001408 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001408                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001408 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001408                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001408
.text$mn:00001408 var_4           = dword ptr -4
.text$mn:00001408 arg_0           = dword ptr  8
.text$mn:00001408
.text$mn:00001408                 push    ebp
.text$mn:00001409                 mov     ebp, esp
.text$mn:0000140B                 push    ecx
.text$mn:0000140C                 mov     [ebp+var_4], 0
.text$mn:00001413                 cmp     [ebp+arg_0], 0
.text$mn:00001417                 jnz     short loc_141B
.text$mn:00001419                 jmp     short loc_143B
.text$mn:0000141B ; ---------------------------------------------------------------------------
.text$mn:0000141B
.text$mn:0000141B loc_141B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000141B                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000141F                 ja      short loc_1436
.text$mn:00001421                 mov     eax, [ebp+arg_0]
.text$mn:00001424                 push    eax             ; unsigned int
.text$mn:00001425                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000142A                 add     esp, 4
.text$mn:0000142D                 mov     [ebp+var_4], eax
.text$mn:00001430                 cmp     [ebp+var_4], 0
.text$mn:00001434                 jnz     short loc_143B
.text$mn:00001436
.text$mn:00001436 loc_1436:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00001436                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000143B
.text$mn:0000143B loc_143B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000143B                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000143B                 mov     eax, [ebp+var_4]
.text$mn:0000143E                 mov     esp, ebp
.text$mn:00001440                 pop     ebp
.text$mn:00001441                 retn
.text$mn:00001441 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001441
.text$mn:00001441 ; ---------------------------------------------------------------------------
.text$mn:00001442                 align 4
.text$mn:00001442 _text$mn        ends
.text$mn:00001442
.text$mn:00001444 ; ===========================================================================
.text$mn:00001444
.text$mn:00001444 ; Segment type: Pure code
.text$mn:00001444 ; Segment permissions: Read/Execute
.text$mn:00001444 _text$mn        segment para public 'CODE' use32
.text$mn:00001444                 assume cs:_text$mn
.text$mn:00001444                 ;org 1444h
.text$mn:00001444 ; COMDAT (pick any)
.text$mn:00001444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001444
.text$mn:00001444 ; =============== S U B R O U T I N E =======================================
.text$mn:00001444
.text$mn:00001444 ; Attributes: bp-based frame
.text$mn:00001444
.text$mn:00001444 ; struct SwitcherFileInfo * __cdecl std::_Allocate<struct SwitcherFileInfo>(unsigned int, struct SwitcherFileInfo *)
.text$mn:00001444                 public ??$_Allocate@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@IPAU1@@Z
.text$mn:00001444 ??$_Allocate@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@IPAU1@@Z proc near
.text$mn:00001444                                         ; CODE XREF: std::allocator<SwitcherFileInfo>::allocate(uint)+Dp
.text$mn:00001444
.text$mn:00001444 var_4           = dword ptr -4
.text$mn:00001444 arg_0           = dword ptr  8
.text$mn:00001444
.text$mn:00001444                 push    ebp
.text$mn:00001445                 mov     ebp, esp
.text$mn:00001447                 push    ecx
.text$mn:00001448                 mov     [ebp+var_4], 0
.text$mn:0000144F                 cmp     [ebp+arg_0], 0
.text$mn:00001453                 jnz     short loc_1457
.text$mn:00001455                 jmp     short loc_147D
.text$mn:00001457 ; ---------------------------------------------------------------------------
.text$mn:00001457
.text$mn:00001457 loc_1457:                               ; CODE XREF: std::_Allocate<SwitcherFileInfo>(uint,SwitcherFileInfo *)+Fj
.text$mn:00001457                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000145E                 ja      short loc_1478
.text$mn:00001460                 mov     eax, [ebp+arg_0]
.text$mn:00001463                 shl     eax, 3
.text$mn:00001466                 push    eax             ; unsigned int
.text$mn:00001467                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000146C                 add     esp, 4
.text$mn:0000146F                 mov     [ebp+var_4], eax
.text$mn:00001472                 cmp     [ebp+var_4], 0
.text$mn:00001476                 jnz     short loc_147D
.text$mn:00001478
.text$mn:00001478 loc_1478:                               ; CODE XREF: std::_Allocate<SwitcherFileInfo>(uint,SwitcherFileInfo *)+1Aj
.text$mn:00001478                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000147D
.text$mn:0000147D loc_147D:                               ; CODE XREF: std::_Allocate<SwitcherFileInfo>(uint,SwitcherFileInfo *)+11j
.text$mn:0000147D                                         ; std::_Allocate<SwitcherFileInfo>(uint,SwitcherFileInfo *)+32j
.text$mn:0000147D                 mov     eax, [ebp+var_4]
.text$mn:00001480                 mov     esp, ebp
.text$mn:00001482                 pop     ebp
.text$mn:00001483                 retn
.text$mn:00001483 ??$_Allocate@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@IPAU1@@Z endp
.text$mn:00001483
.text$mn:00001483 _text$mn        ends
.text$mn:00001483
.text$mn:00001484 ; ===========================================================================
.text$mn:00001484
.text$mn:00001484 ; Segment type: Pure code
.text$mn:00001484 ; Segment permissions: Read/Execute
.text$mn:00001484 _text$mn        segment para public 'CODE' use32
.text$mn:00001484                 assume cs:_text$mn
.text$mn:00001484                 ;org 1484h
.text$mn:00001484 ; COMDAT (pick any)
.text$mn:00001484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001484
.text$mn:00001484 ; =============== S U B R O U T I N E =======================================
.text$mn:00001484
.text$mn:00001484 ; Attributes: bp-based frame
.text$mn:00001484
.text$mn:00001484 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001484                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001484 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001484                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001484
.text$mn:00001484 var_4           = dword ptr -4
.text$mn:00001484 arg_0           = dword ptr  8
.text$mn:00001484
.text$mn:00001484                 push    ebp
.text$mn:00001485                 mov     ebp, esp
.text$mn:00001487                 push    ecx
.text$mn:00001488                 mov     [ebp+var_4], 0
.text$mn:0000148F                 cmp     [ebp+arg_0], 0
.text$mn:00001493                 jnz     short loc_1497
.text$mn:00001495                 jmp     short loc_14BD
.text$mn:00001497 ; ---------------------------------------------------------------------------
.text$mn:00001497
.text$mn:00001497 loc_1497:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00001497                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000149E                 ja      short loc_14B8
.text$mn:000014A0                 mov     eax, [ebp+arg_0]
.text$mn:000014A3                 shl     eax, 3
.text$mn:000014A6                 push    eax             ; unsigned int
.text$mn:000014A7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000014AC                 add     esp, 4
.text$mn:000014AF                 mov     [ebp+var_4], eax
.text$mn:000014B2                 cmp     [ebp+var_4], 0
.text$mn:000014B6                 jnz     short loc_14BD
.text$mn:000014B8
.text$mn:000014B8 loc_14B8:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000014B8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000014BD
.text$mn:000014BD loc_14BD:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000014BD                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000014BD                 mov     eax, [ebp+var_4]
.text$mn:000014C0                 mov     esp, ebp
.text$mn:000014C2                 pop     ebp
.text$mn:000014C3                 retn
.text$mn:000014C3 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000014C3
.text$mn:000014C3 _text$mn        ends
.text$mn:000014C3
.text$mn:000014C4 ; ===========================================================================
.text$mn:000014C4
.text$mn:000014C4 ; Segment type: Pure code
.text$mn:000014C4 ; Segment permissions: Read/Execute
.text$mn:000014C4 _text$mn        segment para public 'CODE' use32
.text$mn:000014C4                 assume cs:_text$mn
.text$mn:000014C4                 ;org 14C4h
.text$mn:000014C4 ; COMDAT (pick any)
.text$mn:000014C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014C4
.text$mn:000014C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014C4
.text$mn:000014C4 ; Attributes: bp-based frame
.text$mn:000014C4
.text$mn:000014C4 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:000014C4                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:000014C4 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:000014C4                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:000014C4
.text$mn:000014C4 var_4           = dword ptr -4
.text$mn:000014C4 arg_0           = dword ptr  8
.text$mn:000014C4
.text$mn:000014C4                 push    ebp
.text$mn:000014C5                 mov     ebp, esp
.text$mn:000014C7                 push    ecx
.text$mn:000014C8                 mov     [ebp+var_4], 0
.text$mn:000014CF                 cmp     [ebp+arg_0], 0
.text$mn:000014D3                 jnz     short loc_14D7
.text$mn:000014D5                 jmp     short loc_14FC
.text$mn:000014D7 ; ---------------------------------------------------------------------------
.text$mn:000014D7
.text$mn:000014D7 loc_14D7:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:000014D7                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:000014DE                 ja      short loc_14F7
.text$mn:000014E0                 mov     eax, [ebp+arg_0]
.text$mn:000014E3                 shl     eax, 1
.text$mn:000014E5                 push    eax             ; unsigned int
.text$mn:000014E6                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000014EB                 add     esp, 4
.text$mn:000014EE                 mov     [ebp+var_4], eax
.text$mn:000014F1                 cmp     [ebp+var_4], 0
.text$mn:000014F5                 jnz     short loc_14FC
.text$mn:000014F7
.text$mn:000014F7 loc_14F7:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:000014F7                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000014FC
.text$mn:000014FC loc_14FC:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:000014FC                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:000014FC                 mov     eax, [ebp+var_4]
.text$mn:000014FF                 mov     esp, ebp
.text$mn:00001501                 pop     ebp
.text$mn:00001502                 retn
.text$mn:00001502 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00001502
.text$mn:00001502 ; ---------------------------------------------------------------------------
.text$mn:00001503                 align 4
.text$mn:00001503 _text$mn        ends
.text$mn:00001503
.text$mn:00001504 ; ===========================================================================
.text$mn:00001504
.text$mn:00001504 ; Segment type: Pure code
.text$mn:00001504 ; Segment permissions: Read/Execute
.text$mn:00001504 _text$mn        segment para public 'CODE' use32
.text$mn:00001504                 assume cs:_text$mn
.text$mn:00001504                 ;org 1504h
.text$mn:00001504 ; COMDAT (pick any)
.text$mn:00001504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001504
.text$mn:00001504 ; =============== S U B R O U T I N E =======================================
.text$mn:00001504
.text$mn:00001504 ; Attributes: bp-based frame
.text$mn:00001504
.text$mn:00001504 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00001504                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00001504 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00001504                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00001504                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00001504
.text$mn:00001504 arg_0           = dword ptr  8
.text$mn:00001504 arg_4           = dword ptr  0Ch
.text$mn:00001504 arg_8           = dword ptr  10h
.text$mn:00001504
.text$mn:00001504                 push    ebp
.text$mn:00001505                 mov     ebp, esp
.text$mn:00001507                 cmp     [ebp+arg_0], 0
.text$mn:0000150B                 jnz     short loc_1522
.text$mn:0000150D                 mov     eax, [ebp+arg_8]
.text$mn:00001510                 push    eax             ; unsigned int
.text$mn:00001511                 mov     ecx, [ebp+arg_4]
.text$mn:00001514                 push    ecx             ; wchar_t *
.text$mn:00001515                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000151A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000151F                 add     esp, 0Ch
.text$mn:00001522
.text$mn:00001522 loc_1522:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00001522                 pop     ebp
.text$mn:00001523                 retn
.text$mn:00001523 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00001523
.text$mn:00001523 _text$mn        ends
.text$mn:00001523
.text$mn:00001524 ; ===========================================================================
.text$mn:00001524
.text$mn:00001524 ; Segment type: Pure code
.text$mn:00001524 ; Segment permissions: Read/Execute
.text$mn:00001524 _text$mn        segment para public 'CODE' use32
.text$mn:00001524                 assume cs:_text$mn
.text$mn:00001524                 ;org 1524h
.text$mn:00001524 ; COMDAT (pick any)
.text$mn:00001524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001524
.text$mn:00001524 ; =============== S U B R O U T I N E =======================================
.text$mn:00001524
.text$mn:00001524 ; Attributes: bp-based frame
.text$mn:00001524
.text$mn:00001524 ; int __cdecl std::_Debug_pointer<SwitcherFileInfo>(int, wchar_t *, unsigned int)
.text$mn:00001524                 public ??$_Debug_pointer@USwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@PB_WI@Z
.text$mn:00001524 ??$_Debug_pointer@USwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@PB_WI@Z proc near
.text$mn:00001524                                         ; CODE XREF: std::_Debug_range2<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001524                                         ; std::_Debug_range2<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00001524
.text$mn:00001524 arg_0           = dword ptr  8
.text$mn:00001524 arg_4           = dword ptr  0Ch
.text$mn:00001524 arg_8           = dword ptr  10h
.text$mn:00001524
.text$mn:00001524                 push    ebp
.text$mn:00001525                 mov     ebp, esp
.text$mn:00001527                 cmp     [ebp+arg_0], 0
.text$mn:0000152B                 jnz     short loc_1542
.text$mn:0000152D                 mov     eax, [ebp+arg_8]
.text$mn:00001530                 push    eax             ; unsigned int
.text$mn:00001531                 mov     ecx, [ebp+arg_4]
.text$mn:00001534                 push    ecx             ; wchar_t *
.text$mn:00001535                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000153A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000153F                 add     esp, 0Ch
.text$mn:00001542
.text$mn:00001542 loc_1542:                               ; CODE XREF: std::_Debug_pointer<SwitcherFileInfo>(SwitcherFileInfo *,wchar_t const *,uint)+7j
.text$mn:00001542                 pop     ebp
.text$mn:00001543                 retn
.text$mn:00001543 ??$_Debug_pointer@USwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@PB_WI@Z endp
.text$mn:00001543
.text$mn:00001543 _text$mn        ends
.text$mn:00001543
.text$mn:00001544 ; ===========================================================================
.text$mn:00001544
.text$mn:00001544 ; Segment type: Pure code
.text$mn:00001544 ; Segment permissions: Read/Execute
.text$mn:00001544 _text$mn        segment para public 'CODE' use32
.text$mn:00001544                 assume cs:_text$mn
.text$mn:00001544                 ;org 1544h
.text$mn:00001544 ; COMDAT (pick any)
.text$mn:00001544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001544
.text$mn:00001544 ; =============== S U B R O U T I N E =======================================
.text$mn:00001544
.text$mn:00001544 ; Attributes: bp-based frame
.text$mn:00001544
.text$mn:00001544 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00001544                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00001544 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00001544                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:00001544                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp
.text$mn:00001544
.text$mn:00001544 arg_0           = dword ptr  8
.text$mn:00001544 arg_4           = dword ptr  0Ch
.text$mn:00001544 arg_8           = dword ptr  10h
.text$mn:00001544
.text$mn:00001544                 push    ebp
.text$mn:00001545                 mov     ebp, esp
.text$mn:00001547                 cmp     [ebp+arg_0], 0
.text$mn:0000154B                 jnz     short loc_1562
.text$mn:0000154D                 mov     eax, [ebp+arg_8]
.text$mn:00001550                 push    eax             ; unsigned int
.text$mn:00001551                 mov     ecx, [ebp+arg_4]
.text$mn:00001554                 push    ecx             ; wchar_t *
.text$mn:00001555                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000155A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000155F                 add     esp, 0Ch
.text$mn:00001562
.text$mn:00001562 loc_1562:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:00001562                 pop     ebp
.text$mn:00001563                 retn
.text$mn:00001563 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:00001563
.text$mn:00001563 _text$mn        ends
.text$mn:00001563
.text$mn:00001564 ; ===========================================================================
.text$mn:00001564
.text$mn:00001564 ; Segment type: Pure code
.text$mn:00001564 ; Segment permissions: Read/Execute
.text$mn:00001564 _text$mn        segment para public 'CODE' use32
.text$mn:00001564                 assume cs:_text$mn
.text$mn:00001564                 ;org 1564h
.text$mn:00001564 ; COMDAT (pick any)
.text$mn:00001564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001564
.text$mn:00001564 ; =============== S U B R O U T I N E =======================================
.text$mn:00001564
.text$mn:00001564 ; Attributes: bp-based frame
.text$mn:00001564
.text$mn:00001564 ; int __cdecl std::_Debug_range2<SwitcherFileInfo *>(int, int, wchar_t *, unsigned int)
.text$mn:00001564                 public ??$_Debug_range2@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001564 ??$_Debug_range2@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001564                                         ; CODE XREF: std::_Debug_range<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint)+2Ap
.text$mn:00001564
.text$mn:00001564 arg_0           = dword ptr  8
.text$mn:00001564 arg_4           = dword ptr  0Ch
.text$mn:00001564 arg_8           = dword ptr  10h
.text$mn:00001564 arg_C           = dword ptr  14h
.text$mn:00001564
.text$mn:00001564                 push    ebp
.text$mn:00001565                 mov     ebp, esp
.text$mn:00001567                 mov     eax, [ebp+arg_0]
.text$mn:0000156A                 cmp     eax, [ebp+arg_4]
.text$mn:0000156D                 jz      short loc_15B4
.text$mn:0000156F                 mov     ecx, [ebp+arg_C]
.text$mn:00001572                 push    ecx             ; unsigned int
.text$mn:00001573                 mov     edx, [ebp+arg_8]
.text$mn:00001576                 push    edx             ; wchar_t *
.text$mn:00001577                 mov     eax, [ebp+arg_0]
.text$mn:0000157A                 push    eax             ; int
.text$mn:0000157B                 call    ??$_Debug_pointer@USwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@PB_WI@Z ; std::_Debug_pointer<SwitcherFileInfo>(SwitcherFileInfo *,wchar_t const *,uint)
.text$mn:00001580                 add     esp, 0Ch
.text$mn:00001583                 mov     ecx, [ebp+arg_C]
.text$mn:00001586                 push    ecx             ; unsigned int
.text$mn:00001587                 mov     edx, [ebp+arg_8]
.text$mn:0000158A                 push    edx             ; wchar_t *
.text$mn:0000158B                 mov     eax, [ebp+arg_4]
.text$mn:0000158E                 push    eax             ; int
.text$mn:0000158F                 call    ??$_Debug_pointer@USwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@PB_WI@Z ; std::_Debug_pointer<SwitcherFileInfo>(SwitcherFileInfo *,wchar_t const *,uint)
.text$mn:00001594                 add     esp, 0Ch
.text$mn:00001597                 mov     ecx, [ebp+arg_4]
.text$mn:0000159A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000159D                 jnb     short loc_15B4
.text$mn:0000159F                 mov     edx, [ebp+arg_C]
.text$mn:000015A2                 push    edx             ; unsigned int
.text$mn:000015A3                 mov     eax, [ebp+arg_8]
.text$mn:000015A6                 push    eax             ; wchar_t *
.text$mn:000015A7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000015AC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000015B1                 add     esp, 0Ch
.text$mn:000015B4
.text$mn:000015B4 loc_15B4:                               ; CODE XREF: std::_Debug_range2<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000015B4                                         ; std::_Debug_range2<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000015B4                 pop     ebp
.text$mn:000015B5                 retn
.text$mn:000015B5 ??$_Debug_range2@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000015B5
.text$mn:000015B5 ; ---------------------------------------------------------------------------
.text$mn:000015B6                 align 4
.text$mn:000015B6 _text$mn        ends
.text$mn:000015B6
.text$mn:000015B8 ; ===========================================================================
.text$mn:000015B8
.text$mn:000015B8 ; Segment type: Pure code
.text$mn:000015B8 ; Segment permissions: Read/Execute
.text$mn:000015B8 _text$mn        segment para public 'CODE' use32
.text$mn:000015B8                 assume cs:_text$mn
.text$mn:000015B8                 ;org 15B8h
.text$mn:000015B8 ; COMDAT (pick any)
.text$mn:000015B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015B8
.text$mn:000015B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015B8
.text$mn:000015B8 ; Attributes: bp-based frame
.text$mn:000015B8
.text$mn:000015B8 ; int __cdecl std::_Debug_range<SwitcherFileInfo *>(int, int, wchar_t *, unsigned int)
.text$mn:000015B8                 public ??$_Debug_range@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WI@Z
.text$mn:000015B8 ??$_Debug_range@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WI@Z proc near
.text$mn:000015B8                                         ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000015B8
.text$mn:000015B8 var_1           = byte ptr -1
.text$mn:000015B8 arg_0           = dword ptr  8
.text$mn:000015B8 arg_4           = dword ptr  0Ch
.text$mn:000015B8 arg_8           = dword ptr  10h
.text$mn:000015B8 arg_C           = dword ptr  14h
.text$mn:000015B8
.text$mn:000015B8                 push    ebp
.text$mn:000015B9                 mov     ebp, esp
.text$mn:000015BB                 push    ecx
.text$mn:000015BC                 lea     eax, [ebp+arg_0]
.text$mn:000015BF                 push    eax
.text$mn:000015C0                 lea     ecx, [ebp+var_1]
.text$mn:000015C3                 push    ecx
.text$mn:000015C4                 call    ??$_Iter_cat@PAUSwitcherFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSwitcherFileInfo@@@Z ; std::_Iter_cat<SwitcherFileInfo *>(SwitcherFileInfo * const &)
.text$mn:000015C9                 add     esp, 8
.text$mn:000015CC                 mov     dl, [eax]
.text$mn:000015CE                 movzx   eax, dl
.text$mn:000015D1                 push    eax
.text$mn:000015D2                 mov     ecx, [ebp+arg_C]
.text$mn:000015D5                 push    ecx             ; unsigned int
.text$mn:000015D6                 mov     edx, [ebp+arg_8]
.text$mn:000015D9                 push    edx             ; wchar_t *
.text$mn:000015DA                 mov     eax, [ebp+arg_4]
.text$mn:000015DD                 push    eax             ; int
.text$mn:000015DE                 mov     ecx, [ebp+arg_0]
.text$mn:000015E1                 push    ecx             ; int
.text$mn:000015E2                 call    ??$_Debug_range2@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000015E7                 add     esp, 14h
.text$mn:000015EA                 mov     esp, ebp
.text$mn:000015EC                 pop     ebp
.text$mn:000015ED                 retn
.text$mn:000015ED ??$_Debug_range@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WI@Z endp
.text$mn:000015ED
.text$mn:000015ED ; ---------------------------------------------------------------------------
.text$mn:000015EE                 align 10h
.text$mn:000015EE _text$mn        ends
.text$mn:000015EE
.text$mn:000015F0 ; ===========================================================================
.text$mn:000015F0
.text$mn:000015F0 ; Segment type: Pure code
.text$mn:000015F0 ; Segment permissions: Read/Execute
.text$mn:000015F0 _text$mn        segment para public 'CODE' use32
.text$mn:000015F0                 assume cs:_text$mn
.text$mn:000015F0                 ;org 15F0h
.text$mn:000015F0 ; COMDAT (pick any)
.text$mn:000015F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015F0
.text$mn:000015F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000015F0
.text$mn:000015F0 ; Attributes: bp-based frame
.text$mn:000015F0
.text$mn:000015F0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>>(struct SwitcherFileInfo *, struct SwitcherFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>> &)
.text$mn:000015F0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z
.text$mn:000015F0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z proc near
.text$mn:000015F0                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Destroy(SwitcherFileInfo *,SwitcherFileInfo *)+21p
.text$mn:000015F0
.text$mn:000015F0 var_1           = byte ptr -1
.text$mn:000015F0 arg_0           = dword ptr  8
.text$mn:000015F0 arg_4           = dword ptr  0Ch
.text$mn:000015F0 arg_8           = dword ptr  10h
.text$mn:000015F0
.text$mn:000015F0                 push    ebp
.text$mn:000015F1                 mov     ebp, esp
.text$mn:000015F3                 push    ecx
.text$mn:000015F4                 mov     eax, [ebp+arg_4]
.text$mn:000015F7                 push    eax
.text$mn:000015F8                 mov     ecx, [ebp+arg_0]
.text$mn:000015FB                 push    ecx
.text$mn:000015FC                 call    ??$_Ptr_cat@USwitcherFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSwitcherFileInfo@@0@Z ; std::_Ptr_cat<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *)
.text$mn:00001601                 add     esp, 8
.text$mn:00001604                 mov     [ebp+var_1], al
.text$mn:00001607                 movzx   edx, [ebp+var_1]
.text$mn:0000160B                 push    edx
.text$mn:0000160C                 mov     eax, [ebp+arg_8]
.text$mn:0000160F                 push    eax
.text$mn:00001610                 mov     ecx, [ebp+arg_4]
.text$mn:00001613                 push    ecx
.text$mn:00001614                 mov     edx, [ebp+arg_0]
.text$mn:00001617                 push    edx
.text$mn:00001618                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000161D                 add     esp, 10h
.text$mn:00001620                 mov     esp, ebp
.text$mn:00001622                 pop     ebp
.text$mn:00001623                 retn
.text$mn:00001623 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z endp
.text$mn:00001623
.text$mn:00001623 _text$mn        ends
.text$mn:00001623
.text$mn:00001624 ; ===========================================================================
.text$mn:00001624
.text$mn:00001624 ; Segment type: Pure code
.text$mn:00001624 ; Segment permissions: Read/Execute
.text$mn:00001624 _text$mn        segment para public 'CODE' use32
.text$mn:00001624                 assume cs:_text$mn
.text$mn:00001624                 ;org 1624h
.text$mn:00001624 ; COMDAT (pick any)
.text$mn:00001624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001624
.text$mn:00001624 ; =============== S U B R O U T I N E =======================================
.text$mn:00001624
.text$mn:00001624 ; Attributes: bp-based frame
.text$mn:00001624
.text$mn:00001624 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>>(struct SwitcherFileInfo *, struct SwitcherFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001624                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001624 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001624                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+28p
.text$mn:00001624
.text$mn:00001624 arg_0           = dword ptr  8
.text$mn:00001624 arg_4           = dword ptr  0Ch
.text$mn:00001624 arg_8           = dword ptr  10h
.text$mn:00001624
.text$mn:00001624                 push    ebp
.text$mn:00001625                 mov     ebp, esp
.text$mn:00001627                 jmp     short loc_1632
.text$mn:00001629 ; ---------------------------------------------------------------------------
.text$mn:00001629
.text$mn:00001629 loc_1629:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00001629                 mov     eax, [ebp+arg_0]
.text$mn:0000162C                 add     eax, 8
.text$mn:0000162F                 mov     [ebp+arg_0], eax
.text$mn:00001632
.text$mn:00001632 loc_1632:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00001632                 mov     ecx, [ebp+arg_0]
.text$mn:00001635                 cmp     ecx, [ebp+arg_4]
.text$mn:00001638                 jz      short loc_1648
.text$mn:0000163A                 mov     edx, [ebp+arg_0]
.text$mn:0000163D                 push    edx
.text$mn:0000163E                 mov     ecx, [ebp+arg_8]
.text$mn:00001641                 call    ??$destroy@USwitcherFileInfo@@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::destroy<SwitcherFileInfo>(SwitcherFileInfo *)
.text$mn:00001646                 jmp     short loc_1629
.text$mn:00001648 ; ---------------------------------------------------------------------------
.text$mn:00001648
.text$mn:00001648 loc_1648:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00001648                 pop     ebp
.text$mn:00001649                 retn
.text$mn:00001649 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001649
.text$mn:00001649 ; ---------------------------------------------------------------------------
.text$mn:0000164A                 align 4
.text$mn:0000164A _text$mn        ends
.text$mn:0000164A
.text$mn:0000164C ; ===========================================================================
.text$mn:0000164C
.text$mn:0000164C ; Segment type: Pure code
.text$mn:0000164C ; Segment permissions: Read/Execute
.text$mn:0000164C _text$mn        segment para public 'CODE' use32
.text$mn:0000164C                 assume cs:_text$mn
.text$mn:0000164C                 ;org 164Ch
.text$mn:0000164C ; COMDAT (pick any)
.text$mn:0000164C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000164C
.text$mn:0000164C ; =============== S U B R O U T I N E =======================================
.text$mn:0000164C
.text$mn:0000164C ; Attributes: bp-based frame
.text$mn:0000164C
.text$mn:0000164C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>>>(struct TaskLstFnStatus *, struct TaskLstFnStatus *, struct std::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>> &)
.text$mn:0000164C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@@Z
.text$mn:0000164C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@@Z proc near
.text$mn:0000164C                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Destroy(TaskLstFnStatus *,TaskLstFnStatus *)+21p
.text$mn:0000164C
.text$mn:0000164C var_1           = byte ptr -1
.text$mn:0000164C arg_0           = dword ptr  8
.text$mn:0000164C arg_4           = dword ptr  0Ch
.text$mn:0000164C arg_8           = dword ptr  10h
.text$mn:0000164C
.text$mn:0000164C                 push    ebp
.text$mn:0000164D                 mov     ebp, esp
.text$mn:0000164F                 push    ecx
.text$mn:00001650                 mov     eax, [ebp+arg_4]
.text$mn:00001653                 push    eax
.text$mn:00001654                 mov     ecx, [ebp+arg_0]
.text$mn:00001657                 push    ecx
.text$mn:00001658                 call    ??$_Ptr_cat@UTaskLstFnStatus@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTaskLstFnStatus@@0@Z ; std::_Ptr_cat<TaskLstFnStatus,TaskLstFnStatus>(TaskLstFnStatus *,TaskLstFnStatus *)
.text$mn:0000165D                 add     esp, 8
.text$mn:00001660                 mov     [ebp+var_1], al
.text$mn:00001663                 movzx   edx, [ebp+var_1]
.text$mn:00001667                 push    edx
.text$mn:00001668                 mov     eax, [ebp+arg_8]
.text$mn:0000166B                 push    eax
.text$mn:0000166C                 mov     ecx, [ebp+arg_4]
.text$mn:0000166F                 push    ecx
.text$mn:00001670                 mov     edx, [ebp+arg_0]
.text$mn:00001673                 push    edx
.text$mn:00001674                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001679                 add     esp, 10h
.text$mn:0000167C                 mov     esp, ebp
.text$mn:0000167E                 pop     ebp
.text$mn:0000167F                 retn
.text$mn:0000167F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@@Z endp
.text$mn:0000167F
.text$mn:0000167F _text$mn        ends
.text$mn:0000167F
.text$mn:00001680 ; ===========================================================================
.text$mn:00001680
.text$mn:00001680 ; Segment type: Pure code
.text$mn:00001680 ; Segment permissions: Read/Execute
.text$mn:00001680 _text$mn        segment para public 'CODE' use32
.text$mn:00001680                 assume cs:_text$mn
.text$mn:00001680                 ;org 1680h
.text$mn:00001680 ; COMDAT (pick any)
.text$mn:00001680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001680
.text$mn:00001680 ; =============== S U B R O U T I N E =======================================
.text$mn:00001680
.text$mn:00001680 ; Attributes: bp-based frame
.text$mn:00001680
.text$mn:00001680 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>>>(struct TaskLstFnStatus *, struct TaskLstFnStatus *, struct std::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001680                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001680 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001680                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &)+28p
.text$mn:00001680
.text$mn:00001680 arg_0           = dword ptr  8
.text$mn:00001680 arg_4           = dword ptr  0Ch
.text$mn:00001680 arg_8           = dword ptr  10h
.text$mn:00001680
.text$mn:00001680                 push    ebp
.text$mn:00001681                 mov     ebp, esp
.text$mn:00001683                 jmp     short loc_168E
.text$mn:00001685 ; ---------------------------------------------------------------------------
.text$mn:00001685
.text$mn:00001685 loc_1685:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00001685                 mov     eax, [ebp+arg_0]
.text$mn:00001688                 add     eax, 2Ch ; ','
.text$mn:0000168B                 mov     [ebp+arg_0], eax
.text$mn:0000168E
.text$mn:0000168E loc_168E:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000168E                 mov     ecx, [ebp+arg_0]
.text$mn:00001691                 cmp     ecx, [ebp+arg_4]
.text$mn:00001694                 jz      short loc_16A4
.text$mn:00001696                 mov     edx, [ebp+arg_0]
.text$mn:00001699                 push    edx
.text$mn:0000169A                 mov     ecx, [ebp+arg_8]
.text$mn:0000169D                 call    ??$destroy@UTaskLstFnStatus@@@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@@Z ; std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>::destroy<TaskLstFnStatus>(TaskLstFnStatus *)
.text$mn:000016A2                 jmp     short loc_1685
.text$mn:000016A4 ; ---------------------------------------------------------------------------
.text$mn:000016A4
.text$mn:000016A4 loc_16A4:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:000016A4                 pop     ebp
.text$mn:000016A5                 retn
.text$mn:000016A5 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000016A5
.text$mn:000016A5 ; ---------------------------------------------------------------------------
.text$mn:000016A6                 align 4
.text$mn:000016A6 _text$mn        ends
.text$mn:000016A6
.text$mn:000016A8 ; ===========================================================================
.text$mn:000016A8
.text$mn:000016A8 ; Segment type: Pure code
.text$mn:000016A8 ; Segment permissions: Read/Execute
.text$mn:000016A8 _text$mn        segment para public 'CODE' use32
.text$mn:000016A8                 assume cs:_text$mn
.text$mn:000016A8                 ;org 16A8h
.text$mn:000016A8 ; COMDAT (pick any)
.text$mn:000016A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016A8
.text$mn:000016A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016A8
.text$mn:000016A8 ; Attributes: bp-based frame
.text$mn:000016A8
.text$mn:000016A8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct SwitcherFileInfo *>(struct SwitcherFileInfo * const &)
.text$mn:000016A8                 public ??$_Iter_cat@PAUSwitcherFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSwitcherFileInfo@@@Z
.text$mn:000016A8 ??$_Iter_cat@PAUSwitcherFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSwitcherFileInfo@@@Z proc near
.text$mn:000016A8                                         ; CODE XREF: std::_Debug_range<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint)+Cp
.text$mn:000016A8
.text$mn:000016A8 var_1           = byte ptr -1
.text$mn:000016A8 arg_0           = dword ptr  8
.text$mn:000016A8
.text$mn:000016A8                 push    ebp
.text$mn:000016A9                 mov     ebp, esp
.text$mn:000016AB                 push    ecx
.text$mn:000016AC                 mov     eax, [ebp+arg_0]
.text$mn:000016AF                 mov     cl, [ebp+var_1]
.text$mn:000016B2                 mov     [eax], cl
.text$mn:000016B4                 mov     eax, [ebp+arg_0]
.text$mn:000016B7                 mov     esp, ebp
.text$mn:000016B9                 pop     ebp
.text$mn:000016BA                 retn
.text$mn:000016BA ??$_Iter_cat@PAUSwitcherFileInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSwitcherFileInfo@@@Z endp
.text$mn:000016BA
.text$mn:000016BA ; ---------------------------------------------------------------------------
.text$mn:000016BB                 align 4
.text$mn:000016BB _text$mn        ends
.text$mn:000016BB
.text$mn:000016BC ; ===========================================================================
.text$mn:000016BC
.text$mn:000016BC ; Segment type: Pure code
.text$mn:000016BC ; Segment permissions: Read/Execute
.text$mn:000016BC _text$mn        segment para public 'CODE' use32
.text$mn:000016BC                 assume cs:_text$mn
.text$mn:000016BC                 ;org 16BCh
.text$mn:000016BC ; COMDAT (pick any)
.text$mn:000016BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016BC
.text$mn:000016BC ; =============== S U B R O U T I N E =======================================
.text$mn:000016BC
.text$mn:000016BC ; Attributes: bp-based frame
.text$mn:000016BC
.text$mn:000016BC ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct SwitcherFileInfo, struct SwitcherFileInfo>(struct SwitcherFileInfo *, struct SwitcherFileInfo *)
.text$mn:000016BC                 public ??$_Ptr_cat@USwitcherFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSwitcherFileInfo@@0@Z
.text$mn:000016BC ??$_Ptr_cat@USwitcherFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSwitcherFileInfo@@0@Z proc near
.text$mn:000016BC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+Cp
.text$mn:000016BC                                         ; std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+Cp
.text$mn:000016BC
.text$mn:000016BC var_1           = byte ptr -1
.text$mn:000016BC
.text$mn:000016BC                 push    ebp
.text$mn:000016BD                 mov     ebp, esp
.text$mn:000016BF                 push    ecx
.text$mn:000016C0                 mov     al, [ebp+var_1]
.text$mn:000016C3                 mov     esp, ebp
.text$mn:000016C5                 pop     ebp
.text$mn:000016C6                 retn
.text$mn:000016C6 ??$_Ptr_cat@USwitcherFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSwitcherFileInfo@@0@Z endp
.text$mn:000016C6
.text$mn:000016C6 ; ---------------------------------------------------------------------------
.text$mn:000016C7                 align 4
.text$mn:000016C7 _text$mn        ends
.text$mn:000016C7
.text$mn:000016C8 ; ===========================================================================
.text$mn:000016C8
.text$mn:000016C8 ; Segment type: Pure code
.text$mn:000016C8 ; Segment permissions: Read/Execute
.text$mn:000016C8 _text$mn        segment para public 'CODE' use32
.text$mn:000016C8                 assume cs:_text$mn
.text$mn:000016C8                 ;org 16C8h
.text$mn:000016C8 ; COMDAT (pick any)
.text$mn:000016C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016C8
.text$mn:000016C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016C8
.text$mn:000016C8 ; Attributes: bp-based frame
.text$mn:000016C8
.text$mn:000016C8 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct TaskLstFnStatus, struct TaskLstFnStatus>(struct TaskLstFnStatus *, struct TaskLstFnStatus *)
.text$mn:000016C8                 public ??$_Ptr_cat@UTaskLstFnStatus@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTaskLstFnStatus@@0@Z
.text$mn:000016C8 ??$_Ptr_cat@UTaskLstFnStatus@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTaskLstFnStatus@@0@Z proc near
.text$mn:000016C8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &)+Cp
.text$mn:000016C8
.text$mn:000016C8 var_1           = byte ptr -1
.text$mn:000016C8
.text$mn:000016C8                 push    ebp
.text$mn:000016C9                 mov     ebp, esp
.text$mn:000016CB                 push    ecx
.text$mn:000016CC                 mov     al, [ebp+var_1]
.text$mn:000016CF                 mov     esp, ebp
.text$mn:000016D1                 pop     ebp
.text$mn:000016D2                 retn
.text$mn:000016D2 ??$_Ptr_cat@UTaskLstFnStatus@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTaskLstFnStatus@@0@Z endp
.text$mn:000016D2
.text$mn:000016D2 ; ---------------------------------------------------------------------------
.text$mn:000016D3                 align 4
.text$mn:000016D3 _text$mn        ends
.text$mn:000016D3
.text$mn:000016D4 ; ===========================================================================
.text$mn:000016D4
.text$mn:000016D4 ; Segment type: Pure code
.text$mn:000016D4 ; Segment permissions: Read/Execute
.text$mn:000016D4 _text$mn        segment para public 'CODE' use32
.text$mn:000016D4                 assume cs:_text$mn
.text$mn:000016D4                 ;org 16D4h
.text$mn:000016D4 ; COMDAT (pick any)
.text$mn:000016D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016D4
.text$mn:000016D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016D4
.text$mn:000016D4 ; Attributes: bp-based frame
.text$mn:000016D4
.text$mn:000016D4 ; struct SwitcherFileInfo * & __cdecl std::_Rechecked<struct SwitcherFileInfo *, struct SwitcherFileInfo *>(struct SwitcherFileInfo * &, struct SwitcherFileInfo *)
.text$mn:000016D4                 public ??$_Rechecked@PAUSwitcherFileInfo@@PAU1@@std@@YAAAPAUSwitcherFileInfo@@AAPAU1@PAU1@@Z
.text$mn:000016D4 ??$_Rechecked@PAUSwitcherFileInfo@@PAU1@@std@@YAAAPAUSwitcherFileInfo@@AAPAU1@PAU1@@Z proc near
.text$mn:000016D4                                         ; CODE XREF: std::_Uninitialized_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+3Bp
.text$mn:000016D4
.text$mn:000016D4 arg_0           = dword ptr  8
.text$mn:000016D4 arg_4           = dword ptr  0Ch
.text$mn:000016D4
.text$mn:000016D4                 push    ebp
.text$mn:000016D5                 mov     ebp, esp
.text$mn:000016D7                 mov     eax, [ebp+arg_0]
.text$mn:000016DA                 mov     ecx, [ebp+arg_4]
.text$mn:000016DD                 mov     [eax], ecx
.text$mn:000016DF                 mov     eax, [ebp+arg_0]
.text$mn:000016E2                 pop     ebp
.text$mn:000016E3                 retn
.text$mn:000016E3 ??$_Rechecked@PAUSwitcherFileInfo@@PAU1@@std@@YAAAPAUSwitcherFileInfo@@AAPAU1@PAU1@@Z endp
.text$mn:000016E3
.text$mn:000016E3 _text$mn        ends
.text$mn:000016E3
.text$mn:000016E4 ; ===========================================================================
.text$mn:000016E4
.text$mn:000016E4 ; Segment type: Pure code
.text$mn:000016E4 ; Segment permissions: Read/Execute
.text$mn:000016E4 _text$mn        segment para public 'CODE' use32
.text$mn:000016E4                 assume cs:_text$mn
.text$mn:000016E4                 ;org 16E4h
.text$mn:000016E4 ; COMDAT (pick any)
.text$mn:000016E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016E4
.text$mn:000016E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E4
.text$mn:000016E4 ; Attributes: bp-based frame
.text$mn:000016E4
.text$mn:000016E4 ; protected: struct SwitcherFileInfo * __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Umove<struct SwitcherFileInfo *>(struct SwitcherFileInfo *, struct SwitcherFileInfo *, struct SwitcherFileInfo *)
.text$mn:000016E4                 public ??$_Umove@PAUSwitcherFileInfo@@@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEPAUSwitcherFileInfo@@PAU2@00@Z
.text$mn:000016E4 ??$_Umove@PAUSwitcherFileInfo@@@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEPAUSwitcherFileInfo@@PAU2@00@Z proc near
.text$mn:000016E4                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+65p
.text$mn:000016E4
.text$mn:000016E4 var_8           = dword ptr -8
.text$mn:000016E4 var_1           = byte ptr -1
.text$mn:000016E4 arg_0           = dword ptr  8
.text$mn:000016E4 arg_4           = dword ptr  0Ch
.text$mn:000016E4 arg_8           = dword ptr  10h
.text$mn:000016E4
.text$mn:000016E4                 push    ebp
.text$mn:000016E5                 mov     ebp, esp
.text$mn:000016E7                 sub     esp, 8
.text$mn:000016EA                 mov     [ebp+var_8], ecx
.text$mn:000016ED                 lea     eax, [ebp+var_1]
.text$mn:000016F0                 push    eax
.text$mn:000016F1                 mov     ecx, [ebp+var_8]
.text$mn:000016F4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:000016F9                 lea     ecx, [ebp+var_1]
.text$mn:000016FC                 push    ecx
.text$mn:000016FD                 mov     edx, [ebp+arg_8]
.text$mn:00001700                 push    edx
.text$mn:00001701                 mov     eax, [ebp+arg_4]
.text$mn:00001704                 push    eax
.text$mn:00001705                 mov     ecx, [ebp+arg_0]
.text$mn:00001708                 push    ecx
.text$mn:00001709                 call    ??$_Uninitialized_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z ; std::_Uninitialized_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)
.text$mn:0000170E                 add     esp, 10h
.text$mn:00001711                 mov     esp, ebp
.text$mn:00001713                 pop     ebp
.text$mn:00001714                 retn    0Ch
.text$mn:00001714 ??$_Umove@PAUSwitcherFileInfo@@@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEPAUSwitcherFileInfo@@PAU2@00@Z endp
.text$mn:00001714
.text$mn:00001714 ; ---------------------------------------------------------------------------
.text$mn:00001717                 align 4
.text$mn:00001717 _text$mn        ends
.text$mn:00001717
.text$mn:00001718 ; ===========================================================================
.text$mn:00001718
.text$mn:00001718 ; Segment type: Pure code
.text$mn:00001718 ; Segment permissions: Read/Execute
.text$mn:00001718 _text$mn        segment para public 'CODE' use32
.text$mn:00001718                 assume cs:_text$mn
.text$mn:00001718                 ;org 1718h
.text$mn:00001718 ; COMDAT (pick any)
.text$mn:00001718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001718
.text$mn:00001718 ; =============== S U B R O U T I N E =======================================
.text$mn:00001718
.text$mn:00001718 ; Attributes: bp-based frame
.text$mn:00001718
.text$mn:00001718 ; struct SwitcherFileInfo * __cdecl std::_Unchecked<struct SwitcherFileInfo *>(struct SwitcherFileInfo *)
.text$mn:00001718                 public ??$_Unchecked@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z
.text$mn:00001718 ??$_Unchecked@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z proc near
.text$mn:00001718                                         ; CODE XREF: std::_Uninitialized_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+Bp
.text$mn:00001718                                         ; std::_Uninitialized_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+18p ...
.text$mn:00001718
.text$mn:00001718 arg_0           = dword ptr  8
.text$mn:00001718
.text$mn:00001718                 push    ebp
.text$mn:00001719                 mov     ebp, esp
.text$mn:0000171B                 mov     eax, [ebp+arg_0]
.text$mn:0000171E                 pop     ebp
.text$mn:0000171F                 retn
.text$mn:0000171F ??$_Unchecked@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z endp
.text$mn:0000171F
.text$mn:0000171F _text$mn        ends
.text$mn:0000171F
.text$mn:00001720 ; ===========================================================================
.text$mn:00001720
.text$mn:00001720 ; Segment type: Pure code
.text$mn:00001720 ; Segment permissions: Read/Execute
.text$mn:00001720 _text$mn        segment para public 'CODE' use32
.text$mn:00001720                 assume cs:_text$mn
.text$mn:00001720                 ;org 1720h
.text$mn:00001720 ; COMDAT (pick any)
.text$mn:00001720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001720
.text$mn:00001720 ; =============== S U B R O U T I N E =======================================
.text$mn:00001720
.text$mn:00001720 ; Attributes: bp-based frame
.text$mn:00001720
.text$mn:00001720 ; int __cdecl std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(int, int, void *, int)
.text$mn:00001720                 public ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z
.text$mn:00001720 ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z proc near
.text$mn:00001720                                         ; CODE XREF: std::_Uninitialized_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+2Ep
.text$mn:00001720
.text$mn:00001720 var_1           = byte ptr -1
.text$mn:00001720 arg_0           = dword ptr  8
.text$mn:00001720 arg_4           = dword ptr  0Ch
.text$mn:00001720 arg_8           = dword ptr  10h
.text$mn:00001720 arg_C           = dword ptr  14h
.text$mn:00001720
.text$mn:00001720                 push    ebp
.text$mn:00001721                 mov     ebp, esp
.text$mn:00001723                 push    ecx
.text$mn:00001724                 mov     eax, [ebp+arg_8]
.text$mn:00001727                 push    eax
.text$mn:00001728                 mov     ecx, [ebp+arg_0]
.text$mn:0000172B                 push    ecx
.text$mn:0000172C                 call    ??$_Ptr_cat@USwitcherFileInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSwitcherFileInfo@@0@Z ; std::_Ptr_cat<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *)
.text$mn:00001731                 add     esp, 8
.text$mn:00001734                 mov     [ebp+var_1], al
.text$mn:00001737                 movzx   edx, [ebp+var_1]
.text$mn:0000173B                 push    edx
.text$mn:0000173C                 mov     eax, [ebp+arg_0]
.text$mn:0000173F                 push    eax
.text$mn:00001740                 call    ??$_Val_type@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z ; std::_Val_type<SwitcherFileInfo *>(SwitcherFileInfo *)
.text$mn:00001745                 add     esp, 4
.text$mn:00001748                 push    eax
.text$mn:00001749                 mov     ecx, [ebp+arg_C]
.text$mn:0000174C                 push    ecx             ; int
.text$mn:0000174D                 mov     edx, [ebp+arg_8]
.text$mn:00001750                 push    edx             ; void *
.text$mn:00001751                 mov     eax, [ebp+arg_4]
.text$mn:00001754                 push    eax             ; int
.text$mn:00001755                 mov     ecx, [ebp+arg_0]
.text$mn:00001758                 push    ecx             ; int
.text$mn:00001759                 call    ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000175E                 add     esp, 18h
.text$mn:00001761                 mov     esp, ebp
.text$mn:00001763                 pop     ebp
.text$mn:00001764                 retn
.text$mn:00001764 ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z endp
.text$mn:00001764
.text$mn:00001764 ; ---------------------------------------------------------------------------
.text$mn:00001765                 align 4
.text$mn:00001765 _text$mn        ends
.text$mn:00001765
.text$mn:00001768 ; ===========================================================================
.text$mn:00001768
.text$mn:00001768 ; Segment type: Pure code
.text$mn:00001768 ; Segment permissions: Read/Execute
.text$mn:00001768 _text$mn        segment para public 'CODE' use32
.text$mn:00001768                 assume cs:_text$mn
.text$mn:00001768                 ;org 1768h
.text$mn:00001768 ; COMDAT (pick any)
.text$mn:00001768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001768
.text$mn:00001768 ; =============== S U B R O U T I N E =======================================
.text$mn:00001768
.text$mn:00001768 ; Attributes: bp-based frame
.text$mn:00001768
.text$mn:00001768 ; int __cdecl std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(int, int, void *, int)
.text$mn:00001768                 public ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001768 ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001768                                         ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+39p
.text$mn:00001768
.text$mn:00001768 var_14          = dword ptr -14h
.text$mn:00001768 var_10          = dword ptr -10h
.text$mn:00001768 var_C           = dword ptr -0Ch
.text$mn:00001768 var_4           = dword ptr -4
.text$mn:00001768 arg_0           = dword ptr  8
.text$mn:00001768 arg_4           = dword ptr  0Ch
.text$mn:00001768 arg_8           = dword ptr  10h
.text$mn:00001768 arg_C           = dword ptr  14h
.text$mn:00001768
.text$mn:00001768 ; FUNCTION CHUNK AT .text$mn:0000182F SIZE 00000009 BYTES
.text$mn:00001768 ; FUNCTION CHUNK AT .text$mn:0000183F SIZE 00000015 BYTES
.text$mn:00001768
.text$mn:00001768                 push    ebp
.text$mn:00001769                 mov     ebp, esp
.text$mn:0000176B                 push    0FFFFFFFFh
.text$mn:0000176D                 push    offset __ehhandler$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001772                 mov     eax, large fs:0
.text$mn:00001778                 push    eax
.text$mn:00001779                 push    ecx
.text$mn:0000177A                 push    ecx
.text$mn:0000177B                 push    ebx
.text$mn:0000177C                 push    esi
.text$mn:0000177D                 push    edi
.text$mn:0000177E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001783                 xor     eax, ebp
.text$mn:00001785                 push    eax
.text$mn:00001786                 lea     eax, [ebp+var_C]
.text$mn:00001789                 mov     large fs:0, eax
.text$mn:0000178F                 mov     [ebp+var_10], esp
.text$mn:00001792                 push    1B6h            ; unsigned int
.text$mn:00001797                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000179C                 mov     eax, [ebp+arg_4]
.text$mn:0000179F                 push    eax             ; int
.text$mn:000017A0                 mov     ecx, [ebp+arg_0]
.text$mn:000017A3                 push    ecx             ; int
.text$mn:000017A4                 call    ??$_Debug_range@PAUSwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@0PB_WI@Z ; std::_Debug_range<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint)
.text$mn:000017A9                 add     esp, 10h
.text$mn:000017AC                 push    1B7h            ; unsigned int
.text$mn:000017B1                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000017B6                 mov     edx, [ebp+arg_8]
.text$mn:000017B9                 push    edx             ; int
.text$mn:000017BA                 call    ??$_Debug_pointer@USwitcherFileInfo@@@std@@YAXPAUSwitcherFileInfo@@PB_WI@Z ; std::_Debug_pointer<SwitcherFileInfo>(SwitcherFileInfo *,wchar_t const *,uint)
.text$mn:000017BF                 add     esp, 0Ch
.text$mn:000017C2                 mov     eax, [ebp+arg_8]
.text$mn:000017C5                 mov     [ebp+var_14], eax
.text$mn:000017C8                 mov     [ebp+var_4], 0
.text$mn:000017CF                 jmp     short loc_17E3
.text$mn:000017D1 ; ---------------------------------------------------------------------------
.text$mn:000017D1
.text$mn:000017D1 loc_17D1:                               ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000017D1                 mov     ecx, [ebp+arg_8]
.text$mn:000017D4                 add     ecx, 8
.text$mn:000017D7                 mov     [ebp+arg_8], ecx
.text$mn:000017DA                 mov     edx, [ebp+arg_0]
.text$mn:000017DD                 add     edx, 8
.text$mn:000017E0                 mov     [ebp+arg_0], edx
.text$mn:000017E3
.text$mn:000017E3 loc_17E3:                               ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000017E3                 mov     eax, [ebp+arg_0]
.text$mn:000017E6                 cmp     eax, [ebp+arg_4]
.text$mn:000017E9                 jz      short loc_17FD
.text$mn:000017EB                 mov     ecx, [ebp+arg_0]
.text$mn:000017EE                 push    ecx             ; int
.text$mn:000017EF                 mov     edx, [ebp+arg_8]
.text$mn:000017F2                 push    edx             ; void *
.text$mn:000017F3                 mov     ecx, [ebp+arg_C]
.text$mn:000017F6                 call    ??$construct@USwitcherFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)
.text$mn:000017FB                 jmp     short loc_17D1
.text$mn:000017FD ; ---------------------------------------------------------------------------
.text$mn:000017FD
.text$mn:000017FD loc_17FD:                               ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:000017FD                 jmp     short loc_182F
.text$mn:000017FD ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000017FD
.text$mn:000017FF
.text$mn:000017FF ; =============== S U B R O U T I N E =======================================
.text$mn:000017FF
.text$mn:000017FF ; Attributes: noreturn
.text$mn:000017FF
.text$mn:000017FF __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:000017FF                                         ; DATA XREF: .xdata$x:00006364o
.text$mn:000017FF                 jmp     short loc_180A
.text$mn:00001801 ; ---------------------------------------------------------------------------
.text$mn:00001801
.text$mn:00001801 loc_1801:                               ; CODE XREF: __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00001801                 mov     eax, [ebp-14h]
.text$mn:00001804                 add     eax, 8
.text$mn:00001807                 mov     [ebp-14h], eax
.text$mn:0000180A
.text$mn:0000180A loc_180A:                               ; CODE XREF: __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:0000180A                 mov     ecx, [ebp-14h]
.text$mn:0000180D                 cmp     ecx, [ebp+10h]
.text$mn:00001810                 jz      short loc_1820
.text$mn:00001812                 mov     edx, [ebp-14h]
.text$mn:00001815                 push    edx
.text$mn:00001816                 mov     ecx, [ebp+14h]
.text$mn:00001819                 call    ??$destroy@USwitcherFileInfo@@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::destroy<SwitcherFileInfo>(SwitcherFileInfo *)
.text$mn:0000181E                 jmp     short loc_1801
.text$mn:00001820 ; ---------------------------------------------------------------------------
.text$mn:00001820
.text$mn:00001820 loc_1820:                               ; CODE XREF: __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00001820                 push    0
.text$mn:00001822                 push    0
.text$mn:00001824                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001824 __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00001824
.text$mn:00001829 ; ---------------------------------------------------------------------------
.text$mn:00001829                 mov     eax, offset $LN13
.text$mn:0000182E                 retn
.text$mn:0000182F ; ---------------------------------------------------------------------------
.text$mn:0000182F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000182F
.text$mn:0000182F loc_182F:                               ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag):loc_17FDj
.text$mn:0000182F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001836                 jmp     short loc_183F
.text$mn:00001836 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001838
.text$mn:00001838 ; =============== S U B R O U T I N E =======================================
.text$mn:00001838
.text$mn:00001838
.text$mn:00001838 $LN13           proc near               ; DATA XREF: .text$mn:00001829o
.text$mn:00001838                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001838 $LN13           endp ; sp-analysis failed
.text$mn:00001838
.text$mn:0000183F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000183F
.text$mn:0000183F loc_183F:                               ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:0000183F                 mov     eax, [ebp+arg_8]
.text$mn:00001842                 mov     ecx, [ebp+var_C]
.text$mn:00001845                 mov     large fs:0, ecx
.text$mn:0000184C                 pop     ecx
.text$mn:0000184D                 pop     edi
.text$mn:0000184E                 pop     esi
.text$mn:0000184F                 pop     ebx
.text$mn:00001850                 mov     esp, ebp
.text$mn:00001852                 pop     ebp
.text$mn:00001853                 retn
.text$mn:00001853 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001853 _text$mn        ends
.text$mn:00001853
.text$x:00001854 ; ===========================================================================
.text$x:00001854
.text$x:00001854 ; Segment type: Pure code
.text$x:00001854 ; Segment permissions: Read/Execute
.text$x:00001854 _text$x         segment para public 'CODE' use32
.text$x:00001854                 assume cs:_text$x
.text$x:00001854                 ;org 1854h
.text$x:00001854 ; COMDAT (pick associative to section at 1768)
.text$x:00001854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001854
.text$x:00001854 ; =============== S U B R O U T I N E =======================================
.text$x:00001854
.text$x:00001854
.text$x:00001854 __ehhandler$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00001854                                         ; DATA XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00001854
.text$x:00001854 arg_4           = dword ptr  8
.text$x:00001854
.text$x:00001854                 mov     edx, [esp+arg_4]
.text$x:00001858                 lea     eax, [edx+0Ch]
.text$x:0000185B                 mov     ecx, [edx-18h]
.text$x:0000185E                 xor     ecx, eax
.text$x:00001860                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001865                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000186A                 jmp     ___CxxFrameHandler3
.text$x:0000186A __ehhandler$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000186A
.text$x:0000186A ; ---------------------------------------------------------------------------
.text$x:0000186F                 align 10h
.text$x:0000186F _text$x         ends
.text$x:0000186F
.text$mn:00001870 ; ===========================================================================
.text$mn:00001870
.text$mn:00001870 ; Segment type: Pure code
.text$mn:00001870 ; Segment permissions: Read/Execute
.text$mn:00001870 _text$mn        segment para public 'CODE' use32
.text$mn:00001870                 assume cs:_text$mn
.text$mn:00001870                 ;org 1870h
.text$mn:00001870 ; COMDAT (pick any)
.text$mn:00001870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001870
.text$mn:00001870 ; =============== S U B R O U T I N E =======================================
.text$mn:00001870
.text$mn:00001870 ; Attributes: bp-based frame
.text$mn:00001870
.text$mn:00001870 ; struct SwitcherFileInfo * __cdecl std::_Uninitialized_move<struct SwitcherFileInfo *, struct SwitcherFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>>(struct SwitcherFileInfo *, struct SwitcherFileInfo *, struct SwitcherFileInfo *, struct std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>> &)
.text$mn:00001870                 public ??$_Uninitialized_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z
.text$mn:00001870 ??$_Uninitialized_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z proc near
.text$mn:00001870                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Umove<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *)+25p
.text$mn:00001870
.text$mn:00001870 arg_0           = dword ptr  8
.text$mn:00001870 arg_4           = dword ptr  0Ch
.text$mn:00001870 arg_8           = dword ptr  10h
.text$mn:00001870 arg_C           = dword ptr  14h
.text$mn:00001870
.text$mn:00001870                 push    ebp
.text$mn:00001871                 mov     ebp, esp
.text$mn:00001873                 mov     eax, [ebp+arg_C]
.text$mn:00001876                 push    eax             ; int
.text$mn:00001877                 mov     ecx, [ebp+arg_8]
.text$mn:0000187A                 push    ecx
.text$mn:0000187B                 call    ??$_Unchecked@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z ; std::_Unchecked<SwitcherFileInfo *>(SwitcherFileInfo *)
.text$mn:00001880                 add     esp, 4
.text$mn:00001883                 push    eax             ; void *
.text$mn:00001884                 mov     edx, [ebp+arg_4]
.text$mn:00001887                 push    edx
.text$mn:00001888                 call    ??$_Unchecked@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z ; std::_Unchecked<SwitcherFileInfo *>(SwitcherFileInfo *)
.text$mn:0000188D                 add     esp, 4
.text$mn:00001890                 push    eax             ; int
.text$mn:00001891                 mov     eax, [ebp+arg_0]
.text$mn:00001894                 push    eax
.text$mn:00001895                 call    ??$_Unchecked@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z ; std::_Unchecked<SwitcherFileInfo *>(SwitcherFileInfo *)
.text$mn:0000189A                 add     esp, 4
.text$mn:0000189D                 push    eax             ; int
.text$mn:0000189E                 call    ??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z ; std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)
.text$mn:000018A3                 add     esp, 10h
.text$mn:000018A6                 push    eax
.text$mn:000018A7                 lea     ecx, [ebp+arg_8]
.text$mn:000018AA                 push    ecx
.text$mn:000018AB                 call    ??$_Rechecked@PAUSwitcherFileInfo@@PAU1@@std@@YAAAPAUSwitcherFileInfo@@AAPAU1@PAU1@@Z ; std::_Rechecked<SwitcherFileInfo *,SwitcherFileInfo *>(SwitcherFileInfo * &,SwitcherFileInfo *)
.text$mn:000018B0                 add     esp, 8
.text$mn:000018B3                 mov     eax, [eax]
.text$mn:000018B5                 pop     ebp
.text$mn:000018B6                 retn
.text$mn:000018B6 ??$_Uninitialized_move@PAUSwitcherFileInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z endp
.text$mn:000018B6
.text$mn:000018B6 ; ---------------------------------------------------------------------------
.text$mn:000018B7                 align 4
.text$mn:000018B7 _text$mn        ends
.text$mn:000018B7
.text$mn:000018B8 ; ===========================================================================
.text$mn:000018B8
.text$mn:000018B8 ; Segment type: Pure code
.text$mn:000018B8 ; Segment permissions: Read/Execute
.text$mn:000018B8 _text$mn        segment para public 'CODE' use32
.text$mn:000018B8                 assume cs:_text$mn
.text$mn:000018B8                 ;org 18B8h
.text$mn:000018B8 ; COMDAT (pick any)
.text$mn:000018B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018B8
.text$mn:000018B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B8
.text$mn:000018B8 ; Attributes: bp-based frame
.text$mn:000018B8
.text$mn:000018B8 ; struct SwitcherFileInfo * __cdecl std::_Val_type<struct SwitcherFileInfo *>(struct SwitcherFileInfo *)
.text$mn:000018B8                 public ??$_Val_type@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z
.text$mn:000018B8 ??$_Val_type@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z proc near
.text$mn:000018B8                                         ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)+20p
.text$mn:000018B8                 push    ebp
.text$mn:000018B9                 mov     ebp, esp
.text$mn:000018BB                 xor     eax, eax
.text$mn:000018BD                 pop     ebp
.text$mn:000018BE                 retn
.text$mn:000018BE ??$_Val_type@PAUSwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@PAU1@@Z endp
.text$mn:000018BE
.text$mn:000018BE ; ---------------------------------------------------------------------------
.text$mn:000018BF                 align 10h
.text$mn:000018BF _text$mn        ends
.text$mn:000018BF
.text$mn:000018C0 ; ===========================================================================
.text$mn:000018C0
.text$mn:000018C0 ; Segment type: Pure code
.text$mn:000018C0 ; Segment permissions: Read/Execute
.text$mn:000018C0 _text$mn        segment para public 'CODE' use32
.text$mn:000018C0                 assume cs:_text$mn
.text$mn:000018C0                 ;org 18C0h
.text$mn:000018C0 ; COMDAT (pick any)
.text$mn:000018C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018C0
.text$mn:000018C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C0
.text$mn:000018C0 ; Attributes: bp-based frame
.text$mn:000018C0
.text$mn:000018C0 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000018C0                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000018C0 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000018C0                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000018C0                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000018C0
.text$mn:000018C0 arg_0           = dword ptr  8
.text$mn:000018C0
.text$mn:000018C0                 push    ebp
.text$mn:000018C1                 mov     ebp, esp
.text$mn:000018C3                 mov     eax, [ebp+arg_0]
.text$mn:000018C6                 pop     ebp
.text$mn:000018C7                 retn
.text$mn:000018C7 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000018C7
.text$mn:000018C7 _text$mn        ends
.text$mn:000018C7
.text$mn:000018C8 ; ===========================================================================
.text$mn:000018C8
.text$mn:000018C8 ; Segment type: Pure code
.text$mn:000018C8 ; Segment permissions: Read/Execute
.text$mn:000018C8 _text$mn        segment para public 'CODE' use32
.text$mn:000018C8                 assume cs:_text$mn
.text$mn:000018C8                 ;org 18C8h
.text$mn:000018C8 ; COMDAT (pick any)
.text$mn:000018C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018C8
.text$mn:000018C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C8
.text$mn:000018C8 ; Attributes: bp-based frame
.text$mn:000018C8
.text$mn:000018C8 ; struct SwitcherFileInfo * __cdecl std::addressof<struct SwitcherFileInfo>(struct SwitcherFileInfo &)
.text$mn:000018C8                 public ??$addressof@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@AAU1@@Z
.text$mn:000018C8 ??$addressof@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@AAU1@@Z proc near
.text$mn:000018C8                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+Dp
.text$mn:000018C8                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+2Dp
.text$mn:000018C8
.text$mn:000018C8 arg_0           = dword ptr  8
.text$mn:000018C8
.text$mn:000018C8                 push    ebp
.text$mn:000018C9                 mov     ebp, esp
.text$mn:000018CB                 mov     eax, [ebp+arg_0]
.text$mn:000018CE                 pop     ebp
.text$mn:000018CF                 retn
.text$mn:000018CF ??$addressof@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@AAU1@@Z endp
.text$mn:000018CF
.text$mn:000018CF _text$mn        ends
.text$mn:000018CF
.text$mn:000018D0 ; ===========================================================================
.text$mn:000018D0
.text$mn:000018D0 ; Segment type: Pure code
.text$mn:000018D0 ; Segment permissions: Read/Execute
.text$mn:000018D0 _text$mn        segment para public 'CODE' use32
.text$mn:000018D0                 assume cs:_text$mn
.text$mn:000018D0                 ;org 18D0h
.text$mn:000018D0 ; COMDAT (pick any)
.text$mn:000018D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018D0
.text$mn:000018D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018D0
.text$mn:000018D0 ; Attributes: bp-based frame
.text$mn:000018D0
.text$mn:000018D0 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000018D0                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000018D0 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000018D0                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000018D0                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000018D0
.text$mn:000018D0 arg_0           = dword ptr  8
.text$mn:000018D0
.text$mn:000018D0                 push    ebp
.text$mn:000018D1                 mov     ebp, esp
.text$mn:000018D3                 mov     eax, [ebp+arg_0]
.text$mn:000018D6                 pop     ebp
.text$mn:000018D7                 retn
.text$mn:000018D7 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000018D7
.text$mn:000018D7 _text$mn        ends
.text$mn:000018D7
.text$mn:000018D8 ; ===========================================================================
.text$mn:000018D8
.text$mn:000018D8 ; Segment type: Pure code
.text$mn:000018D8 ; Segment permissions: Read/Execute
.text$mn:000018D8 _text$mn        segment para public 'CODE' use32
.text$mn:000018D8                 assume cs:_text$mn
.text$mn:000018D8                 ;org 18D8h
.text$mn:000018D8 ; COMDAT (pick any)
.text$mn:000018D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018D8
.text$mn:000018D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018D8
.text$mn:000018D8 ; Attributes: bp-based frame
.text$mn:000018D8
.text$mn:000018D8 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000018D8                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000018D8 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000018D8                                         ; CODE XREF: $LN19+4Bp
.text$mn:000018D8
.text$mn:000018D8 var_4           = dword ptr -4
.text$mn:000018D8 arg_0           = dword ptr  8
.text$mn:000018D8 arg_4           = dword ptr  0Ch
.text$mn:000018D8
.text$mn:000018D8                 push    ebp
.text$mn:000018D9                 mov     ebp, esp
.text$mn:000018DB                 push    ecx
.text$mn:000018DC                 mov     [ebp+var_4], ecx
.text$mn:000018DF                 mov     eax, [ebp+arg_4]
.text$mn:000018E2                 push    eax
.text$mn:000018E3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000018E8                 add     esp, 4
.text$mn:000018EB                 push    eax             ; int
.text$mn:000018EC                 mov     ecx, [ebp+arg_0]
.text$mn:000018EF                 push    ecx             ; void *
.text$mn:000018F0                 mov     edx, [ebp+var_4]
.text$mn:000018F3                 push    edx             ; int
.text$mn:000018F4                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000018F9                 add     esp, 0Ch
.text$mn:000018FC                 mov     esp, ebp
.text$mn:000018FE                 pop     ebp
.text$mn:000018FF                 retn    8
.text$mn:000018FF ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000018FF
.text$mn:000018FF ; ---------------------------------------------------------------------------
.text$mn:00001902                 align 4
.text$mn:00001902 _text$mn        ends
.text$mn:00001902
.text$mn:00001904 ; ===========================================================================
.text$mn:00001904
.text$mn:00001904 ; Segment type: Pure code
.text$mn:00001904 ; Segment permissions: Read/Execute
.text$mn:00001904 _text$mn        segment para public 'CODE' use32
.text$mn:00001904                 assume cs:_text$mn
.text$mn:00001904                 ;org 1904h
.text$mn:00001904 ; COMDAT (pick any)
.text$mn:00001904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001904
.text$mn:00001904 ; =============== S U B R O U T I N E =======================================
.text$mn:00001904
.text$mn:00001904 ; Attributes: bp-based frame
.text$mn:00001904
.text$mn:00001904 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001904                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001904 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001904                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001904
.text$mn:00001904 var_1C          = dword ptr -1Ch
.text$mn:00001904 var_18          = dword ptr -18h
.text$mn:00001904 var_14          = dword ptr -14h
.text$mn:00001904 var_10          = dword ptr -10h
.text$mn:00001904 var_C           = dword ptr -0Ch
.text$mn:00001904 var_4           = dword ptr -4
.text$mn:00001904 arg_0           = dword ptr  8
.text$mn:00001904 arg_4           = dword ptr  0Ch
.text$mn:00001904
.text$mn:00001904                 push    ebp
.text$mn:00001905                 mov     ebp, esp
.text$mn:00001907                 push    0FFFFFFFFh
.text$mn:00001909                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000190E                 mov     eax, large fs:0
.text$mn:00001914                 push    eax
.text$mn:00001915                 sub     esp, 10h
.text$mn:00001918                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000191D                 xor     eax, ebp
.text$mn:0000191F                 push    eax
.text$mn:00001920                 lea     eax, [ebp+var_C]
.text$mn:00001923                 mov     large fs:0, eax
.text$mn:00001929                 mov     [ebp+var_18], ecx
.text$mn:0000192C                 mov     eax, [ebp+arg_0]
.text$mn:0000192F                 push    eax             ; void *
.text$mn:00001930                 push    4               ; unsigned int
.text$mn:00001932                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001937                 add     esp, 8
.text$mn:0000193A                 mov     [ebp+var_10], eax
.text$mn:0000193D                 mov     [ebp+var_4], 0
.text$mn:00001944                 cmp     [ebp+var_10], 0
.text$mn:00001948                 jz      short loc_1965
.text$mn:0000194A                 mov     ecx, [ebp+arg_4]
.text$mn:0000194D                 push    ecx
.text$mn:0000194E                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001953                 add     esp, 4
.text$mn:00001956                 mov     edx, [ebp+var_10]
.text$mn:00001959                 mov     eax, [eax]
.text$mn:0000195B                 mov     [edx], eax
.text$mn:0000195D                 mov     ecx, [ebp+var_10]
.text$mn:00001960                 mov     [ebp+var_14], ecx
.text$mn:00001963                 jmp     short loc_196C
.text$mn:00001965 ; ---------------------------------------------------------------------------
.text$mn:00001965
.text$mn:00001965 loc_1965:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00001965                 mov     [ebp+var_14], 0
.text$mn:0000196C
.text$mn:0000196C loc_196C:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:0000196C                 mov     edx, [ebp+var_14]
.text$mn:0000196F                 mov     [ebp+var_1C], edx
.text$mn:00001972                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001979                 mov     ecx, [ebp+var_C]
.text$mn:0000197C                 mov     large fs:0, ecx
.text$mn:00001983                 pop     ecx
.text$mn:00001984                 mov     esp, ebp
.text$mn:00001986                 pop     ebp
.text$mn:00001987                 retn    8
.text$mn:00001987 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001987
.text$mn:00001987 ; ---------------------------------------------------------------------------
.text$mn:0000198A                 align 4
.text$mn:0000198A _text$mn        ends
.text$mn:0000198A
.text$x:0000198C ; ===========================================================================
.text$x:0000198C
.text$x:0000198C ; Segment type: Pure code
.text$x:0000198C ; Segment permissions: Read/Execute
.text$x:0000198C _text$x         segment para public 'CODE' use32
.text$x:0000198C                 assume cs:_text$x
.text$x:0000198C                 ;org 198Ch
.text$x:0000198C ; COMDAT (pick associative to section at 1904)
.text$x:0000198C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000198C
.text$x:0000198C ; =============== S U B R O U T I N E =======================================
.text$x:0000198C
.text$x:0000198C
.text$x:0000198C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:0000198C                                         ; DATA XREF: .xdata$x:00006304o
.text$x:0000198C                 mov     eax, [ebp+8]
.text$x:0000198F                 push    eax
.text$x:00001990                 mov     eax, [ebp-10h]
.text$x:00001993                 push    eax             ; void *
.text$x:00001994                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001999                 add     esp, 8
.text$x:0000199C                 retn
.text$x:0000199C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:0000199C
.text$x:0000199D
.text$x:0000199D ; =============== S U B R O U T I N E =======================================
.text$x:0000199D
.text$x:0000199D
.text$x:0000199D __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:0000199D                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:0000199D
.text$x:0000199D arg_4           = dword ptr  8
.text$x:0000199D
.text$x:0000199D                 mov     edx, [esp+arg_4]
.text$x:000019A1                 lea     eax, [edx+0Ch]
.text$x:000019A4                 mov     ecx, [edx-14h]
.text$x:000019A7                 xor     ecx, eax
.text$x:000019A9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019AE                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000019B3                 jmp     ___CxxFrameHandler3
.text$x:000019B3 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000019B3
.text$x:000019B3 _text$x         ends
.text$x:000019B3
.text$mn:000019B8 ; ===========================================================================
.text$mn:000019B8
.text$mn:000019B8 ; Segment type: Pure code
.text$mn:000019B8 ; Segment permissions: Read/Execute
.text$mn:000019B8 _text$mn        segment para public 'CODE' use32
.text$mn:000019B8                 assume cs:_text$mn
.text$mn:000019B8                 ;org 19B8h
.text$mn:000019B8 ; COMDAT (pick any)
.text$mn:000019B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019B8
.text$mn:000019B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019B8
.text$mn:000019B8 ; Attributes: bp-based frame
.text$mn:000019B8
.text$mn:000019B8 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000019B8                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000019B8 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000019B8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000019B8
.text$mn:000019B8 arg_0           = dword ptr  8
.text$mn:000019B8 arg_4           = dword ptr  0Ch
.text$mn:000019B8 arg_8           = dword ptr  10h
.text$mn:000019B8
.text$mn:000019B8                 push    ebp
.text$mn:000019B9                 mov     ebp, esp
.text$mn:000019BB                 mov     eax, [ebp+arg_8]
.text$mn:000019BE                 push    eax
.text$mn:000019BF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000019C4                 add     esp, 4
.text$mn:000019C7                 push    eax             ; int
.text$mn:000019C8                 mov     ecx, [ebp+arg_4]
.text$mn:000019CB                 push    ecx             ; void *
.text$mn:000019CC                 mov     ecx, [ebp+arg_0]
.text$mn:000019CF                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000019D4                 pop     ebp
.text$mn:000019D5                 retn
.text$mn:000019D5 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000019D5
.text$mn:000019D5 ; ---------------------------------------------------------------------------
.text$mn:000019D6                 align 4
.text$mn:000019D6 _text$mn        ends
.text$mn:000019D6
.text$mn:000019D8 ; ===========================================================================
.text$mn:000019D8
.text$mn:000019D8 ; Segment type: Pure code
.text$mn:000019D8 ; Segment permissions: Read/Execute
.text$mn:000019D8 _text$mn        segment para public 'CODE' use32
.text$mn:000019D8                 assume cs:_text$mn
.text$mn:000019D8                 ;org 19D8h
.text$mn:000019D8 ; COMDAT (pick any)
.text$mn:000019D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019D8
.text$mn:000019D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019D8
.text$mn:000019D8 ; Attributes: bp-based frame
.text$mn:000019D8
.text$mn:000019D8 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000019D8                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000019D8 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000019D8                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:000019D8
.text$mn:000019D8 var_4           = dword ptr -4
.text$mn:000019D8 arg_0           = dword ptr  8
.text$mn:000019D8 arg_4           = dword ptr  0Ch
.text$mn:000019D8
.text$mn:000019D8                 push    ebp
.text$mn:000019D9                 mov     ebp, esp
.text$mn:000019DB                 push    ecx
.text$mn:000019DC                 mov     [ebp+var_4], ecx
.text$mn:000019DF                 mov     eax, [ebp+arg_4]
.text$mn:000019E2                 push    eax
.text$mn:000019E3                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000019E8                 add     esp, 4
.text$mn:000019EB                 push    eax             ; int
.text$mn:000019EC                 mov     ecx, [ebp+arg_0]
.text$mn:000019EF                 push    ecx             ; void *
.text$mn:000019F0                 mov     edx, [ebp+var_4]
.text$mn:000019F3                 push    edx             ; int
.text$mn:000019F4                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:000019F9                 add     esp, 0Ch
.text$mn:000019FC                 mov     esp, ebp
.text$mn:000019FE                 pop     ebp
.text$mn:000019FF                 retn    8
.text$mn:000019FF ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000019FF
.text$mn:000019FF ; ---------------------------------------------------------------------------
.text$mn:00001A02                 align 4
.text$mn:00001A02 _text$mn        ends
.text$mn:00001A02
.text$mn:00001A04 ; ===========================================================================
.text$mn:00001A04
.text$mn:00001A04 ; Segment type: Pure code
.text$mn:00001A04 ; Segment permissions: Read/Execute
.text$mn:00001A04 _text$mn        segment para public 'CODE' use32
.text$mn:00001A04                 assume cs:_text$mn
.text$mn:00001A04                 ;org 1A04h
.text$mn:00001A04 ; COMDAT (pick any)
.text$mn:00001A04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A04
.text$mn:00001A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A04
.text$mn:00001A04 ; Attributes: bp-based frame
.text$mn:00001A04
.text$mn:00001A04 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00001A04                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001A04 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00001A04                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00001A04
.text$mn:00001A04 var_1C          = dword ptr -1Ch
.text$mn:00001A04 var_18          = dword ptr -18h
.text$mn:00001A04 var_14          = dword ptr -14h
.text$mn:00001A04 var_10          = dword ptr -10h
.text$mn:00001A04 var_C           = dword ptr -0Ch
.text$mn:00001A04 var_4           = dword ptr -4
.text$mn:00001A04 arg_0           = dword ptr  8
.text$mn:00001A04 arg_4           = dword ptr  0Ch
.text$mn:00001A04
.text$mn:00001A04                 push    ebp
.text$mn:00001A05                 mov     ebp, esp
.text$mn:00001A07                 push    0FFFFFFFFh
.text$mn:00001A09                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001A0E                 mov     eax, large fs:0
.text$mn:00001A14                 push    eax
.text$mn:00001A15                 sub     esp, 10h
.text$mn:00001A18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A1D                 xor     eax, ebp
.text$mn:00001A1F                 push    eax
.text$mn:00001A20                 lea     eax, [ebp+var_C]
.text$mn:00001A23                 mov     large fs:0, eax
.text$mn:00001A29                 mov     [ebp+var_18], ecx
.text$mn:00001A2C                 mov     eax, [ebp+arg_0]
.text$mn:00001A2F                 push    eax             ; void *
.text$mn:00001A30                 push    4               ; unsigned int
.text$mn:00001A32                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001A37                 add     esp, 8
.text$mn:00001A3A                 mov     [ebp+var_10], eax
.text$mn:00001A3D                 mov     [ebp+var_4], 0
.text$mn:00001A44                 cmp     [ebp+var_10], 0
.text$mn:00001A48                 jz      short loc_1A65
.text$mn:00001A4A                 mov     ecx, [ebp+arg_4]
.text$mn:00001A4D                 push    ecx
.text$mn:00001A4E                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001A53                 add     esp, 4
.text$mn:00001A56                 mov     edx, [ebp+var_10]
.text$mn:00001A59                 mov     eax, [eax]
.text$mn:00001A5B                 mov     [edx], eax
.text$mn:00001A5D                 mov     ecx, [ebp+var_10]
.text$mn:00001A60                 mov     [ebp+var_14], ecx
.text$mn:00001A63                 jmp     short loc_1A6C
.text$mn:00001A65 ; ---------------------------------------------------------------------------
.text$mn:00001A65
.text$mn:00001A65 loc_1A65:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00001A65                 mov     [ebp+var_14], 0
.text$mn:00001A6C
.text$mn:00001A6C loc_1A6C:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00001A6C                 mov     edx, [ebp+var_14]
.text$mn:00001A6F                 mov     [ebp+var_1C], edx
.text$mn:00001A72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A79                 mov     ecx, [ebp+var_C]
.text$mn:00001A7C                 mov     large fs:0, ecx
.text$mn:00001A83                 pop     ecx
.text$mn:00001A84                 mov     esp, ebp
.text$mn:00001A86                 pop     ebp
.text$mn:00001A87                 retn    8
.text$mn:00001A87 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00001A87
.text$mn:00001A87 ; ---------------------------------------------------------------------------
.text$mn:00001A8A                 align 4
.text$mn:00001A8A _text$mn        ends
.text$mn:00001A8A
.text$x:00001A8C ; ===========================================================================
.text$x:00001A8C
.text$x:00001A8C ; Segment type: Pure code
.text$x:00001A8C ; Segment permissions: Read/Execute
.text$x:00001A8C _text$x         segment para public 'CODE' use32
.text$x:00001A8C                 assume cs:_text$x
.text$x:00001A8C                 ;org 1A8Ch
.text$x:00001A8C ; COMDAT (pick associative to section at 1A04)
.text$x:00001A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A8C
.text$x:00001A8C ; =============== S U B R O U T I N E =======================================
.text$x:00001A8C
.text$x:00001A8C
.text$x:00001A8C __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00001A8C                                         ; DATA XREF: .xdata$x:00006330o
.text$x:00001A8C                 mov     eax, [ebp+8]
.text$x:00001A8F                 push    eax
.text$x:00001A90                 mov     eax, [ebp-10h]
.text$x:00001A93                 push    eax             ; void *
.text$x:00001A94                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001A99                 add     esp, 8
.text$x:00001A9C                 retn
.text$x:00001A9C __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00001A9C
.text$x:00001A9D
.text$x:00001A9D ; =============== S U B R O U T I N E =======================================
.text$x:00001A9D
.text$x:00001A9D
.text$x:00001A9D __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00001A9D                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00001A9D
.text$x:00001A9D arg_4           = dword ptr  8
.text$x:00001A9D
.text$x:00001A9D                 mov     edx, [esp+arg_4]
.text$x:00001AA1                 lea     eax, [edx+0Ch]
.text$x:00001AA4                 mov     ecx, [edx-14h]
.text$x:00001AA7                 xor     ecx, eax
.text$x:00001AA9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AAE                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00001AB3                 jmp     ___CxxFrameHandler3
.text$x:00001AB3 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00001AB3
.text$x:00001AB3 _text$x         ends
.text$x:00001AB3
.text$mn:00001AB8 ; ===========================================================================
.text$mn:00001AB8
.text$mn:00001AB8 ; Segment type: Pure code
.text$mn:00001AB8 ; Segment permissions: Read/Execute
.text$mn:00001AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB8                 assume cs:_text$mn
.text$mn:00001AB8                 ;org 1AB8h
.text$mn:00001AB8 ; COMDAT (pick any)
.text$mn:00001AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AB8
.text$mn:00001AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB8
.text$mn:00001AB8 ; Attributes: bp-based frame
.text$mn:00001AB8
.text$mn:00001AB8 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00001AB8                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00001AB8 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00001AB8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00001AB8
.text$mn:00001AB8 arg_0           = dword ptr  8
.text$mn:00001AB8 arg_4           = dword ptr  0Ch
.text$mn:00001AB8 arg_8           = dword ptr  10h
.text$mn:00001AB8
.text$mn:00001AB8                 push    ebp
.text$mn:00001AB9                 mov     ebp, esp
.text$mn:00001ABB                 mov     eax, [ebp+arg_8]
.text$mn:00001ABE                 push    eax
.text$mn:00001ABF                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001AC4                 add     esp, 4
.text$mn:00001AC7                 push    eax             ; int
.text$mn:00001AC8                 mov     ecx, [ebp+arg_4]
.text$mn:00001ACB                 push    ecx             ; void *
.text$mn:00001ACC                 mov     ecx, [ebp+arg_0]
.text$mn:00001ACF                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00001AD4                 pop     ebp
.text$mn:00001AD5                 retn
.text$mn:00001AD5 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00001AD5
.text$mn:00001AD5 ; ---------------------------------------------------------------------------
.text$mn:00001AD6                 align 4
.text$mn:00001AD6 _text$mn        ends
.text$mn:00001AD6
.text$mn:00001AD8 ; ===========================================================================
.text$mn:00001AD8
.text$mn:00001AD8 ; Segment type: Pure code
.text$mn:00001AD8 ; Segment permissions: Read/Execute
.text$mn:00001AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AD8                 assume cs:_text$mn
.text$mn:00001AD8                 ;org 1AD8h
.text$mn:00001AD8 ; COMDAT (pick any)
.text$mn:00001AD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AD8
.text$mn:00001AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AD8
.text$mn:00001AD8 ; Attributes: bp-based frame
.text$mn:00001AD8
.text$mn:00001AD8 ; int __stdcall std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(void *, int)
.text$mn:00001AD8                 public ??$construct@USwitcherFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z
.text$mn:00001AD8 ??$construct@USwitcherFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z proc near
.text$mn:00001AD8                                         ; CODE XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00001AD8                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+9Ap ...
.text$mn:00001AD8
.text$mn:00001AD8 var_4           = dword ptr -4
.text$mn:00001AD8 arg_0           = dword ptr  8
.text$mn:00001AD8 arg_4           = dword ptr  0Ch
.text$mn:00001AD8
.text$mn:00001AD8                 push    ebp
.text$mn:00001AD9                 mov     ebp, esp
.text$mn:00001ADB                 push    ecx
.text$mn:00001ADC                 mov     [ebp+var_4], ecx
.text$mn:00001ADF                 mov     eax, [ebp+arg_4]
.text$mn:00001AE2                 push    eax
.text$mn:00001AE3                 call    ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z ; std::forward<SwitcherFileInfo>(SwitcherFileInfo &)
.text$mn:00001AE8                 add     esp, 4
.text$mn:00001AEB                 push    eax             ; int
.text$mn:00001AEC                 mov     ecx, [ebp+arg_0]
.text$mn:00001AEF                 push    ecx             ; void *
.text$mn:00001AF0                 mov     edx, [ebp+var_4]
.text$mn:00001AF3                 push    edx             ; int
.text$mn:00001AF4                 call    ??$construct@USwitcherFileInfo@@U1@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@$$QAU3@@Z ; std::allocator_traits<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(std::allocator<SwitcherFileInfo> &,SwitcherFileInfo *,SwitcherFileInfo &&)
.text$mn:00001AF9                 add     esp, 0Ch
.text$mn:00001AFC                 mov     esp, ebp
.text$mn:00001AFE                 pop     ebp
.text$mn:00001AFF                 retn    8
.text$mn:00001AFF ??$construct@USwitcherFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z endp
.text$mn:00001AFF
.text$mn:00001AFF ; ---------------------------------------------------------------------------
.text$mn:00001B02                 align 4
.text$mn:00001B02 _text$mn        ends
.text$mn:00001B02
.text$mn:00001B04 ; ===========================================================================
.text$mn:00001B04
.text$mn:00001B04 ; Segment type: Pure code
.text$mn:00001B04 ; Segment permissions: Read/Execute
.text$mn:00001B04 _text$mn        segment para public 'CODE' use32
.text$mn:00001B04                 assume cs:_text$mn
.text$mn:00001B04                 ;org 1B04h
.text$mn:00001B04 ; COMDAT (pick any)
.text$mn:00001B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B04
.text$mn:00001B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B04
.text$mn:00001B04 ; Attributes: bp-based frame
.text$mn:00001B04
.text$mn:00001B04 ; int __stdcall std::allocator<SwitcherFileInfo>::construct<SwitcherFileInfo,SwitcherFileInfo>(void *, int)
.text$mn:00001B04                 public ??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z
.text$mn:00001B04 ??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z proc near
.text$mn:00001B04                                         ; CODE XREF: std::allocator_traits<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(std::allocator<SwitcherFileInfo> &,SwitcherFileInfo *,SwitcherFileInfo &&)+17p
.text$mn:00001B04
.text$mn:00001B04 var_1C          = dword ptr -1Ch
.text$mn:00001B04 var_18          = dword ptr -18h
.text$mn:00001B04 var_14          = dword ptr -14h
.text$mn:00001B04 var_10          = dword ptr -10h
.text$mn:00001B04 var_C           = dword ptr -0Ch
.text$mn:00001B04 var_4           = dword ptr -4
.text$mn:00001B04 arg_0           = dword ptr  8
.text$mn:00001B04 arg_4           = dword ptr  0Ch
.text$mn:00001B04
.text$mn:00001B04                 push    ebp
.text$mn:00001B05                 mov     ebp, esp
.text$mn:00001B07                 push    0FFFFFFFFh
.text$mn:00001B09                 push    offset __ehhandler$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z
.text$mn:00001B0E                 mov     eax, large fs:0
.text$mn:00001B14                 push    eax
.text$mn:00001B15                 sub     esp, 10h
.text$mn:00001B18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B1D                 xor     eax, ebp
.text$mn:00001B1F                 push    eax
.text$mn:00001B20                 lea     eax, [ebp+var_C]
.text$mn:00001B23                 mov     large fs:0, eax
.text$mn:00001B29                 mov     [ebp+var_18], ecx
.text$mn:00001B2C                 mov     eax, [ebp+arg_0]
.text$mn:00001B2F                 push    eax             ; void *
.text$mn:00001B30                 push    8               ; unsigned int
.text$mn:00001B32                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001B37                 add     esp, 8
.text$mn:00001B3A                 mov     [ebp+var_10], eax
.text$mn:00001B3D                 mov     [ebp+var_4], 0
.text$mn:00001B44                 cmp     [ebp+var_10], 0
.text$mn:00001B48                 jz      short loc_1B6B
.text$mn:00001B4A                 mov     ecx, [ebp+arg_4]
.text$mn:00001B4D                 push    ecx
.text$mn:00001B4E                 call    ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z ; std::forward<SwitcherFileInfo>(SwitcherFileInfo &)
.text$mn:00001B53                 add     esp, 4
.text$mn:00001B56                 mov     edx, [eax]
.text$mn:00001B58                 mov     eax, [eax+4]
.text$mn:00001B5B                 mov     ecx, [ebp+var_10]
.text$mn:00001B5E                 mov     [ecx], edx
.text$mn:00001B60                 mov     [ecx+4], eax
.text$mn:00001B63                 mov     edx, [ebp+var_10]
.text$mn:00001B66                 mov     [ebp+var_14], edx
.text$mn:00001B69                 jmp     short loc_1B72
.text$mn:00001B6B ; ---------------------------------------------------------------------------
.text$mn:00001B6B
.text$mn:00001B6B loc_1B6B:                               ; CODE XREF: std::allocator<SwitcherFileInfo>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)+44j
.text$mn:00001B6B                 mov     [ebp+var_14], 0
.text$mn:00001B72
.text$mn:00001B72 loc_1B72:                               ; CODE XREF: std::allocator<SwitcherFileInfo>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)+65j
.text$mn:00001B72                 mov     eax, [ebp+var_14]
.text$mn:00001B75                 mov     [ebp+var_1C], eax
.text$mn:00001B78                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B7F                 mov     ecx, [ebp+var_C]
.text$mn:00001B82                 mov     large fs:0, ecx
.text$mn:00001B89                 pop     ecx
.text$mn:00001B8A                 mov     esp, ebp
.text$mn:00001B8C                 pop     ebp
.text$mn:00001B8D                 retn    8
.text$mn:00001B8D ??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z endp
.text$mn:00001B8D
.text$mn:00001B8D _text$mn        ends
.text$mn:00001B8D
.text$x:00001B90 ; ===========================================================================
.text$x:00001B90
.text$x:00001B90 ; Segment type: Pure code
.text$x:00001B90 ; Segment permissions: Read/Execute
.text$x:00001B90 _text$x         segment para public 'CODE' use32
.text$x:00001B90                 assume cs:_text$x
.text$x:00001B90                 ;org 1B90h
.text$x:00001B90 ; COMDAT (pick associative to section at 1B04)
.text$x:00001B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001B90
.text$x:00001B90 ; =============== S U B R O U T I N E =======================================
.text$x:00001B90
.text$x:00001B90
.text$x:00001B90 __unwindfunclet$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z$0 proc near
.text$x:00001B90                                         ; DATA XREF: .xdata$x:000062D8o
.text$x:00001B90                 mov     eax, [ebp+8]
.text$x:00001B93                 push    eax
.text$x:00001B94                 mov     eax, [ebp-10h]
.text$x:00001B97                 push    eax             ; void *
.text$x:00001B98                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001B9D                 add     esp, 8
.text$x:00001BA0                 retn
.text$x:00001BA0 __unwindfunclet$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z$0 endp
.text$x:00001BA0
.text$x:00001BA1
.text$x:00001BA1 ; =============== S U B R O U T I N E =======================================
.text$x:00001BA1
.text$x:00001BA1
.text$x:00001BA1 __ehhandler$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z proc near
.text$x:00001BA1                                         ; DATA XREF: std::allocator<SwitcherFileInfo>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)+5o
.text$x:00001BA1
.text$x:00001BA1 arg_4           = dword ptr  8
.text$x:00001BA1
.text$x:00001BA1                 mov     edx, [esp+arg_4]
.text$x:00001BA5                 lea     eax, [edx+0Ch]
.text$x:00001BA8                 mov     ecx, [edx-14h]
.text$x:00001BAB                 xor     ecx, eax
.text$x:00001BAD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BB2                 mov     eax, offset __ehfuncinfo$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z
.text$x:00001BB7                 jmp     ___CxxFrameHandler3
.text$x:00001BB7 __ehhandler$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z endp
.text$x:00001BB7
.text$x:00001BB7 _text$x         ends
.text$x:00001BB7
.text$mn:00001BBC ; ===========================================================================
.text$mn:00001BBC
.text$mn:00001BBC ; Segment type: Pure code
.text$mn:00001BBC ; Segment permissions: Read/Execute
.text$mn:00001BBC _text$mn        segment para public 'CODE' use32
.text$mn:00001BBC                 assume cs:_text$mn
.text$mn:00001BBC                 ;org 1BBCh
.text$mn:00001BBC ; COMDAT (pick any)
.text$mn:00001BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BBC
.text$mn:00001BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BBC
.text$mn:00001BBC ; Attributes: bp-based frame
.text$mn:00001BBC
.text$mn:00001BBC ; int __cdecl std::allocator_traits<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(int, void *, int)
.text$mn:00001BBC                 public ??$construct@USwitcherFileInfo@@U1@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@$$QAU3@@Z
.text$mn:00001BBC ??$construct@USwitcherFileInfo@@U1@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@$$QAU3@@Z proc near
.text$mn:00001BBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)+1Cp
.text$mn:00001BBC
.text$mn:00001BBC arg_0           = dword ptr  8
.text$mn:00001BBC arg_4           = dword ptr  0Ch
.text$mn:00001BBC arg_8           = dword ptr  10h
.text$mn:00001BBC
.text$mn:00001BBC                 push    ebp
.text$mn:00001BBD                 mov     ebp, esp
.text$mn:00001BBF                 mov     eax, [ebp+arg_8]
.text$mn:00001BC2                 push    eax
.text$mn:00001BC3                 call    ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z ; std::forward<SwitcherFileInfo>(SwitcherFileInfo &)
.text$mn:00001BC8                 add     esp, 4
.text$mn:00001BCB                 push    eax             ; int
.text$mn:00001BCC                 mov     ecx, [ebp+arg_4]
.text$mn:00001BCF                 push    ecx             ; void *
.text$mn:00001BD0                 mov     ecx, [ebp+arg_0]
.text$mn:00001BD3                 call    ??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z ; std::allocator<SwitcherFileInfo>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)
.text$mn:00001BD8                 pop     ebp
.text$mn:00001BD9                 retn
.text$mn:00001BD9 ??$construct@USwitcherFileInfo@@U1@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@$$QAU3@@Z endp
.text$mn:00001BD9
.text$mn:00001BD9 ; ---------------------------------------------------------------------------
.text$mn:00001BDA                 align 4
.text$mn:00001BDA _text$mn        ends
.text$mn:00001BDA
.text$mn:00001BDC ; ===========================================================================
.text$mn:00001BDC
.text$mn:00001BDC ; Segment type: Pure code
.text$mn:00001BDC ; Segment permissions: Read/Execute
.text$mn:00001BDC _text$mn        segment para public 'CODE' use32
.text$mn:00001BDC                 assume cs:_text$mn
.text$mn:00001BDC                 ;org 1BDCh
.text$mn:00001BDC ; COMDAT (pick any)
.text$mn:00001BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BDC
.text$mn:00001BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BDC
.text$mn:00001BDC ; Attributes: bp-based frame
.text$mn:00001BDC
.text$mn:00001BDC ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001BDC                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001BDC ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001BDC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Alloc_proxy(void)+32p
.text$mn:00001BDC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Alloc_proxy(void)+32p
.text$mn:00001BDC
.text$mn:00001BDC var_4           = dword ptr -4
.text$mn:00001BDC arg_0           = dword ptr  8
.text$mn:00001BDC arg_4           = dword ptr  0Ch
.text$mn:00001BDC
.text$mn:00001BDC                 push    ebp
.text$mn:00001BDD                 mov     ebp, esp
.text$mn:00001BDF                 push    ecx
.text$mn:00001BE0                 mov     [ebp+var_4], ecx
.text$mn:00001BE3                 mov     eax, [ebp+arg_4]
.text$mn:00001BE6                 push    eax
.text$mn:00001BE7                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001BEC                 add     esp, 4
.text$mn:00001BEF                 push    eax             ; int
.text$mn:00001BF0                 mov     ecx, [ebp+arg_0]
.text$mn:00001BF3                 push    ecx             ; void *
.text$mn:00001BF4                 mov     edx, [ebp+var_4]
.text$mn:00001BF7                 push    edx             ; int
.text$mn:00001BF8                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001BFD                 add     esp, 0Ch
.text$mn:00001C00                 mov     esp, ebp
.text$mn:00001C02                 pop     ebp
.text$mn:00001C03                 retn    8
.text$mn:00001C03 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001C03
.text$mn:00001C03 ; ---------------------------------------------------------------------------
.text$mn:00001C06                 align 4
.text$mn:00001C06 _text$mn        ends
.text$mn:00001C06
.text$mn:00001C08 ; ===========================================================================
.text$mn:00001C08
.text$mn:00001C08 ; Segment type: Pure code
.text$mn:00001C08 ; Segment permissions: Read/Execute
.text$mn:00001C08 _text$mn        segment para public 'CODE' use32
.text$mn:00001C08                 assume cs:_text$mn
.text$mn:00001C08                 ;org 1C08h
.text$mn:00001C08 ; COMDAT (pick any)
.text$mn:00001C08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C08
.text$mn:00001C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C08
.text$mn:00001C08 ; Attributes: bp-based frame
.text$mn:00001C08
.text$mn:00001C08 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001C08                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001C08 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001C08                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00001C08                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:00001C08
.text$mn:00001C08 var_1C          = dword ptr -1Ch
.text$mn:00001C08 var_18          = dword ptr -18h
.text$mn:00001C08 var_14          = dword ptr -14h
.text$mn:00001C08 var_10          = dword ptr -10h
.text$mn:00001C08 var_C           = dword ptr -0Ch
.text$mn:00001C08 var_4           = dword ptr -4
.text$mn:00001C08 arg_0           = dword ptr  8
.text$mn:00001C08 arg_4           = dword ptr  0Ch
.text$mn:00001C08
.text$mn:00001C08                 push    ebp
.text$mn:00001C09                 mov     ebp, esp
.text$mn:00001C0B                 push    0FFFFFFFFh
.text$mn:00001C0D                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001C12                 mov     eax, large fs:0
.text$mn:00001C18                 push    eax
.text$mn:00001C19                 sub     esp, 10h
.text$mn:00001C1C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C21                 xor     eax, ebp
.text$mn:00001C23                 push    eax
.text$mn:00001C24                 lea     eax, [ebp+var_C]
.text$mn:00001C27                 mov     large fs:0, eax
.text$mn:00001C2D                 mov     [ebp+var_18], ecx
.text$mn:00001C30                 mov     eax, [ebp+arg_0]
.text$mn:00001C33                 push    eax             ; void *
.text$mn:00001C34                 push    8               ; unsigned int
.text$mn:00001C36                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001C3B                 add     esp, 8
.text$mn:00001C3E                 mov     [ebp+var_10], eax
.text$mn:00001C41                 mov     [ebp+var_4], 0
.text$mn:00001C48                 cmp     [ebp+var_10], 0
.text$mn:00001C4C                 jz      short loc_1C6F
.text$mn:00001C4E                 mov     ecx, [ebp+arg_4]
.text$mn:00001C51                 push    ecx
.text$mn:00001C52                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001C57                 add     esp, 4
.text$mn:00001C5A                 mov     edx, [eax]
.text$mn:00001C5C                 mov     eax, [eax+4]
.text$mn:00001C5F                 mov     ecx, [ebp+var_10]
.text$mn:00001C62                 mov     [ecx], edx
.text$mn:00001C64                 mov     [ecx+4], eax
.text$mn:00001C67                 mov     edx, [ebp+var_10]
.text$mn:00001C6A                 mov     [ebp+var_14], edx
.text$mn:00001C6D                 jmp     short loc_1C76
.text$mn:00001C6F ; ---------------------------------------------------------------------------
.text$mn:00001C6F
.text$mn:00001C6F loc_1C6F:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00001C6F                 mov     [ebp+var_14], 0
.text$mn:00001C76
.text$mn:00001C76 loc_1C76:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00001C76                 mov     eax, [ebp+var_14]
.text$mn:00001C79                 mov     [ebp+var_1C], eax
.text$mn:00001C7C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001C83                 mov     ecx, [ebp+var_C]
.text$mn:00001C86                 mov     large fs:0, ecx
.text$mn:00001C8D                 pop     ecx
.text$mn:00001C8E                 mov     esp, ebp
.text$mn:00001C90                 pop     ebp
.text$mn:00001C91                 retn    8
.text$mn:00001C91 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001C91
.text$mn:00001C91 _text$mn        ends
.text$mn:00001C91
.text$x:00001C94 ; ===========================================================================
.text$x:00001C94
.text$x:00001C94 ; Segment type: Pure code
.text$x:00001C94 ; Segment permissions: Read/Execute
.text$x:00001C94 _text$x         segment para public 'CODE' use32
.text$x:00001C94                 assume cs:_text$x
.text$x:00001C94                 ;org 1C94h
.text$x:00001C94 ; COMDAT (pick associative to section at 1C08)
.text$x:00001C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001C94
.text$x:00001C94 ; =============== S U B R O U T I N E =======================================
.text$x:00001C94
.text$x:00001C94
.text$x:00001C94 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00001C94                                         ; DATA XREF: .xdata$x:000062ACo
.text$x:00001C94                 mov     eax, [ebp+8]
.text$x:00001C97                 push    eax
.text$x:00001C98                 mov     eax, [ebp-10h]
.text$x:00001C9B                 push    eax             ; void *
.text$x:00001C9C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001CA1                 add     esp, 8
.text$x:00001CA4                 retn
.text$x:00001CA4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001CA4
.text$x:00001CA5
.text$x:00001CA5 ; =============== S U B R O U T I N E =======================================
.text$x:00001CA5
.text$x:00001CA5
.text$x:00001CA5 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001CA5                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001CA5
.text$x:00001CA5 arg_4           = dword ptr  8
.text$x:00001CA5
.text$x:00001CA5                 mov     edx, [esp+arg_4]
.text$x:00001CA9                 lea     eax, [edx+0Ch]
.text$x:00001CAC                 mov     ecx, [edx-14h]
.text$x:00001CAF                 xor     ecx, eax
.text$x:00001CB1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CB6                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00001CBB                 jmp     ___CxxFrameHandler3
.text$x:00001CBB __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00001CBB
.text$x:00001CBB _text$x         ends
.text$x:00001CBB
.text$mn:00001CC0 ; ===========================================================================
.text$mn:00001CC0
.text$mn:00001CC0 ; Segment type: Pure code
.text$mn:00001CC0 ; Segment permissions: Read/Execute
.text$mn:00001CC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CC0                 assume cs:_text$mn
.text$mn:00001CC0                 ;org 1CC0h
.text$mn:00001CC0 ; COMDAT (pick any)
.text$mn:00001CC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CC0
.text$mn:00001CC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CC0
.text$mn:00001CC0 ; Attributes: bp-based frame
.text$mn:00001CC0
.text$mn:00001CC0 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00001CC0                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00001CC0 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00001CC0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00001CC0
.text$mn:00001CC0 arg_0           = dword ptr  8
.text$mn:00001CC0 arg_4           = dword ptr  0Ch
.text$mn:00001CC0 arg_8           = dword ptr  10h
.text$mn:00001CC0
.text$mn:00001CC0                 push    ebp
.text$mn:00001CC1                 mov     ebp, esp
.text$mn:00001CC3                 mov     eax, [ebp+arg_8]
.text$mn:00001CC6                 push    eax
.text$mn:00001CC7                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001CCC                 add     esp, 4
.text$mn:00001CCF                 push    eax             ; int
.text$mn:00001CD0                 mov     ecx, [ebp+arg_4]
.text$mn:00001CD3                 push    ecx             ; void *
.text$mn:00001CD4                 mov     ecx, [ebp+arg_0]
.text$mn:00001CD7                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001CDC                 pop     ebp
.text$mn:00001CDD                 retn
.text$mn:00001CDD ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00001CDD
.text$mn:00001CDD ; ---------------------------------------------------------------------------
.text$mn:00001CDE                 align 10h
.text$mn:00001CDE _text$mn        ends
.text$mn:00001CDE
.text$mn:00001CE0 ; ===========================================================================
.text$mn:00001CE0
.text$mn:00001CE0 ; Segment type: Pure code
.text$mn:00001CE0 ; Segment permissions: Read/Execute
.text$mn:00001CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CE0                 assume cs:_text$mn
.text$mn:00001CE0                 ;org 1CE0h
.text$mn:00001CE0 ; COMDAT (pick any)
.text$mn:00001CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CE0
.text$mn:00001CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CE0
.text$mn:00001CE0 ; Attributes: bp-based frame
.text$mn:00001CE0
.text$mn:00001CE0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001CE0                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00001CE0 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00001CE0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00001CE0
.text$mn:00001CE0 var_4           = dword ptr -4
.text$mn:00001CE0 arg_0           = dword ptr  8
.text$mn:00001CE0
.text$mn:00001CE0                 push    ebp
.text$mn:00001CE1                 mov     ebp, esp
.text$mn:00001CE3                 push    ecx
.text$mn:00001CE4                 mov     [ebp+var_4], ecx
.text$mn:00001CE7                 mov     eax, [ebp+arg_0]
.text$mn:00001CEA                 push    eax
.text$mn:00001CEB                 mov     ecx, [ebp+var_4]
.text$mn:00001CEE                 push    ecx
.text$mn:00001CEF                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001CF4                 add     esp, 8
.text$mn:00001CF7                 mov     esp, ebp
.text$mn:00001CF9                 pop     ebp
.text$mn:00001CFA                 retn    4
.text$mn:00001CFA ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00001CFA
.text$mn:00001CFA ; ---------------------------------------------------------------------------
.text$mn:00001CFD                 align 10h
.text$mn:00001CFD _text$mn        ends
.text$mn:00001CFD
.text$mn:00001D00 ; ===========================================================================
.text$mn:00001D00
.text$mn:00001D00 ; Segment type: Pure code
.text$mn:00001D00 ; Segment permissions: Read/Execute
.text$mn:00001D00 _text$mn        segment para public 'CODE' use32
.text$mn:00001D00                 assume cs:_text$mn
.text$mn:00001D00                 ;org 1D00h
.text$mn:00001D00 ; COMDAT (pick any)
.text$mn:00001D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D00
.text$mn:00001D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D00
.text$mn:00001D00 ; Attributes: bp-based frame
.text$mn:00001D00
.text$mn:00001D00 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001D00                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00001D00 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00001D00                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00001D00
.text$mn:00001D00 var_4           = dword ptr -4
.text$mn:00001D00
.text$mn:00001D00                 push    ebp
.text$mn:00001D01                 mov     ebp, esp
.text$mn:00001D03                 push    ecx
.text$mn:00001D04                 mov     [ebp+var_4], ecx
.text$mn:00001D07                 mov     esp, ebp
.text$mn:00001D09                 pop     ebp
.text$mn:00001D0A                 retn    4
.text$mn:00001D0A ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00001D0A
.text$mn:00001D0A ; ---------------------------------------------------------------------------
.text$mn:00001D0D                 align 10h
.text$mn:00001D0D _text$mn        ends
.text$mn:00001D0D
.text$mn:00001D10 ; ===========================================================================
.text$mn:00001D10
.text$mn:00001D10 ; Segment type: Pure code
.text$mn:00001D10 ; Segment permissions: Read/Execute
.text$mn:00001D10 _text$mn        segment para public 'CODE' use32
.text$mn:00001D10                 assume cs:_text$mn
.text$mn:00001D10                 ;org 1D10h
.text$mn:00001D10 ; COMDAT (pick any)
.text$mn:00001D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D10
.text$mn:00001D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D10
.text$mn:00001D10 ; Attributes: bp-based frame
.text$mn:00001D10
.text$mn:00001D10 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00001D10                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00001D10 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00001D10                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00001D10
.text$mn:00001D10 arg_0           = dword ptr  8
.text$mn:00001D10 arg_4           = dword ptr  0Ch
.text$mn:00001D10
.text$mn:00001D10                 push    ebp
.text$mn:00001D11                 mov     ebp, esp
.text$mn:00001D13                 mov     eax, [ebp+arg_4]
.text$mn:00001D16                 push    eax
.text$mn:00001D17                 mov     ecx, [ebp+arg_0]
.text$mn:00001D1A                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001D1F                 pop     ebp
.text$mn:00001D20                 retn
.text$mn:00001D20 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00001D20
.text$mn:00001D20 ; ---------------------------------------------------------------------------
.text$mn:00001D21                 align 4
.text$mn:00001D21 _text$mn        ends
.text$mn:00001D21
.text$mn:00001D24 ; ===========================================================================
.text$mn:00001D24
.text$mn:00001D24 ; Segment type: Pure code
.text$mn:00001D24 ; Segment permissions: Read/Execute
.text$mn:00001D24 _text$mn        segment para public 'CODE' use32
.text$mn:00001D24                 assume cs:_text$mn
.text$mn:00001D24                 ;org 1D24h
.text$mn:00001D24 ; COMDAT (pick any)
.text$mn:00001D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D24
.text$mn:00001D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D24
.text$mn:00001D24 ; Attributes: bp-based frame
.text$mn:00001D24
.text$mn:00001D24 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001D24                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00001D24 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00001D24                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00001D24
.text$mn:00001D24 var_4           = dword ptr -4
.text$mn:00001D24 arg_0           = dword ptr  8
.text$mn:00001D24
.text$mn:00001D24                 push    ebp
.text$mn:00001D25                 mov     ebp, esp
.text$mn:00001D27                 push    ecx
.text$mn:00001D28                 mov     [ebp+var_4], ecx
.text$mn:00001D2B                 mov     eax, [ebp+arg_0]
.text$mn:00001D2E                 push    eax
.text$mn:00001D2F                 mov     ecx, [ebp+var_4]
.text$mn:00001D32                 push    ecx
.text$mn:00001D33                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00001D38                 add     esp, 8
.text$mn:00001D3B                 mov     esp, ebp
.text$mn:00001D3D                 pop     ebp
.text$mn:00001D3E                 retn    4
.text$mn:00001D3E ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00001D3E
.text$mn:00001D3E ; ---------------------------------------------------------------------------
.text$mn:00001D41                 align 4
.text$mn:00001D41 _text$mn        ends
.text$mn:00001D41
.text$mn:00001D44 ; ===========================================================================
.text$mn:00001D44
.text$mn:00001D44 ; Segment type: Pure code
.text$mn:00001D44 ; Segment permissions: Read/Execute
.text$mn:00001D44 _text$mn        segment para public 'CODE' use32
.text$mn:00001D44                 assume cs:_text$mn
.text$mn:00001D44                 ;org 1D44h
.text$mn:00001D44 ; COMDAT (pick any)
.text$mn:00001D44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D44
.text$mn:00001D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D44
.text$mn:00001D44 ; Attributes: bp-based frame
.text$mn:00001D44
.text$mn:00001D44 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001D44                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00001D44 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00001D44                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00001D44
.text$mn:00001D44 var_4           = dword ptr -4
.text$mn:00001D44
.text$mn:00001D44                 push    ebp
.text$mn:00001D45                 mov     ebp, esp
.text$mn:00001D47                 push    ecx
.text$mn:00001D48                 mov     [ebp+var_4], ecx
.text$mn:00001D4B                 mov     esp, ebp
.text$mn:00001D4D                 pop     ebp
.text$mn:00001D4E                 retn    4
.text$mn:00001D4E ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00001D4E
.text$mn:00001D4E ; ---------------------------------------------------------------------------
.text$mn:00001D51                 align 4
.text$mn:00001D51 _text$mn        ends
.text$mn:00001D51
.text$mn:00001D54 ; ===========================================================================
.text$mn:00001D54
.text$mn:00001D54 ; Segment type: Pure code
.text$mn:00001D54 ; Segment permissions: Read/Execute
.text$mn:00001D54 _text$mn        segment para public 'CODE' use32
.text$mn:00001D54                 assume cs:_text$mn
.text$mn:00001D54                 ;org 1D54h
.text$mn:00001D54 ; COMDAT (pick any)
.text$mn:00001D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D54
.text$mn:00001D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D54
.text$mn:00001D54 ; Attributes: bp-based frame
.text$mn:00001D54
.text$mn:00001D54 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00001D54                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00001D54 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00001D54                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00001D54
.text$mn:00001D54 arg_0           = dword ptr  8
.text$mn:00001D54 arg_4           = dword ptr  0Ch
.text$mn:00001D54
.text$mn:00001D54                 push    ebp
.text$mn:00001D55                 mov     ebp, esp
.text$mn:00001D57                 mov     eax, [ebp+arg_4]
.text$mn:00001D5A                 push    eax
.text$mn:00001D5B                 mov     ecx, [ebp+arg_0]
.text$mn:00001D5E                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001D63                 pop     ebp
.text$mn:00001D64                 retn
.text$mn:00001D64 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00001D64
.text$mn:00001D64 ; ---------------------------------------------------------------------------
.text$mn:00001D65                 align 4
.text$mn:00001D65 _text$mn        ends
.text$mn:00001D65
.text$mn:00001D68 ; ===========================================================================
.text$mn:00001D68
.text$mn:00001D68 ; Segment type: Pure code
.text$mn:00001D68 ; Segment permissions: Read/Execute
.text$mn:00001D68 _text$mn        segment para public 'CODE' use32
.text$mn:00001D68                 assume cs:_text$mn
.text$mn:00001D68                 ;org 1D68h
.text$mn:00001D68 ; COMDAT (pick any)
.text$mn:00001D68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D68
.text$mn:00001D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D68
.text$mn:00001D68 ; Attributes: bp-based frame
.text$mn:00001D68
.text$mn:00001D68 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>::destroy<struct SwitcherFileInfo>(struct SwitcherFileInfo *)
.text$mn:00001D68                 public ??$destroy@USwitcherFileInfo@@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@@Z
.text$mn:00001D68 ??$destroy@USwitcherFileInfo@@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@@Z proc near
.text$mn:00001D68                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00001D68                                         ; __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00001D68
.text$mn:00001D68 var_4           = dword ptr -4
.text$mn:00001D68 arg_0           = dword ptr  8
.text$mn:00001D68
.text$mn:00001D68                 push    ebp
.text$mn:00001D69                 mov     ebp, esp
.text$mn:00001D6B                 push    ecx
.text$mn:00001D6C                 mov     [ebp+var_4], ecx
.text$mn:00001D6F                 mov     eax, [ebp+arg_0]
.text$mn:00001D72                 push    eax
.text$mn:00001D73                 mov     ecx, [ebp+var_4]
.text$mn:00001D76                 push    ecx
.text$mn:00001D77                 call    ??$destroy@USwitcherFileInfo@@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@@Z ; std::allocator_traits<std::allocator<SwitcherFileInfo>>::destroy<SwitcherFileInfo>(std::allocator<SwitcherFileInfo> &,SwitcherFileInfo *)
.text$mn:00001D7C                 add     esp, 8
.text$mn:00001D7F                 mov     esp, ebp
.text$mn:00001D81                 pop     ebp
.text$mn:00001D82                 retn    4
.text$mn:00001D82 ??$destroy@USwitcherFileInfo@@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@@Z endp
.text$mn:00001D82
.text$mn:00001D82 ; ---------------------------------------------------------------------------
.text$mn:00001D85                 align 4
.text$mn:00001D85 _text$mn        ends
.text$mn:00001D85
.text$mn:00001D88 ; ===========================================================================
.text$mn:00001D88
.text$mn:00001D88 ; Segment type: Pure code
.text$mn:00001D88 ; Segment permissions: Read/Execute
.text$mn:00001D88 _text$mn        segment para public 'CODE' use32
.text$mn:00001D88                 assume cs:_text$mn
.text$mn:00001D88                 ;org 1D88h
.text$mn:00001D88 ; COMDAT (pick any)
.text$mn:00001D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D88
.text$mn:00001D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D88
.text$mn:00001D88 ; Attributes: bp-based frame
.text$mn:00001D88
.text$mn:00001D88 ; public: void __thiscall std::allocator<struct SwitcherFileInfo>::destroy<struct SwitcherFileInfo>(struct SwitcherFileInfo *)
.text$mn:00001D88                 public ??$destroy@USwitcherFileInfo@@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@@Z
.text$mn:00001D88 ??$destroy@USwitcherFileInfo@@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@@Z proc near
.text$mn:00001D88                                         ; CODE XREF: std::allocator_traits<std::allocator<SwitcherFileInfo>>::destroy<SwitcherFileInfo>(std::allocator<SwitcherFileInfo> &,SwitcherFileInfo *)+Ap
.text$mn:00001D88
.text$mn:00001D88 var_4           = dword ptr -4
.text$mn:00001D88
.text$mn:00001D88                 push    ebp
.text$mn:00001D89                 mov     ebp, esp
.text$mn:00001D8B                 push    ecx
.text$mn:00001D8C                 mov     [ebp+var_4], ecx
.text$mn:00001D8F                 mov     esp, ebp
.text$mn:00001D91                 pop     ebp
.text$mn:00001D92                 retn    4
.text$mn:00001D92 ??$destroy@USwitcherFileInfo@@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@@Z endp
.text$mn:00001D92
.text$mn:00001D92 ; ---------------------------------------------------------------------------
.text$mn:00001D95                 align 4
.text$mn:00001D95 _text$mn        ends
.text$mn:00001D95
.text$mn:00001D98 ; ===========================================================================
.text$mn:00001D98
.text$mn:00001D98 ; Segment type: Pure code
.text$mn:00001D98 ; Segment permissions: Read/Execute
.text$mn:00001D98 _text$mn        segment para public 'CODE' use32
.text$mn:00001D98                 assume cs:_text$mn
.text$mn:00001D98                 ;org 1D98h
.text$mn:00001D98 ; COMDAT (pick any)
.text$mn:00001D98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D98
.text$mn:00001D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D98
.text$mn:00001D98 ; Attributes: bp-based frame
.text$mn:00001D98
.text$mn:00001D98 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct SwitcherFileInfo>>::destroy<struct SwitcherFileInfo>(class std::allocator<struct SwitcherFileInfo> &, struct SwitcherFileInfo *)
.text$mn:00001D98                 public ??$destroy@USwitcherFileInfo@@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@@Z
.text$mn:00001D98 ??$destroy@USwitcherFileInfo@@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@@Z proc near
.text$mn:00001D98                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::destroy<SwitcherFileInfo>(SwitcherFileInfo *)+Fp
.text$mn:00001D98
.text$mn:00001D98 arg_0           = dword ptr  8
.text$mn:00001D98 arg_4           = dword ptr  0Ch
.text$mn:00001D98
.text$mn:00001D98                 push    ebp
.text$mn:00001D99                 mov     ebp, esp
.text$mn:00001D9B                 mov     eax, [ebp+arg_4]
.text$mn:00001D9E                 push    eax
.text$mn:00001D9F                 mov     ecx, [ebp+arg_0]
.text$mn:00001DA2                 call    ??$destroy@USwitcherFileInfo@@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@@Z ; std::allocator<SwitcherFileInfo>::destroy<SwitcherFileInfo>(SwitcherFileInfo *)
.text$mn:00001DA7                 pop     ebp
.text$mn:00001DA8                 retn
.text$mn:00001DA8 ??$destroy@USwitcherFileInfo@@@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAXAAV?$allocator@USwitcherFileInfo@@@1@PAUSwitcherFileInfo@@@Z endp
.text$mn:00001DA8
.text$mn:00001DA8 ; ---------------------------------------------------------------------------
.text$mn:00001DA9                 align 4
.text$mn:00001DA9 _text$mn        ends
.text$mn:00001DA9
.text$mn:00001DAC ; ===========================================================================
.text$mn:00001DAC
.text$mn:00001DAC ; Segment type: Pure code
.text$mn:00001DAC ; Segment permissions: Read/Execute
.text$mn:00001DAC _text$mn        segment para public 'CODE' use32
.text$mn:00001DAC                 assume cs:_text$mn
.text$mn:00001DAC                 ;org 1DACh
.text$mn:00001DAC ; COMDAT (pick any)
.text$mn:00001DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DAC
.text$mn:00001DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DAC
.text$mn:00001DAC ; Attributes: bp-based frame
.text$mn:00001DAC
.text$mn:00001DAC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>>::destroy<struct TaskLstFnStatus>(struct TaskLstFnStatus *)
.text$mn:00001DAC                 public ??$destroy@UTaskLstFnStatus@@@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@@Z
.text$mn:00001DAC ??$destroy@UTaskLstFnStatus@@@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@@Z proc near
.text$mn:00001DAC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00001DAC
.text$mn:00001DAC var_4           = dword ptr -4
.text$mn:00001DAC arg_0           = dword ptr  8
.text$mn:00001DAC
.text$mn:00001DAC                 push    ebp
.text$mn:00001DAD                 mov     ebp, esp
.text$mn:00001DAF                 push    ecx
.text$mn:00001DB0                 mov     [ebp+var_4], ecx
.text$mn:00001DB3                 mov     eax, [ebp+arg_0]
.text$mn:00001DB6                 push    eax
.text$mn:00001DB7                 mov     ecx, [ebp+var_4]
.text$mn:00001DBA                 push    ecx
.text$mn:00001DBB                 call    ??$destroy@UTaskLstFnStatus@@@?$allocator_traits@V?$allocator@UTaskLstFnStatus@@@std@@@std@@SAXAAV?$allocator@UTaskLstFnStatus@@@1@PAUTaskLstFnStatus@@@Z ; std::allocator_traits<std::allocator<TaskLstFnStatus>>::destroy<TaskLstFnStatus>(std::allocator<TaskLstFnStatus> &,TaskLstFnStatus *)
.text$mn:00001DC0                 add     esp, 8
.text$mn:00001DC3                 mov     esp, ebp
.text$mn:00001DC5                 pop     ebp
.text$mn:00001DC6                 retn    4
.text$mn:00001DC6 ??$destroy@UTaskLstFnStatus@@@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@@Z endp
.text$mn:00001DC6
.text$mn:00001DC6 ; ---------------------------------------------------------------------------
.text$mn:00001DC9                 align 4
.text$mn:00001DC9 _text$mn        ends
.text$mn:00001DC9
.text$mn:00001DCC ; ===========================================================================
.text$mn:00001DCC
.text$mn:00001DCC ; Segment type: Pure code
.text$mn:00001DCC ; Segment permissions: Read/Execute
.text$mn:00001DCC _text$mn        segment para public 'CODE' use32
.text$mn:00001DCC                 assume cs:_text$mn
.text$mn:00001DCC                 ;org 1DCCh
.text$mn:00001DCC ; COMDAT (pick any)
.text$mn:00001DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DCC
.text$mn:00001DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DCC
.text$mn:00001DCC ; Attributes: bp-based frame
.text$mn:00001DCC
.text$mn:00001DCC ; public: void __thiscall std::allocator<struct TaskLstFnStatus>::destroy<struct TaskLstFnStatus>(struct TaskLstFnStatus *)
.text$mn:00001DCC                 public ??$destroy@UTaskLstFnStatus@@@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@@Z
.text$mn:00001DCC ??$destroy@UTaskLstFnStatus@@@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@@Z proc near
.text$mn:00001DCC                                         ; CODE XREF: std::allocator_traits<std::allocator<TaskLstFnStatus>>::destroy<TaskLstFnStatus>(std::allocator<TaskLstFnStatus> &,TaskLstFnStatus *)+Ap
.text$mn:00001DCC
.text$mn:00001DCC var_4           = dword ptr -4
.text$mn:00001DCC arg_0           = dword ptr  8
.text$mn:00001DCC
.text$mn:00001DCC                 push    ebp
.text$mn:00001DCD                 mov     ebp, esp
.text$mn:00001DCF                 push    ecx
.text$mn:00001DD0                 mov     [ebp+var_4], ecx
.text$mn:00001DD3                 push    0
.text$mn:00001DD5                 mov     ecx, [ebp+arg_0]
.text$mn:00001DD8                 call    ??_GTaskLstFnStatus@@QAEPAXI@Z ; TaskLstFnStatus::`scalar deleting destructor'(uint)
.text$mn:00001DDD                 mov     esp, ebp
.text$mn:00001DDF                 pop     ebp
.text$mn:00001DE0                 retn    4
.text$mn:00001DE0 ??$destroy@UTaskLstFnStatus@@@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@@Z endp
.text$mn:00001DE0
.text$mn:00001DE0 ; ---------------------------------------------------------------------------
.text$mn:00001DE3                 align 4
.text$mn:00001DE3 _text$mn        ends
.text$mn:00001DE3
.text$mn:00001DE4 ; ===========================================================================
.text$mn:00001DE4
.text$mn:00001DE4 ; Segment type: Pure code
.text$mn:00001DE4 ; Segment permissions: Read/Execute
.text$mn:00001DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE4                 assume cs:_text$mn
.text$mn:00001DE4                 ;org 1DE4h
.text$mn:00001DE4 ; COMDAT (pick any)
.text$mn:00001DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DE4
.text$mn:00001DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE4
.text$mn:00001DE4 ; Attributes: bp-based frame
.text$mn:00001DE4
.text$mn:00001DE4 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct TaskLstFnStatus>>::destroy<struct TaskLstFnStatus>(class std::allocator<struct TaskLstFnStatus> &, struct TaskLstFnStatus *)
.text$mn:00001DE4                 public ??$destroy@UTaskLstFnStatus@@@?$allocator_traits@V?$allocator@UTaskLstFnStatus@@@std@@@std@@SAXAAV?$allocator@UTaskLstFnStatus@@@1@PAUTaskLstFnStatus@@@Z
.text$mn:00001DE4 ??$destroy@UTaskLstFnStatus@@@?$allocator_traits@V?$allocator@UTaskLstFnStatus@@@std@@@std@@SAXAAV?$allocator@UTaskLstFnStatus@@@1@PAUTaskLstFnStatus@@@Z proc near
.text$mn:00001DE4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>::destroy<TaskLstFnStatus>(TaskLstFnStatus *)+Fp
.text$mn:00001DE4
.text$mn:00001DE4 arg_0           = dword ptr  8
.text$mn:00001DE4 arg_4           = dword ptr  0Ch
.text$mn:00001DE4
.text$mn:00001DE4                 push    ebp
.text$mn:00001DE5                 mov     ebp, esp
.text$mn:00001DE7                 mov     eax, [ebp+arg_4]
.text$mn:00001DEA                 push    eax
.text$mn:00001DEB                 mov     ecx, [ebp+arg_0]
.text$mn:00001DEE                 call    ??$destroy@UTaskLstFnStatus@@@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@@Z ; std::allocator<TaskLstFnStatus>::destroy<TaskLstFnStatus>(TaskLstFnStatus *)
.text$mn:00001DF3                 pop     ebp
.text$mn:00001DF4                 retn
.text$mn:00001DF4 ??$destroy@UTaskLstFnStatus@@@?$allocator_traits@V?$allocator@UTaskLstFnStatus@@@std@@@std@@SAXAAV?$allocator@UTaskLstFnStatus@@@1@PAUTaskLstFnStatus@@@Z endp
.text$mn:00001DF4
.text$mn:00001DF4 ; ---------------------------------------------------------------------------
.text$mn:00001DF5                 align 4
.text$mn:00001DF5 _text$mn        ends
.text$mn:00001DF5
.text$mn:00001DF8 ; ===========================================================================
.text$mn:00001DF8
.text$mn:00001DF8 ; Segment type: Pure code
.text$mn:00001DF8 ; Segment permissions: Read/Execute
.text$mn:00001DF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF8                 assume cs:_text$mn
.text$mn:00001DF8                 ;org 1DF8h
.text$mn:00001DF8 ; COMDAT (pick any)
.text$mn:00001DF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DF8
.text$mn:00001DF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF8
.text$mn:00001DF8 ; Attributes: bp-based frame
.text$mn:00001DF8
.text$mn:00001DF8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001DF8                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001DF8 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001DF8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Free_proxy(void)+22p
.text$mn:00001DF8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Free_proxy(void)+22p
.text$mn:00001DF8
.text$mn:00001DF8 var_4           = dword ptr -4
.text$mn:00001DF8 arg_0           = dword ptr  8
.text$mn:00001DF8
.text$mn:00001DF8                 push    ebp
.text$mn:00001DF9                 mov     ebp, esp
.text$mn:00001DFB                 push    ecx
.text$mn:00001DFC                 mov     [ebp+var_4], ecx
.text$mn:00001DFF                 mov     eax, [ebp+arg_0]
.text$mn:00001E02                 push    eax
.text$mn:00001E03                 mov     ecx, [ebp+var_4]
.text$mn:00001E06                 push    ecx
.text$mn:00001E07                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00001E0C                 add     esp, 8
.text$mn:00001E0F                 mov     esp, ebp
.text$mn:00001E11                 pop     ebp
.text$mn:00001E12                 retn    4
.text$mn:00001E12 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00001E12
.text$mn:00001E12 ; ---------------------------------------------------------------------------
.text$mn:00001E15                 align 4
.text$mn:00001E15 _text$mn        ends
.text$mn:00001E15
.text$mn:00001E18 ; ===========================================================================
.text$mn:00001E18
.text$mn:00001E18 ; Segment type: Pure code
.text$mn:00001E18 ; Segment permissions: Read/Execute
.text$mn:00001E18 _text$mn        segment para public 'CODE' use32
.text$mn:00001E18                 assume cs:_text$mn
.text$mn:00001E18                 ;org 1E18h
.text$mn:00001E18 ; COMDAT (pick any)
.text$mn:00001E18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E18
.text$mn:00001E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E18
.text$mn:00001E18 ; Attributes: bp-based frame
.text$mn:00001E18
.text$mn:00001E18 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001E18                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001E18 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001E18                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00001E18                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00001E18
.text$mn:00001E18 var_4           = dword ptr -4
.text$mn:00001E18
.text$mn:00001E18                 push    ebp
.text$mn:00001E19                 mov     ebp, esp
.text$mn:00001E1B                 push    ecx
.text$mn:00001E1C                 mov     [ebp+var_4], ecx
.text$mn:00001E1F                 mov     esp, ebp
.text$mn:00001E21                 pop     ebp
.text$mn:00001E22                 retn    4
.text$mn:00001E22 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00001E22
.text$mn:00001E22 ; ---------------------------------------------------------------------------
.text$mn:00001E25                 align 4
.text$mn:00001E25 _text$mn        ends
.text$mn:00001E25
.text$mn:00001E28 ; ===========================================================================
.text$mn:00001E28
.text$mn:00001E28 ; Segment type: Pure code
.text$mn:00001E28 ; Segment permissions: Read/Execute
.text$mn:00001E28 _text$mn        segment para public 'CODE' use32
.text$mn:00001E28                 assume cs:_text$mn
.text$mn:00001E28                 ;org 1E28h
.text$mn:00001E28 ; COMDAT (pick any)
.text$mn:00001E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E28
.text$mn:00001E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E28
.text$mn:00001E28 ; Attributes: bp-based frame
.text$mn:00001E28
.text$mn:00001E28 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00001E28                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00001E28 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00001E28                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00001E28
.text$mn:00001E28 arg_0           = dword ptr  8
.text$mn:00001E28 arg_4           = dword ptr  0Ch
.text$mn:00001E28
.text$mn:00001E28                 push    ebp
.text$mn:00001E29                 mov     ebp, esp
.text$mn:00001E2B                 mov     eax, [ebp+arg_4]
.text$mn:00001E2E                 push    eax
.text$mn:00001E2F                 mov     ecx, [ebp+arg_0]
.text$mn:00001E32                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001E37                 pop     ebp
.text$mn:00001E38                 retn
.text$mn:00001E38 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00001E38
.text$mn:00001E38 ; ---------------------------------------------------------------------------
.text$mn:00001E39                 align 4
.text$mn:00001E39 _text$mn        ends
.text$mn:00001E39
.text$mn:00001E3C ; ===========================================================================
.text$mn:00001E3C
.text$mn:00001E3C ; Segment type: Pure code
.text$mn:00001E3C ; Segment permissions: Read/Execute
.text$mn:00001E3C _text$mn        segment para public 'CODE' use32
.text$mn:00001E3C                 assume cs:_text$mn
.text$mn:00001E3C                 ;org 1E3Ch
.text$mn:00001E3C ; COMDAT (pick any)
.text$mn:00001E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E3C
.text$mn:00001E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E3C
.text$mn:00001E3C ; Attributes: bp-based frame
.text$mn:00001E3C
.text$mn:00001E3C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00001E3C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00001E3C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00001E3C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00001E3C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00001E3C
.text$mn:00001E3C arg_0           = dword ptr  8
.text$mn:00001E3C
.text$mn:00001E3C                 push    ebp
.text$mn:00001E3D                 mov     ebp, esp
.text$mn:00001E3F                 mov     eax, [ebp+arg_0]
.text$mn:00001E42                 pop     ebp
.text$mn:00001E43                 retn
.text$mn:00001E43 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00001E43
.text$mn:00001E43 _text$mn        ends
.text$mn:00001E43
.text$mn:00001E44 ; ===========================================================================
.text$mn:00001E44
.text$mn:00001E44 ; Segment type: Pure code
.text$mn:00001E44 ; Segment permissions: Read/Execute
.text$mn:00001E44 _text$mn        segment para public 'CODE' use32
.text$mn:00001E44                 assume cs:_text$mn
.text$mn:00001E44                 ;org 1E44h
.text$mn:00001E44 ; COMDAT (pick any)
.text$mn:00001E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E44
.text$mn:00001E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E44
.text$mn:00001E44 ; Attributes: bp-based frame
.text$mn:00001E44
.text$mn:00001E44 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001E44                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00001E44 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00001E44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00001E44                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00001E44
.text$mn:00001E44 arg_0           = dword ptr  8
.text$mn:00001E44
.text$mn:00001E44                 push    ebp
.text$mn:00001E45                 mov     ebp, esp
.text$mn:00001E47                 mov     eax, [ebp+arg_0]
.text$mn:00001E4A                 pop     ebp
.text$mn:00001E4B                 retn
.text$mn:00001E4B ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00001E4B
.text$mn:00001E4B _text$mn        ends
.text$mn:00001E4B
.text$mn:00001E4C ; ===========================================================================
.text$mn:00001E4C
.text$mn:00001E4C ; Segment type: Pure code
.text$mn:00001E4C ; Segment permissions: Read/Execute
.text$mn:00001E4C _text$mn        segment para public 'CODE' use32
.text$mn:00001E4C                 assume cs:_text$mn
.text$mn:00001E4C                 ;org 1E4Ch
.text$mn:00001E4C ; COMDAT (pick any)
.text$mn:00001E4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E4C
.text$mn:00001E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E4C
.text$mn:00001E4C ; Attributes: bp-based frame
.text$mn:00001E4C
.text$mn:00001E4C ; struct SwitcherFileInfo && __cdecl std::forward<struct SwitcherFileInfo>(struct SwitcherFileInfo &)
.text$mn:00001E4C                 public ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z
.text$mn:00001E4C ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z proc near
.text$mn:00001E4C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)+Bp
.text$mn:00001E4C                                         ; std::allocator<SwitcherFileInfo>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)+4Ap ...
.text$mn:00001E4C
.text$mn:00001E4C arg_0           = dword ptr  8
.text$mn:00001E4C
.text$mn:00001E4C                 push    ebp
.text$mn:00001E4D                 mov     ebp, esp
.text$mn:00001E4F                 mov     eax, [ebp+arg_0]
.text$mn:00001E52                 pop     ebp
.text$mn:00001E53                 retn
.text$mn:00001E53 ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z endp
.text$mn:00001E53
.text$mn:00001E53 _text$mn        ends
.text$mn:00001E53
.text$mn:00001E54 ; ===========================================================================
.text$mn:00001E54
.text$mn:00001E54 ; Segment type: Pure code
.text$mn:00001E54 ; Segment permissions: Read/Execute
.text$mn:00001E54 _text$mn        segment para public 'CODE' use32
.text$mn:00001E54                 assume cs:_text$mn
.text$mn:00001E54                 ;org 1E54h
.text$mn:00001E54 ; COMDAT (pick any)
.text$mn:00001E54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E54
.text$mn:00001E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E54
.text$mn:00001E54 ; Attributes: bp-based frame
.text$mn:00001E54
.text$mn:00001E54 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00001E54                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00001E54 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00001E54                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00001E54                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00001E54
.text$mn:00001E54 arg_0           = dword ptr  8
.text$mn:00001E54
.text$mn:00001E54                 push    ebp
.text$mn:00001E55                 mov     ebp, esp
.text$mn:00001E57                 mov     eax, [ebp+arg_0]
.text$mn:00001E5A                 pop     ebp
.text$mn:00001E5B                 retn
.text$mn:00001E5B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00001E5B
.text$mn:00001E5B _text$mn        ends
.text$mn:00001E5B
.text$mn:00001E5C ; ===========================================================================
.text$mn:00001E5C
.text$mn:00001E5C ; Segment type: Pure code
.text$mn:00001E5C ; Segment permissions: Read/Execute
.text$mn:00001E5C _text$mn        segment para public 'CODE' use32
.text$mn:00001E5C                 assume cs:_text$mn
.text$mn:00001E5C                 ;org 1E5Ch
.text$mn:00001E5C ; COMDAT (pick any)
.text$mn:00001E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E5C
.text$mn:00001E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E5C
.text$mn:00001E5C ; Attributes: bp-based frame
.text$mn:00001E5C
.text$mn:00001E5C ; class std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>> && __cdecl std::forward<class std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>(class std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>> &)
.text$mn:00001E5C                 public ??$forward@V?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YA$$QAV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@0@AAV10@@Z
.text$mn:00001E5C ??$forward@V?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YA$$QAV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@0@AAV10@@Z proc near
.text$mn:00001E5C                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&)+52p
.text$mn:00001E5C
.text$mn:00001E5C arg_0           = dword ptr  8
.text$mn:00001E5C
.text$mn:00001E5C                 push    ebp
.text$mn:00001E5D                 mov     ebp, esp
.text$mn:00001E5F                 mov     eax, [ebp+arg_0]
.text$mn:00001E62                 pop     ebp
.text$mn:00001E63                 retn
.text$mn:00001E63 ??$forward@V?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YA$$QAV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@0@AAV10@@Z endp
.text$mn:00001E63
.text$mn:00001E63 _text$mn        ends
.text$mn:00001E63
.text$mn:00001E64 ; ===========================================================================
.text$mn:00001E64
.text$mn:00001E64 ; Segment type: Pure code
.text$mn:00001E64 ; Segment permissions: Read/Execute
.text$mn:00001E64 _text$mn        segment para public 'CODE' use32
.text$mn:00001E64                 assume cs:_text$mn
.text$mn:00001E64                 ;org 1E64h
.text$mn:00001E64 ; COMDAT (pick any)
.text$mn:00001E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E64
.text$mn:00001E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E64
.text$mn:00001E64 ; Attributes: bp-based frame
.text$mn:00001E64
.text$mn:00001E64 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00001E64                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001E64 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00001E64                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00001E64
.text$mn:00001E64 var_10          = dword ptr -10h
.text$mn:00001E64 var_C           = dword ptr -0Ch
.text$mn:00001E64 var_4           = dword ptr -4
.text$mn:00001E64
.text$mn:00001E64                 push    ebp
.text$mn:00001E65                 mov     ebp, esp
.text$mn:00001E67                 push    0FFFFFFFFh
.text$mn:00001E69                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001E6E                 mov     eax, large fs:0
.text$mn:00001E74                 push    eax
.text$mn:00001E75                 push    ecx
.text$mn:00001E76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E7B                 xor     eax, ebp
.text$mn:00001E7D                 push    eax
.text$mn:00001E7E                 lea     eax, [ebp+var_C]
.text$mn:00001E81                 mov     large fs:0, eax
.text$mn:00001E87                 mov     [ebp+var_10], ecx
.text$mn:00001E8A                 mov     ecx, [ebp+var_10]
.text$mn:00001E8D                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00001E92                 mov     [ebp+var_4], 0
.text$mn:00001E99                 mov     ecx, [ebp+var_10]
.text$mn:00001E9C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001EA1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001EA8                 mov     eax, [ebp+var_10]
.text$mn:00001EAB                 mov     ecx, [ebp+var_C]
.text$mn:00001EAE                 mov     large fs:0, ecx
.text$mn:00001EB5                 pop     ecx
.text$mn:00001EB6                 mov     esp, ebp
.text$mn:00001EB8                 pop     ebp
.text$mn:00001EB9                 retn    4
.text$mn:00001EB9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00001EB9
.text$mn:00001EB9 _text$mn        ends
.text$mn:00001EB9
.text$x:00001EBC ; ===========================================================================
.text$x:00001EBC
.text$x:00001EBC ; Segment type: Pure code
.text$x:00001EBC ; Segment permissions: Read/Execute
.text$x:00001EBC _text$x         segment para public 'CODE' use32
.text$x:00001EBC                 assume cs:_text$x
.text$x:00001EBC                 ;org 1EBCh
.text$x:00001EBC ; COMDAT (pick associative to section at 1E64)
.text$x:00001EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001EBC
.text$x:00001EBC ; =============== S U B R O U T I N E =======================================
.text$x:00001EBC
.text$x:00001EBC
.text$x:00001EBC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00001EBC                                         ; DATA XREF: .xdata$x:00005940o
.text$x:00001EBC                 mov     ecx, [ebp-10h]
.text$x:00001EBF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001EBF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00001EBF
.text$x:00001EC4
.text$x:00001EC4 ; =============== S U B R O U T I N E =======================================
.text$x:00001EC4
.text$x:00001EC4
.text$x:00001EC4 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00001EC4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00001EC4
.text$x:00001EC4 arg_4           = dword ptr  8
.text$x:00001EC4
.text$x:00001EC4                 mov     edx, [esp+arg_4]
.text$x:00001EC8                 lea     eax, [edx+0Ch]
.text$x:00001ECB                 mov     ecx, [edx-8]
.text$x:00001ECE                 xor     ecx, eax
.text$x:00001ED0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001ED5                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00001EDA                 jmp     ___CxxFrameHandler3
.text$x:00001EDA __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00001EDA
.text$x:00001EDA ; ---------------------------------------------------------------------------
.text$x:00001EDF                 align 10h
.text$x:00001EDF _text$x         ends
.text$x:00001EDF
.text$mn:00001EE0 ; ===========================================================================
.text$mn:00001EE0
.text$mn:00001EE0 ; Segment type: Pure code
.text$mn:00001EE0 ; Segment permissions: Read/Execute
.text$mn:00001EE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001EE0                 assume cs:_text$mn
.text$mn:00001EE0                 ;org 1EE0h
.text$mn:00001EE0 ; COMDAT (pick any)
.text$mn:00001EE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EE0
.text$mn:00001EE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EE0
.text$mn:00001EE0 ; Attributes: bp-based frame
.text$mn:00001EE0
.text$mn:00001EE0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00001EE0                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00001EE0 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00001EE0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p
.text$mn:00001EE0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:00001EE0
.text$mn:00001EE0 var_10          = dword ptr -10h
.text$mn:00001EE0 var_C           = dword ptr -0Ch
.text$mn:00001EE0 var_4           = dword ptr -4
.text$mn:00001EE0
.text$mn:00001EE0                 push    ebp
.text$mn:00001EE1                 mov     ebp, esp
.text$mn:00001EE3                 push    0FFFFFFFFh
.text$mn:00001EE5                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00001EEA                 mov     eax, large fs:0
.text$mn:00001EF0                 push    eax
.text$mn:00001EF1                 push    ecx
.text$mn:00001EF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001EF7                 xor     eax, ebp
.text$mn:00001EF9                 push    eax
.text$mn:00001EFA                 lea     eax, [ebp+var_C]
.text$mn:00001EFD                 mov     large fs:0, eax
.text$mn:00001F03                 mov     [ebp+var_10], ecx
.text$mn:00001F06                 mov     ecx, [ebp+var_10]
.text$mn:00001F09                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00001F0E                 mov     [ebp+var_4], 0
.text$mn:00001F15                 mov     ecx, [ebp+var_10]
.text$mn:00001F18                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00001F1D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F24                 mov     eax, [ebp+var_10]
.text$mn:00001F27                 mov     ecx, [ebp+var_C]
.text$mn:00001F2A                 mov     large fs:0, ecx
.text$mn:00001F31                 pop     ecx
.text$mn:00001F32                 mov     esp, ebp
.text$mn:00001F34                 pop     ebp
.text$mn:00001F35                 retn    4
.text$mn:00001F35 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00001F35
.text$mn:00001F35 _text$mn        ends
.text$mn:00001F35
.text$x:00001F38 ; ===========================================================================
.text$x:00001F38
.text$x:00001F38 ; Segment type: Pure code
.text$x:00001F38 ; Segment permissions: Read/Execute
.text$x:00001F38 _text$x         segment para public 'CODE' use32
.text$x:00001F38                 assume cs:_text$x
.text$x:00001F38                 ;org 1F38h
.text$x:00001F38 ; COMDAT (pick associative to section at 1EE0)
.text$x:00001F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001F38
.text$x:00001F38 ; =============== S U B R O U T I N E =======================================
.text$x:00001F38
.text$x:00001F38
.text$x:00001F38 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00001F38                                         ; DATA XREF: .xdata$x:00005CE4o
.text$x:00001F38                 mov     ecx, [ebp-10h]
.text$x:00001F3B                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00001F3B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00001F3B
.text$x:00001F40
.text$x:00001F40 ; =============== S U B R O U T I N E =======================================
.text$x:00001F40
.text$x:00001F40
.text$x:00001F40 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00001F40                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00001F40
.text$x:00001F40 arg_4           = dword ptr  8
.text$x:00001F40
.text$x:00001F40                 mov     edx, [esp+arg_4]
.text$x:00001F44                 lea     eax, [edx+0Ch]
.text$x:00001F47                 mov     ecx, [edx-8]
.text$x:00001F4A                 xor     ecx, eax
.text$x:00001F4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F51                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00001F56                 jmp     ___CxxFrameHandler3
.text$x:00001F56 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00001F56
.text$x:00001F56 ; ---------------------------------------------------------------------------
.text$x:00001F5B                 align 4
.text$x:00001F5B _text$x         ends
.text$x:00001F5B
.text$mn:00001F5C ; ===========================================================================
.text$mn:00001F5C
.text$mn:00001F5C ; Segment type: Pure code
.text$mn:00001F5C ; Segment permissions: Read/Execute
.text$mn:00001F5C _text$mn        segment para public 'CODE' use32
.text$mn:00001F5C                 assume cs:_text$mn
.text$mn:00001F5C                 ;org 1F5Ch
.text$mn:00001F5C ; COMDAT (pick any)
.text$mn:00001F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F5C
.text$mn:00001F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F5C
.text$mn:00001F5C ; Attributes: bp-based frame
.text$mn:00001F5C
.text$mn:00001F5C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001F5C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001F5C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001F5C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00001F5C
.text$mn:00001F5C var_10          = dword ptr -10h
.text$mn:00001F5C var_C           = dword ptr -0Ch
.text$mn:00001F5C var_4           = dword ptr -4
.text$mn:00001F5C
.text$mn:00001F5C                 push    ebp
.text$mn:00001F5D                 mov     ebp, esp
.text$mn:00001F5F                 push    0FFFFFFFFh
.text$mn:00001F61                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001F66                 mov     eax, large fs:0
.text$mn:00001F6C                 push    eax
.text$mn:00001F6D                 push    ecx
.text$mn:00001F6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F73                 xor     eax, ebp
.text$mn:00001F75                 push    eax
.text$mn:00001F76                 lea     eax, [ebp+var_C]
.text$mn:00001F79                 mov     large fs:0, eax
.text$mn:00001F7F                 mov     [ebp+var_10], ecx
.text$mn:00001F82                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001F85                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00001F8A                 mov     [ebp+var_4], 0
.text$mn:00001F91                 mov     eax, [ebp+var_10]
.text$mn:00001F94                 mov     dword ptr [eax+14h], 0
.text$mn:00001F9B                 mov     ecx, [ebp+var_10]
.text$mn:00001F9E                 mov     dword ptr [ecx+18h], 0
.text$mn:00001FA5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001FAC                 mov     eax, [ebp+var_10]
.text$mn:00001FAF                 mov     ecx, [ebp+var_C]
.text$mn:00001FB2                 mov     large fs:0, ecx
.text$mn:00001FB9                 pop     ecx
.text$mn:00001FBA                 mov     esp, ebp
.text$mn:00001FBC                 pop     ebp
.text$mn:00001FBD                 retn
.text$mn:00001FBD ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001FBD
.text$mn:00001FBD ; ---------------------------------------------------------------------------
.text$mn:00001FBE                 align 10h
.text$mn:00001FBE _text$mn        ends
.text$mn:00001FBE
.text$x:00001FC0 ; ===========================================================================
.text$x:00001FC0
.text$x:00001FC0 ; Segment type: Pure code
.text$x:00001FC0 ; Segment permissions: Read/Execute
.text$x:00001FC0 _text$x         segment para public 'CODE' use32
.text$x:00001FC0                 assume cs:_text$x
.text$x:00001FC0                 ;org 1FC0h
.text$x:00001FC0 ; COMDAT (pick associative to section at 1F5C)
.text$x:00001FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001FC0
.text$x:00001FC0 ; =============== S U B R O U T I N E =======================================
.text$x:00001FC0
.text$x:00001FC0
.text$x:00001FC0 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001FC0                                         ; DATA XREF: .xdata$x:000058E8o
.text$x:00001FC0                 mov     ecx, [ebp-10h]  ; this
.text$x:00001FC3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001FC3 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001FC3
.text$x:00001FC8
.text$x:00001FC8 ; =============== S U B R O U T I N E =======================================
.text$x:00001FC8
.text$x:00001FC8
.text$x:00001FC8 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001FC8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001FC8
.text$x:00001FC8 arg_4           = dword ptr  8
.text$x:00001FC8
.text$x:00001FC8                 mov     edx, [esp+arg_4]
.text$x:00001FCC                 lea     eax, [edx+0Ch]
.text$x:00001FCF                 mov     ecx, [edx-8]
.text$x:00001FD2                 xor     ecx, eax
.text$x:00001FD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001FD9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001FDE                 jmp     ___CxxFrameHandler3
.text$x:00001FDE __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001FDE
.text$x:00001FDE ; ---------------------------------------------------------------------------
.text$x:00001FE3                 align 4
.text$x:00001FE3 _text$x         ends
.text$x:00001FE3
.text$mn:00001FE4 ; ===========================================================================
.text$mn:00001FE4
.text$mn:00001FE4 ; Segment type: Pure code
.text$mn:00001FE4 ; Segment permissions: Read/Execute
.text$mn:00001FE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FE4                 assume cs:_text$mn
.text$mn:00001FE4                 ;org 1FE4h
.text$mn:00001FE4 ; COMDAT (pick any)
.text$mn:00001FE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FE4
.text$mn:00001FE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FE4
.text$mn:00001FE4 ; Attributes: bp-based frame
.text$mn:00001FE4
.text$mn:00001FE4 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00001FE4                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001FE4 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00001FE4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00001FE4
.text$mn:00001FE4 var_10          = dword ptr -10h
.text$mn:00001FE4 var_C           = dword ptr -0Ch
.text$mn:00001FE4 var_4           = dword ptr -4
.text$mn:00001FE4
.text$mn:00001FE4                 push    ebp
.text$mn:00001FE5                 mov     ebp, esp
.text$mn:00001FE7                 push    0FFFFFFFFh
.text$mn:00001FE9                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001FEE                 mov     eax, large fs:0
.text$mn:00001FF4                 push    eax
.text$mn:00001FF5                 push    ecx
.text$mn:00001FF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FFB                 xor     eax, ebp
.text$mn:00001FFD                 push    eax
.text$mn:00001FFE                 lea     eax, [ebp+var_C]
.text$mn:00002001                 mov     large fs:0, eax
.text$mn:00002007                 mov     [ebp+var_10], ecx
.text$mn:0000200A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000200D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002012                 mov     [ebp+var_4], 0
.text$mn:00002019                 mov     eax, [ebp+var_10]
.text$mn:0000201C                 mov     dword ptr [eax+14h], 0
.text$mn:00002023                 mov     ecx, [ebp+var_10]
.text$mn:00002026                 mov     dword ptr [ecx+18h], 0
.text$mn:0000202D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002034                 mov     eax, [ebp+var_10]
.text$mn:00002037                 mov     ecx, [ebp+var_C]
.text$mn:0000203A                 mov     large fs:0, ecx
.text$mn:00002041                 pop     ecx
.text$mn:00002042                 mov     esp, ebp
.text$mn:00002044                 pop     ebp
.text$mn:00002045                 retn
.text$mn:00002045 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00002045
.text$mn:00002045 ; ---------------------------------------------------------------------------
.text$mn:00002046                 align 4
.text$mn:00002046 _text$mn        ends
.text$mn:00002046
.text$x:00002048 ; ===========================================================================
.text$x:00002048
.text$x:00002048 ; Segment type: Pure code
.text$x:00002048 ; Segment permissions: Read/Execute
.text$x:00002048 _text$x         segment para public 'CODE' use32
.text$x:00002048                 assume cs:_text$x
.text$x:00002048                 ;org 2048h
.text$x:00002048 ; COMDAT (pick associative to section at 1FE4)
.text$x:00002048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002048
.text$x:00002048 ; =============== S U B R O U T I N E =======================================
.text$x:00002048
.text$x:00002048
.text$x:00002048 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00002048                                         ; DATA XREF: .xdata$x:00005C8Co
.text$x:00002048                 mov     ecx, [ebp-10h]  ; this
.text$x:0000204B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000204B __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000204B
.text$x:00002050
.text$x:00002050 ; =============== S U B R O U T I N E =======================================
.text$x:00002050
.text$x:00002050
.text$x:00002050 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00002050                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00002050
.text$x:00002050 arg_4           = dword ptr  8
.text$x:00002050
.text$x:00002050                 mov     edx, [esp+arg_4]
.text$x:00002054                 lea     eax, [edx+0Ch]
.text$x:00002057                 mov     ecx, [edx-8]
.text$x:0000205A                 xor     ecx, eax
.text$x:0000205C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002061                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00002066                 jmp     ___CxxFrameHandler3
.text$x:00002066 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00002066
.text$x:00002066 ; ---------------------------------------------------------------------------
.text$x:0000206B                 align 4
.text$x:0000206B _text$x         ends
.text$x:0000206B
.text$mn:0000206C ; ===========================================================================
.text$mn:0000206C
.text$mn:0000206C ; Segment type: Pure code
.text$mn:0000206C ; Segment permissions: Read/Execute
.text$mn:0000206C _text$mn        segment para public 'CODE' use32
.text$mn:0000206C                 assume cs:_text$mn
.text$mn:0000206C                 ;org 206Ch
.text$mn:0000206C ; COMDAT (pick any)
.text$mn:0000206C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000206C
.text$mn:0000206C ; =============== S U B R O U T I N E =======================================
.text$mn:0000206C
.text$mn:0000206C ; Attributes: bp-based frame
.text$mn:0000206C
.text$mn:0000206C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>(class std::allocator<struct SwitcherFileInfo> const &)
.text$mn:0000206C                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z
.text$mn:0000206C ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z proc near
.text$mn:0000206C                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&)+38p
.text$mn:0000206C                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)+34p
.text$mn:0000206C
.text$mn:0000206C var_10          = dword ptr -10h
.text$mn:0000206C var_C           = dword ptr -0Ch
.text$mn:0000206C var_4           = dword ptr -4
.text$mn:0000206C
.text$mn:0000206C                 push    ebp
.text$mn:0000206D                 mov     ebp, esp
.text$mn:0000206F                 push    0FFFFFFFFh
.text$mn:00002071                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z
.text$mn:00002076                 mov     eax, large fs:0
.text$mn:0000207C                 push    eax
.text$mn:0000207D                 push    ecx
.text$mn:0000207E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002083                 xor     eax, ebp
.text$mn:00002085                 push    eax
.text$mn:00002086                 lea     eax, [ebp+var_C]
.text$mn:00002089                 mov     large fs:0, eax
.text$mn:0000208F                 mov     [ebp+var_10], ecx
.text$mn:00002092                 mov     ecx, [ebp+var_10]
.text$mn:00002095                 call    ??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SwitcherFileInfo>>::_Vector_val<std::_Simple_types<SwitcherFileInfo>>(void)
.text$mn:0000209A                 mov     [ebp+var_4], 0
.text$mn:000020A1                 mov     ecx, [ebp+var_10]
.text$mn:000020A4                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Alloc_proxy(void)
.text$mn:000020A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000020B0                 mov     eax, [ebp+var_10]
.text$mn:000020B3                 mov     ecx, [ebp+var_C]
.text$mn:000020B6                 mov     large fs:0, ecx
.text$mn:000020BD                 pop     ecx
.text$mn:000020BE                 mov     esp, ebp
.text$mn:000020C0                 pop     ebp
.text$mn:000020C1                 retn    4
.text$mn:000020C1 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z endp
.text$mn:000020C1
.text$mn:000020C1 _text$mn        ends
.text$mn:000020C1
.text$x:000020C4 ; ===========================================================================
.text$x:000020C4
.text$x:000020C4 ; Segment type: Pure code
.text$x:000020C4 ; Segment permissions: Read/Execute
.text$x:000020C4 _text$x         segment para public 'CODE' use32
.text$x:000020C4                 assume cs:_text$x
.text$x:000020C4                 ;org 20C4h
.text$x:000020C4 ; COMDAT (pick associative to section at 206C)
.text$x:000020C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000020C4
.text$x:000020C4 ; =============== S U B R O U T I N E =======================================
.text$x:000020C4
.text$x:000020C4
.text$x:000020C4 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z$0 proc near
.text$x:000020C4                                         ; DATA XREF: .xdata$x:0000614Co
.text$x:000020C4                 mov     ecx, [ebp-10h]
.text$x:000020C7                 jmp     ??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SwitcherFileInfo>>::~_Vector_val<std::_Simple_types<SwitcherFileInfo>>(void)
.text$x:000020C7 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z$0 endp
.text$x:000020C7
.text$x:000020CC
.text$x:000020CC ; =============== S U B R O U T I N E =======================================
.text$x:000020CC
.text$x:000020CC
.text$x:000020CC __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z proc near
.text$x:000020CC                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(std::allocator<SwitcherFileInfo> const &)+5o
.text$x:000020CC
.text$x:000020CC arg_4           = dword ptr  8
.text$x:000020CC
.text$x:000020CC                 mov     edx, [esp+arg_4]
.text$x:000020D0                 lea     eax, [edx+0Ch]
.text$x:000020D3                 mov     ecx, [edx-8]
.text$x:000020D6                 xor     ecx, eax
.text$x:000020D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000020DD                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z
.text$x:000020E2                 jmp     ___CxxFrameHandler3
.text$x:000020E2 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z endp
.text$x:000020E2
.text$x:000020E2 ; ---------------------------------------------------------------------------
.text$x:000020E7                 align 4
.text$x:000020E7 _text$x         ends
.text$x:000020E7
.text$mn:000020E8 ; ===========================================================================
.text$mn:000020E8
.text$mn:000020E8 ; Segment type: Pure code
.text$mn:000020E8 ; Segment permissions: Read/Execute
.text$mn:000020E8 _text$mn        segment para public 'CODE' use32
.text$mn:000020E8                 assume cs:_text$mn
.text$mn:000020E8                 ;org 20E8h
.text$mn:000020E8 ; COMDAT (pick any)
.text$mn:000020E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020E8
.text$mn:000020E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000020E8
.text$mn:000020E8 ; Attributes: bp-based frame
.text$mn:000020E8
.text$mn:000020E8 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>>(class std::allocator<struct TaskLstFnStatus> const &)
.text$mn:000020E8                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z
.text$mn:000020E8 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z proc near
.text$mn:000020E8                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)+34p
.text$mn:000020E8
.text$mn:000020E8 var_10          = dword ptr -10h
.text$mn:000020E8 var_C           = dword ptr -0Ch
.text$mn:000020E8 var_4           = dword ptr -4
.text$mn:000020E8
.text$mn:000020E8                 push    ebp
.text$mn:000020E9                 mov     ebp, esp
.text$mn:000020EB                 push    0FFFFFFFFh
.text$mn:000020ED                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z
.text$mn:000020F2                 mov     eax, large fs:0
.text$mn:000020F8                 push    eax
.text$mn:000020F9                 push    ecx
.text$mn:000020FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000020FF                 xor     eax, ebp
.text$mn:00002101                 push    eax
.text$mn:00002102                 lea     eax, [ebp+var_C]
.text$mn:00002105                 mov     large fs:0, eax
.text$mn:0000210B                 mov     [ebp+var_10], ecx
.text$mn:0000210E                 mov     ecx, [ebp+var_10]
.text$mn:00002111                 call    ??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TaskLstFnStatus>>::_Vector_val<std::_Simple_types<TaskLstFnStatus>>(void)
.text$mn:00002116                 mov     [ebp+var_4], 0
.text$mn:0000211D                 mov     ecx, [ebp+var_10]
.text$mn:00002120                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Alloc_proxy(void)
.text$mn:00002125                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000212C                 mov     eax, [ebp+var_10]
.text$mn:0000212F                 mov     ecx, [ebp+var_C]
.text$mn:00002132                 mov     large fs:0, ecx
.text$mn:00002139                 pop     ecx
.text$mn:0000213A                 mov     esp, ebp
.text$mn:0000213C                 pop     ebp
.text$mn:0000213D                 retn    4
.text$mn:0000213D ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z endp
.text$mn:0000213D
.text$mn:0000213D _text$mn        ends
.text$mn:0000213D
.text$x:00002140 ; ===========================================================================
.text$x:00002140
.text$x:00002140 ; Segment type: Pure code
.text$x:00002140 ; Segment permissions: Read/Execute
.text$x:00002140 _text$x         segment para public 'CODE' use32
.text$x:00002140                 assume cs:_text$x
.text$x:00002140                 ;org 2140h
.text$x:00002140 ; COMDAT (pick associative to section at 20E8)
.text$x:00002140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002140
.text$x:00002140 ; =============== S U B R O U T I N E =======================================
.text$x:00002140
.text$x:00002140
.text$x:00002140 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z$0 proc near
.text$x:00002140                                         ; DATA XREF: .xdata$x:00005F04o
.text$x:00002140                 mov     ecx, [ebp-10h]
.text$x:00002143                 jmp     ??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TaskLstFnStatus>>::~_Vector_val<std::_Simple_types<TaskLstFnStatus>>(void)
.text$x:00002143 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z$0 endp
.text$x:00002143
.text$x:00002148
.text$x:00002148 ; =============== S U B R O U T I N E =======================================
.text$x:00002148
.text$x:00002148
.text$x:00002148 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z proc near
.text$x:00002148                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(std::allocator<TaskLstFnStatus> const &)+5o
.text$x:00002148
.text$x:00002148 arg_4           = dword ptr  8
.text$x:00002148
.text$x:00002148                 mov     edx, [esp+arg_4]
.text$x:0000214C                 lea     eax, [edx+0Ch]
.text$x:0000214F                 mov     ecx, [edx-8]
.text$x:00002152                 xor     ecx, eax
.text$x:00002154                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002159                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z
.text$x:0000215E                 jmp     ___CxxFrameHandler3
.text$x:0000215E __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z endp
.text$x:0000215E
.text$x:0000215E ; ---------------------------------------------------------------------------
.text$x:00002163                 align 4
.text$x:00002163 _text$x         ends
.text$x:00002163
.text$mn:00002164 ; ===========================================================================
.text$mn:00002164
.text$mn:00002164 ; Segment type: Pure code
.text$mn:00002164 ; Segment permissions: Read/Execute
.text$mn:00002164 _text$mn        segment para public 'CODE' use32
.text$mn:00002164                 assume cs:_text$mn
.text$mn:00002164                 ;org 2164h
.text$mn:00002164 ; COMDAT (pick any)
.text$mn:00002164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002164
.text$mn:00002164 ; =============== S U B R O U T I N E =======================================
.text$mn:00002164
.text$mn:00002164 ; Attributes: bp-based frame
.text$mn:00002164
.text$mn:00002164 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct SwitcherFileInfo>>::_Vector_val<struct std::_Simple_types<struct SwitcherFileInfo>>(void)
.text$mn:00002164                 public ??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00002164 ??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:00002164                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(std::allocator<SwitcherFileInfo> const &)+29p
.text$mn:00002164
.text$mn:00002164 var_10          = dword ptr -10h
.text$mn:00002164 var_C           = dword ptr -0Ch
.text$mn:00002164 var_4           = dword ptr -4
.text$mn:00002164
.text$mn:00002164                 push    ebp
.text$mn:00002165                 mov     ebp, esp
.text$mn:00002167                 push    0FFFFFFFFh
.text$mn:00002169                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000216E                 mov     eax, large fs:0
.text$mn:00002174                 push    eax
.text$mn:00002175                 push    ecx
.text$mn:00002176                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000217B                 xor     eax, ebp
.text$mn:0000217D                 push    eax
.text$mn:0000217E                 lea     eax, [ebp+var_C]
.text$mn:00002181                 mov     large fs:0, eax
.text$mn:00002187                 mov     [ebp+var_10], ecx
.text$mn:0000218A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000218D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002192                 mov     [ebp+var_4], 0
.text$mn:00002199                 mov     eax, [ebp+var_10]
.text$mn:0000219C                 mov     dword ptr [eax+4], 0
.text$mn:000021A3                 mov     ecx, [ebp+var_10]
.text$mn:000021A6                 mov     dword ptr [ecx+8], 0
.text$mn:000021AD                 mov     edx, [ebp+var_10]
.text$mn:000021B0                 mov     dword ptr [edx+0Ch], 0
.text$mn:000021B7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000021BE                 mov     eax, [ebp+var_10]
.text$mn:000021C1                 mov     ecx, [ebp+var_C]
.text$mn:000021C4                 mov     large fs:0, ecx
.text$mn:000021CB                 pop     ecx
.text$mn:000021CC                 mov     esp, ebp
.text$mn:000021CE                 pop     ebp
.text$mn:000021CF                 retn
.text$mn:000021CF ??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:000021CF
.text$mn:000021CF _text$mn        ends
.text$mn:000021CF
.text$x:000021D0 ; ===========================================================================
.text$x:000021D0
.text$x:000021D0 ; Segment type: Pure code
.text$x:000021D0 ; Segment permissions: Read/Execute
.text$x:000021D0 _text$x         segment para public 'CODE' use32
.text$x:000021D0                 assume cs:_text$x
.text$x:000021D0                 ;org 21D0h
.text$x:000021D0 ; COMDAT (pick associative to section at 2164)
.text$x:000021D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000021D0
.text$x:000021D0 ; =============== S U B R O U T I N E =======================================
.text$x:000021D0
.text$x:000021D0
.text$x:000021D0 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000021D0                                         ; DATA XREF: .xdata$x:000060F4o
.text$x:000021D0                 mov     ecx, [ebp-10h]  ; this
.text$x:000021D3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000021D3 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:000021D3
.text$x:000021D8
.text$x:000021D8 ; =============== S U B R O U T I N E =======================================
.text$x:000021D8
.text$x:000021D8
.text$x:000021D8 __ehhandler$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:000021D8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<SwitcherFileInfo>>::_Vector_val<std::_Simple_types<SwitcherFileInfo>>(void)+5o
.text$x:000021D8
.text$x:000021D8 arg_4           = dword ptr  8
.text$x:000021D8
.text$x:000021D8                 mov     edx, [esp+arg_4]
.text$x:000021DC                 lea     eax, [edx+0Ch]
.text$x:000021DF                 mov     ecx, [edx-8]
.text$x:000021E2                 xor     ecx, eax
.text$x:000021E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000021E9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$x:000021EE                 jmp     ___CxxFrameHandler3
.text$x:000021EE __ehhandler$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:000021EE
.text$x:000021EE ; ---------------------------------------------------------------------------
.text$x:000021F3                 align 4
.text$x:000021F3 _text$x         ends
.text$x:000021F3
.text$mn:000021F4 ; ===========================================================================
.text$mn:000021F4
.text$mn:000021F4 ; Segment type: Pure code
.text$mn:000021F4 ; Segment permissions: Read/Execute
.text$mn:000021F4 _text$mn        segment para public 'CODE' use32
.text$mn:000021F4                 assume cs:_text$mn
.text$mn:000021F4                 ;org 21F4h
.text$mn:000021F4 ; COMDAT (pick any)
.text$mn:000021F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021F4
.text$mn:000021F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021F4
.text$mn:000021F4 ; Attributes: bp-based frame
.text$mn:000021F4
.text$mn:000021F4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct TaskLstFnStatus>>::_Vector_val<struct std::_Simple_types<struct TaskLstFnStatus>>(void)
.text$mn:000021F4                 public ??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:000021F4 ??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$mn:000021F4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(std::allocator<TaskLstFnStatus> const &)+29p
.text$mn:000021F4
.text$mn:000021F4 var_10          = dword ptr -10h
.text$mn:000021F4 var_C           = dword ptr -0Ch
.text$mn:000021F4 var_4           = dword ptr -4
.text$mn:000021F4
.text$mn:000021F4                 push    ebp
.text$mn:000021F5                 mov     ebp, esp
.text$mn:000021F7                 push    0FFFFFFFFh
.text$mn:000021F9                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:000021FE                 mov     eax, large fs:0
.text$mn:00002204                 push    eax
.text$mn:00002205                 push    ecx
.text$mn:00002206                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000220B                 xor     eax, ebp
.text$mn:0000220D                 push    eax
.text$mn:0000220E                 lea     eax, [ebp+var_C]
.text$mn:00002211                 mov     large fs:0, eax
.text$mn:00002217                 mov     [ebp+var_10], ecx
.text$mn:0000221A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000221D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002222                 mov     [ebp+var_4], 0
.text$mn:00002229                 mov     eax, [ebp+var_10]
.text$mn:0000222C                 mov     dword ptr [eax+4], 0
.text$mn:00002233                 mov     ecx, [ebp+var_10]
.text$mn:00002236                 mov     dword ptr [ecx+8], 0
.text$mn:0000223D                 mov     edx, [ebp+var_10]
.text$mn:00002240                 mov     dword ptr [edx+0Ch], 0
.text$mn:00002247                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000224E                 mov     eax, [ebp+var_10]
.text$mn:00002251                 mov     ecx, [ebp+var_C]
.text$mn:00002254                 mov     large fs:0, ecx
.text$mn:0000225B                 pop     ecx
.text$mn:0000225C                 mov     esp, ebp
.text$mn:0000225E                 pop     ebp
.text$mn:0000225F                 retn
.text$mn:0000225F ??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$mn:0000225F
.text$mn:0000225F _text$mn        ends
.text$mn:0000225F
.text$x:00002260 ; ===========================================================================
.text$x:00002260
.text$x:00002260 ; Segment type: Pure code
.text$x:00002260 ; Segment permissions: Read/Execute
.text$x:00002260 _text$x         segment para public 'CODE' use32
.text$x:00002260                 assume cs:_text$x
.text$x:00002260                 ;org 2260h
.text$x:00002260 ; COMDAT (pick associative to section at 21F4)
.text$x:00002260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002260
.text$x:00002260 ; =============== S U B R O U T I N E =======================================
.text$x:00002260
.text$x:00002260
.text$x:00002260 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002260                                         ; DATA XREF: .xdata$x:00005EACo
.text$x:00002260                 mov     ecx, [ebp-10h]  ; this
.text$x:00002263                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002263 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002263
.text$x:00002268
.text$x:00002268 ; =============== S U B R O U T I N E =======================================
.text$x:00002268
.text$x:00002268
.text$x:00002268 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$x:00002268                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<TaskLstFnStatus>>::_Vector_val<std::_Simple_types<TaskLstFnStatus>>(void)+5o
.text$x:00002268
.text$x:00002268 arg_4           = dword ptr  8
.text$x:00002268
.text$x:00002268                 mov     edx, [esp+arg_4]
.text$x:0000226C                 lea     eax, [edx+0Ch]
.text$x:0000226F                 mov     ecx, [edx-8]
.text$x:00002272                 xor     ecx, eax
.text$x:00002274                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002279                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$x:0000227E                 jmp     ___CxxFrameHandler3
.text$x:0000227E __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$x:0000227E
.text$x:0000227E ; ---------------------------------------------------------------------------
.text$x:00002283                 align 4
.text$x:00002283 _text$x         ends
.text$x:00002283
.text$mn:00002284 ; ===========================================================================
.text$mn:00002284
.text$mn:00002284 ; Segment type: Pure code
.text$mn:00002284 ; Segment permissions: Read/Execute
.text$mn:00002284 _text$mn        segment para public 'CODE' use32
.text$mn:00002284                 assume cs:_text$mn
.text$mn:00002284                 ;org 2284h
.text$mn:00002284 ; COMDAT (pick any)
.text$mn:00002284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002284
.text$mn:00002284 ; =============== S U B R O U T I N E =======================================
.text$mn:00002284
.text$mn:00002284 ; Attributes: bp-based frame
.text$mn:00002284
.text$mn:00002284 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00002284                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00002284 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00002284                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00002284
.text$mn:00002284 var_4           = dword ptr -4
.text$mn:00002284
.text$mn:00002284                 push    ebp
.text$mn:00002285                 mov     ebp, esp
.text$mn:00002287                 push    ecx
.text$mn:00002288                 mov     [ebp+var_4], ecx
.text$mn:0000228B                 mov     ecx, [ebp+var_4]
.text$mn:0000228E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00002293                 mov     eax, [ebp+var_4]
.text$mn:00002296                 mov     esp, ebp
.text$mn:00002298                 pop     ebp
.text$mn:00002299                 retn
.text$mn:00002299 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00002299
.text$mn:00002299 ; ---------------------------------------------------------------------------
.text$mn:0000229A                 align 4
.text$mn:0000229A _text$mn        ends
.text$mn:0000229A
.text$mn:0000229C ; ===========================================================================
.text$mn:0000229C
.text$mn:0000229C ; Segment type: Pure code
.text$mn:0000229C ; Segment permissions: Read/Execute
.text$mn:0000229C _text$mn        segment para public 'CODE' use32
.text$mn:0000229C                 assume cs:_text$mn
.text$mn:0000229C                 ;org 229Ch
.text$mn:0000229C ; COMDAT (pick any)
.text$mn:0000229C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000229C
.text$mn:0000229C ; =============== S U B R O U T I N E =======================================
.text$mn:0000229C
.text$mn:0000229C ; Attributes: bp-based frame
.text$mn:0000229C
.text$mn:0000229C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>(void)
.text$mn:0000229C                 public ??0?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:0000229C ??0?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:0000229C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)+Ap
.text$mn:0000229C
.text$mn:0000229C var_4           = dword ptr -4
.text$mn:0000229C
.text$mn:0000229C                 push    ebp
.text$mn:0000229D                 mov     ebp, esp
.text$mn:0000229F                 push    ecx
.text$mn:000022A0                 mov     [ebp+var_4], ecx
.text$mn:000022A3                 mov     ecx, [ebp+var_4]
.text$mn:000022A6                 call    ??0?$allocator@USwitcherFileInfo@@@std@@QAE@XZ ; std::allocator<SwitcherFileInfo>::allocator<SwitcherFileInfo>(void)
.text$mn:000022AB                 mov     eax, [ebp+var_4]
.text$mn:000022AE                 mov     esp, ebp
.text$mn:000022B0                 pop     ebp
.text$mn:000022B1                 retn
.text$mn:000022B1 ??0?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:000022B1
.text$mn:000022B1 ; ---------------------------------------------------------------------------
.text$mn:000022B2                 align 4
.text$mn:000022B2 _text$mn        ends
.text$mn:000022B2
.text$mn:000022B4 ; ===========================================================================
.text$mn:000022B4
.text$mn:000022B4 ; Segment type: Pure code
.text$mn:000022B4 ; Segment permissions: Read/Execute
.text$mn:000022B4 _text$mn        segment para public 'CODE' use32
.text$mn:000022B4                 assume cs:_text$mn
.text$mn:000022B4                 ;org 22B4h
.text$mn:000022B4 ; COMDAT (pick any)
.text$mn:000022B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022B4
.text$mn:000022B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022B4
.text$mn:000022B4 ; Attributes: bp-based frame
.text$mn:000022B4
.text$mn:000022B4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>>::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>>(void)
.text$mn:000022B4                 public ??0?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:000022B4 ??0?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$mn:000022B4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Getal(void)+Ap
.text$mn:000022B4
.text$mn:000022B4 var_4           = dword ptr -4
.text$mn:000022B4
.text$mn:000022B4                 push    ebp
.text$mn:000022B5                 mov     ebp, esp
.text$mn:000022B7                 push    ecx
.text$mn:000022B8                 mov     [ebp+var_4], ecx
.text$mn:000022BB                 mov     ecx, [ebp+var_4]
.text$mn:000022BE                 call    ??0?$allocator@UTaskLstFnStatus@@@std@@QAE@XZ ; std::allocator<TaskLstFnStatus>::allocator<TaskLstFnStatus>(void)
.text$mn:000022C3                 mov     eax, [ebp+var_4]
.text$mn:000022C6                 mov     esp, ebp
.text$mn:000022C8                 pop     ebp
.text$mn:000022C9                 retn
.text$mn:000022C9 ??0?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$mn:000022C9
.text$mn:000022C9 ; ---------------------------------------------------------------------------
.text$mn:000022CA                 align 4
.text$mn:000022CA _text$mn        ends
.text$mn:000022CA
.text$mn:000022CC ; ===========================================================================
.text$mn:000022CC
.text$mn:000022CC ; Segment type: Pure code
.text$mn:000022CC ; Segment permissions: Read/Execute
.text$mn:000022CC _text$mn        segment para public 'CODE' use32
.text$mn:000022CC                 assume cs:_text$mn
.text$mn:000022CC                 ;org 22CCh
.text$mn:000022CC ; COMDAT (pick any)
.text$mn:000022CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022CC
.text$mn:000022CC ; =============== S U B R O U T I N E =======================================
.text$mn:000022CC
.text$mn:000022CC ; Attributes: bp-based frame
.text$mn:000022CC
.text$mn:000022CC ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000022CC                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000022CC ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000022CC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Alloc_proxy(void)+Cp
.text$mn:000022CC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000022CC
.text$mn:000022CC var_4           = dword ptr -4
.text$mn:000022CC
.text$mn:000022CC                 push    ebp
.text$mn:000022CD                 mov     ebp, esp
.text$mn:000022CF                 push    ecx
.text$mn:000022D0                 mov     [ebp+var_4], ecx
.text$mn:000022D3                 mov     ecx, [ebp+var_4]
.text$mn:000022D6                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000022DB                 mov     eax, [ebp+var_4]
.text$mn:000022DE                 mov     esp, ebp
.text$mn:000022E0                 pop     ebp
.text$mn:000022E1                 retn
.text$mn:000022E1 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:000022E1
.text$mn:000022E1 ; ---------------------------------------------------------------------------
.text$mn:000022E2                 align 4
.text$mn:000022E2 _text$mn        ends
.text$mn:000022E2
.text$mn:000022E4 ; ===========================================================================
.text$mn:000022E4
.text$mn:000022E4 ; Segment type: Pure code
.text$mn:000022E4 ; Segment permissions: Read/Execute
.text$mn:000022E4 _text$mn        segment para public 'CODE' use32
.text$mn:000022E4                 assume cs:_text$mn
.text$mn:000022E4                 ;org 22E4h
.text$mn:000022E4 ; COMDAT (pick any)
.text$mn:000022E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022E4
.text$mn:000022E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022E4
.text$mn:000022E4 ; Attributes: bp-based frame
.text$mn:000022E4
.text$mn:000022E4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:000022E4                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000022E4 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:000022E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:000022E4
.text$mn:000022E4 var_4           = dword ptr -4
.text$mn:000022E4 arg_0           = dword ptr  8
.text$mn:000022E4
.text$mn:000022E4                 push    ebp
.text$mn:000022E5                 mov     ebp, esp
.text$mn:000022E7                 push    ecx
.text$mn:000022E8                 mov     [ebp+var_4], ecx
.text$mn:000022EB                 mov     eax, [ebp+arg_0]
.text$mn:000022EE                 push    eax
.text$mn:000022EF                 mov     ecx, [ebp+var_4]
.text$mn:000022F2                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:000022F7                 mov     eax, [ebp+var_4]
.text$mn:000022FA                 mov     esp, ebp
.text$mn:000022FC                 pop     ebp
.text$mn:000022FD                 retn    4
.text$mn:000022FD ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:000022FD
.text$mn:000022FD _text$mn        ends
.text$mn:000022FD
.text$mn:00002300 ; ===========================================================================
.text$mn:00002300
.text$mn:00002300 ; Segment type: Pure code
.text$mn:00002300 ; Segment permissions: Read/Execute
.text$mn:00002300 _text$mn        segment para public 'CODE' use32
.text$mn:00002300                 assume cs:_text$mn
.text$mn:00002300                 ;org 2300h
.text$mn:00002300 ; COMDAT (pick any)
.text$mn:00002300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002300
.text$mn:00002300 ; =============== S U B R O U T I N E =======================================
.text$mn:00002300
.text$mn:00002300 ; Attributes: bp-based frame
.text$mn:00002300
.text$mn:00002300 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00002300                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00002300 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00002300                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00002300
.text$mn:00002300 var_4           = dword ptr -4
.text$mn:00002300
.text$mn:00002300                 push    ebp
.text$mn:00002301                 mov     ebp, esp
.text$mn:00002303                 push    ecx
.text$mn:00002304                 mov     [ebp+var_4], ecx
.text$mn:00002307                 mov     ecx, [ebp+var_4]
.text$mn:0000230A                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000230F                 mov     eax, [ebp+var_4]
.text$mn:00002312                 mov     esp, ebp
.text$mn:00002314                 pop     ebp
.text$mn:00002315                 retn
.text$mn:00002315 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00002315
.text$mn:00002315 ; ---------------------------------------------------------------------------
.text$mn:00002316                 align 4
.text$mn:00002316 _text$mn        ends
.text$mn:00002316
.text$mn:00002318 ; ===========================================================================
.text$mn:00002318
.text$mn:00002318 ; Segment type: Pure code
.text$mn:00002318 ; Segment permissions: Read/Execute
.text$mn:00002318 _text$mn        segment para public 'CODE' use32
.text$mn:00002318                 assume cs:_text$mn
.text$mn:00002318                 ;org 2318h
.text$mn:00002318 ; COMDAT (pick any)
.text$mn:00002318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002318
.text$mn:00002318 ; =============== S U B R O U T I N E =======================================
.text$mn:00002318
.text$mn:00002318 ; Attributes: bp-based frame
.text$mn:00002318
.text$mn:00002318 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00002318                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00002318 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00002318                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00002318
.text$mn:00002318 var_4           = dword ptr -4
.text$mn:00002318
.text$mn:00002318                 push    ebp
.text$mn:00002319                 mov     ebp, esp
.text$mn:0000231B                 push    ecx
.text$mn:0000231C                 mov     [ebp+var_4], ecx
.text$mn:0000231F                 mov     eax, [ebp+var_4]
.text$mn:00002322                 mov     esp, ebp
.text$mn:00002324                 pop     ebp
.text$mn:00002325                 retn
.text$mn:00002325 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00002325
.text$mn:00002325 ; ---------------------------------------------------------------------------
.text$mn:00002326                 align 4
.text$mn:00002326 _text$mn        ends
.text$mn:00002326
.text$mn:00002328 ; ===========================================================================
.text$mn:00002328
.text$mn:00002328 ; Segment type: Pure code
.text$mn:00002328 ; Segment permissions: Read/Execute
.text$mn:00002328 _text$mn        segment para public 'CODE' use32
.text$mn:00002328                 assume cs:_text$mn
.text$mn:00002328                 ;org 2328h
.text$mn:00002328 ; COMDAT (pick any)
.text$mn:00002328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002328
.text$mn:00002328 ; =============== S U B R O U T I N E =======================================
.text$mn:00002328
.text$mn:00002328 ; Attributes: bp-based frame
.text$mn:00002328
.text$mn:00002328 ; public: __thiscall std::allocator<struct SwitcherFileInfo>::allocator<struct SwitcherFileInfo>(void)
.text$mn:00002328                 public ??0?$allocator@USwitcherFileInfo@@@std@@QAE@XZ
.text$mn:00002328 ??0?$allocator@USwitcherFileInfo@@@std@@QAE@XZ proc near
.text$mn:00002328                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::_Wrap_alloc<std::allocator<SwitcherFileInfo>>(void)+Ap
.text$mn:00002328                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)+2Bp
.text$mn:00002328
.text$mn:00002328 var_4           = dword ptr -4
.text$mn:00002328
.text$mn:00002328                 push    ebp
.text$mn:00002329                 mov     ebp, esp
.text$mn:0000232B                 push    ecx
.text$mn:0000232C                 mov     [ebp+var_4], ecx
.text$mn:0000232F                 mov     eax, [ebp+var_4]
.text$mn:00002332                 mov     esp, ebp
.text$mn:00002334                 pop     ebp
.text$mn:00002335                 retn
.text$mn:00002335 ??0?$allocator@USwitcherFileInfo@@@std@@QAE@XZ endp
.text$mn:00002335
.text$mn:00002335 ; ---------------------------------------------------------------------------
.text$mn:00002336                 align 4
.text$mn:00002336 _text$mn        ends
.text$mn:00002336
.text$mn:00002338 ; ===========================================================================
.text$mn:00002338
.text$mn:00002338 ; Segment type: Pure code
.text$mn:00002338 ; Segment permissions: Read/Execute
.text$mn:00002338 _text$mn        segment para public 'CODE' use32
.text$mn:00002338                 assume cs:_text$mn
.text$mn:00002338                 ;org 2338h
.text$mn:00002338 ; COMDAT (pick any)
.text$mn:00002338                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002338
.text$mn:00002338 ; =============== S U B R O U T I N E =======================================
.text$mn:00002338
.text$mn:00002338 ; Attributes: bp-based frame
.text$mn:00002338
.text$mn:00002338 ; public: __thiscall std::allocator<struct TaskLstFnStatus>::allocator<struct TaskLstFnStatus>(void)
.text$mn:00002338                 public ??0?$allocator@UTaskLstFnStatus@@@std@@QAE@XZ
.text$mn:00002338 ??0?$allocator@UTaskLstFnStatus@@@std@@QAE@XZ proc near
.text$mn:00002338                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>::_Wrap_alloc<std::allocator<TaskLstFnStatus>>(void)+Ap
.text$mn:00002338                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)+2Bp
.text$mn:00002338
.text$mn:00002338 var_4           = dword ptr -4
.text$mn:00002338
.text$mn:00002338                 push    ebp
.text$mn:00002339                 mov     ebp, esp
.text$mn:0000233B                 push    ecx
.text$mn:0000233C                 mov     [ebp+var_4], ecx
.text$mn:0000233F                 mov     eax, [ebp+var_4]
.text$mn:00002342                 mov     esp, ebp
.text$mn:00002344                 pop     ebp
.text$mn:00002345                 retn
.text$mn:00002345 ??0?$allocator@UTaskLstFnStatus@@@std@@QAE@XZ endp
.text$mn:00002345
.text$mn:00002345 ; ---------------------------------------------------------------------------
.text$mn:00002346                 align 4
.text$mn:00002346 _text$mn        ends
.text$mn:00002346
.text$mn:00002348 ; ===========================================================================
.text$mn:00002348
.text$mn:00002348 ; Segment type: Pure code
.text$mn:00002348 ; Segment permissions: Read/Execute
.text$mn:00002348 _text$mn        segment para public 'CODE' use32
.text$mn:00002348                 assume cs:_text$mn
.text$mn:00002348                 ;org 2348h
.text$mn:00002348 ; COMDAT (pick any)
.text$mn:00002348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002348
.text$mn:00002348 ; =============== S U B R O U T I N E =======================================
.text$mn:00002348
.text$mn:00002348 ; Attributes: bp-based frame
.text$mn:00002348
.text$mn:00002348 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00002348                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00002348 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00002348                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00002348                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00002348
.text$mn:00002348 var_4           = dword ptr -4
.text$mn:00002348
.text$mn:00002348                 push    ebp
.text$mn:00002349                 mov     ebp, esp
.text$mn:0000234B                 push    ecx
.text$mn:0000234C                 mov     [ebp+var_4], ecx
.text$mn:0000234F                 mov     eax, [ebp+var_4]
.text$mn:00002352                 mov     esp, ebp
.text$mn:00002354                 pop     ebp
.text$mn:00002355                 retn
.text$mn:00002355 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00002355
.text$mn:00002355 ; ---------------------------------------------------------------------------
.text$mn:00002356                 align 4
.text$mn:00002356 _text$mn        ends
.text$mn:00002356
.text$mn:00002358 ; ===========================================================================
.text$mn:00002358
.text$mn:00002358 ; Segment type: Pure code
.text$mn:00002358 ; Segment permissions: Read/Execute
.text$mn:00002358 _text$mn        segment para public 'CODE' use32
.text$mn:00002358                 assume cs:_text$mn
.text$mn:00002358                 ;org 2358h
.text$mn:00002358 ; COMDAT (pick any)
.text$mn:00002358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002358
.text$mn:00002358 ; =============== S U B R O U T I N E =======================================
.text$mn:00002358
.text$mn:00002358 ; Attributes: bp-based frame
.text$mn:00002358
.text$mn:00002358 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00002358                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00002358 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00002358                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)+Ep
.text$mn:00002358                                         ; std::allocator<wchar_t>::select_on_container_copy_construction(void)+Ep
.text$mn:00002358
.text$mn:00002358 var_4           = dword ptr -4
.text$mn:00002358
.text$mn:00002358                 push    ebp
.text$mn:00002359                 mov     ebp, esp
.text$mn:0000235B                 push    ecx
.text$mn:0000235C                 mov     [ebp+var_4], ecx
.text$mn:0000235F                 mov     eax, [ebp+var_4]
.text$mn:00002362                 mov     esp, ebp
.text$mn:00002364                 pop     ebp
.text$mn:00002365                 retn    4
.text$mn:00002365 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00002365
.text$mn:00002365 _text$mn        ends
.text$mn:00002365
.text$mn:00002368 ; ===========================================================================
.text$mn:00002368
.text$mn:00002368 ; Segment type: Pure code
.text$mn:00002368 ; Segment permissions: Read/Execute
.text$mn:00002368 _text$mn        segment para public 'CODE' use32
.text$mn:00002368                 assume cs:_text$mn
.text$mn:00002368                 ;org 2368h
.text$mn:00002368 ; COMDAT (pick any)
.text$mn:00002368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002368
.text$mn:00002368 ; =============== S U B R O U T I N E =======================================
.text$mn:00002368
.text$mn:00002368 ; Attributes: bp-based frame
.text$mn:00002368
.text$mn:00002368 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00002368                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00002368 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00002368                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp
.text$mn:00002368
.text$mn:00002368 var_4           = dword ptr -4
.text$mn:00002368
.text$mn:00002368                 push    ebp
.text$mn:00002369                 mov     ebp, esp
.text$mn:0000236B                 push    ecx
.text$mn:0000236C                 mov     [ebp+var_4], ecx
.text$mn:0000236F                 mov     eax, [ebp+var_4]
.text$mn:00002372                 mov     esp, ebp
.text$mn:00002374                 pop     ebp
.text$mn:00002375                 retn
.text$mn:00002375 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00002375
.text$mn:00002375 ; ---------------------------------------------------------------------------
.text$mn:00002376                 align 4
.text$mn:00002376 _text$mn        ends
.text$mn:00002376
.text$mn:00002378 ; ===========================================================================
.text$mn:00002378
.text$mn:00002378 ; Segment type: Pure code
.text$mn:00002378 ; Segment permissions: Read/Execute
.text$mn:00002378 _text$mn        segment para public 'CODE' use32
.text$mn:00002378                 assume cs:_text$mn
.text$mn:00002378                 ;org 2378h
.text$mn:00002378 ; COMDAT (pick any)
.text$mn:00002378                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002378
.text$mn:00002378 ; =============== S U B R O U T I N E =======================================
.text$mn:00002378
.text$mn:00002378 ; Attributes: bp-based frame
.text$mn:00002378
.text$mn:00002378 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00002378                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00002378 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00002378                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00002378                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00002378
.text$mn:00002378 var_14          = dword ptr -14h
.text$mn:00002378 var_D           = byte ptr -0Dh
.text$mn:00002378 var_C           = dword ptr -0Ch
.text$mn:00002378 var_4           = dword ptr -4
.text$mn:00002378 Str             = dword ptr  8
.text$mn:00002378
.text$mn:00002378                 push    ebp
.text$mn:00002379                 mov     ebp, esp
.text$mn:0000237B                 push    0FFFFFFFFh
.text$mn:0000237D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00002382                 mov     eax, large fs:0
.text$mn:00002388                 push    eax
.text$mn:00002389                 sub     esp, 8
.text$mn:0000238C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002391                 xor     eax, ebp
.text$mn:00002393                 push    eax
.text$mn:00002394                 lea     eax, [ebp+var_C]
.text$mn:00002397                 mov     large fs:0, eax
.text$mn:0000239D                 mov     [ebp+var_14], ecx
.text$mn:000023A0                 lea     ecx, [ebp+var_D]
.text$mn:000023A3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000023A8                 push    eax
.text$mn:000023A9                 mov     ecx, [ebp+var_14]
.text$mn:000023AC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000023B1                 mov     [ebp+var_4], 0
.text$mn:000023B8                 push    0               ; Size
.text$mn:000023BA                 push    0               ; char
.text$mn:000023BC                 mov     ecx, [ebp+var_14]
.text$mn:000023BF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000023C4                 mov     eax, [ebp+Str]
.text$mn:000023C7                 push    eax             ; Str
.text$mn:000023C8                 mov     ecx, [ebp+var_14]
.text$mn:000023CB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000023D0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000023D7                 mov     eax, [ebp+var_14]
.text$mn:000023DA                 mov     ecx, [ebp+var_C]
.text$mn:000023DD                 mov     large fs:0, ecx
.text$mn:000023E4                 pop     ecx
.text$mn:000023E5                 mov     esp, ebp
.text$mn:000023E7                 pop     ebp
.text$mn:000023E8                 retn    4
.text$mn:000023E8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000023E8
.text$mn:000023E8 ; ---------------------------------------------------------------------------
.text$mn:000023EB                 align 4
.text$mn:000023EB _text$mn        ends
.text$mn:000023EB
.text$x:000023EC ; ===========================================================================
.text$x:000023EC
.text$x:000023EC ; Segment type: Pure code
.text$x:000023EC ; Segment permissions: Read/Execute
.text$x:000023EC _text$x         segment para public 'CODE' use32
.text$x:000023EC                 assume cs:_text$x
.text$x:000023EC                 ;org 23ECh
.text$x:000023EC ; COMDAT (pick associative to section at 2378)
.text$x:000023EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000023EC
.text$x:000023EC ; =============== S U B R O U T I N E =======================================
.text$x:000023EC
.text$x:000023EC
.text$x:000023EC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000023EC                                         ; DATA XREF: .xdata$x:00005998o
.text$x:000023EC                 mov     ecx, [ebp-14h]
.text$x:000023EF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000023EF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000023EF
.text$x:000023F4
.text$x:000023F4 ; =============== S U B R O U T I N E =======================================
.text$x:000023F4
.text$x:000023F4
.text$x:000023F4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000023F4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000023F4
.text$x:000023F4 arg_4           = dword ptr  8
.text$x:000023F4
.text$x:000023F4                 mov     edx, [esp+arg_4]
.text$x:000023F8                 lea     eax, [edx+0Ch]
.text$x:000023FB                 mov     ecx, [edx-0Ch]
.text$x:000023FE                 xor     ecx, eax
.text$x:00002400                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002405                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000240A                 jmp     ___CxxFrameHandler3
.text$x:0000240A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000240A
.text$x:0000240A ; ---------------------------------------------------------------------------
.text$x:0000240F                 align 10h
.text$x:0000240F _text$x         ends
.text$x:0000240F
.text$mn:00002410 ; ===========================================================================
.text$mn:00002410
.text$mn:00002410 ; Segment type: Pure code
.text$mn:00002410 ; Segment permissions: Read/Execute
.text$mn:00002410 _text$mn        segment para public 'CODE' use32
.text$mn:00002410                 assume cs:_text$mn
.text$mn:00002410                 ;org 2410h
.text$mn:00002410 ; COMDAT (pick any)
.text$mn:00002410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002410
.text$mn:00002410 ; =============== S U B R O U T I N E =======================================
.text$mn:00002410
.text$mn:00002410 ; Attributes: bp-based frame
.text$mn:00002410
.text$mn:00002410 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00002410                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00002410 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:00002410                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+274p
.text$mn:00002410                                         ; VerticalFileSwitcherListView::getFullFilePath(uint)+ADp ...
.text$mn:00002410
.text$mn:00002410 var_14          = dword ptr -14h
.text$mn:00002410 var_E           = byte ptr -0Eh
.text$mn:00002410 var_D           = byte ptr -0Dh
.text$mn:00002410 var_C           = dword ptr -0Ch
.text$mn:00002410 var_4           = dword ptr -4
.text$mn:00002410 arg_0           = dword ptr  8
.text$mn:00002410
.text$mn:00002410                 push    ebp
.text$mn:00002411                 mov     ebp, esp
.text$mn:00002413                 push    0FFFFFFFFh
.text$mn:00002415                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:0000241A                 mov     eax, large fs:0
.text$mn:00002420                 push    eax
.text$mn:00002421                 sub     esp, 8
.text$mn:00002424                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002429                 xor     eax, ebp
.text$mn:0000242B                 push    eax
.text$mn:0000242C                 lea     eax, [ebp+var_C]
.text$mn:0000242F                 mov     large fs:0, eax
.text$mn:00002435                 mov     [ebp+var_14], ecx
.text$mn:00002438                 lea     eax, [ebp+var_D]
.text$mn:0000243B                 push    eax
.text$mn:0000243C                 lea     ecx, [ebp+var_E]
.text$mn:0000243F                 push    ecx
.text$mn:00002440                 mov     ecx, [ebp+arg_0]
.text$mn:00002443                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002448                 mov     ecx, eax
.text$mn:0000244A                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:0000244F                 push    eax
.text$mn:00002450                 mov     ecx, [ebp+var_14]
.text$mn:00002453                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00002458                 mov     [ebp+var_4], 0
.text$mn:0000245F                 push    0
.text$mn:00002461                 push    0
.text$mn:00002463                 mov     ecx, [ebp+var_14]
.text$mn:00002466                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000246B                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00002471                 push    edx
.text$mn:00002472                 push    0
.text$mn:00002474                 mov     eax, [ebp+arg_0]
.text$mn:00002477                 push    eax
.text$mn:00002478                 mov     ecx, [ebp+var_14]
.text$mn:0000247B                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00002480                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002487                 mov     eax, [ebp+var_14]
.text$mn:0000248A                 mov     ecx, [ebp+var_C]
.text$mn:0000248D                 mov     large fs:0, ecx
.text$mn:00002494                 pop     ecx
.text$mn:00002495                 mov     esp, ebp
.text$mn:00002497                 pop     ebp
.text$mn:00002498                 retn    4
.text$mn:00002498 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:00002498
.text$mn:00002498 ; ---------------------------------------------------------------------------
.text$mn:0000249B                 align 4
.text$mn:0000249B _text$mn        ends
.text$mn:0000249B
.text$x:0000249C ; ===========================================================================
.text$x:0000249C
.text$x:0000249C ; Segment type: Pure code
.text$x:0000249C ; Segment permissions: Read/Execute
.text$x:0000249C _text$x         segment para public 'CODE' use32
.text$x:0000249C                 assume cs:_text$x
.text$x:0000249C                 ;org 249Ch
.text$x:0000249C ; COMDAT (pick associative to section at 2410)
.text$x:0000249C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000249C
.text$x:0000249C ; =============== S U B R O U T I N E =======================================
.text$x:0000249C
.text$x:0000249C
.text$x:0000249C __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000249C                                         ; DATA XREF: .xdata$x:00005D3Co
.text$x:0000249C                 mov     ecx, [ebp-14h]
.text$x:0000249F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000249F __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000249F
.text$x:000024A4
.text$x:000024A4 ; =============== S U B R O U T I N E =======================================
.text$x:000024A4
.text$x:000024A4
.text$x:000024A4 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:000024A4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:000024A4
.text$x:000024A4 arg_4           = dword ptr  8
.text$x:000024A4
.text$x:000024A4                 mov     edx, [esp+arg_4]
.text$x:000024A8                 lea     eax, [edx+0Ch]
.text$x:000024AB                 mov     ecx, [edx-0Ch]
.text$x:000024AE                 xor     ecx, eax
.text$x:000024B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000024B5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:000024BA                 jmp     ___CxxFrameHandler3
.text$x:000024BA __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:000024BA
.text$x:000024BA ; ---------------------------------------------------------------------------
.text$x:000024BF                 align 10h
.text$x:000024BF _text$x         ends
.text$x:000024BF
.text$mn:000024C0 ; ===========================================================================
.text$mn:000024C0
.text$mn:000024C0 ; Segment type: Pure code
.text$mn:000024C0 ; Segment permissions: Read/Execute
.text$mn:000024C0 _text$mn        segment para public 'CODE' use32
.text$mn:000024C0                 assume cs:_text$mn
.text$mn:000024C0                 ;org 24C0h
.text$mn:000024C0 ; COMDAT (pick any)
.text$mn:000024C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024C0
.text$mn:000024C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024C0
.text$mn:000024C0 ; Attributes: bp-based frame
.text$mn:000024C0
.text$mn:000024C0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:000024C0                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000024C0 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:000024C0                                         ; CODE XREF: VerticalFileSwitcherListView::getFullFilePath(uint)+5Ep
.text$mn:000024C0                                         ; VerticalFileSwitcherListView::add(int,int)+A2p
.text$mn:000024C0
.text$mn:000024C0 var_14          = dword ptr -14h
.text$mn:000024C0 var_D           = byte ptr -0Dh
.text$mn:000024C0 var_C           = dword ptr -0Ch
.text$mn:000024C0 var_4           = dword ptr -4
.text$mn:000024C0 Str             = dword ptr  8
.text$mn:000024C0
.text$mn:000024C0                 push    ebp
.text$mn:000024C1                 mov     ebp, esp
.text$mn:000024C3                 push    0FFFFFFFFh
.text$mn:000024C5                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000024CA                 mov     eax, large fs:0
.text$mn:000024D0                 push    eax
.text$mn:000024D1                 sub     esp, 8
.text$mn:000024D4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000024D9                 xor     eax, ebp
.text$mn:000024DB                 push    eax
.text$mn:000024DC                 lea     eax, [ebp+var_C]
.text$mn:000024DF                 mov     large fs:0, eax
.text$mn:000024E5                 mov     [ebp+var_14], ecx
.text$mn:000024E8                 lea     ecx, [ebp+var_D]
.text$mn:000024EB                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000024F0                 push    eax
.text$mn:000024F1                 mov     ecx, [ebp+var_14]
.text$mn:000024F4                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000024F9                 mov     [ebp+var_4], 0
.text$mn:00002500                 push    0
.text$mn:00002502                 push    0
.text$mn:00002504                 mov     ecx, [ebp+var_14]
.text$mn:00002507                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000250C                 mov     eax, [ebp+Str]
.text$mn:0000250F                 push    eax             ; Str
.text$mn:00002510                 mov     ecx, [ebp+var_14]
.text$mn:00002513                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00002518                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000251F                 mov     eax, [ebp+var_14]
.text$mn:00002522                 mov     ecx, [ebp+var_C]
.text$mn:00002525                 mov     large fs:0, ecx
.text$mn:0000252C                 pop     ecx
.text$mn:0000252D                 mov     esp, ebp
.text$mn:0000252F                 pop     ebp
.text$mn:00002530                 retn    4
.text$mn:00002530 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00002530
.text$mn:00002530 ; ---------------------------------------------------------------------------
.text$mn:00002533                 align 4
.text$mn:00002533 _text$mn        ends
.text$mn:00002533
.text$x:00002534 ; ===========================================================================
.text$x:00002534
.text$x:00002534 ; Segment type: Pure code
.text$x:00002534 ; Segment permissions: Read/Execute
.text$x:00002534 _text$x         segment para public 'CODE' use32
.text$x:00002534                 assume cs:_text$x
.text$x:00002534                 ;org 2534h
.text$x:00002534 ; COMDAT (pick associative to section at 24C0)
.text$x:00002534                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002534
.text$x:00002534 ; =============== S U B R O U T I N E =======================================
.text$x:00002534
.text$x:00002534
.text$x:00002534 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00002534                                         ; DATA XREF: .xdata$x:00005D68o
.text$x:00002534                 mov     ecx, [ebp-14h]
.text$x:00002537                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00002537 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00002537
.text$x:0000253C
.text$x:0000253C ; =============== S U B R O U T I N E =======================================
.text$x:0000253C
.text$x:0000253C
.text$x:0000253C __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:0000253C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:0000253C
.text$x:0000253C arg_4           = dword ptr  8
.text$x:0000253C
.text$x:0000253C                 mov     edx, [esp+arg_4]
.text$x:00002540                 lea     eax, [edx+0Ch]
.text$x:00002543                 mov     ecx, [edx-0Ch]
.text$x:00002546                 xor     ecx, eax
.text$x:00002548                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000254D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00002552                 jmp     ___CxxFrameHandler3
.text$x:00002552 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00002552
.text$x:00002552 ; ---------------------------------------------------------------------------
.text$x:00002557                 align 4
.text$x:00002557 _text$x         ends
.text$x:00002557
.text$mn:00002558 ; ===========================================================================
.text$mn:00002558
.text$mn:00002558 ; Segment type: Pure code
.text$mn:00002558 ; Segment permissions: Read/Execute
.text$mn:00002558 _text$mn        segment para public 'CODE' use32
.text$mn:00002558                 assume cs:_text$mn
.text$mn:00002558                 ;org 2558h
.text$mn:00002558 ; COMDAT (pick any)
.text$mn:00002558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002558
.text$mn:00002558 ; =============== S U B R O U T I N E =======================================
.text$mn:00002558
.text$mn:00002558 ; Attributes: bp-based frame
.text$mn:00002558
.text$mn:00002558 ; public: __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>(class std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>> &&)
.text$mn:00002558                 public ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z
.text$mn:00002558 ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z proc near
.text$mn:00002558                                         ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+135p
.text$mn:00002558
.text$mn:00002558 var_14          = dword ptr -14h
.text$mn:00002558 var_E           = byte ptr -0Eh
.text$mn:00002558 var_D           = byte ptr -0Dh
.text$mn:00002558 var_C           = dword ptr -0Ch
.text$mn:00002558 var_4           = dword ptr -4
.text$mn:00002558 arg_0           = dword ptr  8
.text$mn:00002558
.text$mn:00002558                 push    ebp
.text$mn:00002559                 mov     ebp, esp
.text$mn:0000255B                 push    0FFFFFFFFh
.text$mn:0000255D                 push    offset __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z
.text$mn:00002562                 mov     eax, large fs:0
.text$mn:00002568                 push    eax
.text$mn:00002569                 sub     esp, 8
.text$mn:0000256C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002571                 xor     eax, ebp
.text$mn:00002573                 push    eax
.text$mn:00002574                 lea     eax, [ebp+var_C]
.text$mn:00002577                 mov     large fs:0, eax
.text$mn:0000257D                 mov     [ebp+var_14], ecx
.text$mn:00002580                 lea     eax, [ebp+var_E]
.text$mn:00002583                 push    eax
.text$mn:00002584                 mov     ecx, [ebp+arg_0]
.text$mn:00002587                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:0000258C                 push    eax
.text$mn:0000258D                 mov     ecx, [ebp+var_14]
.text$mn:00002590                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(std::allocator<SwitcherFileInfo> const &)
.text$mn:00002595                 mov     [ebp+var_4], 0
.text$mn:0000259C                 xor     ecx, ecx
.text$mn:0000259E                 mov     [ebp+var_D], cl
.text$mn:000025A1                 movzx   edx, [ebp+var_D]
.text$mn:000025A5                 push    edx             ; int
.text$mn:000025A6                 mov     eax, [ebp+arg_0]
.text$mn:000025A9                 push    eax
.text$mn:000025AA                 call    ??$forward@V?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YA$$QAV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@0@AAV10@@Z ; std::forward<std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &)
.text$mn:000025AF                 add     esp, 4
.text$mn:000025B2                 push    eax             ; struct std::_Container_base12 *
.text$mn:000025B3                 mov     ecx, [ebp+var_14]
.text$mn:000025B6                 call    ?_Assign_rv@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Assign_rv(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&,std::integral_constant<bool,1>)
.text$mn:000025BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000025C2                 mov     eax, [ebp+var_14]
.text$mn:000025C5                 mov     ecx, [ebp+var_C]
.text$mn:000025C8                 mov     large fs:0, ecx
.text$mn:000025CF                 pop     ecx
.text$mn:000025D0                 mov     esp, ebp
.text$mn:000025D2                 pop     ebp
.text$mn:000025D3                 retn    4
.text$mn:000025D3 ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z endp
.text$mn:000025D3
.text$mn:000025D3 ; ---------------------------------------------------------------------------
.text$mn:000025D6                 align 4
.text$mn:000025D6 _text$mn        ends
.text$mn:000025D6
.text$x:000025D8 ; ===========================================================================
.text$x:000025D8
.text$x:000025D8 ; Segment type: Pure code
.text$x:000025D8 ; Segment permissions: Read/Execute
.text$x:000025D8 _text$x         segment para public 'CODE' use32
.text$x:000025D8                 assume cs:_text$x
.text$x:000025D8                 ;org 25D8h
.text$x:000025D8 ; COMDAT (pick associative to section at 2558)
.text$x:000025D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000025D8
.text$x:000025D8 ; =============== S U B R O U T I N E =======================================
.text$x:000025D8
.text$x:000025D8
.text$x:000025D8 __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:000025D8                                         ; DATA XREF: .xdata$x:000061D0o
.text$x:000025D8                 mov     ecx, [ebp-14h]
.text$x:000025DB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(void)
.text$x:000025DB __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:000025DB
.text$x:000025E0
.text$x:000025E0 ; =============== S U B R O U T I N E =======================================
.text$x:000025E0
.text$x:000025E0
.text$x:000025E0 __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z proc near
.text$x:000025E0                                         ; DATA XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&)+5o
.text$x:000025E0
.text$x:000025E0 arg_4           = dword ptr  8
.text$x:000025E0
.text$x:000025E0                 mov     edx, [esp+arg_4]
.text$x:000025E4                 lea     eax, [edx+0Ch]
.text$x:000025E7                 mov     ecx, [edx-0Ch]
.text$x:000025EA                 xor     ecx, eax
.text$x:000025EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025F1                 mov     eax, offset __ehfuncinfo$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z
.text$x:000025F6                 jmp     ___CxxFrameHandler3
.text$x:000025F6 __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z endp
.text$x:000025F6
.text$x:000025F6 ; ---------------------------------------------------------------------------
.text$x:000025FB                 align 4
.text$x:000025FB _text$x         ends
.text$x:000025FB
.text$mn:000025FC ; ===========================================================================
.text$mn:000025FC
.text$mn:000025FC ; Segment type: Pure code
.text$mn:000025FC ; Segment permissions: Read/Execute
.text$mn:000025FC _text$mn        segment para public 'CODE' use32
.text$mn:000025FC                 assume cs:_text$mn
.text$mn:000025FC                 ;org 25FCh
.text$mn:000025FC ; COMDAT (pick any)
.text$mn:000025FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025FC
.text$mn:000025FC ; =============== S U B R O U T I N E =======================================
.text$mn:000025FC
.text$mn:000025FC ; Attributes: bp-based frame
.text$mn:000025FC
.text$mn:000025FC ; public: __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>(void)
.text$mn:000025FC                 public ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:000025FC ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:000025FC                                         ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+32p
.text$mn:000025FC
.text$mn:000025FC var_14          = dword ptr -14h
.text$mn:000025FC var_D           = byte ptr -0Dh
.text$mn:000025FC var_C           = dword ptr -0Ch
.text$mn:000025FC var_4           = dword ptr -4
.text$mn:000025FC
.text$mn:000025FC                 push    ebp
.text$mn:000025FD                 mov     ebp, esp
.text$mn:000025FF                 push    0FFFFFFFFh
.text$mn:00002601                 push    offset __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00002606                 mov     eax, large fs:0
.text$mn:0000260C                 push    eax
.text$mn:0000260D                 sub     esp, 8
.text$mn:00002610                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002615                 xor     eax, ebp
.text$mn:00002617                 push    eax
.text$mn:00002618                 lea     eax, [ebp+var_C]
.text$mn:0000261B                 mov     large fs:0, eax
.text$mn:00002621                 mov     [ebp+var_14], ecx
.text$mn:00002624                 lea     ecx, [ebp+var_D]
.text$mn:00002627                 call    ??0?$allocator@USwitcherFileInfo@@@std@@QAE@XZ ; std::allocator<SwitcherFileInfo>::allocator<SwitcherFileInfo>(void)
.text$mn:0000262C                 push    eax
.text$mn:0000262D                 mov     ecx, [ebp+var_14]
.text$mn:00002630                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(std::allocator<SwitcherFileInfo> const &)
.text$mn:00002635                 mov     [ebp+var_4], 0
.text$mn:0000263C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002643                 mov     eax, [ebp+var_14]
.text$mn:00002646                 mov     ecx, [ebp+var_C]
.text$mn:00002649                 mov     large fs:0, ecx
.text$mn:00002650                 pop     ecx
.text$mn:00002651                 mov     esp, ebp
.text$mn:00002653                 pop     ebp
.text$mn:00002654                 retn
.text$mn:00002654 ??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:00002654
.text$mn:00002654 ; ---------------------------------------------------------------------------
.text$mn:00002655                 align 4
.text$mn:00002655 _text$mn        ends
.text$mn:00002655
.text$x:00002658 ; ===========================================================================
.text$x:00002658
.text$x:00002658 ; Segment type: Pure code
.text$x:00002658 ; Segment permissions: Read/Execute
.text$x:00002658 _text$x         segment para public 'CODE' use32
.text$x:00002658                 assume cs:_text$x
.text$x:00002658                 ;org 2658h
.text$x:00002658 ; COMDAT (pick associative to section at 25FC)
.text$x:00002658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002658
.text$x:00002658 ; =============== S U B R O U T I N E =======================================
.text$x:00002658
.text$x:00002658
.text$x:00002658 __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002658                                         ; DATA XREF: .xdata$x:000061A4o
.text$x:00002658                 mov     ecx, [ebp-14h]
.text$x:0000265B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(void)
.text$x:0000265B __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000265B
.text$x:00002660
.text$x:00002660 ; =============== S U B R O U T I N E =======================================
.text$x:00002660
.text$x:00002660
.text$x:00002660 __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:00002660                                         ; DATA XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)+5o
.text$x:00002660
.text$x:00002660 arg_4           = dword ptr  8
.text$x:00002660
.text$x:00002660                 mov     edx, [esp+arg_4]
.text$x:00002664                 lea     eax, [edx+0Ch]
.text$x:00002667                 mov     ecx, [edx-0Ch]
.text$x:0000266A                 xor     ecx, eax
.text$x:0000266C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002671                 mov     eax, offset __ehfuncinfo$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$x:00002676                 jmp     ___CxxFrameHandler3
.text$x:00002676 __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:00002676
.text$x:00002676 ; ---------------------------------------------------------------------------
.text$x:0000267B                 align 4
.text$x:0000267B _text$x         ends
.text$x:0000267B
.text$mn:0000267C ; ===========================================================================
.text$mn:0000267C
.text$mn:0000267C ; Segment type: Pure code
.text$mn:0000267C ; Segment permissions: Read/Execute
.text$mn:0000267C _text$mn        segment para public 'CODE' use32
.text$mn:0000267C                 assume cs:_text$mn
.text$mn:0000267C                 ;org 267Ch
.text$mn:0000267C ; COMDAT (pick any)
.text$mn:0000267C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000267C
.text$mn:0000267C ; =============== S U B R O U T I N E =======================================
.text$mn:0000267C
.text$mn:0000267C ; Attributes: bp-based frame
.text$mn:0000267C
.text$mn:0000267C ; public: __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>(void)
.text$mn:0000267C                 public ??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:0000267C ??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$mn:0000267C                                         ; CODE XREF: TaskListInfo::TaskListInfo(void)+29p
.text$mn:0000267C
.text$mn:0000267C var_14          = dword ptr -14h
.text$mn:0000267C var_D           = byte ptr -0Dh
.text$mn:0000267C var_C           = dword ptr -0Ch
.text$mn:0000267C var_4           = dword ptr -4
.text$mn:0000267C
.text$mn:0000267C                 push    ebp
.text$mn:0000267D                 mov     ebp, esp
.text$mn:0000267F                 push    0FFFFFFFFh
.text$mn:00002681                 push    offset __ehhandler$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:00002686                 mov     eax, large fs:0
.text$mn:0000268C                 push    eax
.text$mn:0000268D                 sub     esp, 8
.text$mn:00002690                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002695                 xor     eax, ebp
.text$mn:00002697                 push    eax
.text$mn:00002698                 lea     eax, [ebp+var_C]
.text$mn:0000269B                 mov     large fs:0, eax
.text$mn:000026A1                 mov     [ebp+var_14], ecx
.text$mn:000026A4                 lea     ecx, [ebp+var_D]
.text$mn:000026A7                 call    ??0?$allocator@UTaskLstFnStatus@@@std@@QAE@XZ ; std::allocator<TaskLstFnStatus>::allocator<TaskLstFnStatus>(void)
.text$mn:000026AC                 push    eax
.text$mn:000026AD                 mov     ecx, [ebp+var_14]
.text$mn:000026B0                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(std::allocator<TaskLstFnStatus> const &)
.text$mn:000026B5                 mov     [ebp+var_4], 0
.text$mn:000026BC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000026C3                 mov     eax, [ebp+var_14]
.text$mn:000026C6                 mov     ecx, [ebp+var_C]
.text$mn:000026C9                 mov     large fs:0, ecx
.text$mn:000026D0                 pop     ecx
.text$mn:000026D1                 mov     esp, ebp
.text$mn:000026D3                 pop     ebp
.text$mn:000026D4                 retn
.text$mn:000026D4 ??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$mn:000026D4
.text$mn:000026D4 ; ---------------------------------------------------------------------------
.text$mn:000026D5                 align 4
.text$mn:000026D5 _text$mn        ends
.text$mn:000026D5
.text$x:000026D8 ; ===========================================================================
.text$x:000026D8
.text$x:000026D8 ; Segment type: Pure code
.text$x:000026D8 ; Segment permissions: Read/Execute
.text$x:000026D8 _text$x         segment para public 'CODE' use32
.text$x:000026D8                 assume cs:_text$x
.text$x:000026D8                 ;org 26D8h
.text$x:000026D8 ; COMDAT (pick associative to section at 267C)
.text$x:000026D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026D8
.text$x:000026D8 ; =============== S U B R O U T I N E =======================================
.text$x:000026D8
.text$x:000026D8
.text$x:000026D8 __unwindfunclet$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000026D8                                         ; DATA XREF: .xdata$x:00005F5Co
.text$x:000026D8                 mov     ecx, [ebp-14h]
.text$x:000026DB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::~_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(void)
.text$x:000026DB __unwindfunclet$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 endp
.text$x:000026DB
.text$x:000026E0
.text$x:000026E0 ; =============== S U B R O U T I N E =======================================
.text$x:000026E0
.text$x:000026E0
.text$x:000026E0 __ehhandler$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$x:000026E0                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)+5o
.text$x:000026E0
.text$x:000026E0 arg_4           = dword ptr  8
.text$x:000026E0
.text$x:000026E0                 mov     edx, [esp+arg_4]
.text$x:000026E4                 lea     eax, [edx+0Ch]
.text$x:000026E7                 mov     ecx, [edx-0Ch]
.text$x:000026EA                 xor     ecx, eax
.text$x:000026EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000026F1                 mov     eax, offset __ehfuncinfo$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$x:000026F6                 jmp     ___CxxFrameHandler3
.text$x:000026F6 __ehhandler$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$x:000026F6
.text$x:000026F6 ; ---------------------------------------------------------------------------
.text$x:000026FB                 align 4
.text$x:000026FB _text$x         ends
.text$x:000026FB
.text$mn:000026FC ; ===========================================================================
.text$mn:000026FC
.text$mn:000026FC ; Segment type: Pure code
.text$mn:000026FC ; Segment permissions: Read/Execute
.text$mn:000026FC _text$mn        segment para public 'CODE' use32
.text$mn:000026FC                 assume cs:_text$mn
.text$mn:000026FC                 ;org 26FCh
.text$mn:000026FC ; COMDAT (pick any)
.text$mn:000026FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026FC
.text$mn:000026FC ; =============== S U B R O U T I N E =======================================
.text$mn:000026FC
.text$mn:000026FC ; Attributes: bp-based frame
.text$mn:000026FC
.text$mn:000026FC ; _DWORD __thiscall SwitcherFileInfo::SwitcherFileInfo(SwitcherFileInfo *this, int, int)
.text$mn:000026FC                 public ??0SwitcherFileInfo@@QAE@HH@Z
.text$mn:000026FC ??0SwitcherFileInfo@@QAE@HH@Z proc near ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+11Bp
.text$mn:000026FC
.text$mn:000026FC var_4           = dword ptr -4
.text$mn:000026FC arg_0           = dword ptr  8
.text$mn:000026FC arg_4           = dword ptr  0Ch
.text$mn:000026FC
.text$mn:000026FC                 push    ebp
.text$mn:000026FD                 mov     ebp, esp
.text$mn:000026FF                 push    ecx
.text$mn:00002700                 mov     [ebp+var_4], ecx
.text$mn:00002703                 mov     eax, [ebp+var_4]
.text$mn:00002706                 mov     ecx, [ebp+arg_0]
.text$mn:00002709                 mov     [eax], ecx
.text$mn:0000270B                 mov     edx, [ebp+var_4]
.text$mn:0000270E                 mov     eax, [ebp+arg_4]
.text$mn:00002711                 mov     [edx+4], eax
.text$mn:00002714                 mov     eax, [ebp+var_4]
.text$mn:00002717                 mov     esp, ebp
.text$mn:00002719                 pop     ebp
.text$mn:0000271A                 retn    8
.text$mn:0000271A ??0SwitcherFileInfo@@QAE@HH@Z endp
.text$mn:0000271A
.text$mn:0000271A ; ---------------------------------------------------------------------------
.text$mn:0000271D                 align 10h
.text$mn:0000271D _text$mn        ends
.text$mn:0000271D
.text$mn:00002720 ; ===========================================================================
.text$mn:00002720
.text$mn:00002720 ; Segment type: Pure code
.text$mn:00002720 ; Segment permissions: Read/Execute
.text$mn:00002720 _text$mn        segment para public 'CODE' use32
.text$mn:00002720                 assume cs:_text$mn
.text$mn:00002720                 ;org 2720h
.text$mn:00002720 ; COMDAT (pick any)
.text$mn:00002720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002720
.text$mn:00002720 ; =============== S U B R O U T I N E =======================================
.text$mn:00002720
.text$mn:00002720 ; Attributes: bp-based frame
.text$mn:00002720
.text$mn:00002720 ; _DWORD __thiscall TaskListInfo::TaskListInfo(TaskListInfo *__hidden this)
.text$mn:00002720                 public ??0TaskListInfo@@QAE@XZ
.text$mn:00002720 ??0TaskListInfo@@QAE@XZ proc near       ; CODE XREF: VerticalFileSwitcherListView::initList(void)+37p
.text$mn:00002720
.text$mn:00002720 var_10          = dword ptr -10h
.text$mn:00002720 var_C           = dword ptr -0Ch
.text$mn:00002720 var_4           = dword ptr -4
.text$mn:00002720
.text$mn:00002720                 push    ebp
.text$mn:00002721                 mov     ebp, esp
.text$mn:00002723                 push    0FFFFFFFFh
.text$mn:00002725                 push    offset __ehhandler$??0TaskListInfo@@QAE@XZ
.text$mn:0000272A                 mov     eax, large fs:0
.text$mn:00002730                 push    eax
.text$mn:00002731                 push    ecx
.text$mn:00002732                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002737                 xor     eax, ebp
.text$mn:00002739                 push    eax
.text$mn:0000273A                 lea     eax, [ebp+var_C]
.text$mn:0000273D                 mov     large fs:0, eax
.text$mn:00002743                 mov     [ebp+var_10], ecx
.text$mn:00002746                 mov     ecx, [ebp+var_10]
.text$mn:00002749                 call    ??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)
.text$mn:0000274E                 mov     [ebp+var_4], 0
.text$mn:00002755                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000275C                 mov     eax, [ebp+var_10]
.text$mn:0000275F                 mov     ecx, [ebp+var_C]
.text$mn:00002762                 mov     large fs:0, ecx
.text$mn:00002769                 pop     ecx
.text$mn:0000276A                 mov     esp, ebp
.text$mn:0000276C                 pop     ebp
.text$mn:0000276D                 retn
.text$mn:0000276D ??0TaskListInfo@@QAE@XZ endp
.text$mn:0000276D
.text$mn:0000276D ; ---------------------------------------------------------------------------
.text$mn:0000276E                 align 10h
.text$mn:0000276E _text$mn        ends
.text$mn:0000276E
.text$x:00002770 ; ===========================================================================
.text$x:00002770
.text$x:00002770 ; Segment type: Pure code
.text$x:00002770 ; Segment permissions: Read/Execute
.text$x:00002770 _text$x         segment para public 'CODE' use32
.text$x:00002770                 assume cs:_text$x
.text$x:00002770                 ;org 2770h
.text$x:00002770 ; COMDAT (pick associative to section at 2720)
.text$x:00002770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002770
.text$x:00002770 ; =============== S U B R O U T I N E =======================================
.text$x:00002770
.text$x:00002770
.text$x:00002770 __unwindfunclet$??0TaskListInfo@@QAE@XZ$0 proc near
.text$x:00002770                                         ; DATA XREF: .xdata$x:00005FB4o
.text$x:00002770                 mov     ecx, [ebp-10h]
.text$x:00002773                 jmp     ??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::~vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)
.text$x:00002773 __unwindfunclet$??0TaskListInfo@@QAE@XZ$0 endp
.text$x:00002773
.text$x:00002778
.text$x:00002778 ; =============== S U B R O U T I N E =======================================
.text$x:00002778
.text$x:00002778
.text$x:00002778 __ehhandler$??0TaskListInfo@@QAE@XZ proc near
.text$x:00002778                                         ; DATA XREF: TaskListInfo::TaskListInfo(void)+5o
.text$x:00002778
.text$x:00002778 arg_4           = dword ptr  8
.text$x:00002778
.text$x:00002778                 mov     edx, [esp+arg_4]
.text$x:0000277C                 lea     eax, [edx+0Ch]
.text$x:0000277F                 mov     ecx, [edx-8]
.text$x:00002782                 xor     ecx, eax
.text$x:00002784                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002789                 mov     eax, offset __ehfuncinfo$??0TaskListInfo@@QAE@XZ
.text$x:0000278E                 jmp     ___CxxFrameHandler3
.text$x:0000278E __ehhandler$??0TaskListInfo@@QAE@XZ endp
.text$x:0000278E
.text$x:0000278E ; ---------------------------------------------------------------------------
.text$x:00002793                 align 4
.text$x:00002793 _text$x         ends
.text$x:00002793
.text$mn:00002794 ; ===========================================================================
.text$mn:00002794
.text$mn:00002794 ; Segment type: Pure code
.text$mn:00002794 ; Segment permissions: Read/Execute
.text$mn:00002794 _text$mn        segment para public 'CODE' use32
.text$mn:00002794                 assume cs:_text$mn
.text$mn:00002794                 ;org 2794h
.text$mn:00002794 ; COMDAT (pick any)
.text$mn:00002794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002794
.text$mn:00002794 ; =============== S U B R O U T I N E =======================================
.text$mn:00002794
.text$mn:00002794 ; Attributes: bp-based frame
.text$mn:00002794
.text$mn:00002794 ; public: __thiscall TaskLstFnStatus::TaskLstFnStatus(int, int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, int, void *)
.text$mn:00002794                 public ??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z
.text$mn:00002794 ??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z proc near
.text$mn:00002794                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+2ACp
.text$mn:00002794                                         ; VerticalFileSwitcherListView::add(int,int)+CDp
.text$mn:00002794
.text$mn:00002794 var_10          = dword ptr -10h
.text$mn:00002794 var_C           = dword ptr -0Ch
.text$mn:00002794 var_4           = dword ptr -4
.text$mn:00002794 arg_0           = dword ptr  8
.text$mn:00002794 arg_4           = dword ptr  0Ch
.text$mn:00002794 arg_8           = byte ptr  10h
.text$mn:00002794 arg_24          = dword ptr  2Ch
.text$mn:00002794 arg_28          = dword ptr  30h
.text$mn:00002794
.text$mn:00002794                 push    ebp
.text$mn:00002795                 mov     ebp, esp
.text$mn:00002797                 push    0FFFFFFFFh
.text$mn:00002799                 push    offset __ehhandler$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z
.text$mn:0000279E                 mov     eax, large fs:0
.text$mn:000027A4                 push    eax
.text$mn:000027A5                 push    ecx
.text$mn:000027A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000027AB                 xor     eax, ebp
.text$mn:000027AD                 push    eax
.text$mn:000027AE                 lea     eax, [ebp+var_C]
.text$mn:000027B1                 mov     large fs:0, eax
.text$mn:000027B7                 mov     [ebp+var_10], ecx
.text$mn:000027BA                 mov     [ebp+var_4], 0
.text$mn:000027C1                 mov     eax, [ebp+var_10]
.text$mn:000027C4                 mov     ecx, [ebp+arg_0]
.text$mn:000027C7                 mov     [eax], ecx
.text$mn:000027C9                 mov     edx, [ebp+var_10]
.text$mn:000027CC                 mov     eax, [ebp+arg_4]
.text$mn:000027CF                 mov     [edx+4], eax
.text$mn:000027D2                 lea     ecx, [ebp+arg_8]
.text$mn:000027D5                 push    ecx
.text$mn:000027D6                 mov     ecx, [ebp+var_10]
.text$mn:000027D9                 add     ecx, 8
.text$mn:000027DC                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000027E1                 mov     byte ptr [ebp+var_4], 1
.text$mn:000027E5                 mov     edx, [ebp+var_10]
.text$mn:000027E8                 mov     eax, [ebp+arg_24]
.text$mn:000027EB                 mov     [edx+24h], eax
.text$mn:000027EE                 mov     ecx, [ebp+var_10]
.text$mn:000027F1                 mov     edx, [ebp+arg_28]
.text$mn:000027F4                 mov     [ecx+28h], edx
.text$mn:000027F7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000027FE                 lea     ecx, [ebp+arg_8]
.text$mn:00002801                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002806                 mov     eax, [ebp+var_10]
.text$mn:00002809                 mov     ecx, [ebp+var_C]
.text$mn:0000280C                 mov     large fs:0, ecx
.text$mn:00002813                 pop     ecx
.text$mn:00002814                 mov     esp, ebp
.text$mn:00002816                 pop     ebp
.text$mn:00002817                 retn    2Ch
.text$mn:00002817 ??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z endp
.text$mn:00002817
.text$mn:00002817 ; ---------------------------------------------------------------------------
.text$mn:0000281A                 align 4
.text$mn:0000281A _text$mn        ends
.text$mn:0000281A
.text$x:0000281C ; ===========================================================================
.text$x:0000281C
.text$x:0000281C ; Segment type: Pure code
.text$x:0000281C ; Segment permissions: Read/Execute
.text$x:0000281C _text$x         segment para public 'CODE' use32
.text$x:0000281C                 assume cs:_text$x
.text$x:0000281C                 ;org 281Ch
.text$x:0000281C ; COMDAT (pick associative to section at 2794)
.text$x:0000281C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000281C
.text$x:0000281C ; =============== S U B R O U T I N E =======================================
.text$x:0000281C
.text$x:0000281C
.text$x:0000281C __unwindfunclet$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z$0 proc near
.text$x:0000281C                                         ; DATA XREF: .xdata$x:00005E4Co
.text$x:0000281C                 lea     ecx, [ebp+10h]
.text$x:0000281F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000281F __unwindfunclet$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z$0 endp
.text$x:0000281F
.text$x:00002824
.text$x:00002824 ; =============== S U B R O U T I N E =======================================
.text$x:00002824
.text$x:00002824
.text$x:00002824 __unwindfunclet$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z$1 proc near
.text$x:00002824                                         ; DATA XREF: .xdata$x:00005E54o
.text$x:00002824                 mov     ecx, [ebp-10h]
.text$x:00002827                 add     ecx, 8
.text$x:0000282A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000282A __unwindfunclet$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z$1 endp
.text$x:0000282A
.text$x:0000282F
.text$x:0000282F ; =============== S U B R O U T I N E =======================================
.text$x:0000282F
.text$x:0000282F
.text$x:0000282F __ehhandler$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z proc near
.text$x:0000282F                                         ; DATA XREF: TaskLstFnStatus::TaskLstFnStatus(int,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,int,void *)+5o
.text$x:0000282F
.text$x:0000282F arg_4           = dword ptr  8
.text$x:0000282F
.text$x:0000282F                 mov     edx, [esp+arg_4]
.text$x:00002833                 lea     eax, [edx+0Ch]
.text$x:00002836                 mov     ecx, [edx-8]
.text$x:00002839                 xor     ecx, eax
.text$x:0000283B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002840                 mov     eax, offset __ehfuncinfo$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z
.text$x:00002845                 jmp     ___CxxFrameHandler3
.text$x:00002845 __ehhandler$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z endp
.text$x:00002845
.text$x:00002845 ; ---------------------------------------------------------------------------
.text$x:0000284A                 align 4
.text$x:0000284A _text$x         ends
.text$x:0000284A
.text$mn:0000284C ; ===========================================================================
.text$mn:0000284C
.text$mn:0000284C ; Segment type: Pure code
.text$mn:0000284C ; Segment permissions: Read/Execute
.text$mn:0000284C _text$mn        segment para public 'CODE' use32
.text$mn:0000284C                 assume cs:_text$mn
.text$mn:0000284C                 ;org 284Ch
.text$mn:0000284C ; COMDAT (pick any)
.text$mn:0000284C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000284C
.text$mn:0000284C ; =============== S U B R O U T I N E =======================================
.text$mn:0000284C
.text$mn:0000284C ; Attributes: bp-based frame
.text$mn:0000284C
.text$mn:0000284C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000284C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000284C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000284C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:0000284C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:0000284C
.text$mn:0000284C var_4           = dword ptr -4
.text$mn:0000284C
.text$mn:0000284C                 push    ebp
.text$mn:0000284D                 mov     ebp, esp
.text$mn:0000284F                 push    ecx
.text$mn:00002850                 mov     [ebp+var_4], ecx
.text$mn:00002853                 mov     eax, [ebp+var_4]
.text$mn:00002856                 mov     dword ptr [eax], 0
.text$mn:0000285C                 mov     eax, [ebp+var_4]
.text$mn:0000285F                 mov     esp, ebp
.text$mn:00002861                 pop     ebp
.text$mn:00002862                 retn
.text$mn:00002862 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00002862
.text$mn:00002862 ; ---------------------------------------------------------------------------
.text$mn:00002863                 align 4
.text$mn:00002863 _text$mn        ends
.text$mn:00002863
.text$mn:00002864 ; ===========================================================================
.text$mn:00002864
.text$mn:00002864 ; Segment type: Pure code
.text$mn:00002864 ; Segment permissions: Read/Execute
.text$mn:00002864 _text$mn        segment para public 'CODE' use32
.text$mn:00002864                 assume cs:_text$mn
.text$mn:00002864                 ;org 2864h
.text$mn:00002864 ; COMDAT (pick any)
.text$mn:00002864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002864
.text$mn:00002864 ; =============== S U B R O U T I N E =======================================
.text$mn:00002864
.text$mn:00002864 ; Attributes: bp-based frame
.text$mn:00002864
.text$mn:00002864 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00002864                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00002864 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00002864                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00002864                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:00002864
.text$mn:00002864 var_4           = dword ptr -4
.text$mn:00002864
.text$mn:00002864                 push    ebp
.text$mn:00002865                 mov     ebp, esp
.text$mn:00002867                 push    ecx
.text$mn:00002868                 mov     [ebp+var_4], ecx
.text$mn:0000286B                 mov     eax, [ebp+var_4]
.text$mn:0000286E                 mov     dword ptr [eax], 0
.text$mn:00002874                 mov     ecx, [ebp+var_4]
.text$mn:00002877                 mov     dword ptr [ecx+4], 0
.text$mn:0000287E                 mov     eax, [ebp+var_4]
.text$mn:00002881                 mov     esp, ebp
.text$mn:00002883                 pop     ebp
.text$mn:00002884                 retn
.text$mn:00002884 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00002884
.text$mn:00002884 ; ---------------------------------------------------------------------------
.text$mn:00002885                 align 4
.text$mn:00002885 _text$mn        ends
.text$mn:00002885
.text$mn:00002888 ; ===========================================================================
.text$mn:00002888
.text$mn:00002888 ; Segment type: Pure code
.text$mn:00002888 ; Segment permissions: Read/Execute
.text$mn:00002888 _text$mn        segment para public 'CODE' use32
.text$mn:00002888                 assume cs:_text$mn
.text$mn:00002888                 ;org 2888h
.text$mn:00002888 ; COMDAT (pick any)
.text$mn:00002888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002888
.text$mn:00002888 ; =============== S U B R O U T I N E =======================================
.text$mn:00002888
.text$mn:00002888 ; Attributes: bp-based frame
.text$mn:00002888
.text$mn:00002888 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00002888                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002888 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00002888                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00002888                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00002888
.text$mn:00002888 var_10          = dword ptr -10h
.text$mn:00002888 var_C           = dword ptr -0Ch
.text$mn:00002888 var_4           = dword ptr -4
.text$mn:00002888
.text$mn:00002888                 push    ebp
.text$mn:00002889                 mov     ebp, esp
.text$mn:0000288B                 push    0FFFFFFFFh
.text$mn:0000288D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002892                 mov     eax, large fs:0
.text$mn:00002898                 push    eax
.text$mn:00002899                 push    ecx
.text$mn:0000289A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000289F                 xor     eax, ebp
.text$mn:000028A1                 push    eax
.text$mn:000028A2                 lea     eax, [ebp+var_C]
.text$mn:000028A5                 mov     large fs:0, eax
.text$mn:000028AB                 mov     [ebp+var_10], ecx
.text$mn:000028AE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000028B1                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000028B6                 mov     [ebp+var_4], 0
.text$mn:000028BD                 mov     eax, [ebp+var_10]
.text$mn:000028C0                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000028C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028CD                 mov     eax, [ebp+var_10]
.text$mn:000028D0                 mov     ecx, [ebp+var_C]
.text$mn:000028D3                 mov     large fs:0, ecx
.text$mn:000028DA                 pop     ecx
.text$mn:000028DB                 mov     esp, ebp
.text$mn:000028DD                 pop     ebp
.text$mn:000028DE                 retn
.text$mn:000028DE ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000028DE
.text$mn:000028DE ; ---------------------------------------------------------------------------
.text$mn:000028DF                 align 10h
.text$mn:000028DF _text$mn        ends
.text$mn:000028DF
.text$x:000028E0 ; ===========================================================================
.text$x:000028E0
.text$x:000028E0 ; Segment type: Pure code
.text$x:000028E0 ; Segment permissions: Read/Execute
.text$x:000028E0 _text$x         segment para public 'CODE' use32
.text$x:000028E0                 assume cs:_text$x
.text$x:000028E0                 ;org 28E0h
.text$x:000028E0 ; COMDAT (pick associative to section at 2888)
.text$x:000028E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028E0
.text$x:000028E0 ; =============== S U B R O U T I N E =======================================
.text$x:000028E0
.text$x:000028E0
.text$x:000028E0 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000028E0                                         ; DATA XREF: .xdata$x:00005B00o
.text$x:000028E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000028E3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000028E3 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000028E3
.text$x:000028E8
.text$x:000028E8 ; =============== S U B R O U T I N E =======================================
.text$x:000028E8
.text$x:000028E8
.text$x:000028E8 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000028E8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000028E8
.text$x:000028E8 arg_4           = dword ptr  8
.text$x:000028E8
.text$x:000028E8                 mov     edx, [esp+arg_4]
.text$x:000028EC                 lea     eax, [edx+0Ch]
.text$x:000028EF                 mov     ecx, [edx-8]
.text$x:000028F2                 xor     ecx, eax
.text$x:000028F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028F9                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000028FE                 jmp     ___CxxFrameHandler3
.text$x:000028FE __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000028FE
.text$x:000028FE ; ---------------------------------------------------------------------------
.text$x:00002903                 align 4
.text$x:00002903 _text$x         ends
.text$x:00002903
.text$mn:00002904 ; ===========================================================================
.text$mn:00002904
.text$mn:00002904 ; Segment type: Pure code
.text$mn:00002904 ; Segment permissions: Read/Execute
.text$mn:00002904 _text$mn        segment para public 'CODE' use32
.text$mn:00002904                 assume cs:_text$mn
.text$mn:00002904                 ;org 2904h
.text$mn:00002904 ; COMDAT (pick any)
.text$mn:00002904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002904
.text$mn:00002904 ; =============== S U B R O U T I N E =======================================
.text$mn:00002904
.text$mn:00002904 ; Attributes: bp-based frame
.text$mn:00002904
.text$mn:00002904 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002904                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00002904 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00002904                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002904
.text$mn:00002904 var_10          = dword ptr -10h
.text$mn:00002904 var_C           = dword ptr -0Ch
.text$mn:00002904 var_4           = dword ptr -4
.text$mn:00002904
.text$mn:00002904                 push    ebp
.text$mn:00002905                 mov     ebp, esp
.text$mn:00002907                 push    0FFFFFFFFh
.text$mn:00002909                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000290E                 mov     eax, large fs:0
.text$mn:00002914                 push    eax
.text$mn:00002915                 push    ecx
.text$mn:00002916                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000291B                 xor     eax, ebp
.text$mn:0000291D                 push    eax
.text$mn:0000291E                 lea     eax, [ebp+var_C]
.text$mn:00002921                 mov     large fs:0, eax
.text$mn:00002927                 mov     [ebp+var_10], ecx
.text$mn:0000292A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000292D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00002932                 mov     [ebp+var_4], 0
.text$mn:00002939                 mov     eax, [ebp+var_10]
.text$mn:0000293C                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00002942                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002949                 mov     eax, [ebp+var_10]
.text$mn:0000294C                 mov     ecx, [ebp+var_C]
.text$mn:0000294F                 mov     large fs:0, ecx
.text$mn:00002956                 pop     ecx
.text$mn:00002957                 mov     esp, ebp
.text$mn:00002959                 pop     ebp
.text$mn:0000295A                 retn
.text$mn:0000295A ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000295A
.text$mn:0000295A ; ---------------------------------------------------------------------------
.text$mn:0000295B                 align 4
.text$mn:0000295B _text$mn        ends
.text$mn:0000295B
.text$x:0000295C ; ===========================================================================
.text$x:0000295C
.text$x:0000295C ; Segment type: Pure code
.text$x:0000295C ; Segment permissions: Read/Execute
.text$x:0000295C _text$x         segment para public 'CODE' use32
.text$x:0000295C                 assume cs:_text$x
.text$x:0000295C                 ;org 295Ch
.text$x:0000295C ; COMDAT (pick associative to section at 2904)
.text$x:0000295C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000295C
.text$x:0000295C ; =============== S U B R O U T I N E =======================================
.text$x:0000295C
.text$x:0000295C
.text$x:0000295C __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:0000295C                                         ; DATA XREF: .xdata$x:00005B84o
.text$x:0000295C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000295F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000295F __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000295F
.text$x:00002964
.text$x:00002964 ; =============== S U B R O U T I N E =======================================
.text$x:00002964
.text$x:00002964
.text$x:00002964 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00002964                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00002964
.text$x:00002964 arg_4           = dword ptr  8
.text$x:00002964
.text$x:00002964                 mov     edx, [esp+arg_4]
.text$x:00002968                 lea     eax, [edx+0Ch]
.text$x:0000296B                 mov     ecx, [edx-8]
.text$x:0000296E                 xor     ecx, eax
.text$x:00002970                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002975                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000297A                 jmp     ___CxxFrameHandler3
.text$x:0000297A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000297A
.text$x:0000297A ; ---------------------------------------------------------------------------
.text$x:0000297F                 align 10h
.text$x:0000297F _text$x         ends
.text$x:0000297F
.text$mn:00002980 ; ===========================================================================
.text$mn:00002980
.text$mn:00002980 ; Segment type: Pure code
.text$mn:00002980 ; Segment permissions: Read/Execute
.text$mn:00002980 _text$mn        segment para public 'CODE' use32
.text$mn:00002980                 assume cs:_text$mn
.text$mn:00002980                 ;org 2980h
.text$mn:00002980 ; COMDAT (pick any)
.text$mn:00002980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002980
.text$mn:00002980 ; =============== S U B R O U T I N E =======================================
.text$mn:00002980
.text$mn:00002980 ; Attributes: bp-based frame
.text$mn:00002980
.text$mn:00002980 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002980                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00002980 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00002980                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002980
.text$mn:00002980 var_10          = dword ptr -10h
.text$mn:00002980 var_C           = dword ptr -0Ch
.text$mn:00002980 var_4           = dword ptr -4
.text$mn:00002980
.text$mn:00002980                 push    ebp
.text$mn:00002981                 mov     ebp, esp
.text$mn:00002983                 push    0FFFFFFFFh
.text$mn:00002985                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000298A                 mov     eax, large fs:0
.text$mn:00002990                 push    eax
.text$mn:00002991                 push    ecx
.text$mn:00002992                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002997                 xor     eax, ebp
.text$mn:00002999                 push    eax
.text$mn:0000299A                 lea     eax, [ebp+var_C]
.text$mn:0000299D                 mov     large fs:0, eax
.text$mn:000029A3                 mov     [ebp+var_10], ecx
.text$mn:000029A6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000029A9                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000029AE                 mov     [ebp+var_4], 0
.text$mn:000029B5                 mov     eax, [ebp+var_10]
.text$mn:000029B8                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000029BE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000029C5                 mov     eax, [ebp+var_10]
.text$mn:000029C8                 mov     ecx, [ebp+var_C]
.text$mn:000029CB                 mov     large fs:0, ecx
.text$mn:000029D2                 pop     ecx
.text$mn:000029D3                 mov     esp, ebp
.text$mn:000029D5                 pop     ebp
.text$mn:000029D6                 retn
.text$mn:000029D6 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000029D6
.text$mn:000029D6 ; ---------------------------------------------------------------------------
.text$mn:000029D7                 align 4
.text$mn:000029D7 _text$mn        ends
.text$mn:000029D7
.text$x:000029D8 ; ===========================================================================
.text$x:000029D8
.text$x:000029D8 ; Segment type: Pure code
.text$x:000029D8 ; Segment permissions: Read/Execute
.text$x:000029D8 _text$x         segment para public 'CODE' use32
.text$x:000029D8                 assume cs:_text$x
.text$x:000029D8                 ;org 29D8h
.text$x:000029D8 ; COMDAT (pick associative to section at 2980)
.text$x:000029D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000029D8
.text$x:000029D8 ; =============== S U B R O U T I N E =======================================
.text$x:000029D8
.text$x:000029D8
.text$x:000029D8 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000029D8                                         ; DATA XREF: .xdata$x:00005C08o
.text$x:000029D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000029DB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000029DB __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000029DB
.text$x:000029E0
.text$x:000029E0 ; =============== S U B R O U T I N E =======================================
.text$x:000029E0
.text$x:000029E0
.text$x:000029E0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000029E0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000029E0
.text$x:000029E0 arg_4           = dword ptr  8
.text$x:000029E0
.text$x:000029E0                 mov     edx, [esp+arg_4]
.text$x:000029E4                 lea     eax, [edx+0Ch]
.text$x:000029E7                 mov     ecx, [edx-8]
.text$x:000029EA                 xor     ecx, eax
.text$x:000029EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029F1                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000029F6                 jmp     ___CxxFrameHandler3
.text$x:000029F6 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000029F6
.text$x:000029F6 ; ---------------------------------------------------------------------------
.text$x:000029FB                 align 4
.text$x:000029FB _text$x         ends
.text$x:000029FB
.text$mn:000029FC ; ===========================================================================
.text$mn:000029FC
.text$mn:000029FC ; Segment type: Pure code
.text$mn:000029FC ; Segment permissions: Read/Execute
.text$mn:000029FC _text$mn        segment para public 'CODE' use32
.text$mn:000029FC                 assume cs:_text$mn
.text$mn:000029FC                 ;org 29FCh
.text$mn:000029FC ; COMDAT (pick any)
.text$mn:000029FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029FC
.text$mn:000029FC ; =============== S U B R O U T I N E =======================================
.text$mn:000029FC
.text$mn:000029FC ; Attributes: bp-based frame
.text$mn:000029FC
.text$mn:000029FC ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000029FC                 public ??0error_category@std@@QAE@XZ
.text$mn:000029FC ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000029FC
.text$mn:000029FC var_4           = dword ptr -4
.text$mn:000029FC
.text$mn:000029FC                 push    ebp
.text$mn:000029FD                 mov     ebp, esp
.text$mn:000029FF                 push    ecx
.text$mn:00002A00                 mov     [ebp+var_4], ecx
.text$mn:00002A03                 mov     eax, [ebp+var_4]
.text$mn:00002A06                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00002A0C                 mov     eax, [ebp+var_4]
.text$mn:00002A0F                 mov     esp, ebp
.text$mn:00002A11                 pop     ebp
.text$mn:00002A12                 retn
.text$mn:00002A12 ??0error_category@std@@QAE@XZ endp
.text$mn:00002A12
.text$mn:00002A12 ; ---------------------------------------------------------------------------
.text$mn:00002A13                 align 4
.text$mn:00002A13 _text$mn        ends
.text$mn:00002A13
.text$mn:00002A14 ; ===========================================================================
.text$mn:00002A14
.text$mn:00002A14 ; Segment type: Pure code
.text$mn:00002A14 ; Segment permissions: Read/Execute
.text$mn:00002A14 _text$mn        segment para public 'CODE' use32
.text$mn:00002A14                 assume cs:_text$mn
.text$mn:00002A14                 ;org 2A14h
.text$mn:00002A14 ; COMDAT (pick any)
.text$mn:00002A14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A14
.text$mn:00002A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A14
.text$mn:00002A14 ; Attributes: bp-based frame
.text$mn:00002A14
.text$mn:00002A14 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00002A14                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00002A14 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00002A14                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00002A14                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00002A14
.text$mn:00002A14 var_4           = dword ptr -4
.text$mn:00002A14 arg_0           = dword ptr  8
.text$mn:00002A14 arg_4           = dword ptr  0Ch
.text$mn:00002A14
.text$mn:00002A14                 push    ebp
.text$mn:00002A15                 mov     ebp, esp
.text$mn:00002A17                 push    ecx
.text$mn:00002A18                 mov     [ebp+var_4], ecx
.text$mn:00002A1B                 mov     eax, [ebp+var_4]
.text$mn:00002A1E                 mov     ecx, [ebp+arg_0]
.text$mn:00002A21                 mov     [eax], ecx
.text$mn:00002A23                 mov     edx, [ebp+var_4]
.text$mn:00002A26                 mov     eax, [ebp+arg_4]
.text$mn:00002A29                 mov     [edx+4], eax
.text$mn:00002A2C                 mov     eax, [ebp+var_4]
.text$mn:00002A2F                 mov     esp, ebp
.text$mn:00002A31                 pop     ebp
.text$mn:00002A32                 retn    8
.text$mn:00002A32 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00002A32
.text$mn:00002A32 ; ---------------------------------------------------------------------------
.text$mn:00002A35                 align 4
.text$mn:00002A35 _text$mn        ends
.text$mn:00002A35
.text$mn:00002A38 ; ===========================================================================
.text$mn:00002A38
.text$mn:00002A38 ; Segment type: Pure code
.text$mn:00002A38 ; Segment permissions: Read/Execute
.text$mn:00002A38 _text$mn        segment para public 'CODE' use32
.text$mn:00002A38                 assume cs:_text$mn
.text$mn:00002A38                 ;org 2A38h
.text$mn:00002A38 ; COMDAT (pick any)
.text$mn:00002A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A38
.text$mn:00002A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A38
.text$mn:00002A38 ; Attributes: bp-based frame
.text$mn:00002A38
.text$mn:00002A38 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00002A38                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00002A38 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00002A38                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00002A38
.text$mn:00002A38 var_4           = dword ptr -4
.text$mn:00002A38 arg_0           = dword ptr  8
.text$mn:00002A38
.text$mn:00002A38                 push    ebp
.text$mn:00002A39                 mov     ebp, esp
.text$mn:00002A3B                 push    ecx
.text$mn:00002A3C                 mov     [ebp+var_4], ecx
.text$mn:00002A3F                 mov     eax, [ebp+var_4]
.text$mn:00002A42                 mov     ecx, [ebp+arg_0]
.text$mn:00002A45                 mov     [eax], ecx
.text$mn:00002A47                 mov     eax, [ebp+var_4]
.text$mn:00002A4A                 mov     esp, ebp
.text$mn:00002A4C                 pop     ebp
.text$mn:00002A4D                 retn    4
.text$mn:00002A4D ??0id@locale@std@@QAE@I@Z endp
.text$mn:00002A4D
.text$mn:00002A4D _text$mn        ends
.text$mn:00002A4D
.text$mn:00002A50 ; ===========================================================================
.text$mn:00002A50
.text$mn:00002A50 ; Segment type: Pure code
.text$mn:00002A50 ; Segment permissions: Read/Execute
.text$mn:00002A50 _text$mn        segment para public 'CODE' use32
.text$mn:00002A50                 assume cs:_text$mn
.text$mn:00002A50                 ;org 2A50h
.text$mn:00002A50 ; COMDAT (pick any)
.text$mn:00002A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A50
.text$mn:00002A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A50
.text$mn:00002A50 ; Attributes: bp-based frame
.text$mn:00002A50
.text$mn:00002A50 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00002A50                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00002A50 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00002A50                                         ; DATA XREF: .xdata$x:00006410o
.text$mn:00002A50
.text$mn:00002A50 var_10          = dword ptr -10h
.text$mn:00002A50 var_C           = dword ptr -0Ch
.text$mn:00002A50 var_4           = dword ptr -4
.text$mn:00002A50 arg_0           = dword ptr  8
.text$mn:00002A50
.text$mn:00002A50                 push    ebp
.text$mn:00002A51                 mov     ebp, esp
.text$mn:00002A53                 push    0FFFFFFFFh
.text$mn:00002A55                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00002A5A                 mov     eax, large fs:0
.text$mn:00002A60                 push    eax
.text$mn:00002A61                 push    ecx
.text$mn:00002A62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A67                 xor     eax, ebp
.text$mn:00002A69                 push    eax
.text$mn:00002A6A                 lea     eax, [ebp+var_C]
.text$mn:00002A6D                 mov     large fs:0, eax
.text$mn:00002A73                 mov     [ebp+var_10], ecx
.text$mn:00002A76                 mov     eax, [ebp+arg_0]
.text$mn:00002A79                 push    eax             ; struct std::exception *
.text$mn:00002A7A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002A7D                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00002A82                 mov     [ebp+var_4], 0
.text$mn:00002A89                 mov     ecx, [ebp+var_10]
.text$mn:00002A8C                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00002A92                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A99                 mov     eax, [ebp+var_10]
.text$mn:00002A9C                 mov     ecx, [ebp+var_C]
.text$mn:00002A9F                 mov     large fs:0, ecx
.text$mn:00002AA6                 pop     ecx
.text$mn:00002AA7                 mov     esp, ebp
.text$mn:00002AA9                 pop     ebp
.text$mn:00002AAA                 retn    4
.text$mn:00002AAA ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00002AAA
.text$mn:00002AAA ; ---------------------------------------------------------------------------
.text$mn:00002AAD                 align 10h
.text$mn:00002AAD _text$mn        ends
.text$mn:00002AAD
.text$x:00002AB0 ; ===========================================================================
.text$x:00002AB0
.text$x:00002AB0 ; Segment type: Pure code
.text$x:00002AB0 ; Segment permissions: Read/Execute
.text$x:00002AB0 _text$x         segment para public 'CODE' use32
.text$x:00002AB0                 assume cs:_text$x
.text$x:00002AB0                 ;org 2AB0h
.text$x:00002AB0 ; COMDAT (pick associative to section at 2A50)
.text$x:00002AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AB0
.text$x:00002AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00002AB0
.text$x:00002AB0
.text$x:00002AB0 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002AB0                                         ; DATA XREF: .xdata$x:00005AD4o
.text$x:00002AB0                 mov     ecx, [ebp-10h]  ; this
.text$x:00002AB3                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002AB3 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00002AB3
.text$x:00002AB8
.text$x:00002AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00002AB8
.text$x:00002AB8
.text$x:00002AB8 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00002AB8                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00002AB8
.text$x:00002AB8 arg_4           = dword ptr  8
.text$x:00002AB8
.text$x:00002AB8                 mov     edx, [esp+arg_4]
.text$x:00002ABC                 lea     eax, [edx+0Ch]
.text$x:00002ABF                 mov     ecx, [edx-8]
.text$x:00002AC2                 xor     ecx, eax
.text$x:00002AC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AC9                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00002ACE                 jmp     ___CxxFrameHandler3
.text$x:00002ACE __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00002ACE
.text$x:00002ACE ; ---------------------------------------------------------------------------
.text$x:00002AD3                 align 4
.text$x:00002AD3 _text$x         ends
.text$x:00002AD3
.text$mn:00002AD4 ; ===========================================================================
.text$mn:00002AD4
.text$mn:00002AD4 ; Segment type: Pure code
.text$mn:00002AD4 ; Segment permissions: Read/Execute
.text$mn:00002AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AD4                 assume cs:_text$mn
.text$mn:00002AD4                 ;org 2AD4h
.text$mn:00002AD4 ; COMDAT (pick any)
.text$mn:00002AD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AD4
.text$mn:00002AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AD4
.text$mn:00002AD4 ; Attributes: bp-based frame
.text$mn:00002AD4
.text$mn:00002AD4 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00002AD4                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00002AD4 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00002AD4                                         ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+8Bp
.text$mn:00002AD4
.text$mn:00002AD4 var_10          = dword ptr -10h
.text$mn:00002AD4 var_C           = dword ptr -0Ch
.text$mn:00002AD4 var_4           = dword ptr -4
.text$mn:00002AD4 arg_0           = dword ptr  8
.text$mn:00002AD4
.text$mn:00002AD4                 push    ebp
.text$mn:00002AD5                 mov     ebp, esp
.text$mn:00002AD7                 push    0FFFFFFFFh
.text$mn:00002AD9                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00002ADE                 mov     eax, large fs:0
.text$mn:00002AE4                 push    eax
.text$mn:00002AE5                 push    ecx
.text$mn:00002AE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002AEB                 xor     eax, ebp
.text$mn:00002AED                 push    eax
.text$mn:00002AEE                 lea     eax, [ebp+var_C]
.text$mn:00002AF1                 mov     large fs:0, eax
.text$mn:00002AF7                 mov     [ebp+var_10], ecx
.text$mn:00002AFA                 lea     eax, [ebp+arg_0]
.text$mn:00002AFD                 push    eax             ; char **
.text$mn:00002AFE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002B01                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00002B06                 mov     [ebp+var_4], 0
.text$mn:00002B0D                 mov     ecx, [ebp+var_10]
.text$mn:00002B10                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00002B16                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B1D                 mov     eax, [ebp+var_10]
.text$mn:00002B20                 mov     ecx, [ebp+var_C]
.text$mn:00002B23                 mov     large fs:0, ecx
.text$mn:00002B2A                 pop     ecx
.text$mn:00002B2B                 mov     esp, ebp
.text$mn:00002B2D                 pop     ebp
.text$mn:00002B2E                 retn    4
.text$mn:00002B2E ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00002B2E
.text$mn:00002B2E ; ---------------------------------------------------------------------------
.text$mn:00002B31                 align 4
.text$mn:00002B31 _text$mn        ends
.text$mn:00002B31
.text$x:00002B34 ; ===========================================================================
.text$x:00002B34
.text$x:00002B34 ; Segment type: Pure code
.text$x:00002B34 ; Segment permissions: Read/Execute
.text$x:00002B34 _text$x         segment para public 'CODE' use32
.text$x:00002B34                 assume cs:_text$x
.text$x:00002B34                 ;org 2B34h
.text$x:00002B34 ; COMDAT (pick associative to section at 2AD4)
.text$x:00002B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002B34
.text$x:00002B34 ; =============== S U B R O U T I N E =======================================
.text$x:00002B34
.text$x:00002B34
.text$x:00002B34 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00002B34                                         ; DATA XREF: .xdata$x:00005A7Co
.text$x:00002B34                 mov     ecx, [ebp-10h]  ; this
.text$x:00002B37                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002B37 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00002B37
.text$x:00002B3C
.text$x:00002B3C ; =============== S U B R O U T I N E =======================================
.text$x:00002B3C
.text$x:00002B3C
.text$x:00002B3C __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00002B3C                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00002B3C
.text$x:00002B3C arg_4           = dword ptr  8
.text$x:00002B3C
.text$x:00002B3C                 mov     edx, [esp+arg_4]
.text$x:00002B40                 lea     eax, [edx+0Ch]
.text$x:00002B43                 mov     ecx, [edx-8]
.text$x:00002B46                 xor     ecx, eax
.text$x:00002B48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B4D                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00002B52                 jmp     ___CxxFrameHandler3
.text$x:00002B52 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00002B52
.text$x:00002B52 ; ---------------------------------------------------------------------------
.text$x:00002B57                 align 4
.text$x:00002B57 _text$x         ends
.text$x:00002B57
.text$mn:00002B58 ; ===========================================================================
.text$mn:00002B58
.text$mn:00002B58 ; Segment type: Pure code
.text$mn:00002B58 ; Segment permissions: Read/Execute
.text$mn:00002B58 _text$mn        segment para public 'CODE' use32
.text$mn:00002B58                 assume cs:_text$mn
.text$mn:00002B58                 ;org 2B58h
.text$mn:00002B58 ; COMDAT (pick any)
.text$mn:00002B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B58
.text$mn:00002B58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B58
.text$mn:00002B58 ; Attributes: bp-based frame
.text$mn:00002B58
.text$mn:00002B58 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00002B58                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00002B58 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002B58                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00002B58                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00002B58
.text$mn:00002B58 var_10          = dword ptr -10h
.text$mn:00002B58 var_C           = dword ptr -0Ch
.text$mn:00002B58 var_4           = dword ptr -4
.text$mn:00002B58
.text$mn:00002B58                 push    ebp
.text$mn:00002B59                 mov     ebp, esp
.text$mn:00002B5B                 push    0FFFFFFFFh
.text$mn:00002B5D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00002B62                 mov     eax, large fs:0
.text$mn:00002B68                 push    eax
.text$mn:00002B69                 push    ecx
.text$mn:00002B6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B6F                 xor     eax, ebp
.text$mn:00002B71                 push    eax
.text$mn:00002B72                 lea     eax, [ebp+var_C]
.text$mn:00002B75                 mov     large fs:0, eax
.text$mn:00002B7B                 mov     [ebp+var_10], ecx
.text$mn:00002B7E                 mov     [ebp+var_4], 0
.text$mn:00002B85                 mov     ecx, [ebp+var_10]
.text$mn:00002B88                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00002B8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B94                 mov     ecx, [ebp+var_10]
.text$mn:00002B97                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00002B9C                 mov     ecx, [ebp+var_C]
.text$mn:00002B9F                 mov     large fs:0, ecx
.text$mn:00002BA6                 pop     ecx
.text$mn:00002BA7                 mov     esp, ebp
.text$mn:00002BA9                 pop     ebp
.text$mn:00002BAA                 retn
.text$mn:00002BAA ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002BAA
.text$mn:00002BAA ; ---------------------------------------------------------------------------
.text$mn:00002BAB                 align 4
.text$mn:00002BAB _text$mn        ends
.text$mn:00002BAB
.text$x:00002BAC ; ===========================================================================
.text$x:00002BAC
.text$x:00002BAC ; Segment type: Pure code
.text$x:00002BAC ; Segment permissions: Read/Execute
.text$x:00002BAC _text$x         segment para public 'CODE' use32
.text$x:00002BAC                 assume cs:_text$x
.text$x:00002BAC                 ;org 2BACh
.text$x:00002BAC ; COMDAT (pick associative to section at 2B58)
.text$x:00002BAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BAC
.text$x:00002BAC ; =============== S U B R O U T I N E =======================================
.text$x:00002BAC
.text$x:00002BAC
.text$x:00002BAC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002BAC                                         ; DATA XREF: .xdata$x:0000596Co
.text$x:00002BAC                 mov     ecx, [ebp-10h]
.text$x:00002BAF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002BAF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002BAF
.text$x:00002BB4
.text$x:00002BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BB4
.text$x:00002BB4
.text$x:00002BB4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002BB4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00002BB4
.text$x:00002BB4 arg_4           = dword ptr  8
.text$x:00002BB4
.text$x:00002BB4                 mov     edx, [esp+arg_4]
.text$x:00002BB8                 lea     eax, [edx+0Ch]
.text$x:00002BBB                 mov     ecx, [edx-8]
.text$x:00002BBE                 xor     ecx, eax
.text$x:00002BC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BC5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00002BCA                 jmp     ___CxxFrameHandler3
.text$x:00002BCA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00002BCA
.text$x:00002BCA ; ---------------------------------------------------------------------------
.text$x:00002BCF                 align 10h
.text$x:00002BCF _text$x         ends
.text$x:00002BCF
.text$mn:00002BD0 ; ===========================================================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Segment type: Pure code
.text$mn:00002BD0 ; Segment permissions: Read/Execute
.text$mn:00002BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BD0                 assume cs:_text$mn
.text$mn:00002BD0                 ;org 2BD0h
.text$mn:00002BD0 ; COMDAT (pick any)
.text$mn:00002BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BD0
.text$mn:00002BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Attributes: bp-based frame
.text$mn:00002BD0
.text$mn:00002BD0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00002BD0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00002BD0 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002BD0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00002BD0                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j ...
.text$mn:00002BD0
.text$mn:00002BD0 var_10          = dword ptr -10h
.text$mn:00002BD0 var_C           = dword ptr -0Ch
.text$mn:00002BD0 var_4           = dword ptr -4
.text$mn:00002BD0
.text$mn:00002BD0                 push    ebp
.text$mn:00002BD1                 mov     ebp, esp
.text$mn:00002BD3                 push    0FFFFFFFFh
.text$mn:00002BD5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00002BDA                 mov     eax, large fs:0
.text$mn:00002BE0                 push    eax
.text$mn:00002BE1                 push    ecx
.text$mn:00002BE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BE7                 xor     eax, ebp
.text$mn:00002BE9                 push    eax
.text$mn:00002BEA                 lea     eax, [ebp+var_C]
.text$mn:00002BED                 mov     large fs:0, eax
.text$mn:00002BF3                 mov     [ebp+var_10], ecx
.text$mn:00002BF6                 mov     [ebp+var_4], 0
.text$mn:00002BFD                 mov     ecx, [ebp+var_10]
.text$mn:00002C00                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00002C05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C0C                 mov     ecx, [ebp+var_10]
.text$mn:00002C0F                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00002C14                 mov     ecx, [ebp+var_C]
.text$mn:00002C17                 mov     large fs:0, ecx
.text$mn:00002C1E                 pop     ecx
.text$mn:00002C1F                 mov     esp, ebp
.text$mn:00002C21                 pop     ebp
.text$mn:00002C22                 retn
.text$mn:00002C22 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002C22
.text$mn:00002C22 ; ---------------------------------------------------------------------------
.text$mn:00002C23                 align 4
.text$mn:00002C23 _text$mn        ends
.text$mn:00002C23
.text$x:00002C24 ; ===========================================================================
.text$x:00002C24
.text$x:00002C24 ; Segment type: Pure code
.text$x:00002C24 ; Segment permissions: Read/Execute
.text$x:00002C24 _text$x         segment para public 'CODE' use32
.text$x:00002C24                 assume cs:_text$x
.text$x:00002C24                 ;org 2C24h
.text$x:00002C24 ; COMDAT (pick associative to section at 2BD0)
.text$x:00002C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002C24
.text$x:00002C24 ; =============== S U B R O U T I N E =======================================
.text$x:00002C24
.text$x:00002C24
.text$x:00002C24 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002C24                                         ; DATA XREF: .xdata$x:00005D10o
.text$x:00002C24                 mov     ecx, [ebp-10h]
.text$x:00002C27                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00002C27 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002C27
.text$x:00002C2C
.text$x:00002C2C ; =============== S U B R O U T I N E =======================================
.text$x:00002C2C
.text$x:00002C2C
.text$x:00002C2C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002C2C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00002C2C
.text$x:00002C2C arg_4           = dword ptr  8
.text$x:00002C2C
.text$x:00002C2C                 mov     edx, [esp+arg_4]
.text$x:00002C30                 lea     eax, [edx+0Ch]
.text$x:00002C33                 mov     ecx, [edx-8]
.text$x:00002C36                 xor     ecx, eax
.text$x:00002C38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C3D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00002C42                 jmp     ___CxxFrameHandler3
.text$x:00002C42 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00002C42
.text$x:00002C42 ; ---------------------------------------------------------------------------
.text$x:00002C47                 align 4
.text$x:00002C47 _text$x         ends
.text$x:00002C47
.text$mn:00002C48 ; ===========================================================================
.text$mn:00002C48
.text$mn:00002C48 ; Segment type: Pure code
.text$mn:00002C48 ; Segment permissions: Read/Execute
.text$mn:00002C48 _text$mn        segment para public 'CODE' use32
.text$mn:00002C48                 assume cs:_text$mn
.text$mn:00002C48                 ;org 2C48h
.text$mn:00002C48 ; COMDAT (pick any)
.text$mn:00002C48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C48
.text$mn:00002C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C48
.text$mn:00002C48 ; Attributes: bp-based frame
.text$mn:00002C48
.text$mn:00002C48 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002C48                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002C48 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002C48                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00002C48                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00002C48
.text$mn:00002C48 var_10          = dword ptr -10h
.text$mn:00002C48 var_C           = dword ptr -0Ch
.text$mn:00002C48 var_4           = dword ptr -4
.text$mn:00002C48
.text$mn:00002C48                 push    ebp
.text$mn:00002C49                 mov     ebp, esp
.text$mn:00002C4B                 push    0FFFFFFFFh
.text$mn:00002C4D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002C52                 mov     eax, large fs:0
.text$mn:00002C58                 push    eax
.text$mn:00002C59                 push    ecx
.text$mn:00002C5A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C5F                 xor     eax, ebp
.text$mn:00002C61                 push    eax
.text$mn:00002C62                 lea     eax, [ebp+var_C]
.text$mn:00002C65                 mov     large fs:0, eax
.text$mn:00002C6B                 mov     [ebp+var_10], ecx
.text$mn:00002C6E                 mov     [ebp+var_4], 0
.text$mn:00002C75                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C7C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002C7F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002C84                 mov     ecx, [ebp+var_C]
.text$mn:00002C87                 mov     large fs:0, ecx
.text$mn:00002C8E                 pop     ecx
.text$mn:00002C8F                 mov     esp, ebp
.text$mn:00002C91                 pop     ebp
.text$mn:00002C92                 retn
.text$mn:00002C92 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002C92
.text$mn:00002C92 ; ---------------------------------------------------------------------------
.text$mn:00002C93                 align 4
.text$mn:00002C93 _text$mn        ends
.text$mn:00002C93
.text$x:00002C94 ; ===========================================================================
.text$x:00002C94
.text$x:00002C94 ; Segment type: Pure code
.text$x:00002C94 ; Segment permissions: Read/Execute
.text$x:00002C94 _text$x         segment para public 'CODE' use32
.text$x:00002C94                 assume cs:_text$x
.text$x:00002C94                 ;org 2C94h
.text$x:00002C94 ; COMDAT (pick associative to section at 2C48)
.text$x:00002C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002C94
.text$x:00002C94 ; =============== S U B R O U T I N E =======================================
.text$x:00002C94
.text$x:00002C94
.text$x:00002C94 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002C94                                         ; DATA XREF: .xdata$x:00005914o
.text$x:00002C94                 mov     ecx, [ebp-10h]  ; this
.text$x:00002C97                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002C97 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002C97
.text$x:00002C9C
.text$x:00002C9C ; =============== S U B R O U T I N E =======================================
.text$x:00002C9C
.text$x:00002C9C
.text$x:00002C9C __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002C9C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002C9C
.text$x:00002C9C arg_4           = dword ptr  8
.text$x:00002C9C
.text$x:00002C9C                 mov     edx, [esp+arg_4]
.text$x:00002CA0                 lea     eax, [edx+0Ch]
.text$x:00002CA3                 mov     ecx, [edx-8]
.text$x:00002CA6                 xor     ecx, eax
.text$x:00002CA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CAD                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002CB2                 jmp     ___CxxFrameHandler3
.text$x:00002CB2 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002CB2
.text$x:00002CB2 ; ---------------------------------------------------------------------------
.text$x:00002CB7                 align 4
.text$x:00002CB7 _text$x         ends
.text$x:00002CB7
.text$mn:00002CB8 ; ===========================================================================
.text$mn:00002CB8
.text$mn:00002CB8 ; Segment type: Pure code
.text$mn:00002CB8 ; Segment permissions: Read/Execute
.text$mn:00002CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CB8                 assume cs:_text$mn
.text$mn:00002CB8                 ;org 2CB8h
.text$mn:00002CB8 ; COMDAT (pick any)
.text$mn:00002CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CB8
.text$mn:00002CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB8
.text$mn:00002CB8 ; Attributes: bp-based frame
.text$mn:00002CB8
.text$mn:00002CB8 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00002CB8                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002CB8 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00002CB8                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00002CB8                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00002CB8
.text$mn:00002CB8 var_10          = dword ptr -10h
.text$mn:00002CB8 var_C           = dword ptr -0Ch
.text$mn:00002CB8 var_4           = dword ptr -4
.text$mn:00002CB8
.text$mn:00002CB8                 push    ebp
.text$mn:00002CB9                 mov     ebp, esp
.text$mn:00002CBB                 push    0FFFFFFFFh
.text$mn:00002CBD                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002CC2                 mov     eax, large fs:0
.text$mn:00002CC8                 push    eax
.text$mn:00002CC9                 push    ecx
.text$mn:00002CCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002CCF                 xor     eax, ebp
.text$mn:00002CD1                 push    eax
.text$mn:00002CD2                 lea     eax, [ebp+var_C]
.text$mn:00002CD5                 mov     large fs:0, eax
.text$mn:00002CDB                 mov     [ebp+var_10], ecx
.text$mn:00002CDE                 mov     [ebp+var_4], 0
.text$mn:00002CE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CEC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002CEF                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002CF4                 mov     ecx, [ebp+var_C]
.text$mn:00002CF7                 mov     large fs:0, ecx
.text$mn:00002CFE                 pop     ecx
.text$mn:00002CFF                 mov     esp, ebp
.text$mn:00002D01                 pop     ebp
.text$mn:00002D02                 retn
.text$mn:00002D02 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00002D02
.text$mn:00002D02 ; ---------------------------------------------------------------------------
.text$mn:00002D03                 align 4
.text$mn:00002D03 _text$mn        ends
.text$mn:00002D03
.text$x:00002D04 ; ===========================================================================
.text$x:00002D04
.text$x:00002D04 ; Segment type: Pure code
.text$x:00002D04 ; Segment permissions: Read/Execute
.text$x:00002D04 _text$x         segment para public 'CODE' use32
.text$x:00002D04                 assume cs:_text$x
.text$x:00002D04                 ;org 2D04h
.text$x:00002D04 ; COMDAT (pick associative to section at 2CB8)
.text$x:00002D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D04
.text$x:00002D04 ; =============== S U B R O U T I N E =======================================
.text$x:00002D04
.text$x:00002D04
.text$x:00002D04 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00002D04                                         ; DATA XREF: .xdata$x:00005CB8o
.text$x:00002D04                 mov     ecx, [ebp-10h]  ; this
.text$x:00002D07                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002D07 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00002D07
.text$x:00002D0C
.text$x:00002D0C ; =============== S U B R O U T I N E =======================================
.text$x:00002D0C
.text$x:00002D0C
.text$x:00002D0C __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00002D0C                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00002D0C
.text$x:00002D0C arg_4           = dword ptr  8
.text$x:00002D0C
.text$x:00002D0C                 mov     edx, [esp+arg_4]
.text$x:00002D10                 lea     eax, [edx+0Ch]
.text$x:00002D13                 mov     ecx, [edx-8]
.text$x:00002D16                 xor     ecx, eax
.text$x:00002D18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D1D                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00002D22                 jmp     ___CxxFrameHandler3
.text$x:00002D22 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00002D22
.text$x:00002D22 ; ---------------------------------------------------------------------------
.text$x:00002D27                 align 4
.text$x:00002D27 _text$x         ends
.text$x:00002D27
.text$mn:00002D28 ; ===========================================================================
.text$mn:00002D28
.text$mn:00002D28 ; Segment type: Pure code
.text$mn:00002D28 ; Segment permissions: Read/Execute
.text$mn:00002D28 _text$mn        segment para public 'CODE' use32
.text$mn:00002D28                 assume cs:_text$mn
.text$mn:00002D28                 ;org 2D28h
.text$mn:00002D28 ; COMDAT (pick any)
.text$mn:00002D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D28
.text$mn:00002D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D28
.text$mn:00002D28 ; Attributes: bp-based frame
.text$mn:00002D28
.text$mn:00002D28 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>(void)
.text$mn:00002D28                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002D28 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002D28                                         ; CODE XREF: __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:00002D28                                         ; __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00002D28
.text$mn:00002D28 var_10          = dword ptr -10h
.text$mn:00002D28 var_C           = dword ptr -0Ch
.text$mn:00002D28 var_4           = dword ptr -4
.text$mn:00002D28
.text$mn:00002D28                 push    ebp
.text$mn:00002D29                 mov     ebp, esp
.text$mn:00002D2B                 push    0FFFFFFFFh
.text$mn:00002D2D                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002D32                 mov     eax, large fs:0
.text$mn:00002D38                 push    eax
.text$mn:00002D39                 push    ecx
.text$mn:00002D3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D3F                 xor     eax, ebp
.text$mn:00002D41                 push    eax
.text$mn:00002D42                 lea     eax, [ebp+var_C]
.text$mn:00002D45                 mov     large fs:0, eax
.text$mn:00002D4B                 mov     [ebp+var_10], ecx
.text$mn:00002D4E                 mov     [ebp+var_4], 0
.text$mn:00002D55                 mov     ecx, [ebp+var_10]
.text$mn:00002D58                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Free_proxy(void)
.text$mn:00002D5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D64                 mov     ecx, [ebp+var_10]
.text$mn:00002D67                 call    ??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SwitcherFileInfo>>::~_Vector_val<std::_Simple_types<SwitcherFileInfo>>(void)
.text$mn:00002D6C                 mov     ecx, [ebp+var_C]
.text$mn:00002D6F                 mov     large fs:0, ecx
.text$mn:00002D76                 pop     ecx
.text$mn:00002D77                 mov     esp, ebp
.text$mn:00002D79                 pop     ebp
.text$mn:00002D7A                 retn
.text$mn:00002D7A ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002D7A
.text$mn:00002D7A ; ---------------------------------------------------------------------------
.text$mn:00002D7B                 align 4
.text$mn:00002D7B _text$mn        ends
.text$mn:00002D7B
.text$x:00002D7C ; ===========================================================================
.text$x:00002D7C
.text$x:00002D7C ; Segment type: Pure code
.text$x:00002D7C ; Segment permissions: Read/Execute
.text$x:00002D7C _text$x         segment para public 'CODE' use32
.text$x:00002D7C                 assume cs:_text$x
.text$x:00002D7C                 ;org 2D7Ch
.text$x:00002D7C ; COMDAT (pick associative to section at 2D28)
.text$x:00002D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D7C
.text$x:00002D7C ; =============== S U B R O U T I N E =======================================
.text$x:00002D7C
.text$x:00002D7C
.text$x:00002D7C __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002D7C                                         ; DATA XREF: .xdata$x:00006178o
.text$x:00002D7C                 mov     ecx, [ebp-10h]
.text$x:00002D7F                 jmp     ??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SwitcherFileInfo>>::~_Vector_val<std::_Simple_types<SwitcherFileInfo>>(void)
.text$x:00002D7F __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002D7F
.text$x:00002D84
.text$x:00002D84 ; =============== S U B R O U T I N E =======================================
.text$x:00002D84
.text$x:00002D84
.text$x:00002D84 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002D84                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(void)+5o
.text$x:00002D84
.text$x:00002D84 arg_4           = dword ptr  8
.text$x:00002D84
.text$x:00002D84                 mov     edx, [esp+arg_4]
.text$x:00002D88                 lea     eax, [edx+0Ch]
.text$x:00002D8B                 mov     ecx, [edx-8]
.text$x:00002D8E                 xor     ecx, eax
.text$x:00002D90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D95                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ
.text$x:00002D9A                 jmp     ___CxxFrameHandler3
.text$x:00002D9A __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00002D9A
.text$x:00002D9A ; ---------------------------------------------------------------------------
.text$x:00002D9F                 align 10h
.text$x:00002D9F _text$x         ends
.text$x:00002D9F
.text$mn:00002DA0 ; ===========================================================================
.text$mn:00002DA0
.text$mn:00002DA0 ; Segment type: Pure code
.text$mn:00002DA0 ; Segment permissions: Read/Execute
.text$mn:00002DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA0                 assume cs:_text$mn
.text$mn:00002DA0                 ;org 2DA0h
.text$mn:00002DA0 ; COMDAT (pick any)
.text$mn:00002DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DA0
.text$mn:00002DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA0
.text$mn:00002DA0 ; Attributes: bp-based frame
.text$mn:00002DA0
.text$mn:00002DA0 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>>(void)
.text$mn:00002DA0                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002DA0 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002DA0                                         ; CODE XREF: __unwindfunclet$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00002DA0                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::~vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)+3Fp ...
.text$mn:00002DA0
.text$mn:00002DA0 var_10          = dword ptr -10h
.text$mn:00002DA0 var_C           = dword ptr -0Ch
.text$mn:00002DA0 var_4           = dword ptr -4
.text$mn:00002DA0
.text$mn:00002DA0                 push    ebp
.text$mn:00002DA1                 mov     ebp, esp
.text$mn:00002DA3                 push    0FFFFFFFFh
.text$mn:00002DA5                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ
.text$mn:00002DAA                 mov     eax, large fs:0
.text$mn:00002DB0                 push    eax
.text$mn:00002DB1                 push    ecx
.text$mn:00002DB2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DB7                 xor     eax, ebp
.text$mn:00002DB9                 push    eax
.text$mn:00002DBA                 lea     eax, [ebp+var_C]
.text$mn:00002DBD                 mov     large fs:0, eax
.text$mn:00002DC3                 mov     [ebp+var_10], ecx
.text$mn:00002DC6                 mov     [ebp+var_4], 0
.text$mn:00002DCD                 mov     ecx, [ebp+var_10]
.text$mn:00002DD0                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Free_proxy(void)
.text$mn:00002DD5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002DDC                 mov     ecx, [ebp+var_10]
.text$mn:00002DDF                 call    ??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TaskLstFnStatus>>::~_Vector_val<std::_Simple_types<TaskLstFnStatus>>(void)
.text$mn:00002DE4                 mov     ecx, [ebp+var_C]
.text$mn:00002DE7                 mov     large fs:0, ecx
.text$mn:00002DEE                 pop     ecx
.text$mn:00002DEF                 mov     esp, ebp
.text$mn:00002DF1                 pop     ebp
.text$mn:00002DF2                 retn
.text$mn:00002DF2 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002DF2
.text$mn:00002DF2 ; ---------------------------------------------------------------------------
.text$mn:00002DF3                 align 4
.text$mn:00002DF3 _text$mn        ends
.text$mn:00002DF3
.text$x:00002DF4 ; ===========================================================================
.text$x:00002DF4
.text$x:00002DF4 ; Segment type: Pure code
.text$x:00002DF4 ; Segment permissions: Read/Execute
.text$x:00002DF4 _text$x         segment para public 'CODE' use32
.text$x:00002DF4                 assume cs:_text$x
.text$x:00002DF4                 ;org 2DF4h
.text$x:00002DF4 ; COMDAT (pick associative to section at 2DA0)
.text$x:00002DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DF4
.text$x:00002DF4 ; =============== S U B R O U T I N E =======================================
.text$x:00002DF4
.text$x:00002DF4
.text$x:00002DF4 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002DF4                                         ; DATA XREF: .xdata$x:00005F30o
.text$x:00002DF4                 mov     ecx, [ebp-10h]
.text$x:00002DF7                 jmp     ??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TaskLstFnStatus>>::~_Vector_val<std::_Simple_types<TaskLstFnStatus>>(void)
.text$x:00002DF7 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002DF7
.text$x:00002DFC
.text$x:00002DFC ; =============== S U B R O U T I N E =======================================
.text$x:00002DFC
.text$x:00002DFC
.text$x:00002DFC __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002DFC                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::~_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(void)+5o
.text$x:00002DFC
.text$x:00002DFC arg_4           = dword ptr  8
.text$x:00002DFC
.text$x:00002DFC                 mov     edx, [esp+arg_4]
.text$x:00002E00                 lea     eax, [edx+0Ch]
.text$x:00002E03                 mov     ecx, [edx-8]
.text$x:00002E06                 xor     ecx, eax
.text$x:00002E08                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E0D                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ
.text$x:00002E12                 jmp     ___CxxFrameHandler3
.text$x:00002E12 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00002E12
.text$x:00002E12 ; ---------------------------------------------------------------------------
.text$x:00002E17                 align 4
.text$x:00002E17 _text$x         ends
.text$x:00002E17
.text$mn:00002E18 ; ===========================================================================
.text$mn:00002E18
.text$mn:00002E18 ; Segment type: Pure code
.text$mn:00002E18 ; Segment permissions: Read/Execute
.text$mn:00002E18 _text$mn        segment para public 'CODE' use32
.text$mn:00002E18                 assume cs:_text$mn
.text$mn:00002E18                 ;org 2E18h
.text$mn:00002E18 ; COMDAT (pick any)
.text$mn:00002E18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E18
.text$mn:00002E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E18
.text$mn:00002E18 ; Attributes: bp-based frame
.text$mn:00002E18
.text$mn:00002E18 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct SwitcherFileInfo>>::~_Vector_val<struct std::_Simple_types<struct SwitcherFileInfo>>(void)
.text$mn:00002E18                 public ??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00002E18 ??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:00002E18                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z$0+3j
.text$mn:00002E18                                         ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(void)+3Fp ...
.text$mn:00002E18
.text$mn:00002E18 var_10          = dword ptr -10h
.text$mn:00002E18 var_C           = dword ptr -0Ch
.text$mn:00002E18 var_4           = dword ptr -4
.text$mn:00002E18
.text$mn:00002E18                 push    ebp
.text$mn:00002E19                 mov     ebp, esp
.text$mn:00002E1B                 push    0FFFFFFFFh
.text$mn:00002E1D                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00002E22                 mov     eax, large fs:0
.text$mn:00002E28                 push    eax
.text$mn:00002E29                 push    ecx
.text$mn:00002E2A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E2F                 xor     eax, ebp
.text$mn:00002E31                 push    eax
.text$mn:00002E32                 lea     eax, [ebp+var_C]
.text$mn:00002E35                 mov     large fs:0, eax
.text$mn:00002E3B                 mov     [ebp+var_10], ecx
.text$mn:00002E3E                 mov     [ebp+var_4], 0
.text$mn:00002E45                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E4C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E4F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002E54                 mov     ecx, [ebp+var_C]
.text$mn:00002E57                 mov     large fs:0, ecx
.text$mn:00002E5E                 pop     ecx
.text$mn:00002E5F                 mov     esp, ebp
.text$mn:00002E61                 pop     ebp
.text$mn:00002E62                 retn
.text$mn:00002E62 ??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:00002E62
.text$mn:00002E62 ; ---------------------------------------------------------------------------
.text$mn:00002E63                 align 4
.text$mn:00002E63 _text$mn        ends
.text$mn:00002E63
.text$x:00002E64 ; ===========================================================================
.text$x:00002E64
.text$x:00002E64 ; Segment type: Pure code
.text$x:00002E64 ; Segment permissions: Read/Execute
.text$x:00002E64 _text$x         segment para public 'CODE' use32
.text$x:00002E64                 assume cs:_text$x
.text$x:00002E64                 ;org 2E64h
.text$x:00002E64 ; COMDAT (pick associative to section at 2E18)
.text$x:00002E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E64
.text$x:00002E64 ; =============== S U B R O U T I N E =======================================
.text$x:00002E64
.text$x:00002E64
.text$x:00002E64 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002E64                                         ; DATA XREF: .xdata$x:00006120o
.text$x:00002E64                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E67                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002E67 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002E67
.text$x:00002E6C
.text$x:00002E6C ; =============== S U B R O U T I N E =======================================
.text$x:00002E6C
.text$x:00002E6C
.text$x:00002E6C __ehhandler$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:00002E6C                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<SwitcherFileInfo>>::~_Vector_val<std::_Simple_types<SwitcherFileInfo>>(void)+5o
.text$x:00002E6C
.text$x:00002E6C arg_4           = dword ptr  8
.text$x:00002E6C
.text$x:00002E6C                 mov     edx, [esp+arg_4]
.text$x:00002E70                 lea     eax, [edx+0Ch]
.text$x:00002E73                 mov     ecx, [edx-8]
.text$x:00002E76                 xor     ecx, eax
.text$x:00002E78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E7D                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$x:00002E82                 jmp     ___CxxFrameHandler3
.text$x:00002E82 __ehhandler$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:00002E82
.text$x:00002E82 ; ---------------------------------------------------------------------------
.text$x:00002E87                 align 4
.text$x:00002E87 _text$x         ends
.text$x:00002E87
.text$mn:00002E88 ; ===========================================================================
.text$mn:00002E88
.text$mn:00002E88 ; Segment type: Pure code
.text$mn:00002E88 ; Segment permissions: Read/Execute
.text$mn:00002E88 _text$mn        segment para public 'CODE' use32
.text$mn:00002E88                 assume cs:_text$mn
.text$mn:00002E88                 ;org 2E88h
.text$mn:00002E88 ; COMDAT (pick any)
.text$mn:00002E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E88
.text$mn:00002E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E88
.text$mn:00002E88 ; Attributes: bp-based frame
.text$mn:00002E88
.text$mn:00002E88 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct TaskLstFnStatus>>::~_Vector_val<struct std::_Simple_types<struct TaskLstFnStatus>>(void)
.text$mn:00002E88                 public ??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:00002E88 ??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$mn:00002E88                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z$0+3j
.text$mn:00002E88                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::~_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(void)+3Fp ...
.text$mn:00002E88
.text$mn:00002E88 var_10          = dword ptr -10h
.text$mn:00002E88 var_C           = dword ptr -0Ch
.text$mn:00002E88 var_4           = dword ptr -4
.text$mn:00002E88
.text$mn:00002E88                 push    ebp
.text$mn:00002E89                 mov     ebp, esp
.text$mn:00002E8B                 push    0FFFFFFFFh
.text$mn:00002E8D                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:00002E92                 mov     eax, large fs:0
.text$mn:00002E98                 push    eax
.text$mn:00002E99                 push    ecx
.text$mn:00002E9A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E9F                 xor     eax, ebp
.text$mn:00002EA1                 push    eax
.text$mn:00002EA2                 lea     eax, [ebp+var_C]
.text$mn:00002EA5                 mov     large fs:0, eax
.text$mn:00002EAB                 mov     [ebp+var_10], ecx
.text$mn:00002EAE                 mov     [ebp+var_4], 0
.text$mn:00002EB5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002EBC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002EBF                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002EC4                 mov     ecx, [ebp+var_C]
.text$mn:00002EC7                 mov     large fs:0, ecx
.text$mn:00002ECE                 pop     ecx
.text$mn:00002ECF                 mov     esp, ebp
.text$mn:00002ED1                 pop     ebp
.text$mn:00002ED2                 retn
.text$mn:00002ED2 ??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$mn:00002ED2
.text$mn:00002ED2 ; ---------------------------------------------------------------------------
.text$mn:00002ED3                 align 4
.text$mn:00002ED3 _text$mn        ends
.text$mn:00002ED3
.text$x:00002ED4 ; ===========================================================================
.text$x:00002ED4
.text$x:00002ED4 ; Segment type: Pure code
.text$x:00002ED4 ; Segment permissions: Read/Execute
.text$x:00002ED4 _text$x         segment para public 'CODE' use32
.text$x:00002ED4                 assume cs:_text$x
.text$x:00002ED4                 ;org 2ED4h
.text$x:00002ED4 ; COMDAT (pick associative to section at 2E88)
.text$x:00002ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002ED4
.text$x:00002ED4 ; =============== S U B R O U T I N E =======================================
.text$x:00002ED4
.text$x:00002ED4
.text$x:00002ED4 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002ED4                                         ; DATA XREF: .xdata$x:00005ED8o
.text$x:00002ED4                 mov     ecx, [ebp-10h]  ; this
.text$x:00002ED7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002ED7 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002ED7
.text$x:00002EDC
.text$x:00002EDC ; =============== S U B R O U T I N E =======================================
.text$x:00002EDC
.text$x:00002EDC
.text$x:00002EDC __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$x:00002EDC                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<TaskLstFnStatus>>::~_Vector_val<std::_Simple_types<TaskLstFnStatus>>(void)+5o
.text$x:00002EDC
.text$x:00002EDC arg_4           = dword ptr  8
.text$x:00002EDC
.text$x:00002EDC                 mov     edx, [esp+arg_4]
.text$x:00002EE0                 lea     eax, [edx+0Ch]
.text$x:00002EE3                 mov     ecx, [edx-8]
.text$x:00002EE6                 xor     ecx, eax
.text$x:00002EE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EED                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$x:00002EF2                 jmp     ___CxxFrameHandler3
.text$x:00002EF2 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$x:00002EF2
.text$x:00002EF2 ; ---------------------------------------------------------------------------
.text$x:00002EF7                 align 4
.text$x:00002EF7 _text$x         ends
.text$x:00002EF7
.text$mn:00002EF8 ; ===========================================================================
.text$mn:00002EF8
.text$mn:00002EF8 ; Segment type: Pure code
.text$mn:00002EF8 ; Segment permissions: Read/Execute
.text$mn:00002EF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EF8                 assume cs:_text$mn
.text$mn:00002EF8                 ;org 2EF8h
.text$mn:00002EF8 ; COMDAT (pick any)
.text$mn:00002EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EF8
.text$mn:00002EF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EF8
.text$mn:00002EF8 ; Attributes: bp-based frame
.text$mn:00002EF8
.text$mn:00002EF8 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00002EF8                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002EF8 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00002EF8                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00002EF8                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00002EF8
.text$mn:00002EF8 var_10          = dword ptr -10h
.text$mn:00002EF8 var_C           = dword ptr -0Ch
.text$mn:00002EF8 var_4           = dword ptr -4
.text$mn:00002EF8
.text$mn:00002EF8                 push    ebp
.text$mn:00002EF9                 mov     ebp, esp
.text$mn:00002EFB                 push    0FFFFFFFFh
.text$mn:00002EFD                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002F02                 mov     eax, large fs:0
.text$mn:00002F08                 push    eax
.text$mn:00002F09                 push    ecx
.text$mn:00002F0A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F0F                 xor     eax, ebp
.text$mn:00002F11                 push    eax
.text$mn:00002F12                 lea     eax, [ebp+var_C]
.text$mn:00002F15                 mov     large fs:0, eax
.text$mn:00002F1B                 mov     [ebp+var_10], ecx
.text$mn:00002F1E                 mov     [ebp+var_4], 0
.text$mn:00002F25                 push    0               ; Size
.text$mn:00002F27                 push    1               ; char
.text$mn:00002F29                 mov     ecx, [ebp+var_10]
.text$mn:00002F2C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002F31                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F38                 mov     ecx, [ebp+var_10]
.text$mn:00002F3B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00002F40                 mov     ecx, [ebp+var_C]
.text$mn:00002F43                 mov     large fs:0, ecx
.text$mn:00002F4A                 pop     ecx
.text$mn:00002F4B                 mov     esp, ebp
.text$mn:00002F4D                 pop     ebp
.text$mn:00002F4E                 retn
.text$mn:00002F4E ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00002F4E
.text$mn:00002F4E ; ---------------------------------------------------------------------------
.text$mn:00002F4F                 align 10h
.text$mn:00002F4F _text$mn        ends
.text$mn:00002F4F
.text$x:00002F50 ; ===========================================================================
.text$x:00002F50
.text$x:00002F50 ; Segment type: Pure code
.text$x:00002F50 ; Segment permissions: Read/Execute
.text$x:00002F50 _text$x         segment para public 'CODE' use32
.text$x:00002F50                 assume cs:_text$x
.text$x:00002F50                 ;org 2F50h
.text$x:00002F50 ; COMDAT (pick associative to section at 2EF8)
.text$x:00002F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F50
.text$x:00002F50 ; =============== S U B R O U T I N E =======================================
.text$x:00002F50
.text$x:00002F50
.text$x:00002F50 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00002F50                                         ; DATA XREF: .xdata$x:000059C4o
.text$x:00002F50                 mov     ecx, [ebp-10h]
.text$x:00002F53                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00002F53 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00002F53
.text$x:00002F58
.text$x:00002F58 ; =============== S U B R O U T I N E =======================================
.text$x:00002F58
.text$x:00002F58
.text$x:00002F58 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00002F58                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00002F58
.text$x:00002F58 arg_4           = dword ptr  8
.text$x:00002F58
.text$x:00002F58                 mov     edx, [esp+arg_4]
.text$x:00002F5C                 lea     eax, [edx+0Ch]
.text$x:00002F5F                 mov     ecx, [edx-8]
.text$x:00002F62                 xor     ecx, eax
.text$x:00002F64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F69                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00002F6E                 jmp     ___CxxFrameHandler3
.text$x:00002F6E __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00002F6E
.text$x:00002F6E ; ---------------------------------------------------------------------------
.text$x:00002F73                 align 4
.text$x:00002F73 _text$x         ends
.text$x:00002F73
.text$mn:00002F74 ; ===========================================================================
.text$mn:00002F74
.text$mn:00002F74 ; Segment type: Pure code
.text$mn:00002F74 ; Segment permissions: Read/Execute
.text$mn:00002F74 _text$mn        segment para public 'CODE' use32
.text$mn:00002F74                 assume cs:_text$mn
.text$mn:00002F74                 ;org 2F74h
.text$mn:00002F74 ; COMDAT (pick any)
.text$mn:00002F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F74
.text$mn:00002F74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F74
.text$mn:00002F74 ; Attributes: bp-based frame
.text$mn:00002F74
.text$mn:00002F74 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00002F74                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00002F74 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00002F74                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+1D3p
.text$mn:00002F74                                         ; VerticalFileSwitcherListView::initList(void)+424p ...
.text$mn:00002F74
.text$mn:00002F74 var_10          = dword ptr -10h
.text$mn:00002F74 var_C           = dword ptr -0Ch
.text$mn:00002F74 var_4           = dword ptr -4
.text$mn:00002F74
.text$mn:00002F74                 push    ebp
.text$mn:00002F75                 mov     ebp, esp
.text$mn:00002F77                 push    0FFFFFFFFh
.text$mn:00002F79                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00002F7E                 mov     eax, large fs:0
.text$mn:00002F84                 push    eax
.text$mn:00002F85                 push    ecx
.text$mn:00002F86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F8B                 xor     eax, ebp
.text$mn:00002F8D                 push    eax
.text$mn:00002F8E                 lea     eax, [ebp+var_C]
.text$mn:00002F91                 mov     large fs:0, eax
.text$mn:00002F97                 mov     [ebp+var_10], ecx
.text$mn:00002F9A                 mov     [ebp+var_4], 0
.text$mn:00002FA1                 push    0
.text$mn:00002FA3                 push    1
.text$mn:00002FA5                 mov     ecx, [ebp+var_10]
.text$mn:00002FA8                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002FAD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002FB4                 mov     ecx, [ebp+var_10]
.text$mn:00002FB7                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00002FBC                 mov     ecx, [ebp+var_C]
.text$mn:00002FBF                 mov     large fs:0, ecx
.text$mn:00002FC6                 pop     ecx
.text$mn:00002FC7                 mov     esp, ebp
.text$mn:00002FC9                 pop     ebp
.text$mn:00002FCA                 retn
.text$mn:00002FCA ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00002FCA
.text$mn:00002FCA ; ---------------------------------------------------------------------------
.text$mn:00002FCB                 align 4
.text$mn:00002FCB _text$mn        ends
.text$mn:00002FCB
.text$x:00002FCC ; ===========================================================================
.text$x:00002FCC
.text$x:00002FCC ; Segment type: Pure code
.text$x:00002FCC ; Segment permissions: Read/Execute
.text$x:00002FCC _text$x         segment para public 'CODE' use32
.text$x:00002FCC                 assume cs:_text$x
.text$x:00002FCC                 ;org 2FCCh
.text$x:00002FCC ; COMDAT (pick associative to section at 2F74)
.text$x:00002FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002FCC
.text$x:00002FCC ; =============== S U B R O U T I N E =======================================
.text$x:00002FCC
.text$x:00002FCC
.text$x:00002FCC __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00002FCC                                         ; DATA XREF: .xdata$x:00005D94o
.text$x:00002FCC                 mov     ecx, [ebp-10h]
.text$x:00002FCF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00002FCF __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00002FCF
.text$x:00002FD4
.text$x:00002FD4 ; =============== S U B R O U T I N E =======================================
.text$x:00002FD4
.text$x:00002FD4
.text$x:00002FD4 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00002FD4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00002FD4
.text$x:00002FD4 arg_4           = dword ptr  8
.text$x:00002FD4
.text$x:00002FD4                 mov     edx, [esp+arg_4]
.text$x:00002FD8                 lea     eax, [edx+0Ch]
.text$x:00002FDB                 mov     ecx, [edx-8]
.text$x:00002FDE                 xor     ecx, eax
.text$x:00002FE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FE5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00002FEA                 jmp     ___CxxFrameHandler3
.text$x:00002FEA __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00002FEA
.text$x:00002FEA ; ---------------------------------------------------------------------------
.text$x:00002FEF                 align 10h
.text$x:00002FEF _text$x         ends
.text$x:00002FEF
.text$mn:00002FF0 ; ===========================================================================
.text$mn:00002FF0
.text$mn:00002FF0 ; Segment type: Pure code
.text$mn:00002FF0 ; Segment permissions: Read/Execute
.text$mn:00002FF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002FF0                 assume cs:_text$mn
.text$mn:00002FF0                 ;org 2FF0h
.text$mn:00002FF0 ; COMDAT (pick any)
.text$mn:00002FF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FF0
.text$mn:00002FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FF0
.text$mn:00002FF0 ; Attributes: bp-based frame
.text$mn:00002FF0
.text$mn:00002FF0 ; public: __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::~vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>(void)
.text$mn:00002FF0                 public ??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00002FF0 ??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:00002FF0                                         ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+14Ap
.text$mn:00002FF0                                         ; __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$0+3j ...
.text$mn:00002FF0
.text$mn:00002FF0 var_10          = dword ptr -10h
.text$mn:00002FF0 var_C           = dword ptr -0Ch
.text$mn:00002FF0 var_4           = dword ptr -4
.text$mn:00002FF0
.text$mn:00002FF0                 push    ebp
.text$mn:00002FF1                 mov     ebp, esp
.text$mn:00002FF3                 push    0FFFFFFFFh
.text$mn:00002FF5                 push    offset __ehhandler$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$mn:00002FFA                 mov     eax, large fs:0
.text$mn:00003000                 push    eax
.text$mn:00003001                 push    ecx
.text$mn:00003002                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003007                 xor     eax, ebp
.text$mn:00003009                 push    eax
.text$mn:0000300A                 lea     eax, [ebp+var_C]
.text$mn:0000300D                 mov     large fs:0, eax
.text$mn:00003013                 mov     [ebp+var_10], ecx
.text$mn:00003016                 mov     [ebp+var_4], 0
.text$mn:0000301D                 mov     ecx, [ebp+var_10]
.text$mn:00003020                 call    ?_Tidy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Tidy(void)
.text$mn:00003025                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000302C                 mov     ecx, [ebp+var_10]
.text$mn:0000302F                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(void)
.text$mn:00003034                 mov     ecx, [ebp+var_C]
.text$mn:00003037                 mov     large fs:0, ecx
.text$mn:0000303E                 pop     ecx
.text$mn:0000303F                 mov     esp, ebp
.text$mn:00003041                 pop     ebp
.text$mn:00003042                 retn
.text$mn:00003042 ??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$mn:00003042
.text$mn:00003042 ; ---------------------------------------------------------------------------
.text$mn:00003043                 align 4
.text$mn:00003043 _text$mn        ends
.text$mn:00003043
.text$x:00003044 ; ===========================================================================
.text$x:00003044
.text$x:00003044 ; Segment type: Pure code
.text$x:00003044 ; Segment permissions: Read/Execute
.text$x:00003044 _text$x         segment para public 'CODE' use32
.text$x:00003044                 assume cs:_text$x
.text$x:00003044                 ;org 3044h
.text$x:00003044 ; COMDAT (pick associative to section at 2FF0)
.text$x:00003044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003044
.text$x:00003044 ; =============== S U B R O U T I N E =======================================
.text$x:00003044
.text$x:00003044
.text$x:00003044 __unwindfunclet$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003044                                         ; DATA XREF: .xdata$x:000061FCo
.text$x:00003044                 mov     ecx, [ebp-10h]
.text$x:00003047                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(void)
.text$x:00003047 __unwindfunclet$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003047
.text$x:0000304C
.text$x:0000304C ; =============== S U B R O U T I N E =======================================
.text$x:0000304C
.text$x:0000304C
.text$x:0000304C __ehhandler$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ proc near
.text$x:0000304C                                         ; DATA XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::~vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)+5o
.text$x:0000304C
.text$x:0000304C arg_4           = dword ptr  8
.text$x:0000304C
.text$x:0000304C                 mov     edx, [esp+arg_4]
.text$x:00003050                 lea     eax, [edx+0Ch]
.text$x:00003053                 mov     ecx, [edx-8]
.text$x:00003056                 xor     ecx, eax
.text$x:00003058                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000305D                 mov     eax, offset __ehfuncinfo$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.text$x:00003062                 jmp     ___CxxFrameHandler3
.text$x:00003062 __ehhandler$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ endp
.text$x:00003062
.text$x:00003062 ; ---------------------------------------------------------------------------
.text$x:00003067                 align 4
.text$x:00003067 _text$x         ends
.text$x:00003067
.text$mn:00003068 ; ===========================================================================
.text$mn:00003068
.text$mn:00003068 ; Segment type: Pure code
.text$mn:00003068 ; Segment permissions: Read/Execute
.text$mn:00003068 _text$mn        segment para public 'CODE' use32
.text$mn:00003068                 assume cs:_text$mn
.text$mn:00003068                 ;org 3068h
.text$mn:00003068 ; COMDAT (pick any)
.text$mn:00003068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003068
.text$mn:00003068 ; =============== S U B R O U T I N E =======================================
.text$mn:00003068
.text$mn:00003068 ; Attributes: bp-based frame
.text$mn:00003068
.text$mn:00003068 ; public: __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::~vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>(void)
.text$mn:00003068                 public ??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:00003068 ??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$mn:00003068                                         ; CODE XREF: __unwindfunclet$??0TaskListInfo@@QAE@XZ$0+3j
.text$mn:00003068                                         ; TaskListInfo::~TaskListInfo(void)+37p ...
.text$mn:00003068
.text$mn:00003068 var_10          = dword ptr -10h
.text$mn:00003068 var_C           = dword ptr -0Ch
.text$mn:00003068 var_4           = dword ptr -4
.text$mn:00003068
.text$mn:00003068                 push    ebp
.text$mn:00003069                 mov     ebp, esp
.text$mn:0000306B                 push    0FFFFFFFFh
.text$mn:0000306D                 push    offset __ehhandler$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$mn:00003072                 mov     eax, large fs:0
.text$mn:00003078                 push    eax
.text$mn:00003079                 push    ecx
.text$mn:0000307A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000307F                 xor     eax, ebp
.text$mn:00003081                 push    eax
.text$mn:00003082                 lea     eax, [ebp+var_C]
.text$mn:00003085                 mov     large fs:0, eax
.text$mn:0000308B                 mov     [ebp+var_10], ecx
.text$mn:0000308E                 mov     [ebp+var_4], 0
.text$mn:00003095                 mov     ecx, [ebp+var_10]
.text$mn:00003098                 call    ?_Tidy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXXZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Tidy(void)
.text$mn:0000309D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000030A4                 mov     ecx, [ebp+var_10]
.text$mn:000030A7                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::~_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(void)
.text$mn:000030AC                 mov     ecx, [ebp+var_C]
.text$mn:000030AF                 mov     large fs:0, ecx
.text$mn:000030B6                 pop     ecx
.text$mn:000030B7                 mov     esp, ebp
.text$mn:000030B9                 pop     ebp
.text$mn:000030BA                 retn
.text$mn:000030BA ??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$mn:000030BA
.text$mn:000030BA ; ---------------------------------------------------------------------------
.text$mn:000030BB                 align 4
.text$mn:000030BB _text$mn        ends
.text$mn:000030BB
.text$x:000030BC ; ===========================================================================
.text$x:000030BC
.text$x:000030BC ; Segment type: Pure code
.text$x:000030BC ; Segment permissions: Read/Execute
.text$x:000030BC _text$x         segment para public 'CODE' use32
.text$x:000030BC                 assume cs:_text$x
.text$x:000030BC                 ;org 30BCh
.text$x:000030BC ; COMDAT (pick associative to section at 3068)
.text$x:000030BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030BC
.text$x:000030BC ; =============== S U B R O U T I N E =======================================
.text$x:000030BC
.text$x:000030BC
.text$x:000030BC __unwindfunclet$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000030BC                                         ; DATA XREF: .xdata$x:00005F88o
.text$x:000030BC                 mov     ecx, [ebp-10h]
.text$x:000030BF                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::~_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(void)
.text$x:000030BF __unwindfunclet$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0 endp
.text$x:000030BF
.text$x:000030C4
.text$x:000030C4 ; =============== S U B R O U T I N E =======================================
.text$x:000030C4
.text$x:000030C4
.text$x:000030C4 __ehhandler$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ proc near
.text$x:000030C4                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::~vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)+5o
.text$x:000030C4
.text$x:000030C4 arg_4           = dword ptr  8
.text$x:000030C4
.text$x:000030C4                 mov     edx, [esp+arg_4]
.text$x:000030C8                 lea     eax, [edx+0Ch]
.text$x:000030CB                 mov     ecx, [edx-8]
.text$x:000030CE                 xor     ecx, eax
.text$x:000030D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030D5                 mov     eax, offset __ehfuncinfo$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.text$x:000030DA                 jmp     ___CxxFrameHandler3
.text$x:000030DA __ehhandler$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ endp
.text$x:000030DA
.text$x:000030DA ; ---------------------------------------------------------------------------
.text$x:000030DF                 align 10h
.text$x:000030DF _text$x         ends
.text$x:000030DF
.text$mn:000030E0 ; ===========================================================================
.text$mn:000030E0
.text$mn:000030E0 ; Segment type: Pure code
.text$mn:000030E0 ; Segment permissions: Read/Execute
.text$mn:000030E0 _text$mn        segment para public 'CODE' use32
.text$mn:000030E0                 assume cs:_text$mn
.text$mn:000030E0                 ;org 30E0h
.text$mn:000030E0 ; COMDAT (pick any)
.text$mn:000030E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030E0
.text$mn:000030E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030E0
.text$mn:000030E0 ; Attributes: bp-based frame
.text$mn:000030E0
.text$mn:000030E0 ; _DWORD __thiscall TaskListInfo::~TaskListInfo(TaskListInfo *__hidden this)
.text$mn:000030E0                 public ??1TaskListInfo@@QAE@XZ
.text$mn:000030E0 ??1TaskListInfo@@QAE@XZ proc near       ; CODE XREF: VerticalFileSwitcherListView::initList(void)+436p
.text$mn:000030E0                                         ; __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$0+6j
.text$mn:000030E0
.text$mn:000030E0 var_10          = dword ptr -10h
.text$mn:000030E0 var_C           = dword ptr -0Ch
.text$mn:000030E0 var_4           = dword ptr -4
.text$mn:000030E0
.text$mn:000030E0                 push    ebp
.text$mn:000030E1                 mov     ebp, esp
.text$mn:000030E3                 push    0FFFFFFFFh
.text$mn:000030E5                 push    offset __ehhandler$??1TaskListInfo@@QAE@XZ
.text$mn:000030EA                 mov     eax, large fs:0
.text$mn:000030F0                 push    eax
.text$mn:000030F1                 push    ecx
.text$mn:000030F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030F7                 xor     eax, ebp
.text$mn:000030F9                 push    eax
.text$mn:000030FA                 lea     eax, [ebp+var_C]
.text$mn:000030FD                 mov     large fs:0, eax
.text$mn:00003103                 mov     [ebp+var_10], ecx
.text$mn:00003106                 mov     [ebp+var_4], 0
.text$mn:0000310D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003114                 mov     ecx, [ebp+var_10]
.text$mn:00003117                 call    ??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::~vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)
.text$mn:0000311C                 mov     ecx, [ebp+var_C]
.text$mn:0000311F                 mov     large fs:0, ecx
.text$mn:00003126                 pop     ecx
.text$mn:00003127                 mov     esp, ebp
.text$mn:00003129                 pop     ebp
.text$mn:0000312A                 retn
.text$mn:0000312A ??1TaskListInfo@@QAE@XZ endp
.text$mn:0000312A
.text$mn:0000312A ; ---------------------------------------------------------------------------
.text$mn:0000312B                 align 4
.text$mn:0000312B _text$mn        ends
.text$mn:0000312B
.text$x:0000312C ; ===========================================================================
.text$x:0000312C
.text$x:0000312C ; Segment type: Pure code
.text$x:0000312C ; Segment permissions: Read/Execute
.text$x:0000312C _text$x         segment para public 'CODE' use32
.text$x:0000312C                 assume cs:_text$x
.text$x:0000312C                 ;org 312Ch
.text$x:0000312C ; COMDAT (pick associative to section at 30E0)
.text$x:0000312C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000312C
.text$x:0000312C ; =============== S U B R O U T I N E =======================================
.text$x:0000312C
.text$x:0000312C
.text$x:0000312C __unwindfunclet$??1TaskListInfo@@QAE@XZ$0 proc near
.text$x:0000312C                                         ; DATA XREF: .xdata$x:00005FE0o
.text$x:0000312C                 mov     ecx, [ebp-10h]
.text$x:0000312F                 jmp     ??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::~vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)
.text$x:0000312F __unwindfunclet$??1TaskListInfo@@QAE@XZ$0 endp
.text$x:0000312F
.text$x:00003134
.text$x:00003134 ; =============== S U B R O U T I N E =======================================
.text$x:00003134
.text$x:00003134
.text$x:00003134 __ehhandler$??1TaskListInfo@@QAE@XZ proc near
.text$x:00003134                                         ; DATA XREF: TaskListInfo::~TaskListInfo(void)+5o
.text$x:00003134
.text$x:00003134 arg_4           = dword ptr  8
.text$x:00003134
.text$x:00003134                 mov     edx, [esp+arg_4]
.text$x:00003138                 lea     eax, [edx+0Ch]
.text$x:0000313B                 mov     ecx, [edx-8]
.text$x:0000313E                 xor     ecx, eax
.text$x:00003140                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003145                 mov     eax, offset __ehfuncinfo$??1TaskListInfo@@QAE@XZ
.text$x:0000314A                 jmp     ___CxxFrameHandler3
.text$x:0000314A __ehhandler$??1TaskListInfo@@QAE@XZ endp
.text$x:0000314A
.text$x:0000314A ; ---------------------------------------------------------------------------
.text$x:0000314F                 align 10h
.text$x:0000314F _text$x         ends
.text$x:0000314F
.text$mn:00003150 ; ===========================================================================
.text$mn:00003150
.text$mn:00003150 ; Segment type: Pure code
.text$mn:00003150 ; Segment permissions: Read/Execute
.text$mn:00003150 _text$mn        segment para public 'CODE' use32
.text$mn:00003150                 assume cs:_text$mn
.text$mn:00003150                 ;org 3150h
.text$mn:00003150 ; COMDAT (pick any)
.text$mn:00003150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003150
.text$mn:00003150 ; =============== S U B R O U T I N E =======================================
.text$mn:00003150
.text$mn:00003150 ; Attributes: bp-based frame
.text$mn:00003150
.text$mn:00003150 ; _DWORD __thiscall TaskLstFnStatus::~TaskLstFnStatus(TaskLstFnStatus *__hidden this)
.text$mn:00003150                 public ??1TaskLstFnStatus@@QAE@XZ
.text$mn:00003150 ??1TaskLstFnStatus@@QAE@XZ proc near    ; CODE XREF: TaskLstFnStatus::`scalar deleting destructor'(uint)+Ap
.text$mn:00003150
.text$mn:00003150 var_10          = dword ptr -10h
.text$mn:00003150 var_C           = dword ptr -0Ch
.text$mn:00003150 var_4           = dword ptr -4
.text$mn:00003150
.text$mn:00003150                 push    ebp
.text$mn:00003151                 mov     ebp, esp
.text$mn:00003153                 push    0FFFFFFFFh
.text$mn:00003155                 push    offset __ehhandler$??1TaskLstFnStatus@@QAE@XZ
.text$mn:0000315A                 mov     eax, large fs:0
.text$mn:00003160                 push    eax
.text$mn:00003161                 push    ecx
.text$mn:00003162                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003167                 xor     eax, ebp
.text$mn:00003169                 push    eax
.text$mn:0000316A                 lea     eax, [ebp+var_C]
.text$mn:0000316D                 mov     large fs:0, eax
.text$mn:00003173                 mov     [ebp+var_10], ecx
.text$mn:00003176                 mov     [ebp+var_4], 0
.text$mn:0000317D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003184                 mov     ecx, [ebp+var_10]
.text$mn:00003187                 add     ecx, 8
.text$mn:0000318A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000318F                 mov     ecx, [ebp+var_C]
.text$mn:00003192                 mov     large fs:0, ecx
.text$mn:00003199                 pop     ecx
.text$mn:0000319A                 mov     esp, ebp
.text$mn:0000319C                 pop     ebp
.text$mn:0000319D                 retn
.text$mn:0000319D ??1TaskLstFnStatus@@QAE@XZ endp
.text$mn:0000319D
.text$mn:0000319D ; ---------------------------------------------------------------------------
.text$mn:0000319E                 align 10h
.text$mn:0000319E _text$mn        ends
.text$mn:0000319E
.text$x:000031A0 ; ===========================================================================
.text$x:000031A0
.text$x:000031A0 ; Segment type: Pure code
.text$x:000031A0 ; Segment permissions: Read/Execute
.text$x:000031A0 _text$x         segment para public 'CODE' use32
.text$x:000031A0                 assume cs:_text$x
.text$x:000031A0                 ;org 31A0h
.text$x:000031A0 ; COMDAT (pick associative to section at 3150)
.text$x:000031A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000031A0
.text$x:000031A0 ; =============== S U B R O U T I N E =======================================
.text$x:000031A0
.text$x:000031A0
.text$x:000031A0 __unwindfunclet$??1TaskLstFnStatus@@QAE@XZ$0 proc near
.text$x:000031A0                                         ; DATA XREF: .xdata$x:00005E80o
.text$x:000031A0                 mov     ecx, [ebp-10h]
.text$x:000031A3                 add     ecx, 8
.text$x:000031A6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000031A6 __unwindfunclet$??1TaskLstFnStatus@@QAE@XZ$0 endp
.text$x:000031A6
.text$x:000031AB
.text$x:000031AB ; =============== S U B R O U T I N E =======================================
.text$x:000031AB
.text$x:000031AB
.text$x:000031AB __ehhandler$??1TaskLstFnStatus@@QAE@XZ proc near
.text$x:000031AB                                         ; DATA XREF: TaskLstFnStatus::~TaskLstFnStatus(void)+5o
.text$x:000031AB
.text$x:000031AB arg_4           = dword ptr  8
.text$x:000031AB
.text$x:000031AB                 mov     edx, [esp+arg_4]
.text$x:000031AF                 lea     eax, [edx+0Ch]
.text$x:000031B2                 mov     ecx, [edx-8]
.text$x:000031B5                 xor     ecx, eax
.text$x:000031B7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031BC                 mov     eax, offset __ehfuncinfo$??1TaskLstFnStatus@@QAE@XZ
.text$x:000031C1                 jmp     ___CxxFrameHandler3
.text$x:000031C1 __ehhandler$??1TaskLstFnStatus@@QAE@XZ endp
.text$x:000031C1
.text$x:000031C1 ; ---------------------------------------------------------------------------
.text$x:000031C6                 align 4
.text$x:000031C6 _text$x         ends
.text$x:000031C6
.text$mn:000031C8 ; ===========================================================================
.text$mn:000031C8
.text$mn:000031C8 ; Segment type: Pure code
.text$mn:000031C8 ; Segment permissions: Read/Execute
.text$mn:000031C8 _text$mn        segment para public 'CODE' use32
.text$mn:000031C8                 assume cs:_text$mn
.text$mn:000031C8                 ;org 31C8h
.text$mn:000031C8 ; COMDAT (pick any)
.text$mn:000031C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031C8
.text$mn:000031C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000031C8
.text$mn:000031C8 ; Attributes: bp-based frame
.text$mn:000031C8
.text$mn:000031C8 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000031C8                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000031C8 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000031C8                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000031C8                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:000031C8
.text$mn:000031C8 var_4           = dword ptr -4
.text$mn:000031C8
.text$mn:000031C8                 push    ebp
.text$mn:000031C9                 mov     ebp, esp
.text$mn:000031CB                 push    ecx
.text$mn:000031CC                 mov     [ebp+var_4], ecx
.text$mn:000031CF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000031D2                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000031D7                 mov     esp, ebp
.text$mn:000031D9                 pop     ebp
.text$mn:000031DA                 retn
.text$mn:000031DA ??1_Container_base12@std@@QAE@XZ endp
.text$mn:000031DA
.text$mn:000031DA ; ---------------------------------------------------------------------------
.text$mn:000031DB                 align 4
.text$mn:000031DB _text$mn        ends
.text$mn:000031DB
.text$mn:000031DC ; ===========================================================================
.text$mn:000031DC
.text$mn:000031DC ; Segment type: Pure code
.text$mn:000031DC ; Segment permissions: Read/Execute
.text$mn:000031DC _text$mn        segment para public 'CODE' use32
.text$mn:000031DC                 assume cs:_text$mn
.text$mn:000031DC                 ;org 31DCh
.text$mn:000031DC ; COMDAT (pick any)
.text$mn:000031DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031DC
.text$mn:000031DC ; =============== S U B R O U T I N E =======================================
.text$mn:000031DC
.text$mn:000031DC ; Attributes: bp-based frame
.text$mn:000031DC
.text$mn:000031DC ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000031DC                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:000031DC ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:000031DC                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:000031DC                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:000031DC
.text$mn:000031DC var_10          = dword ptr -10h
.text$mn:000031DC var_C           = dword ptr -0Ch
.text$mn:000031DC var_4           = dword ptr -4
.text$mn:000031DC
.text$mn:000031DC                 push    ebp
.text$mn:000031DD                 mov     ebp, esp
.text$mn:000031DF                 push    0FFFFFFFFh
.text$mn:000031E1                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000031E6                 mov     eax, large fs:0
.text$mn:000031EC                 push    eax
.text$mn:000031ED                 push    ecx
.text$mn:000031EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000031F3                 xor     eax, ebp
.text$mn:000031F5                 push    eax
.text$mn:000031F6                 lea     eax, [ebp+var_C]
.text$mn:000031F9                 mov     large fs:0, eax
.text$mn:000031FF                 mov     [ebp+var_10], ecx
.text$mn:00003202                 mov     [ebp+var_4], 0
.text$mn:00003209                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003210                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003213                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00003218                 mov     ecx, [ebp+var_C]
.text$mn:0000321B                 mov     large fs:0, ecx
.text$mn:00003222                 pop     ecx
.text$mn:00003223                 mov     esp, ebp
.text$mn:00003225                 pop     ebp
.text$mn:00003226                 retn
.text$mn:00003226 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00003226
.text$mn:00003226 ; ---------------------------------------------------------------------------
.text$mn:00003227                 align 4
.text$mn:00003227 _text$mn        ends
.text$mn:00003227
.text$x:00003228 ; ===========================================================================
.text$x:00003228
.text$x:00003228 ; Segment type: Pure code
.text$x:00003228 ; Segment permissions: Read/Execute
.text$x:00003228 _text$x         segment para public 'CODE' use32
.text$x:00003228                 assume cs:_text$x
.text$x:00003228                 ;org 3228h
.text$x:00003228 ; COMDAT (pick associative to section at 31DC)
.text$x:00003228                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003228
.text$x:00003228 ; =============== S U B R O U T I N E =======================================
.text$x:00003228
.text$x:00003228
.text$x:00003228 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00003228                                         ; DATA XREF: .xdata$x:00005B58o
.text$x:00003228                 mov     ecx, [ebp-10h]  ; this
.text$x:0000322B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000322B __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000322B
.text$x:00003230
.text$x:00003230 ; =============== S U B R O U T I N E =======================================
.text$x:00003230
.text$x:00003230
.text$x:00003230 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00003230                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00003230
.text$x:00003230 arg_4           = dword ptr  8
.text$x:00003230
.text$x:00003230                 mov     edx, [esp+arg_4]
.text$x:00003234                 lea     eax, [edx+0Ch]
.text$x:00003237                 mov     ecx, [edx-8]
.text$x:0000323A                 xor     ecx, eax
.text$x:0000323C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003241                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00003246                 jmp     ___CxxFrameHandler3
.text$x:00003246 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00003246
.text$x:00003246 ; ---------------------------------------------------------------------------
.text$x:0000324B                 align 4
.text$x:0000324B _text$x         ends
.text$x:0000324B
.text$mn:0000324C ; ===========================================================================
.text$mn:0000324C
.text$mn:0000324C ; Segment type: Pure code
.text$mn:0000324C ; Segment permissions: Read/Execute
.text$mn:0000324C _text$mn        segment para public 'CODE' use32
.text$mn:0000324C                 assume cs:_text$mn
.text$mn:0000324C                 ;org 324Ch
.text$mn:0000324C ; COMDAT (pick any)
.text$mn:0000324C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000324C
.text$mn:0000324C ; =============== S U B R O U T I N E =======================================
.text$mn:0000324C
.text$mn:0000324C ; Attributes: bp-based frame
.text$mn:0000324C
.text$mn:0000324C ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000324C                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000324C ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:0000324C                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000324C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000324C
.text$mn:0000324C var_10          = dword ptr -10h
.text$mn:0000324C var_C           = dword ptr -0Ch
.text$mn:0000324C var_4           = dword ptr -4
.text$mn:0000324C
.text$mn:0000324C                 push    ebp
.text$mn:0000324D                 mov     ebp, esp
.text$mn:0000324F                 push    0FFFFFFFFh
.text$mn:00003251                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003256                 mov     eax, large fs:0
.text$mn:0000325C                 push    eax
.text$mn:0000325D                 push    ecx
.text$mn:0000325E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003263                 xor     eax, ebp
.text$mn:00003265                 push    eax
.text$mn:00003266                 lea     eax, [ebp+var_C]
.text$mn:00003269                 mov     large fs:0, eax
.text$mn:0000326F                 mov     [ebp+var_10], ecx
.text$mn:00003272                 mov     [ebp+var_4], 0
.text$mn:00003279                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003280                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003283                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003288                 mov     ecx, [ebp+var_C]
.text$mn:0000328B                 mov     large fs:0, ecx
.text$mn:00003292                 pop     ecx
.text$mn:00003293                 mov     esp, ebp
.text$mn:00003295                 pop     ebp
.text$mn:00003296                 retn
.text$mn:00003296 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00003296
.text$mn:00003296 ; ---------------------------------------------------------------------------
.text$mn:00003297                 align 4
.text$mn:00003297 _text$mn        ends
.text$mn:00003297
.text$x:00003298 ; ===========================================================================
.text$x:00003298
.text$x:00003298 ; Segment type: Pure code
.text$x:00003298 ; Segment permissions: Read/Execute
.text$x:00003298 _text$x         segment para public 'CODE' use32
.text$x:00003298                 assume cs:_text$x
.text$x:00003298                 ;org 3298h
.text$x:00003298 ; COMDAT (pick associative to section at 324C)
.text$x:00003298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003298
.text$x:00003298 ; =============== S U B R O U T I N E =======================================
.text$x:00003298
.text$x:00003298
.text$x:00003298 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00003298                                         ; DATA XREF: .xdata$x:00005BDCo
.text$x:00003298                 mov     ecx, [ebp-10h]  ; this
.text$x:0000329B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000329B __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:0000329B
.text$x:000032A0
.text$x:000032A0 ; =============== S U B R O U T I N E =======================================
.text$x:000032A0
.text$x:000032A0
.text$x:000032A0 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000032A0                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000032A0
.text$x:000032A0 arg_4           = dword ptr  8
.text$x:000032A0
.text$x:000032A0                 mov     edx, [esp+arg_4]
.text$x:000032A4                 lea     eax, [edx+0Ch]
.text$x:000032A7                 mov     ecx, [edx-8]
.text$x:000032AA                 xor     ecx, eax
.text$x:000032AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000032B1                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000032B6                 jmp     ___CxxFrameHandler3
.text$x:000032B6 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000032B6
.text$x:000032B6 ; ---------------------------------------------------------------------------
.text$x:000032BB                 align 4
.text$x:000032BB _text$x         ends
.text$x:000032BB
.text$mn:000032BC ; ===========================================================================
.text$mn:000032BC
.text$mn:000032BC ; Segment type: Pure code
.text$mn:000032BC ; Segment permissions: Read/Execute
.text$mn:000032BC _text$mn        segment para public 'CODE' use32
.text$mn:000032BC                 assume cs:_text$mn
.text$mn:000032BC                 ;org 32BCh
.text$mn:000032BC ; COMDAT (pick any)
.text$mn:000032BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032BC
.text$mn:000032BC ; =============== S U B R O U T I N E =======================================
.text$mn:000032BC
.text$mn:000032BC ; Attributes: bp-based frame
.text$mn:000032BC
.text$mn:000032BC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000032BC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000032BC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000032BC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000032BC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000032BC
.text$mn:000032BC var_10          = dword ptr -10h
.text$mn:000032BC var_C           = dword ptr -0Ch
.text$mn:000032BC var_4           = dword ptr -4
.text$mn:000032BC
.text$mn:000032BC                 push    ebp
.text$mn:000032BD                 mov     ebp, esp
.text$mn:000032BF                 push    0FFFFFFFFh
.text$mn:000032C1                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000032C6                 mov     eax, large fs:0
.text$mn:000032CC                 push    eax
.text$mn:000032CD                 push    ecx
.text$mn:000032CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032D3                 xor     eax, ebp
.text$mn:000032D5                 push    eax
.text$mn:000032D6                 lea     eax, [ebp+var_C]
.text$mn:000032D9                 mov     large fs:0, eax
.text$mn:000032DF                 mov     [ebp+var_10], ecx
.text$mn:000032E2                 mov     [ebp+var_4], 0
.text$mn:000032E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000032F0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000032F3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000032F8                 mov     ecx, [ebp+var_C]
.text$mn:000032FB                 mov     large fs:0, ecx
.text$mn:00003302                 pop     ecx
.text$mn:00003303                 mov     esp, ebp
.text$mn:00003305                 pop     ebp
.text$mn:00003306                 retn
.text$mn:00003306 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00003306
.text$mn:00003306 ; ---------------------------------------------------------------------------
.text$mn:00003307                 align 4
.text$mn:00003307 _text$mn        ends
.text$mn:00003307
.text$x:00003308 ; ===========================================================================
.text$x:00003308
.text$x:00003308 ; Segment type: Pure code
.text$x:00003308 ; Segment permissions: Read/Execute
.text$x:00003308 _text$x         segment para public 'CODE' use32
.text$x:00003308                 assume cs:_text$x
.text$x:00003308                 ;org 3308h
.text$x:00003308 ; COMDAT (pick associative to section at 32BC)
.text$x:00003308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003308
.text$x:00003308 ; =============== S U B R O U T I N E =======================================
.text$x:00003308
.text$x:00003308
.text$x:00003308 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00003308                                         ; DATA XREF: .xdata$x:00005C60o
.text$x:00003308                 mov     ecx, [ebp-10h]  ; this
.text$x:0000330B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000330B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000330B
.text$x:00003310
.text$x:00003310 ; =============== S U B R O U T I N E =======================================
.text$x:00003310
.text$x:00003310
.text$x:00003310 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00003310                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00003310
.text$x:00003310 arg_4           = dword ptr  8
.text$x:00003310
.text$x:00003310                 mov     edx, [esp+arg_4]
.text$x:00003314                 lea     eax, [edx+0Ch]
.text$x:00003317                 mov     ecx, [edx-8]
.text$x:0000331A                 xor     ecx, eax
.text$x:0000331C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003321                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00003326                 jmp     ___CxxFrameHandler3
.text$x:00003326 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00003326
.text$x:00003326 ; ---------------------------------------------------------------------------
.text$x:0000332B                 align 4
.text$x:0000332B _text$x         ends
.text$x:0000332B
.text$mn:0000332C ; ===========================================================================
.text$mn:0000332C
.text$mn:0000332C ; Segment type: Pure code
.text$mn:0000332C ; Segment permissions: Read/Execute
.text$mn:0000332C _text$mn        segment para public 'CODE' use32
.text$mn:0000332C                 assume cs:_text$mn
.text$mn:0000332C                 ;org 332Ch
.text$mn:0000332C ; COMDAT (pick any)
.text$mn:0000332C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000332C
.text$mn:0000332C ; =============== S U B R O U T I N E =======================================
.text$mn:0000332C
.text$mn:0000332C ; Attributes: bp-based frame
.text$mn:0000332C
.text$mn:0000332C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000332C                 public ??1error_category@std@@UAE@XZ
.text$mn:0000332C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000332C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000332C
.text$mn:0000332C var_4           = dword ptr -4
.text$mn:0000332C
.text$mn:0000332C                 push    ebp
.text$mn:0000332D                 mov     ebp, esp
.text$mn:0000332F                 push    ecx
.text$mn:00003330                 mov     [ebp+var_4], ecx
.text$mn:00003333                 mov     eax, [ebp+var_4]
.text$mn:00003336                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000333C                 mov     esp, ebp
.text$mn:0000333E                 pop     ebp
.text$mn:0000333F                 retn
.text$mn:0000333F ??1error_category@std@@UAE@XZ endp
.text$mn:0000333F
.text$mn:0000333F _text$mn        ends
.text$mn:0000333F
.text$mn:00003340 ; ===========================================================================
.text$mn:00003340
.text$mn:00003340 ; Segment type: Pure code
.text$mn:00003340 ; Segment permissions: Read/Execute
.text$mn:00003340 _text$mn        segment para public 'CODE' use32
.text$mn:00003340                 assume cs:_text$mn
.text$mn:00003340                 ;org 3340h
.text$mn:00003340 ; COMDAT (pick any)
.text$mn:00003340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003340
.text$mn:00003340 ; =============== S U B R O U T I N E =======================================
.text$mn:00003340
.text$mn:00003340 ; Attributes: bp-based frame
.text$mn:00003340
.text$mn:00003340 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00003340                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00003340 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00003340                                         ; DATA XREF: .xdata$x:000063C0o
.text$mn:00003340
.text$mn:00003340 var_10          = dword ptr -10h
.text$mn:00003340 var_C           = dword ptr -0Ch
.text$mn:00003340 var_4           = dword ptr -4
.text$mn:00003340
.text$mn:00003340                 push    ebp
.text$mn:00003341                 mov     ebp, esp
.text$mn:00003343                 push    0FFFFFFFFh
.text$mn:00003345                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:0000334A                 mov     eax, large fs:0
.text$mn:00003350                 push    eax
.text$mn:00003351                 push    ecx
.text$mn:00003352                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003357                 xor     eax, ebp
.text$mn:00003359                 push    eax
.text$mn:0000335A                 lea     eax, [ebp+var_C]
.text$mn:0000335D                 mov     large fs:0, eax
.text$mn:00003363                 mov     [ebp+var_10], ecx
.text$mn:00003366                 mov     [ebp+var_4], 0
.text$mn:0000336D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003374                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003377                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:0000337C                 mov     ecx, [ebp+var_C]
.text$mn:0000337F                 mov     large fs:0, ecx
.text$mn:00003386                 pop     ecx
.text$mn:00003387                 mov     esp, ebp
.text$mn:00003389                 pop     ebp
.text$mn:0000338A                 retn
.text$mn:0000338A ??1runtime_error@std@@UAE@XZ endp
.text$mn:0000338A
.text$mn:0000338A ; ---------------------------------------------------------------------------
.text$mn:0000338B                 align 4
.text$mn:0000338B _text$mn        ends
.text$mn:0000338B
.text$x:0000338C ; ===========================================================================
.text$x:0000338C
.text$x:0000338C ; Segment type: Pure code
.text$x:0000338C ; Segment permissions: Read/Execute
.text$x:0000338C _text$x         segment para public 'CODE' use32
.text$x:0000338C                 assume cs:_text$x
.text$x:0000338C                 ;org 338Ch
.text$x:0000338C ; COMDAT (pick associative to section at 3340)
.text$x:0000338C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000338C
.text$x:0000338C ; =============== S U B R O U T I N E =======================================
.text$x:0000338C
.text$x:0000338C
.text$x:0000338C __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:0000338C                                         ; DATA XREF: .xdata$x:00005AA8o
.text$x:0000338C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000338F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000338F __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:0000338F
.text$x:00003394
.text$x:00003394 ; =============== S U B R O U T I N E =======================================
.text$x:00003394
.text$x:00003394
.text$x:00003394 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00003394                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00003394
.text$x:00003394 arg_4           = dword ptr  8
.text$x:00003394
.text$x:00003394                 mov     edx, [esp+arg_4]
.text$x:00003398                 lea     eax, [edx+0Ch]
.text$x:0000339B                 mov     ecx, [edx-8]
.text$x:0000339E                 xor     ecx, eax
.text$x:000033A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000033A5                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:000033AA                 jmp     ___CxxFrameHandler3
.text$x:000033AA __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:000033AA
.text$x:000033AA ; ---------------------------------------------------------------------------
.text$x:000033AF                 align 10h
.text$x:000033AF _text$x         ends
.text$x:000033AF
.text$mn:000033B0 ; ===========================================================================
.text$mn:000033B0
.text$mn:000033B0 ; Segment type: Pure code
.text$mn:000033B0 ; Segment permissions: Read/Execute
.text$mn:000033B0 _text$mn        segment para public 'CODE' use32
.text$mn:000033B0                 assume cs:_text$mn
.text$mn:000033B0                 ;org 33B0h
.text$mn:000033B0 ; COMDAT (pick any)
.text$mn:000033B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033B0
.text$mn:000033B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033B0
.text$mn:000033B0 ; Attributes: bp-based frame
.text$mn:000033B0
.text$mn:000033B0 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:000033B0                 public ??2@YAPAXIPAX@Z
.text$mn:000033B0 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:000033B0                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:000033B0
.text$mn:000033B0 arg_4           = dword ptr  0Ch
.text$mn:000033B0
.text$mn:000033B0                 push    ebp
.text$mn:000033B1                 mov     ebp, esp
.text$mn:000033B3                 mov     eax, [ebp+arg_4]
.text$mn:000033B6                 pop     ebp
.text$mn:000033B7                 retn
.text$mn:000033B7 ??2@YAPAXIPAX@Z endp
.text$mn:000033B7
.text$mn:000033B7 _text$mn        ends
.text$mn:000033B7
.text$mn:000033B8 ; ===========================================================================
.text$mn:000033B8
.text$mn:000033B8 ; Segment type: Pure code
.text$mn:000033B8 ; Segment permissions: Read/Execute
.text$mn:000033B8 _text$mn        segment para public 'CODE' use32
.text$mn:000033B8                 assume cs:_text$mn
.text$mn:000033B8                 ;org 33B8h
.text$mn:000033B8 ; COMDAT (pick any)
.text$mn:000033B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033B8
.text$mn:000033B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000033B8
.text$mn:000033B8 ; Attributes: bp-based frame
.text$mn:000033B8
.text$mn:000033B8 ; void __cdecl operator delete(void *)
.text$mn:000033B8                 public ??3@YAXPAX0@Z
.text$mn:000033B8 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:000033B8                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:000033B8                 push    ebp
.text$mn:000033B9                 mov     ebp, esp
.text$mn:000033BB                 pop     ebp
.text$mn:000033BC                 retn
.text$mn:000033BC ??3@YAXPAX0@Z   endp
.text$mn:000033BC
.text$mn:000033BC ; ---------------------------------------------------------------------------
.text$mn:000033BD                 align 10h
.text$mn:000033BD _text$mn        ends
.text$mn:000033BD
.text$mn:000033C0 ; ===========================================================================
.text$mn:000033C0
.text$mn:000033C0 ; Segment type: Pure code
.text$mn:000033C0 ; Segment permissions: Read/Execute
.text$mn:000033C0 _text$mn        segment para public 'CODE' use32
.text$mn:000033C0                 assume cs:_text$mn
.text$mn:000033C0                 ;org 33C0h
.text$mn:000033C0 ; COMDAT (pick any)
.text$mn:000033C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033C0
.text$mn:000033C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033C0
.text$mn:000033C0 ; Attributes: bp-based frame
.text$mn:000033C0
.text$mn:000033C0 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:000033C0                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:000033C0 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:000033C0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:000033C0                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:000033C0
.text$mn:000033C0 var_8           = dword ptr -8
.text$mn:000033C0 var_4           = dword ptr -4
.text$mn:000033C0 arg_0           = dword ptr  8
.text$mn:000033C0
.text$mn:000033C0                 push    ebp
.text$mn:000033C1                 mov     ebp, esp
.text$mn:000033C3                 sub     esp, 8
.text$mn:000033C6                 mov     [ebp+var_8], ecx
.text$mn:000033C9                 mov     eax, [ebp+var_8]
.text$mn:000033CC                 cmp     eax, [ebp+arg_0]
.text$mn:000033CF                 jnz     short loc_33DA
.text$mn:000033D1                 mov     [ebp+var_4], 1
.text$mn:000033D8                 jmp     short loc_33E1
.text$mn:000033DA ; ---------------------------------------------------------------------------
.text$mn:000033DA
.text$mn:000033DA loc_33DA:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:000033DA                 mov     [ebp+var_4], 0
.text$mn:000033E1
.text$mn:000033E1 loc_33E1:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000033E1                 mov     al, byte ptr [ebp+var_4]
.text$mn:000033E4                 mov     esp, ebp
.text$mn:000033E6                 pop     ebp
.text$mn:000033E7                 retn    4
.text$mn:000033E7 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000033E7
.text$mn:000033E7 ; ---------------------------------------------------------------------------
.text$mn:000033EA                 align 4
.text$mn:000033EA _text$mn        ends
.text$mn:000033EA
.text$mn:000033EC ; ===========================================================================
.text$mn:000033EC
.text$mn:000033EC ; Segment type: Pure code
.text$mn:000033EC ; Segment permissions: Read/Execute
.text$mn:000033EC _text$mn        segment para public 'CODE' use32
.text$mn:000033EC                 assume cs:_text$mn
.text$mn:000033EC                 ;org 33ECh
.text$mn:000033EC ; COMDAT (pick any)
.text$mn:000033EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033EC
.text$mn:000033EC ; =============== S U B R O U T I N E =======================================
.text$mn:000033EC
.text$mn:000033EC ; Attributes: bp-based frame
.text$mn:000033EC
.text$mn:000033EC ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000033EC                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000033EC ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000033EC                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000033EC
.text$mn:000033EC var_8           = dword ptr -8
.text$mn:000033EC var_4           = dword ptr -4
.text$mn:000033EC arg_0           = dword ptr  8
.text$mn:000033EC
.text$mn:000033EC                 push    ebp
.text$mn:000033ED                 mov     ebp, esp
.text$mn:000033EF                 sub     esp, 8
.text$mn:000033F2                 push    esi
.text$mn:000033F3                 mov     [ebp+var_4], ecx
.text$mn:000033F6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000033F9                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000033FE                 push    eax
.text$mn:000033FF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003402                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00003407                 mov     ecx, eax
.text$mn:00003409                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000340E                 movzx   eax, al
.text$mn:00003411                 test    eax, eax
.text$mn:00003413                 jz      short loc_3434
.text$mn:00003415                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003418                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000341D                 mov     esi, eax
.text$mn:0000341F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003422                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00003427                 cmp     esi, eax
.text$mn:00003429                 jnz     short loc_3434
.text$mn:0000342B                 mov     [ebp+var_8], 1
.text$mn:00003432                 jmp     short loc_343B
.text$mn:00003434 ; ---------------------------------------------------------------------------
.text$mn:00003434
.text$mn:00003434 loc_3434:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00003434                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00003434                 mov     [ebp+var_8], 0
.text$mn:0000343B
.text$mn:0000343B loc_343B:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000343B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000343E                 pop     esi
.text$mn:0000343F                 mov     esp, ebp
.text$mn:00003441                 pop     ebp
.text$mn:00003442                 retn    4
.text$mn:00003442 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00003442
.text$mn:00003442 ; ---------------------------------------------------------------------------
.text$mn:00003445                 align 4
.text$mn:00003445 _text$mn        ends
.text$mn:00003445
.text$mn:00003448 ; ===========================================================================
.text$mn:00003448
.text$mn:00003448 ; Segment type: Pure code
.text$mn:00003448 ; Segment permissions: Read/Execute
.text$mn:00003448 _text$mn        segment para public 'CODE' use32
.text$mn:00003448                 assume cs:_text$mn
.text$mn:00003448                 ;org 3448h
.text$mn:00003448 ; COMDAT (pick any)
.text$mn:00003448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003448
.text$mn:00003448 ; =============== S U B R O U T I N E =======================================
.text$mn:00003448
.text$mn:00003448 ; Attributes: bp-based frame
.text$mn:00003448
.text$mn:00003448 ; public: struct TaskLstFnStatus & __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::operator[](unsigned int)
.text$mn:00003448                 public ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z
.text$mn:00003448 ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z proc near
.text$mn:00003448                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+223p
.text$mn:00003448
.text$mn:00003448 var_4           = dword ptr -4
.text$mn:00003448 arg_0           = dword ptr  8
.text$mn:00003448
.text$mn:00003448                 push    ebp
.text$mn:00003449                 mov     ebp, esp
.text$mn:0000344B                 push    ecx
.text$mn:0000344C                 mov     [ebp+var_4], ecx
.text$mn:0000344F                 mov     ecx, [ebp+var_4]
.text$mn:00003452                 call    ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::size(void)
.text$mn:00003457                 cmp     eax, [ebp+arg_0]
.text$mn:0000345A                 ja      short loc_34C4
.text$mn:0000345C                 push    4B1h            ; unsigned int
.text$mn:00003461                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003466                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000346B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003470                 add     esp, 0Ch
.text$mn:00003473                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00003478                 test    eax, eax
.text$mn:0000347A                 jz      short loc_3480
.text$mn:0000347C                 xor     ecx, ecx
.text$mn:0000347E                 jnz     short loc_34A6
.text$mn:00003480
.text$mn:00003480 loc_3480:                               ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+32j
.text$mn:00003480                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00003485                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000348A                 push    0
.text$mn:0000348C                 push    4B2h
.text$mn:00003491                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003496                 push    2
.text$mn:00003498                 call    __CrtDbgReportW
.text$mn:0000349D                 add     esp, 18h
.text$mn:000034A0                 cmp     eax, 1
.text$mn:000034A3                 jnz     short loc_34A6
.text$mn:000034A5                 int     3               ; Trap to Debugger
.text$mn:000034A6
.text$mn:000034A6 loc_34A6:                               ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+36j
.text$mn:000034A6                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+5Bj
.text$mn:000034A6                 push    0
.text$mn:000034A8                 push    4B2h
.text$mn:000034AD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000034B2                 push    offset ??_C@_1LO@OIFNPDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAa?$AAs?$AAk?$AAL?$AAs?$AAt?$AAF?$AAn?$AAS?$AAt?$AAa?$AAt@ ; "std::vector<struct TaskLstFnStatus,clas"...
.text$mn:000034B7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000034BC                 call    __invalid_parameter
.text$mn:000034C1                 add     esp, 14h
.text$mn:000034C4
.text$mn:000034C4 loc_34C4:                               ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+12j
.text$mn:000034C4                 imul    eax, [ebp+arg_0], 2Ch
.text$mn:000034C8                 mov     ecx, [ebp+var_4]
.text$mn:000034CB                 add     eax, [ecx+4]
.text$mn:000034CE                 mov     esp, ebp
.text$mn:000034D0                 pop     ebp
.text$mn:000034D1                 retn    4
.text$mn:000034D1 ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z endp
.text$mn:000034D1
.text$mn:000034D1 _text$mn        ends
.text$mn:000034D1
.text$mn:000034D4 ; ===========================================================================
.text$mn:000034D4
.text$mn:000034D4 ; Segment type: Pure code
.text$mn:000034D4 ; Segment permissions: Read/Execute
.text$mn:000034D4 _text$mn        segment para public 'CODE' use32
.text$mn:000034D4                 assume cs:_text$mn
.text$mn:000034D4                 ;org 34D4h
.text$mn:000034D4 ; COMDAT (pick any)
.text$mn:000034D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034D4
.text$mn:000034D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034D4
.text$mn:000034D4 ; Attributes: bp-based frame
.text$mn:000034D4
.text$mn:000034D4 ; public: void * __thiscall TaskLstFnStatus::`scalar deleting destructor'(unsigned int)
.text$mn:000034D4                 public ??_GTaskLstFnStatus@@QAEPAXI@Z
.text$mn:000034D4 ??_GTaskLstFnStatus@@QAEPAXI@Z proc near
.text$mn:000034D4                                         ; CODE XREF: VerticalFileSwitcherListView::destroy(void)+7Ep
.text$mn:000034D4                                         ; VerticalFileSwitcherListView::remove(int)+4Bp ...
.text$mn:000034D4
.text$mn:000034D4 var_4           = dword ptr -4
.text$mn:000034D4 arg_0           = dword ptr  8
.text$mn:000034D4
.text$mn:000034D4                 push    ebp
.text$mn:000034D5                 mov     ebp, esp
.text$mn:000034D7                 push    ecx
.text$mn:000034D8                 mov     [ebp+var_4], ecx
.text$mn:000034DB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000034DE                 call    ??1TaskLstFnStatus@@QAE@XZ ; TaskLstFnStatus::~TaskLstFnStatus(void)
.text$mn:000034E3                 mov     eax, [ebp+arg_0]
.text$mn:000034E6                 and     eax, 1
.text$mn:000034E9                 jz      short loc_34F7
.text$mn:000034EB                 mov     ecx, [ebp+var_4]
.text$mn:000034EE                 push    ecx             ; void *
.text$mn:000034EF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000034F4                 add     esp, 4
.text$mn:000034F7
.text$mn:000034F7 loc_34F7:                               ; CODE XREF: TaskLstFnStatus::`scalar deleting destructor'(uint)+15j
.text$mn:000034F7                 mov     eax, [ebp+var_4]
.text$mn:000034FA                 mov     esp, ebp
.text$mn:000034FC                 pop     ebp
.text$mn:000034FD                 retn    4
.text$mn:000034FD ??_GTaskLstFnStatus@@QAEPAXI@Z endp
.text$mn:000034FD
.text$mn:000034FD _text$mn        ends
.text$mn:000034FD
.text$mn:00003500 ; ===========================================================================
.text$mn:00003500
.text$mn:00003500 ; Segment type: Pure code
.text$mn:00003500 ; Segment permissions: Read/Execute
.text$mn:00003500 _text$mn        segment para public 'CODE' use32
.text$mn:00003500                 assume cs:_text$mn
.text$mn:00003500                 ;org 3500h
.text$mn:00003500 ; COMDAT (pick any)
.text$mn:00003500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003500
.text$mn:00003500 ; =============== S U B R O U T I N E =======================================
.text$mn:00003500
.text$mn:00003500 ; Attributes: bp-based frame
.text$mn:00003500
.text$mn:00003500 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003500                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00003500 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003500
.text$mn:00003500 var_4           = dword ptr -4
.text$mn:00003500 arg_0           = dword ptr  8
.text$mn:00003500
.text$mn:00003500                 push    ebp
.text$mn:00003501                 mov     ebp, esp
.text$mn:00003503                 push    ecx
.text$mn:00003504                 mov     [ebp+var_4], ecx
.text$mn:00003507                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000350A                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000350F                 mov     eax, [ebp+arg_0]
.text$mn:00003512                 and     eax, 1
.text$mn:00003515                 jz      short loc_3523
.text$mn:00003517                 mov     ecx, [ebp+var_4]
.text$mn:0000351A                 push    ecx             ; void *
.text$mn:0000351B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003520                 add     esp, 4
.text$mn:00003523
.text$mn:00003523 loc_3523:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00003523                 mov     eax, [ebp+var_4]
.text$mn:00003526                 mov     esp, ebp
.text$mn:00003528                 pop     ebp
.text$mn:00003529                 retn    4
.text$mn:00003529 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00003529
.text$mn:00003529 _text$mn        ends
.text$mn:00003529
.text$mn:0000352C ; ===========================================================================
.text$mn:0000352C
.text$mn:0000352C ; Segment type: Pure code
.text$mn:0000352C ; Segment permissions: Read/Execute
.text$mn:0000352C _text$mn        segment para public 'CODE' use32
.text$mn:0000352C                 assume cs:_text$mn
.text$mn:0000352C                 ;org 352Ch
.text$mn:0000352C ; COMDAT (pick any)
.text$mn:0000352C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000352C
.text$mn:0000352C ; =============== S U B R O U T I N E =======================================
.text$mn:0000352C
.text$mn:0000352C ; Attributes: bp-based frame
.text$mn:0000352C
.text$mn:0000352C ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000352C                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:0000352C ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000352C
.text$mn:0000352C var_4           = dword ptr -4
.text$mn:0000352C arg_0           = dword ptr  8
.text$mn:0000352C
.text$mn:0000352C                 push    ebp
.text$mn:0000352D                 mov     ebp, esp
.text$mn:0000352F                 push    ecx
.text$mn:00003530                 mov     [ebp+var_4], ecx
.text$mn:00003533                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003536                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000353B                 mov     eax, [ebp+arg_0]
.text$mn:0000353E                 and     eax, 1
.text$mn:00003541                 jz      short loc_354F
.text$mn:00003543                 mov     ecx, [ebp+var_4]
.text$mn:00003546                 push    ecx             ; void *
.text$mn:00003547                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000354C                 add     esp, 4
.text$mn:0000354F
.text$mn:0000354F loc_354F:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000354F                 mov     eax, [ebp+var_4]
.text$mn:00003552                 mov     esp, ebp
.text$mn:00003554                 pop     ebp
.text$mn:00003555                 retn    4
.text$mn:00003555 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00003555
.text$mn:00003555 _text$mn        ends
.text$mn:00003555
.text$mn:00003558 ; ===========================================================================
.text$mn:00003558
.text$mn:00003558 ; Segment type: Pure code
.text$mn:00003558 ; Segment permissions: Read/Execute
.text$mn:00003558 _text$mn        segment para public 'CODE' use32
.text$mn:00003558                 assume cs:_text$mn
.text$mn:00003558                 ;org 3558h
.text$mn:00003558 ; COMDAT (pick any)
.text$mn:00003558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003558
.text$mn:00003558 ; =============== S U B R O U T I N E =======================================
.text$mn:00003558
.text$mn:00003558 ; Attributes: bp-based frame
.text$mn:00003558
.text$mn:00003558 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003558                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00003558 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003558
.text$mn:00003558 var_4           = dword ptr -4
.text$mn:00003558 arg_0           = dword ptr  8
.text$mn:00003558
.text$mn:00003558                 push    ebp
.text$mn:00003559                 mov     ebp, esp
.text$mn:0000355B                 push    ecx
.text$mn:0000355C                 mov     [ebp+var_4], ecx
.text$mn:0000355F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003562                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00003567                 mov     eax, [ebp+arg_0]
.text$mn:0000356A                 and     eax, 1
.text$mn:0000356D                 jz      short loc_357B
.text$mn:0000356F                 mov     ecx, [ebp+var_4]
.text$mn:00003572                 push    ecx             ; void *
.text$mn:00003573                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003578                 add     esp, 4
.text$mn:0000357B
.text$mn:0000357B loc_357B:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000357B                 mov     eax, [ebp+var_4]
.text$mn:0000357E                 mov     esp, ebp
.text$mn:00003580                 pop     ebp
.text$mn:00003581                 retn    4
.text$mn:00003581 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00003581
.text$mn:00003581 _text$mn        ends
.text$mn:00003581
.text$mn:00003584 ; ===========================================================================
.text$mn:00003584
.text$mn:00003584 ; Segment type: Pure code
.text$mn:00003584 ; Segment permissions: Read/Execute
.text$mn:00003584 _text$mn        segment para public 'CODE' use32
.text$mn:00003584                 assume cs:_text$mn
.text$mn:00003584                 ;org 3584h
.text$mn:00003584 ; COMDAT (pick any)
.text$mn:00003584                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003584
.text$mn:00003584 ; =============== S U B R O U T I N E =======================================
.text$mn:00003584
.text$mn:00003584 ; Attributes: bp-based frame
.text$mn:00003584
.text$mn:00003584 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003584                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00003584 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00003584
.text$mn:00003584 var_4           = dword ptr -4
.text$mn:00003584 arg_0           = dword ptr  8
.text$mn:00003584
.text$mn:00003584                 push    ebp
.text$mn:00003585                 mov     ebp, esp
.text$mn:00003587                 push    ecx
.text$mn:00003588                 mov     [ebp+var_4], ecx
.text$mn:0000358B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000358E                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00003593                 mov     eax, [ebp+arg_0]
.text$mn:00003596                 and     eax, 1
.text$mn:00003599                 jz      short loc_35A7
.text$mn:0000359B                 mov     ecx, [ebp+var_4]
.text$mn:0000359E                 push    ecx             ; void *
.text$mn:0000359F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000035A4                 add     esp, 4
.text$mn:000035A7
.text$mn:000035A7 loc_35A7:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000035A7                 mov     eax, [ebp+var_4]
.text$mn:000035AA                 mov     esp, ebp
.text$mn:000035AC                 pop     ebp
.text$mn:000035AD                 retn    4
.text$mn:000035AD ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000035AD
.text$mn:000035AD _text$mn        ends
.text$mn:000035AD
.text$mn:000035B0 ; ===========================================================================
.text$mn:000035B0
.text$mn:000035B0 ; Segment type: Pure code
.text$mn:000035B0 ; Segment permissions: Read/Execute
.text$mn:000035B0 _text$mn        segment para public 'CODE' use32
.text$mn:000035B0                 assume cs:_text$mn
.text$mn:000035B0                 ;org 35B0h
.text$mn:000035B0 ; COMDAT (pick any)
.text$mn:000035B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035B0
.text$mn:000035B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035B0
.text$mn:000035B0 ; Attributes: bp-based frame
.text$mn:000035B0
.text$mn:000035B0 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:000035B0                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:000035B0 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:000035B0
.text$mn:000035B0 var_4           = dword ptr -4
.text$mn:000035B0 arg_0           = dword ptr  8
.text$mn:000035B0
.text$mn:000035B0                 push    ebp
.text$mn:000035B1                 mov     ebp, esp
.text$mn:000035B3                 push    ecx
.text$mn:000035B4                 mov     [ebp+var_4], ecx
.text$mn:000035B7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000035BA                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:000035BF                 mov     eax, [ebp+arg_0]
.text$mn:000035C2                 and     eax, 1
.text$mn:000035C5                 jz      short loc_35D3
.text$mn:000035C7                 mov     ecx, [ebp+var_4]
.text$mn:000035CA                 push    ecx             ; void *
.text$mn:000035CB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000035D0                 add     esp, 4
.text$mn:000035D3
.text$mn:000035D3 loc_35D3:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:000035D3                 mov     eax, [ebp+var_4]
.text$mn:000035D6                 mov     esp, ebp
.text$mn:000035D8                 pop     ebp
.text$mn:000035D9                 retn    4
.text$mn:000035D9 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:000035D9
.text$mn:000035D9 _text$mn        ends
.text$mn:000035D9
.text$di:000035DC ; ===========================================================================
.text$di:000035DC
.text$di:000035DC ; Segment type: Pure code
.text$di:000035DC ; Segment permissions: Read/Execute
.text$di:000035DC _text$di        segment para public 'CODE' use32
.text$di:000035DC                 assume cs:_text$di
.text$di:000035DC                 ;org 35DCh
.text$di:000035DC ; COMDAT (pick any)
.text$di:000035DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000035DC
.text$di:000035DC ; =============== S U B R O U T I N E =======================================
.text$di:000035DC
.text$di:000035DC ; Attributes: bp-based frame
.text$di:000035DC
.text$di:000035DC ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000035DC ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000035DC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000035DC                 push    ebp
.text$di:000035DD                 mov     ebp, esp
.text$di:000035DF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000035E4                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000035E9                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000035EE                 call    _atexit
.text$di:000035F3                 add     esp, 4
.text$di:000035F6                 pop     ebp
.text$di:000035F7                 retn
.text$di:000035F7 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000035F7
.text$di:000035F7 _text$di        ends
.text$di:000035F7
.text$di:000035F8 ; ===========================================================================
.text$di:000035F8
.text$di:000035F8 ; Segment type: Pure code
.text$di:000035F8 ; Segment permissions: Read/Execute
.text$di:000035F8 _text$di        segment para public 'CODE' use32
.text$di:000035F8                 assume cs:_text$di
.text$di:000035F8                 ;org 35F8h
.text$di:000035F8 ; COMDAT (pick any)
.text$di:000035F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000035F8
.text$di:000035F8 ; =============== S U B R O U T I N E =======================================
.text$di:000035F8
.text$di:000035F8 ; Attributes: bp-based frame
.text$di:000035F8
.text$di:000035F8 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000035F8 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000035F8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000035F8                 push    ebp
.text$di:000035F9                 mov     ebp, esp
.text$di:000035FB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00003600                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00003605                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000360A                 call    _atexit
.text$di:0000360F                 add     esp, 4
.text$di:00003612                 pop     ebp
.text$di:00003613                 retn
.text$di:00003613 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00003613
.text$di:00003613 _text$di        ends
.text$di:00003613
.text$di:00003614 ; ===========================================================================
.text$di:00003614
.text$di:00003614 ; Segment type: Pure code
.text$di:00003614 ; Segment permissions: Read/Execute
.text$di:00003614 _text$di        segment para public 'CODE' use32
.text$di:00003614                 assume cs:_text$di
.text$di:00003614                 ;org 3614h
.text$di:00003614 ; COMDAT (pick any)
.text$di:00003614                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003614
.text$di:00003614 ; =============== S U B R O U T I N E =======================================
.text$di:00003614
.text$di:00003614 ; Attributes: bp-based frame
.text$di:00003614
.text$di:00003614 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00003614 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00003614                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00003614                 push    ebp
.text$di:00003615                 mov     ebp, esp
.text$di:00003617                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:0000361C                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00003621                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00003626                 call    _atexit
.text$di:0000362B                 add     esp, 4
.text$di:0000362E                 pop     ebp
.text$di:0000362F                 retn
.text$di:0000362F ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000362F
.text$di:0000362F _text$di        ends
.text$di:0000362F
.text$di:00003630 ; ===========================================================================
.text$di:00003630
.text$di:00003630 ; Segment type: Pure code
.text$di:00003630 ; Segment permissions: Read/Execute
.text$di:00003630 _text$di        segment para public 'CODE' use32
.text$di:00003630                 assume cs:_text$di
.text$di:00003630                 ;org 3630h
.text$di:00003630 ; COMDAT (pick any)
.text$di:00003630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003630
.text$di:00003630 ; =============== S U B R O U T I N E =======================================
.text$di:00003630
.text$di:00003630 ; Attributes: bp-based frame
.text$di:00003630
.text$di:00003630 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00003630 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003630                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00003630                 push    ebp
.text$di:00003631                 mov     ebp, esp
.text$di:00003633                 push    0               ; unsigned int
.text$di:00003635                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000363A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000363F                 pop     ebp
.text$di:00003640                 retn
.text$di:00003640 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003640
.text$di:00003640 ; ---------------------------------------------------------------------------
.text$di:00003641                 align 4
.text$di:00003641 _text$di        ends
.text$di:00003641
.text$di:00003644 ; ===========================================================================
.text$di:00003644
.text$di:00003644 ; Segment type: Pure code
.text$di:00003644 ; Segment permissions: Read/Execute
.text$di:00003644 _text$di        segment para public 'CODE' use32
.text$di:00003644                 assume cs:_text$di
.text$di:00003644                 ;org 3644h
.text$di:00003644 ; COMDAT (pick any)
.text$di:00003644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003644
.text$di:00003644 ; =============== S U B R O U T I N E =======================================
.text$di:00003644
.text$di:00003644 ; Attributes: bp-based frame
.text$di:00003644
.text$di:00003644 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00003644 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003644                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00003644                 push    ebp
.text$di:00003645                 mov     ebp, esp
.text$di:00003647                 push    0               ; unsigned int
.text$di:00003649                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000364E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003653                 pop     ebp
.text$di:00003654                 retn
.text$di:00003654 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003654
.text$di:00003654 ; ---------------------------------------------------------------------------
.text$di:00003655                 align 4
.text$di:00003655 _text$di        ends
.text$di:00003655
.text$di:00003658 ; ===========================================================================
.text$di:00003658
.text$di:00003658 ; Segment type: Pure code
.text$di:00003658 ; Segment permissions: Read/Execute
.text$di:00003658 _text$di        segment para public 'CODE' use32
.text$di:00003658                 assume cs:_text$di
.text$di:00003658                 ;org 3658h
.text$di:00003658 ; COMDAT (pick any)
.text$di:00003658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003658
.text$di:00003658 ; =============== S U B R O U T I N E =======================================
.text$di:00003658
.text$di:00003658 ; Attributes: bp-based frame
.text$di:00003658
.text$di:00003658 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00003658 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003658                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00003658                 push    ebp
.text$di:00003659                 mov     ebp, esp
.text$di:0000365B                 push    0               ; unsigned int
.text$di:0000365D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00003662                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003667                 pop     ebp
.text$di:00003668                 retn
.text$di:00003668 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003668
.text$di:00003668 ; ---------------------------------------------------------------------------
.text$di:00003669                 align 4
.text$di:00003669 _text$di        ends
.text$di:00003669
.text$di:0000366C ; ===========================================================================
.text$di:0000366C
.text$di:0000366C ; Segment type: Pure code
.text$di:0000366C ; Segment permissions: Read/Execute
.text$di:0000366C _text$di        segment para public 'CODE' use32
.text$di:0000366C                 assume cs:_text$di
.text$di:0000366C                 ;org 366Ch
.text$di:0000366C ; COMDAT (pick any)
.text$di:0000366C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000366C
.text$di:0000366C ; =============== S U B R O U T I N E =======================================
.text$di:0000366C
.text$di:0000366C ; Attributes: bp-based frame
.text$di:0000366C
.text$di:0000366C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:0000366C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000366C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:0000366C                 push    ebp
.text$di:0000366D                 mov     ebp, esp
.text$di:0000366F                 push    0               ; unsigned int
.text$di:00003671                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00003676                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000367B                 pop     ebp
.text$di:0000367C                 retn
.text$di:0000367C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000367C
.text$di:0000367C ; ---------------------------------------------------------------------------
.text$di:0000367D                 align 10h
.text$di:0000367D _text$di        ends
.text$di:0000367D
.text$di:00003680 ; ===========================================================================
.text$di:00003680
.text$di:00003680 ; Segment type: Pure code
.text$di:00003680 ; Segment permissions: Read/Execute
.text$di:00003680 _text$di        segment para public 'CODE' use32
.text$di:00003680                 assume cs:_text$di
.text$di:00003680                 ;org 3680h
.text$di:00003680 ; COMDAT (pick any)
.text$di:00003680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003680
.text$di:00003680 ; =============== S U B R O U T I N E =======================================
.text$di:00003680
.text$di:00003680 ; Attributes: bp-based frame
.text$di:00003680
.text$di:00003680 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00003680 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00003680
.text$di:00003680 var_1           = byte ptr -1
.text$di:00003680
.text$di:00003680                 push    ebp
.text$di:00003681                 mov     ebp, esp
.text$di:00003683                 push    ecx
.text$di:00003684                 xor     eax, eax
.text$di:00003686                 mov     [ebp+var_1], al
.text$di:00003689                 mov     esp, ebp
.text$di:0000368B                 pop     ebp
.text$di:0000368C                 retn
.text$di:0000368C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:0000368C
.text$di:0000368C ; ---------------------------------------------------------------------------
.text$di:0000368D                 align 10h
.text$di:0000368D _text$di        ends
.text$di:0000368D
.text$di:00003690 ; ===========================================================================
.text$di:00003690
.text$di:00003690 ; Segment type: Pure code
.text$di:00003690 ; Segment permissions: Read/Execute
.text$di:00003690 _text$di        segment para public 'CODE' use32
.text$di:00003690                 assume cs:_text$di
.text$di:00003690                 ;org 3690h
.text$di:00003690 ; COMDAT (pick any)
.text$di:00003690                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003690
.text$di:00003690 ; =============== S U B R O U T I N E =======================================
.text$di:00003690
.text$di:00003690 ; Attributes: bp-based frame
.text$di:00003690
.text$di:00003690 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00003690 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00003690                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00003690
.text$di:00003690 var_1           = byte ptr -1
.text$di:00003690
.text$di:00003690                 push    ebp
.text$di:00003691                 mov     ebp, esp
.text$di:00003693                 push    ecx
.text$di:00003694                 xor     eax, eax
.text$di:00003696                 mov     [ebp+var_1], al
.text$di:00003699                 mov     esp, ebp
.text$di:0000369B                 pop     ebp
.text$di:0000369C                 retn
.text$di:0000369C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:0000369C
.text$di:0000369C ; ---------------------------------------------------------------------------
.text$di:0000369D                 align 10h
.text$di:0000369D _text$di        ends
.text$di:0000369D
.text$yd:000036A0 ; ===========================================================================
.text$yd:000036A0
.text$yd:000036A0 ; Segment type: Pure code
.text$yd:000036A0 ; Segment permissions: Read/Execute
.text$yd:000036A0 _text$yd        segment para public 'CODE' use32
.text$yd:000036A0                 assume cs:_text$yd
.text$yd:000036A0                 ;org 36A0h
.text$yd:000036A0 ; COMDAT (pick any)
.text$yd:000036A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000036A0
.text$yd:000036A0 ; =============== S U B R O U T I N E =======================================
.text$yd:000036A0
.text$yd:000036A0 ; Attributes: bp-based frame
.text$yd:000036A0
.text$yd:000036A0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000036A0 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000036A0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000036A0                 push    ebp
.text$yd:000036A1                 mov     ebp, esp
.text$yd:000036A3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:000036A8                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:000036AD                 pop     ebp
.text$yd:000036AE                 retn
.text$yd:000036AE ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:000036AE
.text$yd:000036AE ; ---------------------------------------------------------------------------
.text$yd:000036AF                 align 10h
.text$yd:000036AF _text$yd        ends
.text$yd:000036AF
.text$yd:000036B0 ; ===========================================================================
.text$yd:000036B0
.text$yd:000036B0 ; Segment type: Pure code
.text$yd:000036B0 ; Segment permissions: Read/Execute
.text$yd:000036B0 _text$yd        segment para public 'CODE' use32
.text$yd:000036B0                 assume cs:_text$yd
.text$yd:000036B0                 ;org 36B0h
.text$yd:000036B0 ; COMDAT (pick any)
.text$yd:000036B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000036B0
.text$yd:000036B0 ; =============== S U B R O U T I N E =======================================
.text$yd:000036B0
.text$yd:000036B0 ; Attributes: bp-based frame
.text$yd:000036B0
.text$yd:000036B0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000036B0 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000036B0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000036B0                 push    ebp
.text$yd:000036B1                 mov     ebp, esp
.text$yd:000036B3                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000036B8                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000036BD                 pop     ebp
.text$yd:000036BE                 retn
.text$yd:000036BE ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000036BE
.text$yd:000036BE ; ---------------------------------------------------------------------------
.text$yd:000036BF                 align 10h
.text$yd:000036BF _text$yd        ends
.text$yd:000036BF
.text$yd:000036C0 ; ===========================================================================
.text$yd:000036C0
.text$yd:000036C0 ; Segment type: Pure code
.text$yd:000036C0 ; Segment permissions: Read/Execute
.text$yd:000036C0 _text$yd        segment para public 'CODE' use32
.text$yd:000036C0                 assume cs:_text$yd
.text$yd:000036C0                 ;org 36C0h
.text$yd:000036C0 ; COMDAT (pick any)
.text$yd:000036C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000036C0
.text$yd:000036C0 ; =============== S U B R O U T I N E =======================================
.text$yd:000036C0
.text$yd:000036C0 ; Attributes: bp-based frame
.text$yd:000036C0
.text$yd:000036C0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000036C0 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000036C0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000036C0                 push    ebp
.text$yd:000036C1                 mov     ebp, esp
.text$yd:000036C3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000036C8                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000036CD                 pop     ebp
.text$yd:000036CE                 retn
.text$yd:000036CE ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000036CE
.text$yd:000036CE ; ---------------------------------------------------------------------------
.text$yd:000036CF                 align 10h
.text$yd:000036CF _text$yd        ends
.text$yd:000036CF
.text$mn:000036D0 ; ===========================================================================
.text$mn:000036D0
.text$mn:000036D0 ; Segment type: Pure code
.text$mn:000036D0 ; Segment permissions: Read/Execute
.text$mn:000036D0 _text$mn        segment para public 'CODE' use32
.text$mn:000036D0                 assume cs:_text$mn
.text$mn:000036D0                 ;org 36D0h
.text$mn:000036D0 ; COMDAT (pick any)
.text$mn:000036D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036D0
.text$mn:000036D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036D0
.text$mn:000036D0 ; Attributes: bp-based frame
.text$mn:000036D0
.text$mn:000036D0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000036D0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000036D0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000036D0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000036D0
.text$mn:000036D0 var_10          = byte ptr -10h
.text$mn:000036D0 var_8           = dword ptr -8
.text$mn:000036D0 var_1           = byte ptr -1
.text$mn:000036D0
.text$mn:000036D0                 push    ebp
.text$mn:000036D1                 mov     ebp, esp
.text$mn:000036D3                 sub     esp, 10h
.text$mn:000036D6                 mov     [ebp+var_8], ecx
.text$mn:000036D9                 lea     ecx, [ebp+var_1]
.text$mn:000036DC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000036E1                 push    1
.text$mn:000036E3                 lea     ecx, [ebp+var_1]
.text$mn:000036E6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000036EB                 mov     ecx, [ebp+var_8]
.text$mn:000036EE                 mov     [ecx], eax
.text$mn:000036F0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000036F3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000036F8                 push    eax             ; int
.text$mn:000036F9                 mov     edx, [ebp+var_8]
.text$mn:000036FC                 mov     eax, [edx]
.text$mn:000036FE                 push    eax             ; void *
.text$mn:000036FF                 lea     ecx, [ebp+var_1]
.text$mn:00003702                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003707                 mov     ecx, [ebp+var_8]
.text$mn:0000370A                 mov     edx, [ecx]
.text$mn:0000370C                 mov     eax, [ebp+var_8]
.text$mn:0000370F                 mov     [edx], eax
.text$mn:00003711                 mov     esp, ebp
.text$mn:00003713                 pop     ebp
.text$mn:00003714                 retn
.text$mn:00003714 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003714
.text$mn:00003714 ; ---------------------------------------------------------------------------
.text$mn:00003715                 align 4
.text$mn:00003715 _text$mn        ends
.text$mn:00003715
.text$mn:00003718 ; ===========================================================================
.text$mn:00003718
.text$mn:00003718 ; Segment type: Pure code
.text$mn:00003718 ; Segment permissions: Read/Execute
.text$mn:00003718 _text$mn        segment para public 'CODE' use32
.text$mn:00003718                 assume cs:_text$mn
.text$mn:00003718                 ;org 3718h
.text$mn:00003718 ; COMDAT (pick any)
.text$mn:00003718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003718
.text$mn:00003718 ; =============== S U B R O U T I N E =======================================
.text$mn:00003718
.text$mn:00003718 ; Attributes: bp-based frame
.text$mn:00003718
.text$mn:00003718 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00003718                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00003718 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003718                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00003718
.text$mn:00003718 var_10          = byte ptr -10h
.text$mn:00003718 var_8           = dword ptr -8
.text$mn:00003718 var_1           = byte ptr -1
.text$mn:00003718
.text$mn:00003718                 push    ebp
.text$mn:00003719                 mov     ebp, esp
.text$mn:0000371B                 sub     esp, 10h
.text$mn:0000371E                 mov     [ebp+var_8], ecx
.text$mn:00003721                 lea     ecx, [ebp+var_1]
.text$mn:00003724                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003729                 push    1
.text$mn:0000372B                 lea     ecx, [ebp+var_1]
.text$mn:0000372E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00003733                 mov     ecx, [ebp+var_8]
.text$mn:00003736                 mov     [ecx], eax
.text$mn:00003738                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000373B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003740                 push    eax             ; int
.text$mn:00003741                 mov     edx, [ebp+var_8]
.text$mn:00003744                 mov     eax, [edx]
.text$mn:00003746                 push    eax             ; void *
.text$mn:00003747                 lea     ecx, [ebp+var_1]
.text$mn:0000374A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000374F                 mov     ecx, [ebp+var_8]
.text$mn:00003752                 mov     edx, [ecx]
.text$mn:00003754                 mov     eax, [ebp+var_8]
.text$mn:00003757                 mov     [edx], eax
.text$mn:00003759                 mov     esp, ebp
.text$mn:0000375B                 pop     ebp
.text$mn:0000375C                 retn
.text$mn:0000375C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000375C
.text$mn:0000375C ; ---------------------------------------------------------------------------
.text$mn:0000375D                 align 10h
.text$mn:0000375D _text$mn        ends
.text$mn:0000375D
.text$mn:00003760 ; ===========================================================================
.text$mn:00003760
.text$mn:00003760 ; Segment type: Pure code
.text$mn:00003760 ; Segment permissions: Read/Execute
.text$mn:00003760 _text$mn        segment para public 'CODE' use32
.text$mn:00003760                 assume cs:_text$mn
.text$mn:00003760                 ;org 3760h
.text$mn:00003760 ; COMDAT (pick any)
.text$mn:00003760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003760
.text$mn:00003760 ; =============== S U B R O U T I N E =======================================
.text$mn:00003760
.text$mn:00003760 ; Attributes: bp-based frame
.text$mn:00003760
.text$mn:00003760 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>::_Alloc_proxy(void)
.text$mn:00003760                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ
.text$mn:00003760 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003760                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(std::allocator<SwitcherFileInfo> const &)+38p
.text$mn:00003760
.text$mn:00003760 var_10          = byte ptr -10h
.text$mn:00003760 var_8           = dword ptr -8
.text$mn:00003760 var_1           = byte ptr -1
.text$mn:00003760
.text$mn:00003760                 push    ebp
.text$mn:00003761                 mov     ebp, esp
.text$mn:00003763                 sub     esp, 10h
.text$mn:00003766                 mov     [ebp+var_8], ecx
.text$mn:00003769                 lea     ecx, [ebp+var_1]
.text$mn:0000376C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00003771                 push    1
.text$mn:00003773                 lea     ecx, [ebp+var_1]
.text$mn:00003776                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000377B                 mov     ecx, [ebp+var_8]
.text$mn:0000377E                 mov     [ecx], eax
.text$mn:00003780                 lea     ecx, [ebp+var_10] ; this
.text$mn:00003783                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003788                 push    eax             ; int
.text$mn:00003789                 mov     edx, [ebp+var_8]
.text$mn:0000378C                 mov     eax, [edx]
.text$mn:0000378E                 push    eax             ; void *
.text$mn:0000378F                 lea     ecx, [ebp+var_1]
.text$mn:00003792                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003797                 mov     ecx, [ebp+var_8]
.text$mn:0000379A                 mov     edx, [ecx]
.text$mn:0000379C                 mov     eax, [ebp+var_8]
.text$mn:0000379F                 mov     [edx], eax
.text$mn:000037A1                 mov     esp, ebp
.text$mn:000037A3                 pop     ebp
.text$mn:000037A4                 retn
.text$mn:000037A4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000037A4
.text$mn:000037A4 ; ---------------------------------------------------------------------------
.text$mn:000037A5                 align 4
.text$mn:000037A5 _text$mn        ends
.text$mn:000037A5
.text$mn:000037A8 ; ===========================================================================
.text$mn:000037A8
.text$mn:000037A8 ; Segment type: Pure code
.text$mn:000037A8 ; Segment permissions: Read/Execute
.text$mn:000037A8 _text$mn        segment para public 'CODE' use32
.text$mn:000037A8                 assume cs:_text$mn
.text$mn:000037A8                 ;org 37A8h
.text$mn:000037A8 ; COMDAT (pick any)
.text$mn:000037A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037A8
.text$mn:000037A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000037A8
.text$mn:000037A8 ; Attributes: bp-based frame
.text$mn:000037A8
.text$mn:000037A8 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>>::_Alloc_proxy(void)
.text$mn:000037A8                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ
.text$mn:000037A8 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000037A8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(std::allocator<TaskLstFnStatus> const &)+38p
.text$mn:000037A8
.text$mn:000037A8 var_10          = byte ptr -10h
.text$mn:000037A8 var_8           = dword ptr -8
.text$mn:000037A8 var_1           = byte ptr -1
.text$mn:000037A8
.text$mn:000037A8                 push    ebp
.text$mn:000037A9                 mov     ebp, esp
.text$mn:000037AB                 sub     esp, 10h
.text$mn:000037AE                 mov     [ebp+var_8], ecx
.text$mn:000037B1                 lea     ecx, [ebp+var_1]
.text$mn:000037B4                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000037B9                 push    1
.text$mn:000037BB                 lea     ecx, [ebp+var_1]
.text$mn:000037BE                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:000037C3                 mov     ecx, [ebp+var_8]
.text$mn:000037C6                 mov     [ecx], eax
.text$mn:000037C8                 lea     ecx, [ebp+var_10] ; this
.text$mn:000037CB                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000037D0                 push    eax             ; int
.text$mn:000037D1                 mov     edx, [ebp+var_8]
.text$mn:000037D4                 mov     eax, [edx]
.text$mn:000037D6                 push    eax             ; void *
.text$mn:000037D7                 lea     ecx, [ebp+var_1]
.text$mn:000037DA                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000037DF                 mov     ecx, [ebp+var_8]
.text$mn:000037E2                 mov     edx, [ecx]
.text$mn:000037E4                 mov     eax, [ebp+var_8]
.text$mn:000037E7                 mov     [edx], eax
.text$mn:000037E9                 mov     esp, ebp
.text$mn:000037EB                 pop     ebp
.text$mn:000037EC                 retn
.text$mn:000037EC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000037EC
.text$mn:000037EC ; ---------------------------------------------------------------------------
.text$mn:000037ED                 align 10h
.text$mn:000037ED _text$mn        ends
.text$mn:000037ED
.text$mn:000037F0 ; ===========================================================================
.text$mn:000037F0
.text$mn:000037F0 ; Segment type: Pure code
.text$mn:000037F0 ; Segment permissions: Read/Execute
.text$mn:000037F0 _text$mn        segment para public 'CODE' use32
.text$mn:000037F0                 assume cs:_text$mn
.text$mn:000037F0                 ;org 37F0h
.text$mn:000037F0 ; COMDAT (pick any)
.text$mn:000037F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037F0
.text$mn:000037F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037F0
.text$mn:000037F0 ; Attributes: bp-based frame
.text$mn:000037F0
.text$mn:000037F0 ; int __stdcall std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Assign_rv(struct std::_Container_base12 *, int)
.text$mn:000037F0                 public ?_Assign_rv@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
.text$mn:000037F0 ?_Assign_rv@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z proc near
.text$mn:000037F0                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&)+5Ep
.text$mn:000037F0
.text$mn:000037F0 var_4           = dword ptr -4
.text$mn:000037F0 arg_0           = dword ptr  8
.text$mn:000037F0
.text$mn:000037F0                 push    ebp
.text$mn:000037F1                 mov     ebp, esp
.text$mn:000037F3                 push    ecx
.text$mn:000037F4                 mov     [ebp+var_4], ecx
.text$mn:000037F7                 mov     eax, [ebp+arg_0]
.text$mn:000037FA                 push    eax             ; struct std::_Container_base12 *
.text$mn:000037FB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000037FE                 call    ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all(std::_Container_base12 &)
.text$mn:00003803                 mov     ecx, [ebp+var_4]
.text$mn:00003806                 mov     edx, [ebp+arg_0]
.text$mn:00003809                 mov     eax, [edx+4]
.text$mn:0000380C                 mov     [ecx+4], eax
.text$mn:0000380F                 mov     ecx, [ebp+var_4]
.text$mn:00003812                 mov     edx, [ebp+arg_0]
.text$mn:00003815                 mov     eax, [edx+8]
.text$mn:00003818                 mov     [ecx+8], eax
.text$mn:0000381B                 mov     ecx, [ebp+var_4]
.text$mn:0000381E                 mov     edx, [ebp+arg_0]
.text$mn:00003821                 mov     eax, [edx+0Ch]
.text$mn:00003824                 mov     [ecx+0Ch], eax
.text$mn:00003827                 mov     ecx, [ebp+arg_0]
.text$mn:0000382A                 mov     dword ptr [ecx+4], 0
.text$mn:00003831                 mov     edx, [ebp+arg_0]
.text$mn:00003834                 mov     dword ptr [edx+8], 0
.text$mn:0000383B                 mov     eax, [ebp+arg_0]
.text$mn:0000383E                 mov     dword ptr [eax+0Ch], 0
.text$mn:00003845                 mov     esp, ebp
.text$mn:00003847                 pop     ebp
.text$mn:00003848                 retn    8
.text$mn:00003848 ?_Assign_rv@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z endp
.text$mn:00003848
.text$mn:00003848 ; ---------------------------------------------------------------------------
.text$mn:0000384B                 align 4
.text$mn:0000384B _text$mn        ends
.text$mn:0000384B
.text$mn:0000384C ; ===========================================================================
.text$mn:0000384C
.text$mn:0000384C ; Segment type: Pure code
.text$mn:0000384C ; Segment permissions: Read/Execute
.text$mn:0000384C _text$mn        segment para public 'CODE' use32
.text$mn:0000384C                 assume cs:_text$mn
.text$mn:0000384C                 ;org 384Ch
.text$mn:0000384C ; COMDAT (pick any)
.text$mn:0000384C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000384C
.text$mn:0000384C ; =============== S U B R O U T I N E =======================================
.text$mn:0000384C
.text$mn:0000384C ; Attributes: bp-based frame
.text$mn:0000384C
.text$mn:0000384C ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:0000384C                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:0000384C ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000384C                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+80p
.text$mn:0000384C
.text$mn:0000384C var_4           = dword ptr -4
.text$mn:0000384C
.text$mn:0000384C                 push    ebp
.text$mn:0000384D                 mov     ebp, esp
.text$mn:0000384F                 push    ecx
.text$mn:00003850                 mov     [ebp+var_4], ecx
.text$mn:00003853                 mov     eax, [ebp+var_4]
.text$mn:00003856                 mov     dword ptr [eax], 0
.text$mn:0000385C                 mov     esp, ebp
.text$mn:0000385E                 pop     ebp
.text$mn:0000385F                 retn
.text$mn:0000385F ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000385F
.text$mn:0000385F _text$mn        ends
.text$mn:0000385F
.text$mn:00003860 ; ===========================================================================
.text$mn:00003860
.text$mn:00003860 ; Segment type: Pure code
.text$mn:00003860 ; Segment permissions: Read/Execute
.text$mn:00003860 _text$mn        segment para public 'CODE' use32
.text$mn:00003860                 assume cs:_text$mn
.text$mn:00003860                 ;org 3860h
.text$mn:00003860 ; COMDAT (pick any)
.text$mn:00003860                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003860
.text$mn:00003860 ; =============== S U B R O U T I N E =======================================
.text$mn:00003860
.text$mn:00003860 ; Attributes: bp-based frame
.text$mn:00003860
.text$mn:00003860 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00003860                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003860 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00003860                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00003860
.text$mn:00003860 var_20          = dword ptr -20h
.text$mn:00003860 var_1C          = dword ptr -1Ch
.text$mn:00003860 var_18          = dword ptr -18h
.text$mn:00003860 var_11          = byte ptr -11h
.text$mn:00003860 var_10          = dword ptr -10h
.text$mn:00003860 var_C           = byte ptr -0Ch
.text$mn:00003860 var_4           = dword ptr -4
.text$mn:00003860 arg_0           = dword ptr  8
.text$mn:00003860
.text$mn:00003860 ; FUNCTION CHUNK AT .text$mn:00003982 SIZE 00000009 BYTES
.text$mn:00003860
.text$mn:00003860                 push    ebp
.text$mn:00003861                 mov     ebp, esp
.text$mn:00003863                 push    0FFFFFFFFh
.text$mn:00003865                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000386A                 mov     eax, large fs:0
.text$mn:00003870                 push    eax
.text$mn:00003871                 push    ecx
.text$mn:00003872                 sub     esp, 10h
.text$mn:00003875                 push    ebx
.text$mn:00003876                 push    esi
.text$mn:00003877                 push    edi
.text$mn:00003878                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000387D                 xor     eax, ebp
.text$mn:0000387F                 push    eax
.text$mn:00003880                 lea     eax, [ebp+var_C]
.text$mn:00003883                 mov     large fs:0, eax
.text$mn:00003889                 mov     [ebp+var_10], esp
.text$mn:0000388C                 mov     [ebp+var_18], ecx
.text$mn:0000388F                 mov     eax, [ebp+arg_0]
.text$mn:00003892                 or      eax, 0Fh
.text$mn:00003895                 mov     [ebp+var_1C], eax
.text$mn:00003898                 mov     ecx, [ebp+var_18]
.text$mn:0000389B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000038A0                 cmp     eax, [ebp+var_1C]
.text$mn:000038A3                 jnb     short loc_38AD
.text$mn:000038A5                 mov     ecx, [ebp+arg_0]
.text$mn:000038A8                 mov     [ebp+var_1C], ecx
.text$mn:000038AB                 jmp     short loc_38FF
.text$mn:000038AD ; ---------------------------------------------------------------------------
.text$mn:000038AD
.text$mn:000038AD loc_38AD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000038AD                 mov     edx, [ebp+var_18]
.text$mn:000038B0                 mov     ecx, [edx+18h]
.text$mn:000038B3                 shr     ecx, 1
.text$mn:000038B5                 mov     eax, [ebp+var_1C]
.text$mn:000038B8                 xor     edx, edx
.text$mn:000038BA                 mov     esi, 3
.text$mn:000038BF                 div     esi
.text$mn:000038C1                 cmp     ecx, eax
.text$mn:000038C3                 ja      short loc_38C7
.text$mn:000038C5                 jmp     short loc_38FF
.text$mn:000038C7 ; ---------------------------------------------------------------------------
.text$mn:000038C7
.text$mn:000038C7 loc_38C7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000038C7                 mov     ecx, [ebp+var_18]
.text$mn:000038CA                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000038CF                 mov     edx, [ebp+var_18]
.text$mn:000038D2                 mov     ecx, [edx+18h]
.text$mn:000038D5                 shr     ecx, 1
.text$mn:000038D7                 sub     eax, ecx
.text$mn:000038D9                 mov     edx, [ebp+var_18]
.text$mn:000038DC                 cmp     [edx+18h], eax
.text$mn:000038DF                 ja      short loc_38F4
.text$mn:000038E1                 mov     eax, [ebp+var_18]
.text$mn:000038E4                 mov     ecx, [eax+18h]
.text$mn:000038E7                 shr     ecx, 1
.text$mn:000038E9                 mov     edx, [ebp+var_18]
.text$mn:000038EC                 add     ecx, [edx+18h]
.text$mn:000038EF                 mov     [ebp+var_1C], ecx
.text$mn:000038F2                 jmp     short loc_38FF
.text$mn:000038F4 ; ---------------------------------------------------------------------------
.text$mn:000038F4
.text$mn:000038F4 loc_38F4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000038F4                 mov     ecx, [ebp+var_18]
.text$mn:000038F7                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000038FC                 mov     [ebp+var_1C], eax
.text$mn:000038FF
.text$mn:000038FF loc_38FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000038FF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000038FF                 mov     [ebp+var_4], 0
.text$mn:00003906                 mov     eax, [ebp+var_1C]
.text$mn:00003909                 add     eax, 1
.text$mn:0000390C                 push    eax
.text$mn:0000390D                 lea     ecx, [ebp+var_11]
.text$mn:00003910                 push    ecx
.text$mn:00003911                 mov     ecx, [ebp+var_18]
.text$mn:00003914                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003919                 mov     ecx, eax
.text$mn:0000391B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003920                 mov     [ebp+var_20], eax
.text$mn:00003923                 jmp     short loc_3982
.text$mn:00003923 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00003923
.text$mn:00003925
.text$mn:00003925 ; =============== S U B R O U T I N E =======================================
.text$mn:00003925
.text$mn:00003925
.text$mn:00003925 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00003925                                         ; DATA XREF: .xdata$x:000059F8o
.text$mn:00003925
.text$mn:00003925 ; FUNCTION CHUNK AT .text$mn:0000396C SIZE 00000009 BYTES
.text$mn:00003925 ; FUNCTION CHUNK AT .text$mn:0000397C SIZE 00000006 BYTES
.text$mn:00003925
.text$mn:00003925                 mov     [ebp-10h], esp
.text$mn:00003928                 mov     edx, [ebp+8]
.text$mn:0000392B                 mov     [ebp-1Ch], edx
.text$mn:0000392E                 mov     byte ptr [ebp-4], 2
.text$mn:00003932                 mov     eax, [ebp-1Ch]
.text$mn:00003935                 add     eax, 1
.text$mn:00003938                 push    eax
.text$mn:00003939                 lea     ecx, [ebp-12h]
.text$mn:0000393C                 push    ecx
.text$mn:0000393D                 mov     ecx, [ebp-18h]
.text$mn:00003940                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003945                 mov     ecx, eax
.text$mn:00003947                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000394C                 mov     [ebp-20h], eax
.text$mn:0000394F                 jmp     short loc_396C
.text$mn:0000394F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000394F
.text$mn:00003951
.text$mn:00003951 ; =============== S U B R O U T I N E =======================================
.text$mn:00003951
.text$mn:00003951 ; Attributes: noreturn
.text$mn:00003951
.text$mn:00003951 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00003951                                         ; DATA XREF: .xdata$x:00005A08o
.text$mn:00003951                 push    0               ; Size
.text$mn:00003953                 push    1               ; char
.text$mn:00003955                 mov     ecx, [ebp-18h]
.text$mn:00003958                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000395D                 push    0
.text$mn:0000395F                 push    0
.text$mn:00003961                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003961 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00003961
.text$mn:00003966 ; ---------------------------------------------------------------------------
.text$mn:00003966                 mov     eax, offset $LN17
.text$mn:0000396B                 retn
.text$mn:0000396C ; ---------------------------------------------------------------------------
.text$mn:0000396C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000396C
.text$mn:0000396C loc_396C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000396C                 mov     dword ptr [ebp-4], 1
.text$mn:00003973                 jmp     short loc_397C
.text$mn:00003973 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003975
.text$mn:00003975 ; =============== S U B R O U T I N E =======================================
.text$mn:00003975
.text$mn:00003975
.text$mn:00003975 $LN17           proc near               ; DATA XREF: .text$mn:00003966o
.text$mn:00003975                 mov     dword ptr [ebp-4], 1
.text$mn:00003975 $LN17           endp ; sp-analysis failed
.text$mn:00003975
.text$mn:0000397C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000397C
.text$mn:0000397C loc_397C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000397C                 mov     eax, offset $LN19
.text$mn:00003981                 retn
.text$mn:00003981 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003982 ; ---------------------------------------------------------------------------
.text$mn:00003982 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003982
.text$mn:00003982 loc_3982:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00003982                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003989                 jmp     short loc_3992
.text$mn:00003989 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000398B
.text$mn:0000398B ; =============== S U B R O U T I N E =======================================
.text$mn:0000398B
.text$mn:0000398B
.text$mn:0000398B $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_397Co
.text$mn:0000398B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003992
.text$mn:00003992 loc_3992:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00003992                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00003996                 jbe     short loc_39B1
.text$mn:00003998                 mov     edx, [ebp+0Ch]
.text$mn:0000399B                 push    edx             ; Size
.text$mn:0000399C                 mov     ecx, [ebp-18h]
.text$mn:0000399F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000039A4                 push    eax             ; Src
.text$mn:000039A5                 mov     eax, [ebp-20h]
.text$mn:000039A8                 push    eax             ; Dst
.text$mn:000039A9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000039AE                 add     esp, 0Ch
.text$mn:000039B1
.text$mn:000039B1 loc_39B1:                               ; CODE XREF: $LN19+Bj
.text$mn:000039B1                 push    0               ; Size
.text$mn:000039B3                 push    1               ; char
.text$mn:000039B5                 mov     ecx, [ebp-18h]
.text$mn:000039B8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000039BD                 lea     ecx, [ebp-20h]
.text$mn:000039C0                 push    ecx             ; int
.text$mn:000039C1                 mov     edx, [ebp-18h]
.text$mn:000039C4                 add     edx, 4
.text$mn:000039C7                 push    edx             ; void *
.text$mn:000039C8                 lea     eax, [ebp-13h]
.text$mn:000039CB                 push    eax
.text$mn:000039CC                 mov     ecx, [ebp-18h]
.text$mn:000039CF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000039D4                 mov     ecx, eax
.text$mn:000039D6                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000039DB                 mov     ecx, [ebp-18h]
.text$mn:000039DE                 mov     edx, [ebp-1Ch]
.text$mn:000039E1                 mov     [ecx+18h], edx
.text$mn:000039E4                 mov     eax, [ebp+0Ch]
.text$mn:000039E7                 push    eax
.text$mn:000039E8                 mov     ecx, [ebp-18h]
.text$mn:000039EB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000039F0                 mov     ecx, [ebp-0Ch]
.text$mn:000039F3                 mov     large fs:0, ecx
.text$mn:000039FA                 pop     ecx
.text$mn:000039FB                 pop     edi
.text$mn:000039FC                 pop     esi
.text$mn:000039FD                 pop     ebx
.text$mn:000039FE                 mov     esp, ebp
.text$mn:00003A00                 pop     ebp
.text$mn:00003A01                 retn    8
.text$mn:00003A01 $LN19           endp ; sp-analysis failed
.text$mn:00003A01
.text$mn:00003A01 _text$mn        ends
.text$mn:00003A01
.text$x:00003A04 ; ===========================================================================
.text$x:00003A04
.text$x:00003A04 ; Segment type: Pure code
.text$x:00003A04 ; Segment permissions: Read/Execute
.text$x:00003A04 _text$x         segment para public 'CODE' use32
.text$x:00003A04                 assume cs:_text$x
.text$x:00003A04                 ;org 3A04h
.text$x:00003A04 ; COMDAT (pick associative to section at 3860)
.text$x:00003A04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003A04
.text$x:00003A04 ; =============== S U B R O U T I N E =======================================
.text$x:00003A04
.text$x:00003A04
.text$x:00003A04 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00003A04                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00003A04
.text$x:00003A04 arg_4           = dword ptr  8
.text$x:00003A04
.text$x:00003A04                 mov     edx, [esp+arg_4]
.text$x:00003A08                 lea     eax, [edx+0Ch]
.text$x:00003A0B                 mov     ecx, [edx-24h]
.text$x:00003A0E                 xor     ecx, eax
.text$x:00003A10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A15                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00003A1A                 jmp     ___CxxFrameHandler3
.text$x:00003A1A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00003A1A
.text$x:00003A1A ; ---------------------------------------------------------------------------
.text$x:00003A1F                 align 10h
.text$x:00003A1F _text$x         ends
.text$x:00003A1F
.text$mn:00003A20 ; ===========================================================================
.text$mn:00003A20
.text$mn:00003A20 ; Segment type: Pure code
.text$mn:00003A20 ; Segment permissions: Read/Execute
.text$mn:00003A20 _text$mn        segment para public 'CODE' use32
.text$mn:00003A20                 assume cs:_text$mn
.text$mn:00003A20                 ;org 3A20h
.text$mn:00003A20 ; COMDAT (pick any)
.text$mn:00003A20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A20
.text$mn:00003A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A20
.text$mn:00003A20 ; Attributes: bp-based frame
.text$mn:00003A20
.text$mn:00003A20 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00003A20                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003A20 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00003A20                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00003A20
.text$mn:00003A20 var_20          = dword ptr -20h
.text$mn:00003A20 var_1C          = dword ptr -1Ch
.text$mn:00003A20 var_18          = dword ptr -18h
.text$mn:00003A20 var_11          = byte ptr -11h
.text$mn:00003A20 var_10          = dword ptr -10h
.text$mn:00003A20 var_C           = byte ptr -0Ch
.text$mn:00003A20 var_4           = dword ptr -4
.text$mn:00003A20 arg_0           = dword ptr  8
.text$mn:00003A20
.text$mn:00003A20 ; FUNCTION CHUNK AT .text$mn:00003B42 SIZE 00000009 BYTES
.text$mn:00003A20
.text$mn:00003A20                 push    ebp
.text$mn:00003A21                 mov     ebp, esp
.text$mn:00003A23                 push    0FFFFFFFFh
.text$mn:00003A25                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003A2A                 mov     eax, large fs:0
.text$mn:00003A30                 push    eax
.text$mn:00003A31                 push    ecx
.text$mn:00003A32                 sub     esp, 10h
.text$mn:00003A35                 push    ebx
.text$mn:00003A36                 push    esi
.text$mn:00003A37                 push    edi
.text$mn:00003A38                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A3D                 xor     eax, ebp
.text$mn:00003A3F                 push    eax
.text$mn:00003A40                 lea     eax, [ebp+var_C]
.text$mn:00003A43                 mov     large fs:0, eax
.text$mn:00003A49                 mov     [ebp+var_10], esp
.text$mn:00003A4C                 mov     [ebp+var_18], ecx
.text$mn:00003A4F                 mov     eax, [ebp+arg_0]
.text$mn:00003A52                 or      eax, 7
.text$mn:00003A55                 mov     [ebp+var_1C], eax
.text$mn:00003A58                 mov     ecx, [ebp+var_18]
.text$mn:00003A5B                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00003A60                 cmp     eax, [ebp+var_1C]
.text$mn:00003A63                 jnb     short loc_3A6D
.text$mn:00003A65                 mov     ecx, [ebp+arg_0]
.text$mn:00003A68                 mov     [ebp+var_1C], ecx
.text$mn:00003A6B                 jmp     short loc_3ABF
.text$mn:00003A6D ; ---------------------------------------------------------------------------
.text$mn:00003A6D
.text$mn:00003A6D loc_3A6D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00003A6D                 mov     edx, [ebp+var_18]
.text$mn:00003A70                 mov     ecx, [edx+18h]
.text$mn:00003A73                 shr     ecx, 1
.text$mn:00003A75                 mov     eax, [ebp+var_1C]
.text$mn:00003A78                 xor     edx, edx
.text$mn:00003A7A                 mov     esi, 3
.text$mn:00003A7F                 div     esi
.text$mn:00003A81                 cmp     ecx, eax
.text$mn:00003A83                 ja      short loc_3A87
.text$mn:00003A85                 jmp     short loc_3ABF
.text$mn:00003A87 ; ---------------------------------------------------------------------------
.text$mn:00003A87
.text$mn:00003A87 loc_3A87:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00003A87                 mov     ecx, [ebp+var_18]
.text$mn:00003A8A                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00003A8F                 mov     edx, [ebp+var_18]
.text$mn:00003A92                 mov     ecx, [edx+18h]
.text$mn:00003A95                 shr     ecx, 1
.text$mn:00003A97                 sub     eax, ecx
.text$mn:00003A99                 mov     edx, [ebp+var_18]
.text$mn:00003A9C                 cmp     [edx+18h], eax
.text$mn:00003A9F                 ja      short loc_3AB4
.text$mn:00003AA1                 mov     eax, [ebp+var_18]
.text$mn:00003AA4                 mov     ecx, [eax+18h]
.text$mn:00003AA7                 shr     ecx, 1
.text$mn:00003AA9                 mov     edx, [ebp+var_18]
.text$mn:00003AAC                 add     ecx, [edx+18h]
.text$mn:00003AAF                 mov     [ebp+var_1C], ecx
.text$mn:00003AB2                 jmp     short loc_3ABF
.text$mn:00003AB4 ; ---------------------------------------------------------------------------
.text$mn:00003AB4
.text$mn:00003AB4 loc_3AB4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00003AB4                 mov     ecx, [ebp+var_18]
.text$mn:00003AB7                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00003ABC                 mov     [ebp+var_1C], eax
.text$mn:00003ABF
.text$mn:00003ABF loc_3ABF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00003ABF                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00003ABF                 mov     [ebp+var_4], 0
.text$mn:00003AC6                 mov     eax, [ebp+var_1C]
.text$mn:00003AC9                 add     eax, 1
.text$mn:00003ACC                 push    eax
.text$mn:00003ACD                 lea     ecx, [ebp+var_11]
.text$mn:00003AD0                 push    ecx
.text$mn:00003AD1                 mov     ecx, [ebp+var_18]
.text$mn:00003AD4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003AD9                 mov     ecx, eax
.text$mn:00003ADB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00003AE0                 mov     [ebp+var_20], eax
.text$mn:00003AE3                 jmp     short loc_3B42
.text$mn:00003AE3 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00003AE3
.text$mn:00003AE5
.text$mn:00003AE5 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AE5
.text$mn:00003AE5
.text$mn:00003AE5 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00003AE5                                         ; DATA XREF: .xdata$x:00005DC8o
.text$mn:00003AE5
.text$mn:00003AE5 ; FUNCTION CHUNK AT .text$mn:00003B2C SIZE 00000009 BYTES
.text$mn:00003AE5 ; FUNCTION CHUNK AT .text$mn:00003B3C SIZE 00000006 BYTES
.text$mn:00003AE5
.text$mn:00003AE5                 mov     [ebp-10h], esp
.text$mn:00003AE8                 mov     edx, [ebp+8]
.text$mn:00003AEB                 mov     [ebp-1Ch], edx
.text$mn:00003AEE                 mov     byte ptr [ebp-4], 2
.text$mn:00003AF2                 mov     eax, [ebp-1Ch]
.text$mn:00003AF5                 add     eax, 1
.text$mn:00003AF8                 push    eax
.text$mn:00003AF9                 lea     ecx, [ebp-12h]
.text$mn:00003AFC                 push    ecx
.text$mn:00003AFD                 mov     ecx, [ebp-18h]
.text$mn:00003B00                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003B05                 mov     ecx, eax
.text$mn:00003B07                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00003B0C                 mov     [ebp-20h], eax
.text$mn:00003B0F                 jmp     short loc_3B2C
.text$mn:00003B0F __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00003B0F
.text$mn:00003B11
.text$mn:00003B11 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B11
.text$mn:00003B11 ; Attributes: noreturn
.text$mn:00003B11
.text$mn:00003B11 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00003B11                                         ; DATA XREF: .xdata$x:00005DD8o
.text$mn:00003B11                 push    0
.text$mn:00003B13                 push    1
.text$mn:00003B15                 mov     ecx, [ebp-18h]
.text$mn:00003B18                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003B1D                 push    0
.text$mn:00003B1F                 push    0
.text$mn:00003B21                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003B21 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00003B21
.text$mn:00003B26 ; ---------------------------------------------------------------------------
.text$mn:00003B26                 mov     eax, offset $LN17_0
.text$mn:00003B2B                 retn
.text$mn:00003B2C ; ---------------------------------------------------------------------------
.text$mn:00003B2C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003B2C
.text$mn:00003B2C loc_3B2C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00003B2C                 mov     dword ptr [ebp-4], 1
.text$mn:00003B33                 jmp     short loc_3B3C
.text$mn:00003B33 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003B35
.text$mn:00003B35 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B35
.text$mn:00003B35
.text$mn:00003B35 $LN17_0         proc near               ; DATA XREF: .text$mn:00003B26o
.text$mn:00003B35                 mov     dword ptr [ebp-4], 1
.text$mn:00003B35 $LN17_0         endp ; sp-analysis failed
.text$mn:00003B35
.text$mn:00003B3C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003B3C
.text$mn:00003B3C loc_3B3C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00003B3C                 mov     eax, offset $LN19_0
.text$mn:00003B41                 retn
.text$mn:00003B41 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00003B42 ; ---------------------------------------------------------------------------
.text$mn:00003B42 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003B42
.text$mn:00003B42 loc_3B42:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00003B42                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B49                 jmp     short loc_3B52
.text$mn:00003B49 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00003B4B
.text$mn:00003B4B ; =============== S U B R O U T I N E =======================================
.text$mn:00003B4B
.text$mn:00003B4B
.text$mn:00003B4B $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_3B3Co
.text$mn:00003B4B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003B52
.text$mn:00003B52 loc_3B52:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00003B52                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00003B56                 jbe     short loc_3B71
.text$mn:00003B58                 mov     edx, [ebp+0Ch]
.text$mn:00003B5B                 push    edx             ; int
.text$mn:00003B5C                 mov     ecx, [ebp-18h]
.text$mn:00003B5F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003B64                 push    eax             ; Src
.text$mn:00003B65                 mov     eax, [ebp-20h]
.text$mn:00003B68                 push    eax             ; Dst
.text$mn:00003B69                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00003B6E                 add     esp, 0Ch
.text$mn:00003B71
.text$mn:00003B71 loc_3B71:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00003B71                 push    0
.text$mn:00003B73                 push    1
.text$mn:00003B75                 mov     ecx, [ebp-18h]
.text$mn:00003B78                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003B7D                 lea     ecx, [ebp-20h]
.text$mn:00003B80                 push    ecx             ; int
.text$mn:00003B81                 mov     edx, [ebp-18h]
.text$mn:00003B84                 add     edx, 4
.text$mn:00003B87                 push    edx             ; void *
.text$mn:00003B88                 lea     eax, [ebp-13h]
.text$mn:00003B8B                 push    eax
.text$mn:00003B8C                 mov     ecx, [ebp-18h]
.text$mn:00003B8F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003B94                 mov     ecx, eax
.text$mn:00003B96                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00003B9B                 mov     ecx, [ebp-18h]
.text$mn:00003B9E                 mov     edx, [ebp-1Ch]
.text$mn:00003BA1                 mov     [ecx+18h], edx
.text$mn:00003BA4                 mov     eax, [ebp+0Ch]
.text$mn:00003BA7                 push    eax
.text$mn:00003BA8                 mov     ecx, [ebp-18h]
.text$mn:00003BAB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003BB0                 mov     ecx, [ebp-0Ch]
.text$mn:00003BB3                 mov     large fs:0, ecx
.text$mn:00003BBA                 pop     ecx
.text$mn:00003BBB                 pop     edi
.text$mn:00003BBC                 pop     esi
.text$mn:00003BBD                 pop     ebx
.text$mn:00003BBE                 mov     esp, ebp
.text$mn:00003BC0                 pop     ebp
.text$mn:00003BC1                 retn    8
.text$mn:00003BC1 $LN19_0         endp ; sp-analysis failed
.text$mn:00003BC1
.text$mn:00003BC1 _text$mn        ends
.text$mn:00003BC1
.text$x:00003BC4 ; ===========================================================================
.text$x:00003BC4
.text$x:00003BC4 ; Segment type: Pure code
.text$x:00003BC4 ; Segment permissions: Read/Execute
.text$x:00003BC4 _text$x         segment para public 'CODE' use32
.text$x:00003BC4                 assume cs:_text$x
.text$x:00003BC4                 ;org 3BC4h
.text$x:00003BC4 ; COMDAT (pick associative to section at 3A20)
.text$x:00003BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BC4
.text$x:00003BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BC4
.text$x:00003BC4
.text$x:00003BC4 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00003BC4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00003BC4
.text$x:00003BC4 arg_4           = dword ptr  8
.text$x:00003BC4
.text$x:00003BC4                 mov     edx, [esp+arg_4]
.text$x:00003BC8                 lea     eax, [edx+0Ch]
.text$x:00003BCB                 mov     ecx, [edx-24h]
.text$x:00003BCE                 xor     ecx, eax
.text$x:00003BD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BD5                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00003BDA                 jmp     ___CxxFrameHandler3
.text$x:00003BDA __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00003BDA
.text$x:00003BDA ; ---------------------------------------------------------------------------
.text$x:00003BDF                 align 10h
.text$x:00003BDF _text$x         ends
.text$x:00003BDF
.text$mn:00003BE0 ; ===========================================================================
.text$mn:00003BE0
.text$mn:00003BE0 ; Segment type: Pure code
.text$mn:00003BE0 ; Segment permissions: Read/Execute
.text$mn:00003BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00003BE0                 assume cs:_text$mn
.text$mn:00003BE0                 ;org 3BE0h
.text$mn:00003BE0 ; COMDAT (pick any)
.text$mn:00003BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BE0
.text$mn:00003BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BE0
.text$mn:00003BE0 ; Attributes: bp-based frame
.text$mn:00003BE0
.text$mn:00003BE0 ; protected: void __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Destroy(struct SwitcherFileInfo *, struct SwitcherFileInfo *)
.text$mn:00003BE0                 public ?_Destroy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXPAUSwitcherFileInfo@@0@Z
.text$mn:00003BE0 ?_Destroy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXPAUSwitcherFileInfo@@0@Z proc near
.text$mn:00003BE0                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+CBp
.text$mn:00003BE0                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Tidy(void)+2Bp
.text$mn:00003BE0
.text$mn:00003BE0 var_8           = dword ptr -8
.text$mn:00003BE0 var_1           = byte ptr -1
.text$mn:00003BE0 arg_0           = dword ptr  8
.text$mn:00003BE0 arg_4           = dword ptr  0Ch
.text$mn:00003BE0
.text$mn:00003BE0                 push    ebp
.text$mn:00003BE1                 mov     ebp, esp
.text$mn:00003BE3                 sub     esp, 8
.text$mn:00003BE6                 mov     [ebp+var_8], ecx
.text$mn:00003BE9                 lea     eax, [ebp+var_1]
.text$mn:00003BEC                 push    eax
.text$mn:00003BED                 mov     ecx, [ebp+var_8]
.text$mn:00003BF0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:00003BF5                 lea     ecx, [ebp+var_1]
.text$mn:00003BF8                 push    ecx
.text$mn:00003BF9                 mov     edx, [ebp+arg_4]
.text$mn:00003BFC                 push    edx
.text$mn:00003BFD                 mov     eax, [ebp+arg_0]
.text$mn:00003C00                 push    eax
.text$mn:00003C01                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@YAXPAUSwitcherFileInfo@@0AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>>(SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &)
.text$mn:00003C06                 add     esp, 0Ch
.text$mn:00003C09                 mov     esp, ebp
.text$mn:00003C0B                 pop     ebp
.text$mn:00003C0C                 retn    8
.text$mn:00003C0C ?_Destroy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXPAUSwitcherFileInfo@@0@Z endp
.text$mn:00003C0C
.text$mn:00003C0C ; ---------------------------------------------------------------------------
.text$mn:00003C0F                 align 10h
.text$mn:00003C0F _text$mn        ends
.text$mn:00003C0F
.text$mn:00003C10 ; ===========================================================================
.text$mn:00003C10
.text$mn:00003C10 ; Segment type: Pure code
.text$mn:00003C10 ; Segment permissions: Read/Execute
.text$mn:00003C10 _text$mn        segment para public 'CODE' use32
.text$mn:00003C10                 assume cs:_text$mn
.text$mn:00003C10                 ;org 3C10h
.text$mn:00003C10 ; COMDAT (pick any)
.text$mn:00003C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C10
.text$mn:00003C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C10
.text$mn:00003C10 ; Attributes: bp-based frame
.text$mn:00003C10
.text$mn:00003C10 ; protected: void __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::_Destroy(struct TaskLstFnStatus *, struct TaskLstFnStatus *)
.text$mn:00003C10                 public ?_Destroy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXPAUTaskLstFnStatus@@0@Z
.text$mn:00003C10 ?_Destroy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXPAUTaskLstFnStatus@@0@Z proc near
.text$mn:00003C10                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Tidy(void)+2Bp
.text$mn:00003C10
.text$mn:00003C10 var_8           = dword ptr -8
.text$mn:00003C10 var_1           = byte ptr -1
.text$mn:00003C10 arg_0           = dword ptr  8
.text$mn:00003C10 arg_4           = dword ptr  0Ch
.text$mn:00003C10
.text$mn:00003C10                 push    ebp
.text$mn:00003C11                 mov     ebp, esp
.text$mn:00003C13                 sub     esp, 8
.text$mn:00003C16                 mov     [ebp+var_8], ecx
.text$mn:00003C19                 lea     eax, [ebp+var_1]
.text$mn:00003C1C                 push    eax
.text$mn:00003C1D                 mov     ecx, [ebp+var_8]
.text$mn:00003C20                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Getal(void)
.text$mn:00003C25                 lea     ecx, [ebp+var_1]
.text$mn:00003C28                 push    ecx
.text$mn:00003C29                 mov     edx, [ebp+arg_4]
.text$mn:00003C2C                 push    edx
.text$mn:00003C2D                 mov     eax, [ebp+arg_0]
.text$mn:00003C30                 push    eax
.text$mn:00003C31                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@YAXPAUTaskLstFnStatus@@0AAU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>>(TaskLstFnStatus *,TaskLstFnStatus *,std::_Wrap_alloc<std::allocator<TaskLstFnStatus>> &)
.text$mn:00003C36                 add     esp, 0Ch
.text$mn:00003C39                 mov     esp, ebp
.text$mn:00003C3B                 pop     ebp
.text$mn:00003C3C                 retn    8
.text$mn:00003C3C ?_Destroy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXPAUTaskLstFnStatus@@0@Z endp
.text$mn:00003C3C
.text$mn:00003C3C ; ---------------------------------------------------------------------------
.text$mn:00003C3F                 align 10h
.text$mn:00003C3F _text$mn        ends
.text$mn:00003C3F
.text$mn:00003C40 ; ===========================================================================
.text$mn:00003C40
.text$mn:00003C40 ; Segment type: Pure code
.text$mn:00003C40 ; Segment permissions: Read/Execute
.text$mn:00003C40 _text$mn        segment para public 'CODE' use32
.text$mn:00003C40                 assume cs:_text$mn
.text$mn:00003C40                 ;org 3C40h
.text$mn:00003C40 ; COMDAT (pick any)
.text$mn:00003C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C40
.text$mn:00003C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C40
.text$mn:00003C40 ; Attributes: bp-based frame
.text$mn:00003C40
.text$mn:00003C40 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00003C40                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00003C40 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00003C40                                         ; CODE XREF: $LN19+60p
.text$mn:00003C40                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00003C40
.text$mn:00003C40 var_8           = dword ptr -8
.text$mn:00003C40 var_1           = byte ptr -1
.text$mn:00003C40 arg_0           = dword ptr  8
.text$mn:00003C40
.text$mn:00003C40                 push    ebp
.text$mn:00003C41                 mov     ebp, esp
.text$mn:00003C43                 sub     esp, 8
.text$mn:00003C46                 mov     [ebp+var_8], ecx
.text$mn:00003C49                 mov     [ebp+var_1], 0
.text$mn:00003C4D                 mov     eax, [ebp+var_8]
.text$mn:00003C50                 mov     ecx, [ebp+arg_0]
.text$mn:00003C53                 mov     [eax+14h], ecx
.text$mn:00003C56                 lea     edx, [ebp+var_1]
.text$mn:00003C59                 push    edx
.text$mn:00003C5A                 mov     ecx, [ebp+var_8]
.text$mn:00003C5D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003C62                 add     eax, [ebp+arg_0]
.text$mn:00003C65                 push    eax
.text$mn:00003C66                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00003C6B                 add     esp, 8
.text$mn:00003C6E                 mov     esp, ebp
.text$mn:00003C70                 pop     ebp
.text$mn:00003C71                 retn    4
.text$mn:00003C71 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00003C71
.text$mn:00003C71 _text$mn        ends
.text$mn:00003C71
.text$mn:00003C74 ; ===========================================================================
.text$mn:00003C74
.text$mn:00003C74 ; Segment type: Pure code
.text$mn:00003C74 ; Segment permissions: Read/Execute
.text$mn:00003C74 _text$mn        segment para public 'CODE' use32
.text$mn:00003C74                 assume cs:_text$mn
.text$mn:00003C74                 ;org 3C74h
.text$mn:00003C74 ; COMDAT (pick any)
.text$mn:00003C74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C74
.text$mn:00003C74 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C74
.text$mn:00003C74 ; Attributes: bp-based frame
.text$mn:00003C74
.text$mn:00003C74 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00003C74                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00003C74 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00003C74                                         ; CODE XREF: $LN19_0+60p
.text$mn:00003C74                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00003C74
.text$mn:00003C74 var_8           = dword ptr -8
.text$mn:00003C74 var_2           = word ptr -2
.text$mn:00003C74 arg_0           = dword ptr  8
.text$mn:00003C74
.text$mn:00003C74                 push    ebp
.text$mn:00003C75                 mov     ebp, esp
.text$mn:00003C77                 sub     esp, 8
.text$mn:00003C7A                 mov     [ebp+var_8], ecx
.text$mn:00003C7D                 xor     eax, eax
.text$mn:00003C7F                 mov     [ebp+var_2], ax
.text$mn:00003C83                 mov     ecx, [ebp+var_8]
.text$mn:00003C86                 mov     edx, [ebp+arg_0]
.text$mn:00003C89                 mov     [ecx+14h], edx
.text$mn:00003C8C                 lea     eax, [ebp+var_2]
.text$mn:00003C8F                 push    eax
.text$mn:00003C90                 mov     ecx, [ebp+var_8]
.text$mn:00003C93                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003C98                 mov     ecx, [ebp+arg_0]
.text$mn:00003C9B                 lea     edx, [eax+ecx*2]
.text$mn:00003C9E                 push    edx
.text$mn:00003C9F                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00003CA4                 add     esp, 8
.text$mn:00003CA7                 mov     esp, ebp
.text$mn:00003CA9                 pop     ebp
.text$mn:00003CAA                 retn    4
.text$mn:00003CAA ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00003CAA
.text$mn:00003CAA ; ---------------------------------------------------------------------------
.text$mn:00003CAD                 align 10h
.text$mn:00003CAD _text$mn        ends
.text$mn:00003CAD
.text$mn:00003CB0 ; ===========================================================================
.text$mn:00003CB0
.text$mn:00003CB0 ; Segment type: Pure code
.text$mn:00003CB0 ; Segment permissions: Read/Execute
.text$mn:00003CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CB0                 assume cs:_text$mn
.text$mn:00003CB0                 ;org 3CB0h
.text$mn:00003CB0 ; COMDAT (pick any)
.text$mn:00003CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CB0
.text$mn:00003CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CB0
.text$mn:00003CB0 ; Attributes: bp-based frame
.text$mn:00003CB0
.text$mn:00003CB0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003CB0                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00003CB0 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003CB0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00003CB0
.text$mn:00003CB0 var_8           = dword ptr -8
.text$mn:00003CB0 var_1           = byte ptr -1
.text$mn:00003CB0
.text$mn:00003CB0                 push    ebp
.text$mn:00003CB1                 mov     ebp, esp
.text$mn:00003CB3                 sub     esp, 8
.text$mn:00003CB6                 mov     [ebp+var_8], ecx
.text$mn:00003CB9                 lea     ecx, [ebp+var_1]
.text$mn:00003CBC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003CC1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003CC4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003CC9                 mov     eax, [ebp+var_8]
.text$mn:00003CCC                 mov     ecx, [eax]
.text$mn:00003CCE                 push    ecx
.text$mn:00003CCF                 lea     ecx, [ebp+var_1]
.text$mn:00003CD2                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003CD7                 push    1               ; int
.text$mn:00003CD9                 mov     edx, [ebp+var_8]
.text$mn:00003CDC                 mov     eax, [edx]
.text$mn:00003CDE                 push    eax             ; void *
.text$mn:00003CDF                 lea     ecx, [ebp+var_1]
.text$mn:00003CE2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00003CE7                 mov     ecx, [ebp+var_8]
.text$mn:00003CEA                 mov     dword ptr [ecx], 0
.text$mn:00003CF0                 mov     esp, ebp
.text$mn:00003CF2                 pop     ebp
.text$mn:00003CF3                 retn
.text$mn:00003CF3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003CF3
.text$mn:00003CF3 _text$mn        ends
.text$mn:00003CF3
.text$mn:00003CF4 ; ===========================================================================
.text$mn:00003CF4
.text$mn:00003CF4 ; Segment type: Pure code
.text$mn:00003CF4 ; Segment permissions: Read/Execute
.text$mn:00003CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00003CF4                 assume cs:_text$mn
.text$mn:00003CF4                 ;org 3CF4h
.text$mn:00003CF4 ; COMDAT (pick any)
.text$mn:00003CF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CF4
.text$mn:00003CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CF4
.text$mn:00003CF4 ; Attributes: bp-based frame
.text$mn:00003CF4
.text$mn:00003CF4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00003CF4                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00003CF4 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003CF4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00003CF4
.text$mn:00003CF4 var_8           = dword ptr -8
.text$mn:00003CF4 var_1           = byte ptr -1
.text$mn:00003CF4
.text$mn:00003CF4                 push    ebp
.text$mn:00003CF5                 mov     ebp, esp
.text$mn:00003CF7                 sub     esp, 8
.text$mn:00003CFA                 mov     [ebp+var_8], ecx
.text$mn:00003CFD                 lea     ecx, [ebp+var_1]
.text$mn:00003D00                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003D05                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D08                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003D0D                 mov     eax, [ebp+var_8]
.text$mn:00003D10                 mov     ecx, [eax]
.text$mn:00003D12                 push    ecx
.text$mn:00003D13                 lea     ecx, [ebp+var_1]
.text$mn:00003D16                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003D1B                 push    1               ; int
.text$mn:00003D1D                 mov     edx, [ebp+var_8]
.text$mn:00003D20                 mov     eax, [edx]
.text$mn:00003D22                 push    eax             ; void *
.text$mn:00003D23                 lea     ecx, [ebp+var_1]
.text$mn:00003D26                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00003D2B                 mov     ecx, [ebp+var_8]
.text$mn:00003D2E                 mov     dword ptr [ecx], 0
.text$mn:00003D34                 mov     esp, ebp
.text$mn:00003D36                 pop     ebp
.text$mn:00003D37                 retn
.text$mn:00003D37 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003D37
.text$mn:00003D37 _text$mn        ends
.text$mn:00003D37
.text$mn:00003D38 ; ===========================================================================
.text$mn:00003D38
.text$mn:00003D38 ; Segment type: Pure code
.text$mn:00003D38 ; Segment permissions: Read/Execute
.text$mn:00003D38 _text$mn        segment para public 'CODE' use32
.text$mn:00003D38                 assume cs:_text$mn
.text$mn:00003D38                 ;org 3D38h
.text$mn:00003D38 ; COMDAT (pick any)
.text$mn:00003D38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D38
.text$mn:00003D38 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D38
.text$mn:00003D38 ; Attributes: bp-based frame
.text$mn:00003D38
.text$mn:00003D38 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>::_Free_proxy(void)
.text$mn:00003D38                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ
.text$mn:00003D38 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003D38                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>(void)+30p
.text$mn:00003D38
.text$mn:00003D38 var_8           = dword ptr -8
.text$mn:00003D38 var_1           = byte ptr -1
.text$mn:00003D38
.text$mn:00003D38                 push    ebp
.text$mn:00003D39                 mov     ebp, esp
.text$mn:00003D3B                 sub     esp, 8
.text$mn:00003D3E                 mov     [ebp+var_8], ecx
.text$mn:00003D41                 lea     ecx, [ebp+var_1]
.text$mn:00003D44                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00003D49                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D4C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003D51                 mov     eax, [ebp+var_8]
.text$mn:00003D54                 mov     ecx, [eax]
.text$mn:00003D56                 push    ecx
.text$mn:00003D57                 lea     ecx, [ebp+var_1]
.text$mn:00003D5A                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003D5F                 push    1               ; int
.text$mn:00003D61                 mov     edx, [ebp+var_8]
.text$mn:00003D64                 mov     eax, [edx]
.text$mn:00003D66                 push    eax             ; void *
.text$mn:00003D67                 lea     ecx, [ebp+var_1]
.text$mn:00003D6A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00003D6F                 mov     ecx, [ebp+var_8]
.text$mn:00003D72                 mov     dword ptr [ecx], 0
.text$mn:00003D78                 mov     esp, ebp
.text$mn:00003D7A                 pop     ebp
.text$mn:00003D7B                 retn
.text$mn:00003D7B ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003D7B
.text$mn:00003D7B _text$mn        ends
.text$mn:00003D7B
.text$mn:00003D7C ; ===========================================================================
.text$mn:00003D7C
.text$mn:00003D7C ; Segment type: Pure code
.text$mn:00003D7C ; Segment permissions: Read/Execute
.text$mn:00003D7C _text$mn        segment para public 'CODE' use32
.text$mn:00003D7C                 assume cs:_text$mn
.text$mn:00003D7C                 ;org 3D7Ch
.text$mn:00003D7C ; COMDAT (pick any)
.text$mn:00003D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D7C
.text$mn:00003D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D7C
.text$mn:00003D7C ; Attributes: bp-based frame
.text$mn:00003D7C
.text$mn:00003D7C ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>>::_Free_proxy(void)
.text$mn:00003D7C                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ
.text$mn:00003D7C ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003D7C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::~_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>(void)+30p
.text$mn:00003D7C
.text$mn:00003D7C var_8           = dword ptr -8
.text$mn:00003D7C var_1           = byte ptr -1
.text$mn:00003D7C
.text$mn:00003D7C                 push    ebp
.text$mn:00003D7D                 mov     ebp, esp
.text$mn:00003D7F                 sub     esp, 8
.text$mn:00003D82                 mov     [ebp+var_8], ecx
.text$mn:00003D85                 lea     ecx, [ebp+var_1]
.text$mn:00003D88                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00003D8D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003D90                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003D95                 mov     eax, [ebp+var_8]
.text$mn:00003D98                 mov     ecx, [eax]
.text$mn:00003D9A                 push    ecx
.text$mn:00003D9B                 lea     ecx, [ebp+var_1]
.text$mn:00003D9E                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003DA3                 push    1               ; int
.text$mn:00003DA5                 mov     edx, [ebp+var_8]
.text$mn:00003DA8                 mov     eax, [edx]
.text$mn:00003DAA                 push    eax             ; void *
.text$mn:00003DAB                 lea     ecx, [ebp+var_1]
.text$mn:00003DAE                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00003DB3                 mov     ecx, [ebp+var_8]
.text$mn:00003DB6                 mov     dword ptr [ecx], 0
.text$mn:00003DBC                 mov     esp, ebp
.text$mn:00003DBE                 pop     ebp
.text$mn:00003DBF                 retn
.text$mn:00003DBF ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003DBF
.text$mn:00003DBF _text$mn        ends
.text$mn:00003DBF
.text$mn:00003DC0 ; ===========================================================================
.text$mn:00003DC0
.text$mn:00003DC0 ; Segment type: Pure code
.text$mn:00003DC0 ; Segment permissions: Read/Execute
.text$mn:00003DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DC0                 assume cs:_text$mn
.text$mn:00003DC0                 ;org 3DC0h
.text$mn:00003DC0 ; COMDAT (pick any)
.text$mn:00003DC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DC0
.text$mn:00003DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DC0
.text$mn:00003DC0 ; Attributes: bp-based frame
.text$mn:00003DC0
.text$mn:00003DC0 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00003DC0                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00003DC0 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00003DC0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00003DC0                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00003DC0
.text$mn:00003DC0 var_4           = dword ptr -4
.text$mn:00003DC0 arg_0           = dword ptr  8
.text$mn:00003DC0
.text$mn:00003DC0                 push    ebp
.text$mn:00003DC1                 mov     ebp, esp
.text$mn:00003DC3                 push    ecx
.text$mn:00003DC4                 mov     [ebp+var_4], ecx
.text$mn:00003DC7                 mov     ecx, [ebp+arg_0]
.text$mn:00003DCA                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00003DCF                 mov     eax, [ebp+arg_0]
.text$mn:00003DD2                 mov     esp, ebp
.text$mn:00003DD4                 pop     ebp
.text$mn:00003DD5                 retn    4
.text$mn:00003DD5 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00003DD5
.text$mn:00003DD5 _text$mn        ends
.text$mn:00003DD5
.text$mn:00003DD8 ; ===========================================================================
.text$mn:00003DD8
.text$mn:00003DD8 ; Segment type: Pure code
.text$mn:00003DD8 ; Segment permissions: Read/Execute
.text$mn:00003DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00003DD8                 assume cs:_text$mn
.text$mn:00003DD8                 ;org 3DD8h
.text$mn:00003DD8 ; COMDAT (pick any)
.text$mn:00003DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DD8
.text$mn:00003DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DD8
.text$mn:00003DD8 ; Attributes: bp-based frame
.text$mn:00003DD8
.text$mn:00003DD8 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00003DD8                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00003DD8 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00003DD8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:00003DD8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p ...
.text$mn:00003DD8
.text$mn:00003DD8 var_4           = dword ptr -4
.text$mn:00003DD8 arg_0           = dword ptr  8
.text$mn:00003DD8
.text$mn:00003DD8                 push    ebp
.text$mn:00003DD9                 mov     ebp, esp
.text$mn:00003DDB                 push    ecx
.text$mn:00003DDC                 mov     [ebp+var_4], ecx
.text$mn:00003DDF                 mov     ecx, [ebp+arg_0]
.text$mn:00003DE2                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00003DE7                 mov     eax, [ebp+arg_0]
.text$mn:00003DEA                 mov     esp, ebp
.text$mn:00003DEC                 pop     ebp
.text$mn:00003DED                 retn    4
.text$mn:00003DED ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00003DED
.text$mn:00003DED _text$mn        ends
.text$mn:00003DED
.text$mn:00003DF0 ; ===========================================================================
.text$mn:00003DF0
.text$mn:00003DF0 ; Segment type: Pure code
.text$mn:00003DF0 ; Segment permissions: Read/Execute
.text$mn:00003DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DF0                 assume cs:_text$mn
.text$mn:00003DF0                 ;org 3DF0h
.text$mn:00003DF0 ; COMDAT (pick any)
.text$mn:00003DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DF0
.text$mn:00003DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DF0
.text$mn:00003DF0 ; Attributes: bp-based frame
.text$mn:00003DF0
.text$mn:00003DF0 ; public: struct std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>>::_Getal(void)const
.text$mn:00003DF0                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ
.text$mn:00003DF0 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ proc near
.text$mn:00003DF0                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Umove<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *)+10p
.text$mn:00003DF0                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&)+2Fp ...
.text$mn:00003DF0
.text$mn:00003DF0 var_4           = dword ptr -4
.text$mn:00003DF0 arg_0           = dword ptr  8
.text$mn:00003DF0
.text$mn:00003DF0                 push    ebp
.text$mn:00003DF1                 mov     ebp, esp
.text$mn:00003DF3                 push    ecx
.text$mn:00003DF4                 mov     [ebp+var_4], ecx
.text$mn:00003DF7                 mov     ecx, [ebp+arg_0]
.text$mn:00003DFA                 call    ??0?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::_Wrap_alloc<std::allocator<SwitcherFileInfo>>(void)
.text$mn:00003DFF                 mov     eax, [ebp+arg_0]
.text$mn:00003E02                 mov     esp, ebp
.text$mn:00003E04                 pop     ebp
.text$mn:00003E05                 retn    4
.text$mn:00003E05 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ endp
.text$mn:00003E05
.text$mn:00003E05 _text$mn        ends
.text$mn:00003E05
.text$mn:00003E08 ; ===========================================================================
.text$mn:00003E08
.text$mn:00003E08 ; Segment type: Pure code
.text$mn:00003E08 ; Segment permissions: Read/Execute
.text$mn:00003E08 _text$mn        segment para public 'CODE' use32
.text$mn:00003E08                 assume cs:_text$mn
.text$mn:00003E08                 ;org 3E08h
.text$mn:00003E08 ; COMDAT (pick any)
.text$mn:00003E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E08
.text$mn:00003E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E08
.text$mn:00003E08 ; Attributes: bp-based frame
.text$mn:00003E08
.text$mn:00003E08 ; public: struct std::_Wrap_alloc<class std::allocator<struct TaskLstFnStatus>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>>::_Getal(void)const
.text$mn:00003E08                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@2@XZ
.text$mn:00003E08 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@2@XZ proc near
.text$mn:00003E08                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Destroy(TaskLstFnStatus *,TaskLstFnStatus *)+10p
.text$mn:00003E08                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Tidy(void)+55p
.text$mn:00003E08
.text$mn:00003E08 var_4           = dword ptr -4
.text$mn:00003E08 arg_0           = dword ptr  8
.text$mn:00003E08
.text$mn:00003E08                 push    ebp
.text$mn:00003E09                 mov     ebp, esp
.text$mn:00003E0B                 push    ecx
.text$mn:00003E0C                 mov     [ebp+var_4], ecx
.text$mn:00003E0F                 mov     ecx, [ebp+arg_0]
.text$mn:00003E12                 call    ??0?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>::_Wrap_alloc<std::allocator<TaskLstFnStatus>>(void)
.text$mn:00003E17                 mov     eax, [ebp+arg_0]
.text$mn:00003E1A                 mov     esp, ebp
.text$mn:00003E1C                 pop     ebp
.text$mn:00003E1D                 retn    4
.text$mn:00003E1D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@2@XZ endp
.text$mn:00003E1D
.text$mn:00003E1D _text$mn        ends
.text$mn:00003E1D
.text$mn:00003E20 ; ===========================================================================
.text$mn:00003E20
.text$mn:00003E20 ; Segment type: Pure code
.text$mn:00003E20 ; Segment permissions: Read/Execute
.text$mn:00003E20 _text$mn        segment para public 'CODE' use32
.text$mn:00003E20                 assume cs:_text$mn
.text$mn:00003E20                 ;org 3E20h
.text$mn:00003E20 ; COMDAT (pick any)
.text$mn:00003E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E20
.text$mn:00003E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E20
.text$mn:00003E20 ; Attributes: bp-based frame
.text$mn:00003E20
.text$mn:00003E20 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00003E20                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00003E20 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00003E20                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+3Cp
.text$mn:00003E20
.text$mn:00003E20 var_8           = dword ptr -8
.text$mn:00003E20 var_4           = dword ptr -4
.text$mn:00003E20
.text$mn:00003E20                 push    ebp
.text$mn:00003E21                 mov     ebp, esp
.text$mn:00003E23                 sub     esp, 8
.text$mn:00003E26                 mov     [ebp+var_4], ecx
.text$mn:00003E29                 mov     eax, [ebp+var_4]
.text$mn:00003E2C                 cmp     dword ptr [eax], 0
.text$mn:00003E2F                 jnz     short loc_3E3A
.text$mn:00003E31                 mov     [ebp+var_8], 0
.text$mn:00003E38                 jmp     short loc_3E45
.text$mn:00003E3A ; ---------------------------------------------------------------------------
.text$mn:00003E3A
.text$mn:00003E3A loc_3E3A:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00003E3A                 mov     ecx, [ebp+var_4]
.text$mn:00003E3D                 mov     edx, [ecx]
.text$mn:00003E3F                 add     edx, 4
.text$mn:00003E42                 mov     [ebp+var_8], edx
.text$mn:00003E45
.text$mn:00003E45 loc_3E45:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00003E45                 mov     eax, [ebp+var_8]
.text$mn:00003E48                 mov     esp, ebp
.text$mn:00003E4A                 pop     ebp
.text$mn:00003E4B                 retn
.text$mn:00003E4B ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00003E4B
.text$mn:00003E4B _text$mn        ends
.text$mn:00003E4B
.text$mn:00003E4C ; ===========================================================================
.text$mn:00003E4C
.text$mn:00003E4C ; Segment type: Pure code
.text$mn:00003E4C ; Segment permissions: Read/Execute
.text$mn:00003E4C _text$mn        segment para public 'CODE' use32
.text$mn:00003E4C                 assume cs:_text$mn
.text$mn:00003E4C                 ;org 3E4Ch
.text$mn:00003E4C ; COMDAT (pick any)
.text$mn:00003E4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E4C
.text$mn:00003E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E4C
.text$mn:00003E4C ; Attributes: bp-based frame
.text$mn:00003E4C
.text$mn:00003E4C ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00003E4C                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00003E4C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00003E4C                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+71p
.text$mn:00003E4C                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+8Ap
.text$mn:00003E4C
.text$mn:00003E4C var_4           = dword ptr -4
.text$mn:00003E4C
.text$mn:00003E4C                 push    ebp
.text$mn:00003E4D                 mov     ebp, esp
.text$mn:00003E4F                 push    ecx
.text$mn:00003E50                 mov     [ebp+var_4], ecx
.text$mn:00003E53                 mov     eax, [ebp+var_4]
.text$mn:00003E56                 add     eax, 4
.text$mn:00003E59                 mov     esp, ebp
.text$mn:00003E5B                 pop     ebp
.text$mn:00003E5C                 retn
.text$mn:00003E5C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00003E5C
.text$mn:00003E5C ; ---------------------------------------------------------------------------
.text$mn:00003E5D                 align 10h
.text$mn:00003E5D _text$mn        ends
.text$mn:00003E5D
.text$mn:00003E60 ; ===========================================================================
.text$mn:00003E60
.text$mn:00003E60 ; Segment type: Pure code
.text$mn:00003E60 ; Segment permissions: Read/Execute
.text$mn:00003E60 _text$mn        segment para public 'CODE' use32
.text$mn:00003E60                 assume cs:_text$mn
.text$mn:00003E60                 ;org 3E60h
.text$mn:00003E60 ; COMDAT (pick any)
.text$mn:00003E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E60
.text$mn:00003E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E60
.text$mn:00003E60 ; Attributes: bp-based frame
.text$mn:00003E60
.text$mn:00003E60 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00003E60                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00003E60 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00003E60                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00003E60                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00003E60
.text$mn:00003E60 var_C           = dword ptr -0Ch
.text$mn:00003E60 Size            = dword ptr -8
.text$mn:00003E60 var_4           = dword ptr -4
.text$mn:00003E60 arg_0           = dword ptr  8
.text$mn:00003E60 arg_4           = byte ptr  0Ch
.text$mn:00003E60
.text$mn:00003E60                 push    ebp
.text$mn:00003E61                 mov     ebp, esp
.text$mn:00003E63                 sub     esp, 0Ch
.text$mn:00003E66                 mov     [ebp+var_4], ecx
.text$mn:00003E69                 mov     ecx, [ebp+var_4]
.text$mn:00003E6C                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003E71                 cmp     eax, [ebp+arg_0]
.text$mn:00003E74                 jnb     short loc_3E7E
.text$mn:00003E76                 mov     ecx, [ebp+var_4]
.text$mn:00003E79                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00003E7E
.text$mn:00003E7E loc_3E7E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00003E7E                 mov     eax, [ebp+var_4]
.text$mn:00003E81                 mov     ecx, [eax+18h]
.text$mn:00003E84                 cmp     ecx, [ebp+arg_0]
.text$mn:00003E87                 jnb     short loc_3E9E
.text$mn:00003E89                 mov     edx, [ebp+var_4]
.text$mn:00003E8C                 mov     eax, [edx+14h]
.text$mn:00003E8F                 push    eax
.text$mn:00003E90                 mov     ecx, [ebp+arg_0]
.text$mn:00003E93                 push    ecx
.text$mn:00003E94                 mov     ecx, [ebp+var_4]
.text$mn:00003E97                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00003E9C                 jmp     short loc_3EE8
.text$mn:00003E9E ; ---------------------------------------------------------------------------
.text$mn:00003E9E
.text$mn:00003E9E loc_3E9E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00003E9E                 movzx   edx, [ebp+arg_4]
.text$mn:00003EA2                 test    edx, edx
.text$mn:00003EA4                 jz      short loc_3ED8
.text$mn:00003EA6                 cmp     [ebp+arg_0], 10h
.text$mn:00003EAA                 jnb     short loc_3ED8
.text$mn:00003EAC                 mov     eax, [ebp+var_4]
.text$mn:00003EAF                 mov     ecx, [ebp+arg_0]
.text$mn:00003EB2                 cmp     ecx, [eax+14h]
.text$mn:00003EB5                 jnb     short loc_3EBF
.text$mn:00003EB7                 mov     edx, [ebp+arg_0]
.text$mn:00003EBA                 mov     [ebp+Size], edx
.text$mn:00003EBD                 jmp     short loc_3EC8
.text$mn:00003EBF ; ---------------------------------------------------------------------------
.text$mn:00003EBF
.text$mn:00003EBF loc_3EBF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00003EBF                 mov     eax, [ebp+var_4]
.text$mn:00003EC2                 mov     ecx, [eax+14h]
.text$mn:00003EC5                 mov     [ebp+Size], ecx
.text$mn:00003EC8
.text$mn:00003EC8 loc_3EC8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00003EC8                 mov     edx, [ebp+Size]
.text$mn:00003ECB                 push    edx             ; Size
.text$mn:00003ECC                 push    1               ; char
.text$mn:00003ECE                 mov     ecx, [ebp+var_4]
.text$mn:00003ED1                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003ED6                 jmp     short loc_3EE8
.text$mn:00003ED8 ; ---------------------------------------------------------------------------
.text$mn:00003ED8
.text$mn:00003ED8 loc_3ED8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00003ED8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00003ED8                 cmp     [ebp+arg_0], 0
.text$mn:00003EDC                 jnz     short loc_3EE8
.text$mn:00003EDE                 push    0
.text$mn:00003EE0                 mov     ecx, [ebp+var_4]
.text$mn:00003EE3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003EE8
.text$mn:00003EE8 loc_3EE8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00003EE8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00003EE8                 cmp     [ebp+arg_0], 0
.text$mn:00003EEC                 jbe     short loc_3EF7
.text$mn:00003EEE                 mov     [ebp+var_C], 1
.text$mn:00003EF5                 jmp     short loc_3EFE
.text$mn:00003EF7 ; ---------------------------------------------------------------------------
.text$mn:00003EF7
.text$mn:00003EF7 loc_3EF7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00003EF7                 mov     [ebp+var_C], 0
.text$mn:00003EFE
.text$mn:00003EFE loc_3EFE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00003EFE                 mov     al, byte ptr [ebp+var_C]
.text$mn:00003F01                 mov     esp, ebp
.text$mn:00003F03                 pop     ebp
.text$mn:00003F04                 retn    8
.text$mn:00003F04 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00003F04
.text$mn:00003F04 ; ---------------------------------------------------------------------------
.text$mn:00003F07                 align 4
.text$mn:00003F07 _text$mn        ends
.text$mn:00003F07
.text$mn:00003F08 ; ===========================================================================
.text$mn:00003F08
.text$mn:00003F08 ; Segment type: Pure code
.text$mn:00003F08 ; Segment permissions: Read/Execute
.text$mn:00003F08 _text$mn        segment para public 'CODE' use32
.text$mn:00003F08                 assume cs:_text$mn
.text$mn:00003F08                 ;org 3F08h
.text$mn:00003F08 ; COMDAT (pick any)
.text$mn:00003F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F08
.text$mn:00003F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F08
.text$mn:00003F08 ; Attributes: bp-based frame
.text$mn:00003F08
.text$mn:00003F08 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00003F08                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00003F08 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00003F08                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00003F08                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:00003F08
.text$mn:00003F08 var_C           = dword ptr -0Ch
.text$mn:00003F08 var_8           = dword ptr -8
.text$mn:00003F08 var_4           = dword ptr -4
.text$mn:00003F08 arg_0           = dword ptr  8
.text$mn:00003F08 arg_4           = byte ptr  0Ch
.text$mn:00003F08
.text$mn:00003F08                 push    ebp
.text$mn:00003F09                 mov     ebp, esp
.text$mn:00003F0B                 sub     esp, 0Ch
.text$mn:00003F0E                 mov     [ebp+var_4], ecx
.text$mn:00003F11                 mov     ecx, [ebp+var_4]
.text$mn:00003F14                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00003F19                 cmp     eax, [ebp+arg_0]
.text$mn:00003F1C                 jnb     short loc_3F26
.text$mn:00003F1E                 mov     ecx, [ebp+var_4]
.text$mn:00003F21                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00003F26
.text$mn:00003F26 loc_3F26:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00003F26                 mov     eax, [ebp+var_4]
.text$mn:00003F29                 mov     ecx, [eax+18h]
.text$mn:00003F2C                 cmp     ecx, [ebp+arg_0]
.text$mn:00003F2F                 jnb     short loc_3F46
.text$mn:00003F31                 mov     edx, [ebp+var_4]
.text$mn:00003F34                 mov     eax, [edx+14h]
.text$mn:00003F37                 push    eax
.text$mn:00003F38                 mov     ecx, [ebp+arg_0]
.text$mn:00003F3B                 push    ecx
.text$mn:00003F3C                 mov     ecx, [ebp+var_4]
.text$mn:00003F3F                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00003F44                 jmp     short loc_3F90
.text$mn:00003F46 ; ---------------------------------------------------------------------------
.text$mn:00003F46
.text$mn:00003F46 loc_3F46:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00003F46                 movzx   edx, [ebp+arg_4]
.text$mn:00003F4A                 test    edx, edx
.text$mn:00003F4C                 jz      short loc_3F80
.text$mn:00003F4E                 cmp     [ebp+arg_0], 8
.text$mn:00003F52                 jnb     short loc_3F80
.text$mn:00003F54                 mov     eax, [ebp+var_4]
.text$mn:00003F57                 mov     ecx, [ebp+arg_0]
.text$mn:00003F5A                 cmp     ecx, [eax+14h]
.text$mn:00003F5D                 jnb     short loc_3F67
.text$mn:00003F5F                 mov     edx, [ebp+arg_0]
.text$mn:00003F62                 mov     [ebp+var_8], edx
.text$mn:00003F65                 jmp     short loc_3F70
.text$mn:00003F67 ; ---------------------------------------------------------------------------
.text$mn:00003F67
.text$mn:00003F67 loc_3F67:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00003F67                 mov     eax, [ebp+var_4]
.text$mn:00003F6A                 mov     ecx, [eax+14h]
.text$mn:00003F6D                 mov     [ebp+var_8], ecx
.text$mn:00003F70
.text$mn:00003F70 loc_3F70:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00003F70                 mov     edx, [ebp+var_8]
.text$mn:00003F73                 push    edx
.text$mn:00003F74                 push    1
.text$mn:00003F76                 mov     ecx, [ebp+var_4]
.text$mn:00003F79                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003F7E                 jmp     short loc_3F90
.text$mn:00003F80 ; ---------------------------------------------------------------------------
.text$mn:00003F80
.text$mn:00003F80 loc_3F80:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00003F80                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00003F80                 cmp     [ebp+arg_0], 0
.text$mn:00003F84                 jnz     short loc_3F90
.text$mn:00003F86                 push    0
.text$mn:00003F88                 mov     ecx, [ebp+var_4]
.text$mn:00003F8B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003F90
.text$mn:00003F90 loc_3F90:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00003F90                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00003F90                 cmp     [ebp+arg_0], 0
.text$mn:00003F94                 jbe     short loc_3F9F
.text$mn:00003F96                 mov     [ebp+var_C], 1
.text$mn:00003F9D                 jmp     short loc_3FA6
.text$mn:00003F9F ; ---------------------------------------------------------------------------
.text$mn:00003F9F
.text$mn:00003F9F loc_3F9F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00003F9F                 mov     [ebp+var_C], 0
.text$mn:00003FA6
.text$mn:00003FA6 loc_3FA6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00003FA6                 mov     al, byte ptr [ebp+var_C]
.text$mn:00003FA9                 mov     esp, ebp
.text$mn:00003FAB                 pop     ebp
.text$mn:00003FAC                 retn    8
.text$mn:00003FAC ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00003FAC
.text$mn:00003FAC ; ---------------------------------------------------------------------------
.text$mn:00003FAF                 align 10h
.text$mn:00003FAF _text$mn        ends
.text$mn:00003FAF
.text$mn:00003FB0 ; ===========================================================================
.text$mn:00003FB0
.text$mn:00003FB0 ; Segment type: Pure code
.text$mn:00003FB0 ; Segment permissions: Read/Execute
.text$mn:00003FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FB0                 assume cs:_text$mn
.text$mn:00003FB0                 ;org 3FB0h
.text$mn:00003FB0 ; COMDAT (pick any)
.text$mn:00003FB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FB0
.text$mn:00003FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FB0
.text$mn:00003FB0 ; Attributes: bp-based frame
.text$mn:00003FB0
.text$mn:00003FB0 ; protected: unsigned int __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Grow_to(unsigned int)const
.text$mn:00003FB0                 public ?_Grow_to@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEII@Z
.text$mn:00003FB0 ?_Grow_to@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEII@Z proc near
.text$mn:00003FB0                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+45p
.text$mn:00003FB0
.text$mn:00003FB0 var_C           = dword ptr -0Ch
.text$mn:00003FB0 var_8           = dword ptr -8
.text$mn:00003FB0 var_4           = dword ptr -4
.text$mn:00003FB0 arg_0           = dword ptr  8
.text$mn:00003FB0
.text$mn:00003FB0                 push    ebp
.text$mn:00003FB1                 mov     ebp, esp
.text$mn:00003FB3                 sub     esp, 0Ch
.text$mn:00003FB6                 mov     [ebp+var_8], ecx
.text$mn:00003FB9                 mov     ecx, [ebp+var_8]
.text$mn:00003FBC                 call    ?capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::capacity(void)
.text$mn:00003FC1                 mov     [ebp+var_4], eax
.text$mn:00003FC4                 mov     ecx, [ebp+var_8]
.text$mn:00003FC7                 call    ?max_size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::max_size(void)
.text$mn:00003FCC                 mov     ecx, [ebp+var_4]
.text$mn:00003FCF                 shr     ecx, 1
.text$mn:00003FD1                 sub     eax, ecx
.text$mn:00003FD3                 cmp     eax, [ebp+var_4]
.text$mn:00003FD6                 jnb     short loc_3FE1
.text$mn:00003FD8                 mov     [ebp+var_C], 0
.text$mn:00003FDF                 jmp     short loc_3FEC
.text$mn:00003FE1 ; ---------------------------------------------------------------------------
.text$mn:00003FE1
.text$mn:00003FE1 loc_3FE1:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Grow_to(uint)+26j
.text$mn:00003FE1                 mov     edx, [ebp+var_4]
.text$mn:00003FE4                 shr     edx, 1
.text$mn:00003FE6                 add     edx, [ebp+var_4]
.text$mn:00003FE9                 mov     [ebp+var_C], edx
.text$mn:00003FEC
.text$mn:00003FEC loc_3FEC:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Grow_to(uint)+2Fj
.text$mn:00003FEC                 mov     eax, [ebp+var_C]
.text$mn:00003FEF                 mov     [ebp+var_4], eax
.text$mn:00003FF2                 mov     ecx, [ebp+var_4]
.text$mn:00003FF5                 cmp     ecx, [ebp+arg_0]
.text$mn:00003FF8                 jnb     short loc_4000
.text$mn:00003FFA                 mov     edx, [ebp+arg_0]
.text$mn:00003FFD                 mov     [ebp+var_4], edx
.text$mn:00004000
.text$mn:00004000 loc_4000:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Grow_to(uint)+48j
.text$mn:00004000                 mov     eax, [ebp+var_4]
.text$mn:00004003                 mov     esp, ebp
.text$mn:00004005                 pop     ebp
.text$mn:00004006                 retn    4
.text$mn:00004006 ?_Grow_to@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEII@Z endp
.text$mn:00004006
.text$mn:00004006 ; ---------------------------------------------------------------------------
.text$mn:00004009                 align 4
.text$mn:00004009 _text$mn        ends
.text$mn:00004009
.text$mn:0000400C ; ===========================================================================
.text$mn:0000400C
.text$mn:0000400C ; Segment type: Pure code
.text$mn:0000400C ; Segment permissions: Read/Execute
.text$mn:0000400C _text$mn        segment para public 'CODE' use32
.text$mn:0000400C                 assume cs:_text$mn
.text$mn:0000400C                 ;org 400Ch
.text$mn:0000400C ; COMDAT (pick any)
.text$mn:0000400C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000400C
.text$mn:0000400C ; =============== S U B R O U T I N E =======================================
.text$mn:0000400C
.text$mn:0000400C ; Attributes: bp-based frame
.text$mn:0000400C
.text$mn:0000400C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000400C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000400C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000400C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000400C
.text$mn:0000400C var_4           = dword ptr -4
.text$mn:0000400C arg_0           = dword ptr  8
.text$mn:0000400C
.text$mn:0000400C                 push    ebp
.text$mn:0000400D                 mov     ebp, esp
.text$mn:0000400F                 push    ecx
.text$mn:00004010                 mov     [ebp+var_4], ecx
.text$mn:00004013                 cmp     [ebp+arg_0], 0
.text$mn:00004017                 jz      short loc_4039
.text$mn:00004019                 mov     ecx, [ebp+var_4]
.text$mn:0000401C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004021                 cmp     [ebp+arg_0], eax
.text$mn:00004024                 jb      short loc_4039
.text$mn:00004026                 mov     ecx, [ebp+var_4]
.text$mn:00004029                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000402E                 mov     ecx, [ebp+var_4]
.text$mn:00004031                 add     eax, [ecx+14h]
.text$mn:00004034                 cmp     eax, [ebp+arg_0]
.text$mn:00004037                 ja      short loc_403F
.text$mn:00004039
.text$mn:00004039 loc_4039:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00004039                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00004039                 xor     al, al
.text$mn:0000403B                 jmp     short loc_4041
.text$mn:0000403D ; ---------------------------------------------------------------------------
.text$mn:0000403D                 jmp     short loc_4041
.text$mn:0000403F ; ---------------------------------------------------------------------------
.text$mn:0000403F
.text$mn:0000403F loc_403F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000403F                 mov     al, 1
.text$mn:00004041
.text$mn:00004041 loc_4041:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00004041                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00004041                 mov     esp, ebp
.text$mn:00004043                 pop     ebp
.text$mn:00004044                 retn    4
.text$mn:00004044 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00004044
.text$mn:00004044 ; ---------------------------------------------------------------------------
.text$mn:00004047                 align 4
.text$mn:00004047 _text$mn        ends
.text$mn:00004047
.text$mn:00004048 ; ===========================================================================
.text$mn:00004048
.text$mn:00004048 ; Segment type: Pure code
.text$mn:00004048 ; Segment permissions: Read/Execute
.text$mn:00004048 _text$mn        segment para public 'CODE' use32
.text$mn:00004048                 assume cs:_text$mn
.text$mn:00004048                 ;org 4048h
.text$mn:00004048 ; COMDAT (pick any)
.text$mn:00004048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004048
.text$mn:00004048 ; =============== S U B R O U T I N E =======================================
.text$mn:00004048
.text$mn:00004048 ; Attributes: bp-based frame
.text$mn:00004048
.text$mn:00004048 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00004048                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00004048 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00004048                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00004048
.text$mn:00004048 var_4           = dword ptr -4
.text$mn:00004048 arg_0           = dword ptr  8
.text$mn:00004048
.text$mn:00004048                 push    ebp
.text$mn:00004049                 mov     ebp, esp
.text$mn:0000404B                 push    ecx
.text$mn:0000404C                 mov     [ebp+var_4], ecx
.text$mn:0000404F                 cmp     [ebp+arg_0], 0
.text$mn:00004053                 jz      short loc_4078
.text$mn:00004055                 mov     ecx, [ebp+var_4]
.text$mn:00004058                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000405D                 cmp     [ebp+arg_0], eax
.text$mn:00004060                 jb      short loc_4078
.text$mn:00004062                 mov     ecx, [ebp+var_4]
.text$mn:00004065                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000406A                 mov     ecx, [ebp+var_4]
.text$mn:0000406D                 mov     edx, [ecx+14h]
.text$mn:00004070                 lea     eax, [eax+edx*2]
.text$mn:00004073                 cmp     eax, [ebp+arg_0]
.text$mn:00004076                 ja      short loc_407E
.text$mn:00004078
.text$mn:00004078 loc_4078:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00004078                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00004078                 xor     al, al
.text$mn:0000407A                 jmp     short loc_4080
.text$mn:0000407C ; ---------------------------------------------------------------------------
.text$mn:0000407C                 jmp     short loc_4080
.text$mn:0000407E ; ---------------------------------------------------------------------------
.text$mn:0000407E
.text$mn:0000407E loc_407E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:0000407E                 mov     al, 1
.text$mn:00004080
.text$mn:00004080 loc_4080:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00004080                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00004080                 mov     esp, ebp
.text$mn:00004082                 pop     ebp
.text$mn:00004083                 retn    4
.text$mn:00004083 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00004083
.text$mn:00004083 ; ---------------------------------------------------------------------------
.text$mn:00004086                 align 4
.text$mn:00004086 _text$mn        ends
.text$mn:00004086
.text$mn:00004088 ; ===========================================================================
.text$mn:00004088
.text$mn:00004088 ; Segment type: Pure code
.text$mn:00004088 ; Segment permissions: Read/Execute
.text$mn:00004088 _text$mn        segment para public 'CODE' use32
.text$mn:00004088                 assume cs:_text$mn
.text$mn:00004088                 ;org 4088h
.text$mn:00004088 ; COMDAT (pick any)
.text$mn:00004088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004088
.text$mn:00004088 ; =============== S U B R O U T I N E =======================================
.text$mn:00004088
.text$mn:00004088 ; Attributes: bp-based frame
.text$mn:00004088
.text$mn:00004088 ; protected: bool __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Inside(struct SwitcherFileInfo const *)const
.text$mn:00004088                 public ?_Inside@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBE_NPBUSwitcherFileInfo@@@Z
.text$mn:00004088 ?_Inside@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBE_NPBUSwitcherFileInfo@@@Z proc near
.text$mn:00004088                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+19p
.text$mn:00004088
.text$mn:00004088 var_8           = dword ptr -8
.text$mn:00004088 var_4           = dword ptr -4
.text$mn:00004088 arg_0           = dword ptr  8
.text$mn:00004088
.text$mn:00004088                 push    ebp
.text$mn:00004089                 mov     ebp, esp
.text$mn:0000408B                 sub     esp, 8
.text$mn:0000408E                 mov     [ebp+var_4], ecx
.text$mn:00004091                 mov     eax, [ebp+var_4]
.text$mn:00004094                 mov     ecx, [ebp+arg_0]
.text$mn:00004097                 cmp     ecx, [eax+8]
.text$mn:0000409A                 jnb     short loc_40B0
.text$mn:0000409C                 mov     edx, [ebp+var_4]
.text$mn:0000409F                 mov     eax, [edx+4]
.text$mn:000040A2                 cmp     eax, [ebp+arg_0]
.text$mn:000040A5                 ja      short loc_40B0
.text$mn:000040A7                 mov     [ebp+var_8], 1
.text$mn:000040AE                 jmp     short loc_40B7
.text$mn:000040B0 ; ---------------------------------------------------------------------------
.text$mn:000040B0
.text$mn:000040B0 loc_40B0:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Inside(SwitcherFileInfo const *)+12j
.text$mn:000040B0                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Inside(SwitcherFileInfo const *)+1Dj
.text$mn:000040B0                 mov     [ebp+var_8], 0
.text$mn:000040B7
.text$mn:000040B7 loc_40B7:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Inside(SwitcherFileInfo const *)+26j
.text$mn:000040B7                 mov     al, byte ptr [ebp+var_8]
.text$mn:000040BA                 mov     esp, ebp
.text$mn:000040BC                 pop     ebp
.text$mn:000040BD                 retn    4
.text$mn:000040BD ?_Inside@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBE_NPBUSwitcherFileInfo@@@Z endp
.text$mn:000040BD
.text$mn:000040BD _text$mn        ends
.text$mn:000040BD
.text$mn:000040C0 ; ===========================================================================
.text$mn:000040C0
.text$mn:000040C0 ; Segment type: Pure code
.text$mn:000040C0 ; Segment permissions: Read/Execute
.text$mn:000040C0 _text$mn        segment para public 'CODE' use32
.text$mn:000040C0                 assume cs:_text$mn
.text$mn:000040C0                 ;org 40C0h
.text$mn:000040C0 ; COMDAT (pick any)
.text$mn:000040C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040C0
.text$mn:000040C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040C0
.text$mn:000040C0 ; Attributes: bp-based frame
.text$mn:000040C0
.text$mn:000040C0 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000040C0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000040C0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000040C0                                         ; CODE XREF: $LN19+14p
.text$mn:000040C0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000040C0
.text$mn:000040C0 var_8           = dword ptr -8
.text$mn:000040C0 var_4           = dword ptr -4
.text$mn:000040C0
.text$mn:000040C0                 push    ebp
.text$mn:000040C1                 mov     ebp, esp
.text$mn:000040C3                 sub     esp, 8
.text$mn:000040C6                 mov     [ebp+var_4], ecx
.text$mn:000040C9                 mov     eax, [ebp+var_4]
.text$mn:000040CC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000040D0                 jb      short loc_40E6
.text$mn:000040D2                 mov     ecx, [ebp+var_4]
.text$mn:000040D5                 mov     edx, [ecx+4]
.text$mn:000040D8                 push    edx
.text$mn:000040D9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000040DE                 add     esp, 4
.text$mn:000040E1                 mov     [ebp+var_8], eax
.text$mn:000040E4                 jmp     short loc_40EF
.text$mn:000040E6 ; ---------------------------------------------------------------------------
.text$mn:000040E6
.text$mn:000040E6 loc_40E6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000040E6                 mov     eax, [ebp+var_4]
.text$mn:000040E9                 add     eax, 4
.text$mn:000040EC                 mov     [ebp+var_8], eax
.text$mn:000040EF
.text$mn:000040EF loc_40EF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000040EF                 mov     eax, [ebp+var_8]
.text$mn:000040F2                 mov     esp, ebp
.text$mn:000040F4                 pop     ebp
.text$mn:000040F5                 retn
.text$mn:000040F5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000040F5
.text$mn:000040F5 ; ---------------------------------------------------------------------------
.text$mn:000040F6                 align 4
.text$mn:000040F6 _text$mn        ends
.text$mn:000040F6
.text$mn:000040F8 ; ===========================================================================
.text$mn:000040F8
.text$mn:000040F8 ; Segment type: Pure code
.text$mn:000040F8 ; Segment permissions: Read/Execute
.text$mn:000040F8 _text$mn        segment para public 'CODE' use32
.text$mn:000040F8                 assume cs:_text$mn
.text$mn:000040F8                 ;org 40F8h
.text$mn:000040F8 ; COMDAT (pick any)
.text$mn:000040F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040F8
.text$mn:000040F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000040F8
.text$mn:000040F8 ; Attributes: bp-based frame
.text$mn:000040F8
.text$mn:000040F8 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000040F8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000040F8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000040F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000040F8
.text$mn:000040F8 var_8           = dword ptr -8
.text$mn:000040F8 var_4           = dword ptr -4
.text$mn:000040F8
.text$mn:000040F8                 push    ebp
.text$mn:000040F9                 mov     ebp, esp
.text$mn:000040FB                 sub     esp, 8
.text$mn:000040FE                 mov     [ebp+var_4], ecx
.text$mn:00004101                 mov     eax, [ebp+var_4]
.text$mn:00004104                 cmp     dword ptr [eax+18h], 10h
.text$mn:00004108                 jb      short loc_411E
.text$mn:0000410A                 mov     ecx, [ebp+var_4]
.text$mn:0000410D                 mov     edx, [ecx+4]
.text$mn:00004110                 push    edx
.text$mn:00004111                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004116                 add     esp, 4
.text$mn:00004119                 mov     [ebp+var_8], eax
.text$mn:0000411C                 jmp     short loc_4127
.text$mn:0000411E ; ---------------------------------------------------------------------------
.text$mn:0000411E
.text$mn:0000411E loc_411E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000411E                 mov     eax, [ebp+var_4]
.text$mn:00004121                 add     eax, 4
.text$mn:00004124                 mov     [ebp+var_8], eax
.text$mn:00004127
.text$mn:00004127 loc_4127:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00004127                 mov     eax, [ebp+var_8]
.text$mn:0000412A                 mov     esp, ebp
.text$mn:0000412C                 pop     ebp
.text$mn:0000412D                 retn
.text$mn:0000412D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000412D
.text$mn:0000412D ; ---------------------------------------------------------------------------
.text$mn:0000412E                 align 10h
.text$mn:0000412E _text$mn        ends
.text$mn:0000412E
.text$mn:00004130 ; ===========================================================================
.text$mn:00004130
.text$mn:00004130 ; Segment type: Pure code
.text$mn:00004130 ; Segment permissions: Read/Execute
.text$mn:00004130 _text$mn        segment para public 'CODE' use32
.text$mn:00004130                 assume cs:_text$mn
.text$mn:00004130                 ;org 4130h
.text$mn:00004130 ; COMDAT (pick any)
.text$mn:00004130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004130
.text$mn:00004130 ; =============== S U B R O U T I N E =======================================
.text$mn:00004130
.text$mn:00004130 ; Attributes: bp-based frame
.text$mn:00004130
.text$mn:00004130 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004130                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00004130 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00004130                                         ; CODE XREF: $LN19_0+14p
.text$mn:00004130                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00004130
.text$mn:00004130 var_8           = dword ptr -8
.text$mn:00004130 var_4           = dword ptr -4
.text$mn:00004130
.text$mn:00004130                 push    ebp
.text$mn:00004131                 mov     ebp, esp
.text$mn:00004133                 sub     esp, 8
.text$mn:00004136                 mov     [ebp+var_4], ecx
.text$mn:00004139                 mov     eax, [ebp+var_4]
.text$mn:0000413C                 cmp     dword ptr [eax+18h], 8
.text$mn:00004140                 jb      short loc_4156
.text$mn:00004142                 mov     ecx, [ebp+var_4]
.text$mn:00004145                 mov     edx, [ecx+4]
.text$mn:00004148                 push    edx
.text$mn:00004149                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000414E                 add     esp, 4
.text$mn:00004151                 mov     [ebp+var_8], eax
.text$mn:00004154                 jmp     short loc_415F
.text$mn:00004156 ; ---------------------------------------------------------------------------
.text$mn:00004156
.text$mn:00004156 loc_4156:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00004156                 mov     eax, [ebp+var_4]
.text$mn:00004159                 add     eax, 4
.text$mn:0000415C                 mov     [ebp+var_8], eax
.text$mn:0000415F
.text$mn:0000415F loc_415F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000415F                 mov     eax, [ebp+var_8]
.text$mn:00004162                 mov     esp, ebp
.text$mn:00004164                 pop     ebp
.text$mn:00004165                 retn
.text$mn:00004165 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00004165
.text$mn:00004165 ; ---------------------------------------------------------------------------
.text$mn:00004166                 align 4
.text$mn:00004166 _text$mn        ends
.text$mn:00004166
.text$mn:00004168 ; ===========================================================================
.text$mn:00004168
.text$mn:00004168 ; Segment type: Pure code
.text$mn:00004168 ; Segment permissions: Read/Execute
.text$mn:00004168 _text$mn        segment para public 'CODE' use32
.text$mn:00004168                 assume cs:_text$mn
.text$mn:00004168                 ;org 4168h
.text$mn:00004168 ; COMDAT (pick any)
.text$mn:00004168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004168
.text$mn:00004168 ; =============== S U B R O U T I N E =======================================
.text$mn:00004168
.text$mn:00004168 ; Attributes: bp-based frame
.text$mn:00004168
.text$mn:00004168 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00004168                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00004168 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00004168                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:00004168                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:00004168
.text$mn:00004168 var_8           = dword ptr -8
.text$mn:00004168 var_4           = dword ptr -4
.text$mn:00004168
.text$mn:00004168                 push    ebp
.text$mn:00004169                 mov     ebp, esp
.text$mn:0000416B                 sub     esp, 8
.text$mn:0000416E                 mov     [ebp+var_4], ecx
.text$mn:00004171                 mov     eax, [ebp+var_4]
.text$mn:00004174                 cmp     dword ptr [eax+18h], 8
.text$mn:00004178                 jb      short loc_418E
.text$mn:0000417A                 mov     ecx, [ebp+var_4]
.text$mn:0000417D                 mov     edx, [ecx+4]
.text$mn:00004180                 push    edx
.text$mn:00004181                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00004186                 add     esp, 4
.text$mn:00004189                 mov     [ebp+var_8], eax
.text$mn:0000418C                 jmp     short loc_4197
.text$mn:0000418E ; ---------------------------------------------------------------------------
.text$mn:0000418E
.text$mn:0000418E loc_418E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000418E                 mov     eax, [ebp+var_4]
.text$mn:00004191                 add     eax, 4
.text$mn:00004194                 mov     [ebp+var_8], eax
.text$mn:00004197
.text$mn:00004197 loc_4197:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00004197                 mov     eax, [ebp+var_8]
.text$mn:0000419A                 mov     esp, ebp
.text$mn:0000419C                 pop     ebp
.text$mn:0000419D                 retn
.text$mn:0000419D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:0000419D
.text$mn:0000419D ; ---------------------------------------------------------------------------
.text$mn:0000419E                 align 10h
.text$mn:0000419E _text$mn        ends
.text$mn:0000419E
.text$mn:000041A0 ; ===========================================================================
.text$mn:000041A0
.text$mn:000041A0 ; Segment type: Pure code
.text$mn:000041A0 ; Segment permissions: Read/Execute
.text$mn:000041A0 _text$mn        segment para public 'CODE' use32
.text$mn:000041A0                 assume cs:_text$mn
.text$mn:000041A0                 ;org 41A0h
.text$mn:000041A0 ; COMDAT (pick any)
.text$mn:000041A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041A0
.text$mn:000041A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000041A0
.text$mn:000041A0 ; Attributes: bp-based frame
.text$mn:000041A0
.text$mn:000041A0 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000041A0                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000041A0 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000041A0                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000041A0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:000041A0
.text$mn:000041A0 var_18          = byte ptr -18h
.text$mn:000041A0 var_14          = dword ptr -14h
.text$mn:000041A0 var_10          = dword ptr -10h
.text$mn:000041A0 var_C           = dword ptr -0Ch
.text$mn:000041A0 var_4           = dword ptr -4
.text$mn:000041A0
.text$mn:000041A0                 push    ebp
.text$mn:000041A1                 mov     ebp, esp
.text$mn:000041A3                 push    0FFFFFFFFh
.text$mn:000041A5                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000041AA                 mov     eax, large fs:0
.text$mn:000041B0                 push    eax
.text$mn:000041B1                 sub     esp, 0Ch
.text$mn:000041B4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041B9                 xor     eax, ebp
.text$mn:000041BB                 push    eax
.text$mn:000041BC                 lea     eax, [ebp+var_C]
.text$mn:000041BF                 mov     large fs:0, eax
.text$mn:000041C5                 mov     [ebp+var_14], ecx
.text$mn:000041C8                 mov     eax, [ebp+var_14]
.text$mn:000041CB                 cmp     dword ptr [eax], 0
.text$mn:000041CE                 jz      short loc_422B
.text$mn:000041D0                 push    3               ; int
.text$mn:000041D2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000041D5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000041DA                 mov     [ebp+var_4], 0
.text$mn:000041E1                 mov     ecx, [ebp+var_14]
.text$mn:000041E4                 mov     edx, [ecx]
.text$mn:000041E6                 add     edx, 4
.text$mn:000041E9                 mov     [ebp+var_10], edx
.text$mn:000041EC                 jmp     short loc_41FB
.text$mn:000041EE ; ---------------------------------------------------------------------------
.text$mn:000041EE
.text$mn:000041EE loc_41EE:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000041EE                 mov     eax, [ebp+var_10]
.text$mn:000041F1                 mov     ecx, [eax]
.text$mn:000041F3                 mov     edx, [ebp+var_10]
.text$mn:000041F6                 mov     eax, [ecx+4]
.text$mn:000041F9                 mov     [edx], eax
.text$mn:000041FB
.text$mn:000041FB loc_41FB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000041FB                 mov     ecx, [ebp+var_10]
.text$mn:000041FE                 cmp     dword ptr [ecx], 0
.text$mn:00004201                 jz      short loc_4210
.text$mn:00004203                 mov     edx, [ebp+var_10]
.text$mn:00004206                 mov     eax, [edx]
.text$mn:00004208                 mov     dword ptr [eax], 0
.text$mn:0000420E                 jmp     short loc_41EE
.text$mn:00004210 ; ---------------------------------------------------------------------------
.text$mn:00004210
.text$mn:00004210 loc_4210:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00004210                 mov     ecx, [ebp+var_14]
.text$mn:00004213                 mov     edx, [ecx]
.text$mn:00004215                 mov     dword ptr [edx+4], 0
.text$mn:0000421C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004223                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004226                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000422B
.text$mn:0000422B loc_422B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:0000422B                 mov     ecx, [ebp+var_C]
.text$mn:0000422E                 mov     large fs:0, ecx
.text$mn:00004235                 pop     ecx
.text$mn:00004236                 mov     esp, ebp
.text$mn:00004238                 pop     ebp
.text$mn:00004239                 retn
.text$mn:00004239 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00004239
.text$mn:00004239 ; ---------------------------------------------------------------------------
.text$mn:0000423A                 align 4
.text$mn:0000423A _text$mn        ends
.text$mn:0000423A
.text$x:0000423C ; ===========================================================================
.text$x:0000423C
.text$x:0000423C ; Segment type: Pure code
.text$x:0000423C ; Segment permissions: Read/Execute
.text$x:0000423C _text$x         segment para public 'CODE' use32
.text$x:0000423C                 assume cs:_text$x
.text$x:0000423C                 ;org 423Ch
.text$x:0000423C ; COMDAT (pick associative to section at 41A0)
.text$x:0000423C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000423C
.text$x:0000423C ; =============== S U B R O U T I N E =======================================
.text$x:0000423C
.text$x:0000423C
.text$x:0000423C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:0000423C                                         ; DATA XREF: .xdata$x:00005890o
.text$x:0000423C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000423F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000423F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000423F
.text$x:00004244
.text$x:00004244 ; =============== S U B R O U T I N E =======================================
.text$x:00004244
.text$x:00004244
.text$x:00004244 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00004244                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00004244
.text$x:00004244 arg_4           = dword ptr  8
.text$x:00004244
.text$x:00004244                 mov     edx, [esp+arg_4]
.text$x:00004248                 lea     eax, [edx+0Ch]
.text$x:0000424B                 mov     ecx, [edx-10h]
.text$x:0000424E                 xor     ecx, eax
.text$x:00004250                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004255                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000425A                 jmp     ___CxxFrameHandler3
.text$x:0000425A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000425A
.text$x:0000425A ; ---------------------------------------------------------------------------
.text$x:0000425F                 align 10h
.text$x:0000425F _text$x         ends
.text$x:0000425F
.text$mn:00004260 ; ===========================================================================
.text$mn:00004260
.text$mn:00004260 ; Segment type: Pure code
.text$mn:00004260 ; Segment permissions: Read/Execute
.text$mn:00004260 _text$mn        segment para public 'CODE' use32
.text$mn:00004260                 assume cs:_text$mn
.text$mn:00004260                 ;org 4260h
.text$mn:00004260 ; COMDAT (pick any)
.text$mn:00004260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004260
.text$mn:00004260 ; =============== S U B R O U T I N E =======================================
.text$mn:00004260
.text$mn:00004260 ; Attributes: bp-based frame
.text$mn:00004260
.text$mn:00004260 ; protected: void __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Orphan_range(struct SwitcherFileInfo *, struct SwitcherFileInfo *)const
.text$mn:00004260                 public ?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z
.text$mn:00004260 ?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z proc near
.text$mn:00004260                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+6Ap
.text$mn:00004260                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+D9p
.text$mn:00004260
.text$mn:00004260 var_18          = byte ptr -18h
.text$mn:00004260 var_14          = dword ptr -14h
.text$mn:00004260 var_10          = dword ptr -10h
.text$mn:00004260 var_C           = dword ptr -0Ch
.text$mn:00004260 var_4           = dword ptr -4
.text$mn:00004260 arg_0           = dword ptr  8
.text$mn:00004260 arg_4           = dword ptr  0Ch
.text$mn:00004260
.text$mn:00004260                 push    ebp
.text$mn:00004261                 mov     ebp, esp
.text$mn:00004263                 push    0FFFFFFFFh
.text$mn:00004265                 push    offset __ehhandler$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z
.text$mn:0000426A                 mov     eax, large fs:0
.text$mn:00004270                 push    eax
.text$mn:00004271                 sub     esp, 0Ch
.text$mn:00004274                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004279                 xor     eax, ebp
.text$mn:0000427B                 push    eax
.text$mn:0000427C                 lea     eax, [ebp+var_C]
.text$mn:0000427F                 mov     large fs:0, eax
.text$mn:00004285                 mov     [ebp+var_14], ecx
.text$mn:00004288                 push    3               ; int
.text$mn:0000428A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000428D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004292                 mov     [ebp+var_4], 0
.text$mn:00004299                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000429C                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:000042A1                 mov     [ebp+var_10], eax
.text$mn:000042A4                 cmp     [ebp+var_10], 0
.text$mn:000042A8                 jz      short loc_42F8
.text$mn:000042AA
.text$mn:000042AA loc_42AA:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *):loc_42F6j
.text$mn:000042AA                 mov     eax, [ebp+var_10]
.text$mn:000042AD                 cmp     dword ptr [eax], 0
.text$mn:000042B0                 jz      short loc_42F8
.text$mn:000042B2                 mov     ecx, [ebp+var_10]
.text$mn:000042B5                 mov     edx, [ecx]
.text$mn:000042B7                 mov     eax, [edx+8]
.text$mn:000042BA                 cmp     eax, [ebp+arg_0]
.text$mn:000042BD                 jb      short loc_42CC
.text$mn:000042BF                 mov     ecx, [ebp+var_10]
.text$mn:000042C2                 mov     edx, [ecx]
.text$mn:000042C4                 mov     eax, [ebp+arg_4]
.text$mn:000042C7                 cmp     eax, [edx+8]
.text$mn:000042CA                 jnb     short loc_42DB
.text$mn:000042CC
.text$mn:000042CC loc_42CC:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+5Dj
.text$mn:000042CC                 mov     ecx, [ebp+var_10]
.text$mn:000042CF                 mov     ecx, [ecx]      ; this
.text$mn:000042D1                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000042D6                 mov     [ebp+var_10], eax
.text$mn:000042D9                 jmp     short loc_42F6
.text$mn:000042DB ; ---------------------------------------------------------------------------
.text$mn:000042DB
.text$mn:000042DB loc_42DB:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+6Aj
.text$mn:000042DB                 mov     edx, [ebp+var_10]
.text$mn:000042DE                 mov     ecx, [edx]      ; this
.text$mn:000042E0                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:000042E5                 mov     eax, [ebp+var_10]
.text$mn:000042E8                 mov     ecx, [eax]      ; this
.text$mn:000042EA                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000042EF                 mov     ecx, [ebp+var_10]
.text$mn:000042F2                 mov     edx, [eax]
.text$mn:000042F4                 mov     [ecx], edx
.text$mn:000042F6
.text$mn:000042F6 loc_42F6:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+79j
.text$mn:000042F6                 jmp     short loc_42AA
.text$mn:000042F8 ; ---------------------------------------------------------------------------
.text$mn:000042F8
.text$mn:000042F8 loc_42F8:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+48j
.text$mn:000042F8                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+50j
.text$mn:000042F8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000042FF                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004302                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004307                 mov     ecx, [ebp+var_C]
.text$mn:0000430A                 mov     large fs:0, ecx
.text$mn:00004311                 pop     ecx
.text$mn:00004312                 mov     esp, ebp
.text$mn:00004314                 pop     ebp
.text$mn:00004315                 retn    8
.text$mn:00004315 ?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z endp
.text$mn:00004315
.text$mn:00004315 _text$mn        ends
.text$mn:00004315
.text$x:00004318 ; ===========================================================================
.text$x:00004318
.text$x:00004318 ; Segment type: Pure code
.text$x:00004318 ; Segment permissions: Read/Execute
.text$x:00004318 _text$x         segment para public 'CODE' use32
.text$x:00004318                 assume cs:_text$x
.text$x:00004318                 ;org 4318h
.text$x:00004318 ; COMDAT (pick associative to section at 4260)
.text$x:00004318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004318
.text$x:00004318 ; =============== S U B R O U T I N E =======================================
.text$x:00004318
.text$x:00004318
.text$x:00004318 __unwindfunclet$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z$0 proc near
.text$x:00004318                                         ; DATA XREF: .xdata$x:00006280o
.text$x:00004318                 lea     ecx, [ebp-18h]  ; this
.text$x:0000431B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000431B __unwindfunclet$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z$0 endp
.text$x:0000431B
.text$x:00004320
.text$x:00004320 ; =============== S U B R O U T I N E =======================================
.text$x:00004320
.text$x:00004320
.text$x:00004320 __ehhandler$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z proc near
.text$x:00004320                                         ; DATA XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+5o
.text$x:00004320
.text$x:00004320 arg_4           = dword ptr  8
.text$x:00004320
.text$x:00004320                 mov     edx, [esp+arg_4]
.text$x:00004324                 lea     eax, [edx+0Ch]
.text$x:00004327                 mov     ecx, [edx-10h]
.text$x:0000432A                 xor     ecx, eax
.text$x:0000432C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004331                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z
.text$x:00004336                 jmp     ___CxxFrameHandler3
.text$x:00004336 __ehhandler$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z endp
.text$x:00004336
.text$x:00004336 ; ---------------------------------------------------------------------------
.text$x:0000433B                 align 4
.text$x:0000433B _text$x         ends
.text$x:0000433B
.text$mn:0000433C ; ===========================================================================
.text$mn:0000433C
.text$mn:0000433C ; Segment type: Pure code
.text$mn:0000433C ; Segment permissions: Read/Execute
.text$mn:0000433C _text$mn        segment para public 'CODE' use32
.text$mn:0000433C                 assume cs:_text$mn
.text$mn:0000433C                 ;org 433Ch
.text$mn:0000433C ; COMDAT (pick any)
.text$mn:0000433C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000433C
.text$mn:0000433C ; =============== S U B R O U T I N E =======================================
.text$mn:0000433C
.text$mn:0000433C ; Attributes: bp-based frame
.text$mn:0000433C
.text$mn:0000433C ; protected: void __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Reallocate(unsigned int)
.text$mn:0000433C                 public ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:0000433C ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z proc near
.text$mn:0000433C                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+4Ep
.text$mn:0000433C
.text$mn:0000433C var_20          = dword ptr -20h
.text$mn:0000433C var_1C          = dword ptr -1Ch
.text$mn:0000433C var_18          = dword ptr -18h
.text$mn:0000433C var_13          = byte ptr -13h
.text$mn:0000433C var_11          = byte ptr -11h
.text$mn:0000433C var_10          = dword ptr -10h
.text$mn:0000433C var_C           = dword ptr -0Ch
.text$mn:0000433C var_4           = dword ptr -4
.text$mn:0000433C arg_0           = dword ptr  8
.text$mn:0000433C
.text$mn:0000433C ; FUNCTION CHUNK AT .text$mn:000043D2 SIZE 00000009 BYTES
.text$mn:0000433C ; FUNCTION CHUNK AT .text$mn:000043E2 SIZE 00000097 BYTES
.text$mn:0000433C
.text$mn:0000433C                 push    ebp
.text$mn:0000433D                 mov     ebp, esp
.text$mn:0000433F                 push    0FFFFFFFFh
.text$mn:00004341                 push    offset __ehhandler$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:00004346                 mov     eax, large fs:0
.text$mn:0000434C                 push    eax
.text$mn:0000434D                 push    ecx
.text$mn:0000434E                 sub     esp, 10h
.text$mn:00004351                 push    ebx
.text$mn:00004352                 push    esi
.text$mn:00004353                 push    edi
.text$mn:00004354                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004359                 xor     eax, ebp
.text$mn:0000435B                 push    eax
.text$mn:0000435C                 lea     eax, [ebp+var_C]
.text$mn:0000435F                 mov     large fs:0, eax
.text$mn:00004365                 mov     [ebp+var_10], esp
.text$mn:00004368                 mov     [ebp+var_18], ecx
.text$mn:0000436B                 mov     eax, [ebp+arg_0]
.text$mn:0000436E                 push    eax
.text$mn:0000436F                 lea     ecx, [ebp+var_11]
.text$mn:00004372                 push    ecx
.text$mn:00004373                 mov     ecx, [ebp+var_18]
.text$mn:00004376                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:0000437B                 mov     ecx, eax
.text$mn:0000437D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEPAUSwitcherFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::allocate(uint)
.text$mn:00004382                 mov     [ebp+var_1C], eax
.text$mn:00004385                 mov     [ebp+var_4], 0
.text$mn:0000438C                 mov     edx, [ebp+var_1C]
.text$mn:0000438F                 push    edx
.text$mn:00004390                 mov     eax, [ebp+var_18]
.text$mn:00004393                 mov     ecx, [eax+8]
.text$mn:00004396                 push    ecx
.text$mn:00004397                 mov     edx, [ebp+var_18]
.text$mn:0000439A                 mov     eax, [edx+4]
.text$mn:0000439D                 push    eax
.text$mn:0000439E                 mov     ecx, [ebp+var_18]
.text$mn:000043A1                 call    ??$_Umove@PAUSwitcherFileInfo@@@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEPAUSwitcherFileInfo@@PAU2@00@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Umove<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *)
.text$mn:000043A6                 jmp     short loc_43D2
.text$mn:000043A6 ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z endp
.text$mn:000043A6
.text$mn:000043A8
.text$mn:000043A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043A8
.text$mn:000043A8 ; Attributes: noreturn
.text$mn:000043A8
.text$mn:000043A8 __catch$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:000043A8                                         ; DATA XREF: .xdata$x:00006230o
.text$mn:000043A8                 mov     ecx, [ebp+8]
.text$mn:000043AB                 push    ecx             ; int
.text$mn:000043AC                 mov     edx, [ebp-1Ch]
.text$mn:000043AF                 push    edx             ; void *
.text$mn:000043B0                 lea     eax, [ebp-12h]
.text$mn:000043B3                 push    eax
.text$mn:000043B4                 mov     ecx, [ebp-18h]
.text$mn:000043B7                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:000043BC                 mov     ecx, eax
.text$mn:000043BE                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::deallocate(SwitcherFileInfo *,uint)
.text$mn:000043C3                 push    0
.text$mn:000043C5                 push    0
.text$mn:000043C7                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000043C7 __catch$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:000043C7
.text$mn:000043CC ; ---------------------------------------------------------------------------
.text$mn:000043CC                 mov     eax, offset $LN8
.text$mn:000043D1                 retn
.text$mn:000043D2 ; ---------------------------------------------------------------------------
.text$mn:000043D2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:000043D2
.text$mn:000043D2 loc_43D2:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+6Aj
.text$mn:000043D2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000043D9                 jmp     short loc_43E2
.text$mn:000043D9 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:000043DB
.text$mn:000043DB ; =============== S U B R O U T I N E =======================================
.text$mn:000043DB
.text$mn:000043DB
.text$mn:000043DB $LN8            proc near               ; DATA XREF: .text$mn:000043CCo
.text$mn:000043DB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000043DB $LN8            endp ; sp-analysis failed
.text$mn:000043DB
.text$mn:000043E2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:000043E2
.text$mn:000043E2 loc_43E2:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+9Dj
.text$mn:000043E2                 mov     ecx, [ebp+var_18]
.text$mn:000043E5                 call    ?size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::size(void)
.text$mn:000043EA                 mov     [ebp+var_20], eax
.text$mn:000043ED                 mov     ecx, [ebp+var_18]
.text$mn:000043F0                 cmp     dword ptr [ecx+4], 0
.text$mn:000043F4                 jz      short loc_4436
.text$mn:000043F6                 mov     edx, [ebp+var_18]
.text$mn:000043F9                 mov     eax, [edx+8]
.text$mn:000043FC                 push    eax
.text$mn:000043FD                 mov     ecx, [ebp+var_18]
.text$mn:00004400                 mov     edx, [ecx+4]
.text$mn:00004403                 push    edx
.text$mn:00004404                 mov     ecx, [ebp+var_18]
.text$mn:00004407                 call    ?_Destroy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXPAUSwitcherFileInfo@@0@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Destroy(SwitcherFileInfo *,SwitcherFileInfo *)
.text$mn:0000440C                 mov     eax, [ebp+var_18]
.text$mn:0000440F                 mov     ecx, [ebp+var_18]
.text$mn:00004412                 mov     edx, [eax+0Ch]
.text$mn:00004415                 sub     edx, [ecx+4]
.text$mn:00004418                 sar     edx, 3
.text$mn:0000441B                 push    edx             ; int
.text$mn:0000441C                 mov     eax, [ebp+var_18]
.text$mn:0000441F                 mov     ecx, [eax+4]
.text$mn:00004422                 push    ecx             ; void *
.text$mn:00004423                 lea     edx, [ebp+var_13]
.text$mn:00004426                 push    edx
.text$mn:00004427                 mov     ecx, [ebp+var_18]
.text$mn:0000442A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:0000442F                 mov     ecx, eax
.text$mn:00004431                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::deallocate(SwitcherFileInfo *,uint)
.text$mn:00004436
.text$mn:00004436 loc_4436:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+B8j
.text$mn:00004436                 mov     ecx, [ebp+var_18] ; this
.text$mn:00004439                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000443E                 mov     eax, [ebp+arg_0]
.text$mn:00004441                 mov     ecx, [ebp+var_1C]
.text$mn:00004444                 lea     edx, [ecx+eax*8]
.text$mn:00004447                 mov     eax, [ebp+var_18]
.text$mn:0000444A                 mov     [eax+0Ch], edx
.text$mn:0000444D                 mov     ecx, [ebp+var_20]
.text$mn:00004450                 mov     edx, [ebp+var_1C]
.text$mn:00004453                 lea     eax, [edx+ecx*8]
.text$mn:00004456                 mov     ecx, [ebp+var_18]
.text$mn:00004459                 mov     [ecx+8], eax
.text$mn:0000445C                 mov     edx, [ebp+var_18]
.text$mn:0000445F                 mov     eax, [ebp+var_1C]
.text$mn:00004462                 mov     [edx+4], eax
.text$mn:00004465                 mov     ecx, [ebp+var_C]
.text$mn:00004468                 mov     large fs:0, ecx
.text$mn:0000446F                 pop     ecx
.text$mn:00004470                 pop     edi
.text$mn:00004471                 pop     esi
.text$mn:00004472                 pop     ebx
.text$mn:00004473                 mov     esp, ebp
.text$mn:00004475                 pop     ebp
.text$mn:00004476                 retn    4
.text$mn:00004476 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:00004476 ; ---------------------------------------------------------------------------
.text$mn:00004479                 align 4
.text$mn:00004479 _text$mn        ends
.text$mn:00004479
.text$x:0000447C ; ===========================================================================
.text$x:0000447C
.text$x:0000447C ; Segment type: Pure code
.text$x:0000447C ; Segment permissions: Read/Execute
.text$x:0000447C _text$x         segment para public 'CODE' use32
.text$x:0000447C                 assume cs:_text$x
.text$x:0000447C                 ;org 447Ch
.text$x:0000447C ; COMDAT (pick associative to section at 433C)
.text$x:0000447C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000447C
.text$x:0000447C ; =============== S U B R O U T I N E =======================================
.text$x:0000447C
.text$x:0000447C
.text$x:0000447C __ehhandler$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z proc near
.text$x:0000447C                                         ; DATA XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+5o
.text$x:0000447C
.text$x:0000447C arg_4           = dword ptr  8
.text$x:0000447C
.text$x:0000447C                 mov     edx, [esp+arg_4]
.text$x:00004480                 lea     eax, [edx+0Ch]
.text$x:00004483                 mov     ecx, [edx-24h]
.text$x:00004486                 xor     ecx, eax
.text$x:00004488                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000448D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$x:00004492                 jmp     ___CxxFrameHandler3
.text$x:00004492 __ehhandler$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z endp
.text$x:00004492
.text$x:00004492 ; ---------------------------------------------------------------------------
.text$x:00004497                 align 4
.text$x:00004497 _text$x         ends
.text$x:00004497
.text$mn:00004498 ; ===========================================================================
.text$mn:00004498
.text$mn:00004498 ; Segment type: Pure code
.text$mn:00004498 ; Segment permissions: Read/Execute
.text$mn:00004498 _text$mn        segment para public 'CODE' use32
.text$mn:00004498                 assume cs:_text$mn
.text$mn:00004498                 ;org 4498h
.text$mn:00004498 ; COMDAT (pick any)
.text$mn:00004498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004498
.text$mn:00004498 ; =============== S U B R O U T I N E =======================================
.text$mn:00004498
.text$mn:00004498 ; Attributes: bp-based frame
.text$mn:00004498
.text$mn:00004498 ; protected: void __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Reserve(unsigned int)
.text$mn:00004498                 public ?_Reserve@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.text$mn:00004498 ?_Reserve@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z proc near
.text$mn:00004498                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+54p
.text$mn:00004498                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+C3p
.text$mn:00004498
.text$mn:00004498 var_4           = dword ptr -4
.text$mn:00004498 arg_0           = dword ptr  8
.text$mn:00004498
.text$mn:00004498                 push    ebp
.text$mn:00004499                 mov     ebp, esp
.text$mn:0000449B                 push    ecx
.text$mn:0000449C                 push    esi
.text$mn:0000449D                 mov     [ebp+var_4], ecx
.text$mn:000044A0                 mov     ecx, [ebp+var_4]
.text$mn:000044A3                 call    ?_Unused_capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Unused_capacity(void)
.text$mn:000044A8                 cmp     eax, [ebp+arg_0]
.text$mn:000044AB                 jnb     short loc_44EB
.text$mn:000044AD                 mov     ecx, [ebp+var_4]
.text$mn:000044B0                 call    ?max_size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::max_size(void)
.text$mn:000044B5                 mov     esi, eax
.text$mn:000044B7                 mov     ecx, [ebp+var_4]
.text$mn:000044BA                 call    ?size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::size(void)
.text$mn:000044BF                 sub     esi, eax
.text$mn:000044C1                 cmp     esi, [ebp+arg_0]
.text$mn:000044C4                 jnb     short loc_44CE
.text$mn:000044C6                 mov     ecx, [ebp+var_4]
.text$mn:000044C9                 call    ?_Xlen@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Xlen(void)
.text$mn:000044CE
.text$mn:000044CE loc_44CE:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+2Cj
.text$mn:000044CE                 mov     ecx, [ebp+var_4]
.text$mn:000044D1                 call    ?size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::size(void)
.text$mn:000044D6                 add     eax, [ebp+arg_0]
.text$mn:000044D9                 push    eax
.text$mn:000044DA                 mov     ecx, [ebp+var_4]
.text$mn:000044DD                 call    ?_Grow_to@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEII@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Grow_to(uint)
.text$mn:000044E2                 push    eax
.text$mn:000044E3                 mov     ecx, [ebp+var_4]
.text$mn:000044E6                 call    ?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)
.text$mn:000044EB
.text$mn:000044EB loc_44EB:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+13j
.text$mn:000044EB                 pop     esi
.text$mn:000044EC                 mov     esp, ebp
.text$mn:000044EE                 pop     ebp
.text$mn:000044EF                 retn    4
.text$mn:000044EF ?_Reserve@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z endp
.text$mn:000044EF
.text$mn:000044EF ; ---------------------------------------------------------------------------
.text$mn:000044F2                 align 4
.text$mn:000044F2 _text$mn        ends
.text$mn:000044F2
.text$mn:000044F4 ; ===========================================================================
.text$mn:000044F4
.text$mn:000044F4 ; Segment type: Pure code
.text$mn:000044F4 ; Segment permissions: Read/Execute
.text$mn:000044F4 _text$mn        segment para public 'CODE' use32
.text$mn:000044F4                 assume cs:_text$mn
.text$mn:000044F4                 ;org 44F4h
.text$mn:000044F4 ; COMDAT (pick any)
.text$mn:000044F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044F4
.text$mn:000044F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000044F4
.text$mn:000044F4 ; Attributes: bp-based frame
.text$mn:000044F4
.text$mn:000044F4 ; void __thiscall std::_Container_base12::_Swap_all(std::_Container_base12 *this, struct std::_Container_base12 *)
.text$mn:000044F4                 public ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:000044F4 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$mn:000044F4                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Assign_rv(std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>> &&,std::integral_constant<bool,1>)+Ep
.text$mn:000044F4
.text$mn:000044F4 var_18          = byte ptr -18h
.text$mn:000044F4 var_14          = dword ptr -14h
.text$mn:000044F4 var_10          = dword ptr -10h
.text$mn:000044F4 var_C           = dword ptr -0Ch
.text$mn:000044F4 var_4           = dword ptr -4
.text$mn:000044F4 arg_0           = dword ptr  8
.text$mn:000044F4
.text$mn:000044F4                 push    ebp
.text$mn:000044F5                 mov     ebp, esp
.text$mn:000044F7                 push    0FFFFFFFFh
.text$mn:000044F9                 push    offset __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:000044FE                 mov     eax, large fs:0
.text$mn:00004504                 push    eax
.text$mn:00004505                 sub     esp, 0Ch
.text$mn:00004508                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000450D                 xor     eax, ebp
.text$mn:0000450F                 push    eax
.text$mn:00004510                 lea     eax, [ebp+var_C]
.text$mn:00004513                 mov     large fs:0, eax
.text$mn:00004519                 mov     [ebp+var_10], ecx
.text$mn:0000451C                 push    3               ; int
.text$mn:0000451E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004521                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004526                 mov     [ebp+var_4], 0
.text$mn:0000452D                 mov     eax, [ebp+var_10]
.text$mn:00004530                 mov     ecx, [eax]
.text$mn:00004532                 mov     [ebp+var_14], ecx
.text$mn:00004535                 mov     edx, [ebp+var_10]
.text$mn:00004538                 mov     eax, [ebp+arg_0]
.text$mn:0000453B                 mov     ecx, [eax]
.text$mn:0000453D                 mov     [edx], ecx
.text$mn:0000453F                 mov     edx, [ebp+arg_0]
.text$mn:00004542                 mov     eax, [ebp+var_14]
.text$mn:00004545                 mov     [edx], eax
.text$mn:00004547                 mov     ecx, [ebp+var_10]
.text$mn:0000454A                 cmp     dword ptr [ecx], 0
.text$mn:0000454D                 jz      short loc_4559
.text$mn:0000454F                 mov     edx, [ebp+var_10]
.text$mn:00004552                 mov     eax, [edx]
.text$mn:00004554                 mov     ecx, [ebp+var_10]
.text$mn:00004557                 mov     [eax], ecx
.text$mn:00004559
.text$mn:00004559 loc_4559:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+59j
.text$mn:00004559                 mov     edx, [ebp+arg_0]
.text$mn:0000455C                 cmp     dword ptr [edx], 0
.text$mn:0000455F                 jz      short loc_456B
.text$mn:00004561                 mov     eax, [ebp+arg_0]
.text$mn:00004564                 mov     ecx, [eax]
.text$mn:00004566                 mov     edx, [ebp+arg_0]
.text$mn:00004569                 mov     [ecx], edx
.text$mn:0000456B
.text$mn:0000456B loc_456B:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+6Bj
.text$mn:0000456B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004572                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004575                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000457A                 mov     ecx, [ebp+var_C]
.text$mn:0000457D                 mov     large fs:0, ecx
.text$mn:00004584                 pop     ecx
.text$mn:00004585                 mov     esp, ebp
.text$mn:00004587                 pop     ebp
.text$mn:00004588                 retn    4
.text$mn:00004588 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$mn:00004588
.text$mn:00004588 ; ---------------------------------------------------------------------------
.text$mn:0000458B                 align 4
.text$mn:0000458B _text$mn        ends
.text$mn:0000458B
.text$x:0000458C ; ===========================================================================
.text$x:0000458C
.text$x:0000458C ; Segment type: Pure code
.text$x:0000458C ; Segment permissions: Read/Execute
.text$x:0000458C _text$x         segment para public 'CODE' use32
.text$x:0000458C                 assume cs:_text$x
.text$x:0000458C                 ;org 458Ch
.text$x:0000458C ; COMDAT (pick associative to section at 44F4)
.text$x:0000458C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000458C
.text$x:0000458C ; =============== S U B R O U T I N E =======================================
.text$x:0000458C
.text$x:0000458C
.text$x:0000458C __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 proc near
.text$x:0000458C                                         ; DATA XREF: .xdata$x:000058BCo
.text$x:0000458C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000458F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000458F __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 endp
.text$x:0000458F
.text$x:00004594
.text$x:00004594 ; =============== S U B R O U T I N E =======================================
.text$x:00004594
.text$x:00004594
.text$x:00004594 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$x:00004594                                         ; DATA XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+5o
.text$x:00004594
.text$x:00004594 arg_4           = dword ptr  8
.text$x:00004594
.text$x:00004594                 mov     edx, [esp+arg_4]
.text$x:00004598                 lea     eax, [edx+0Ch]
.text$x:0000459B                 mov     ecx, [edx-10h]
.text$x:0000459E                 xor     ecx, eax
.text$x:000045A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000045A5                 mov     eax, offset __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$x:000045AA                 jmp     ___CxxFrameHandler3
.text$x:000045AA __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$x:000045AA
.text$x:000045AA ; ---------------------------------------------------------------------------
.text$x:000045AF                 align 10h
.text$x:000045AF _text$x         ends
.text$x:000045AF
.text$mn:000045B0 ; ===========================================================================
.text$mn:000045B0
.text$mn:000045B0 ; Segment type: Pure code
.text$mn:000045B0 ; Segment permissions: Read/Execute
.text$mn:000045B0 _text$mn        segment para public 'CODE' use32
.text$mn:000045B0                 assume cs:_text$mn
.text$mn:000045B0                 ;org 45B0h
.text$mn:000045B0 ; COMDAT (pick any)
.text$mn:000045B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045B0
.text$mn:000045B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000045B0
.text$mn:000045B0 ; Attributes: bp-based frame
.text$mn:000045B0
.text$mn:000045B0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000045B0                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000045B0 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000045B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000045B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000045B0
.text$mn:000045B0 var_C           = dword ptr -0Ch
.text$mn:000045B0 var_8           = dword ptr -8
.text$mn:000045B0 var_2           = byte ptr -2
.text$mn:000045B0 var_1           = byte ptr -1
.text$mn:000045B0 arg_0           = byte ptr  8
.text$mn:000045B0 Size            = dword ptr  0Ch
.text$mn:000045B0
.text$mn:000045B0                 push    ebp
.text$mn:000045B1                 mov     ebp, esp
.text$mn:000045B3                 sub     esp, 0Ch
.text$mn:000045B6                 mov     [ebp+var_8], ecx
.text$mn:000045B9                 movzx   eax, [ebp+arg_0]
.text$mn:000045BD                 test    eax, eax
.text$mn:000045BF                 jnz     short loc_45C3
.text$mn:000045C1                 jmp     short loc_4636
.text$mn:000045C3 ; ---------------------------------------------------------------------------
.text$mn:000045C3
.text$mn:000045C3 loc_45C3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000045C3                 mov     ecx, [ebp+var_8]
.text$mn:000045C6                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000045CA                 jb      short loc_4636
.text$mn:000045CC                 mov     edx, [ebp+var_8]
.text$mn:000045CF                 mov     eax, [edx+4]
.text$mn:000045D2                 mov     [ebp+var_C], eax
.text$mn:000045D5                 mov     ecx, [ebp+var_8]
.text$mn:000045D8                 add     ecx, 4
.text$mn:000045DB                 push    ecx
.text$mn:000045DC                 lea     edx, [ebp+var_1]
.text$mn:000045DF                 push    edx
.text$mn:000045E0                 mov     ecx, [ebp+var_8]
.text$mn:000045E3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000045E8                 mov     ecx, eax
.text$mn:000045EA                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000045EF                 cmp     [ebp+Size], 0
.text$mn:000045F3                 jbe     short loc_4615
.text$mn:000045F5                 mov     eax, [ebp+Size]
.text$mn:000045F8                 push    eax             ; Size
.text$mn:000045F9                 mov     ecx, [ebp+var_C]
.text$mn:000045FC                 push    ecx
.text$mn:000045FD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004602                 add     esp, 4
.text$mn:00004605                 push    eax             ; Src
.text$mn:00004606                 mov     edx, [ebp+var_8]
.text$mn:00004609                 add     edx, 4
.text$mn:0000460C                 push    edx             ; Dst
.text$mn:0000460D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004612                 add     esp, 0Ch
.text$mn:00004615
.text$mn:00004615 loc_4615:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00004615                 mov     eax, [ebp+var_8]
.text$mn:00004618                 mov     ecx, [eax+18h]
.text$mn:0000461B                 add     ecx, 1
.text$mn:0000461E                 push    ecx             ; int
.text$mn:0000461F                 mov     edx, [ebp+var_C]
.text$mn:00004622                 push    edx             ; void *
.text$mn:00004623                 lea     eax, [ebp+var_2]
.text$mn:00004626                 push    eax
.text$mn:00004627                 mov     ecx, [ebp+var_8]
.text$mn:0000462A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000462F                 mov     ecx, eax
.text$mn:00004631                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00004636
.text$mn:00004636 loc_4636:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00004636                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00004636                 mov     ecx, [ebp+var_8]
.text$mn:00004639                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00004640                 mov     edx, [ebp+Size]
.text$mn:00004643                 push    edx
.text$mn:00004644                 mov     ecx, [ebp+var_8]
.text$mn:00004647                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000464C                 mov     esp, ebp
.text$mn:0000464E                 pop     ebp
.text$mn:0000464F                 retn    8
.text$mn:0000464F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000464F
.text$mn:0000464F ; ---------------------------------------------------------------------------
.text$mn:00004652                 align 4
.text$mn:00004652 _text$mn        ends
.text$mn:00004652
.text$mn:00004654 ; ===========================================================================
.text$mn:00004654
.text$mn:00004654 ; Segment type: Pure code
.text$mn:00004654 ; Segment permissions: Read/Execute
.text$mn:00004654 _text$mn        segment para public 'CODE' use32
.text$mn:00004654                 assume cs:_text$mn
.text$mn:00004654                 ;org 4654h
.text$mn:00004654 ; COMDAT (pick any)
.text$mn:00004654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004654
.text$mn:00004654 ; =============== S U B R O U T I N E =======================================
.text$mn:00004654
.text$mn:00004654 ; Attributes: bp-based frame
.text$mn:00004654
.text$mn:00004654 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00004654                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00004654 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00004654                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p
.text$mn:00004654                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p ...
.text$mn:00004654
.text$mn:00004654 var_C           = dword ptr -0Ch
.text$mn:00004654 var_8           = dword ptr -8
.text$mn:00004654 var_2           = byte ptr -2
.text$mn:00004654 var_1           = byte ptr -1
.text$mn:00004654 arg_0           = byte ptr  8
.text$mn:00004654 arg_4           = dword ptr  0Ch
.text$mn:00004654
.text$mn:00004654                 push    ebp
.text$mn:00004655                 mov     ebp, esp
.text$mn:00004657                 sub     esp, 0Ch
.text$mn:0000465A                 mov     [ebp+var_8], ecx
.text$mn:0000465D                 movzx   eax, [ebp+arg_0]
.text$mn:00004661                 test    eax, eax
.text$mn:00004663                 jnz     short loc_4667
.text$mn:00004665                 jmp     short loc_46DA
.text$mn:00004667 ; ---------------------------------------------------------------------------
.text$mn:00004667
.text$mn:00004667 loc_4667:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00004667                 mov     ecx, [ebp+var_8]
.text$mn:0000466A                 cmp     dword ptr [ecx+18h], 8
.text$mn:0000466E                 jb      short loc_46DA
.text$mn:00004670                 mov     edx, [ebp+var_8]
.text$mn:00004673                 mov     eax, [edx+4]
.text$mn:00004676                 mov     [ebp+var_C], eax
.text$mn:00004679                 mov     ecx, [ebp+var_8]
.text$mn:0000467C                 add     ecx, 4
.text$mn:0000467F                 push    ecx
.text$mn:00004680                 lea     edx, [ebp+var_1]
.text$mn:00004683                 push    edx
.text$mn:00004684                 mov     ecx, [ebp+var_8]
.text$mn:00004687                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000468C                 mov     ecx, eax
.text$mn:0000468E                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00004693                 cmp     [ebp+arg_4], 0
.text$mn:00004697                 jbe     short loc_46B9
.text$mn:00004699                 mov     eax, [ebp+arg_4]
.text$mn:0000469C                 push    eax             ; int
.text$mn:0000469D                 mov     ecx, [ebp+var_C]
.text$mn:000046A0                 push    ecx
.text$mn:000046A1                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000046A6                 add     esp, 4
.text$mn:000046A9                 push    eax             ; Src
.text$mn:000046AA                 mov     edx, [ebp+var_8]
.text$mn:000046AD                 add     edx, 4
.text$mn:000046B0                 push    edx             ; Dst
.text$mn:000046B1                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000046B6                 add     esp, 0Ch
.text$mn:000046B9
.text$mn:000046B9 loc_46B9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:000046B9                 mov     eax, [ebp+var_8]
.text$mn:000046BC                 mov     ecx, [eax+18h]
.text$mn:000046BF                 add     ecx, 1
.text$mn:000046C2                 push    ecx             ; int
.text$mn:000046C3                 mov     edx, [ebp+var_C]
.text$mn:000046C6                 push    edx             ; void *
.text$mn:000046C7                 lea     eax, [ebp+var_2]
.text$mn:000046CA                 push    eax
.text$mn:000046CB                 mov     ecx, [ebp+var_8]
.text$mn:000046CE                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000046D3                 mov     ecx, eax
.text$mn:000046D5                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:000046DA
.text$mn:000046DA loc_46DA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:000046DA                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:000046DA                 mov     ecx, [ebp+var_8]
.text$mn:000046DD                 mov     dword ptr [ecx+18h], 7
.text$mn:000046E4                 mov     edx, [ebp+arg_4]
.text$mn:000046E7                 push    edx
.text$mn:000046E8                 mov     ecx, [ebp+var_8]
.text$mn:000046EB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000046F0                 mov     esp, ebp
.text$mn:000046F2                 pop     ebp
.text$mn:000046F3                 retn    8
.text$mn:000046F3 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:000046F3
.text$mn:000046F3 ; ---------------------------------------------------------------------------
.text$mn:000046F6                 align 4
.text$mn:000046F6 _text$mn        ends
.text$mn:000046F6
.text$mn:000046F8 ; ===========================================================================
.text$mn:000046F8
.text$mn:000046F8 ; Segment type: Pure code
.text$mn:000046F8 ; Segment permissions: Read/Execute
.text$mn:000046F8 _text$mn        segment para public 'CODE' use32
.text$mn:000046F8                 assume cs:_text$mn
.text$mn:000046F8                 ;org 46F8h
.text$mn:000046F8 ; COMDAT (pick any)
.text$mn:000046F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046F8
.text$mn:000046F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046F8
.text$mn:000046F8 ; Attributes: bp-based frame
.text$mn:000046F8
.text$mn:000046F8 ; protected: void __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Tidy(void)
.text$mn:000046F8                 public ?_Tidy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXXZ
.text$mn:000046F8 ?_Tidy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXXZ proc near
.text$mn:000046F8                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::~vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>(void)+30p
.text$mn:000046F8
.text$mn:000046F8 var_8           = dword ptr -8
.text$mn:000046F8 var_1           = byte ptr -1
.text$mn:000046F8
.text$mn:000046F8                 push    ebp
.text$mn:000046F9                 mov     ebp, esp
.text$mn:000046FB                 sub     esp, 8
.text$mn:000046FE                 mov     [ebp+var_8], ecx
.text$mn:00004701                 mov     eax, [ebp+var_8]
.text$mn:00004704                 cmp     dword ptr [eax+4], 0
.text$mn:00004708                 jz      short loc_4770
.text$mn:0000470A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000470D                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004712                 mov     ecx, [ebp+var_8]
.text$mn:00004715                 mov     edx, [ecx+8]
.text$mn:00004718                 push    edx
.text$mn:00004719                 mov     eax, [ebp+var_8]
.text$mn:0000471C                 mov     ecx, [eax+4]
.text$mn:0000471F                 push    ecx
.text$mn:00004720                 mov     ecx, [ebp+var_8]
.text$mn:00004723                 call    ?_Destroy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXPAUSwitcherFileInfo@@0@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Destroy(SwitcherFileInfo *,SwitcherFileInfo *)
.text$mn:00004728                 mov     edx, [ebp+var_8]
.text$mn:0000472B                 mov     eax, [ebp+var_8]
.text$mn:0000472E                 mov     ecx, [edx+0Ch]
.text$mn:00004731                 sub     ecx, [eax+4]
.text$mn:00004734                 sar     ecx, 3
.text$mn:00004737                 push    ecx             ; int
.text$mn:00004738                 mov     edx, [ebp+var_8]
.text$mn:0000473B                 mov     eax, [edx+4]
.text$mn:0000473E                 push    eax             ; void *
.text$mn:0000473F                 lea     ecx, [ebp+var_1]
.text$mn:00004742                 push    ecx
.text$mn:00004743                 mov     ecx, [ebp+var_8]
.text$mn:00004746                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:0000474B                 mov     ecx, eax
.text$mn:0000474D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@I@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::deallocate(SwitcherFileInfo *,uint)
.text$mn:00004752                 mov     edx, [ebp+var_8]
.text$mn:00004755                 mov     dword ptr [edx+4], 0
.text$mn:0000475C                 mov     eax, [ebp+var_8]
.text$mn:0000475F                 mov     dword ptr [eax+8], 0
.text$mn:00004766                 mov     ecx, [ebp+var_8]
.text$mn:00004769                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00004770
.text$mn:00004770 loc_4770:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Tidy(void)+10j
.text$mn:00004770                 mov     esp, ebp
.text$mn:00004772                 pop     ebp
.text$mn:00004773                 retn
.text$mn:00004773 ?_Tidy@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXXZ endp
.text$mn:00004773
.text$mn:00004773 _text$mn        ends
.text$mn:00004773
.text$mn:00004774 ; ===========================================================================
.text$mn:00004774
.text$mn:00004774 ; Segment type: Pure code
.text$mn:00004774 ; Segment permissions: Read/Execute
.text$mn:00004774 _text$mn        segment para public 'CODE' use32
.text$mn:00004774                 assume cs:_text$mn
.text$mn:00004774                 ;org 4774h
.text$mn:00004774 ; COMDAT (pick any)
.text$mn:00004774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004774
.text$mn:00004774 ; =============== S U B R O U T I N E =======================================
.text$mn:00004774
.text$mn:00004774 ; Attributes: bp-based frame
.text$mn:00004774
.text$mn:00004774 ; protected: void __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::_Tidy(void)
.text$mn:00004774                 public ?_Tidy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXXZ
.text$mn:00004774 ?_Tidy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXXZ proc near
.text$mn:00004774                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::~vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>(void)+30p
.text$mn:00004774
.text$mn:00004774 var_8           = dword ptr -8
.text$mn:00004774 var_1           = byte ptr -1
.text$mn:00004774
.text$mn:00004774                 push    ebp
.text$mn:00004775                 mov     ebp, esp
.text$mn:00004777                 sub     esp, 8
.text$mn:0000477A                 mov     [ebp+var_8], ecx
.text$mn:0000477D                 mov     eax, [ebp+var_8]
.text$mn:00004780                 cmp     dword ptr [eax+4], 0
.text$mn:00004784                 jz      short loc_47F3
.text$mn:00004786                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004789                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000478E                 mov     ecx, [ebp+var_8]
.text$mn:00004791                 mov     edx, [ecx+8]
.text$mn:00004794                 push    edx
.text$mn:00004795                 mov     eax, [ebp+var_8]
.text$mn:00004798                 mov     ecx, [eax+4]
.text$mn:0000479B                 push    ecx
.text$mn:0000479C                 mov     ecx, [ebp+var_8]
.text$mn:0000479F                 call    ?_Destroy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXPAUTaskLstFnStatus@@0@Z ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Destroy(TaskLstFnStatus *,TaskLstFnStatus *)
.text$mn:000047A4                 mov     edx, [ebp+var_8]
.text$mn:000047A7                 mov     eax, [ebp+var_8]
.text$mn:000047AA                 mov     ecx, [edx+0Ch]
.text$mn:000047AD                 sub     ecx, [eax+4]
.text$mn:000047B0                 mov     eax, ecx
.text$mn:000047B2                 cdq
.text$mn:000047B3                 mov     ecx, 2Ch ; ','
.text$mn:000047B8                 idiv    ecx
.text$mn:000047BA                 push    eax             ; int
.text$mn:000047BB                 mov     edx, [ebp+var_8]
.text$mn:000047BE                 mov     eax, [edx+4]
.text$mn:000047C1                 push    eax             ; void *
.text$mn:000047C2                 lea     ecx, [ebp+var_1]
.text$mn:000047C5                 push    ecx
.text$mn:000047C6                 mov     ecx, [ebp+var_8]
.text$mn:000047C9                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Getal(void)
.text$mn:000047CE                 mov     ecx, eax
.text$mn:000047D0                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@I@Z ; std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>::deallocate(TaskLstFnStatus *,uint)
.text$mn:000047D5                 mov     edx, [ebp+var_8]
.text$mn:000047D8                 mov     dword ptr [edx+4], 0
.text$mn:000047DF                 mov     eax, [ebp+var_8]
.text$mn:000047E2                 mov     dword ptr [eax+8], 0
.text$mn:000047E9                 mov     ecx, [ebp+var_8]
.text$mn:000047EC                 mov     dword ptr [ecx+0Ch], 0
.text$mn:000047F3
.text$mn:000047F3 loc_47F3:                               ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Tidy(void)+10j
.text$mn:000047F3                 mov     esp, ebp
.text$mn:000047F5                 pop     ebp
.text$mn:000047F6                 retn
.text$mn:000047F6 ?_Tidy@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@IAEXXZ endp
.text$mn:000047F6
.text$mn:000047F6 ; ---------------------------------------------------------------------------
.text$mn:000047F7                 align 4
.text$mn:000047F7 _text$mn        ends
.text$mn:000047F7
.text$mn:000047F8 ; ===========================================================================
.text$mn:000047F8
.text$mn:000047F8 ; Segment type: Pure code
.text$mn:000047F8 ; Segment permissions: Read/Execute
.text$mn:000047F8 _text$mn        segment para public 'CODE' use32
.text$mn:000047F8                 assume cs:_text$mn
.text$mn:000047F8                 ;org 47F8h
.text$mn:000047F8 ; COMDAT (pick any)
.text$mn:000047F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047F8
.text$mn:000047F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000047F8
.text$mn:000047F8 ; Attributes: bp-based frame
.text$mn:000047F8
.text$mn:000047F8 ; public: unsigned int __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Unused_capacity(void)const
.text$mn:000047F8                 public ?_Unused_capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ
.text$mn:000047F8 ?_Unused_capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:000047F8                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+Bp
.text$mn:000047F8
.text$mn:000047F8 var_4           = dword ptr -4
.text$mn:000047F8
.text$mn:000047F8                 push    ebp
.text$mn:000047F9                 mov     ebp, esp
.text$mn:000047FB                 push    ecx
.text$mn:000047FC                 mov     [ebp+var_4], ecx
.text$mn:000047FF                 mov     eax, [ebp+var_4]
.text$mn:00004802                 mov     ecx, [ebp+var_4]
.text$mn:00004805                 mov     eax, [eax+0Ch]
.text$mn:00004808                 sub     eax, [ecx+8]
.text$mn:0000480B                 sar     eax, 3
.text$mn:0000480E                 mov     esp, ebp
.text$mn:00004810                 pop     ebp
.text$mn:00004811                 retn
.text$mn:00004811 ?_Unused_capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:00004811
.text$mn:00004811 ; ---------------------------------------------------------------------------
.text$mn:00004812                 align 4
.text$mn:00004812 _text$mn        ends
.text$mn:00004812
.text$mn:00004814 ; ===========================================================================
.text$mn:00004814
.text$mn:00004814 ; Segment type: Pure code
.text$mn:00004814 ; Segment permissions: Read/Execute
.text$mn:00004814 _text$mn        segment para public 'CODE' use32
.text$mn:00004814                 assume cs:_text$mn
.text$mn:00004814                 ;org 4814h
.text$mn:00004814 ; COMDAT (pick any)
.text$mn:00004814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004814
.text$mn:00004814 ; =============== S U B R O U T I N E =======================================
.text$mn:00004814
.text$mn:00004814 ; Attributes: bp-based frame
.text$mn:00004814
.text$mn:00004814 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00004814                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00004814 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00004814                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00004814
.text$mn:00004814 var_4           = dword ptr -4
.text$mn:00004814
.text$mn:00004814                 push    ebp
.text$mn:00004815                 mov     ebp, esp
.text$mn:00004817                 push    ecx
.text$mn:00004818                 mov     [ebp+var_4], ecx
.text$mn:0000481B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00004820                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00004825                 mov     esp, ebp
.text$mn:00004827                 pop     ebp
.text$mn:00004828                 retn
.text$mn:00004828 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00004828
.text$mn:00004828 ; ---------------------------------------------------------------------------
.text$mn:00004829                 align 4
.text$mn:00004829 _text$mn        ends
.text$mn:00004829
.text$mn:0000482C ; ===========================================================================
.text$mn:0000482C
.text$mn:0000482C ; Segment type: Pure code
.text$mn:0000482C ; Segment permissions: Read/Execute
.text$mn:0000482C _text$mn        segment para public 'CODE' use32
.text$mn:0000482C                 assume cs:_text$mn
.text$mn:0000482C                 ;org 482Ch
.text$mn:0000482C ; COMDAT (pick any)
.text$mn:0000482C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000482C
.text$mn:0000482C ; =============== S U B R O U T I N E =======================================
.text$mn:0000482C
.text$mn:0000482C ; Attributes: bp-based frame
.text$mn:0000482C
.text$mn:0000482C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000482C                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000482C ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000482C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:0000482C
.text$mn:0000482C var_4           = dword ptr -4
.text$mn:0000482C
.text$mn:0000482C                 push    ebp
.text$mn:0000482D                 mov     ebp, esp
.text$mn:0000482F                 push    ecx
.text$mn:00004830                 mov     [ebp+var_4], ecx
.text$mn:00004833                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00004838                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000483D                 mov     esp, ebp
.text$mn:0000483F                 pop     ebp
.text$mn:00004840                 retn
.text$mn:00004840 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00004840
.text$mn:00004840 ; ---------------------------------------------------------------------------
.text$mn:00004841                 align 4
.text$mn:00004841 _text$mn        ends
.text$mn:00004841
.text$mn:00004844 ; ===========================================================================
.text$mn:00004844
.text$mn:00004844 ; Segment type: Pure code
.text$mn:00004844 ; Segment permissions: Read/Execute
.text$mn:00004844 _text$mn        segment para public 'CODE' use32
.text$mn:00004844                 assume cs:_text$mn
.text$mn:00004844                 ;org 4844h
.text$mn:00004844 ; COMDAT (pick any)
.text$mn:00004844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004844
.text$mn:00004844 ; =============== S U B R O U T I N E =======================================
.text$mn:00004844
.text$mn:00004844 ; Attributes: bp-based frame
.text$mn:00004844
.text$mn:00004844 ; protected: void __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::_Xlen(void)const
.text$mn:00004844                 public ?_Xlen@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXXZ
.text$mn:00004844 ?_Xlen@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXXZ proc near
.text$mn:00004844                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+31p
.text$mn:00004844
.text$mn:00004844 var_4           = dword ptr -4
.text$mn:00004844
.text$mn:00004844                 push    ebp
.text$mn:00004845                 mov     ebp, esp
.text$mn:00004847                 push    ecx
.text$mn:00004848                 mov     [ebp+var_4], ecx
.text$mn:0000484B                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00004850                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00004855                 mov     esp, ebp
.text$mn:00004857                 pop     ebp
.text$mn:00004858                 retn
.text$mn:00004858 ?_Xlen@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXXZ endp
.text$mn:00004858
.text$mn:00004858 ; ---------------------------------------------------------------------------
.text$mn:00004859                 align 4
.text$mn:00004859 _text$mn        ends
.text$mn:00004859
.text$mn:0000485C ; ===========================================================================
.text$mn:0000485C
.text$mn:0000485C ; Segment type: Pure code
.text$mn:0000485C ; Segment permissions: Read/Execute
.text$mn:0000485C _text$mn        segment para public 'CODE' use32
.text$mn:0000485C                 assume cs:_text$mn
.text$mn:0000485C                 ;org 485Ch
.text$mn:0000485C ; COMDAT (pick any)
.text$mn:0000485C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000485C
.text$mn:0000485C ; =============== S U B R O U T I N E =======================================
.text$mn:0000485C
.text$mn:0000485C ; Attributes: bp-based frame
.text$mn:0000485C
.text$mn:0000485C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:0000485C                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000485C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000485C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:0000485C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:0000485C
.text$mn:0000485C var_4           = dword ptr -4
.text$mn:0000485C
.text$mn:0000485C                 push    ebp
.text$mn:0000485D                 mov     ebp, esp
.text$mn:0000485F                 push    ecx
.text$mn:00004860                 mov     [ebp+var_4], ecx
.text$mn:00004863                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00004868                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000486D                 mov     esp, ebp
.text$mn:0000486F                 pop     ebp
.text$mn:00004870                 retn
.text$mn:00004870 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00004870
.text$mn:00004870 ; ---------------------------------------------------------------------------
.text$mn:00004871                 align 4
.text$mn:00004871 _text$mn        ends
.text$mn:00004871
.text$mn:00004874 ; ===========================================================================
.text$mn:00004874
.text$mn:00004874 ; Segment type: Pure code
.text$mn:00004874 ; Segment permissions: Read/Execute
.text$mn:00004874 _text$mn        segment para public 'CODE' use32
.text$mn:00004874                 assume cs:_text$mn
.text$mn:00004874                 ;org 4874h
.text$mn:00004874 ; COMDAT (pick any)
.text$mn:00004874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004874
.text$mn:00004874 ; =============== S U B R O U T I N E =======================================
.text$mn:00004874
.text$mn:00004874 ; Attributes: bp-based frame
.text$mn:00004874
.text$mn:00004874 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00004874                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00004874 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00004874                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00004874                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+15p ...
.text$mn:00004874
.text$mn:00004874 var_4           = dword ptr -4
.text$mn:00004874
.text$mn:00004874                 push    ebp
.text$mn:00004875                 mov     ebp, esp
.text$mn:00004877                 push    ecx
.text$mn:00004878                 mov     [ebp+var_4], ecx
.text$mn:0000487B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00004880                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00004885                 mov     esp, ebp
.text$mn:00004887                 pop     ebp
.text$mn:00004888                 retn
.text$mn:00004888 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00004888
.text$mn:00004888 ; ---------------------------------------------------------------------------
.text$mn:00004889                 align 4
.text$mn:00004889 _text$mn        ends
.text$mn:00004889
.text$mn:0000488C ; ===========================================================================
.text$mn:0000488C
.text$mn:0000488C ; Segment type: Pure code
.text$mn:0000488C ; Segment permissions: Read/Execute
.text$mn:0000488C _text$mn        segment para public 'CODE' use32
.text$mn:0000488C                 assume cs:_text$mn
.text$mn:0000488C                 ;org 488Ch
.text$mn:0000488C ; COMDAT (pick any)
.text$mn:0000488C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000488C
.text$mn:0000488C ; =============== S U B R O U T I N E =======================================
.text$mn:0000488C
.text$mn:0000488C ; Attributes: bp-based frame
.text$mn:0000488C
.text$mn:0000488C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000488C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000488C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000488C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000488C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000488C
.text$mn:0000488C var_4           = dword ptr -4
.text$mn:0000488C arg_0           = dword ptr  8
.text$mn:0000488C
.text$mn:0000488C                 push    ebp
.text$mn:0000488D                 mov     ebp, esp
.text$mn:0000488F                 push    ecx
.text$mn:00004890                 mov     [ebp+var_4], ecx
.text$mn:00004893                 mov     eax, [ebp+arg_0]
.text$mn:00004896                 push    eax
.text$mn:00004897                 mov     ecx, [ebp+var_4]
.text$mn:0000489A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000489F                 mov     esp, ebp
.text$mn:000048A1                 pop     ebp
.text$mn:000048A2                 retn    4
.text$mn:000048A2 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000048A2
.text$mn:000048A2 ; ---------------------------------------------------------------------------
.text$mn:000048A5                 align 4
.text$mn:000048A5 _text$mn        ends
.text$mn:000048A5
.text$mn:000048A8 ; ===========================================================================
.text$mn:000048A8
.text$mn:000048A8 ; Segment type: Pure code
.text$mn:000048A8 ; Segment permissions: Read/Execute
.text$mn:000048A8 _text$mn        segment para public 'CODE' use32
.text$mn:000048A8                 assume cs:_text$mn
.text$mn:000048A8                 ;org 48A8h
.text$mn:000048A8 ; COMDAT (pick any)
.text$mn:000048A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048A8
.text$mn:000048A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048A8
.text$mn:000048A8 ; Attributes: bp-based frame
.text$mn:000048A8
.text$mn:000048A8 ; public: struct SwitcherFileInfo * __thiscall std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>::allocate(unsigned int)
.text$mn:000048A8                 public ?allocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEPAUSwitcherFileInfo@@I@Z
.text$mn:000048A8 ?allocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEPAUSwitcherFileInfo@@I@Z proc near
.text$mn:000048A8                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+41p
.text$mn:000048A8
.text$mn:000048A8 var_4           = dword ptr -4
.text$mn:000048A8 arg_0           = dword ptr  8
.text$mn:000048A8
.text$mn:000048A8                 push    ebp
.text$mn:000048A9                 mov     ebp, esp
.text$mn:000048AB                 push    ecx
.text$mn:000048AC                 mov     [ebp+var_4], ecx
.text$mn:000048AF                 mov     eax, [ebp+arg_0]
.text$mn:000048B2                 push    eax
.text$mn:000048B3                 mov     ecx, [ebp+var_4]
.text$mn:000048B6                 call    ?allocate@?$allocator@USwitcherFileInfo@@@std@@QAEPAUSwitcherFileInfo@@I@Z ; std::allocator<SwitcherFileInfo>::allocate(uint)
.text$mn:000048BB                 mov     esp, ebp
.text$mn:000048BD                 pop     ebp
.text$mn:000048BE                 retn    4
.text$mn:000048BE ?allocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEPAUSwitcherFileInfo@@I@Z endp
.text$mn:000048BE
.text$mn:000048BE ; ---------------------------------------------------------------------------
.text$mn:000048C1                 align 4
.text$mn:000048C1 _text$mn        ends
.text$mn:000048C1
.text$mn:000048C4 ; ===========================================================================
.text$mn:000048C4
.text$mn:000048C4 ; Segment type: Pure code
.text$mn:000048C4 ; Segment permissions: Read/Execute
.text$mn:000048C4 _text$mn        segment para public 'CODE' use32
.text$mn:000048C4                 assume cs:_text$mn
.text$mn:000048C4                 ;org 48C4h
.text$mn:000048C4 ; COMDAT (pick any)
.text$mn:000048C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048C4
.text$mn:000048C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000048C4
.text$mn:000048C4 ; Attributes: bp-based frame
.text$mn:000048C4
.text$mn:000048C4 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:000048C4                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000048C4 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000048C4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Alloc_proxy(void)+16p
.text$mn:000048C4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Alloc_proxy(void)+16p
.text$mn:000048C4
.text$mn:000048C4 var_4           = dword ptr -4
.text$mn:000048C4 arg_0           = dword ptr  8
.text$mn:000048C4
.text$mn:000048C4                 push    ebp
.text$mn:000048C5                 mov     ebp, esp
.text$mn:000048C7                 push    ecx
.text$mn:000048C8                 mov     [ebp+var_4], ecx
.text$mn:000048CB                 mov     eax, [ebp+arg_0]
.text$mn:000048CE                 push    eax
.text$mn:000048CF                 mov     ecx, [ebp+var_4]
.text$mn:000048D2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000048D7                 mov     esp, ebp
.text$mn:000048D9                 pop     ebp
.text$mn:000048DA                 retn    4
.text$mn:000048DA ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000048DA
.text$mn:000048DA ; ---------------------------------------------------------------------------
.text$mn:000048DD                 align 10h
.text$mn:000048DD _text$mn        ends
.text$mn:000048DD
.text$mn:000048E0 ; ===========================================================================
.text$mn:000048E0
.text$mn:000048E0 ; Segment type: Pure code
.text$mn:000048E0 ; Segment permissions: Read/Execute
.text$mn:000048E0 _text$mn        segment para public 'CODE' use32
.text$mn:000048E0                 assume cs:_text$mn
.text$mn:000048E0                 ;org 48E0h
.text$mn:000048E0 ; COMDAT (pick any)
.text$mn:000048E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048E0
.text$mn:000048E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000048E0
.text$mn:000048E0 ; Attributes: bp-based frame
.text$mn:000048E0
.text$mn:000048E0 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:000048E0                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:000048E0 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:000048E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:000048E0                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:000048E0
.text$mn:000048E0 var_4           = dword ptr -4
.text$mn:000048E0 arg_0           = dword ptr  8
.text$mn:000048E0
.text$mn:000048E0                 push    ebp
.text$mn:000048E1                 mov     ebp, esp
.text$mn:000048E3                 push    ecx
.text$mn:000048E4                 mov     [ebp+var_4], ecx
.text$mn:000048E7                 mov     eax, [ebp+arg_0]
.text$mn:000048EA                 push    eax
.text$mn:000048EB                 mov     ecx, [ebp+var_4]
.text$mn:000048EE                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:000048F3                 mov     esp, ebp
.text$mn:000048F5                 pop     ebp
.text$mn:000048F6                 retn    4
.text$mn:000048F6 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:000048F6
.text$mn:000048F6 ; ---------------------------------------------------------------------------
.text$mn:000048F9                 align 4
.text$mn:000048F9 _text$mn        ends
.text$mn:000048F9
.text$mn:000048FC ; ===========================================================================
.text$mn:000048FC
.text$mn:000048FC ; Segment type: Pure code
.text$mn:000048FC ; Segment permissions: Read/Execute
.text$mn:000048FC _text$mn        segment para public 'CODE' use32
.text$mn:000048FC                 assume cs:_text$mn
.text$mn:000048FC                 ;org 48FCh
.text$mn:000048FC ; COMDAT (pick any)
.text$mn:000048FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048FC
.text$mn:000048FC ; =============== S U B R O U T I N E =======================================
.text$mn:000048FC
.text$mn:000048FC ; Attributes: bp-based frame
.text$mn:000048FC
.text$mn:000048FC ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000048FC                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000048FC ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000048FC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000048FC
.text$mn:000048FC var_4           = dword ptr -4
.text$mn:000048FC arg_0           = dword ptr  8
.text$mn:000048FC
.text$mn:000048FC                 push    ebp
.text$mn:000048FD                 mov     ebp, esp
.text$mn:000048FF                 push    ecx
.text$mn:00004900                 mov     [ebp+var_4], ecx
.text$mn:00004903                 push    0
.text$mn:00004905                 mov     eax, [ebp+arg_0]
.text$mn:00004908                 push    eax
.text$mn:00004909                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000490E                 add     esp, 8
.text$mn:00004911                 mov     esp, ebp
.text$mn:00004913                 pop     ebp
.text$mn:00004914                 retn    4
.text$mn:00004914 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00004914
.text$mn:00004914 ; ---------------------------------------------------------------------------
.text$mn:00004917                 align 4
.text$mn:00004917 _text$mn        ends
.text$mn:00004917
.text$mn:00004918 ; ===========================================================================
.text$mn:00004918
.text$mn:00004918 ; Segment type: Pure code
.text$mn:00004918 ; Segment permissions: Read/Execute
.text$mn:00004918 _text$mn        segment para public 'CODE' use32
.text$mn:00004918                 assume cs:_text$mn
.text$mn:00004918                 ;org 4918h
.text$mn:00004918 ; COMDAT (pick any)
.text$mn:00004918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004918
.text$mn:00004918 ; =============== S U B R O U T I N E =======================================
.text$mn:00004918
.text$mn:00004918 ; Attributes: bp-based frame
.text$mn:00004918
.text$mn:00004918 ; public: struct SwitcherFileInfo * __thiscall std::allocator<struct SwitcherFileInfo>::allocate(unsigned int)
.text$mn:00004918                 public ?allocate@?$allocator@USwitcherFileInfo@@@std@@QAEPAUSwitcherFileInfo@@I@Z
.text$mn:00004918 ?allocate@?$allocator@USwitcherFileInfo@@@std@@QAEPAUSwitcherFileInfo@@I@Z proc near
.text$mn:00004918                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::allocate(uint)+Ep
.text$mn:00004918
.text$mn:00004918 var_4           = dword ptr -4
.text$mn:00004918 arg_0           = dword ptr  8
.text$mn:00004918
.text$mn:00004918                 push    ebp
.text$mn:00004919                 mov     ebp, esp
.text$mn:0000491B                 push    ecx
.text$mn:0000491C                 mov     [ebp+var_4], ecx
.text$mn:0000491F                 push    0
.text$mn:00004921                 mov     eax, [ebp+arg_0]
.text$mn:00004924                 push    eax
.text$mn:00004925                 call    ??$_Allocate@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@IPAU1@@Z ; std::_Allocate<SwitcherFileInfo>(uint,SwitcherFileInfo *)
.text$mn:0000492A                 add     esp, 8
.text$mn:0000492D                 mov     esp, ebp
.text$mn:0000492F                 pop     ebp
.text$mn:00004930                 retn    4
.text$mn:00004930 ?allocate@?$allocator@USwitcherFileInfo@@@std@@QAEPAUSwitcherFileInfo@@I@Z endp
.text$mn:00004930
.text$mn:00004930 ; ---------------------------------------------------------------------------
.text$mn:00004933                 align 4
.text$mn:00004933 _text$mn        ends
.text$mn:00004933
.text$mn:00004934 ; ===========================================================================
.text$mn:00004934
.text$mn:00004934 ; Segment type: Pure code
.text$mn:00004934 ; Segment permissions: Read/Execute
.text$mn:00004934 _text$mn        segment para public 'CODE' use32
.text$mn:00004934                 assume cs:_text$mn
.text$mn:00004934                 ;org 4934h
.text$mn:00004934 ; COMDAT (pick any)
.text$mn:00004934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004934
.text$mn:00004934 ; =============== S U B R O U T I N E =======================================
.text$mn:00004934
.text$mn:00004934 ; Attributes: bp-based frame
.text$mn:00004934
.text$mn:00004934 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00004934                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00004934 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00004934                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00004934                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:00004934
.text$mn:00004934 var_4           = dword ptr -4
.text$mn:00004934 arg_0           = dword ptr  8
.text$mn:00004934
.text$mn:00004934                 push    ebp
.text$mn:00004935                 mov     ebp, esp
.text$mn:00004937                 push    ecx
.text$mn:00004938                 mov     [ebp+var_4], ecx
.text$mn:0000493B                 push    0
.text$mn:0000493D                 mov     eax, [ebp+arg_0]
.text$mn:00004940                 push    eax
.text$mn:00004941                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00004946                 add     esp, 8
.text$mn:00004949                 mov     esp, ebp
.text$mn:0000494B                 pop     ebp
.text$mn:0000494C                 retn    4
.text$mn:0000494C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000494C
.text$mn:0000494C ; ---------------------------------------------------------------------------
.text$mn:0000494F                 align 10h
.text$mn:0000494F _text$mn        ends
.text$mn:0000494F
.text$mn:00004950 ; ===========================================================================
.text$mn:00004950
.text$mn:00004950 ; Segment type: Pure code
.text$mn:00004950 ; Segment permissions: Read/Execute
.text$mn:00004950 _text$mn        segment para public 'CODE' use32
.text$mn:00004950                 assume cs:_text$mn
.text$mn:00004950                 ;org 4950h
.text$mn:00004950 ; COMDAT (pick any)
.text$mn:00004950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004950
.text$mn:00004950 ; =============== S U B R O U T I N E =======================================
.text$mn:00004950
.text$mn:00004950 ; Attributes: bp-based frame
.text$mn:00004950
.text$mn:00004950 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00004950                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00004950 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00004950                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00004950
.text$mn:00004950 var_4           = dword ptr -4
.text$mn:00004950 arg_0           = dword ptr  8
.text$mn:00004950
.text$mn:00004950                 push    ebp
.text$mn:00004951                 mov     ebp, esp
.text$mn:00004953                 push    ecx
.text$mn:00004954                 mov     [ebp+var_4], ecx
.text$mn:00004957                 push    0
.text$mn:00004959                 mov     eax, [ebp+arg_0]
.text$mn:0000495C                 push    eax
.text$mn:0000495D                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00004962                 add     esp, 8
.text$mn:00004965                 mov     esp, ebp
.text$mn:00004967                 pop     ebp
.text$mn:00004968                 retn    4
.text$mn:00004968 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00004968
.text$mn:00004968 ; ---------------------------------------------------------------------------
.text$mn:0000496B                 align 4
.text$mn:0000496B _text$mn        ends
.text$mn:0000496B
.text$mn:0000496C ; ===========================================================================
.text$mn:0000496C
.text$mn:0000496C ; Segment type: Pure code
.text$mn:0000496C ; Segment permissions: Read/Execute
.text$mn:0000496C _text$mn        segment para public 'CODE' use32
.text$mn:0000496C                 assume cs:_text$mn
.text$mn:0000496C                 ;org 496Ch
.text$mn:0000496C ; COMDAT (pick any)
.text$mn:0000496C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000496C
.text$mn:0000496C ; =============== S U B R O U T I N E =======================================
.text$mn:0000496C
.text$mn:0000496C ; Attributes: bp-based frame
.text$mn:0000496C
.text$mn:0000496C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000496C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000496C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000496C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000496C
.text$mn:0000496C Size            = dword ptr -8
.text$mn:0000496C var_4           = dword ptr -4
.text$mn:0000496C arg_0           = dword ptr  8
.text$mn:0000496C arg_4           = dword ptr  0Ch
.text$mn:0000496C arg_8           = dword ptr  10h
.text$mn:0000496C
.text$mn:0000496C                 push    ebp
.text$mn:0000496D                 mov     ebp, esp
.text$mn:0000496F                 sub     esp, 8
.text$mn:00004972                 mov     [ebp+var_4], ecx
.text$mn:00004975                 mov     ecx, [ebp+arg_0]
.text$mn:00004978                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000497D                 cmp     eax, [ebp+arg_4]
.text$mn:00004980                 jnb     short loc_498A
.text$mn:00004982                 mov     ecx, [ebp+var_4]
.text$mn:00004985                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000498A
.text$mn:0000498A loc_498A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000498A                 mov     ecx, [ebp+arg_0]
.text$mn:0000498D                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00004992                 sub     eax, [ebp+arg_4]
.text$mn:00004995                 mov     [ebp+Size], eax
.text$mn:00004998                 mov     eax, [ebp+arg_8]
.text$mn:0000499B                 cmp     eax, [ebp+Size]
.text$mn:0000499E                 jnb     short loc_49A6
.text$mn:000049A0                 mov     ecx, [ebp+arg_8]
.text$mn:000049A3                 mov     [ebp+Size], ecx
.text$mn:000049A6
.text$mn:000049A6 loc_49A6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000049A6                 mov     edx, [ebp+var_4]
.text$mn:000049A9                 cmp     edx, [ebp+arg_0]
.text$mn:000049AC                 jnz     short loc_49CD
.text$mn:000049AE                 mov     eax, [ebp+arg_4]
.text$mn:000049B1                 add     eax, [ebp+Size]
.text$mn:000049B4                 push    eax
.text$mn:000049B5                 mov     ecx, [ebp+var_4]
.text$mn:000049B8                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000049BD                 mov     ecx, [ebp+arg_4]
.text$mn:000049C0                 push    ecx
.text$mn:000049C1                 push    0
.text$mn:000049C3                 mov     ecx, [ebp+var_4]
.text$mn:000049C6                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000049CB                 jmp     short loc_4A0F
.text$mn:000049CD ; ---------------------------------------------------------------------------
.text$mn:000049CD
.text$mn:000049CD loc_49CD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000049CD                 push    0
.text$mn:000049CF                 mov     edx, [ebp+Size]
.text$mn:000049D2                 push    edx
.text$mn:000049D3                 mov     ecx, [ebp+var_4]
.text$mn:000049D6                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000049DB                 movzx   eax, al
.text$mn:000049DE                 test    eax, eax
.text$mn:000049E0                 jz      short loc_4A0F
.text$mn:000049E2                 mov     ecx, [ebp+Size]
.text$mn:000049E5                 push    ecx             ; Size
.text$mn:000049E6                 mov     ecx, [ebp+arg_0]
.text$mn:000049E9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000049EE                 add     eax, [ebp+arg_4]
.text$mn:000049F1                 push    eax             ; Src
.text$mn:000049F2                 mov     ecx, [ebp+var_4]
.text$mn:000049F5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000049FA                 push    eax             ; Dst
.text$mn:000049FB                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004A00                 add     esp, 0Ch
.text$mn:00004A03                 mov     edx, [ebp+Size]
.text$mn:00004A06                 push    edx
.text$mn:00004A07                 mov     ecx, [ebp+var_4]
.text$mn:00004A0A                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004A0F
.text$mn:00004A0F loc_4A0F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00004A0F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00004A0F                 mov     eax, [ebp+var_4]
.text$mn:00004A12                 mov     esp, ebp
.text$mn:00004A14                 pop     ebp
.text$mn:00004A15                 retn    0Ch
.text$mn:00004A15 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00004A15
.text$mn:00004A15 _text$mn        ends
.text$mn:00004A15
.text$mn:00004A18 ; ===========================================================================
.text$mn:00004A18
.text$mn:00004A18 ; Segment type: Pure code
.text$mn:00004A18 ; Segment permissions: Read/Execute
.text$mn:00004A18 _text$mn        segment para public 'CODE' use32
.text$mn:00004A18                 assume cs:_text$mn
.text$mn:00004A18                 ;org 4A18h
.text$mn:00004A18 ; COMDAT (pick any)
.text$mn:00004A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A18
.text$mn:00004A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A18
.text$mn:00004A18 ; Attributes: bp-based frame
.text$mn:00004A18
.text$mn:00004A18 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00004A18                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00004A18 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00004A18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00004A18
.text$mn:00004A18 var_4           = dword ptr -4
.text$mn:00004A18 Str             = dword ptr  8
.text$mn:00004A18
.text$mn:00004A18                 push    ebp
.text$mn:00004A19                 mov     ebp, esp
.text$mn:00004A1B                 push    ecx
.text$mn:00004A1C                 mov     [ebp+var_4], ecx
.text$mn:00004A1F                 push    490h            ; unsigned int
.text$mn:00004A24                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004A29                 mov     eax, [ebp+Str]
.text$mn:00004A2C                 push    eax             ; int
.text$mn:00004A2D                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00004A32                 add     esp, 0Ch
.text$mn:00004A35                 mov     ecx, [ebp+Str]
.text$mn:00004A38                 push    ecx             ; Str
.text$mn:00004A39                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00004A3E                 add     esp, 4
.text$mn:00004A41                 push    eax             ; Size
.text$mn:00004A42                 mov     edx, [ebp+Str]
.text$mn:00004A45                 push    edx             ; Src
.text$mn:00004A46                 mov     ecx, [ebp+var_4]
.text$mn:00004A49                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00004A4E                 mov     esp, ebp
.text$mn:00004A50                 pop     ebp
.text$mn:00004A51                 retn    4
.text$mn:00004A51 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00004A51
.text$mn:00004A51 _text$mn        ends
.text$mn:00004A51
.text$mn:00004A54 ; ===========================================================================
.text$mn:00004A54
.text$mn:00004A54 ; Segment type: Pure code
.text$mn:00004A54 ; Segment permissions: Read/Execute
.text$mn:00004A54 _text$mn        segment para public 'CODE' use32
.text$mn:00004A54                 assume cs:_text$mn
.text$mn:00004A54                 ;org 4A54h
.text$mn:00004A54 ; COMDAT (pick any)
.text$mn:00004A54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A54
.text$mn:00004A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A54
.text$mn:00004A54 ; Attributes: bp-based frame
.text$mn:00004A54
.text$mn:00004A54 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00004A54                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00004A54 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00004A54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00004A54
.text$mn:00004A54 var_4           = dword ptr -4
.text$mn:00004A54 Src             = dword ptr  8
.text$mn:00004A54 Size            = dword ptr  0Ch
.text$mn:00004A54
.text$mn:00004A54                 push    ebp
.text$mn:00004A55                 mov     ebp, esp
.text$mn:00004A57                 push    ecx
.text$mn:00004A58                 mov     [ebp+var_4], ecx
.text$mn:00004A5B                 cmp     [ebp+Size], 0
.text$mn:00004A5F                 jz      short loc_4A77
.text$mn:00004A61                 push    47Fh            ; unsigned int
.text$mn:00004A66                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004A6B                 mov     eax, [ebp+Src]
.text$mn:00004A6E                 push    eax             ; int
.text$mn:00004A6F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00004A74                 add     esp, 0Ch
.text$mn:00004A77
.text$mn:00004A77 loc_4A77:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00004A77                 mov     ecx, [ebp+Src]
.text$mn:00004A7A                 push    ecx
.text$mn:00004A7B                 mov     ecx, [ebp+var_4]
.text$mn:00004A7E                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00004A83                 movzx   edx, al
.text$mn:00004A86                 test    edx, edx
.text$mn:00004A88                 jz      short loc_4AAA
.text$mn:00004A8A                 mov     eax, [ebp+Size]
.text$mn:00004A8D                 push    eax
.text$mn:00004A8E                 mov     ecx, [ebp+var_4]
.text$mn:00004A91                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004A96                 mov     ecx, [ebp+Src]
.text$mn:00004A99                 sub     ecx, eax
.text$mn:00004A9B                 push    ecx
.text$mn:00004A9C                 mov     edx, [ebp+var_4]
.text$mn:00004A9F                 push    edx
.text$mn:00004AA0                 mov     ecx, [ebp+var_4]
.text$mn:00004AA3                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00004AA8                 jmp     short loc_4AE7
.text$mn:00004AAA ; ---------------------------------------------------------------------------
.text$mn:00004AAA
.text$mn:00004AAA loc_4AAA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00004AAA                 push    0
.text$mn:00004AAC                 mov     eax, [ebp+Size]
.text$mn:00004AAF                 push    eax
.text$mn:00004AB0                 mov     ecx, [ebp+var_4]
.text$mn:00004AB3                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00004AB8                 movzx   ecx, al
.text$mn:00004ABB                 test    ecx, ecx
.text$mn:00004ABD                 jz      short loc_4AE4
.text$mn:00004ABF                 mov     edx, [ebp+Size]
.text$mn:00004AC2                 push    edx             ; Size
.text$mn:00004AC3                 mov     eax, [ebp+Src]
.text$mn:00004AC6                 push    eax             ; Src
.text$mn:00004AC7                 mov     ecx, [ebp+var_4]
.text$mn:00004ACA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004ACF                 push    eax             ; Dst
.text$mn:00004AD0                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004AD5                 add     esp, 0Ch
.text$mn:00004AD8                 mov     ecx, [ebp+Size]
.text$mn:00004ADB                 push    ecx
.text$mn:00004ADC                 mov     ecx, [ebp+var_4]
.text$mn:00004ADF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004AE4
.text$mn:00004AE4 loc_4AE4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00004AE4                 mov     eax, [ebp+var_4]
.text$mn:00004AE7
.text$mn:00004AE7 loc_4AE7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00004AE7                 mov     esp, ebp
.text$mn:00004AE9                 pop     ebp
.text$mn:00004AEA                 retn    8
.text$mn:00004AEA ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00004AEA
.text$mn:00004AEA ; ---------------------------------------------------------------------------
.text$mn:00004AED                 align 10h
.text$mn:00004AED _text$mn        ends
.text$mn:00004AED
.text$mn:00004AF0 ; ===========================================================================
.text$mn:00004AF0
.text$mn:00004AF0 ; Segment type: Pure code
.text$mn:00004AF0 ; Segment permissions: Read/Execute
.text$mn:00004AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00004AF0                 assume cs:_text$mn
.text$mn:00004AF0                 ;org 4AF0h
.text$mn:00004AF0 ; COMDAT (pick any)
.text$mn:00004AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AF0
.text$mn:00004AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AF0
.text$mn:00004AF0 ; Attributes: bp-based frame
.text$mn:00004AF0
.text$mn:00004AF0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00004AF0                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00004AF0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00004AF0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:00004AF0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00004AF0
.text$mn:00004AF0 var_8           = dword ptr -8
.text$mn:00004AF0 var_4           = dword ptr -4
.text$mn:00004AF0 arg_0           = dword ptr  8
.text$mn:00004AF0 arg_4           = dword ptr  0Ch
.text$mn:00004AF0 arg_8           = dword ptr  10h
.text$mn:00004AF0
.text$mn:00004AF0                 push    ebp
.text$mn:00004AF1                 mov     ebp, esp
.text$mn:00004AF3                 sub     esp, 8
.text$mn:00004AF6                 mov     [ebp+var_4], ecx
.text$mn:00004AF9                 mov     ecx, [ebp+arg_0]
.text$mn:00004AFC                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00004B01                 cmp     eax, [ebp+arg_4]
.text$mn:00004B04                 jnb     short loc_4B0E
.text$mn:00004B06                 mov     ecx, [ebp+var_4]
.text$mn:00004B09                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00004B0E
.text$mn:00004B0E loc_4B0E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00004B0E                 mov     ecx, [ebp+arg_0]
.text$mn:00004B11                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00004B16                 sub     eax, [ebp+arg_4]
.text$mn:00004B19                 mov     [ebp+var_8], eax
.text$mn:00004B1C                 mov     eax, [ebp+arg_8]
.text$mn:00004B1F                 cmp     eax, [ebp+var_8]
.text$mn:00004B22                 jnb     short loc_4B2A
.text$mn:00004B24                 mov     ecx, [ebp+arg_8]
.text$mn:00004B27                 mov     [ebp+var_8], ecx
.text$mn:00004B2A
.text$mn:00004B2A loc_4B2A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00004B2A                 mov     edx, [ebp+var_4]
.text$mn:00004B2D                 cmp     edx, [ebp+arg_0]
.text$mn:00004B30                 jnz     short loc_4B51
.text$mn:00004B32                 mov     eax, [ebp+arg_4]
.text$mn:00004B35                 add     eax, [ebp+var_8]
.text$mn:00004B38                 push    eax
.text$mn:00004B39                 mov     ecx, [ebp+var_4]
.text$mn:00004B3C                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00004B41                 mov     ecx, [ebp+arg_4]
.text$mn:00004B44                 push    ecx
.text$mn:00004B45                 push    0
.text$mn:00004B47                 mov     ecx, [ebp+var_4]
.text$mn:00004B4A                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00004B4F                 jmp     short loc_4B96
.text$mn:00004B51 ; ---------------------------------------------------------------------------
.text$mn:00004B51
.text$mn:00004B51 loc_4B51:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00004B51                 push    0
.text$mn:00004B53                 mov     edx, [ebp+var_8]
.text$mn:00004B56                 push    edx
.text$mn:00004B57                 mov     ecx, [ebp+var_4]
.text$mn:00004B5A                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00004B5F                 movzx   eax, al
.text$mn:00004B62                 test    eax, eax
.text$mn:00004B64                 jz      short loc_4B96
.text$mn:00004B66                 mov     ecx, [ebp+var_8]
.text$mn:00004B69                 push    ecx             ; int
.text$mn:00004B6A                 mov     ecx, [ebp+arg_0]
.text$mn:00004B6D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004B72                 mov     edx, [ebp+arg_4]
.text$mn:00004B75                 lea     eax, [eax+edx*2]
.text$mn:00004B78                 push    eax             ; Src
.text$mn:00004B79                 mov     ecx, [ebp+var_4]
.text$mn:00004B7C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004B81                 push    eax             ; Dst
.text$mn:00004B82                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00004B87                 add     esp, 0Ch
.text$mn:00004B8A                 mov     ecx, [ebp+var_8]
.text$mn:00004B8D                 push    ecx
.text$mn:00004B8E                 mov     ecx, [ebp+var_4]
.text$mn:00004B91                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004B96
.text$mn:00004B96 loc_4B96:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00004B96                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00004B96                 mov     eax, [ebp+var_4]
.text$mn:00004B99                 mov     esp, ebp
.text$mn:00004B9B                 pop     ebp
.text$mn:00004B9C                 retn    0Ch
.text$mn:00004B9C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00004B9C
.text$mn:00004B9C ; ---------------------------------------------------------------------------
.text$mn:00004B9F                 align 10h
.text$mn:00004B9F _text$mn        ends
.text$mn:00004B9F
.text$mn:00004BA0 ; ===========================================================================
.text$mn:00004BA0
.text$mn:00004BA0 ; Segment type: Pure code
.text$mn:00004BA0 ; Segment permissions: Read/Execute
.text$mn:00004BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BA0                 assume cs:_text$mn
.text$mn:00004BA0                 ;org 4BA0h
.text$mn:00004BA0 ; COMDAT (pick any)
.text$mn:00004BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BA0
.text$mn:00004BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BA0
.text$mn:00004BA0 ; Attributes: bp-based frame
.text$mn:00004BA0
.text$mn:00004BA0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00004BA0                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00004BA0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00004BA0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:00004BA0
.text$mn:00004BA0 var_4           = dword ptr -4
.text$mn:00004BA0 Str             = dword ptr  8
.text$mn:00004BA0
.text$mn:00004BA0                 push    ebp
.text$mn:00004BA1                 mov     ebp, esp
.text$mn:00004BA3                 push    ecx
.text$mn:00004BA4                 mov     [ebp+var_4], ecx
.text$mn:00004BA7                 push    490h            ; unsigned int
.text$mn:00004BAC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004BB1                 mov     eax, [ebp+Str]
.text$mn:00004BB4                 push    eax             ; int
.text$mn:00004BB5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00004BBA                 add     esp, 0Ch
.text$mn:00004BBD                 mov     ecx, [ebp+Str]
.text$mn:00004BC0                 push    ecx             ; Str
.text$mn:00004BC1                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00004BC6                 add     esp, 4
.text$mn:00004BC9                 push    eax             ; int
.text$mn:00004BCA                 mov     edx, [ebp+Str]
.text$mn:00004BCD                 push    edx             ; Src
.text$mn:00004BCE                 mov     ecx, [ebp+var_4]
.text$mn:00004BD1                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00004BD6                 mov     esp, ebp
.text$mn:00004BD8                 pop     ebp
.text$mn:00004BD9                 retn    4
.text$mn:00004BD9 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00004BD9
.text$mn:00004BD9 _text$mn        ends
.text$mn:00004BD9
.text$mn:00004BDC ; ===========================================================================
.text$mn:00004BDC
.text$mn:00004BDC ; Segment type: Pure code
.text$mn:00004BDC ; Segment permissions: Read/Execute
.text$mn:00004BDC _text$mn        segment para public 'CODE' use32
.text$mn:00004BDC                 assume cs:_text$mn
.text$mn:00004BDC                 ;org 4BDCh
.text$mn:00004BDC ; COMDAT (pick any)
.text$mn:00004BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BDC
.text$mn:00004BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004BDC
.text$mn:00004BDC ; Attributes: bp-based frame
.text$mn:00004BDC
.text$mn:00004BDC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00004BDC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00004BDC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00004BDC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00004BDC
.text$mn:00004BDC var_4           = dword ptr -4
.text$mn:00004BDC Src             = dword ptr  8
.text$mn:00004BDC arg_4           = dword ptr  0Ch
.text$mn:00004BDC
.text$mn:00004BDC                 push    ebp
.text$mn:00004BDD                 mov     ebp, esp
.text$mn:00004BDF                 push    ecx
.text$mn:00004BE0                 mov     [ebp+var_4], ecx
.text$mn:00004BE3                 cmp     [ebp+arg_4], 0
.text$mn:00004BE7                 jz      short loc_4BFF
.text$mn:00004BE9                 push    47Fh            ; unsigned int
.text$mn:00004BEE                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004BF3                 mov     eax, [ebp+Src]
.text$mn:00004BF6                 push    eax             ; int
.text$mn:00004BF7                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00004BFC                 add     esp, 0Ch
.text$mn:00004BFF
.text$mn:00004BFF loc_4BFF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00004BFF                 mov     ecx, [ebp+Src]
.text$mn:00004C02                 push    ecx
.text$mn:00004C03                 mov     ecx, [ebp+var_4]
.text$mn:00004C06                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00004C0B                 movzx   edx, al
.text$mn:00004C0E                 test    edx, edx
.text$mn:00004C10                 jz      short loc_4C34
.text$mn:00004C12                 mov     eax, [ebp+arg_4]
.text$mn:00004C15                 push    eax
.text$mn:00004C16                 mov     ecx, [ebp+var_4]
.text$mn:00004C19                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004C1E                 mov     ecx, [ebp+Src]
.text$mn:00004C21                 sub     ecx, eax
.text$mn:00004C23                 sar     ecx, 1
.text$mn:00004C25                 push    ecx
.text$mn:00004C26                 mov     edx, [ebp+var_4]
.text$mn:00004C29                 push    edx
.text$mn:00004C2A                 mov     ecx, [ebp+var_4]
.text$mn:00004C2D                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00004C32                 jmp     short loc_4C71
.text$mn:00004C34 ; ---------------------------------------------------------------------------
.text$mn:00004C34
.text$mn:00004C34 loc_4C34:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00004C34                 push    0
.text$mn:00004C36                 mov     eax, [ebp+arg_4]
.text$mn:00004C39                 push    eax
.text$mn:00004C3A                 mov     ecx, [ebp+var_4]
.text$mn:00004C3D                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00004C42                 movzx   ecx, al
.text$mn:00004C45                 test    ecx, ecx
.text$mn:00004C47                 jz      short loc_4C6E
.text$mn:00004C49                 mov     edx, [ebp+arg_4]
.text$mn:00004C4C                 push    edx             ; int
.text$mn:00004C4D                 mov     eax, [ebp+Src]
.text$mn:00004C50                 push    eax             ; Src
.text$mn:00004C51                 mov     ecx, [ebp+var_4]
.text$mn:00004C54                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004C59                 push    eax             ; Dst
.text$mn:00004C5A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00004C5F                 add     esp, 0Ch
.text$mn:00004C62                 mov     ecx, [ebp+arg_4]
.text$mn:00004C65                 push    ecx
.text$mn:00004C66                 mov     ecx, [ebp+var_4]
.text$mn:00004C69                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004C6E
.text$mn:00004C6E loc_4C6E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00004C6E                 mov     eax, [ebp+var_4]
.text$mn:00004C71
.text$mn:00004C71 loc_4C71:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00004C71                 mov     esp, ebp
.text$mn:00004C73                 pop     ebp
.text$mn:00004C74                 retn    8
.text$mn:00004C74 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00004C74
.text$mn:00004C74 ; ---------------------------------------------------------------------------
.text$mn:00004C77                 align 4
.text$mn:00004C77 _text$mn        ends
.text$mn:00004C77
.text$mn:00004C78 ; ===========================================================================
.text$mn:00004C78
.text$mn:00004C78 ; Segment type: Pure code
.text$mn:00004C78 ; Segment permissions: Read/Execute
.text$mn:00004C78 _text$mn        segment para public 'CODE' use32
.text$mn:00004C78                 assume cs:_text$mn
.text$mn:00004C78                 ;org 4C78h
.text$mn:00004C78 ; COMDAT (pick any)
.text$mn:00004C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C78
.text$mn:00004C78 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C78
.text$mn:00004C78 ; Attributes: bp-based frame
.text$mn:00004C78
.text$mn:00004C78 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00004C78                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00004C78 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00004C78                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00004C78
.text$mn:00004C78 arg_0           = dword ptr  8
.text$mn:00004C78 arg_4           = dword ptr  0Ch
.text$mn:00004C78
.text$mn:00004C78                 push    ebp
.text$mn:00004C79                 mov     ebp, esp
.text$mn:00004C7B                 mov     eax, [ebp+arg_0]
.text$mn:00004C7E                 mov     ecx, [ebp+arg_4]
.text$mn:00004C81                 mov     dl, [ecx]
.text$mn:00004C83                 mov     [eax], dl
.text$mn:00004C85                 pop     ebp
.text$mn:00004C86                 retn
.text$mn:00004C86 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00004C86
.text$mn:00004C86 ; ---------------------------------------------------------------------------
.text$mn:00004C87                 align 4
.text$mn:00004C87 _text$mn        ends
.text$mn:00004C87
.text$mn:00004C88 ; ===========================================================================
.text$mn:00004C88
.text$mn:00004C88 ; Segment type: Pure code
.text$mn:00004C88 ; Segment permissions: Read/Execute
.text$mn:00004C88 _text$mn        segment para public 'CODE' use32
.text$mn:00004C88                 assume cs:_text$mn
.text$mn:00004C88                 ;org 4C88h
.text$mn:00004C88 ; COMDAT (pick any)
.text$mn:00004C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C88
.text$mn:00004C88 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C88
.text$mn:00004C88 ; Attributes: bp-based frame
.text$mn:00004C88
.text$mn:00004C88 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00004C88                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00004C88 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00004C88                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00004C88
.text$mn:00004C88 arg_0           = dword ptr  8
.text$mn:00004C88 arg_4           = dword ptr  0Ch
.text$mn:00004C88
.text$mn:00004C88                 push    ebp
.text$mn:00004C89                 mov     ebp, esp
.text$mn:00004C8B                 mov     eax, [ebp+arg_0]
.text$mn:00004C8E                 mov     ecx, [ebp+arg_4]
.text$mn:00004C91                 mov     dx, [ecx]
.text$mn:00004C94                 mov     [eax], dx
.text$mn:00004C97                 pop     ebp
.text$mn:00004C98                 retn
.text$mn:00004C98 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00004C98
.text$mn:00004C98 ; ---------------------------------------------------------------------------
.text$mn:00004C99                 align 4
.text$mn:00004C99 _text$mn        ends
.text$mn:00004C99
.text$mn:00004C9C ; ===========================================================================
.text$mn:00004C9C
.text$mn:00004C9C ; Segment type: Pure code
.text$mn:00004C9C ; Segment permissions: Read/Execute
.text$mn:00004C9C _text$mn        segment para public 'CODE' use32
.text$mn:00004C9C                 assume cs:_text$mn
.text$mn:00004C9C                 ;org 4C9Ch
.text$mn:00004C9C ; COMDAT (pick any)
.text$mn:00004C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C9C
.text$mn:00004C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C9C
.text$mn:00004C9C ; Attributes: bp-based frame
.text$mn:00004C9C
.text$mn:00004C9C ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00004C9C                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00004C9C ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00004C9C                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+16Dp
.text$mn:00004C9C                                         ; VerticalFileSwitcherListView::initList(void)+1B8p ...
.text$mn:00004C9C
.text$mn:00004C9C var_4           = dword ptr -4
.text$mn:00004C9C
.text$mn:00004C9C                 push    ebp
.text$mn:00004C9D                 mov     ebp, esp
.text$mn:00004C9F                 push    ecx
.text$mn:00004CA0                 mov     [ebp+var_4], ecx
.text$mn:00004CA3                 mov     ecx, [ebp+var_4]
.text$mn:00004CA6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004CAB                 mov     esp, ebp
.text$mn:00004CAD                 pop     ebp
.text$mn:00004CAE                 retn
.text$mn:00004CAE ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00004CAE
.text$mn:00004CAE ; ---------------------------------------------------------------------------
.text$mn:00004CAF                 align 10h
.text$mn:00004CAF _text$mn        ends
.text$mn:00004CAF
.text$mn:00004CB0 ; ===========================================================================
.text$mn:00004CB0
.text$mn:00004CB0 ; Segment type: Pure code
.text$mn:00004CB0 ; Segment permissions: Read/Execute
.text$mn:00004CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00004CB0                 assume cs:_text$mn
.text$mn:00004CB0                 ;org 4CB0h
.text$mn:00004CB0 ; COMDAT (pick any)
.text$mn:00004CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CB0
.text$mn:00004CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CB0
.text$mn:00004CB0 ; Attributes: bp-based frame
.text$mn:00004CB0
.text$mn:00004CB0 ; public: unsigned int __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::capacity(void)const
.text$mn:00004CB0                 public ?capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ
.text$mn:00004CB0 ?capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00004CB0                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Grow_to(uint)+Cp
.text$mn:00004CB0
.text$mn:00004CB0 var_4           = dword ptr -4
.text$mn:00004CB0
.text$mn:00004CB0                 push    ebp
.text$mn:00004CB1                 mov     ebp, esp
.text$mn:00004CB3                 push    ecx
.text$mn:00004CB4                 mov     [ebp+var_4], ecx
.text$mn:00004CB7                 mov     eax, [ebp+var_4]
.text$mn:00004CBA                 mov     ecx, [ebp+var_4]
.text$mn:00004CBD                 mov     eax, [eax+0Ch]
.text$mn:00004CC0                 sub     eax, [ecx+4]
.text$mn:00004CC3                 sar     eax, 3
.text$mn:00004CC6                 mov     esp, ebp
.text$mn:00004CC8                 pop     ebp
.text$mn:00004CC9                 retn
.text$mn:00004CC9 ?capacity@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:00004CC9
.text$mn:00004CC9 ; ---------------------------------------------------------------------------
.text$mn:00004CCA                 align 4
.text$mn:00004CCA _text$mn        ends
.text$mn:00004CCA
.text$mn:00004CCC ; ===========================================================================
.text$mn:00004CCC
.text$mn:00004CCC ; Segment type: Pure code
.text$mn:00004CCC ; Segment permissions: Read/Execute
.text$mn:00004CCC _text$mn        segment para public 'CODE' use32
.text$mn:00004CCC                 assume cs:_text$mn
.text$mn:00004CCC                 ;org 4CCCh
.text$mn:00004CCC ; COMDAT (pick any)
.text$mn:00004CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CCC
.text$mn:00004CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00004CCC
.text$mn:00004CCC ; Attributes: bp-based frame
.text$mn:00004CCC
.text$mn:00004CCC ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00004CCC                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00004CCC ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00004CCC                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00004CCC
.text$mn:00004CCC var_4           = dword ptr -4
.text$mn:00004CCC
.text$mn:00004CCC                 push    ebp
.text$mn:00004CCD                 mov     ebp, esp
.text$mn:00004CCF                 push    ecx
.text$mn:00004CD0                 mov     [ebp+var_4], ecx
.text$mn:00004CD3                 mov     eax, [ebp+var_4]
.text$mn:00004CD6                 mov     eax, [eax+4]
.text$mn:00004CD9                 mov     esp, ebp
.text$mn:00004CDB                 pop     ebp
.text$mn:00004CDC                 retn
.text$mn:00004CDC ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00004CDC
.text$mn:00004CDC ; ---------------------------------------------------------------------------
.text$mn:00004CDD                 align 10h
.text$mn:00004CDD _text$mn        ends
.text$mn:00004CDD
.text$mn:00004CE0 ; ===========================================================================
.text$mn:00004CE0
.text$mn:00004CE0 ; Segment type: Pure code
.text$mn:00004CE0 ; Segment permissions: Read/Execute
.text$mn:00004CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004CE0                 assume cs:_text$mn
.text$mn:00004CE0                 ;org 4CE0h
.text$mn:00004CE0 ; COMDAT (pick any)
.text$mn:00004CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CE0
.text$mn:00004CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CE0
.text$mn:00004CE0 ; Attributes: bp-based frame
.text$mn:00004CE0
.text$mn:00004CE0 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00004CE0                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00004CE0 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00004CE0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00004CE0                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00004CE0
.text$mn:00004CE0 var_4           = dword ptr -4
.text$mn:00004CE0
.text$mn:00004CE0                 push    ebp
.text$mn:00004CE1                 mov     ebp, esp
.text$mn:00004CE3                 push    ecx
.text$mn:00004CE4                 mov     [ebp+var_4], ecx
.text$mn:00004CE7                 mov     eax, [ebp+var_4]
.text$mn:00004CEA                 mov     eax, [eax+4]
.text$mn:00004CED                 mov     esp, ebp
.text$mn:00004CEF                 pop     ebp
.text$mn:00004CF0                 retn
.text$mn:00004CF0 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00004CF0
.text$mn:00004CF0 ; ---------------------------------------------------------------------------
.text$mn:00004CF1                 align 4
.text$mn:00004CF1 _text$mn        ends
.text$mn:00004CF1
.text$mn:00004CF4 ; ===========================================================================
.text$mn:00004CF4
.text$mn:00004CF4 ; Segment type: Pure code
.text$mn:00004CF4 ; Segment permissions: Read/Execute
.text$mn:00004CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CF4                 assume cs:_text$mn
.text$mn:00004CF4                 ;org 4CF4h
.text$mn:00004CF4 ; COMDAT (pick any)
.text$mn:00004CF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CF4
.text$mn:00004CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CF4
.text$mn:00004CF4 ; Attributes: bp-based frame
.text$mn:00004CF4
.text$mn:00004CF4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00004CF4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00004CF4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00004CF4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00004CF4
.text$mn:00004CF4 var_4           = dword ptr -4
.text$mn:00004CF4 Dst             = dword ptr  8
.text$mn:00004CF4 Src             = dword ptr  0Ch
.text$mn:00004CF4 Size            = dword ptr  10h
.text$mn:00004CF4
.text$mn:00004CF4                 push    ebp
.text$mn:00004CF5                 mov     ebp, esp
.text$mn:00004CF7                 push    ecx
.text$mn:00004CF8                 cmp     [ebp+Size], 0
.text$mn:00004CFC                 jnz     short loc_4D06
.text$mn:00004CFE                 mov     eax, [ebp+Dst]
.text$mn:00004D01                 mov     [ebp+var_4], eax
.text$mn:00004D04                 jmp     short loc_4D1D
.text$mn:00004D06 ; ---------------------------------------------------------------------------
.text$mn:00004D06
.text$mn:00004D06 loc_4D06:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00004D06                 mov     ecx, [ebp+Size]
.text$mn:00004D09                 push    ecx             ; Size
.text$mn:00004D0A                 mov     edx, [ebp+Src]
.text$mn:00004D0D                 push    edx             ; Src
.text$mn:00004D0E                 mov     eax, [ebp+Dst]
.text$mn:00004D11                 push    eax             ; Dst
.text$mn:00004D12                 call    _memcpy
.text$mn:00004D17                 add     esp, 0Ch
.text$mn:00004D1A                 mov     [ebp+var_4], eax
.text$mn:00004D1D
.text$mn:00004D1D loc_4D1D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00004D1D                 mov     eax, [ebp+var_4]
.text$mn:00004D20                 mov     esp, ebp
.text$mn:00004D22                 pop     ebp
.text$mn:00004D23                 retn
.text$mn:00004D23 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00004D23
.text$mn:00004D23 _text$mn        ends
.text$mn:00004D23
.text$mn:00004D24 ; ===========================================================================
.text$mn:00004D24
.text$mn:00004D24 ; Segment type: Pure code
.text$mn:00004D24 ; Segment permissions: Read/Execute
.text$mn:00004D24 _text$mn        segment para public 'CODE' use32
.text$mn:00004D24                 assume cs:_text$mn
.text$mn:00004D24                 ;org 4D24h
.text$mn:00004D24 ; COMDAT (pick any)
.text$mn:00004D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D24
.text$mn:00004D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D24
.text$mn:00004D24 ; Attributes: bp-based frame
.text$mn:00004D24
.text$mn:00004D24 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00004D24                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00004D24 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00004D24                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00004D24                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00004D24
.text$mn:00004D24 var_4           = dword ptr -4
.text$mn:00004D24 Dst             = dword ptr  8
.text$mn:00004D24 Src             = dword ptr  0Ch
.text$mn:00004D24 arg_8           = dword ptr  10h
.text$mn:00004D24
.text$mn:00004D24                 push    ebp
.text$mn:00004D25                 mov     ebp, esp
.text$mn:00004D27                 push    ecx
.text$mn:00004D28                 cmp     [ebp+arg_8], 0
.text$mn:00004D2C                 jnz     short loc_4D36
.text$mn:00004D2E                 mov     eax, [ebp+Dst]
.text$mn:00004D31                 mov     [ebp+var_4], eax
.text$mn:00004D34                 jmp     short loc_4D4D
.text$mn:00004D36 ; ---------------------------------------------------------------------------
.text$mn:00004D36
.text$mn:00004D36 loc_4D36:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00004D36                 mov     ecx, [ebp+arg_8]
.text$mn:00004D39                 push    ecx             ; int
.text$mn:00004D3A                 mov     edx, [ebp+Src]
.text$mn:00004D3D                 push    edx             ; Src
.text$mn:00004D3E                 mov     eax, [ebp+Dst]
.text$mn:00004D41                 push    eax             ; Dst
.text$mn:00004D42                 call    _wmemcpy
.text$mn:00004D47                 add     esp, 0Ch
.text$mn:00004D4A                 mov     [ebp+var_4], eax
.text$mn:00004D4D
.text$mn:00004D4D loc_4D4D:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00004D4D                 mov     eax, [ebp+var_4]
.text$mn:00004D50                 mov     esp, ebp
.text$mn:00004D52                 pop     ebp
.text$mn:00004D53                 retn
.text$mn:00004D53 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00004D53
.text$mn:00004D53 _text$mn        ends
.text$mn:00004D53
.text$mn:00004D54 ; ===========================================================================
.text$mn:00004D54
.text$mn:00004D54 ; Segment type: Pure code
.text$mn:00004D54 ; Segment permissions: Read/Execute
.text$mn:00004D54 _text$mn        segment para public 'CODE' use32
.text$mn:00004D54                 assume cs:_text$mn
.text$mn:00004D54                 ;org 4D54h
.text$mn:00004D54 ; COMDAT (pick any)
.text$mn:00004D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D54
.text$mn:00004D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D54
.text$mn:00004D54 ; Attributes: bp-based frame
.text$mn:00004D54
.text$mn:00004D54 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00004D54                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00004D54 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00004D54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00004D54
.text$mn:00004D54 var_4           = dword ptr -4
.text$mn:00004D54 arg_0           = dword ptr  8
.text$mn:00004D54 arg_4           = dword ptr  0Ch
.text$mn:00004D54
.text$mn:00004D54                 push    ebp
.text$mn:00004D55                 mov     ebp, esp
.text$mn:00004D57                 push    ecx
.text$mn:00004D58                 mov     [ebp+var_4], ecx
.text$mn:00004D5B                 mov     eax, [ebp+arg_4]
.text$mn:00004D5E                 push    eax             ; int
.text$mn:00004D5F                 mov     ecx, [ebp+arg_0]
.text$mn:00004D62                 push    ecx             ; void *
.text$mn:00004D63                 mov     ecx, [ebp+var_4]
.text$mn:00004D66                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00004D6B                 mov     esp, ebp
.text$mn:00004D6D                 pop     ebp
.text$mn:00004D6E                 retn    8
.text$mn:00004D6E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00004D6E
.text$mn:00004D6E ; ---------------------------------------------------------------------------
.text$mn:00004D71                 align 4
.text$mn:00004D71 _text$mn        ends
.text$mn:00004D71
.text$mn:00004D74 ; ===========================================================================
.text$mn:00004D74
.text$mn:00004D74 ; Segment type: Pure code
.text$mn:00004D74 ; Segment permissions: Read/Execute
.text$mn:00004D74 _text$mn        segment para public 'CODE' use32
.text$mn:00004D74                 assume cs:_text$mn
.text$mn:00004D74                 ;org 4D74h
.text$mn:00004D74 ; COMDAT (pick any)
.text$mn:00004D74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D74
.text$mn:00004D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D74
.text$mn:00004D74 ; Attributes: bp-based frame
.text$mn:00004D74
.text$mn:00004D74 ; int __stdcall std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::deallocate(void *, int)
.text$mn:00004D74                 public ?deallocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@I@Z
.text$mn:00004D74 ?deallocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@I@Z proc near
.text$mn:00004D74                                         ; CODE XREF: __catch$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00004D74                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+F5p ...
.text$mn:00004D74
.text$mn:00004D74 var_4           = dword ptr -4
.text$mn:00004D74 arg_0           = dword ptr  8
.text$mn:00004D74 arg_4           = dword ptr  0Ch
.text$mn:00004D74
.text$mn:00004D74                 push    ebp
.text$mn:00004D75                 mov     ebp, esp
.text$mn:00004D77                 push    ecx
.text$mn:00004D78                 mov     [ebp+var_4], ecx
.text$mn:00004D7B                 mov     eax, [ebp+arg_4]
.text$mn:00004D7E                 push    eax             ; int
.text$mn:00004D7F                 mov     ecx, [ebp+arg_0]
.text$mn:00004D82                 push    ecx             ; void *
.text$mn:00004D83                 mov     ecx, [ebp+var_4]
.text$mn:00004D86                 call    ?deallocate@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@I@Z ; std::allocator<SwitcherFileInfo>::deallocate(SwitcherFileInfo *,uint)
.text$mn:00004D8B                 mov     esp, ebp
.text$mn:00004D8D                 pop     ebp
.text$mn:00004D8E                 retn    8
.text$mn:00004D8E ?deallocate@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@I@Z endp
.text$mn:00004D8E
.text$mn:00004D8E ; ---------------------------------------------------------------------------
.text$mn:00004D91                 align 4
.text$mn:00004D91 _text$mn        ends
.text$mn:00004D91
.text$mn:00004D94 ; ===========================================================================
.text$mn:00004D94
.text$mn:00004D94 ; Segment type: Pure code
.text$mn:00004D94 ; Segment permissions: Read/Execute
.text$mn:00004D94 _text$mn        segment para public 'CODE' use32
.text$mn:00004D94                 assume cs:_text$mn
.text$mn:00004D94                 ;org 4D94h
.text$mn:00004D94 ; COMDAT (pick any)
.text$mn:00004D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D94
.text$mn:00004D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D94
.text$mn:00004D94 ; Attributes: bp-based frame
.text$mn:00004D94
.text$mn:00004D94 ; int __stdcall std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>::deallocate(void *, int)
.text$mn:00004D94                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@I@Z
.text$mn:00004D94 ?deallocate@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@I@Z proc near
.text$mn:00004D94                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::_Tidy(void)+5Cp
.text$mn:00004D94
.text$mn:00004D94 var_4           = dword ptr -4
.text$mn:00004D94 arg_0           = dword ptr  8
.text$mn:00004D94 arg_4           = dword ptr  0Ch
.text$mn:00004D94
.text$mn:00004D94                 push    ebp
.text$mn:00004D95                 mov     ebp, esp
.text$mn:00004D97                 push    ecx
.text$mn:00004D98                 mov     [ebp+var_4], ecx
.text$mn:00004D9B                 mov     eax, [ebp+arg_4]
.text$mn:00004D9E                 push    eax             ; int
.text$mn:00004D9F                 mov     ecx, [ebp+arg_0]
.text$mn:00004DA2                 push    ecx             ; void *
.text$mn:00004DA3                 mov     ecx, [ebp+var_4]
.text$mn:00004DA6                 call    ?deallocate@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@I@Z ; std::allocator<TaskLstFnStatus>::deallocate(TaskLstFnStatus *,uint)
.text$mn:00004DAB                 mov     esp, ebp
.text$mn:00004DAD                 pop     ebp
.text$mn:00004DAE                 retn    8
.text$mn:00004DAE ?deallocate@?$_Wrap_alloc@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEXPAUTaskLstFnStatus@@I@Z endp
.text$mn:00004DAE
.text$mn:00004DAE ; ---------------------------------------------------------------------------
.text$mn:00004DB1                 align 4
.text$mn:00004DB1 _text$mn        ends
.text$mn:00004DB1
.text$mn:00004DB4 ; ===========================================================================
.text$mn:00004DB4
.text$mn:00004DB4 ; Segment type: Pure code
.text$mn:00004DB4 ; Segment permissions: Read/Execute
.text$mn:00004DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004DB4                 assume cs:_text$mn
.text$mn:00004DB4                 ;org 4DB4h
.text$mn:00004DB4 ; COMDAT (pick any)
.text$mn:00004DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DB4
.text$mn:00004DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DB4
.text$mn:00004DB4 ; Attributes: bp-based frame
.text$mn:00004DB4
.text$mn:00004DB4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00004DB4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00004DB4 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00004DB4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Free_proxy(void)+32p
.text$mn:00004DB4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>>::_Free_proxy(void)+32p
.text$mn:00004DB4
.text$mn:00004DB4 var_4           = dword ptr -4
.text$mn:00004DB4 arg_0           = dword ptr  8
.text$mn:00004DB4 arg_4           = dword ptr  0Ch
.text$mn:00004DB4
.text$mn:00004DB4                 push    ebp
.text$mn:00004DB5                 mov     ebp, esp
.text$mn:00004DB7                 push    ecx
.text$mn:00004DB8                 mov     [ebp+var_4], ecx
.text$mn:00004DBB                 mov     eax, [ebp+arg_4]
.text$mn:00004DBE                 push    eax             ; int
.text$mn:00004DBF                 mov     ecx, [ebp+arg_0]
.text$mn:00004DC2                 push    ecx             ; void *
.text$mn:00004DC3                 mov     ecx, [ebp+var_4]
.text$mn:00004DC6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004DCB                 mov     esp, ebp
.text$mn:00004DCD                 pop     ebp
.text$mn:00004DCE                 retn    8
.text$mn:00004DCE ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00004DCE
.text$mn:00004DCE ; ---------------------------------------------------------------------------
.text$mn:00004DD1                 align 4
.text$mn:00004DD1 _text$mn        ends
.text$mn:00004DD1
.text$mn:00004DD4 ; ===========================================================================
.text$mn:00004DD4
.text$mn:00004DD4 ; Segment type: Pure code
.text$mn:00004DD4 ; Segment permissions: Read/Execute
.text$mn:00004DD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004DD4                 assume cs:_text$mn
.text$mn:00004DD4                 ;org 4DD4h
.text$mn:00004DD4 ; COMDAT (pick any)
.text$mn:00004DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DD4
.text$mn:00004DD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DD4
.text$mn:00004DD4 ; Attributes: bp-based frame
.text$mn:00004DD4
.text$mn:00004DD4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00004DD4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00004DD4 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00004DD4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00004DD4
.text$mn:00004DD4 var_4           = dword ptr -4
.text$mn:00004DD4 arg_0           = dword ptr  8
.text$mn:00004DD4 arg_4           = dword ptr  0Ch
.text$mn:00004DD4
.text$mn:00004DD4                 push    ebp
.text$mn:00004DD5                 mov     ebp, esp
.text$mn:00004DD7                 push    ecx
.text$mn:00004DD8                 mov     [ebp+var_4], ecx
.text$mn:00004DDB                 mov     eax, [ebp+arg_4]
.text$mn:00004DDE                 push    eax             ; int
.text$mn:00004DDF                 mov     ecx, [ebp+arg_0]
.text$mn:00004DE2                 push    ecx             ; void *
.text$mn:00004DE3                 mov     ecx, [ebp+var_4]
.text$mn:00004DE6                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:00004DEB                 mov     esp, ebp
.text$mn:00004DED                 pop     ebp
.text$mn:00004DEE                 retn    8
.text$mn:00004DEE ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:00004DEE
.text$mn:00004DEE ; ---------------------------------------------------------------------------
.text$mn:00004DF1                 align 4
.text$mn:00004DF1 _text$mn        ends
.text$mn:00004DF1
.text$mn:00004DF4 ; ===========================================================================
.text$mn:00004DF4
.text$mn:00004DF4 ; Segment type: Pure code
.text$mn:00004DF4 ; Segment permissions: Read/Execute
.text$mn:00004DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004DF4                 assume cs:_text$mn
.text$mn:00004DF4                 ;org 4DF4h
.text$mn:00004DF4 ; COMDAT (pick any)
.text$mn:00004DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DF4
.text$mn:00004DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DF4
.text$mn:00004DF4 ; Attributes: bp-based frame
.text$mn:00004DF4
.text$mn:00004DF4 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00004DF4                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00004DF4 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00004DF4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00004DF4
.text$mn:00004DF4 var_4           = dword ptr -4
.text$mn:00004DF4 arg_0           = dword ptr  8
.text$mn:00004DF4
.text$mn:00004DF4                 push    ebp
.text$mn:00004DF5                 mov     ebp, esp
.text$mn:00004DF7                 push    ecx
.text$mn:00004DF8                 mov     [ebp+var_4], ecx
.text$mn:00004DFB                 mov     eax, [ebp+arg_0]
.text$mn:00004DFE                 push    eax             ; void *
.text$mn:00004DFF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004E04                 add     esp, 4
.text$mn:00004E07                 mov     esp, ebp
.text$mn:00004E09                 pop     ebp
.text$mn:00004E0A                 retn    8
.text$mn:00004E0A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00004E0A
.text$mn:00004E0A ; ---------------------------------------------------------------------------
.text$mn:00004E0D                 align 10h
.text$mn:00004E0D _text$mn        ends
.text$mn:00004E0D
.text$mn:00004E10 ; ===========================================================================
.text$mn:00004E10
.text$mn:00004E10 ; Segment type: Pure code
.text$mn:00004E10 ; Segment permissions: Read/Execute
.text$mn:00004E10 _text$mn        segment para public 'CODE' use32
.text$mn:00004E10                 assume cs:_text$mn
.text$mn:00004E10                 ;org 4E10h
.text$mn:00004E10 ; COMDAT (pick any)
.text$mn:00004E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E10
.text$mn:00004E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E10
.text$mn:00004E10 ; Attributes: bp-based frame
.text$mn:00004E10
.text$mn:00004E10 ; int __stdcall std::allocator<SwitcherFileInfo>::deallocate(void *, int)
.text$mn:00004E10                 public ?deallocate@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@I@Z
.text$mn:00004E10 ?deallocate@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@I@Z proc near
.text$mn:00004E10                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::deallocate(SwitcherFileInfo *,uint)+12p
.text$mn:00004E10
.text$mn:00004E10 var_4           = dword ptr -4
.text$mn:00004E10 arg_0           = dword ptr  8
.text$mn:00004E10
.text$mn:00004E10                 push    ebp
.text$mn:00004E11                 mov     ebp, esp
.text$mn:00004E13                 push    ecx
.text$mn:00004E14                 mov     [ebp+var_4], ecx
.text$mn:00004E17                 mov     eax, [ebp+arg_0]
.text$mn:00004E1A                 push    eax             ; void *
.text$mn:00004E1B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004E20                 add     esp, 4
.text$mn:00004E23                 mov     esp, ebp
.text$mn:00004E25                 pop     ebp
.text$mn:00004E26                 retn    8
.text$mn:00004E26 ?deallocate@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@I@Z endp
.text$mn:00004E26
.text$mn:00004E26 ; ---------------------------------------------------------------------------
.text$mn:00004E29                 align 4
.text$mn:00004E29 _text$mn        ends
.text$mn:00004E29
.text$mn:00004E2C ; ===========================================================================
.text$mn:00004E2C
.text$mn:00004E2C ; Segment type: Pure code
.text$mn:00004E2C ; Segment permissions: Read/Execute
.text$mn:00004E2C _text$mn        segment para public 'CODE' use32
.text$mn:00004E2C                 assume cs:_text$mn
.text$mn:00004E2C                 ;org 4E2Ch
.text$mn:00004E2C ; COMDAT (pick any)
.text$mn:00004E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E2C
.text$mn:00004E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00004E2C
.text$mn:00004E2C ; Attributes: bp-based frame
.text$mn:00004E2C
.text$mn:00004E2C ; int __stdcall std::allocator<TaskLstFnStatus>::deallocate(void *, int)
.text$mn:00004E2C                 public ?deallocate@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@I@Z
.text$mn:00004E2C ?deallocate@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@I@Z proc near
.text$mn:00004E2C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TaskLstFnStatus>>::deallocate(TaskLstFnStatus *,uint)+12p
.text$mn:00004E2C
.text$mn:00004E2C var_4           = dword ptr -4
.text$mn:00004E2C arg_0           = dword ptr  8
.text$mn:00004E2C
.text$mn:00004E2C                 push    ebp
.text$mn:00004E2D                 mov     ebp, esp
.text$mn:00004E2F                 push    ecx
.text$mn:00004E30                 mov     [ebp+var_4], ecx
.text$mn:00004E33                 mov     eax, [ebp+arg_0]
.text$mn:00004E36                 push    eax             ; void *
.text$mn:00004E37                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004E3C                 add     esp, 4
.text$mn:00004E3F                 mov     esp, ebp
.text$mn:00004E41                 pop     ebp
.text$mn:00004E42                 retn    8
.text$mn:00004E42 ?deallocate@?$allocator@UTaskLstFnStatus@@@std@@QAEXPAUTaskLstFnStatus@@I@Z endp
.text$mn:00004E42
.text$mn:00004E42 ; ---------------------------------------------------------------------------
.text$mn:00004E45                 align 4
.text$mn:00004E45 _text$mn        ends
.text$mn:00004E45
.text$mn:00004E48 ; ===========================================================================
.text$mn:00004E48
.text$mn:00004E48 ; Segment type: Pure code
.text$mn:00004E48 ; Segment permissions: Read/Execute
.text$mn:00004E48 _text$mn        segment para public 'CODE' use32
.text$mn:00004E48                 assume cs:_text$mn
.text$mn:00004E48                 ;org 4E48h
.text$mn:00004E48 ; COMDAT (pick any)
.text$mn:00004E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E48
.text$mn:00004E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E48
.text$mn:00004E48 ; Attributes: bp-based frame
.text$mn:00004E48
.text$mn:00004E48 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00004E48                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00004E48 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00004E48                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00004E48                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:00004E48
.text$mn:00004E48 var_4           = dword ptr -4
.text$mn:00004E48 arg_0           = dword ptr  8
.text$mn:00004E48
.text$mn:00004E48                 push    ebp
.text$mn:00004E49                 mov     ebp, esp
.text$mn:00004E4B                 push    ecx
.text$mn:00004E4C                 mov     [ebp+var_4], ecx
.text$mn:00004E4F                 mov     eax, [ebp+arg_0]
.text$mn:00004E52                 push    eax             ; void *
.text$mn:00004E53                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004E58                 add     esp, 4
.text$mn:00004E5B                 mov     esp, ebp
.text$mn:00004E5D                 pop     ebp
.text$mn:00004E5E                 retn    8
.text$mn:00004E5E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00004E5E
.text$mn:00004E5E ; ---------------------------------------------------------------------------
.text$mn:00004E61                 align 4
.text$mn:00004E61 _text$mn        ends
.text$mn:00004E61
.text$mn:00004E64 ; ===========================================================================
.text$mn:00004E64
.text$mn:00004E64 ; Segment type: Pure code
.text$mn:00004E64 ; Segment permissions: Read/Execute
.text$mn:00004E64 _text$mn        segment para public 'CODE' use32
.text$mn:00004E64                 assume cs:_text$mn
.text$mn:00004E64                 ;org 4E64h
.text$mn:00004E64 ; COMDAT (pick any)
.text$mn:00004E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E64
.text$mn:00004E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E64
.text$mn:00004E64 ; Attributes: bp-based frame
.text$mn:00004E64
.text$mn:00004E64 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00004E64                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00004E64 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00004E64                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00004E64
.text$mn:00004E64 var_4           = dword ptr -4
.text$mn:00004E64 arg_0           = dword ptr  8
.text$mn:00004E64
.text$mn:00004E64                 push    ebp
.text$mn:00004E65                 mov     ebp, esp
.text$mn:00004E67                 push    ecx
.text$mn:00004E68                 mov     [ebp+var_4], ecx
.text$mn:00004E6B                 mov     eax, [ebp+arg_0]
.text$mn:00004E6E                 push    eax             ; void *
.text$mn:00004E6F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004E74                 add     esp, 4
.text$mn:00004E77                 mov     esp, ebp
.text$mn:00004E79                 pop     ebp
.text$mn:00004E7A                 retn    8
.text$mn:00004E7A ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00004E7A
.text$mn:00004E7A ; ---------------------------------------------------------------------------
.text$mn:00004E7D                 align 10h
.text$mn:00004E7D _text$mn        ends
.text$mn:00004E7D
.text$mn:00004E80 ; ===========================================================================
.text$mn:00004E80
.text$mn:00004E80 ; Segment type: Pure code
.text$mn:00004E80 ; Segment permissions: Read/Execute
.text$mn:00004E80 _text$mn        segment para public 'CODE' use32
.text$mn:00004E80                 assume cs:_text$mn
.text$mn:00004E80                 ;org 4E80h
.text$mn:00004E80 ; COMDAT (pick any)
.text$mn:00004E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E80
.text$mn:00004E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E80
.text$mn:00004E80 ; Attributes: bp-based frame
.text$mn:00004E80
.text$mn:00004E80 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00004E80                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00004E80 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00004E80                                         ; DATA XREF: .rdata:000064ECo
.text$mn:00004E80
.text$mn:00004E80 var_4           = dword ptr -4
.text$mn:00004E80 arg_0           = dword ptr  8
.text$mn:00004E80 arg_4           = dword ptr  0Ch
.text$mn:00004E80
.text$mn:00004E80                 push    ebp
.text$mn:00004E81                 mov     ebp, esp
.text$mn:00004E83                 push    ecx
.text$mn:00004E84                 mov     [ebp+var_4], ecx
.text$mn:00004E87                 mov     eax, [ebp+arg_4]
.text$mn:00004E8A                 push    eax             ; int
.text$mn:00004E8B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00004E90                 add     esp, 4
.text$mn:00004E93                 test    eax, eax
.text$mn:00004E95                 jz      short loc_4EB0
.text$mn:00004E97                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00004E9C                 push    eax             ; struct std::error_category *
.text$mn:00004E9D                 mov     ecx, [ebp+arg_4]
.text$mn:00004EA0                 push    ecx             ; int
.text$mn:00004EA1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004EA4                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00004EA9                 mov     eax, [ebp+arg_0]
.text$mn:00004EAC                 jmp     short loc_4EC5
.text$mn:00004EAE ; ---------------------------------------------------------------------------
.text$mn:00004EAE                 jmp     short loc_4EC5
.text$mn:00004EB0 ; ---------------------------------------------------------------------------
.text$mn:00004EB0
.text$mn:00004EB0 loc_4EB0:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00004EB0                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00004EB5                 push    eax             ; struct std::error_category *
.text$mn:00004EB6                 mov     edx, [ebp+arg_4]
.text$mn:00004EB9                 push    edx             ; int
.text$mn:00004EBA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004EBD                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00004EC2                 mov     eax, [ebp+arg_0]
.text$mn:00004EC5
.text$mn:00004EC5 loc_4EC5:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00004EC5                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00004EC5                 mov     esp, ebp
.text$mn:00004EC7                 pop     ebp
.text$mn:00004EC8                 retn    8
.text$mn:00004EC8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00004EC8
.text$mn:00004EC8 ; ---------------------------------------------------------------------------
.text$mn:00004ECB                 align 4
.text$mn:00004ECB _text$mn        ends
.text$mn:00004ECB
.text$mn:00004ECC ; ===========================================================================
.text$mn:00004ECC
.text$mn:00004ECC ; Segment type: Pure code
.text$mn:00004ECC ; Segment permissions: Read/Execute
.text$mn:00004ECC _text$mn        segment para public 'CODE' use32
.text$mn:00004ECC                 assume cs:_text$mn
.text$mn:00004ECC                 ;org 4ECCh
.text$mn:00004ECC ; COMDAT (pick any)
.text$mn:00004ECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004ECC
.text$mn:00004ECC ; =============== S U B R O U T I N E =======================================
.text$mn:00004ECC
.text$mn:00004ECC ; Attributes: bp-based frame
.text$mn:00004ECC
.text$mn:00004ECC ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00004ECC                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00004ECC ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00004ECC                                         ; DATA XREF: .rdata:0000645Co
.text$mn:00004ECC                                         ; .rdata:00006478o ...
.text$mn:00004ECC
.text$mn:00004ECC var_4           = dword ptr -4
.text$mn:00004ECC arg_0           = dword ptr  8
.text$mn:00004ECC arg_4           = dword ptr  0Ch
.text$mn:00004ECC
.text$mn:00004ECC                 push    ebp
.text$mn:00004ECD                 mov     ebp, esp
.text$mn:00004ECF                 push    ecx
.text$mn:00004ED0                 mov     [ebp+var_4], ecx
.text$mn:00004ED3                 mov     eax, [ebp+var_4]
.text$mn:00004ED6                 push    eax             ; struct std::error_category *
.text$mn:00004ED7                 mov     ecx, [ebp+arg_4]
.text$mn:00004EDA                 push    ecx             ; int
.text$mn:00004EDB                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004EDE                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00004EE3                 mov     eax, [ebp+arg_0]
.text$mn:00004EE6                 mov     esp, ebp
.text$mn:00004EE8                 pop     ebp
.text$mn:00004EE9                 retn    8
.text$mn:00004EE9 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00004EE9
.text$mn:00004EE9 _text$mn        ends
.text$mn:00004EE9
.text$mn:00004EEC ; ===========================================================================
.text$mn:00004EEC
.text$mn:00004EEC ; Segment type: Pure code
.text$mn:00004EEC ; Segment permissions: Read/Execute
.text$mn:00004EEC _text$mn        segment para public 'CODE' use32
.text$mn:00004EEC                 assume cs:_text$mn
.text$mn:00004EEC                 ;org 4EECh
.text$mn:00004EEC ; COMDAT (pick any)
.text$mn:00004EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EEC
.text$mn:00004EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00004EEC
.text$mn:00004EEC ; Attributes: bp-based frame
.text$mn:00004EEC
.text$mn:00004EEC ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00004EEC                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00004EEC ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00004EEC                                         ; DATA XREF: .rdata:00006460o
.text$mn:00004EEC                                         ; .rdata:0000647Co ...
.text$mn:00004EEC
.text$mn:00004EEC var_8           = dword ptr -8
.text$mn:00004EEC var_4           = dword ptr -4
.text$mn:00004EEC arg_0           = dword ptr  8
.text$mn:00004EEC arg_4           = dword ptr  0Ch
.text$mn:00004EEC
.text$mn:00004EEC                 push    ebp
.text$mn:00004EED                 mov     ebp, esp
.text$mn:00004EEF                 sub     esp, 8
.text$mn:00004EF2                 mov     [ebp+var_8], ecx
.text$mn:00004EF5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004EF8                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00004EFD                 push    eax
.text$mn:00004EFE                 mov     ecx, [ebp+var_8]
.text$mn:00004F01                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00004F06                 movzx   eax, al
.text$mn:00004F09                 test    eax, eax
.text$mn:00004F0B                 jz      short loc_4F23
.text$mn:00004F0D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004F10                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00004F15                 cmp     eax, [ebp+arg_4]
.text$mn:00004F18                 jnz     short loc_4F23
.text$mn:00004F1A                 mov     [ebp+var_4], 1
.text$mn:00004F21                 jmp     short loc_4F2A
.text$mn:00004F23 ; ---------------------------------------------------------------------------
.text$mn:00004F23
.text$mn:00004F23 loc_4F23:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00004F23                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00004F23                 mov     [ebp+var_4], 0
.text$mn:00004F2A
.text$mn:00004F2A loc_4F2A:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00004F2A                 mov     al, byte ptr [ebp+var_4]
.text$mn:00004F2D                 mov     esp, ebp
.text$mn:00004F2F                 pop     ebp
.text$mn:00004F30                 retn    8
.text$mn:00004F30 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00004F30
.text$mn:00004F30 ; ---------------------------------------------------------------------------
.text$mn:00004F33                 align 4
.text$mn:00004F33 _text$mn        ends
.text$mn:00004F33
.text$mn:00004F34 ; ===========================================================================
.text$mn:00004F34
.text$mn:00004F34 ; Segment type: Pure code
.text$mn:00004F34 ; Segment permissions: Read/Execute
.text$mn:00004F34 _text$mn        segment para public 'CODE' use32
.text$mn:00004F34                 assume cs:_text$mn
.text$mn:00004F34                 ;org 4F34h
.text$mn:00004F34 ; COMDAT (pick any)
.text$mn:00004F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F34
.text$mn:00004F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F34
.text$mn:00004F34 ; Attributes: bp-based frame
.text$mn:00004F34
.text$mn:00004F34 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00004F34                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00004F34 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00004F34                                         ; DATA XREF: .rdata:00006464o
.text$mn:00004F34                                         ; .rdata:00006480o ...
.text$mn:00004F34
.text$mn:00004F34 var_C           = byte ptr -0Ch
.text$mn:00004F34 var_4           = dword ptr -4
.text$mn:00004F34 arg_0           = dword ptr  8
.text$mn:00004F34 arg_4           = dword ptr  0Ch
.text$mn:00004F34
.text$mn:00004F34                 push    ebp
.text$mn:00004F35                 mov     ebp, esp
.text$mn:00004F37                 sub     esp, 0Ch
.text$mn:00004F3A                 mov     [ebp+var_4], ecx
.text$mn:00004F3D                 mov     eax, [ebp+arg_4]
.text$mn:00004F40                 push    eax             ; std::error_condition *
.text$mn:00004F41                 mov     ecx, [ebp+arg_0]
.text$mn:00004F44                 push    ecx
.text$mn:00004F45                 lea     edx, [ebp+var_C]
.text$mn:00004F48                 push    edx
.text$mn:00004F49                 mov     eax, [ebp+var_4]
.text$mn:00004F4C                 mov     edx, [eax]
.text$mn:00004F4E                 mov     ecx, [ebp+var_4]
.text$mn:00004F51                 mov     eax, [edx+0Ch]
.text$mn:00004F54                 call    eax
.text$mn:00004F56                 mov     ecx, eax
.text$mn:00004F58                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00004F5D                 mov     esp, ebp
.text$mn:00004F5F                 pop     ebp
.text$mn:00004F60                 retn    8
.text$mn:00004F60 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00004F60
.text$mn:00004F60 ; ---------------------------------------------------------------------------
.text$mn:00004F63                 align 4
.text$mn:00004F63 _text$mn        ends
.text$mn:00004F63
.text$mn:00004F64 ; ===========================================================================
.text$mn:00004F64
.text$mn:00004F64 ; Segment type: Pure code
.text$mn:00004F64 ; Segment permissions: Read/Execute
.text$mn:00004F64 _text$mn        segment para public 'CODE' use32
.text$mn:00004F64                 assume cs:_text$mn
.text$mn:00004F64                 ;org 4F64h
.text$mn:00004F64 ; COMDAT (pick any)
.text$mn:00004F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F64
.text$mn:00004F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F64
.text$mn:00004F64 ; Attributes: bp-based frame
.text$mn:00004F64
.text$mn:00004F64 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00004F64                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00004F64 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00004F64                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00004F64
.text$mn:00004F64 var_4           = dword ptr -4
.text$mn:00004F64 arg_0           = dword ptr  8
.text$mn:00004F64
.text$mn:00004F64                 push    ebp
.text$mn:00004F65                 mov     ebp, esp
.text$mn:00004F67                 push    ecx
.text$mn:00004F68                 mov     [ebp+var_4], ecx
.text$mn:00004F6B                 mov     eax, [ebp+var_4]
.text$mn:00004F6E                 mov     ecx, [eax+14h]
.text$mn:00004F71                 cmp     ecx, [ebp+arg_0]
.text$mn:00004F74                 jnb     short loc_4F7E
.text$mn:00004F76                 mov     ecx, [ebp+var_4]
.text$mn:00004F79                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00004F7E
.text$mn:00004F7E loc_4F7E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00004F7E                 mov     edx, [ebp+arg_0]
.text$mn:00004F81                 push    edx
.text$mn:00004F82                 mov     ecx, [ebp+var_4]
.text$mn:00004F85                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004F8A                 mov     eax, [ebp+var_4]
.text$mn:00004F8D                 mov     esp, ebp
.text$mn:00004F8F                 pop     ebp
.text$mn:00004F90                 retn    4
.text$mn:00004F90 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00004F90
.text$mn:00004F90 ; ---------------------------------------------------------------------------
.text$mn:00004F93                 align 4
.text$mn:00004F93 _text$mn        ends
.text$mn:00004F93
.text$mn:00004F94 ; ===========================================================================
.text$mn:00004F94
.text$mn:00004F94 ; Segment type: Pure code
.text$mn:00004F94 ; Segment permissions: Read/Execute
.text$mn:00004F94 _text$mn        segment para public 'CODE' use32
.text$mn:00004F94                 assume cs:_text$mn
.text$mn:00004F94                 ;org 4F94h
.text$mn:00004F94 ; COMDAT (pick any)
.text$mn:00004F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F94
.text$mn:00004F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F94
.text$mn:00004F94 ; Attributes: bp-based frame
.text$mn:00004F94
.text$mn:00004F94 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00004F94                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00004F94 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00004F94                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00004F94
.text$mn:00004F94 var_C           = dword ptr -0Ch
.text$mn:00004F94 Dst             = dword ptr -8
.text$mn:00004F94 var_4           = dword ptr -4
.text$mn:00004F94 arg_0           = dword ptr  8
.text$mn:00004F94 arg_4           = dword ptr  0Ch
.text$mn:00004F94
.text$mn:00004F94                 push    ebp
.text$mn:00004F95                 mov     ebp, esp
.text$mn:00004F97                 sub     esp, 0Ch
.text$mn:00004F9A                 mov     [ebp+var_4], ecx
.text$mn:00004F9D                 mov     eax, [ebp+var_4]
.text$mn:00004FA0                 mov     ecx, [eax+14h]
.text$mn:00004FA3                 cmp     ecx, [ebp+arg_0]
.text$mn:00004FA6                 jnb     short loc_4FB0
.text$mn:00004FA8                 mov     ecx, [ebp+var_4]
.text$mn:00004FAB                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00004FB0
.text$mn:00004FB0 loc_4FB0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00004FB0                 mov     edx, [ebp+var_4]
.text$mn:00004FB3                 mov     eax, [edx+14h]
.text$mn:00004FB6                 sub     eax, [ebp+arg_0]
.text$mn:00004FB9                 cmp     eax, [ebp+arg_4]
.text$mn:00004FBC                 ja      short loc_4FCC
.text$mn:00004FBE                 mov     ecx, [ebp+arg_0]
.text$mn:00004FC1                 push    ecx
.text$mn:00004FC2                 mov     ecx, [ebp+var_4]
.text$mn:00004FC5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004FCA                 jmp     short loc_5012
.text$mn:00004FCC ; ---------------------------------------------------------------------------
.text$mn:00004FCC
.text$mn:00004FCC loc_4FCC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00004FCC                 cmp     [ebp+arg_4], 0
.text$mn:00004FD0                 jbe     short loc_5012
.text$mn:00004FD2                 mov     ecx, [ebp+var_4]
.text$mn:00004FD5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004FDA                 add     eax, [ebp+arg_0]
.text$mn:00004FDD                 mov     [ebp+Dst], eax
.text$mn:00004FE0                 mov     edx, [ebp+var_4]
.text$mn:00004FE3                 mov     eax, [edx+14h]
.text$mn:00004FE6                 sub     eax, [ebp+arg_4]
.text$mn:00004FE9                 mov     [ebp+var_C], eax
.text$mn:00004FEC                 mov     ecx, [ebp+var_C]
.text$mn:00004FEF                 sub     ecx, [ebp+arg_0]
.text$mn:00004FF2                 push    ecx             ; Size
.text$mn:00004FF3                 mov     edx, [ebp+Dst]
.text$mn:00004FF6                 add     edx, [ebp+arg_4]
.text$mn:00004FF9                 push    edx             ; Src
.text$mn:00004FFA                 mov     eax, [ebp+Dst]
.text$mn:00004FFD                 push    eax             ; Dst
.text$mn:00004FFE                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00005003                 add     esp, 0Ch
.text$mn:00005006                 mov     ecx, [ebp+var_C]
.text$mn:00005009                 push    ecx
.text$mn:0000500A                 mov     ecx, [ebp+var_4]
.text$mn:0000500D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005012
.text$mn:00005012 loc_5012:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00005012                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00005012                 mov     eax, [ebp+var_4]
.text$mn:00005015                 mov     esp, ebp
.text$mn:00005017                 pop     ebp
.text$mn:00005018                 retn    8
.text$mn:00005018 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00005018
.text$mn:00005018 ; ---------------------------------------------------------------------------
.text$mn:0000501B                 align 4
.text$mn:0000501B _text$mn        ends
.text$mn:0000501B
.text$mn:0000501C ; ===========================================================================
.text$mn:0000501C
.text$mn:0000501C ; Segment type: Pure code
.text$mn:0000501C ; Segment permissions: Read/Execute
.text$mn:0000501C _text$mn        segment para public 'CODE' use32
.text$mn:0000501C                 assume cs:_text$mn
.text$mn:0000501C                 ;org 501Ch
.text$mn:0000501C ; COMDAT (pick any)
.text$mn:0000501C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000501C
.text$mn:0000501C ; =============== S U B R O U T I N E =======================================
.text$mn:0000501C
.text$mn:0000501C ; Attributes: bp-based frame
.text$mn:0000501C
.text$mn:0000501C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:0000501C                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:0000501C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000501C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:0000501C
.text$mn:0000501C var_4           = dword ptr -4
.text$mn:0000501C arg_0           = dword ptr  8
.text$mn:0000501C
.text$mn:0000501C                 push    ebp
.text$mn:0000501D                 mov     ebp, esp
.text$mn:0000501F                 push    ecx
.text$mn:00005020                 mov     [ebp+var_4], ecx
.text$mn:00005023                 mov     eax, [ebp+var_4]
.text$mn:00005026                 mov     ecx, [eax+14h]
.text$mn:00005029                 cmp     ecx, [ebp+arg_0]
.text$mn:0000502C                 jnb     short loc_5036
.text$mn:0000502E                 mov     ecx, [ebp+var_4]
.text$mn:00005031                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00005036
.text$mn:00005036 loc_5036:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:00005036                 mov     edx, [ebp+arg_0]
.text$mn:00005039                 push    edx
.text$mn:0000503A                 mov     ecx, [ebp+var_4]
.text$mn:0000503D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005042                 mov     eax, [ebp+var_4]
.text$mn:00005045                 mov     esp, ebp
.text$mn:00005047                 pop     ebp
.text$mn:00005048                 retn    4
.text$mn:00005048 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00005048
.text$mn:00005048 ; ---------------------------------------------------------------------------
.text$mn:0000504B                 align 4
.text$mn:0000504B _text$mn        ends
.text$mn:0000504B
.text$mn:0000504C ; ===========================================================================
.text$mn:0000504C
.text$mn:0000504C ; Segment type: Pure code
.text$mn:0000504C ; Segment permissions: Read/Execute
.text$mn:0000504C _text$mn        segment para public 'CODE' use32
.text$mn:0000504C                 assume cs:_text$mn
.text$mn:0000504C                 ;org 504Ch
.text$mn:0000504C ; COMDAT (pick any)
.text$mn:0000504C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000504C
.text$mn:0000504C ; =============== S U B R O U T I N E =======================================
.text$mn:0000504C
.text$mn:0000504C ; Attributes: bp-based frame
.text$mn:0000504C
.text$mn:0000504C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0000504C                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0000504C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000504C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0000504C
.text$mn:0000504C var_C           = dword ptr -0Ch
.text$mn:0000504C Dst             = dword ptr -8
.text$mn:0000504C var_4           = dword ptr -4
.text$mn:0000504C arg_0           = dword ptr  8
.text$mn:0000504C arg_4           = dword ptr  0Ch
.text$mn:0000504C
.text$mn:0000504C                 push    ebp
.text$mn:0000504D                 mov     ebp, esp
.text$mn:0000504F                 sub     esp, 0Ch
.text$mn:00005052                 mov     [ebp+var_4], ecx
.text$mn:00005055                 mov     eax, [ebp+var_4]
.text$mn:00005058                 mov     ecx, [eax+14h]
.text$mn:0000505B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000505E                 jnb     short loc_5068
.text$mn:00005060                 mov     ecx, [ebp+var_4]
.text$mn:00005063                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00005068
.text$mn:00005068 loc_5068:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00005068                 mov     edx, [ebp+var_4]
.text$mn:0000506B                 mov     eax, [edx+14h]
.text$mn:0000506E                 sub     eax, [ebp+arg_0]
.text$mn:00005071                 cmp     eax, [ebp+arg_4]
.text$mn:00005074                 ja      short loc_5084
.text$mn:00005076                 mov     ecx, [ebp+arg_0]
.text$mn:00005079                 push    ecx
.text$mn:0000507A                 mov     ecx, [ebp+var_4]
.text$mn:0000507D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005082                 jmp     short loc_50D0
.text$mn:00005084 ; ---------------------------------------------------------------------------
.text$mn:00005084
.text$mn:00005084 loc_5084:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00005084                 cmp     [ebp+arg_4], 0
.text$mn:00005088                 jbe     short loc_50D0
.text$mn:0000508A                 mov     ecx, [ebp+var_4]
.text$mn:0000508D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00005092                 mov     edx, [ebp+arg_0]
.text$mn:00005095                 lea     eax, [eax+edx*2]
.text$mn:00005098                 mov     [ebp+Dst], eax
.text$mn:0000509B                 mov     ecx, [ebp+var_4]
.text$mn:0000509E                 mov     edx, [ecx+14h]
.text$mn:000050A1                 sub     edx, [ebp+arg_4]
.text$mn:000050A4                 mov     [ebp+var_C], edx
.text$mn:000050A7                 mov     eax, [ebp+var_C]
.text$mn:000050AA                 sub     eax, [ebp+arg_0]
.text$mn:000050AD                 push    eax             ; int
.text$mn:000050AE                 mov     ecx, [ebp+arg_4]
.text$mn:000050B1                 mov     edx, [ebp+Dst]
.text$mn:000050B4                 lea     eax, [edx+ecx*2]
.text$mn:000050B7                 push    eax             ; Src
.text$mn:000050B8                 mov     ecx, [ebp+Dst]
.text$mn:000050BB                 push    ecx             ; Dst
.text$mn:000050BC                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000050C1                 add     esp, 0Ch
.text$mn:000050C4                 mov     edx, [ebp+var_C]
.text$mn:000050C7                 push    edx
.text$mn:000050C8                 mov     ecx, [ebp+var_4]
.text$mn:000050CB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000050D0
.text$mn:000050D0 loc_50D0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:000050D0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:000050D0                 mov     eax, [ebp+var_4]
.text$mn:000050D3                 mov     esp, ebp
.text$mn:000050D5                 pop     ebp
.text$mn:000050D6                 retn    8
.text$mn:000050D6 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:000050D6
.text$mn:000050D6 ; ---------------------------------------------------------------------------
.text$mn:000050D9                 align 4
.text$mn:000050D9 _text$mn        ends
.text$mn:000050D9
.text$mn:000050DC ; ===========================================================================
.text$mn:000050DC
.text$mn:000050DC ; Segment type: Pure code
.text$mn:000050DC ; Segment permissions: Read/Execute
.text$mn:000050DC _text$mn        segment para public 'CODE' use32
.text$mn:000050DC                 assume cs:_text$mn
.text$mn:000050DC                 ;org 50DCh
.text$mn:000050DC ; COMDAT (pick any)
.text$mn:000050DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050DC
.text$mn:000050DC ; =============== S U B R O U T I N E =======================================
.text$mn:000050DC
.text$mn:000050DC ; Attributes: bp-based frame
.text$mn:000050DC
.text$mn:000050DC ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000050DC                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000050DC ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000050DC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000050DC                 push    ebp
.text$mn:000050DD                 mov     ebp, esp
.text$mn:000050DF                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000050E4                 pop     ebp
.text$mn:000050E5                 retn
.text$mn:000050E5 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000050E5
.text$mn:000050E5 ; ---------------------------------------------------------------------------
.text$mn:000050E6                 align 4
.text$mn:000050E6 _text$mn        ends
.text$mn:000050E6
.text$mn:000050E8 ; ===========================================================================
.text$mn:000050E8
.text$mn:000050E8 ; Segment type: Pure code
.text$mn:000050E8 ; Segment permissions: Read/Execute
.text$mn:000050E8 _text$mn        segment para public 'CODE' use32
.text$mn:000050E8                 assume cs:_text$mn
.text$mn:000050E8                 ;org 50E8h
.text$mn:000050E8 ; COMDAT (pick any)
.text$mn:000050E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050E8
.text$mn:000050E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000050E8
.text$mn:000050E8 ; Attributes: bp-based frame
.text$mn:000050E8
.text$mn:000050E8 ; const wchar_t *__thiscall Buffer::getFileName(Buffer *__hidden this)
.text$mn:000050E8                 public ?getFileName@Buffer@@QBEPB_WXZ
.text$mn:000050E8 ?getFileName@Buffer@@QBEPB_WXZ proc near
.text$mn:000050E8                                         ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+28p
.text$mn:000050E8                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+1F6p ...
.text$mn:000050E8
.text$mn:000050E8 var_4           = dword ptr -4
.text$mn:000050E8
.text$mn:000050E8                 push    ebp
.text$mn:000050E9                 mov     ebp, esp
.text$mn:000050EB                 push    ecx
.text$mn:000050EC                 mov     [ebp+var_4], ecx
.text$mn:000050EF                 mov     eax, [ebp+var_4]
.text$mn:000050F2                 mov     eax, [eax+0A8h]
.text$mn:000050F8                 mov     esp, ebp
.text$mn:000050FA                 pop     ebp
.text$mn:000050FB                 retn
.text$mn:000050FB ?getFileName@Buffer@@QBEPB_WXZ endp
.text$mn:000050FB
.text$mn:000050FB _text$mn        ends
.text$mn:000050FB
.text$mn:000050FC ; ===========================================================================
.text$mn:000050FC
.text$mn:000050FC ; Segment type: Pure code
.text$mn:000050FC ; Segment permissions: Read/Execute
.text$mn:000050FC _text$mn        segment para public 'CODE' use32
.text$mn:000050FC                 assume cs:_text$mn
.text$mn:000050FC                 ;org 50FCh
.text$mn:000050FC ; COMDAT (pick any)
.text$mn:000050FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050FC
.text$mn:000050FC ; =============== S U B R O U T I N E =======================================
.text$mn:000050FC
.text$mn:000050FC ; Attributes: bp-based frame
.text$mn:000050FC
.text$mn:000050FC ; bool __thiscall Buffer::getFileReadOnly(Buffer *__hidden this)
.text$mn:000050FC                 public ?getFileReadOnly@Buffer@@QBE_NXZ
.text$mn:000050FC ?getFileReadOnly@Buffer@@QBE_NXZ proc near
.text$mn:000050FC                                         ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+C1p
.text$mn:000050FC                                         ; VerticalFileSwitcherListView::add(int,int)+1BFp
.text$mn:000050FC
.text$mn:000050FC var_4           = dword ptr -4
.text$mn:000050FC
.text$mn:000050FC                 push    ebp
.text$mn:000050FD                 mov     ebp, esp
.text$mn:000050FF                 push    ecx
.text$mn:00005100                 mov     [ebp+var_4], ecx
.text$mn:00005103                 mov     eax, [ebp+var_4]
.text$mn:00005106                 mov     al, [eax+88h]
.text$mn:0000510C                 mov     esp, ebp
.text$mn:0000510E                 pop     ebp
.text$mn:0000510F                 retn
.text$mn:0000510F ?getFileReadOnly@Buffer@@QBE_NXZ endp
.text$mn:0000510F
.text$mn:0000510F _text$mn        ends
.text$mn:0000510F
.text$mn:00005110 ; ===========================================================================
.text$mn:00005110
.text$mn:00005110 ; Segment type: Pure code
.text$mn:00005110 ; Segment permissions: Read/Execute
.text$mn:00005110 _text$mn        segment para public 'CODE' use32
.text$mn:00005110                 assume cs:_text$mn
.text$mn:00005110                 ;org 5110h
.text$mn:00005110 ; COMDAT (pick any)
.text$mn:00005110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005110
.text$mn:00005110 ; =============== S U B R O U T I N E =======================================
.text$mn:00005110
.text$mn:00005110 ; Attributes: bp-based frame
.text$mn:00005110
.text$mn:00005110 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00005110                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00005110 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00005110                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+94p
.text$mn:00005110                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+42p ...
.text$mn:00005110                 push    ebp
.text$mn:00005111                 mov     ebp, esp
.text$mn:00005113                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00005118                 pop     ebp
.text$mn:00005119                 retn
.text$mn:00005119 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00005119
.text$mn:00005119 ; ---------------------------------------------------------------------------
.text$mn:0000511A                 align 4
.text$mn:0000511A _text$mn        ends
.text$mn:0000511A
.text$mn:0000511C ; ===========================================================================
.text$mn:0000511C
.text$mn:0000511C ; Segment type: Pure code
.text$mn:0000511C ; Segment permissions: Read/Execute
.text$mn:0000511C _text$mn        segment para public 'CODE' use32
.text$mn:0000511C                 assume cs:_text$mn
.text$mn:0000511C                 ;org 511Ch
.text$mn:0000511C ; COMDAT (pick any)
.text$mn:0000511C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000511C
.text$mn:0000511C ; =============== S U B R O U T I N E =======================================
.text$mn:0000511C
.text$mn:0000511C ; Attributes: bp-based frame
.text$mn:0000511C
.text$mn:0000511C ; struct NativeLangSpeaker *__thiscall NppParameters::getNativeLangSpeaker(NppParameters *__hidden this)
.text$mn:0000511C                 public ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ
.text$mn:0000511C ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ proc near
.text$mn:0000511C                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+A5p
.text$mn:0000511C
.text$mn:0000511C var_4           = dword ptr -4
.text$mn:0000511C
.text$mn:0000511C                 push    ebp
.text$mn:0000511D                 mov     ebp, esp
.text$mn:0000511F                 push    ecx
.text$mn:00005120                 mov     [ebp+var_4], ecx
.text$mn:00005123                 mov     eax, [ebp+var_4]
.text$mn:00005126                 mov     eax, [eax+1CC20h]
.text$mn:0000512C                 mov     esp, ebp
.text$mn:0000512E                 pop     ebp
.text$mn:0000512F                 retn
.text$mn:0000512F ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ endp
.text$mn:0000512F
.text$mn:0000512F _text$mn        ends
.text$mn:0000512F
.text$mn:00005130 ; ===========================================================================
.text$mn:00005130
.text$mn:00005130 ; Segment type: Pure code
.text$mn:00005130 ; Segment permissions: Read/Execute
.text$mn:00005130 _text$mn        segment para public 'CODE' use32
.text$mn:00005130                 assume cs:_text$mn
.text$mn:00005130                 ;org 5130h
.text$mn:00005130 ; COMDAT (pick any)
.text$mn:00005130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005130
.text$mn:00005130 ; =============== S U B R O U T I N E =======================================
.text$mn:00005130
.text$mn:00005130 ; Attributes: bp-based frame
.text$mn:00005130
.text$mn:00005130 ; const struct NppGUI *__thiscall NppParameters::getNppGUI(NppParameters *__hidden this)
.text$mn:00005130                 public ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ
.text$mn:00005130 ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ proc near
.text$mn:00005130                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+B6p
.text$mn:00005130                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+49p ...
.text$mn:00005130
.text$mn:00005130 var_4           = dword ptr -4
.text$mn:00005130
.text$mn:00005130                 push    ebp
.text$mn:00005131                 mov     ebp, esp
.text$mn:00005133                 push    ecx
.text$mn:00005134                 mov     [ebp+var_4], ecx
.text$mn:00005137                 mov     eax, [ebp+var_4]
.text$mn:0000513A                 add     eax, 118h
.text$mn:0000513F                 mov     esp, ebp
.text$mn:00005141                 pop     ebp
.text$mn:00005142                 retn
.text$mn:00005142 ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ endp
.text$mn:00005142
.text$mn:00005142 ; ---------------------------------------------------------------------------
.text$mn:00005143                 align 4
.text$mn:00005143 _text$mn        ends
.text$mn:00005143
.text$mn:00005144 ; ===========================================================================
.text$mn:00005144
.text$mn:00005144 ; Segment type: Pure code
.text$mn:00005144 ; Segment permissions: Read/Execute
.text$mn:00005144 _text$mn        segment para public 'CODE' use32
.text$mn:00005144                 assume cs:_text$mn
.text$mn:00005144                 ;org 5144h
.text$mn:00005144 ; COMDAT (pick any)
.text$mn:00005144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005144
.text$mn:00005144 ; =============== S U B R O U T I N E =======================================
.text$mn:00005144
.text$mn:00005144 ; Attributes: bp-based frame
.text$mn:00005144
.text$mn:00005144 ; bool __thiscall Buffer::getUserReadOnly(Buffer *__hidden this)
.text$mn:00005144                 public ?getUserReadOnly@Buffer@@QBE_NXZ
.text$mn:00005144 ?getUserReadOnly@Buffer@@QBE_NXZ proc near
.text$mn:00005144                                         ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+AFp
.text$mn:00005144                                         ; VerticalFileSwitcherListView::add(int,int)+1ADp
.text$mn:00005144
.text$mn:00005144 var_4           = dword ptr -4
.text$mn:00005144
.text$mn:00005144                 push    ebp
.text$mn:00005145                 mov     ebp, esp
.text$mn:00005147                 push    ecx
.text$mn:00005148                 mov     [ebp+var_4], ecx
.text$mn:0000514B                 mov     eax, [ebp+var_4]
.text$mn:0000514E                 mov     al, [eax+44h]
.text$mn:00005151                 mov     esp, ebp
.text$mn:00005153                 pop     ebp
.text$mn:00005154                 retn
.text$mn:00005154 ?getUserReadOnly@Buffer@@QBE_NXZ endp
.text$mn:00005154
.text$mn:00005154 ; ---------------------------------------------------------------------------
.text$mn:00005155                 align 4
.text$mn:00005155 _text$mn        ends
.text$mn:00005155
.text$mn:00005158 ; ===========================================================================
.text$mn:00005158
.text$mn:00005158 ; Segment type: Pure code
.text$mn:00005158 ; Segment permissions: Read/Execute
.text$mn:00005158 _text$mn        segment para public 'CODE' use32
.text$mn:00005158                 assume cs:_text$mn
.text$mn:00005158                 ;org 5158h
.text$mn:00005158 ; COMDAT (pick any)
.text$mn:00005158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005158
.text$mn:00005158 ; =============== S U B R O U T I N E =======================================
.text$mn:00005158
.text$mn:00005158 ; Attributes: bp-based frame
.text$mn:00005158
.text$mn:00005158 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00005158                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00005158 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00005158                                         ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+14p
.text$mn:00005158
.text$mn:00005158 var_4           = dword ptr -4
.text$mn:00005158 arg_0           = dword ptr  8
.text$mn:00005158 arg_4           = dword ptr  0Ch
.text$mn:00005158
.text$mn:00005158                 push    ebp
.text$mn:00005159                 mov     ebp, esp
.text$mn:0000515B                 push    ecx
.text$mn:0000515C                 mov     [ebp+var_4], ecx
.text$mn:0000515F                 mov     eax, [ebp+var_4]
.text$mn:00005162                 mov     ecx, [ebp+arg_0]
.text$mn:00005165                 mov     [eax+4], ecx
.text$mn:00005168                 mov     edx, [ebp+var_4]
.text$mn:0000516B                 mov     eax, [ebp+arg_4]
.text$mn:0000516E                 mov     [edx+8], eax
.text$mn:00005171                 mov     esp, ebp
.text$mn:00005173                 pop     ebp
.text$mn:00005174                 retn    8
.text$mn:00005174 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00005174
.text$mn:00005174 ; ---------------------------------------------------------------------------
.text$mn:00005177                 align 4
.text$mn:00005177 _text$mn        ends
.text$mn:00005177
.text$mn:00005178 ; ===========================================================================
.text$mn:00005178
.text$mn:00005178 ; Segment type: Pure code
.text$mn:00005178 ; Segment permissions: Read/Execute
.text$mn:00005178 _text$mn        segment para public 'CODE' use32
.text$mn:00005178                 assume cs:_text$mn
.text$mn:00005178                 ;org 5178h
.text$mn:00005178 ; COMDAT (pick any)
.text$mn:00005178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005178
.text$mn:00005178 ; =============== S U B R O U T I N E =======================================
.text$mn:00005178
.text$mn:00005178 ; Attributes: bp-based frame
.text$mn:00005178
.text$mn:00005178 ; bool __thiscall Buffer::isDirty(Buffer *__hidden this)
.text$mn:00005178                 public ?isDirty@Buffer@@QBE_NXZ
.text$mn:00005178 ?isDirty@Buffer@@QBE_NXZ proc near      ; CODE XREF: VerticalFileSwitcherListView::setItemIconStatus(int)+D3p
.text$mn:00005178                                         ; VerticalFileSwitcherListView::add(int,int)+1D1p
.text$mn:00005178
.text$mn:00005178 var_4           = dword ptr -4
.text$mn:00005178
.text$mn:00005178                 push    ebp
.text$mn:00005179                 mov     ebp, esp
.text$mn:0000517B                 push    ecx
.text$mn:0000517C                 mov     [ebp+var_4], ecx
.text$mn:0000517F                 mov     eax, [ebp+var_4]
.text$mn:00005182                 mov     al, [eax+34h]
.text$mn:00005185                 mov     esp, ebp
.text$mn:00005187                 pop     ebp
.text$mn:00005188                 retn
.text$mn:00005188 ?isDirty@Buffer@@QBE_NXZ endp
.text$mn:00005188
.text$mn:00005188 ; ---------------------------------------------------------------------------
.text$mn:00005189                 align 4
.text$mn:00005189 _text$mn        ends
.text$mn:00005189
.text$mn:0000518C ; ===========================================================================
.text$mn:0000518C
.text$mn:0000518C ; Segment type: Pure code
.text$mn:0000518C ; Segment permissions: Read/Execute
.text$mn:0000518C _text$mn        segment para public 'CODE' use32
.text$mn:0000518C                 assume cs:_text$mn
.text$mn:0000518C                 ;org 518Ch
.text$mn:0000518C ; COMDAT (pick any)
.text$mn:0000518C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000518C
.text$mn:0000518C ; =============== S U B R O U T I N E =======================================
.text$mn:0000518C
.text$mn:0000518C ; Attributes: bp-based frame
.text$mn:0000518C
.text$mn:0000518C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000518C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000518C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000518C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000518C
.text$mn:0000518C var_4           = dword ptr -4
.text$mn:0000518C Str             = dword ptr  8
.text$mn:0000518C
.text$mn:0000518C                 push    ebp
.text$mn:0000518D                 mov     ebp, esp
.text$mn:0000518F                 push    ecx
.text$mn:00005190                 mov     eax, [ebp+Str]
.text$mn:00005193                 movsx   ecx, byte ptr [eax]
.text$mn:00005196                 test    ecx, ecx
.text$mn:00005198                 jnz     short loc_51A3
.text$mn:0000519A                 mov     [ebp+var_4], 0
.text$mn:000051A1                 jmp     short loc_51B2
.text$mn:000051A3 ; ---------------------------------------------------------------------------
.text$mn:000051A3
.text$mn:000051A3 loc_51A3:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:000051A3                 mov     edx, [ebp+Str]
.text$mn:000051A6                 push    edx             ; Str
.text$mn:000051A7                 call    _strlen
.text$mn:000051AC                 add     esp, 4
.text$mn:000051AF                 mov     [ebp+var_4], eax
.text$mn:000051B2
.text$mn:000051B2 loc_51B2:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:000051B2                 mov     eax, [ebp+var_4]
.text$mn:000051B5                 mov     esp, ebp
.text$mn:000051B7                 pop     ebp
.text$mn:000051B8                 retn
.text$mn:000051B8 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:000051B8
.text$mn:000051B8 ; ---------------------------------------------------------------------------
.text$mn:000051B9                 align 4
.text$mn:000051B9 _text$mn        ends
.text$mn:000051B9
.text$mn:000051BC ; ===========================================================================
.text$mn:000051BC
.text$mn:000051BC ; Segment type: Pure code
.text$mn:000051BC ; Segment permissions: Read/Execute
.text$mn:000051BC _text$mn        segment para public 'CODE' use32
.text$mn:000051BC                 assume cs:_text$mn
.text$mn:000051BC                 ;org 51BCh
.text$mn:000051BC ; COMDAT (pick any)
.text$mn:000051BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051BC
.text$mn:000051BC ; =============== S U B R O U T I N E =======================================
.text$mn:000051BC
.text$mn:000051BC ; Attributes: bp-based frame
.text$mn:000051BC
.text$mn:000051BC ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:000051BC                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:000051BC ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:000051BC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:000051BC
.text$mn:000051BC var_4           = dword ptr -4
.text$mn:000051BC Str             = dword ptr  8
.text$mn:000051BC
.text$mn:000051BC                 push    ebp
.text$mn:000051BD                 mov     ebp, esp
.text$mn:000051BF                 push    ecx
.text$mn:000051C0                 mov     eax, [ebp+Str]
.text$mn:000051C3                 movzx   ecx, word ptr [eax]
.text$mn:000051C6                 test    ecx, ecx
.text$mn:000051C8                 jnz     short loc_51D3
.text$mn:000051CA                 mov     [ebp+var_4], 0
.text$mn:000051D1                 jmp     short loc_51E2
.text$mn:000051D3 ; ---------------------------------------------------------------------------
.text$mn:000051D3
.text$mn:000051D3 loc_51D3:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:000051D3                 mov     edx, [ebp+Str]
.text$mn:000051D6                 push    edx             ; Str
.text$mn:000051D7                 call    _wcslen
.text$mn:000051DC                 add     esp, 4
.text$mn:000051DF                 mov     [ebp+var_4], eax
.text$mn:000051E2
.text$mn:000051E2 loc_51E2:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:000051E2                 mov     eax, [ebp+var_4]
.text$mn:000051E5                 mov     esp, ebp
.text$mn:000051E7                 pop     ebp
.text$mn:000051E8                 retn
.text$mn:000051E8 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:000051E8
.text$mn:000051E8 ; ---------------------------------------------------------------------------
.text$mn:000051E9                 align 4
.text$mn:000051E9 _text$mn        ends
.text$mn:000051E9
.text$mn:000051EC ; ===========================================================================
.text$mn:000051EC
.text$mn:000051EC ; Segment type: Pure code
.text$mn:000051EC ; Segment permissions: Read/Execute
.text$mn:000051EC _text$mn        segment para public 'CODE' use32
.text$mn:000051EC                 assume cs:_text$mn
.text$mn:000051EC                 ;org 51ECh
.text$mn:000051EC ; COMDAT (pick any)
.text$mn:000051EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051EC
.text$mn:000051EC ; =============== S U B R O U T I N E =======================================
.text$mn:000051EC
.text$mn:000051EC ; Attributes: bp-based frame
.text$mn:000051EC
.text$mn:000051EC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000051EC                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000051EC ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000051EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000051EC
.text$mn:000051EC var_4           = dword ptr -4
.text$mn:000051EC
.text$mn:000051EC                 push    ebp
.text$mn:000051ED                 mov     ebp, esp
.text$mn:000051EF                 push    ecx
.text$mn:000051F0                 mov     [ebp+var_4], ecx
.text$mn:000051F3                 mov     eax, [ebp+var_4]
.text$mn:000051F6                 push    eax
.text$mn:000051F7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000051FC                 add     esp, 4
.text$mn:000051FF                 mov     esp, ebp
.text$mn:00005201                 pop     ebp
.text$mn:00005202                 retn
.text$mn:00005202 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00005202
.text$mn:00005202 ; ---------------------------------------------------------------------------
.text$mn:00005203                 align 4
.text$mn:00005203 _text$mn        ends
.text$mn:00005203
.text$mn:00005204 ; ===========================================================================
.text$mn:00005204
.text$mn:00005204 ; Segment type: Pure code
.text$mn:00005204 ; Segment permissions: Read/Execute
.text$mn:00005204 _text$mn        segment para public 'CODE' use32
.text$mn:00005204                 assume cs:_text$mn
.text$mn:00005204                 ;org 5204h
.text$mn:00005204 ; COMDAT (pick any)
.text$mn:00005204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005204
.text$mn:00005204 ; =============== S U B R O U T I N E =======================================
.text$mn:00005204
.text$mn:00005204 ; Attributes: bp-based frame
.text$mn:00005204
.text$mn:00005204 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct SwitcherFileInfo>>::max_size(void)const
.text$mn:00005204                 public ?max_size@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ
.text$mn:00005204 ?max_size@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00005204                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::max_size(void)+17p
.text$mn:00005204
.text$mn:00005204 var_4           = dword ptr -4
.text$mn:00005204
.text$mn:00005204                 push    ebp
.text$mn:00005205                 mov     ebp, esp
.text$mn:00005207                 push    ecx
.text$mn:00005208                 mov     [ebp+var_4], ecx
.text$mn:0000520B                 mov     eax, [ebp+var_4]
.text$mn:0000520E                 push    eax
.text$mn:0000520F                 call    ?max_size@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAIABV?$allocator@USwitcherFileInfo@@@2@@Z ; std::allocator_traits<std::allocator<SwitcherFileInfo>>::max_size(std::allocator<SwitcherFileInfo> const &)
.text$mn:00005214                 add     esp, 4
.text$mn:00005217                 mov     esp, ebp
.text$mn:00005219                 pop     ebp
.text$mn:0000521A                 retn
.text$mn:0000521A ?max_size@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000521A
.text$mn:0000521A ; ---------------------------------------------------------------------------
.text$mn:0000521B                 align 4
.text$mn:0000521B _text$mn        ends
.text$mn:0000521B
.text$mn:0000521C ; ===========================================================================
.text$mn:0000521C
.text$mn:0000521C ; Segment type: Pure code
.text$mn:0000521C ; Segment permissions: Read/Execute
.text$mn:0000521C _text$mn        segment para public 'CODE' use32
.text$mn:0000521C                 assume cs:_text$mn
.text$mn:0000521C                 ;org 521Ch
.text$mn:0000521C ; COMDAT (pick any)
.text$mn:0000521C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000521C
.text$mn:0000521C ; =============== S U B R O U T I N E =======================================
.text$mn:0000521C
.text$mn:0000521C ; Attributes: bp-based frame
.text$mn:0000521C
.text$mn:0000521C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000521C                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000521C ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000521C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000521C
.text$mn:0000521C var_4           = dword ptr -4
.text$mn:0000521C
.text$mn:0000521C                 push    ebp
.text$mn:0000521D                 mov     ebp, esp
.text$mn:0000521F                 push    ecx
.text$mn:00005220                 mov     [ebp+var_4], ecx
.text$mn:00005223                 mov     eax, [ebp+var_4]
.text$mn:00005226                 push    eax
.text$mn:00005227                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:0000522C                 add     esp, 4
.text$mn:0000522F                 mov     esp, ebp
.text$mn:00005231                 pop     ebp
.text$mn:00005232                 retn
.text$mn:00005232 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:00005232
.text$mn:00005232 ; ---------------------------------------------------------------------------
.text$mn:00005233                 align 4
.text$mn:00005233 _text$mn        ends
.text$mn:00005233
.text$mn:00005234 ; ===========================================================================
.text$mn:00005234
.text$mn:00005234 ; Segment type: Pure code
.text$mn:00005234 ; Segment permissions: Read/Execute
.text$mn:00005234 _text$mn        segment para public 'CODE' use32
.text$mn:00005234                 assume cs:_text$mn
.text$mn:00005234                 ;org 5234h
.text$mn:00005234 ; COMDAT (pick any)
.text$mn:00005234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005234
.text$mn:00005234 ; =============== S U B R O U T I N E =======================================
.text$mn:00005234
.text$mn:00005234 ; Attributes: bp-based frame
.text$mn:00005234
.text$mn:00005234 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00005234                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00005234 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00005234                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00005234
.text$mn:00005234 var_4           = dword ptr -4
.text$mn:00005234
.text$mn:00005234                 push    ebp
.text$mn:00005235                 mov     ebp, esp
.text$mn:00005237                 push    ecx
.text$mn:00005238                 mov     [ebp+var_4], ecx
.text$mn:0000523B                 or      eax, 0FFFFFFFFh
.text$mn:0000523E                 mov     esp, ebp
.text$mn:00005240                 pop     ebp
.text$mn:00005241                 retn
.text$mn:00005241 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00005241
.text$mn:00005241 ; ---------------------------------------------------------------------------
.text$mn:00005242                 align 4
.text$mn:00005242 _text$mn        ends
.text$mn:00005242
.text$mn:00005244 ; ===========================================================================
.text$mn:00005244
.text$mn:00005244 ; Segment type: Pure code
.text$mn:00005244 ; Segment permissions: Read/Execute
.text$mn:00005244 _text$mn        segment para public 'CODE' use32
.text$mn:00005244                 assume cs:_text$mn
.text$mn:00005244                 ;org 5244h
.text$mn:00005244 ; COMDAT (pick any)
.text$mn:00005244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005244
.text$mn:00005244 ; =============== S U B R O U T I N E =======================================
.text$mn:00005244
.text$mn:00005244 ; Attributes: bp-based frame
.text$mn:00005244
.text$mn:00005244 ; public: unsigned int __thiscall std::allocator<struct SwitcherFileInfo>::max_size(void)const
.text$mn:00005244                 public ?max_size@?$allocator@USwitcherFileInfo@@@std@@QBEIXZ
.text$mn:00005244 ?max_size@?$allocator@USwitcherFileInfo@@@std@@QBEIXZ proc near
.text$mn:00005244                                         ; CODE XREF: std::allocator_traits<std::allocator<SwitcherFileInfo>>::max_size(std::allocator<SwitcherFileInfo> const &)+6p
.text$mn:00005244
.text$mn:00005244 var_4           = dword ptr -4
.text$mn:00005244
.text$mn:00005244                 push    ebp
.text$mn:00005245                 mov     ebp, esp
.text$mn:00005247                 push    ecx
.text$mn:00005248                 mov     [ebp+var_4], ecx
.text$mn:0000524B                 mov     eax, 1FFFFFFFh
.text$mn:00005250                 mov     esp, ebp
.text$mn:00005252                 pop     ebp
.text$mn:00005253                 retn
.text$mn:00005253 ?max_size@?$allocator@USwitcherFileInfo@@@std@@QBEIXZ endp
.text$mn:00005253
.text$mn:00005253 _text$mn        ends
.text$mn:00005253
.text$mn:00005254 ; ===========================================================================
.text$mn:00005254
.text$mn:00005254 ; Segment type: Pure code
.text$mn:00005254 ; Segment permissions: Read/Execute
.text$mn:00005254 _text$mn        segment para public 'CODE' use32
.text$mn:00005254                 assume cs:_text$mn
.text$mn:00005254                 ;org 5254h
.text$mn:00005254 ; COMDAT (pick any)
.text$mn:00005254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005254
.text$mn:00005254 ; =============== S U B R O U T I N E =======================================
.text$mn:00005254
.text$mn:00005254 ; Attributes: bp-based frame
.text$mn:00005254
.text$mn:00005254 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:00005254                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:00005254 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:00005254                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:00005254
.text$mn:00005254 var_4           = dword ptr -4
.text$mn:00005254
.text$mn:00005254                 push    ebp
.text$mn:00005255                 mov     ebp, esp
.text$mn:00005257                 push    ecx
.text$mn:00005258                 mov     [ebp+var_4], ecx
.text$mn:0000525B                 mov     eax, 7FFFFFFFh
.text$mn:00005260                 mov     esp, ebp
.text$mn:00005262                 pop     ebp
.text$mn:00005263                 retn
.text$mn:00005263 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:00005263
.text$mn:00005263 _text$mn        ends
.text$mn:00005263
.text$mn:00005264 ; ===========================================================================
.text$mn:00005264
.text$mn:00005264 ; Segment type: Pure code
.text$mn:00005264 ; Segment permissions: Read/Execute
.text$mn:00005264 _text$mn        segment para public 'CODE' use32
.text$mn:00005264                 assume cs:_text$mn
.text$mn:00005264                 ;org 5264h
.text$mn:00005264 ; COMDAT (pick any)
.text$mn:00005264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005264
.text$mn:00005264 ; =============== S U B R O U T I N E =======================================
.text$mn:00005264
.text$mn:00005264 ; Attributes: bp-based frame
.text$mn:00005264
.text$mn:00005264 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00005264                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00005264 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00005264                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00005264
.text$mn:00005264 arg_0           = dword ptr  8
.text$mn:00005264
.text$mn:00005264                 push    ebp
.text$mn:00005265                 mov     ebp, esp
.text$mn:00005267                 mov     ecx, [ebp+arg_0]
.text$mn:0000526A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000526F                 pop     ebp
.text$mn:00005270                 retn
.text$mn:00005270 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00005270
.text$mn:00005270 ; ---------------------------------------------------------------------------
.text$mn:00005271                 align 4
.text$mn:00005271 _text$mn        ends
.text$mn:00005271
.text$mn:00005274 ; ===========================================================================
.text$mn:00005274
.text$mn:00005274 ; Segment type: Pure code
.text$mn:00005274 ; Segment permissions: Read/Execute
.text$mn:00005274 _text$mn        segment para public 'CODE' use32
.text$mn:00005274                 assume cs:_text$mn
.text$mn:00005274                 ;org 5274h
.text$mn:00005274 ; COMDAT (pick any)
.text$mn:00005274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005274
.text$mn:00005274 ; =============== S U B R O U T I N E =======================================
.text$mn:00005274
.text$mn:00005274 ; Attributes: bp-based frame
.text$mn:00005274
.text$mn:00005274 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct SwitcherFileInfo>>::max_size(class std::allocator<struct SwitcherFileInfo> const &)
.text$mn:00005274                 public ?max_size@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAIABV?$allocator@USwitcherFileInfo@@@2@@Z
.text$mn:00005274 ?max_size@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAIABV?$allocator@USwitcherFileInfo@@@2@@Z proc near
.text$mn:00005274                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::max_size(void)+Bp
.text$mn:00005274
.text$mn:00005274 arg_0           = dword ptr  8
.text$mn:00005274
.text$mn:00005274                 push    ebp
.text$mn:00005275                 mov     ebp, esp
.text$mn:00005277                 mov     ecx, [ebp+arg_0]
.text$mn:0000527A                 call    ?max_size@?$allocator@USwitcherFileInfo@@@std@@QBEIXZ ; std::allocator<SwitcherFileInfo>::max_size(void)
.text$mn:0000527F                 pop     ebp
.text$mn:00005280                 retn
.text$mn:00005280 ?max_size@?$allocator_traits@V?$allocator@USwitcherFileInfo@@@std@@@std@@SAIABV?$allocator@USwitcherFileInfo@@@2@@Z endp
.text$mn:00005280
.text$mn:00005280 ; ---------------------------------------------------------------------------
.text$mn:00005281                 align 4
.text$mn:00005281 _text$mn        ends
.text$mn:00005281
.text$mn:00005284 ; ===========================================================================
.text$mn:00005284
.text$mn:00005284 ; Segment type: Pure code
.text$mn:00005284 ; Segment permissions: Read/Execute
.text$mn:00005284 _text$mn        segment para public 'CODE' use32
.text$mn:00005284                 assume cs:_text$mn
.text$mn:00005284                 ;org 5284h
.text$mn:00005284 ; COMDAT (pick any)
.text$mn:00005284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005284
.text$mn:00005284 ; =============== S U B R O U T I N E =======================================
.text$mn:00005284
.text$mn:00005284 ; Attributes: bp-based frame
.text$mn:00005284
.text$mn:00005284 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:00005284                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:00005284 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:00005284                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:00005284
.text$mn:00005284 arg_0           = dword ptr  8
.text$mn:00005284
.text$mn:00005284                 push    ebp
.text$mn:00005285                 mov     ebp, esp
.text$mn:00005287                 mov     ecx, [ebp+arg_0]
.text$mn:0000528A                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000528F                 pop     ebp
.text$mn:00005290                 retn
.text$mn:00005290 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:00005290
.text$mn:00005290 ; ---------------------------------------------------------------------------
.text$mn:00005291                 align 4
.text$mn:00005291 _text$mn        ends
.text$mn:00005291
.text$mn:00005294 ; ===========================================================================
.text$mn:00005294
.text$mn:00005294 ; Segment type: Pure code
.text$mn:00005294 ; Segment permissions: Read/Execute
.text$mn:00005294 _text$mn        segment para public 'CODE' use32
.text$mn:00005294                 assume cs:_text$mn
.text$mn:00005294                 ;org 5294h
.text$mn:00005294 ; COMDAT (pick any)
.text$mn:00005294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005294
.text$mn:00005294 ; =============== S U B R O U T I N E =======================================
.text$mn:00005294
.text$mn:00005294 ; Attributes: bp-based frame
.text$mn:00005294
.text$mn:00005294 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00005294                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00005294 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00005294                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00005294                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00005294
.text$mn:00005294 var_10          = dword ptr -10h
.text$mn:00005294 var_C           = dword ptr -0Ch
.text$mn:00005294 var_8           = dword ptr -8
.text$mn:00005294 var_1           = byte ptr -1
.text$mn:00005294
.text$mn:00005294                 push    ebp
.text$mn:00005295                 mov     ebp, esp
.text$mn:00005297                 sub     esp, 10h
.text$mn:0000529A                 mov     [ebp+var_10], ecx
.text$mn:0000529D                 lea     eax, [ebp+var_1]
.text$mn:000052A0                 push    eax
.text$mn:000052A1                 mov     ecx, [ebp+var_10]
.text$mn:000052A4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000052A9                 mov     ecx, eax
.text$mn:000052AB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000052B0                 mov     [ebp+var_8], eax
.text$mn:000052B3                 cmp     [ebp+var_8], 1
.text$mn:000052B7                 ja      short loc_52C2
.text$mn:000052B9                 mov     [ebp+var_C], 1
.text$mn:000052C0                 jmp     short loc_52CB
.text$mn:000052C2 ; ---------------------------------------------------------------------------
.text$mn:000052C2
.text$mn:000052C2 loc_52C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000052C2                 mov     ecx, [ebp+var_8]
.text$mn:000052C5                 sub     ecx, 1
.text$mn:000052C8                 mov     [ebp+var_C], ecx
.text$mn:000052CB
.text$mn:000052CB loc_52CB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000052CB                 mov     eax, [ebp+var_C]
.text$mn:000052CE                 mov     esp, ebp
.text$mn:000052D0                 pop     ebp
.text$mn:000052D1                 retn
.text$mn:000052D1 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000052D1
.text$mn:000052D1 ; ---------------------------------------------------------------------------
.text$mn:000052D2                 align 4
.text$mn:000052D2 _text$mn        ends
.text$mn:000052D2
.text$mn:000052D4 ; ===========================================================================
.text$mn:000052D4
.text$mn:000052D4 ; Segment type: Pure code
.text$mn:000052D4 ; Segment permissions: Read/Execute
.text$mn:000052D4 _text$mn        segment para public 'CODE' use32
.text$mn:000052D4                 assume cs:_text$mn
.text$mn:000052D4                 ;org 52D4h
.text$mn:000052D4 ; COMDAT (pick any)
.text$mn:000052D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052D4
.text$mn:000052D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000052D4
.text$mn:000052D4 ; Attributes: bp-based frame
.text$mn:000052D4
.text$mn:000052D4 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:000052D4                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:000052D4 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:000052D4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:000052D4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:000052D4
.text$mn:000052D4 var_10          = dword ptr -10h
.text$mn:000052D4 var_C           = dword ptr -0Ch
.text$mn:000052D4 var_8           = dword ptr -8
.text$mn:000052D4 var_1           = byte ptr -1
.text$mn:000052D4
.text$mn:000052D4                 push    ebp
.text$mn:000052D5                 mov     ebp, esp
.text$mn:000052D7                 sub     esp, 10h
.text$mn:000052DA                 mov     [ebp+var_10], ecx
.text$mn:000052DD                 lea     eax, [ebp+var_1]
.text$mn:000052E0                 push    eax
.text$mn:000052E1                 mov     ecx, [ebp+var_10]
.text$mn:000052E4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000052E9                 mov     ecx, eax
.text$mn:000052EB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:000052F0                 mov     [ebp+var_8], eax
.text$mn:000052F3                 cmp     [ebp+var_8], 1
.text$mn:000052F7                 ja      short loc_5302
.text$mn:000052F9                 mov     [ebp+var_C], 1
.text$mn:00005300                 jmp     short loc_530B
.text$mn:00005302 ; ---------------------------------------------------------------------------
.text$mn:00005302
.text$mn:00005302 loc_5302:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:00005302                 mov     ecx, [ebp+var_8]
.text$mn:00005305                 sub     ecx, 1
.text$mn:00005308                 mov     [ebp+var_C], ecx
.text$mn:0000530B
.text$mn:0000530B loc_530B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000530B                 mov     eax, [ebp+var_C]
.text$mn:0000530E                 mov     esp, ebp
.text$mn:00005310                 pop     ebp
.text$mn:00005311                 retn
.text$mn:00005311 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00005311
.text$mn:00005311 ; ---------------------------------------------------------------------------
.text$mn:00005312                 align 4
.text$mn:00005312 _text$mn        ends
.text$mn:00005312
.text$mn:00005314 ; ===========================================================================
.text$mn:00005314
.text$mn:00005314 ; Segment type: Pure code
.text$mn:00005314 ; Segment permissions: Read/Execute
.text$mn:00005314 _text$mn        segment para public 'CODE' use32
.text$mn:00005314                 assume cs:_text$mn
.text$mn:00005314                 ;org 5314h
.text$mn:00005314 ; COMDAT (pick any)
.text$mn:00005314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005314
.text$mn:00005314 ; =============== S U B R O U T I N E =======================================
.text$mn:00005314
.text$mn:00005314 ; Attributes: bp-based frame
.text$mn:00005314
.text$mn:00005314 ; public: unsigned int __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::max_size(void)const
.text$mn:00005314                 public ?max_size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ
.text$mn:00005314 ?max_size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00005314                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Grow_to(uint)+17p
.text$mn:00005314                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+18p
.text$mn:00005314
.text$mn:00005314 var_8           = dword ptr -8
.text$mn:00005314 var_1           = byte ptr -1
.text$mn:00005314
.text$mn:00005314                 push    ebp
.text$mn:00005315                 mov     ebp, esp
.text$mn:00005317                 sub     esp, 8
.text$mn:0000531A                 mov     [ebp+var_8], ecx
.text$mn:0000531D                 lea     eax, [ebp+var_1]
.text$mn:00005320                 push    eax
.text$mn:00005321                 mov     ecx, [ebp+var_8]
.text$mn:00005324                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:00005329                 mov     ecx, eax
.text$mn:0000532B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::max_size(void)
.text$mn:00005330                 mov     esp, ebp
.text$mn:00005332                 pop     ebp
.text$mn:00005333                 retn
.text$mn:00005333 ?max_size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:00005333
.text$mn:00005333 _text$mn        ends
.text$mn:00005333
.text$mn:00005334 ; ===========================================================================
.text$mn:00005334
.text$mn:00005334 ; Segment type: Pure code
.text$mn:00005334 ; Segment permissions: Read/Execute
.text$mn:00005334 _text$mn        segment para public 'CODE' use32
.text$mn:00005334                 assume cs:_text$mn
.text$mn:00005334                 ;org 5334h
.text$mn:00005334 ; COMDAT (pick any)
.text$mn:00005334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005334
.text$mn:00005334 ; =============== S U B R O U T I N E =======================================
.text$mn:00005334
.text$mn:00005334 ; Attributes: bp-based frame
.text$mn:00005334
.text$mn:00005334 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00005334                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00005334 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00005334                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00005334                                         ; DATA XREF: .rdata:00006474o
.text$mn:00005334
.text$mn:00005334 var_1C          = dword ptr -1Ch
.text$mn:00005334 var_18          = dword ptr -18h
.text$mn:00005334 Str             = dword ptr -14h
.text$mn:00005334 var_10          = dword ptr -10h
.text$mn:00005334 var_C           = dword ptr -0Ch
.text$mn:00005334 var_4           = dword ptr -4
.text$mn:00005334 arg_0           = dword ptr  8
.text$mn:00005334 arg_4           = dword ptr  0Ch
.text$mn:00005334
.text$mn:00005334                 push    ebp
.text$mn:00005335                 mov     ebp, esp
.text$mn:00005337                 push    0FFFFFFFFh
.text$mn:00005339                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000533E                 mov     eax, large fs:0
.text$mn:00005344                 push    eax
.text$mn:00005345                 sub     esp, 10h
.text$mn:00005348                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000534D                 xor     eax, ebp
.text$mn:0000534F                 push    eax
.text$mn:00005350                 lea     eax, [ebp+var_C]
.text$mn:00005353                 mov     large fs:0, eax
.text$mn:00005359                 mov     [ebp+var_1C], ecx
.text$mn:0000535C                 mov     [ebp+var_18], 0
.text$mn:00005363                 mov     eax, [ebp+arg_4]
.text$mn:00005366                 push    eax             ; int
.text$mn:00005367                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000536C                 add     esp, 4
.text$mn:0000536F                 mov     [ebp+var_10], eax
.text$mn:00005372                 cmp     [ebp+var_10], 0
.text$mn:00005376                 jz      short loc_5380
.text$mn:00005378                 mov     ecx, [ebp+var_10]
.text$mn:0000537B                 mov     [ebp+Str], ecx
.text$mn:0000537E                 jmp     short loc_5387
.text$mn:00005380 ; ---------------------------------------------------------------------------
.text$mn:00005380
.text$mn:00005380 loc_5380:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00005380                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00005387
.text$mn:00005387 loc_5387:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00005387                 mov     edx, [ebp+Str]
.text$mn:0000538A                 push    edx             ; Str
.text$mn:0000538B                 mov     ecx, [ebp+arg_0]
.text$mn:0000538E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00005393                 mov     [ebp+var_4], 0
.text$mn:0000539A                 mov     eax, [ebp+var_18]
.text$mn:0000539D                 or      eax, 1
.text$mn:000053A0                 mov     [ebp+var_18], eax
.text$mn:000053A3                 mov     eax, [ebp+arg_0]
.text$mn:000053A6                 mov     ecx, [ebp+var_C]
.text$mn:000053A9                 mov     large fs:0, ecx
.text$mn:000053B0                 pop     ecx
.text$mn:000053B1                 mov     esp, ebp
.text$mn:000053B3                 pop     ebp
.text$mn:000053B4                 retn    8
.text$mn:000053B4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000053B4
.text$mn:000053B4 ; ---------------------------------------------------------------------------
.text$mn:000053B7                 align 4
.text$mn:000053B7 _text$mn        ends
.text$mn:000053B7
.text$x:000053B8 ; ===========================================================================
.text$x:000053B8
.text$x:000053B8 ; Segment type: Pure code
.text$x:000053B8 ; Segment permissions: Read/Execute
.text$x:000053B8 _text$x         segment para public 'CODE' use32
.text$x:000053B8                 assume cs:_text$x
.text$x:000053B8                 ;org 53B8h
.text$x:000053B8 ; COMDAT (pick associative to section at 5334)
.text$x:000053B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000053B8
.text$x:000053B8 ; =============== S U B R O U T I N E =======================================
.text$x:000053B8
.text$x:000053B8
.text$x:000053B8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000053B8                                         ; DATA XREF: .xdata$x:00005B2Co
.text$x:000053B8                 mov     eax, [ebp-18h]
.text$x:000053BB                 and     eax, 1
.text$x:000053BE                 jz      $LN6
.text$x:000053C4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000053C8                 mov     ecx, [ebp+8]
.text$x:000053CB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000053D0 ; ---------------------------------------------------------------------------
.text$x:000053D0
.text$x:000053D0 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000053D0                 retn
.text$x:000053D0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000053D0
.text$x:000053D1
.text$x:000053D1 ; =============== S U B R O U T I N E =======================================
.text$x:000053D1
.text$x:000053D1
.text$x:000053D1 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000053D1                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:000053D1
.text$x:000053D1 arg_4           = dword ptr  8
.text$x:000053D1
.text$x:000053D1                 mov     edx, [esp+arg_4]
.text$x:000053D5                 lea     eax, [edx+0Ch]
.text$x:000053D8                 mov     ecx, [edx-14h]
.text$x:000053DB                 xor     ecx, eax
.text$x:000053DD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000053E2                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000053E7                 jmp     ___CxxFrameHandler3
.text$x:000053E7 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000053E7
.text$x:000053E7 _text$x         ends
.text$x:000053E7
.text$mn:000053EC ; ===========================================================================
.text$mn:000053EC
.text$mn:000053EC ; Segment type: Pure code
.text$mn:000053EC ; Segment permissions: Read/Execute
.text$mn:000053EC _text$mn        segment para public 'CODE' use32
.text$mn:000053EC                 assume cs:_text$mn
.text$mn:000053EC                 ;org 53ECh
.text$mn:000053EC ; COMDAT (pick any)
.text$mn:000053EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053EC
.text$mn:000053EC ; =============== S U B R O U T I N E =======================================
.text$mn:000053EC
.text$mn:000053EC ; Attributes: bp-based frame
.text$mn:000053EC
.text$mn:000053EC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000053EC                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000053EC ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000053EC                                         ; DATA XREF: .rdata:000064A8o
.text$mn:000053EC
.text$mn:000053EC var_14          = dword ptr -14h
.text$mn:000053EC var_10          = dword ptr -10h
.text$mn:000053EC var_C           = dword ptr -0Ch
.text$mn:000053EC var_4           = dword ptr -4
.text$mn:000053EC arg_0           = dword ptr  8
.text$mn:000053EC arg_4           = dword ptr  0Ch
.text$mn:000053EC
.text$mn:000053EC                 push    ebp
.text$mn:000053ED                 mov     ebp, esp
.text$mn:000053EF                 push    0FFFFFFFFh
.text$mn:000053F1                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000053F6                 mov     eax, large fs:0
.text$mn:000053FC                 push    eax
.text$mn:000053FD                 sub     esp, 8
.text$mn:00005400                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005405                 xor     eax, ebp
.text$mn:00005407                 push    eax
.text$mn:00005408                 lea     eax, [ebp+var_C]
.text$mn:0000540B                 mov     large fs:0, eax
.text$mn:00005411                 mov     [ebp+var_14], ecx
.text$mn:00005414                 mov     [ebp+var_10], 0
.text$mn:0000541B                 cmp     [ebp+arg_4], 1
.text$mn:0000541F                 jnz     short loc_5445
.text$mn:00005421                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00005426                 mov     ecx, [ebp+arg_0]
.text$mn:00005429                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000542E                 mov     [ebp+var_4], 0
.text$mn:00005435                 mov     eax, [ebp+var_10]
.text$mn:00005438                 or      eax, 1
.text$mn:0000543B                 mov     [ebp+var_10], eax
.text$mn:0000543E                 mov     eax, [ebp+arg_0]
.text$mn:00005441                 jmp     short loc_5468
.text$mn:00005443 ; ---------------------------------------------------------------------------
.text$mn:00005443                 jmp     short loc_5468
.text$mn:00005445 ; ---------------------------------------------------------------------------
.text$mn:00005445
.text$mn:00005445 loc_5445:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00005445                 mov     ecx, [ebp+arg_4]
.text$mn:00005448                 push    ecx
.text$mn:00005449                 mov     edx, [ebp+arg_0]
.text$mn:0000544C                 push    edx
.text$mn:0000544D                 mov     ecx, [ebp+var_14]
.text$mn:00005450                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00005455                 mov     [ebp+var_4], 0
.text$mn:0000545C                 mov     eax, [ebp+var_10]
.text$mn:0000545F                 or      eax, 1
.text$mn:00005462                 mov     [ebp+var_10], eax
.text$mn:00005465                 mov     eax, [ebp+arg_0]
.text$mn:00005468
.text$mn:00005468 loc_5468:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00005468                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00005468                 mov     ecx, [ebp+var_C]
.text$mn:0000546B                 mov     large fs:0, ecx
.text$mn:00005472                 pop     ecx
.text$mn:00005473                 mov     esp, ebp
.text$mn:00005475                 pop     ebp
.text$mn:00005476                 retn    8
.text$mn:00005476 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00005476
.text$mn:00005476 ; ---------------------------------------------------------------------------
.text$mn:00005479                 align 4
.text$mn:00005479 _text$mn        ends
.text$mn:00005479
.text$x:0000547C ; ===========================================================================
.text$x:0000547C
.text$x:0000547C ; Segment type: Pure code
.text$x:0000547C ; Segment permissions: Read/Execute
.text$x:0000547C _text$x         segment para public 'CODE' use32
.text$x:0000547C                 assume cs:_text$x
.text$x:0000547C                 ;org 547Ch
.text$x:0000547C ; COMDAT (pick associative to section at 53EC)
.text$x:0000547C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000547C
.text$x:0000547C ; =============== S U B R O U T I N E =======================================
.text$x:0000547C
.text$x:0000547C
.text$x:0000547C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000547C                                         ; DATA XREF: .xdata$x:00005BB0o
.text$x:0000547C                 mov     eax, [ebp-10h]
.text$x:0000547F                 and     eax, 1
.text$x:00005482                 jz      $LN6_0
.text$x:00005488                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000548C                 mov     ecx, [ebp+8]
.text$x:0000548F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00005494 ; ---------------------------------------------------------------------------
.text$x:00005494
.text$x:00005494 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00005494                 retn
.text$x:00005494 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00005494
.text$x:00005495
.text$x:00005495 ; =============== S U B R O U T I N E =======================================
.text$x:00005495
.text$x:00005495
.text$x:00005495 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00005495                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00005495
.text$x:00005495 arg_4           = dword ptr  8
.text$x:00005495
.text$x:00005495                 mov     edx, [esp+arg_4]
.text$x:00005499                 lea     eax, [edx+0Ch]
.text$x:0000549C                 mov     ecx, [edx-0Ch]
.text$x:0000549F                 xor     ecx, eax
.text$x:000054A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000054A6                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000054AB                 jmp     ___CxxFrameHandler3
.text$x:000054AB __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000054AB
.text$x:000054AB _text$x         ends
.text$x:000054AB
.text$mn:000054B0 ; ===========================================================================
.text$mn:000054B0
.text$mn:000054B0 ; Segment type: Pure code
.text$mn:000054B0 ; Segment permissions: Read/Execute
.text$mn:000054B0 _text$mn        segment para public 'CODE' use32
.text$mn:000054B0                 assume cs:_text$mn
.text$mn:000054B0                 ;org 54B0h
.text$mn:000054B0 ; COMDAT (pick any)
.text$mn:000054B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054B0
.text$mn:000054B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054B0
.text$mn:000054B0 ; Attributes: bp-based frame
.text$mn:000054B0
.text$mn:000054B0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000054B0                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000054B0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000054B0                                         ; DATA XREF: .rdata:000064E8o
.text$mn:000054B0
.text$mn:000054B0 var_1C          = dword ptr -1Ch
.text$mn:000054B0 var_18          = dword ptr -18h
.text$mn:000054B0 Str             = dword ptr -14h
.text$mn:000054B0 var_10          = dword ptr -10h
.text$mn:000054B0 var_C           = dword ptr -0Ch
.text$mn:000054B0 var_4           = dword ptr -4
.text$mn:000054B0 arg_0           = dword ptr  8
.text$mn:000054B0 arg_4           = dword ptr  0Ch
.text$mn:000054B0
.text$mn:000054B0                 push    ebp
.text$mn:000054B1                 mov     ebp, esp
.text$mn:000054B3                 push    0FFFFFFFFh
.text$mn:000054B5                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000054BA                 mov     eax, large fs:0
.text$mn:000054C0                 push    eax
.text$mn:000054C1                 sub     esp, 10h
.text$mn:000054C4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000054C9                 xor     eax, ebp
.text$mn:000054CB                 push    eax
.text$mn:000054CC                 lea     eax, [ebp+var_C]
.text$mn:000054CF                 mov     large fs:0, eax
.text$mn:000054D5                 mov     [ebp+var_1C], ecx
.text$mn:000054D8                 mov     [ebp+var_18], 0
.text$mn:000054DF                 mov     eax, [ebp+arg_4]
.text$mn:000054E2                 push    eax             ; int
.text$mn:000054E3                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:000054E8                 add     esp, 4
.text$mn:000054EB                 mov     [ebp+var_10], eax
.text$mn:000054EE                 cmp     [ebp+var_10], 0
.text$mn:000054F2                 jz      short loc_54FC
.text$mn:000054F4                 mov     ecx, [ebp+var_10]
.text$mn:000054F7                 mov     [ebp+Str], ecx
.text$mn:000054FA                 jmp     short loc_5503
.text$mn:000054FC ; ---------------------------------------------------------------------------
.text$mn:000054FC
.text$mn:000054FC loc_54FC:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000054FC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00005503
.text$mn:00005503 loc_5503:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00005503                 mov     edx, [ebp+Str]
.text$mn:00005506                 push    edx             ; Str
.text$mn:00005507                 mov     ecx, [ebp+arg_0]
.text$mn:0000550A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000550F                 mov     [ebp+var_4], 0
.text$mn:00005516                 mov     eax, [ebp+var_18]
.text$mn:00005519                 or      eax, 1
.text$mn:0000551C                 mov     [ebp+var_18], eax
.text$mn:0000551F                 mov     eax, [ebp+arg_0]
.text$mn:00005522                 mov     ecx, [ebp+var_C]
.text$mn:00005525                 mov     large fs:0, ecx
.text$mn:0000552C                 pop     ecx
.text$mn:0000552D                 mov     esp, ebp
.text$mn:0000552F                 pop     ebp
.text$mn:00005530                 retn    8
.text$mn:00005530 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00005530
.text$mn:00005530 ; ---------------------------------------------------------------------------
.text$mn:00005533                 align 4
.text$mn:00005533 _text$mn        ends
.text$mn:00005533
.text$x:00005534 ; ===========================================================================
.text$x:00005534
.text$x:00005534 ; Segment type: Pure code
.text$x:00005534 ; Segment permissions: Read/Execute
.text$x:00005534 _text$x         segment para public 'CODE' use32
.text$x:00005534                 assume cs:_text$x
.text$x:00005534                 ;org 5534h
.text$x:00005534 ; COMDAT (pick associative to section at 54B0)
.text$x:00005534                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005534
.text$x:00005534 ; =============== S U B R O U T I N E =======================================
.text$x:00005534
.text$x:00005534
.text$x:00005534 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00005534                                         ; DATA XREF: .xdata$x:00005C34o
.text$x:00005534                 mov     eax, [ebp-18h]
.text$x:00005537                 and     eax, 1
.text$x:0000553A                 jz      $LN6_1
.text$x:00005540                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00005544                 mov     ecx, [ebp+8]
.text$x:00005547                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000554C ; ---------------------------------------------------------------------------
.text$x:0000554C
.text$x:0000554C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000554C                 retn
.text$x:0000554C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000554C
.text$x:0000554D
.text$x:0000554D ; =============== S U B R O U T I N E =======================================
.text$x:0000554D
.text$x:0000554D
.text$x:0000554D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000554D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000554D
.text$x:0000554D arg_4           = dword ptr  8
.text$x:0000554D
.text$x:0000554D                 mov     edx, [esp+arg_4]
.text$x:00005551                 lea     eax, [edx+0Ch]
.text$x:00005554                 mov     ecx, [edx-14h]
.text$x:00005557                 xor     ecx, eax
.text$x:00005559                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000555E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00005563                 jmp     ___CxxFrameHandler3
.text$x:00005563 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00005563
.text$x:00005563 _text$x         ends
.text$x:00005563
.text$mn:00005568 ; ===========================================================================
.text$mn:00005568
.text$mn:00005568 ; Segment type: Pure code
.text$mn:00005568 ; Segment permissions: Read/Execute
.text$mn:00005568 _text$mn        segment para public 'CODE' use32
.text$mn:00005568                 assume cs:_text$mn
.text$mn:00005568                 ;org 5568h
.text$mn:00005568 ; COMDAT (pick any)
.text$mn:00005568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005568
.text$mn:00005568 ; =============== S U B R O U T I N E =======================================
.text$mn:00005568
.text$mn:00005568 ; Attributes: bp-based frame
.text$mn:00005568
.text$mn:00005568 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00005568                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00005568 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00005568                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00005568
.text$mn:00005568 var_4           = dword ptr -4
.text$mn:00005568 Dst             = dword ptr  8
.text$mn:00005568 Src             = dword ptr  0Ch
.text$mn:00005568 Size            = dword ptr  10h
.text$mn:00005568
.text$mn:00005568                 push    ebp
.text$mn:00005569                 mov     ebp, esp
.text$mn:0000556B                 push    ecx
.text$mn:0000556C                 cmp     [ebp+Size], 0
.text$mn:00005570                 jnz     short loc_557A
.text$mn:00005572                 mov     eax, [ebp+Dst]
.text$mn:00005575                 mov     [ebp+var_4], eax
.text$mn:00005578                 jmp     short loc_5591
.text$mn:0000557A ; ---------------------------------------------------------------------------
.text$mn:0000557A
.text$mn:0000557A loc_557A:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000557A                 mov     ecx, [ebp+Size]
.text$mn:0000557D                 push    ecx             ; Size
.text$mn:0000557E                 mov     edx, [ebp+Src]
.text$mn:00005581                 push    edx             ; Src
.text$mn:00005582                 mov     eax, [ebp+Dst]
.text$mn:00005585                 push    eax             ; Dst
.text$mn:00005586                 call    _memmove
.text$mn:0000558B                 add     esp, 0Ch
.text$mn:0000558E                 mov     [ebp+var_4], eax
.text$mn:00005591
.text$mn:00005591 loc_5591:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00005591                 mov     eax, [ebp+var_4]
.text$mn:00005594                 mov     esp, ebp
.text$mn:00005596                 pop     ebp
.text$mn:00005597                 retn
.text$mn:00005597 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00005597
.text$mn:00005597 _text$mn        ends
.text$mn:00005597
.text$mn:00005598 ; ===========================================================================
.text$mn:00005598
.text$mn:00005598 ; Segment type: Pure code
.text$mn:00005598 ; Segment permissions: Read/Execute
.text$mn:00005598 _text$mn        segment para public 'CODE' use32
.text$mn:00005598                 assume cs:_text$mn
.text$mn:00005598                 ;org 5598h
.text$mn:00005598 ; COMDAT (pick any)
.text$mn:00005598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005598
.text$mn:00005598 ; =============== S U B R O U T I N E =======================================
.text$mn:00005598
.text$mn:00005598 ; Attributes: bp-based frame
.text$mn:00005598
.text$mn:00005598 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00005598                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00005598 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00005598                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:00005598
.text$mn:00005598 var_4           = dword ptr -4
.text$mn:00005598 Dst             = dword ptr  8
.text$mn:00005598 Src             = dword ptr  0Ch
.text$mn:00005598 arg_8           = dword ptr  10h
.text$mn:00005598
.text$mn:00005598                 push    ebp
.text$mn:00005599                 mov     ebp, esp
.text$mn:0000559B                 push    ecx
.text$mn:0000559C                 cmp     [ebp+arg_8], 0
.text$mn:000055A0                 jnz     short loc_55AA
.text$mn:000055A2                 mov     eax, [ebp+Dst]
.text$mn:000055A5                 mov     [ebp+var_4], eax
.text$mn:000055A8                 jmp     short loc_55C1
.text$mn:000055AA ; ---------------------------------------------------------------------------
.text$mn:000055AA
.text$mn:000055AA loc_55AA:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000055AA                 mov     ecx, [ebp+arg_8]
.text$mn:000055AD                 push    ecx             ; int
.text$mn:000055AE                 mov     edx, [ebp+Src]
.text$mn:000055B1                 push    edx             ; Src
.text$mn:000055B2                 mov     eax, [ebp+Dst]
.text$mn:000055B5                 push    eax             ; Dst
.text$mn:000055B6                 call    _wmemmove
.text$mn:000055BB                 add     esp, 0Ch
.text$mn:000055BE                 mov     [ebp+var_4], eax
.text$mn:000055C1
.text$mn:000055C1 loc_55C1:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:000055C1                 mov     eax, [ebp+var_4]
.text$mn:000055C4                 mov     esp, ebp
.text$mn:000055C6                 pop     ebp
.text$mn:000055C7                 retn
.text$mn:000055C7 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:000055C7
.text$mn:000055C7 _text$mn        ends
.text$mn:000055C7
.text$mn:000055C8 ; ===========================================================================
.text$mn:000055C8
.text$mn:000055C8 ; Segment type: Pure code
.text$mn:000055C8 ; Segment permissions: Read/Execute
.text$mn:000055C8 _text$mn        segment para public 'CODE' use32
.text$mn:000055C8                 assume cs:_text$mn
.text$mn:000055C8                 ;org 55C8h
.text$mn:000055C8 ; COMDAT (pick any)
.text$mn:000055C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055C8
.text$mn:000055C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000055C8
.text$mn:000055C8 ; Attributes: bp-based frame
.text$mn:000055C8
.text$mn:000055C8 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000055C8                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000055C8 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000055C8                                         ; DATA XREF: .rdata:00006470o
.text$mn:000055C8
.text$mn:000055C8 var_4           = dword ptr -4
.text$mn:000055C8
.text$mn:000055C8                 push    ebp
.text$mn:000055C9                 mov     ebp, esp
.text$mn:000055CB                 push    ecx
.text$mn:000055CC                 mov     [ebp+var_4], ecx
.text$mn:000055CF                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:000055D4                 mov     esp, ebp
.text$mn:000055D6                 pop     ebp
.text$mn:000055D7                 retn
.text$mn:000055D7 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:000055D7
.text$mn:000055D7 _text$mn        ends
.text$mn:000055D7
.text$mn:000055D8 ; ===========================================================================
.text$mn:000055D8
.text$mn:000055D8 ; Segment type: Pure code
.text$mn:000055D8 ; Segment permissions: Read/Execute
.text$mn:000055D8 _text$mn        segment para public 'CODE' use32
.text$mn:000055D8                 assume cs:_text$mn
.text$mn:000055D8                 ;org 55D8h
.text$mn:000055D8 ; COMDAT (pick any)
.text$mn:000055D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055D8
.text$mn:000055D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000055D8
.text$mn:000055D8 ; Attributes: bp-based frame
.text$mn:000055D8
.text$mn:000055D8 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:000055D8                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:000055D8 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:000055D8                                         ; DATA XREF: .rdata:000064A4o
.text$mn:000055D8
.text$mn:000055D8 var_4           = dword ptr -4
.text$mn:000055D8
.text$mn:000055D8                 push    ebp
.text$mn:000055D9                 mov     ebp, esp
.text$mn:000055DB                 push    ecx
.text$mn:000055DC                 mov     [ebp+var_4], ecx
.text$mn:000055DF                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:000055E4                 mov     esp, ebp
.text$mn:000055E6                 pop     ebp
.text$mn:000055E7                 retn
.text$mn:000055E7 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:000055E7
.text$mn:000055E7 _text$mn        ends
.text$mn:000055E7
.text$mn:000055E8 ; ===========================================================================
.text$mn:000055E8
.text$mn:000055E8 ; Segment type: Pure code
.text$mn:000055E8 ; Segment permissions: Read/Execute
.text$mn:000055E8 _text$mn        segment para public 'CODE' use32
.text$mn:000055E8                 assume cs:_text$mn
.text$mn:000055E8                 ;org 55E8h
.text$mn:000055E8 ; COMDAT (pick any)
.text$mn:000055E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055E8
.text$mn:000055E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000055E8
.text$mn:000055E8 ; Attributes: bp-based frame
.text$mn:000055E8
.text$mn:000055E8 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:000055E8                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:000055E8 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:000055E8                                         ; DATA XREF: .rdata:000064E4o
.text$mn:000055E8
.text$mn:000055E8 var_4           = dword ptr -4
.text$mn:000055E8
.text$mn:000055E8                 push    ebp
.text$mn:000055E9                 mov     ebp, esp
.text$mn:000055EB                 push    ecx
.text$mn:000055EC                 mov     [ebp+var_4], ecx
.text$mn:000055EF                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:000055F4                 mov     esp, ebp
.text$mn:000055F6                 pop     ebp
.text$mn:000055F7                 retn
.text$mn:000055F7 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:000055F7
.text$mn:000055F7 _text$mn        ends
.text$mn:000055F7
.text$mn:000055F8 ; ===========================================================================
.text$mn:000055F8
.text$mn:000055F8 ; Segment type: Pure code
.text$mn:000055F8 ; Segment permissions: Read/Execute
.text$mn:000055F8 _text$mn        segment para public 'CODE' use32
.text$mn:000055F8                 assume cs:_text$mn
.text$mn:000055F8                 ;org 55F8h
.text$mn:000055F8 ; COMDAT (pick any)
.text$mn:000055F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055F8
.text$mn:000055F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000055F8
.text$mn:000055F8 ; Attributes: bp-based frame
.text$mn:000055F8
.text$mn:000055F8 ; public: void __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::push_back(struct SwitcherFileInfo &&)
.text$mn:000055F8                 public ?push_back@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAUSwitcherFileInfo@@@Z
.text$mn:000055F8 ?push_back@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAUSwitcherFileInfo@@@Z proc near
.text$mn:000055F8                                         ; CODE XREF: VerticalFileSwitcherListView::getSelectedFiles(bool)+124p
.text$mn:000055F8
.text$mn:000055F8 var_C           = dword ptr -0Ch
.text$mn:000055F8 var_8           = dword ptr -8
.text$mn:000055F8 var_2           = byte ptr -2
.text$mn:000055F8 var_1           = byte ptr -1
.text$mn:000055F8 arg_0           = dword ptr  8
.text$mn:000055F8
.text$mn:000055F8                 push    ebp
.text$mn:000055F9                 mov     ebp, esp
.text$mn:000055FB                 sub     esp, 0Ch
.text$mn:000055FE                 mov     [ebp+var_8], ecx
.text$mn:00005601                 mov     eax, [ebp+arg_0]
.text$mn:00005604                 push    eax
.text$mn:00005605                 call    ??$addressof@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@AAU1@@Z ; std::addressof<SwitcherFileInfo>(SwitcherFileInfo &)
.text$mn:0000560A                 add     esp, 4
.text$mn:0000560D                 push    eax
.text$mn:0000560E                 mov     ecx, [ebp+var_8]
.text$mn:00005611                 call    ?_Inside@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBE_NPBUSwitcherFileInfo@@@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Inside(SwitcherFileInfo const *)
.text$mn:00005616                 movzx   ecx, al
.text$mn:00005619                 test    ecx, ecx
.text$mn:0000561B                 jz      loc_56A8
.text$mn:00005621                 mov     edx, [ebp+arg_0]
.text$mn:00005624                 push    edx
.text$mn:00005625                 call    ??$addressof@USwitcherFileInfo@@@std@@YAPAUSwitcherFileInfo@@AAU1@@Z ; std::addressof<SwitcherFileInfo>(SwitcherFileInfo &)
.text$mn:0000562A                 add     esp, 4
.text$mn:0000562D                 mov     ecx, [ebp+var_8]
.text$mn:00005630                 sub     eax, [ecx+4]
.text$mn:00005633                 sar     eax, 3
.text$mn:00005636                 mov     [ebp+var_C], eax
.text$mn:00005639                 mov     edx, [ebp+var_8]
.text$mn:0000563C                 mov     eax, [ebp+var_8]
.text$mn:0000563F                 mov     ecx, [edx+8]
.text$mn:00005642                 cmp     ecx, [eax+0Ch]
.text$mn:00005645                 jnz     short loc_5651
.text$mn:00005647                 push    1
.text$mn:00005649                 mov     ecx, [ebp+var_8]
.text$mn:0000564C                 call    ?_Reserve@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)
.text$mn:00005651
.text$mn:00005651 loc_5651:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+4Dj
.text$mn:00005651                 mov     edx, [ebp+var_8]
.text$mn:00005654                 mov     eax, [edx+8]
.text$mn:00005657                 push    eax
.text$mn:00005658                 mov     ecx, [ebp+var_8]
.text$mn:0000565B                 mov     edx, [ecx+8]
.text$mn:0000565E                 push    edx
.text$mn:0000565F                 mov     ecx, [ebp+var_8]
.text$mn:00005662                 call    ?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)
.text$mn:00005667                 mov     eax, [ebp+var_8]
.text$mn:0000566A                 mov     ecx, [eax+4]
.text$mn:0000566D                 mov     edx, [ebp+var_C]
.text$mn:00005670                 lea     eax, [ecx+edx*8]
.text$mn:00005673                 push    eax
.text$mn:00005674                 call    ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z ; std::forward<SwitcherFileInfo>(SwitcherFileInfo &)
.text$mn:00005679                 add     esp, 4
.text$mn:0000567C                 push    eax             ; int
.text$mn:0000567D                 mov     ecx, [ebp+var_8]
.text$mn:00005680                 mov     edx, [ecx+8]
.text$mn:00005683                 push    edx             ; void *
.text$mn:00005684                 lea     eax, [ebp+var_1]
.text$mn:00005687                 push    eax
.text$mn:00005688                 mov     ecx, [ebp+var_8]
.text$mn:0000568B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:00005690                 mov     ecx, eax
.text$mn:00005692                 call    ??$construct@USwitcherFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)
.text$mn:00005697                 mov     ecx, [ebp+var_8]
.text$mn:0000569A                 mov     edx, [ecx+8]
.text$mn:0000569D                 add     edx, 8
.text$mn:000056A0                 mov     eax, [ebp+var_8]
.text$mn:000056A3                 mov     [eax+8], edx
.text$mn:000056A6                 jmp     short loc_570C
.text$mn:000056A8 ; ---------------------------------------------------------------------------
.text$mn:000056A8
.text$mn:000056A8 loc_56A8:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+23j
.text$mn:000056A8                 mov     ecx, [ebp+var_8]
.text$mn:000056AB                 mov     edx, [ebp+var_8]
.text$mn:000056AE                 mov     eax, [ecx+8]
.text$mn:000056B1                 cmp     eax, [edx+0Ch]
.text$mn:000056B4                 jnz     short loc_56C0
.text$mn:000056B6                 push    1
.text$mn:000056B8                 mov     ecx, [ebp+var_8]
.text$mn:000056BB                 call    ?_Reserve@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)
.text$mn:000056C0
.text$mn:000056C0 loc_56C0:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+BCj
.text$mn:000056C0                 mov     ecx, [ebp+var_8]
.text$mn:000056C3                 mov     edx, [ecx+8]
.text$mn:000056C6                 push    edx
.text$mn:000056C7                 mov     eax, [ebp+var_8]
.text$mn:000056CA                 mov     ecx, [eax+8]
.text$mn:000056CD                 push    ecx
.text$mn:000056CE                 mov     ecx, [ebp+var_8]
.text$mn:000056D1                 call    ?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)
.text$mn:000056D6                 mov     edx, [ebp+arg_0]
.text$mn:000056D9                 push    edx
.text$mn:000056DA                 call    ??$forward@USwitcherFileInfo@@@std@@YA$$QAUSwitcherFileInfo@@AAU1@@Z ; std::forward<SwitcherFileInfo>(SwitcherFileInfo &)
.text$mn:000056DF                 add     esp, 4
.text$mn:000056E2                 push    eax             ; int
.text$mn:000056E3                 mov     eax, [ebp+var_8]
.text$mn:000056E6                 mov     ecx, [eax+8]
.text$mn:000056E9                 push    ecx             ; void *
.text$mn:000056EA                 lea     edx, [ebp+var_2]
.text$mn:000056ED                 push    edx
.text$mn:000056EE                 mov     ecx, [ebp+var_8]
.text$mn:000056F1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>>::_Getal(void)
.text$mn:000056F6                 mov     ecx, eax
.text$mn:000056F8                 call    ??$construct@USwitcherFileInfo@@U1@@?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<SwitcherFileInfo>>::construct<SwitcherFileInfo,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo &&)
.text$mn:000056FD                 mov     eax, [ebp+var_8]
.text$mn:00005700                 mov     ecx, [eax+8]
.text$mn:00005703                 add     ecx, 8
.text$mn:00005706                 mov     edx, [ebp+var_8]
.text$mn:00005709                 mov     [edx+8], ecx
.text$mn:0000570C
.text$mn:0000570C loc_570C:                               ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::push_back(SwitcherFileInfo &&)+AEj
.text$mn:0000570C                 mov     esp, ebp
.text$mn:0000570E                 pop     ebp
.text$mn:0000570F                 retn    4
.text$mn:0000570F ?push_back@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAEX$$QAUSwitcherFileInfo@@@Z endp
.text$mn:0000570F
.text$mn:0000570F ; ---------------------------------------------------------------------------
.text$mn:00005712                 align 4
.text$mn:00005712 _text$mn        ends
.text$mn:00005712
.text$mn:00005714 ; ===========================================================================
.text$mn:00005714
.text$mn:00005714 ; Segment type: Pure code
.text$mn:00005714 ; Segment permissions: Read/Execute
.text$mn:00005714 _text$mn        segment para public 'CODE' use32
.text$mn:00005714                 assume cs:_text$mn
.text$mn:00005714                 ;org 5714h
.text$mn:00005714 ; COMDAT (pick any)
.text$mn:00005714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005714
.text$mn:00005714 ; =============== S U B R O U T I N E =======================================
.text$mn:00005714
.text$mn:00005714 ; Attributes: bp-based frame
.text$mn:00005714
.text$mn:00005714 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:00005714                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:00005714 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00005714                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:00005714
.text$mn:00005714 var_8           = dword ptr -8
.text$mn:00005714 var_1           = byte ptr -1
.text$mn:00005714 arg_0           = dword ptr  8
.text$mn:00005714
.text$mn:00005714                 push    ebp
.text$mn:00005715                 mov     ebp, esp
.text$mn:00005717                 sub     esp, 8
.text$mn:0000571A                 mov     [ebp+var_8], ecx
.text$mn:0000571D                 mov     eax, [ebp+var_8]
.text$mn:00005720                 push    eax
.text$mn:00005721                 lea     ecx, [ebp+var_1]
.text$mn:00005724                 push    ecx
.text$mn:00005725                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:0000572A                 add     esp, 8
.text$mn:0000572D                 push    eax
.text$mn:0000572E                 mov     ecx, [ebp+arg_0]
.text$mn:00005731                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:00005736                 mov     eax, [ebp+arg_0]
.text$mn:00005739                 mov     esp, ebp
.text$mn:0000573B                 pop     ebp
.text$mn:0000573C                 retn    4
.text$mn:0000573C ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000573C
.text$mn:0000573C ; ---------------------------------------------------------------------------
.text$mn:0000573F                 align 10h
.text$mn:0000573F _text$mn        ends
.text$mn:0000573F
.text$mn:00005740 ; ===========================================================================
.text$mn:00005740
.text$mn:00005740 ; Segment type: Pure code
.text$mn:00005740 ; Segment permissions: Read/Execute
.text$mn:00005740 _text$mn        segment para public 'CODE' use32
.text$mn:00005740                 assume cs:_text$mn
.text$mn:00005740                 ;org 5740h
.text$mn:00005740 ; COMDAT (pick any)
.text$mn:00005740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005740
.text$mn:00005740 ; =============== S U B R O U T I N E =======================================
.text$mn:00005740
.text$mn:00005740 ; Attributes: bp-based frame
.text$mn:00005740
.text$mn:00005740 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:00005740                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:00005740 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:00005740                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:00005740
.text$mn:00005740 var_4           = dword ptr -4
.text$mn:00005740 arg_0           = dword ptr  8
.text$mn:00005740
.text$mn:00005740                 push    ebp
.text$mn:00005741                 mov     ebp, esp
.text$mn:00005743                 push    ecx
.text$mn:00005744                 mov     [ebp+var_4], ecx
.text$mn:00005747                 mov     eax, [ebp+var_4]
.text$mn:0000574A                 push    eax
.text$mn:0000574B                 mov     ecx, [ebp+arg_0]
.text$mn:0000574E                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00005753                 mov     eax, [ebp+arg_0]
.text$mn:00005756                 mov     esp, ebp
.text$mn:00005758                 pop     ebp
.text$mn:00005759                 retn    4
.text$mn:00005759 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:00005759
.text$mn:00005759 _text$mn        ends
.text$mn:00005759
.text$mn:0000575C ; ===========================================================================
.text$mn:0000575C
.text$mn:0000575C ; Segment type: Pure code
.text$mn:0000575C ; Segment permissions: Read/Execute
.text$mn:0000575C _text$mn        segment para public 'CODE' use32
.text$mn:0000575C                 assume cs:_text$mn
.text$mn:0000575C                 ;org 575Ch
.text$mn:0000575C ; COMDAT (pick any)
.text$mn:0000575C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000575C
.text$mn:0000575C ; =============== S U B R O U T I N E =======================================
.text$mn:0000575C
.text$mn:0000575C ; Attributes: bp-based frame
.text$mn:0000575C
.text$mn:0000575C ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:0000575C                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:0000575C ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:0000575C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:0000575C
.text$mn:0000575C arg_0           = dword ptr  8
.text$mn:0000575C arg_4           = dword ptr  0Ch
.text$mn:0000575C
.text$mn:0000575C                 push    ebp
.text$mn:0000575D                 mov     ebp, esp
.text$mn:0000575F                 mov     eax, [ebp+arg_0]
.text$mn:00005762                 push    eax
.text$mn:00005763                 mov     ecx, [ebp+arg_4]
.text$mn:00005766                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:0000576B                 mov     eax, [ebp+arg_0]
.text$mn:0000576E                 pop     ebp
.text$mn:0000576F                 retn
.text$mn:0000576F ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:0000576F
.text$mn:0000576F _text$mn        ends
.text$mn:0000576F
.text$mn:00005770 ; ===========================================================================
.text$mn:00005770
.text$mn:00005770 ; Segment type: Pure code
.text$mn:00005770 ; Segment permissions: Read/Execute
.text$mn:00005770 _text$mn        segment para public 'CODE' use32
.text$mn:00005770                 assume cs:_text$mn
.text$mn:00005770                 ;org 5770h
.text$mn:00005770 ; COMDAT (pick any)
.text$mn:00005770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005770
.text$mn:00005770 ; =============== S U B R O U T I N E =======================================
.text$mn:00005770
.text$mn:00005770 ; Attributes: bp-based frame
.text$mn:00005770
.text$mn:00005770 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00005770                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00005770 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00005770                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00005770                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00005770
.text$mn:00005770 var_4           = dword ptr -4
.text$mn:00005770
.text$mn:00005770                 push    ebp
.text$mn:00005771                 mov     ebp, esp
.text$mn:00005773                 push    ecx
.text$mn:00005774                 mov     [ebp+var_4], ecx
.text$mn:00005777                 mov     eax, [ebp+var_4]
.text$mn:0000577A                 mov     eax, [eax+14h]
.text$mn:0000577D                 mov     esp, ebp
.text$mn:0000577F                 pop     ebp
.text$mn:00005780                 retn
.text$mn:00005780 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00005780
.text$mn:00005780 ; ---------------------------------------------------------------------------
.text$mn:00005781                 align 4
.text$mn:00005781 _text$mn        ends
.text$mn:00005781
.text$mn:00005784 ; ===========================================================================
.text$mn:00005784
.text$mn:00005784 ; Segment type: Pure code
.text$mn:00005784 ; Segment permissions: Read/Execute
.text$mn:00005784 _text$mn        segment para public 'CODE' use32
.text$mn:00005784                 assume cs:_text$mn
.text$mn:00005784                 ;org 5784h
.text$mn:00005784 ; COMDAT (pick any)
.text$mn:00005784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005784
.text$mn:00005784 ; =============== S U B R O U T I N E =======================================
.text$mn:00005784
.text$mn:00005784 ; Attributes: bp-based frame
.text$mn:00005784
.text$mn:00005784 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00005784                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00005784 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00005784                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00005784                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:00005784
.text$mn:00005784 var_4           = dword ptr -4
.text$mn:00005784
.text$mn:00005784                 push    ebp
.text$mn:00005785                 mov     ebp, esp
.text$mn:00005787                 push    ecx
.text$mn:00005788                 mov     [ebp+var_4], ecx
.text$mn:0000578B                 mov     eax, [ebp+var_4]
.text$mn:0000578E                 mov     eax, [eax+14h]
.text$mn:00005791                 mov     esp, ebp
.text$mn:00005793                 pop     ebp
.text$mn:00005794                 retn
.text$mn:00005794 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00005794
.text$mn:00005794 ; ---------------------------------------------------------------------------
.text$mn:00005795                 align 4
.text$mn:00005795 _text$mn        ends
.text$mn:00005795
.text$mn:00005798 ; ===========================================================================
.text$mn:00005798
.text$mn:00005798 ; Segment type: Pure code
.text$mn:00005798 ; Segment permissions: Read/Execute
.text$mn:00005798 _text$mn        segment para public 'CODE' use32
.text$mn:00005798                 assume cs:_text$mn
.text$mn:00005798                 ;org 5798h
.text$mn:00005798 ; COMDAT (pick any)
.text$mn:00005798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005798
.text$mn:00005798 ; =============== S U B R O U T I N E =======================================
.text$mn:00005798
.text$mn:00005798 ; Attributes: bp-based frame
.text$mn:00005798
.text$mn:00005798 ; public: unsigned int __thiscall std::vector<struct SwitcherFileInfo, class std::allocator<struct SwitcherFileInfo>>::size(void)const
.text$mn:00005798                 public ?size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ
.text$mn:00005798 ?size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00005798                                         ; CODE XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reallocate(uint)+A9p
.text$mn:00005798                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Reserve(uint)+22p ...
.text$mn:00005798
.text$mn:00005798 var_4           = dword ptr -4
.text$mn:00005798
.text$mn:00005798                 push    ebp
.text$mn:00005799                 mov     ebp, esp
.text$mn:0000579B                 push    ecx
.text$mn:0000579C                 mov     [ebp+var_4], ecx
.text$mn:0000579F                 mov     eax, [ebp+var_4]
.text$mn:000057A2                 mov     ecx, [ebp+var_4]
.text$mn:000057A5                 mov     eax, [eax+8]
.text$mn:000057A8                 sub     eax, [ecx+4]
.text$mn:000057AB                 sar     eax, 3
.text$mn:000057AE                 mov     esp, ebp
.text$mn:000057B0                 pop     ebp
.text$mn:000057B1                 retn
.text$mn:000057B1 ?size@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QBEIXZ endp
.text$mn:000057B1
.text$mn:000057B1 ; ---------------------------------------------------------------------------
.text$mn:000057B2                 align 4
.text$mn:000057B2 _text$mn        ends
.text$mn:000057B2
.text$mn:000057B4 ; ===========================================================================
.text$mn:000057B4
.text$mn:000057B4 ; Segment type: Pure code
.text$mn:000057B4 ; Segment permissions: Read/Execute
.text$mn:000057B4 _text$mn        segment para public 'CODE' use32
.text$mn:000057B4                 assume cs:_text$mn
.text$mn:000057B4                 ;org 57B4h
.text$mn:000057B4 ; COMDAT (pick any)
.text$mn:000057B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057B4
.text$mn:000057B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000057B4
.text$mn:000057B4 ; Attributes: bp-based frame
.text$mn:000057B4
.text$mn:000057B4 ; public: unsigned int __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::size(void)const
.text$mn:000057B4                 public ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ
.text$mn:000057B4 ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ proc near
.text$mn:000057B4                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+1E8p
.text$mn:000057B4                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+Ap
.text$mn:000057B4
.text$mn:000057B4 var_4           = dword ptr -4
.text$mn:000057B4
.text$mn:000057B4                 push    ebp
.text$mn:000057B5                 mov     ebp, esp
.text$mn:000057B7                 push    ecx
.text$mn:000057B8                 mov     [ebp+var_4], ecx
.text$mn:000057BB                 mov     eax, [ebp+var_4]
.text$mn:000057BE                 mov     ecx, [ebp+var_4]
.text$mn:000057C1                 mov     eax, [eax+8]
.text$mn:000057C4                 sub     eax, [ecx+4]
.text$mn:000057C7                 cdq
.text$mn:000057C8                 mov     ecx, 2Ch ; ','
.text$mn:000057CD                 idiv    ecx
.text$mn:000057CF                 mov     esp, ebp
.text$mn:000057D1                 pop     ebp
.text$mn:000057D2                 retn
.text$mn:000057D2 ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ endp
.text$mn:000057D2
.text$mn:000057D2 ; ---------------------------------------------------------------------------
.text$mn:000057D3                 align 4
.text$mn:000057D3 _text$mn        ends
.text$mn:000057D3
.text$mn:000057D4 ; ===========================================================================
.text$mn:000057D4
.text$mn:000057D4 ; Segment type: Pure code
.text$mn:000057D4 ; Segment permissions: Read/Execute
.text$mn:000057D4 _text$mn        segment para public 'CODE' use32
.text$mn:000057D4                 assume cs:_text$mn
.text$mn:000057D4                 ;org 57D4h
.text$mn:000057D4 ; COMDAT (pick any)
.text$mn:000057D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057D4
.text$mn:000057D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000057D4
.text$mn:000057D4 ; Attributes: bp-based frame
.text$mn:000057D4
.text$mn:000057D4 ; __int32 __stdcall VerticalFileSwitcherListView::staticProc(HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:000057D4                 public ?staticProc@VerticalFileSwitcherListView@@KGJPAUHWND__@@IIJ@Z
.text$mn:000057D4 ?staticProc@VerticalFileSwitcherListView@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:000057D4                                         ; DATA XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+B1o
.text$mn:000057D4
.text$mn:000057D4 hWnd            = dword ptr  8
.text$mn:000057D4 Msg             = dword ptr  0Ch
.text$mn:000057D4 wParam          = dword ptr  10h
.text$mn:000057D4 arg_C           = dword ptr  14h
.text$mn:000057D4
.text$mn:000057D4                 push    ebp
.text$mn:000057D5                 mov     ebp, esp
.text$mn:000057D7                 mov     eax, [ebp+arg_C]
.text$mn:000057DA                 push    eax             ; __int32
.text$mn:000057DB                 mov     ecx, [ebp+wParam]
.text$mn:000057DE                 push    ecx             ; wParam
.text$mn:000057DF                 mov     edx, [ebp+Msg]
.text$mn:000057E2                 push    edx             ; Msg
.text$mn:000057E3                 mov     eax, [ebp+hWnd]
.text$mn:000057E6                 push    eax             ; hWnd
.text$mn:000057E7                 push    0FFFFFFEBh      ; nIndex
.text$mn:000057E9                 mov     ecx, [ebp+hWnd]
.text$mn:000057EC                 push    ecx             ; hWnd
.text$mn:000057ED                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:000057F3                 mov     ecx, eax        ; this
.text$mn:000057F5                 call    ?runProc@VerticalFileSwitcherListView@@IAEJPAUHWND__@@IIJ@Z ; VerticalFileSwitcherListView::runProc(HWND__ *,uint,uint,long)
.text$mn:000057FA                 pop     ebp
.text$mn:000057FB                 retn    10h
.text$mn:000057FB ?staticProc@VerticalFileSwitcherListView@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:000057FB
.text$mn:000057FB ; ---------------------------------------------------------------------------
.text$mn:000057FE                 align 10h
.text$mn:000057FE _text$mn        ends
.text$mn:000057FE
.text$mn:00005800 ; ===========================================================================
.text$mn:00005800
.text$mn:00005800 ; Segment type: Pure code
.text$mn:00005800 ; Segment permissions: Read/Execute
.text$mn:00005800 _text$mn        segment para public 'CODE' use32
.text$mn:00005800                 assume cs:_text$mn
.text$mn:00005800                 ;org 5800h
.text$mn:00005800 ; COMDAT (pick any)
.text$mn:00005800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005800
.text$mn:00005800 ; =============== S U B R O U T I N E =======================================
.text$mn:00005800
.text$mn:00005800 ; Attributes: bp-based frame
.text$mn:00005800
.text$mn:00005800 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00005800                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00005800 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00005800                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_4EB0p
.text$mn:00005800                 push    ebp
.text$mn:00005801                 mov     ebp, esp
.text$mn:00005803                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00005808                 pop     ebp
.text$mn:00005809                 retn
.text$mn:00005809 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00005809
.text$mn:00005809 ; ---------------------------------------------------------------------------
.text$mn:0000580A                 align 4
.text$mn:0000580A _text$mn        ends
.text$mn:0000580A
.text$mn:0000580C ; ===========================================================================
.text$mn:0000580C
.text$mn:0000580C ; Segment type: Pure code
.text$mn:0000580C ; Segment permissions: Read/Execute
.text$mn:0000580C _text$mn        segment para public 'CODE' use32
.text$mn:0000580C                 assume cs:_text$mn
.text$mn:0000580C                 ;org 580Ch
.text$mn:0000580C ; COMDAT (pick any)
.text$mn:0000580C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000580C
.text$mn:0000580C ; =============== S U B R O U T I N E =======================================
.text$mn:0000580C
.text$mn:0000580C ; Attributes: bp-based frame
.text$mn:0000580C
.text$mn:0000580C ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000580C                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000580C ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000580C
.text$mn:0000580C var_4           = dword ptr -4
.text$mn:0000580C
.text$mn:0000580C                 push    ebp
.text$mn:0000580D                 mov     ebp, esp
.text$mn:0000580F                 push    ecx
.text$mn:00005810                 mov     [ebp+var_4], ecx
.text$mn:00005813                 mov     eax, [ebp+var_4]
.text$mn:00005816                 mov     eax, [eax]
.text$mn:00005818                 mov     esp, ebp
.text$mn:0000581A                 pop     ebp
.text$mn:0000581B                 retn
.text$mn:0000581B ?value@error_code@std@@QBEHXZ endp
.text$mn:0000581B
.text$mn:0000581B _text$mn        ends
.text$mn:0000581B
.text$mn:0000581C ; ===========================================================================
.text$mn:0000581C
.text$mn:0000581C ; Segment type: Pure code
.text$mn:0000581C ; Segment permissions: Read/Execute
.text$mn:0000581C _text$mn        segment para public 'CODE' use32
.text$mn:0000581C                 assume cs:_text$mn
.text$mn:0000581C                 ;org 581Ch
.text$mn:0000581C ; COMDAT (pick any)
.text$mn:0000581C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000581C
.text$mn:0000581C ; =============== S U B R O U T I N E =======================================
.text$mn:0000581C
.text$mn:0000581C ; Attributes: bp-based frame
.text$mn:0000581C
.text$mn:0000581C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000581C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000581C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000581C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000581C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000581C
.text$mn:0000581C var_4           = dword ptr -4
.text$mn:0000581C
.text$mn:0000581C                 push    ebp
.text$mn:0000581D                 mov     ebp, esp
.text$mn:0000581F                 push    ecx
.text$mn:00005820                 mov     [ebp+var_4], ecx
.text$mn:00005823                 mov     eax, [ebp+var_4]
.text$mn:00005826                 mov     eax, [eax]
.text$mn:00005828                 mov     esp, ebp
.text$mn:0000582A                 pop     ebp
.text$mn:0000582B                 retn
.text$mn:0000582B ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000582B
.text$mn:0000582B _text$mn        ends
.text$mn:0000582B
.text$mn:0000582C ; ===========================================================================
.text$mn:0000582C
.text$mn:0000582C ; Segment type: Pure code
.text$mn:0000582C ; Segment permissions: Read/Execute
.text$mn:0000582C _text$mn        segment para public 'CODE' use32
.text$mn:0000582C                 assume cs:_text$mn
.text$mn:0000582C                 ;org 582Ch
.text$mn:0000582C ; COMDAT (pick any)
.text$mn:0000582C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000582C
.text$mn:0000582C ; =============== S U B R O U T I N E =======================================
.text$mn:0000582C
.text$mn:0000582C ; Attributes: bp-based frame
.text$mn:0000582C
.text$mn:0000582C                 public _hypot
.text$mn:0000582C _hypot          proc near
.text$mn:0000582C
.text$mn:0000582C var_10          = qword ptr -10h
.text$mn:0000582C var_8           = qword ptr -8
.text$mn:0000582C arg_0           = qword ptr  8
.text$mn:0000582C arg_8           = qword ptr  10h
.text$mn:0000582C
.text$mn:0000582C                 push    ebp
.text$mn:0000582D                 mov     ebp, esp
.text$mn:0000582F                 sub     esp, 8
.text$mn:00005832                 movsd   xmm0, [ebp+arg_8]
.text$mn:00005837                 movsd   [esp+8+var_8], xmm0
.text$mn:0000583C                 sub     esp, 8
.text$mn:0000583F                 movsd   xmm0, [ebp+arg_0]
.text$mn:00005844                 movsd   [esp+10h+var_10], xmm0
.text$mn:00005849                 call    __hypot
.text$mn:0000584E                 add     esp, 10h
.text$mn:00005851                 pop     ebp
.text$mn:00005852                 retn
.text$mn:00005852 _hypot          endp
.text$mn:00005852
.text$mn:00005852 ; ---------------------------------------------------------------------------
.text$mn:00005853                 align 4
.text$mn:00005853 _text$mn        ends
.text$mn:00005853
.text$mn:00005854 ; ===========================================================================
.text$mn:00005854
.text$mn:00005854 ; Segment type: Pure code
.text$mn:00005854 ; Segment permissions: Read/Execute
.text$mn:00005854 _text$mn        segment para public 'CODE' use32
.text$mn:00005854                 assume cs:_text$mn
.text$mn:00005854                 ;org 5854h
.text$mn:00005854 ; COMDAT (pick any)
.text$mn:00005854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005854
.text$mn:00005854 ; =============== S U B R O U T I N E =======================================
.text$mn:00005854
.text$mn:00005854 ; Attributes: bp-based frame
.text$mn:00005854
.text$mn:00005854 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00005854                 public _wmemcpy
.text$mn:00005854 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00005854
.text$mn:00005854 Dst             = dword ptr  8
.text$mn:00005854 Src             = dword ptr  0Ch
.text$mn:00005854 arg_8           = dword ptr  10h
.text$mn:00005854
.text$mn:00005854                 push    ebp
.text$mn:00005855                 mov     ebp, esp
.text$mn:00005857                 mov     eax, [ebp+arg_8]
.text$mn:0000585A                 shl     eax, 1
.text$mn:0000585C                 push    eax             ; Size
.text$mn:0000585D                 mov     ecx, [ebp+Src]
.text$mn:00005860                 push    ecx             ; Src
.text$mn:00005861                 mov     edx, [ebp+Dst]
.text$mn:00005864                 push    edx             ; Dst
.text$mn:00005865                 call    _memcpy
.text$mn:0000586A                 add     esp, 0Ch
.text$mn:0000586D                 pop     ebp
.text$mn:0000586E                 retn
.text$mn:0000586E _wmemcpy        endp
.text$mn:0000586E
.text$mn:0000586E ; ---------------------------------------------------------------------------
.text$mn:0000586F                 align 10h
.text$mn:0000586F _text$mn        ends
.text$mn:0000586F
.text$mn:00005870 ; ===========================================================================
.text$mn:00005870
.text$mn:00005870 ; Segment type: Pure code
.text$mn:00005870 ; Segment permissions: Read/Execute
.text$mn:00005870 _text$mn        segment para public 'CODE' use32
.text$mn:00005870                 assume cs:_text$mn
.text$mn:00005870                 ;org 5870h
.text$mn:00005870 ; COMDAT (pick any)
.text$mn:00005870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005870
.text$mn:00005870 ; =============== S U B R O U T I N E =======================================
.text$mn:00005870
.text$mn:00005870 ; Attributes: bp-based frame
.text$mn:00005870
.text$mn:00005870 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00005870                 public _wmemmove
.text$mn:00005870 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00005870
.text$mn:00005870 Dst             = dword ptr  8
.text$mn:00005870 Src             = dword ptr  0Ch
.text$mn:00005870 arg_8           = dword ptr  10h
.text$mn:00005870
.text$mn:00005870                 push    ebp
.text$mn:00005871                 mov     ebp, esp
.text$mn:00005873                 mov     eax, [ebp+arg_8]
.text$mn:00005876                 shl     eax, 1
.text$mn:00005878                 push    eax             ; Size
.text$mn:00005879                 mov     ecx, [ebp+Src]
.text$mn:0000587C                 push    ecx             ; Src
.text$mn:0000587D                 mov     edx, [ebp+Dst]
.text$mn:00005880                 push    edx             ; Dst
.text$mn:00005881                 call    _memmove
.text$mn:00005886                 add     esp, 0Ch
.text$mn:00005889                 pop     ebp
.text$mn:0000588A                 retn
.text$mn:0000588A _wmemmove       endp
.text$mn:0000588A
.text$mn:0000588A ; ---------------------------------------------------------------------------
.text$mn:0000588B                 align 4
.text$mn:0000588B _text$mn        ends
.text$mn:0000588B
.xdata$x:0000588C ; ===========================================================================
.xdata$x:0000588C
.xdata$x:0000588C ; Segment type: Pure data
.xdata$x:0000588C ; Segment permissions: Read
.xdata$x:0000588C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000588C                 assume cs:_xdata$x
.xdata$x:0000588C                 ;org 588Ch
.xdata$x:0000588C ; COMDAT (pick associative to section at 41A0)
.xdata$x:0000588C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000588C                                         ; DATA XREF: .xdata$x:0000589Co
.xdata$x:0000588D                 db 0FFh
.xdata$x:0000588E                 db 0FFh
.xdata$x:0000588F                 db 0FFh
.xdata$x:00005890                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00005894 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00005894                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00005895                 db    5
.xdata$x:00005896                 db  93h ; 
.xdata$x:00005897                 db  19h
.xdata$x:00005898                 db    1
.xdata$x:00005899                 db    0
.xdata$x:0000589A                 db    0
.xdata$x:0000589B                 db    0
.xdata$x:0000589C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:000058A0                 db    0
.xdata$x:000058A1                 db    0
.xdata$x:000058A2                 db    0
.xdata$x:000058A3                 db    0
.xdata$x:000058A4                 db    0
.xdata$x:000058A5                 db    0
.xdata$x:000058A6                 db    0
.xdata$x:000058A7                 db    0
.xdata$x:000058A8                 db    0
.xdata$x:000058A9                 db    0
.xdata$x:000058AA                 db    0
.xdata$x:000058AB                 db    0
.xdata$x:000058AC                 db    0
.xdata$x:000058AD                 db    0
.xdata$x:000058AE                 db    0
.xdata$x:000058AF                 db    0
.xdata$x:000058B0                 db    0
.xdata$x:000058B1                 db    0
.xdata$x:000058B2                 db    0
.xdata$x:000058B3                 db    0
.xdata$x:000058B4                 db    0
.xdata$x:000058B5                 db    0
.xdata$x:000058B6                 db    0
.xdata$x:000058B7                 db    0
.xdata$x:000058B7 _xdata$x        ends
.xdata$x:000058B7
.xdata$x:000058B8 ; ===========================================================================
.xdata$x:000058B8
.xdata$x:000058B8 ; Segment type: Pure data
.xdata$x:000058B8 ; Segment permissions: Read
.xdata$x:000058B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000058B8                 assume cs:_xdata$x
.xdata$x:000058B8                 ;org 58B8h
.xdata$x:000058B8 ; COMDAT (pick associative to section at 44F4)
.xdata$x:000058B8 __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db 0FFh
.xdata$x:000058B8                                         ; DATA XREF: .xdata$x:000058C8o
.xdata$x:000058B9                 db 0FFh
.xdata$x:000058BA                 db 0FFh
.xdata$x:000058BB                 db 0FFh
.xdata$x:000058BC                 dd offset __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0
.xdata$x:000058C0 __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db  22h ; "
.xdata$x:000058C0                                         ; DATA XREF: __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z+11o
.xdata$x:000058C1                 db    5
.xdata$x:000058C2                 db  93h ; 
.xdata$x:000058C3                 db  19h
.xdata$x:000058C4                 db    1
.xdata$x:000058C5                 db    0
.xdata$x:000058C6                 db    0
.xdata$x:000058C7                 db    0
.xdata$x:000058C8                 dd offset __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.xdata$x:000058CC                 db    0
.xdata$x:000058CD                 db    0
.xdata$x:000058CE                 db    0
.xdata$x:000058CF                 db    0
.xdata$x:000058D0                 db    0
.xdata$x:000058D1                 db    0
.xdata$x:000058D2                 db    0
.xdata$x:000058D3                 db    0
.xdata$x:000058D4                 db    0
.xdata$x:000058D5                 db    0
.xdata$x:000058D6                 db    0
.xdata$x:000058D7                 db    0
.xdata$x:000058D8                 db    0
.xdata$x:000058D9                 db    0
.xdata$x:000058DA                 db    0
.xdata$x:000058DB                 db    0
.xdata$x:000058DC                 db    0
.xdata$x:000058DD                 db    0
.xdata$x:000058DE                 db    0
.xdata$x:000058DF                 db    0
.xdata$x:000058E0                 db    0
.xdata$x:000058E1                 db    0
.xdata$x:000058E2                 db    0
.xdata$x:000058E3                 db    0
.xdata$x:000058E3 _xdata$x        ends
.xdata$x:000058E3
.xdata$x:000058E4 ; ===========================================================================
.xdata$x:000058E4
.xdata$x:000058E4 ; Segment type: Pure data
.xdata$x:000058E4 ; Segment permissions: Read
.xdata$x:000058E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000058E4                 assume cs:_xdata$x
.xdata$x:000058E4                 ;org 58E4h
.xdata$x:000058E4 ; COMDAT (pick associative to section at 1F5C)
.xdata$x:000058E4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000058E4                                         ; DATA XREF: .xdata$x:000058F4o
.xdata$x:000058E5                 db 0FFh
.xdata$x:000058E6                 db 0FFh
.xdata$x:000058E7                 db 0FFh
.xdata$x:000058E8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000058EC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000058EC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000058ED                 db    5
.xdata$x:000058EE                 db  93h ; 
.xdata$x:000058EF                 db  19h
.xdata$x:000058F0                 db    1
.xdata$x:000058F1                 db    0
.xdata$x:000058F2                 db    0
.xdata$x:000058F3                 db    0
.xdata$x:000058F4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000058F8                 db    0
.xdata$x:000058F9                 db    0
.xdata$x:000058FA                 db    0
.xdata$x:000058FB                 db    0
.xdata$x:000058FC                 db    0
.xdata$x:000058FD                 db    0
.xdata$x:000058FE                 db    0
.xdata$x:000058FF                 db    0
.xdata$x:00005900                 db    0
.xdata$x:00005901                 db    0
.xdata$x:00005902                 db    0
.xdata$x:00005903                 db    0
.xdata$x:00005904                 db    0
.xdata$x:00005905                 db    0
.xdata$x:00005906                 db    0
.xdata$x:00005907                 db    0
.xdata$x:00005908                 db    0
.xdata$x:00005909                 db    0
.xdata$x:0000590A                 db    0
.xdata$x:0000590B                 db    0
.xdata$x:0000590C                 db    0
.xdata$x:0000590D                 db    0
.xdata$x:0000590E                 db    0
.xdata$x:0000590F                 db    0
.xdata$x:0000590F _xdata$x        ends
.xdata$x:0000590F
.xdata$x:00005910 ; ===========================================================================
.xdata$x:00005910
.xdata$x:00005910 ; Segment type: Pure data
.xdata$x:00005910 ; Segment permissions: Read
.xdata$x:00005910 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005910                 assume cs:_xdata$x
.xdata$x:00005910                 ;org 5910h
.xdata$x:00005910 ; COMDAT (pick associative to section at 2C48)
.xdata$x:00005910 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005910                                         ; DATA XREF: .xdata$x:00005920o
.xdata$x:00005911                 db 0FFh
.xdata$x:00005912                 db 0FFh
.xdata$x:00005913                 db 0FFh
.xdata$x:00005914                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00005918 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005918                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00005919                 db    5
.xdata$x:0000591A                 db  93h ; 
.xdata$x:0000591B                 db  19h
.xdata$x:0000591C                 db    1
.xdata$x:0000591D                 db    0
.xdata$x:0000591E                 db    0
.xdata$x:0000591F                 db    0
.xdata$x:00005920                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00005924                 db    0
.xdata$x:00005925                 db    0
.xdata$x:00005926                 db    0
.xdata$x:00005927                 db    0
.xdata$x:00005928                 db    0
.xdata$x:00005929                 db    0
.xdata$x:0000592A                 db    0
.xdata$x:0000592B                 db    0
.xdata$x:0000592C                 db    0
.xdata$x:0000592D                 db    0
.xdata$x:0000592E                 db    0
.xdata$x:0000592F                 db    0
.xdata$x:00005930                 db    0
.xdata$x:00005931                 db    0
.xdata$x:00005932                 db    0
.xdata$x:00005933                 db    0
.xdata$x:00005934                 db    0
.xdata$x:00005935                 db    0
.xdata$x:00005936                 db    0
.xdata$x:00005937                 db    0
.xdata$x:00005938                 db    0
.xdata$x:00005939                 db    0
.xdata$x:0000593A                 db    0
.xdata$x:0000593B                 db    0
.xdata$x:0000593B _xdata$x        ends
.xdata$x:0000593B
.xdata$x:0000593C ; ===========================================================================
.xdata$x:0000593C
.xdata$x:0000593C ; Segment type: Pure data
.xdata$x:0000593C ; Segment permissions: Read
.xdata$x:0000593C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000593C                 assume cs:_xdata$x
.xdata$x:0000593C                 ;org 593Ch
.xdata$x:0000593C ; COMDAT (pick associative to section at 1E64)
.xdata$x:0000593C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000593C                                         ; DATA XREF: .xdata$x:0000594Co
.xdata$x:0000593D                 db 0FFh
.xdata$x:0000593E                 db 0FFh
.xdata$x:0000593F                 db 0FFh
.xdata$x:00005940                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00005944 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00005944                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00005945                 db    5
.xdata$x:00005946                 db  93h ; 
.xdata$x:00005947                 db  19h
.xdata$x:00005948                 db    1
.xdata$x:00005949                 db    0
.xdata$x:0000594A                 db    0
.xdata$x:0000594B                 db    0
.xdata$x:0000594C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00005950                 db    0
.xdata$x:00005951                 db    0
.xdata$x:00005952                 db    0
.xdata$x:00005953                 db    0
.xdata$x:00005954                 db    0
.xdata$x:00005955                 db    0
.xdata$x:00005956                 db    0
.xdata$x:00005957                 db    0
.xdata$x:00005958                 db    0
.xdata$x:00005959                 db    0
.xdata$x:0000595A                 db    0
.xdata$x:0000595B                 db    0
.xdata$x:0000595C                 db    0
.xdata$x:0000595D                 db    0
.xdata$x:0000595E                 db    0
.xdata$x:0000595F                 db    0
.xdata$x:00005960                 db    0
.xdata$x:00005961                 db    0
.xdata$x:00005962                 db    0
.xdata$x:00005963                 db    0
.xdata$x:00005964                 db    0
.xdata$x:00005965                 db    0
.xdata$x:00005966                 db    0
.xdata$x:00005967                 db    0
.xdata$x:00005967 _xdata$x        ends
.xdata$x:00005967
.xdata$x:00005968 ; ===========================================================================
.xdata$x:00005968
.xdata$x:00005968 ; Segment type: Pure data
.xdata$x:00005968 ; Segment permissions: Read
.xdata$x:00005968 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005968                 assume cs:_xdata$x
.xdata$x:00005968                 ;org 5968h
.xdata$x:00005968 ; COMDAT (pick associative to section at 2B58)
.xdata$x:00005968 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005968                                         ; DATA XREF: .xdata$x:00005978o
.xdata$x:00005969                 db 0FFh
.xdata$x:0000596A                 db 0FFh
.xdata$x:0000596B                 db 0FFh
.xdata$x:0000596C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00005970 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005970                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005971                 db    5
.xdata$x:00005972                 db  93h ; 
.xdata$x:00005973                 db  19h
.xdata$x:00005974                 db    1
.xdata$x:00005975                 db    0
.xdata$x:00005976                 db    0
.xdata$x:00005977                 db    0
.xdata$x:00005978                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000597C                 db    0
.xdata$x:0000597D                 db    0
.xdata$x:0000597E                 db    0
.xdata$x:0000597F                 db    0
.xdata$x:00005980                 db    0
.xdata$x:00005981                 db    0
.xdata$x:00005982                 db    0
.xdata$x:00005983                 db    0
.xdata$x:00005984                 db    0
.xdata$x:00005985                 db    0
.xdata$x:00005986                 db    0
.xdata$x:00005987                 db    0
.xdata$x:00005988                 db    0
.xdata$x:00005989                 db    0
.xdata$x:0000598A                 db    0
.xdata$x:0000598B                 db    0
.xdata$x:0000598C                 db    0
.xdata$x:0000598D                 db    0
.xdata$x:0000598E                 db    0
.xdata$x:0000598F                 db    0
.xdata$x:00005990                 db    0
.xdata$x:00005991                 db    0
.xdata$x:00005992                 db    0
.xdata$x:00005993                 db    0
.xdata$x:00005993 _xdata$x        ends
.xdata$x:00005993
.xdata$x:00005994 ; ===========================================================================
.xdata$x:00005994
.xdata$x:00005994 ; Segment type: Pure data
.xdata$x:00005994 ; Segment permissions: Read
.xdata$x:00005994 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005994                 assume cs:_xdata$x
.xdata$x:00005994                 ;org 5994h
.xdata$x:00005994 ; COMDAT (pick associative to section at 2378)
.xdata$x:00005994 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00005994                                         ; DATA XREF: .xdata$x:000059A4o
.xdata$x:00005995                 db 0FFh
.xdata$x:00005996                 db 0FFh
.xdata$x:00005997                 db 0FFh
.xdata$x:00005998                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000599C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000599C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000599D                 db    5
.xdata$x:0000599E                 db  93h ; 
.xdata$x:0000599F                 db  19h
.xdata$x:000059A0                 db    1
.xdata$x:000059A1                 db    0
.xdata$x:000059A2                 db    0
.xdata$x:000059A3                 db    0
.xdata$x:000059A4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000059A8                 align 20h
.xdata$x:000059A8 _xdata$x        ends
.xdata$x:000059A8
.xdata$x:000059C0 ; ===========================================================================
.xdata$x:000059C0
.xdata$x:000059C0 ; Segment type: Pure data
.xdata$x:000059C0 ; Segment permissions: Read
.xdata$x:000059C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000059C0                 assume cs:_xdata$x
.xdata$x:000059C0                 ;org 59C0h
.xdata$x:000059C0 ; COMDAT (pick associative to section at 2EF8)
.xdata$x:000059C0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000059C0                                         ; DATA XREF: .xdata$x:000059D0o
.xdata$x:000059C1                 db 0FFh
.xdata$x:000059C2                 db 0FFh
.xdata$x:000059C3                 db 0FFh
.xdata$x:000059C4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000059C8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000059C8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000059C9                 db    5
.xdata$x:000059CA                 db  93h ; 
.xdata$x:000059CB                 db  19h
.xdata$x:000059CC                 db    1
.xdata$x:000059CD                 db    0
.xdata$x:000059CE                 db    0
.xdata$x:000059CF                 db    0
.xdata$x:000059D0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000059D4                 db    0
.xdata$x:000059D5                 db    0
.xdata$x:000059D6                 db    0
.xdata$x:000059D7                 db    0
.xdata$x:000059D8                 db    0
.xdata$x:000059D9                 db    0
.xdata$x:000059DA                 db    0
.xdata$x:000059DB                 db    0
.xdata$x:000059DC                 db    0
.xdata$x:000059DD                 db    0
.xdata$x:000059DE                 db    0
.xdata$x:000059DF                 db    0
.xdata$x:000059E0                 db    0
.xdata$x:000059E1                 db    0
.xdata$x:000059E2                 db    0
.xdata$x:000059E3                 db    0
.xdata$x:000059E4                 db    0
.xdata$x:000059E5                 db    0
.xdata$x:000059E6                 db    0
.xdata$x:000059E7                 db    0
.xdata$x:000059E8                 db    0
.xdata$x:000059E9                 db    0
.xdata$x:000059EA                 db    0
.xdata$x:000059EB                 db    0
.xdata$x:000059EB _xdata$x        ends
.xdata$x:000059EB
.xdata$x:000059EC ; ===========================================================================
.xdata$x:000059EC
.xdata$x:000059EC ; Segment type: Pure data
.xdata$x:000059EC ; Segment permissions: Read
.xdata$x:000059EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000059EC                 assume cs:_xdata$x
.xdata$x:000059EC                 ;org 59ECh
.xdata$x:000059EC ; COMDAT (pick associative to section at 3860)
.xdata$x:000059EC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000059EC                                         ; DATA XREF: .xdata$x:00005A74o
.xdata$x:000059ED                 db    0
.xdata$x:000059EE                 db    0
.xdata$x:000059EF                 db    0
.xdata$x:000059F0                 db    0
.xdata$x:000059F1                 db    0
.xdata$x:000059F2                 db    0
.xdata$x:000059F3                 db    0
.xdata$x:000059F4                 db    0
.xdata$x:000059F5                 db    0
.xdata$x:000059F6                 db    0
.xdata$x:000059F7                 db    0
.xdata$x:000059F8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000059FC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000059FC                                         ; DATA XREF: .xdata$x:00005A60o
.xdata$x:000059FD                 db    0
.xdata$x:000059FE                 db    0
.xdata$x:000059FF                 db    0
.xdata$x:00005A00                 db    0
.xdata$x:00005A01                 db    0
.xdata$x:00005A02                 db    0
.xdata$x:00005A03                 db    0
.xdata$x:00005A04                 db    0
.xdata$x:00005A05                 db    0
.xdata$x:00005A06                 db    0
.xdata$x:00005A07                 db    0
.xdata$x:00005A08                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00005A0C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00005A0C                                         ; DATA XREF: .xdata$x:00005A34o
.xdata$x:00005A0D                 db 0FFh
.xdata$x:00005A0E                 db 0FFh
.xdata$x:00005A0F                 db 0FFh
.xdata$x:00005A10                 db    0
.xdata$x:00005A11                 db    0
.xdata$x:00005A12                 db    0
.xdata$x:00005A13                 db    0
.xdata$x:00005A14                 db 0FFh
.xdata$x:00005A15                 db 0FFh
.xdata$x:00005A16                 db 0FFh
.xdata$x:00005A17                 db 0FFh
.xdata$x:00005A18                 db    0
.xdata$x:00005A19                 db    0
.xdata$x:00005A1A                 db    0
.xdata$x:00005A1B                 db    0
.xdata$x:00005A1C                 db    1
.xdata$x:00005A1D                 db    0
.xdata$x:00005A1E                 db    0
.xdata$x:00005A1F                 db    0
.xdata$x:00005A20                 db    0
.xdata$x:00005A21                 db    0
.xdata$x:00005A22                 db    0
.xdata$x:00005A23                 db    0
.xdata$x:00005A24                 db    1
.xdata$x:00005A25                 db    0
.xdata$x:00005A26                 db    0
.xdata$x:00005A27                 db    0
.xdata$x:00005A28                 db    0
.xdata$x:00005A29                 db    0
.xdata$x:00005A2A                 db    0
.xdata$x:00005A2B                 db    0
.xdata$x:00005A2C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00005A2C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00005A2D                 db    5
.xdata$x:00005A2E                 db  93h ; 
.xdata$x:00005A2F                 db  19h
.xdata$x:00005A30                 db    4
.xdata$x:00005A31                 db    0
.xdata$x:00005A32                 db    0
.xdata$x:00005A33                 db    0
.xdata$x:00005A34                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00005A38                 db    2
.xdata$x:00005A39                 db    0
.xdata$x:00005A3A                 db    0
.xdata$x:00005A3B                 db    0
.xdata$x:00005A3C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00005A40                 db    0
.xdata$x:00005A41                 db    0
.xdata$x:00005A42                 db    0
.xdata$x:00005A43                 db    0
.xdata$x:00005A44                 db    0
.xdata$x:00005A45                 db    0
.xdata$x:00005A46                 db    0
.xdata$x:00005A47                 db    0
.xdata$x:00005A48                 db    0
.xdata$x:00005A49                 db    0
.xdata$x:00005A4A                 db    0
.xdata$x:00005A4B                 db    0
.xdata$x:00005A4C                 db    0
.xdata$x:00005A4D                 db    0
.xdata$x:00005A4E                 db    0
.xdata$x:00005A4F                 db    0
.xdata$x:00005A50 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00005A50                                         ; DATA XREF: .xdata$x:00005A3Co
.xdata$x:00005A51                 db    0
.xdata$x:00005A52                 db    0
.xdata$x:00005A53                 db    0
.xdata$x:00005A54                 db    2
.xdata$x:00005A55                 db    0
.xdata$x:00005A56                 db    0
.xdata$x:00005A57                 db    0
.xdata$x:00005A58                 db    3
.xdata$x:00005A59                 db    0
.xdata$x:00005A5A                 db    0
.xdata$x:00005A5B                 db    0
.xdata$x:00005A5C                 db    1
.xdata$x:00005A5D                 db    0
.xdata$x:00005A5E                 db    0
.xdata$x:00005A5F                 db    0
.xdata$x:00005A60                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00005A64                 db    0
.xdata$x:00005A65                 db    0
.xdata$x:00005A66                 db    0
.xdata$x:00005A67                 db    0
.xdata$x:00005A68                 db    0
.xdata$x:00005A69                 db    0
.xdata$x:00005A6A                 db    0
.xdata$x:00005A6B                 db    0
.xdata$x:00005A6C                 db    3
.xdata$x:00005A6D                 db    0
.xdata$x:00005A6E                 db    0
.xdata$x:00005A6F                 db    0
.xdata$x:00005A70                 db    1
.xdata$x:00005A71                 db    0
.xdata$x:00005A72                 db    0
.xdata$x:00005A73                 db    0
.xdata$x:00005A74                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00005A74 _xdata$x        ends
.xdata$x:00005A74
.xdata$x:00005A78 ; ===========================================================================
.xdata$x:00005A78
.xdata$x:00005A78 ; Segment type: Pure data
.xdata$x:00005A78 ; Segment permissions: Read
.xdata$x:00005A78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005A78                 assume cs:_xdata$x
.xdata$x:00005A78                 ;org 5A78h
.xdata$x:00005A78 ; COMDAT (pick associative to section at 2AD4)
.xdata$x:00005A78 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00005A78                                         ; DATA XREF: .xdata$x:00005A88o
.xdata$x:00005A79                 db 0FFh
.xdata$x:00005A7A                 db 0FFh
.xdata$x:00005A7B                 db 0FFh
.xdata$x:00005A7C                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00005A80 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00005A80                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00005A81                 db    5
.xdata$x:00005A82                 db  93h ; 
.xdata$x:00005A83                 db  19h
.xdata$x:00005A84                 db    1
.xdata$x:00005A85                 db    0
.xdata$x:00005A86                 db    0
.xdata$x:00005A87                 db    0
.xdata$x:00005A88                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00005A8C                 db    0
.xdata$x:00005A8D                 db    0
.xdata$x:00005A8E                 db    0
.xdata$x:00005A8F                 db    0
.xdata$x:00005A90                 db    0
.xdata$x:00005A91                 db    0
.xdata$x:00005A92                 db    0
.xdata$x:00005A93                 db    0
.xdata$x:00005A94                 db    0
.xdata$x:00005A95                 db    0
.xdata$x:00005A96                 db    0
.xdata$x:00005A97                 db    0
.xdata$x:00005A98                 db    0
.xdata$x:00005A99                 db    0
.xdata$x:00005A9A                 db    0
.xdata$x:00005A9B                 db    0
.xdata$x:00005A9C                 db    0
.xdata$x:00005A9D                 db    0
.xdata$x:00005A9E                 db    0
.xdata$x:00005A9F                 db    0
.xdata$x:00005AA0                 db    0
.xdata$x:00005AA1                 db    0
.xdata$x:00005AA2                 db    0
.xdata$x:00005AA3                 db    0
.xdata$x:00005AA3 _xdata$x        ends
.xdata$x:00005AA3
.xdata$x:00005AA4 ; ===========================================================================
.xdata$x:00005AA4
.xdata$x:00005AA4 ; Segment type: Pure data
.xdata$x:00005AA4 ; Segment permissions: Read
.xdata$x:00005AA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005AA4                 assume cs:_xdata$x
.xdata$x:00005AA4                 ;org 5AA4h
.xdata$x:00005AA4 ; COMDAT (pick associative to section at 3340)
.xdata$x:00005AA4 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00005AA4                                         ; DATA XREF: .xdata$x:00005AB4o
.xdata$x:00005AA5                 db 0FFh
.xdata$x:00005AA6                 db 0FFh
.xdata$x:00005AA7                 db 0FFh
.xdata$x:00005AA8                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00005AAC __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00005AAC                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00005AAD                 db    5
.xdata$x:00005AAE                 db  93h ; 
.xdata$x:00005AAF                 db  19h
.xdata$x:00005AB0                 db    1
.xdata$x:00005AB1                 db    0
.xdata$x:00005AB2                 db    0
.xdata$x:00005AB3                 db    0
.xdata$x:00005AB4                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00005AB8                 db    0
.xdata$x:00005AB9                 db    0
.xdata$x:00005ABA                 db    0
.xdata$x:00005ABB                 db    0
.xdata$x:00005ABC                 db    0
.xdata$x:00005ABD                 db    0
.xdata$x:00005ABE                 db    0
.xdata$x:00005ABF                 db    0
.xdata$x:00005AC0                 db    0
.xdata$x:00005AC1                 db    0
.xdata$x:00005AC2                 db    0
.xdata$x:00005AC3                 db    0
.xdata$x:00005AC4                 db    0
.xdata$x:00005AC5                 db    0
.xdata$x:00005AC6                 db    0
.xdata$x:00005AC7                 db    0
.xdata$x:00005AC8                 db    0
.xdata$x:00005AC9                 db    0
.xdata$x:00005ACA                 db    0
.xdata$x:00005ACB                 db    0
.xdata$x:00005ACC                 db    0
.xdata$x:00005ACD                 db    0
.xdata$x:00005ACE                 db    0
.xdata$x:00005ACF                 db    0
.xdata$x:00005ACF _xdata$x        ends
.xdata$x:00005ACF
.xdata$x:00005AD0 ; ===========================================================================
.xdata$x:00005AD0
.xdata$x:00005AD0 ; Segment type: Pure data
.xdata$x:00005AD0 ; Segment permissions: Read
.xdata$x:00005AD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005AD0                 assume cs:_xdata$x
.xdata$x:00005AD0                 ;org 5AD0h
.xdata$x:00005AD0 ; COMDAT (pick associative to section at 2A50)
.xdata$x:00005AD0 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00005AD0                                         ; DATA XREF: .xdata$x:00005AE0o
.xdata$x:00005AD1                 db 0FFh
.xdata$x:00005AD2                 db 0FFh
.xdata$x:00005AD3                 db 0FFh
.xdata$x:00005AD4                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00005AD8 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00005AD8                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00005AD9                 db    5
.xdata$x:00005ADA                 db  93h ; 
.xdata$x:00005ADB                 db  19h
.xdata$x:00005ADC                 db    1
.xdata$x:00005ADD                 db    0
.xdata$x:00005ADE                 db    0
.xdata$x:00005ADF                 db    0
.xdata$x:00005AE0                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00005AE4                 db    0
.xdata$x:00005AE5                 db    0
.xdata$x:00005AE6                 db    0
.xdata$x:00005AE7                 db    0
.xdata$x:00005AE8                 db    0
.xdata$x:00005AE9                 db    0
.xdata$x:00005AEA                 db    0
.xdata$x:00005AEB                 db    0
.xdata$x:00005AEC                 db    0
.xdata$x:00005AED                 db    0
.xdata$x:00005AEE                 db    0
.xdata$x:00005AEF                 db    0
.xdata$x:00005AF0                 db    0
.xdata$x:00005AF1                 db    0
.xdata$x:00005AF2                 db    0
.xdata$x:00005AF3                 db    0
.xdata$x:00005AF4                 db    0
.xdata$x:00005AF5                 db    0
.xdata$x:00005AF6                 db    0
.xdata$x:00005AF7                 db    0
.xdata$x:00005AF8                 db    0
.xdata$x:00005AF9                 db    0
.xdata$x:00005AFA                 db    0
.xdata$x:00005AFB                 db    0
.xdata$x:00005AFB _xdata$x        ends
.xdata$x:00005AFB
.xdata$x:00005AFC ; ===========================================================================
.xdata$x:00005AFC
.xdata$x:00005AFC ; Segment type: Pure data
.xdata$x:00005AFC ; Segment permissions: Read
.xdata$x:00005AFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005AFC                 assume cs:_xdata$x
.xdata$x:00005AFC                 ;org 5AFCh
.xdata$x:00005AFC ; COMDAT (pick associative to section at 2888)
.xdata$x:00005AFC __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00005AFC                                         ; DATA XREF: .xdata$x:00005B0Co
.xdata$x:00005AFD                 db 0FFh
.xdata$x:00005AFE                 db 0FFh
.xdata$x:00005AFF                 db 0FFh
.xdata$x:00005B00                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00005B04 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00005B04                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00005B05                 db    5
.xdata$x:00005B06                 db  93h ; 
.xdata$x:00005B07                 db  19h
.xdata$x:00005B08                 db    1
.xdata$x:00005B09                 db    0
.xdata$x:00005B0A                 db    0
.xdata$x:00005B0B                 db    0
.xdata$x:00005B0C                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00005B10                 db    0
.xdata$x:00005B11                 db    0
.xdata$x:00005B12                 db    0
.xdata$x:00005B13                 db    0
.xdata$x:00005B14                 db    0
.xdata$x:00005B15                 db    0
.xdata$x:00005B16                 db    0
.xdata$x:00005B17                 db    0
.xdata$x:00005B18                 db    0
.xdata$x:00005B19                 db    0
.xdata$x:00005B1A                 db    0
.xdata$x:00005B1B                 db    0
.xdata$x:00005B1C                 db    0
.xdata$x:00005B1D                 db    0
.xdata$x:00005B1E                 db    0
.xdata$x:00005B1F                 db    0
.xdata$x:00005B20                 db    0
.xdata$x:00005B21                 db    0
.xdata$x:00005B22                 db    0
.xdata$x:00005B23                 db    0
.xdata$x:00005B24                 db    0
.xdata$x:00005B25                 db    0
.xdata$x:00005B26                 db    0
.xdata$x:00005B27                 db    0
.xdata$x:00005B27 _xdata$x        ends
.xdata$x:00005B27
.xdata$x:00005B28 ; ===========================================================================
.xdata$x:00005B28
.xdata$x:00005B28 ; Segment type: Pure data
.xdata$x:00005B28 ; Segment permissions: Read
.xdata$x:00005B28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005B28                 assume cs:_xdata$x
.xdata$x:00005B28                 ;org 5B28h
.xdata$x:00005B28 ; COMDAT (pick associative to section at 5334)
.xdata$x:00005B28 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00005B28                                         ; DATA XREF: .xdata$x:00005B38o
.xdata$x:00005B29                 db 0FFh
.xdata$x:00005B2A                 db 0FFh
.xdata$x:00005B2B                 db 0FFh
.xdata$x:00005B2C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00005B30 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00005B30                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00005B31                 db    5
.xdata$x:00005B32                 db  93h ; 
.xdata$x:00005B33                 db  19h
.xdata$x:00005B34                 db    1
.xdata$x:00005B35                 db    0
.xdata$x:00005B36                 db    0
.xdata$x:00005B37                 db    0
.xdata$x:00005B38                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00005B3C                 db    0
.xdata$x:00005B3D                 db    0
.xdata$x:00005B3E                 db    0
.xdata$x:00005B3F                 db    0
.xdata$x:00005B40                 db    0
.xdata$x:00005B41                 db    0
.xdata$x:00005B42                 db    0
.xdata$x:00005B43                 db    0
.xdata$x:00005B44                 db    0
.xdata$x:00005B45                 db    0
.xdata$x:00005B46                 db    0
.xdata$x:00005B47                 db    0
.xdata$x:00005B48                 db    0
.xdata$x:00005B49                 db    0
.xdata$x:00005B4A                 db    0
.xdata$x:00005B4B                 db    0
.xdata$x:00005B4C                 db    0
.xdata$x:00005B4D                 db    0
.xdata$x:00005B4E                 db    0
.xdata$x:00005B4F                 db    0
.xdata$x:00005B50                 db    0
.xdata$x:00005B51                 db    0
.xdata$x:00005B52                 db    0
.xdata$x:00005B53                 db    0
.xdata$x:00005B53 _xdata$x        ends
.xdata$x:00005B53
.xdata$x:00005B54 ; ===========================================================================
.xdata$x:00005B54
.xdata$x:00005B54 ; Segment type: Pure data
.xdata$x:00005B54 ; Segment permissions: Read
.xdata$x:00005B54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005B54                 assume cs:_xdata$x
.xdata$x:00005B54                 ;org 5B54h
.xdata$x:00005B54 ; COMDAT (pick associative to section at 31DC)
.xdata$x:00005B54 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00005B54                                         ; DATA XREF: .xdata$x:00005B64o
.xdata$x:00005B55                 db 0FFh
.xdata$x:00005B56                 db 0FFh
.xdata$x:00005B57                 db 0FFh
.xdata$x:00005B58                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00005B5C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00005B5C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00005B5D                 db    5
.xdata$x:00005B5E                 db  93h ; 
.xdata$x:00005B5F                 db  19h
.xdata$x:00005B60                 db    1
.xdata$x:00005B61                 db    0
.xdata$x:00005B62                 db    0
.xdata$x:00005B63                 db    0
.xdata$x:00005B64                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00005B68                 align 20h
.xdata$x:00005B68 _xdata$x        ends
.xdata$x:00005B68
.xdata$x:00005B80 ; ===========================================================================
.xdata$x:00005B80
.xdata$x:00005B80 ; Segment type: Pure data
.xdata$x:00005B80 ; Segment permissions: Read
.xdata$x:00005B80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005B80                 assume cs:_xdata$x
.xdata$x:00005B80                 ;org 5B80h
.xdata$x:00005B80 ; COMDAT (pick associative to section at 2904)
.xdata$x:00005B80 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00005B80                                         ; DATA XREF: .xdata$x:00005B90o
.xdata$x:00005B81                 db 0FFh
.xdata$x:00005B82                 db 0FFh
.xdata$x:00005B83                 db 0FFh
.xdata$x:00005B84                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00005B88 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00005B88                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00005B89                 db    5
.xdata$x:00005B8A                 db  93h ; 
.xdata$x:00005B8B                 db  19h
.xdata$x:00005B8C                 db    1
.xdata$x:00005B8D                 db    0
.xdata$x:00005B8E                 db    0
.xdata$x:00005B8F                 db    0
.xdata$x:00005B90                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00005B94                 db    0
.xdata$x:00005B95                 db    0
.xdata$x:00005B96                 db    0
.xdata$x:00005B97                 db    0
.xdata$x:00005B98                 db    0
.xdata$x:00005B99                 db    0
.xdata$x:00005B9A                 db    0
.xdata$x:00005B9B                 db    0
.xdata$x:00005B9C                 db    0
.xdata$x:00005B9D                 db    0
.xdata$x:00005B9E                 db    0
.xdata$x:00005B9F                 db    0
.xdata$x:00005BA0                 db    0
.xdata$x:00005BA1                 db    0
.xdata$x:00005BA2                 db    0
.xdata$x:00005BA3                 db    0
.xdata$x:00005BA4                 db    0
.xdata$x:00005BA5                 db    0
.xdata$x:00005BA6                 db    0
.xdata$x:00005BA7                 db    0
.xdata$x:00005BA8                 db    0
.xdata$x:00005BA9                 db    0
.xdata$x:00005BAA                 db    0
.xdata$x:00005BAB                 db    0
.xdata$x:00005BAB _xdata$x        ends
.xdata$x:00005BAB
.xdata$x:00005BAC ; ===========================================================================
.xdata$x:00005BAC
.xdata$x:00005BAC ; Segment type: Pure data
.xdata$x:00005BAC ; Segment permissions: Read
.xdata$x:00005BAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005BAC                 assume cs:_xdata$x
.xdata$x:00005BAC                 ;org 5BACh
.xdata$x:00005BAC ; COMDAT (pick associative to section at 53EC)
.xdata$x:00005BAC __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00005BAC                                         ; DATA XREF: .xdata$x:00005BBCo
.xdata$x:00005BAD                 db 0FFh
.xdata$x:00005BAE                 db 0FFh
.xdata$x:00005BAF                 db 0FFh
.xdata$x:00005BB0                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00005BB4 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00005BB4                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00005BB5                 db    5
.xdata$x:00005BB6                 db  93h ; 
.xdata$x:00005BB7                 db  19h
.xdata$x:00005BB8                 db    1
.xdata$x:00005BB9                 db    0
.xdata$x:00005BBA                 db    0
.xdata$x:00005BBB                 db    0
.xdata$x:00005BBC                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00005BC0                 db    0
.xdata$x:00005BC1                 db    0
.xdata$x:00005BC2                 db    0
.xdata$x:00005BC3                 db    0
.xdata$x:00005BC4                 db    0
.xdata$x:00005BC5                 db    0
.xdata$x:00005BC6                 db    0
.xdata$x:00005BC7                 db    0
.xdata$x:00005BC8                 db    0
.xdata$x:00005BC9                 db    0
.xdata$x:00005BCA                 db    0
.xdata$x:00005BCB                 db    0
.xdata$x:00005BCC                 db    0
.xdata$x:00005BCD                 db    0
.xdata$x:00005BCE                 db    0
.xdata$x:00005BCF                 db    0
.xdata$x:00005BD0                 db    0
.xdata$x:00005BD1                 db    0
.xdata$x:00005BD2                 db    0
.xdata$x:00005BD3                 db    0
.xdata$x:00005BD4                 db    0
.xdata$x:00005BD5                 db    0
.xdata$x:00005BD6                 db    0
.xdata$x:00005BD7                 db    0
.xdata$x:00005BD7 _xdata$x        ends
.xdata$x:00005BD7
.xdata$x:00005BD8 ; ===========================================================================
.xdata$x:00005BD8
.xdata$x:00005BD8 ; Segment type: Pure data
.xdata$x:00005BD8 ; Segment permissions: Read
.xdata$x:00005BD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005BD8                 assume cs:_xdata$x
.xdata$x:00005BD8                 ;org 5BD8h
.xdata$x:00005BD8 ; COMDAT (pick associative to section at 324C)
.xdata$x:00005BD8 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00005BD8                                         ; DATA XREF: .xdata$x:00005BE8o
.xdata$x:00005BD9                 db 0FFh
.xdata$x:00005BDA                 db 0FFh
.xdata$x:00005BDB                 db 0FFh
.xdata$x:00005BDC                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00005BE0 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00005BE0                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00005BE1                 db    5
.xdata$x:00005BE2                 db  93h ; 
.xdata$x:00005BE3                 db  19h
.xdata$x:00005BE4                 db    1
.xdata$x:00005BE5                 db    0
.xdata$x:00005BE6                 db    0
.xdata$x:00005BE7                 db    0
.xdata$x:00005BE8                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00005BEC                 db    0
.xdata$x:00005BED                 db    0
.xdata$x:00005BEE                 db    0
.xdata$x:00005BEF                 db    0
.xdata$x:00005BF0                 db    0
.xdata$x:00005BF1                 db    0
.xdata$x:00005BF2                 db    0
.xdata$x:00005BF3                 db    0
.xdata$x:00005BF4                 db    0
.xdata$x:00005BF5                 db    0
.xdata$x:00005BF6                 db    0
.xdata$x:00005BF7                 db    0
.xdata$x:00005BF8                 db    0
.xdata$x:00005BF9                 db    0
.xdata$x:00005BFA                 db    0
.xdata$x:00005BFB                 db    0
.xdata$x:00005BFC                 db    0
.xdata$x:00005BFD                 db    0
.xdata$x:00005BFE                 db    0
.xdata$x:00005BFF                 db    0
.xdata$x:00005C00                 db    0
.xdata$x:00005C01                 db    0
.xdata$x:00005C02                 db    0
.xdata$x:00005C03                 db    0
.xdata$x:00005C03 _xdata$x        ends
.xdata$x:00005C03
.xdata$x:00005C04 ; ===========================================================================
.xdata$x:00005C04
.xdata$x:00005C04 ; Segment type: Pure data
.xdata$x:00005C04 ; Segment permissions: Read
.xdata$x:00005C04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005C04                 assume cs:_xdata$x
.xdata$x:00005C04                 ;org 5C04h
.xdata$x:00005C04 ; COMDAT (pick associative to section at 2980)
.xdata$x:00005C04 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00005C04                                         ; DATA XREF: .xdata$x:00005C14o
.xdata$x:00005C05                 db 0FFh
.xdata$x:00005C06                 db 0FFh
.xdata$x:00005C07                 db 0FFh
.xdata$x:00005C08                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00005C0C __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00005C0C                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00005C0D                 db    5
.xdata$x:00005C0E                 db  93h ; 
.xdata$x:00005C0F                 db  19h
.xdata$x:00005C10                 db    1
.xdata$x:00005C11                 db    0
.xdata$x:00005C12                 db    0
.xdata$x:00005C13                 db    0
.xdata$x:00005C14                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00005C18                 db    0
.xdata$x:00005C19                 db    0
.xdata$x:00005C1A                 db    0
.xdata$x:00005C1B                 db    0
.xdata$x:00005C1C                 db    0
.xdata$x:00005C1D                 db    0
.xdata$x:00005C1E                 db    0
.xdata$x:00005C1F                 db    0
.xdata$x:00005C20                 db    0
.xdata$x:00005C21                 db    0
.xdata$x:00005C22                 db    0
.xdata$x:00005C23                 db    0
.xdata$x:00005C24                 db    0
.xdata$x:00005C25                 db    0
.xdata$x:00005C26                 db    0
.xdata$x:00005C27                 db    0
.xdata$x:00005C28                 db    0
.xdata$x:00005C29                 db    0
.xdata$x:00005C2A                 db    0
.xdata$x:00005C2B                 db    0
.xdata$x:00005C2C                 db    0
.xdata$x:00005C2D                 db    0
.xdata$x:00005C2E                 db    0
.xdata$x:00005C2F                 db    0
.xdata$x:00005C2F _xdata$x        ends
.xdata$x:00005C2F
.xdata$x:00005C30 ; ===========================================================================
.xdata$x:00005C30
.xdata$x:00005C30 ; Segment type: Pure data
.xdata$x:00005C30 ; Segment permissions: Read
.xdata$x:00005C30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005C30                 assume cs:_xdata$x
.xdata$x:00005C30                 ;org 5C30h
.xdata$x:00005C30 ; COMDAT (pick associative to section at 54B0)
.xdata$x:00005C30 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00005C30                                         ; DATA XREF: .xdata$x:00005C40o
.xdata$x:00005C31                 db 0FFh
.xdata$x:00005C32                 db 0FFh
.xdata$x:00005C33                 db 0FFh
.xdata$x:00005C34                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00005C38 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00005C38                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00005C39                 db    5
.xdata$x:00005C3A                 db  93h ; 
.xdata$x:00005C3B                 db  19h
.xdata$x:00005C3C                 db    1
.xdata$x:00005C3D                 db    0
.xdata$x:00005C3E                 db    0
.xdata$x:00005C3F                 db    0
.xdata$x:00005C40                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00005C44                 db    0
.xdata$x:00005C45                 db    0
.xdata$x:00005C46                 db    0
.xdata$x:00005C47                 db    0
.xdata$x:00005C48                 db    0
.xdata$x:00005C49                 db    0
.xdata$x:00005C4A                 db    0
.xdata$x:00005C4B                 db    0
.xdata$x:00005C4C                 db    0
.xdata$x:00005C4D                 db    0
.xdata$x:00005C4E                 db    0
.xdata$x:00005C4F                 db    0
.xdata$x:00005C50                 db    0
.xdata$x:00005C51                 db    0
.xdata$x:00005C52                 db    0
.xdata$x:00005C53                 db    0
.xdata$x:00005C54                 db    0
.xdata$x:00005C55                 db    0
.xdata$x:00005C56                 db    0
.xdata$x:00005C57                 db    0
.xdata$x:00005C58                 db    0
.xdata$x:00005C59                 db    0
.xdata$x:00005C5A                 db    0
.xdata$x:00005C5B                 db    0
.xdata$x:00005C5B _xdata$x        ends
.xdata$x:00005C5B
.xdata$x:00005C5C ; ===========================================================================
.xdata$x:00005C5C
.xdata$x:00005C5C ; Segment type: Pure data
.xdata$x:00005C5C ; Segment permissions: Read
.xdata$x:00005C5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005C5C                 assume cs:_xdata$x
.xdata$x:00005C5C                 ;org 5C5Ch
.xdata$x:00005C5C ; COMDAT (pick associative to section at 32BC)
.xdata$x:00005C5C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00005C5C                                         ; DATA XREF: .xdata$x:00005C6Co
.xdata$x:00005C5D                 db 0FFh
.xdata$x:00005C5E                 db 0FFh
.xdata$x:00005C5F                 db 0FFh
.xdata$x:00005C60                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00005C64 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00005C64                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00005C65                 db    5
.xdata$x:00005C66                 db  93h ; 
.xdata$x:00005C67                 db  19h
.xdata$x:00005C68                 db    1
.xdata$x:00005C69                 db    0
.xdata$x:00005C6A                 db    0
.xdata$x:00005C6B                 db    0
.xdata$x:00005C6C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00005C70                 db    0
.xdata$x:00005C71                 db    0
.xdata$x:00005C72                 db    0
.xdata$x:00005C73                 db    0
.xdata$x:00005C74                 db    0
.xdata$x:00005C75                 db    0
.xdata$x:00005C76                 db    0
.xdata$x:00005C77                 db    0
.xdata$x:00005C78                 db    0
.xdata$x:00005C79                 db    0
.xdata$x:00005C7A                 db    0
.xdata$x:00005C7B                 db    0
.xdata$x:00005C7C                 db    0
.xdata$x:00005C7D                 db    0
.xdata$x:00005C7E                 db    0
.xdata$x:00005C7F                 db    0
.xdata$x:00005C80                 db    0
.xdata$x:00005C81                 db    0
.xdata$x:00005C82                 db    0
.xdata$x:00005C83                 db    0
.xdata$x:00005C84                 db    0
.xdata$x:00005C85                 db    0
.xdata$x:00005C86                 db    0
.xdata$x:00005C87                 db    0
.xdata$x:00005C87 _xdata$x        ends
.xdata$x:00005C87
.xdata$x:00005C88 ; ===========================================================================
.xdata$x:00005C88
.xdata$x:00005C88 ; Segment type: Pure data
.xdata$x:00005C88 ; Segment permissions: Read
.xdata$x:00005C88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005C88                 assume cs:_xdata$x
.xdata$x:00005C88                 ;org 5C88h
.xdata$x:00005C88 ; COMDAT (pick associative to section at 1FE4)
.xdata$x:00005C88 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005C88                                         ; DATA XREF: .xdata$x:00005C98o
.xdata$x:00005C89                 db 0FFh
.xdata$x:00005C8A                 db 0FFh
.xdata$x:00005C8B                 db 0FFh
.xdata$x:00005C8C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00005C90 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005C90                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00005C91                 db    5
.xdata$x:00005C92                 db  93h ; 
.xdata$x:00005C93                 db  19h
.xdata$x:00005C94                 db    1
.xdata$x:00005C95                 db    0
.xdata$x:00005C96                 db    0
.xdata$x:00005C97                 db    0
.xdata$x:00005C98                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00005C9C                 db    0
.xdata$x:00005C9D                 db    0
.xdata$x:00005C9E                 db    0
.xdata$x:00005C9F                 db    0
.xdata$x:00005CA0                 db    0
.xdata$x:00005CA1                 db    0
.xdata$x:00005CA2                 db    0
.xdata$x:00005CA3                 db    0
.xdata$x:00005CA4                 db    0
.xdata$x:00005CA5                 db    0
.xdata$x:00005CA6                 db    0
.xdata$x:00005CA7                 db    0
.xdata$x:00005CA8                 db    0
.xdata$x:00005CA9                 db    0
.xdata$x:00005CAA                 db    0
.xdata$x:00005CAB                 db    0
.xdata$x:00005CAC                 db    0
.xdata$x:00005CAD                 db    0
.xdata$x:00005CAE                 db    0
.xdata$x:00005CAF                 db    0
.xdata$x:00005CB0                 db    0
.xdata$x:00005CB1                 db    0
.xdata$x:00005CB2                 db    0
.xdata$x:00005CB3                 db    0
.xdata$x:00005CB3 _xdata$x        ends
.xdata$x:00005CB3
.xdata$x:00005CB4 ; ===========================================================================
.xdata$x:00005CB4
.xdata$x:00005CB4 ; Segment type: Pure data
.xdata$x:00005CB4 ; Segment permissions: Read
.xdata$x:00005CB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005CB4                 assume cs:_xdata$x
.xdata$x:00005CB4                 ;org 5CB4h
.xdata$x:00005CB4 ; COMDAT (pick associative to section at 2CB8)
.xdata$x:00005CB4 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005CB4                                         ; DATA XREF: .xdata$x:00005CC4o
.xdata$x:00005CB5                 db 0FFh
.xdata$x:00005CB6                 db 0FFh
.xdata$x:00005CB7                 db 0FFh
.xdata$x:00005CB8                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00005CBC __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005CBC                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00005CBD                 db    5
.xdata$x:00005CBE                 db  93h ; 
.xdata$x:00005CBF                 db  19h
.xdata$x:00005CC0                 db    1
.xdata$x:00005CC1                 db    0
.xdata$x:00005CC2                 db    0
.xdata$x:00005CC3                 db    0
.xdata$x:00005CC4                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00005CC8                 align 20h
.xdata$x:00005CC8 _xdata$x        ends
.xdata$x:00005CC8
.xdata$x:00005CE0 ; ===========================================================================
.xdata$x:00005CE0
.xdata$x:00005CE0 ; Segment type: Pure data
.xdata$x:00005CE0 ; Segment permissions: Read
.xdata$x:00005CE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005CE0                 assume cs:_xdata$x
.xdata$x:00005CE0                 ;org 5CE0h
.xdata$x:00005CE0 ; COMDAT (pick associative to section at 1EE0)
.xdata$x:00005CE0 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:00005CE0                                         ; DATA XREF: .xdata$x:00005CF0o
.xdata$x:00005CE1                 db 0FFh
.xdata$x:00005CE2                 db 0FFh
.xdata$x:00005CE3                 db 0FFh
.xdata$x:00005CE4                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:00005CE8 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:00005CE8                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:00005CE9                 db    5
.xdata$x:00005CEA                 db  93h ; 
.xdata$x:00005CEB                 db  19h
.xdata$x:00005CEC                 db    1
.xdata$x:00005CED                 db    0
.xdata$x:00005CEE                 db    0
.xdata$x:00005CEF                 db    0
.xdata$x:00005CF0                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:00005CF4                 db    0
.xdata$x:00005CF5                 db    0
.xdata$x:00005CF6                 db    0
.xdata$x:00005CF7                 db    0
.xdata$x:00005CF8                 db    0
.xdata$x:00005CF9                 db    0
.xdata$x:00005CFA                 db    0
.xdata$x:00005CFB                 db    0
.xdata$x:00005CFC                 db    0
.xdata$x:00005CFD                 db    0
.xdata$x:00005CFE                 db    0
.xdata$x:00005CFF                 db    0
.xdata$x:00005D00                 db    0
.xdata$x:00005D01                 db    0
.xdata$x:00005D02                 db    0
.xdata$x:00005D03                 db    0
.xdata$x:00005D04                 db    0
.xdata$x:00005D05                 db    0
.xdata$x:00005D06                 db    0
.xdata$x:00005D07                 db    0
.xdata$x:00005D08                 db    0
.xdata$x:00005D09                 db    0
.xdata$x:00005D0A                 db    0
.xdata$x:00005D0B                 db    0
.xdata$x:00005D0B _xdata$x        ends
.xdata$x:00005D0B
.xdata$x:00005D0C ; ===========================================================================
.xdata$x:00005D0C
.xdata$x:00005D0C ; Segment type: Pure data
.xdata$x:00005D0C ; Segment permissions: Read
.xdata$x:00005D0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005D0C                 assume cs:_xdata$x
.xdata$x:00005D0C                 ;org 5D0Ch
.xdata$x:00005D0C ; COMDAT (pick associative to section at 2BD0)
.xdata$x:00005D0C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005D0C                                         ; DATA XREF: .xdata$x:00005D1Co
.xdata$x:00005D0D                 db 0FFh
.xdata$x:00005D0E                 db 0FFh
.xdata$x:00005D0F                 db 0FFh
.xdata$x:00005D10                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00005D14 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005D14                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005D15                 db    5
.xdata$x:00005D16                 db  93h ; 
.xdata$x:00005D17                 db  19h
.xdata$x:00005D18                 db    1
.xdata$x:00005D19                 db    0
.xdata$x:00005D1A                 db    0
.xdata$x:00005D1B                 db    0
.xdata$x:00005D1C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00005D20                 db    0
.xdata$x:00005D21                 db    0
.xdata$x:00005D22                 db    0
.xdata$x:00005D23                 db    0
.xdata$x:00005D24                 db    0
.xdata$x:00005D25                 db    0
.xdata$x:00005D26                 db    0
.xdata$x:00005D27                 db    0
.xdata$x:00005D28                 db    0
.xdata$x:00005D29                 db    0
.xdata$x:00005D2A                 db    0
.xdata$x:00005D2B                 db    0
.xdata$x:00005D2C                 db    0
.xdata$x:00005D2D                 db    0
.xdata$x:00005D2E                 db    0
.xdata$x:00005D2F                 db    0
.xdata$x:00005D30                 db    0
.xdata$x:00005D31                 db    0
.xdata$x:00005D32                 db    0
.xdata$x:00005D33                 db    0
.xdata$x:00005D34                 db    0
.xdata$x:00005D35                 db    0
.xdata$x:00005D36                 db    0
.xdata$x:00005D37                 db    0
.xdata$x:00005D37 _xdata$x        ends
.xdata$x:00005D37
.xdata$x:00005D38 ; ===========================================================================
.xdata$x:00005D38
.xdata$x:00005D38 ; Segment type: Pure data
.xdata$x:00005D38 ; Segment permissions: Read
.xdata$x:00005D38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005D38                 assume cs:_xdata$x
.xdata$x:00005D38                 ;org 5D38h
.xdata$x:00005D38 ; COMDAT (pick associative to section at 2410)
.xdata$x:00005D38 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00005D38                                         ; DATA XREF: .xdata$x:00005D48o
.xdata$x:00005D39                 db 0FFh
.xdata$x:00005D3A                 db 0FFh
.xdata$x:00005D3B                 db 0FFh
.xdata$x:00005D3C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:00005D40 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00005D40                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:00005D41                 db    5
.xdata$x:00005D42                 db  93h ; 
.xdata$x:00005D43                 db  19h
.xdata$x:00005D44                 db    1
.xdata$x:00005D45                 db    0
.xdata$x:00005D46                 db    0
.xdata$x:00005D47                 db    0
.xdata$x:00005D48                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:00005D4C                 db    0
.xdata$x:00005D4D                 db    0
.xdata$x:00005D4E                 db    0
.xdata$x:00005D4F                 db    0
.xdata$x:00005D50                 db    0
.xdata$x:00005D51                 db    0
.xdata$x:00005D52                 db    0
.xdata$x:00005D53                 db    0
.xdata$x:00005D54                 db    0
.xdata$x:00005D55                 db    0
.xdata$x:00005D56                 db    0
.xdata$x:00005D57                 db    0
.xdata$x:00005D58                 db    0
.xdata$x:00005D59                 db    0
.xdata$x:00005D5A                 db    0
.xdata$x:00005D5B                 db    0
.xdata$x:00005D5C                 db    0
.xdata$x:00005D5D                 db    0
.xdata$x:00005D5E                 db    0
.xdata$x:00005D5F                 db    0
.xdata$x:00005D60                 db    0
.xdata$x:00005D61                 db    0
.xdata$x:00005D62                 db    0
.xdata$x:00005D63                 db    0
.xdata$x:00005D63 _xdata$x        ends
.xdata$x:00005D63
.xdata$x:00005D64 ; ===========================================================================
.xdata$x:00005D64
.xdata$x:00005D64 ; Segment type: Pure data
.xdata$x:00005D64 ; Segment permissions: Read
.xdata$x:00005D64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005D64                 assume cs:_xdata$x
.xdata$x:00005D64                 ;org 5D64h
.xdata$x:00005D64 ; COMDAT (pick associative to section at 24C0)
.xdata$x:00005D64 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:00005D64                                         ; DATA XREF: .xdata$x:00005D74o
.xdata$x:00005D65                 db 0FFh
.xdata$x:00005D66                 db 0FFh
.xdata$x:00005D67                 db 0FFh
.xdata$x:00005D68                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00005D6C __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00005D6C                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00005D6D                 db    5
.xdata$x:00005D6E                 db  93h ; 
.xdata$x:00005D6F                 db  19h
.xdata$x:00005D70                 db    1
.xdata$x:00005D71                 db    0
.xdata$x:00005D72                 db    0
.xdata$x:00005D73                 db    0
.xdata$x:00005D74                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:00005D78                 db    0
.xdata$x:00005D79                 db    0
.xdata$x:00005D7A                 db    0
.xdata$x:00005D7B                 db    0
.xdata$x:00005D7C                 db    0
.xdata$x:00005D7D                 db    0
.xdata$x:00005D7E                 db    0
.xdata$x:00005D7F                 db    0
.xdata$x:00005D80                 db    0
.xdata$x:00005D81                 db    0
.xdata$x:00005D82                 db    0
.xdata$x:00005D83                 db    0
.xdata$x:00005D84                 db    0
.xdata$x:00005D85                 db    0
.xdata$x:00005D86                 db    0
.xdata$x:00005D87                 db    0
.xdata$x:00005D88                 db    0
.xdata$x:00005D89                 db    0
.xdata$x:00005D8A                 db    0
.xdata$x:00005D8B                 db    0
.xdata$x:00005D8C                 db    0
.xdata$x:00005D8D                 db    0
.xdata$x:00005D8E                 db    0
.xdata$x:00005D8F                 db    0
.xdata$x:00005D8F _xdata$x        ends
.xdata$x:00005D8F
.xdata$x:00005D90 ; ===========================================================================
.xdata$x:00005D90
.xdata$x:00005D90 ; Segment type: Pure data
.xdata$x:00005D90 ; Segment permissions: Read
.xdata$x:00005D90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005D90                 assume cs:_xdata$x
.xdata$x:00005D90                 ;org 5D90h
.xdata$x:00005D90 ; COMDAT (pick associative to section at 2F74)
.xdata$x:00005D90 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00005D90                                         ; DATA XREF: .xdata$x:00005DA0o
.xdata$x:00005D91                 db 0FFh
.xdata$x:00005D92                 db 0FFh
.xdata$x:00005D93                 db 0FFh
.xdata$x:00005D94                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00005D98 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00005D98                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00005D99                 db    5
.xdata$x:00005D9A                 db  93h ; 
.xdata$x:00005D9B                 db  19h
.xdata$x:00005D9C                 db    1
.xdata$x:00005D9D                 db    0
.xdata$x:00005D9E                 db    0
.xdata$x:00005D9F                 db    0
.xdata$x:00005DA0                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00005DA4                 db    0
.xdata$x:00005DA5                 db    0
.xdata$x:00005DA6                 db    0
.xdata$x:00005DA7                 db    0
.xdata$x:00005DA8                 db    0
.xdata$x:00005DA9                 db    0
.xdata$x:00005DAA                 db    0
.xdata$x:00005DAB                 db    0
.xdata$x:00005DAC                 db    0
.xdata$x:00005DAD                 db    0
.xdata$x:00005DAE                 db    0
.xdata$x:00005DAF                 db    0
.xdata$x:00005DB0                 db    0
.xdata$x:00005DB1                 db    0
.xdata$x:00005DB2                 db    0
.xdata$x:00005DB3                 db    0
.xdata$x:00005DB4                 db    0
.xdata$x:00005DB5                 db    0
.xdata$x:00005DB6                 db    0
.xdata$x:00005DB7                 db    0
.xdata$x:00005DB8                 db    0
.xdata$x:00005DB9                 db    0
.xdata$x:00005DBA                 db    0
.xdata$x:00005DBB                 db    0
.xdata$x:00005DBB _xdata$x        ends
.xdata$x:00005DBB
.xdata$x:00005DBC ; ===========================================================================
.xdata$x:00005DBC
.xdata$x:00005DBC ; Segment type: Pure data
.xdata$x:00005DBC ; Segment permissions: Read
.xdata$x:00005DBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005DBC                 assume cs:_xdata$x
.xdata$x:00005DBC                 ;org 5DBCh
.xdata$x:00005DBC ; COMDAT (pick associative to section at 3A20)
.xdata$x:00005DBC __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00005DBC                                         ; DATA XREF: .xdata$x:00005E44o
.xdata$x:00005DBD                 db    0
.xdata$x:00005DBE                 db    0
.xdata$x:00005DBF                 db    0
.xdata$x:00005DC0                 db    0
.xdata$x:00005DC1                 db    0
.xdata$x:00005DC2                 db    0
.xdata$x:00005DC3                 db    0
.xdata$x:00005DC4                 db    0
.xdata$x:00005DC5                 db    0
.xdata$x:00005DC6                 db    0
.xdata$x:00005DC7                 db    0
.xdata$x:00005DC8                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00005DCC __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00005DCC                                         ; DATA XREF: .xdata$x:00005E30o
.xdata$x:00005DCD                 db    0
.xdata$x:00005DCE                 db    0
.xdata$x:00005DCF                 db    0
.xdata$x:00005DD0                 db    0
.xdata$x:00005DD1                 db    0
.xdata$x:00005DD2                 db    0
.xdata$x:00005DD3                 db    0
.xdata$x:00005DD4                 db    0
.xdata$x:00005DD5                 db    0
.xdata$x:00005DD6                 db    0
.xdata$x:00005DD7                 db    0
.xdata$x:00005DD8                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00005DDC __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00005DDC                                         ; DATA XREF: .xdata$x:00005E04o
.xdata$x:00005DDD                 db 0FFh
.xdata$x:00005DDE                 db 0FFh
.xdata$x:00005DDF                 db 0FFh
.xdata$x:00005DE0                 db    0
.xdata$x:00005DE1                 db    0
.xdata$x:00005DE2                 db    0
.xdata$x:00005DE3                 db    0
.xdata$x:00005DE4                 db 0FFh
.xdata$x:00005DE5                 db 0FFh
.xdata$x:00005DE6                 db 0FFh
.xdata$x:00005DE7                 db 0FFh
.xdata$x:00005DE8                 db    0
.xdata$x:00005DE9                 db    0
.xdata$x:00005DEA                 db    0
.xdata$x:00005DEB                 db    0
.xdata$x:00005DEC                 db    1
.xdata$x:00005DED                 db    0
.xdata$x:00005DEE                 db    0
.xdata$x:00005DEF                 db    0
.xdata$x:00005DF0                 db    0
.xdata$x:00005DF1                 db    0
.xdata$x:00005DF2                 db    0
.xdata$x:00005DF3                 db    0
.xdata$x:00005DF4                 db    1
.xdata$x:00005DF5                 db    0
.xdata$x:00005DF6                 db    0
.xdata$x:00005DF7                 db    0
.xdata$x:00005DF8                 db    0
.xdata$x:00005DF9                 db    0
.xdata$x:00005DFA                 db    0
.xdata$x:00005DFB                 db    0
.xdata$x:00005DFC __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00005DFC                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00005DFD                 db    5
.xdata$x:00005DFE                 db  93h ; 
.xdata$x:00005DFF                 db  19h
.xdata$x:00005E00                 db    4
.xdata$x:00005E01                 db    0
.xdata$x:00005E02                 db    0
.xdata$x:00005E03                 db    0
.xdata$x:00005E04                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00005E08                 db    2
.xdata$x:00005E09                 db    0
.xdata$x:00005E0A                 db    0
.xdata$x:00005E0B                 db    0
.xdata$x:00005E0C                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00005E10                 align 20h
.xdata$x:00005E20 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00005E20                                         ; DATA XREF: .xdata$x:00005E0Co
.xdata$x:00005E21                 db    0
.xdata$x:00005E22                 db    0
.xdata$x:00005E23                 db    0
.xdata$x:00005E24                 db    2
.xdata$x:00005E25                 db    0
.xdata$x:00005E26                 db    0
.xdata$x:00005E27                 db    0
.xdata$x:00005E28                 db    3
.xdata$x:00005E29                 db    0
.xdata$x:00005E2A                 db    0
.xdata$x:00005E2B                 db    0
.xdata$x:00005E2C                 db    1
.xdata$x:00005E2D                 db    0
.xdata$x:00005E2E                 db    0
.xdata$x:00005E2F                 db    0
.xdata$x:00005E30                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00005E34                 db    0
.xdata$x:00005E35                 db    0
.xdata$x:00005E36                 db    0
.xdata$x:00005E37                 db    0
.xdata$x:00005E38                 db    0
.xdata$x:00005E39                 db    0
.xdata$x:00005E3A                 db    0
.xdata$x:00005E3B                 db    0
.xdata$x:00005E3C                 db    3
.xdata$x:00005E3D                 db    0
.xdata$x:00005E3E                 db    0
.xdata$x:00005E3F                 db    0
.xdata$x:00005E40                 db    1
.xdata$x:00005E41                 db    0
.xdata$x:00005E42                 db    0
.xdata$x:00005E43                 db    0
.xdata$x:00005E44                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00005E44 _xdata$x        ends
.xdata$x:00005E44
.xdata$x:00005E48 ; ===========================================================================
.xdata$x:00005E48
.xdata$x:00005E48 ; Segment type: Pure data
.xdata$x:00005E48 ; Segment permissions: Read
.xdata$x:00005E48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005E48                 assume cs:_xdata$x
.xdata$x:00005E48                 ;org 5E48h
.xdata$x:00005E48 ; COMDAT (pick associative to section at 2794)
.xdata$x:00005E48 __unwindtable$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z db 0FFh
.xdata$x:00005E48                                         ; DATA XREF: .xdata$x:00005E60o
.xdata$x:00005E49                 db 0FFh
.xdata$x:00005E4A                 db 0FFh
.xdata$x:00005E4B                 db 0FFh
.xdata$x:00005E4C                 dd offset __unwindfunclet$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z$0
.xdata$x:00005E50                 db    0
.xdata$x:00005E51                 db    0
.xdata$x:00005E52                 db    0
.xdata$x:00005E53                 db    0
.xdata$x:00005E54                 dd offset __unwindfunclet$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z$1
.xdata$x:00005E58 __ehfuncinfo$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z db  22h ; "
.xdata$x:00005E58                                         ; DATA XREF: __ehhandler$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z+11o
.xdata$x:00005E59                 db    5
.xdata$x:00005E5A                 db  93h ; 
.xdata$x:00005E5B                 db  19h
.xdata$x:00005E5C                 db    2
.xdata$x:00005E5D                 db    0
.xdata$x:00005E5E                 db    0
.xdata$x:00005E5F                 db    0
.xdata$x:00005E60                 dd offset __unwindtable$??0TaskLstFnStatus@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPAX@Z
.xdata$x:00005E64                 db    0
.xdata$x:00005E65                 db    0
.xdata$x:00005E66                 db    0
.xdata$x:00005E67                 db    0
.xdata$x:00005E68                 db    0
.xdata$x:00005E69                 db    0
.xdata$x:00005E6A                 db    0
.xdata$x:00005E6B                 db    0
.xdata$x:00005E6C                 db    0
.xdata$x:00005E6D                 db    0
.xdata$x:00005E6E                 db    0
.xdata$x:00005E6F                 db    0
.xdata$x:00005E70                 db    0
.xdata$x:00005E71                 db    0
.xdata$x:00005E72                 db    0
.xdata$x:00005E73                 db    0
.xdata$x:00005E74                 db    0
.xdata$x:00005E75                 db    0
.xdata$x:00005E76                 db    0
.xdata$x:00005E77                 db    0
.xdata$x:00005E78                 db    0
.xdata$x:00005E79                 db    0
.xdata$x:00005E7A                 db    0
.xdata$x:00005E7B                 db    0
.xdata$x:00005E7B _xdata$x        ends
.xdata$x:00005E7B
.xdata$x:00005E7C ; ===========================================================================
.xdata$x:00005E7C
.xdata$x:00005E7C ; Segment type: Pure data
.xdata$x:00005E7C ; Segment permissions: Read
.xdata$x:00005E7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005E7C                 assume cs:_xdata$x
.xdata$x:00005E7C                 ;org 5E7Ch
.xdata$x:00005E7C ; COMDAT (pick associative to section at 3150)
.xdata$x:00005E7C __unwindtable$??1TaskLstFnStatus@@QAE@XZ db 0FFh
.xdata$x:00005E7C                                         ; DATA XREF: .xdata$x:00005E8Co
.xdata$x:00005E7D                 db 0FFh
.xdata$x:00005E7E                 db 0FFh
.xdata$x:00005E7F                 db 0FFh
.xdata$x:00005E80                 dd offset __unwindfunclet$??1TaskLstFnStatus@@QAE@XZ$0
.xdata$x:00005E84 __ehfuncinfo$??1TaskLstFnStatus@@QAE@XZ db  22h ; "
.xdata$x:00005E84                                         ; DATA XREF: __ehhandler$??1TaskLstFnStatus@@QAE@XZ+11o
.xdata$x:00005E85                 db    5
.xdata$x:00005E86                 db  93h ; 
.xdata$x:00005E87                 db  19h
.xdata$x:00005E88                 db    1
.xdata$x:00005E89                 db    0
.xdata$x:00005E8A                 db    0
.xdata$x:00005E8B                 db    0
.xdata$x:00005E8C                 dd offset __unwindtable$??1TaskLstFnStatus@@QAE@XZ
.xdata$x:00005E90                 db    0
.xdata$x:00005E91                 db    0
.xdata$x:00005E92                 db    0
.xdata$x:00005E93                 db    0
.xdata$x:00005E94                 db    0
.xdata$x:00005E95                 db    0
.xdata$x:00005E96                 db    0
.xdata$x:00005E97                 db    0
.xdata$x:00005E98                 db    0
.xdata$x:00005E99                 db    0
.xdata$x:00005E9A                 db    0
.xdata$x:00005E9B                 db    0
.xdata$x:00005E9C                 db    0
.xdata$x:00005E9D                 db    0
.xdata$x:00005E9E                 db    0
.xdata$x:00005E9F                 db    0
.xdata$x:00005EA0                 db    0
.xdata$x:00005EA1                 db    0
.xdata$x:00005EA2                 db    0
.xdata$x:00005EA3                 db    0
.xdata$x:00005EA4                 db    0
.xdata$x:00005EA5                 db    0
.xdata$x:00005EA6                 db    0
.xdata$x:00005EA7                 db    0
.xdata$x:00005EA7 _xdata$x        ends
.xdata$x:00005EA7
.xdata$x:00005EA8 ; ===========================================================================
.xdata$x:00005EA8
.xdata$x:00005EA8 ; Segment type: Pure data
.xdata$x:00005EA8 ; Segment permissions: Read
.xdata$x:00005EA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005EA8                 assume cs:_xdata$x
.xdata$x:00005EA8                 ;org 5EA8h
.xdata$x:00005EA8 ; COMDAT (pick associative to section at 21F4)
.xdata$x:00005EA8 __unwindtable$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005EA8                                         ; DATA XREF: .xdata$x:00005EB8o
.xdata$x:00005EA9                 db 0FFh
.xdata$x:00005EAA                 db 0FFh
.xdata$x:00005EAB                 db 0FFh
.xdata$x:00005EAC                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0
.xdata$x:00005EB0 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005EB0                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005EB1                 db    5
.xdata$x:00005EB2                 db  93h ; 
.xdata$x:00005EB3                 db  19h
.xdata$x:00005EB4                 db    1
.xdata$x:00005EB5                 db    0
.xdata$x:00005EB6                 db    0
.xdata$x:00005EB7                 db    0
.xdata$x:00005EB8                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.xdata$x:00005EBC                 db    0
.xdata$x:00005EBD                 db    0
.xdata$x:00005EBE                 db    0
.xdata$x:00005EBF                 db    0
.xdata$x:00005EC0                 db    0
.xdata$x:00005EC1                 db    0
.xdata$x:00005EC2                 db    0
.xdata$x:00005EC3                 db    0
.xdata$x:00005EC4                 db    0
.xdata$x:00005EC5                 db    0
.xdata$x:00005EC6                 db    0
.xdata$x:00005EC7                 db    0
.xdata$x:00005EC8                 db    0
.xdata$x:00005EC9                 db    0
.xdata$x:00005ECA                 db    0
.xdata$x:00005ECB                 db    0
.xdata$x:00005ECC                 db    0
.xdata$x:00005ECD                 db    0
.xdata$x:00005ECE                 db    0
.xdata$x:00005ECF                 db    0
.xdata$x:00005ED0                 db    0
.xdata$x:00005ED1                 db    0
.xdata$x:00005ED2                 db    0
.xdata$x:00005ED3                 db    0
.xdata$x:00005ED3 _xdata$x        ends
.xdata$x:00005ED3
.xdata$x:00005ED4 ; ===========================================================================
.xdata$x:00005ED4
.xdata$x:00005ED4 ; Segment type: Pure data
.xdata$x:00005ED4 ; Segment permissions: Read
.xdata$x:00005ED4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005ED4                 assume cs:_xdata$x
.xdata$x:00005ED4                 ;org 5ED4h
.xdata$x:00005ED4 ; COMDAT (pick associative to section at 2E88)
.xdata$x:00005ED4 __unwindtable$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005ED4                                         ; DATA XREF: .xdata$x:00005EE4o
.xdata$x:00005ED5                 db 0FFh
.xdata$x:00005ED6                 db 0FFh
.xdata$x:00005ED7                 db 0FFh
.xdata$x:00005ED8                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0
.xdata$x:00005EDC __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005EDC                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005EDD                 db    5
.xdata$x:00005EDE                 db  93h ; 
.xdata$x:00005EDF                 db  19h
.xdata$x:00005EE0                 db    1
.xdata$x:00005EE1                 db    0
.xdata$x:00005EE2                 db    0
.xdata$x:00005EE3                 db    0
.xdata$x:00005EE4                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.xdata$x:00005EE8                 align 20h
.xdata$x:00005EE8 _xdata$x        ends
.xdata$x:00005EE8
.xdata$x:00005F00 ; ===========================================================================
.xdata$x:00005F00
.xdata$x:00005F00 ; Segment type: Pure data
.xdata$x:00005F00 ; Segment permissions: Read
.xdata$x:00005F00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005F00                 assume cs:_xdata$x
.xdata$x:00005F00                 ;org 5F00h
.xdata$x:00005F00 ; COMDAT (pick associative to section at 20E8)
.xdata$x:00005F00 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z db 0FFh
.xdata$x:00005F00                                         ; DATA XREF: .xdata$x:00005F10o
.xdata$x:00005F01                 db 0FFh
.xdata$x:00005F02                 db 0FFh
.xdata$x:00005F03                 db 0FFh
.xdata$x:00005F04                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z$0
.xdata$x:00005F08 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z db  22h ; "
.xdata$x:00005F08                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z+11o
.xdata$x:00005F09                 db    5
.xdata$x:00005F0A                 db  93h ; 
.xdata$x:00005F0B                 db  19h
.xdata$x:00005F0C                 db    1
.xdata$x:00005F0D                 db    0
.xdata$x:00005F0E                 db    0
.xdata$x:00005F0F                 db    0
.xdata$x:00005F10                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@ABV?$allocator@UTaskLstFnStatus@@@1@@Z
.xdata$x:00005F14                 db    0
.xdata$x:00005F15                 db    0
.xdata$x:00005F16                 db    0
.xdata$x:00005F17                 db    0
.xdata$x:00005F18                 db    0
.xdata$x:00005F19                 db    0
.xdata$x:00005F1A                 db    0
.xdata$x:00005F1B                 db    0
.xdata$x:00005F1C                 db    0
.xdata$x:00005F1D                 db    0
.xdata$x:00005F1E                 db    0
.xdata$x:00005F1F                 db    0
.xdata$x:00005F20                 db    0
.xdata$x:00005F21                 db    0
.xdata$x:00005F22                 db    0
.xdata$x:00005F23                 db    0
.xdata$x:00005F24                 db    0
.xdata$x:00005F25                 db    0
.xdata$x:00005F26                 db    0
.xdata$x:00005F27                 db    0
.xdata$x:00005F28                 db    0
.xdata$x:00005F29                 db    0
.xdata$x:00005F2A                 db    0
.xdata$x:00005F2B                 db    0
.xdata$x:00005F2B _xdata$x        ends
.xdata$x:00005F2B
.xdata$x:00005F2C ; ===========================================================================
.xdata$x:00005F2C
.xdata$x:00005F2C ; Segment type: Pure data
.xdata$x:00005F2C ; Segment permissions: Read
.xdata$x:00005F2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005F2C                 assume cs:_xdata$x
.xdata$x:00005F2C                 ;org 5F2Ch
.xdata$x:00005F2C ; COMDAT (pick associative to section at 2DA0)
.xdata$x:00005F2C __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005F2C                                         ; DATA XREF: .xdata$x:00005F3Co
.xdata$x:00005F2D                 db 0FFh
.xdata$x:00005F2E                 db 0FFh
.xdata$x:00005F2F                 db 0FFh
.xdata$x:00005F30                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00005F34 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005F34                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005F35                 db    5
.xdata$x:00005F36                 db  93h ; 
.xdata$x:00005F37                 db  19h
.xdata$x:00005F38                 db    1
.xdata$x:00005F39                 db    0
.xdata$x:00005F3A                 db    0
.xdata$x:00005F3B                 db    0
.xdata$x:00005F3C                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00005F40                 db    0
.xdata$x:00005F41                 db    0
.xdata$x:00005F42                 db    0
.xdata$x:00005F43                 db    0
.xdata$x:00005F44                 db    0
.xdata$x:00005F45                 db    0
.xdata$x:00005F46                 db    0
.xdata$x:00005F47                 db    0
.xdata$x:00005F48                 db    0
.xdata$x:00005F49                 db    0
.xdata$x:00005F4A                 db    0
.xdata$x:00005F4B                 db    0
.xdata$x:00005F4C                 db    0
.xdata$x:00005F4D                 db    0
.xdata$x:00005F4E                 db    0
.xdata$x:00005F4F                 db    0
.xdata$x:00005F50                 db    0
.xdata$x:00005F51                 db    0
.xdata$x:00005F52                 db    0
.xdata$x:00005F53                 db    0
.xdata$x:00005F54                 db    0
.xdata$x:00005F55                 db    0
.xdata$x:00005F56                 db    0
.xdata$x:00005F57                 db    0
.xdata$x:00005F57 _xdata$x        ends
.xdata$x:00005F57
.xdata$x:00005F58 ; ===========================================================================
.xdata$x:00005F58
.xdata$x:00005F58 ; Segment type: Pure data
.xdata$x:00005F58 ; Segment permissions: Read
.xdata$x:00005F58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005F58                 assume cs:_xdata$x
.xdata$x:00005F58                 ;org 5F58h
.xdata$x:00005F58 ; COMDAT (pick associative to section at 267C)
.xdata$x:00005F58 __unwindtable$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005F58                                         ; DATA XREF: .xdata$x:00005F68o
.xdata$x:00005F59                 db 0FFh
.xdata$x:00005F5A                 db 0FFh
.xdata$x:00005F5B                 db 0FFh
.xdata$x:00005F5C                 dd offset __unwindfunclet$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0
.xdata$x:00005F60 __ehfuncinfo$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005F60                                         ; DATA XREF: __ehhandler$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005F61                 db    5
.xdata$x:00005F62                 db  93h ; 
.xdata$x:00005F63                 db  19h
.xdata$x:00005F64                 db    1
.xdata$x:00005F65                 db    0
.xdata$x:00005F66                 db    0
.xdata$x:00005F67                 db    0
.xdata$x:00005F68                 dd offset __unwindtable$??0?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.xdata$x:00005F6C                 db    0
.xdata$x:00005F6D                 db    0
.xdata$x:00005F6E                 db    0
.xdata$x:00005F6F                 db    0
.xdata$x:00005F70                 db    0
.xdata$x:00005F71                 db    0
.xdata$x:00005F72                 db    0
.xdata$x:00005F73                 db    0
.xdata$x:00005F74                 db    0
.xdata$x:00005F75                 db    0
.xdata$x:00005F76                 db    0
.xdata$x:00005F77                 db    0
.xdata$x:00005F78                 db    0
.xdata$x:00005F79                 db    0
.xdata$x:00005F7A                 db    0
.xdata$x:00005F7B                 db    0
.xdata$x:00005F7C                 db    0
.xdata$x:00005F7D                 db    0
.xdata$x:00005F7E                 db    0
.xdata$x:00005F7F                 db    0
.xdata$x:00005F80                 db    0
.xdata$x:00005F81                 db    0
.xdata$x:00005F82                 db    0
.xdata$x:00005F83                 db    0
.xdata$x:00005F83 _xdata$x        ends
.xdata$x:00005F83
.xdata$x:00005F84 ; ===========================================================================
.xdata$x:00005F84
.xdata$x:00005F84 ; Segment type: Pure data
.xdata$x:00005F84 ; Segment permissions: Read
.xdata$x:00005F84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005F84                 assume cs:_xdata$x
.xdata$x:00005F84                 ;org 5F84h
.xdata$x:00005F84 ; COMDAT (pick associative to section at 3068)
.xdata$x:00005F84 __unwindtable$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005F84                                         ; DATA XREF: .xdata$x:00005F94o
.xdata$x:00005F85                 db 0FFh
.xdata$x:00005F86                 db 0FFh
.xdata$x:00005F87                 db 0FFh
.xdata$x:00005F88                 dd offset __unwindfunclet$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ$0
.xdata$x:00005F8C __ehfuncinfo$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005F8C                                         ; DATA XREF: __ehhandler$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005F8D                 db    5
.xdata$x:00005F8E                 db  93h ; 
.xdata$x:00005F8F                 db  19h
.xdata$x:00005F90                 db    1
.xdata$x:00005F91                 db    0
.xdata$x:00005F92                 db    0
.xdata$x:00005F93                 db    0
.xdata$x:00005F94                 dd offset __unwindtable$??1?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAE@XZ
.xdata$x:00005F98                 db    0
.xdata$x:00005F99                 db    0
.xdata$x:00005F9A                 db    0
.xdata$x:00005F9B                 db    0
.xdata$x:00005F9C                 db    0
.xdata$x:00005F9D                 db    0
.xdata$x:00005F9E                 db    0
.xdata$x:00005F9F                 db    0
.xdata$x:00005FA0                 db    0
.xdata$x:00005FA1                 db    0
.xdata$x:00005FA2                 db    0
.xdata$x:00005FA3                 db    0
.xdata$x:00005FA4                 db    0
.xdata$x:00005FA5                 db    0
.xdata$x:00005FA6                 db    0
.xdata$x:00005FA7                 db    0
.xdata$x:00005FA8                 db    0
.xdata$x:00005FA9                 db    0
.xdata$x:00005FAA                 db    0
.xdata$x:00005FAB                 db    0
.xdata$x:00005FAC                 db    0
.xdata$x:00005FAD                 db    0
.xdata$x:00005FAE                 db    0
.xdata$x:00005FAF                 db    0
.xdata$x:00005FAF _xdata$x        ends
.xdata$x:00005FAF
.xdata$x:00005FB0 ; ===========================================================================
.xdata$x:00005FB0
.xdata$x:00005FB0 ; Segment type: Pure data
.xdata$x:00005FB0 ; Segment permissions: Read
.xdata$x:00005FB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005FB0                 assume cs:_xdata$x
.xdata$x:00005FB0                 ;org 5FB0h
.xdata$x:00005FB0 ; COMDAT (pick associative to section at 2720)
.xdata$x:00005FB0 __unwindtable$??0TaskListInfo@@QAE@XZ db 0FFh
.xdata$x:00005FB0                                         ; DATA XREF: .xdata$x:00005FC0o
.xdata$x:00005FB1                 db 0FFh
.xdata$x:00005FB2                 db 0FFh
.xdata$x:00005FB3                 db 0FFh
.xdata$x:00005FB4                 dd offset __unwindfunclet$??0TaskListInfo@@QAE@XZ$0
.xdata$x:00005FB8 __ehfuncinfo$??0TaskListInfo@@QAE@XZ db  22h ; "
.xdata$x:00005FB8                                         ; DATA XREF: __ehhandler$??0TaskListInfo@@QAE@XZ+11o
.xdata$x:00005FB9                 db    5
.xdata$x:00005FBA                 db  93h ; 
.xdata$x:00005FBB                 db  19h
.xdata$x:00005FBC                 db    1
.xdata$x:00005FBD                 db    0
.xdata$x:00005FBE                 db    0
.xdata$x:00005FBF                 db    0
.xdata$x:00005FC0                 dd offset __unwindtable$??0TaskListInfo@@QAE@XZ
.xdata$x:00005FC4                 db    0
.xdata$x:00005FC5                 db    0
.xdata$x:00005FC6                 db    0
.xdata$x:00005FC7                 db    0
.xdata$x:00005FC8                 db    0
.xdata$x:00005FC9                 db    0
.xdata$x:00005FCA                 db    0
.xdata$x:00005FCB                 db    0
.xdata$x:00005FCC                 db    0
.xdata$x:00005FCD                 db    0
.xdata$x:00005FCE                 db    0
.xdata$x:00005FCF                 db    0
.xdata$x:00005FD0                 db    0
.xdata$x:00005FD1                 db    0
.xdata$x:00005FD2                 db    0
.xdata$x:00005FD3                 db    0
.xdata$x:00005FD4                 db    0
.xdata$x:00005FD5                 db    0
.xdata$x:00005FD6                 db    0
.xdata$x:00005FD7                 db    0
.xdata$x:00005FD8                 db    0
.xdata$x:00005FD9                 db    0
.xdata$x:00005FDA                 db    0
.xdata$x:00005FDB                 db    0
.xdata$x:00005FDB _xdata$x        ends
.xdata$x:00005FDB
.xdata$x:00005FDC ; ===========================================================================
.xdata$x:00005FDC
.xdata$x:00005FDC ; Segment type: Pure data
.xdata$x:00005FDC ; Segment permissions: Read
.xdata$x:00005FDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005FDC                 assume cs:_xdata$x
.xdata$x:00005FDC                 ;org 5FDCh
.xdata$x:00005FDC ; COMDAT (pick associative to section at 30E0)
.xdata$x:00005FDC __unwindtable$??1TaskListInfo@@QAE@XZ db 0FFh
.xdata$x:00005FDC                                         ; DATA XREF: .xdata$x:00005FECo
.xdata$x:00005FDD                 db 0FFh
.xdata$x:00005FDE                 db 0FFh
.xdata$x:00005FDF                 db 0FFh
.xdata$x:00005FE0                 dd offset __unwindfunclet$??1TaskListInfo@@QAE@XZ$0
.xdata$x:00005FE4 __ehfuncinfo$??1TaskListInfo@@QAE@XZ db  22h ; "
.xdata$x:00005FE4                                         ; DATA XREF: __ehhandler$??1TaskListInfo@@QAE@XZ+11o
.xdata$x:00005FE5                 db    5
.xdata$x:00005FE6                 db  93h ; 
.xdata$x:00005FE7                 db  19h
.xdata$x:00005FE8                 db    1
.xdata$x:00005FE9                 db    0
.xdata$x:00005FEA                 db    0
.xdata$x:00005FEB                 db    0
.xdata$x:00005FEC                 dd offset __unwindtable$??1TaskListInfo@@QAE@XZ
.xdata$x:00005FF0                 db    0
.xdata$x:00005FF1                 db    0
.xdata$x:00005FF2                 db    0
.xdata$x:00005FF3                 db    0
.xdata$x:00005FF4                 db    0
.xdata$x:00005FF5                 db    0
.xdata$x:00005FF6                 db    0
.xdata$x:00005FF7                 db    0
.xdata$x:00005FF8                 db    0
.xdata$x:00005FF9                 db    0
.xdata$x:00005FFA                 db    0
.xdata$x:00005FFB                 db    0
.xdata$x:00005FFC                 db    0
.xdata$x:00005FFD                 db    0
.xdata$x:00005FFE                 db    0
.xdata$x:00005FFF                 db    0
.xdata$x:00006000                 db    0
.xdata$x:00006001                 db    0
.xdata$x:00006002                 db    0
.xdata$x:00006003                 db    0
.xdata$x:00006004                 db    0
.xdata$x:00006005                 db    0
.xdata$x:00006006                 db    0
.xdata$x:00006007                 db    0
.xdata$x:00006007 _xdata$x        ends
.xdata$x:00006007
.xdata$x:00006008 ; ===========================================================================
.xdata$x:00006008
.xdata$x:00006008 ; Segment type: Pure data
.xdata$x:00006008 ; Segment permissions: Read
.xdata$x:00006008 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006008                 assume cs:_xdata$x
.xdata$x:00006008                 ;org 6008h
.xdata$x:00006008 __unwindtable$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z db 0FFh
.xdata$x:00006008                                         ; DATA XREF: .xdata$x:00006080o
.xdata$x:00006009                 db 0FFh
.xdata$x:0000600A                 db 0FFh
.xdata$x:0000600B                 db 0FFh
.xdata$x:0000600C                 dd offset __unwindfunclet$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0
.xdata$x:00006010 __unwindtable$?add@VerticalFileSwitcherListView@@IAEHHH@Z db 0FFh
.xdata$x:00006010                                         ; DATA XREF: .xdata$x:00006038o
.xdata$x:00006011                 db 0FFh
.xdata$x:00006012                 db 0FFh
.xdata$x:00006013                 db 0FFh
.xdata$x:00006014                 dd offset __unwindfunclet$?add@VerticalFileSwitcherListView@@IAEHHH@Z$0
.xdata$x:00006018                 db    0
.xdata$x:00006019                 db    0
.xdata$x:0000601A                 db    0
.xdata$x:0000601B                 db    0
.xdata$x:0000601C                 dd offset __unwindfunclet$?add@VerticalFileSwitcherListView@@IAEHHH@Z$1
.xdata$x:00006020 __unwindtable$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z db 0FFh
.xdata$x:00006020                                         ; DATA XREF: .xdata$x:0000605Co
.xdata$x:00006021                 db 0FFh
.xdata$x:00006022                 db 0FFh
.xdata$x:00006023                 db 0FFh
.xdata$x:00006024                 dd offset __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$1
.xdata$x:00006028                 db    0
.xdata$x:00006029                 db    0
.xdata$x:0000602A                 db    0
.xdata$x:0000602B                 db    0
.xdata$x:0000602C                 dd offset __unwindfunclet$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z$0
.xdata$x:00006030 __ehfuncinfo$?add@VerticalFileSwitcherListView@@IAEHHH@Z db  22h ; "
.xdata$x:00006030                                         ; DATA XREF: __ehhandler$?add@VerticalFileSwitcherListView@@IAEHHH@Z+1Eo
.xdata$x:00006031                 db    5
.xdata$x:00006032                 db  93h ; 
.xdata$x:00006033                 db  19h
.xdata$x:00006034                 db    2
.xdata$x:00006035                 db    0
.xdata$x:00006036                 db    0
.xdata$x:00006037                 db    0
.xdata$x:00006038                 dd offset __unwindtable$?add@VerticalFileSwitcherListView@@IAEHHH@Z
.xdata$x:0000603C                 db    0
.xdata$x:0000603D                 db    0
.xdata$x:0000603E                 db    0
.xdata$x:0000603F                 db    0
.xdata$x:00006040                 db    0
.xdata$x:00006041                 db    0
.xdata$x:00006042                 db    0
.xdata$x:00006043                 db    0
.xdata$x:00006044                 db    0
.xdata$x:00006045                 db    0
.xdata$x:00006046                 db    0
.xdata$x:00006047                 db    0
.xdata$x:00006048                 db    0
.xdata$x:00006049                 db    0
.xdata$x:0000604A                 db    0
.xdata$x:0000604B                 db    0
.xdata$x:0000604C                 db    0
.xdata$x:0000604D                 db    0
.xdata$x:0000604E                 db    0
.xdata$x:0000604F                 db    0
.xdata$x:00006050                 db    0
.xdata$x:00006051                 db    0
.xdata$x:00006052                 db    0
.xdata$x:00006053                 db    0
.xdata$x:00006054 __ehfuncinfo$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z db  22h ; "
.xdata$x:00006054                                         ; DATA XREF: __ehhandler$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z+11o
.xdata$x:00006055                 db    5
.xdata$x:00006056                 db  93h ; 
.xdata$x:00006057                 db  19h
.xdata$x:00006058                 db    2
.xdata$x:00006059                 db    0
.xdata$x:0000605A                 db    0
.xdata$x:0000605B                 db    0
.xdata$x:0000605C                 dd offset __unwindtable$?getSelectedFiles@VerticalFileSwitcherListView@@QBE?AV?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@_N@Z
.xdata$x:00006060                 db    0
.xdata$x:00006061                 db    0
.xdata$x:00006062                 db    0
.xdata$x:00006063                 db    0
.xdata$x:00006064                 db    0
.xdata$x:00006065                 db    0
.xdata$x:00006066                 db    0
.xdata$x:00006067                 db    0
.xdata$x:00006068                 db    0
.xdata$x:00006069                 db    0
.xdata$x:0000606A                 db    0
.xdata$x:0000606B                 db    0
.xdata$x:0000606C                 db    0
.xdata$x:0000606D                 db    0
.xdata$x:0000606E                 db    0
.xdata$x:0000606F                 db    0
.xdata$x:00006070                 db    0
.xdata$x:00006071                 db    0
.xdata$x:00006072                 db    0
.xdata$x:00006073                 db    0
.xdata$x:00006074                 db    0
.xdata$x:00006075                 db    0
.xdata$x:00006076                 db    0
.xdata$x:00006077                 db    0
.xdata$x:00006078 __ehfuncinfo$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z db  22h ; "
.xdata$x:00006078                                         ; DATA XREF: __ehhandler$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z+11o
.xdata$x:00006079                 db    5
.xdata$x:0000607A                 db  93h ; 
.xdata$x:0000607B                 db  19h
.xdata$x:0000607C                 db    1
.xdata$x:0000607D                 db    0
.xdata$x:0000607E                 db    0
.xdata$x:0000607F                 db    0
.xdata$x:00006080                 dd offset __unwindtable$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.xdata$x:00006084                 db    0
.xdata$x:00006085                 db    0
.xdata$x:00006086                 db    0
.xdata$x:00006087                 db    0
.xdata$x:00006088                 db    0
.xdata$x:00006089                 db    0
.xdata$x:0000608A                 db    0
.xdata$x:0000608B                 db    0
.xdata$x:0000608C                 db    0
.xdata$x:0000608D                 db    0
.xdata$x:0000608E                 db    0
.xdata$x:0000608F                 db    0
.xdata$x:00006090                 db    0
.xdata$x:00006091                 db    0
.xdata$x:00006092                 db    0
.xdata$x:00006093                 db    0
.xdata$x:00006094                 db    0
.xdata$x:00006095                 db    0
.xdata$x:00006096                 db    0
.xdata$x:00006097                 db    0
.xdata$x:00006098                 db    0
.xdata$x:00006099                 db    0
.xdata$x:0000609A                 db    0
.xdata$x:0000609B                 db    0
.xdata$x:0000609C __ehfuncinfo$?initList@VerticalFileSwitcherListView@@QAEXXZ db  22h ; "
.xdata$x:0000609C                                         ; DATA XREF: __ehhandler$?initList@VerticalFileSwitcherListView@@QAEXXZ+1Eo
.xdata$x:0000609D                 db    5
.xdata$x:0000609E                 db  93h ; 
.xdata$x:0000609F                 db  19h
.xdata$x:000060A0                 db    6
.xdata$x:000060A1                 db    0
.xdata$x:000060A2                 db    0
.xdata$x:000060A3                 db    0
.xdata$x:000060A4                 dd offset __unwindtable$?initList@VerticalFileSwitcherListView@@QAEXXZ
.xdata$x:000060A8                 align 20h
.xdata$x:000060C0 __unwindtable$?initList@VerticalFileSwitcherListView@@QAEXXZ db 0FFh
.xdata$x:000060C0                                         ; DATA XREF: .xdata$x:000060A4o
.xdata$x:000060C1                 db 0FFh
.xdata$x:000060C2                 db 0FFh
.xdata$x:000060C3                 db 0FFh
.xdata$x:000060C4                 dd offset __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$0
.xdata$x:000060C8                 db    0
.xdata$x:000060C9                 db    0
.xdata$x:000060CA                 db    0
.xdata$x:000060CB                 db    0
.xdata$x:000060CC                 dd offset __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$1
.xdata$x:000060D0                 db    0
.xdata$x:000060D1                 db    0
.xdata$x:000060D2                 db    0
.xdata$x:000060D3                 db    0
.xdata$x:000060D4                 dd offset __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$2
.xdata$x:000060D8                 db    2
.xdata$x:000060D9                 db    0
.xdata$x:000060DA                 db    0
.xdata$x:000060DB                 db    0
.xdata$x:000060DC                 dd offset __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$3
.xdata$x:000060E0                 db    2
.xdata$x:000060E1                 db    0
.xdata$x:000060E2                 db    0
.xdata$x:000060E3                 db    0
.xdata$x:000060E4                 dd offset __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$4
.xdata$x:000060E8                 db    4
.xdata$x:000060E9                 db    0
.xdata$x:000060EA                 db    0
.xdata$x:000060EB                 db    0
.xdata$x:000060EC                 dd offset __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$5
.xdata$x:000060EC _xdata$x        ends
.xdata$x:000060EC
.xdata$x:000060F0 ; ===========================================================================
.xdata$x:000060F0
.xdata$x:000060F0 ; Segment type: Pure data
.xdata$x:000060F0 ; Segment permissions: Read
.xdata$x:000060F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000060F0                 assume cs:_xdata$x
.xdata$x:000060F0                 ;org 60F0h
.xdata$x:000060F0 ; COMDAT (pick associative to section at 2164)
.xdata$x:000060F0 __unwindtable$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000060F0                                         ; DATA XREF: .xdata$x:00006100o
.xdata$x:000060F1                 db 0FFh
.xdata$x:000060F2                 db 0FFh
.xdata$x:000060F3                 db 0FFh
.xdata$x:000060F4                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:000060F8 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000060F8                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:000060F9                 db    5
.xdata$x:000060FA                 db  93h ; 
.xdata$x:000060FB                 db  19h
.xdata$x:000060FC                 db    1
.xdata$x:000060FD                 db    0
.xdata$x:000060FE                 db    0
.xdata$x:000060FF                 db    0
.xdata$x:00006100                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:00006104                 db    0
.xdata$x:00006105                 db    0
.xdata$x:00006106                 db    0
.xdata$x:00006107                 db    0
.xdata$x:00006108                 db    0
.xdata$x:00006109                 db    0
.xdata$x:0000610A                 db    0
.xdata$x:0000610B                 db    0
.xdata$x:0000610C                 db    0
.xdata$x:0000610D                 db    0
.xdata$x:0000610E                 db    0
.xdata$x:0000610F                 db    0
.xdata$x:00006110                 db    0
.xdata$x:00006111                 db    0
.xdata$x:00006112                 db    0
.xdata$x:00006113                 db    0
.xdata$x:00006114                 db    0
.xdata$x:00006115                 db    0
.xdata$x:00006116                 db    0
.xdata$x:00006117                 db    0
.xdata$x:00006118                 db    0
.xdata$x:00006119                 db    0
.xdata$x:0000611A                 db    0
.xdata$x:0000611B                 db    0
.xdata$x:0000611B _xdata$x        ends
.xdata$x:0000611B
.xdata$x:0000611C ; ===========================================================================
.xdata$x:0000611C
.xdata$x:0000611C ; Segment type: Pure data
.xdata$x:0000611C ; Segment permissions: Read
.xdata$x:0000611C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000611C                 assume cs:_xdata$x
.xdata$x:0000611C                 ;org 611Ch
.xdata$x:0000611C ; COMDAT (pick associative to section at 2E18)
.xdata$x:0000611C __unwindtable$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000611C                                         ; DATA XREF: .xdata$x:0000612Co
.xdata$x:0000611D                 db 0FFh
.xdata$x:0000611E                 db 0FFh
.xdata$x:0000611F                 db 0FFh
.xdata$x:00006120                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:00006124 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006124                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006125                 db    5
.xdata$x:00006126                 db  93h ; 
.xdata$x:00006127                 db  19h
.xdata$x:00006128                 db    1
.xdata$x:00006129                 db    0
.xdata$x:0000612A                 db    0
.xdata$x:0000612B                 db    0
.xdata$x:0000612C                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:00006130                 db    0
.xdata$x:00006131                 db    0
.xdata$x:00006132                 db    0
.xdata$x:00006133                 db    0
.xdata$x:00006134                 db    0
.xdata$x:00006135                 db    0
.xdata$x:00006136                 db    0
.xdata$x:00006137                 db    0
.xdata$x:00006138                 db    0
.xdata$x:00006139                 db    0
.xdata$x:0000613A                 db    0
.xdata$x:0000613B                 db    0
.xdata$x:0000613C                 db    0
.xdata$x:0000613D                 db    0
.xdata$x:0000613E                 db    0
.xdata$x:0000613F                 db    0
.xdata$x:00006140                 db    0
.xdata$x:00006141                 db    0
.xdata$x:00006142                 db    0
.xdata$x:00006143                 db    0
.xdata$x:00006144                 db    0
.xdata$x:00006145                 db    0
.xdata$x:00006146                 db    0
.xdata$x:00006147                 db    0
.xdata$x:00006147 _xdata$x        ends
.xdata$x:00006147
.xdata$x:00006148 ; ===========================================================================
.xdata$x:00006148
.xdata$x:00006148 ; Segment type: Pure data
.xdata$x:00006148 ; Segment permissions: Read
.xdata$x:00006148 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006148                 assume cs:_xdata$x
.xdata$x:00006148                 ;org 6148h
.xdata$x:00006148 ; COMDAT (pick associative to section at 206C)
.xdata$x:00006148 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z db 0FFh
.xdata$x:00006148                                         ; DATA XREF: .xdata$x:00006158o
.xdata$x:00006149                 db 0FFh
.xdata$x:0000614A                 db 0FFh
.xdata$x:0000614B                 db 0FFh
.xdata$x:0000614C                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z$0
.xdata$x:00006150 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z db  22h ; "
.xdata$x:00006150                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z+11o
.xdata$x:00006151                 db    5
.xdata$x:00006152                 db  93h ; 
.xdata$x:00006153                 db  19h
.xdata$x:00006154                 db    1
.xdata$x:00006155                 db    0
.xdata$x:00006156                 db    0
.xdata$x:00006157                 db    0
.xdata$x:00006158                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@USwitcherFileInfo@@@1@@Z
.xdata$x:0000615C                 db    0
.xdata$x:0000615D                 db    0
.xdata$x:0000615E                 db    0
.xdata$x:0000615F                 db    0
.xdata$x:00006160                 db    0
.xdata$x:00006161                 db    0
.xdata$x:00006162                 db    0
.xdata$x:00006163                 db    0
.xdata$x:00006164                 db    0
.xdata$x:00006165                 db    0
.xdata$x:00006166                 db    0
.xdata$x:00006167                 db    0
.xdata$x:00006168                 db    0
.xdata$x:00006169                 db    0
.xdata$x:0000616A                 db    0
.xdata$x:0000616B                 db    0
.xdata$x:0000616C                 db    0
.xdata$x:0000616D                 db    0
.xdata$x:0000616E                 db    0
.xdata$x:0000616F                 db    0
.xdata$x:00006170                 db    0
.xdata$x:00006171                 db    0
.xdata$x:00006172                 db    0
.xdata$x:00006173                 db    0
.xdata$x:00006173 _xdata$x        ends
.xdata$x:00006173
.xdata$x:00006174 ; ===========================================================================
.xdata$x:00006174
.xdata$x:00006174 ; Segment type: Pure data
.xdata$x:00006174 ; Segment permissions: Read
.xdata$x:00006174 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006174                 assume cs:_xdata$x
.xdata$x:00006174                 ;org 6174h
.xdata$x:00006174 ; COMDAT (pick associative to section at 2D28)
.xdata$x:00006174 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006174                                         ; DATA XREF: .xdata$x:00006184o
.xdata$x:00006175                 db 0FFh
.xdata$x:00006176                 db 0FFh
.xdata$x:00006177                 db 0FFh
.xdata$x:00006178                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000617C __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000617C                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000617D                 db    5
.xdata$x:0000617E                 db  93h ; 
.xdata$x:0000617F                 db  19h
.xdata$x:00006180                 db    1
.xdata$x:00006181                 db    0
.xdata$x:00006182                 db    0
.xdata$x:00006183                 db    0
.xdata$x:00006184                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00006188                 align 20h
.xdata$x:00006188 _xdata$x        ends
.xdata$x:00006188
.xdata$x:000061A0 ; ===========================================================================
.xdata$x:000061A0
.xdata$x:000061A0 ; Segment type: Pure data
.xdata$x:000061A0 ; Segment permissions: Read
.xdata$x:000061A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000061A0                 assume cs:_xdata$x
.xdata$x:000061A0                 ;org 61A0h
.xdata$x:000061A0 ; COMDAT (pick associative to section at 25FC)
.xdata$x:000061A0 __unwindtable$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000061A0                                         ; DATA XREF: .xdata$x:000061B0o
.xdata$x:000061A1                 db 0FFh
.xdata$x:000061A2                 db 0FFh
.xdata$x:000061A3                 db 0FFh
.xdata$x:000061A4                 dd offset __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:000061A8 __ehfuncinfo$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000061A8                                         ; DATA XREF: __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:000061A9                 db    5
.xdata$x:000061AA                 db  93h ; 
.xdata$x:000061AB                 db  19h
.xdata$x:000061AC                 db    1
.xdata$x:000061AD                 db    0
.xdata$x:000061AE                 db    0
.xdata$x:000061AF                 db    0
.xdata$x:000061B0                 dd offset __unwindtable$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:000061B4                 db    0
.xdata$x:000061B5                 db    0
.xdata$x:000061B6                 db    0
.xdata$x:000061B7                 db    0
.xdata$x:000061B8                 db    0
.xdata$x:000061B9                 db    0
.xdata$x:000061BA                 db    0
.xdata$x:000061BB                 db    0
.xdata$x:000061BC                 db    0
.xdata$x:000061BD                 db    0
.xdata$x:000061BE                 db    0
.xdata$x:000061BF                 db    0
.xdata$x:000061C0                 db    0
.xdata$x:000061C1                 db    0
.xdata$x:000061C2                 db    0
.xdata$x:000061C3                 db    0
.xdata$x:000061C4                 db    0
.xdata$x:000061C5                 db    0
.xdata$x:000061C6                 db    0
.xdata$x:000061C7                 db    0
.xdata$x:000061C8                 db    0
.xdata$x:000061C9                 db    0
.xdata$x:000061CA                 db    0
.xdata$x:000061CB                 db    0
.xdata$x:000061CB _xdata$x        ends
.xdata$x:000061CB
.xdata$x:000061CC ; ===========================================================================
.xdata$x:000061CC
.xdata$x:000061CC ; Segment type: Pure data
.xdata$x:000061CC ; Segment permissions: Read
.xdata$x:000061CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000061CC                 assume cs:_xdata$x
.xdata$x:000061CC                 ;org 61CCh
.xdata$x:000061CC ; COMDAT (pick associative to section at 2558)
.xdata$x:000061CC __unwindtable$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:000061CC                                         ; DATA XREF: .xdata$x:000061DCo
.xdata$x:000061CD                 db 0FFh
.xdata$x:000061CE                 db 0FFh
.xdata$x:000061CF                 db 0FFh
.xdata$x:000061D0                 dd offset __unwindfunclet$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z$0
.xdata$x:000061D4 __ehfuncinfo$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:000061D4                                         ; DATA XREF: __ehhandler$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:000061D5                 db    5
.xdata$x:000061D6                 db  93h ; 
.xdata$x:000061D7                 db  19h
.xdata$x:000061D8                 db    1
.xdata$x:000061D9                 db    0
.xdata$x:000061DA                 db    0
.xdata$x:000061DB                 db    0
.xdata$x:000061DC                 dd offset __unwindtable$??0?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@$$QAV01@@Z
.xdata$x:000061E0                 db    0
.xdata$x:000061E1                 db    0
.xdata$x:000061E2                 db    0
.xdata$x:000061E3                 db    0
.xdata$x:000061E4                 db    0
.xdata$x:000061E5                 db    0
.xdata$x:000061E6                 db    0
.xdata$x:000061E7                 db    0
.xdata$x:000061E8                 db    0
.xdata$x:000061E9                 db    0
.xdata$x:000061EA                 db    0
.xdata$x:000061EB                 db    0
.xdata$x:000061EC                 db    0
.xdata$x:000061ED                 db    0
.xdata$x:000061EE                 db    0
.xdata$x:000061EF                 db    0
.xdata$x:000061F0                 db    0
.xdata$x:000061F1                 db    0
.xdata$x:000061F2                 db    0
.xdata$x:000061F3                 db    0
.xdata$x:000061F4                 db    0
.xdata$x:000061F5                 db    0
.xdata$x:000061F6                 db    0
.xdata$x:000061F7                 db    0
.xdata$x:000061F7 _xdata$x        ends
.xdata$x:000061F7
.xdata$x:000061F8 ; ===========================================================================
.xdata$x:000061F8
.xdata$x:000061F8 ; Segment type: Pure data
.xdata$x:000061F8 ; Segment permissions: Read
.xdata$x:000061F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000061F8                 assume cs:_xdata$x
.xdata$x:000061F8                 ;org 61F8h
.xdata$x:000061F8 ; COMDAT (pick associative to section at 2FF0)
.xdata$x:000061F8 __unwindtable$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000061F8                                         ; DATA XREF: .xdata$x:00006208o
.xdata$x:000061F9                 db 0FFh
.xdata$x:000061FA                 db 0FFh
.xdata$x:000061FB                 db 0FFh
.xdata$x:000061FC                 dd offset __unwindfunclet$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:00006200 __ehfuncinfo$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006200                                         ; DATA XREF: __ehhandler$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006201                 db    5
.xdata$x:00006202                 db  93h ; 
.xdata$x:00006203                 db  19h
.xdata$x:00006204                 db    1
.xdata$x:00006205                 db    0
.xdata$x:00006206                 db    0
.xdata$x:00006207                 db    0
.xdata$x:00006208                 dd offset __unwindtable$??1?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@QAE@XZ
.xdata$x:0000620C                 db    0
.xdata$x:0000620D                 db    0
.xdata$x:0000620E                 db    0
.xdata$x:0000620F                 db    0
.xdata$x:00006210                 db    0
.xdata$x:00006211                 db    0
.xdata$x:00006212                 db    0
.xdata$x:00006213                 db    0
.xdata$x:00006214                 db    0
.xdata$x:00006215                 db    0
.xdata$x:00006216                 db    0
.xdata$x:00006217                 db    0
.xdata$x:00006218                 db    0
.xdata$x:00006219                 db    0
.xdata$x:0000621A                 db    0
.xdata$x:0000621B                 db    0
.xdata$x:0000621C                 db    0
.xdata$x:0000621D                 db    0
.xdata$x:0000621E                 db    0
.xdata$x:0000621F                 db    0
.xdata$x:00006220                 db    0
.xdata$x:00006221                 db    0
.xdata$x:00006222                 db    0
.xdata$x:00006223                 db    0
.xdata$x:00006223 _xdata$x        ends
.xdata$x:00006223
.xdata$x:00006224 ; ===========================================================================
.xdata$x:00006224
.xdata$x:00006224 ; Segment type: Pure data
.xdata$x:00006224 ; Segment permissions: Read
.xdata$x:00006224 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006224                 assume cs:_xdata$x
.xdata$x:00006224                 ;org 6224h
.xdata$x:00006224 ; COMDAT (pick associative to section at 433C)
.xdata$x:00006224 __catchsym$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00006224                                         ; DATA XREF: .xdata$x:00006254o
.xdata$x:00006225                 db    0
.xdata$x:00006226                 db    0
.xdata$x:00006227                 db    0
.xdata$x:00006228                 db    0
.xdata$x:00006229                 db    0
.xdata$x:0000622A                 db    0
.xdata$x:0000622B                 db    0
.xdata$x:0000622C                 db    0
.xdata$x:0000622D                 db    0
.xdata$x:0000622E                 db    0
.xdata$x:0000622F                 db    0
.xdata$x:00006230                 dd offset __catch$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z$0
.xdata$x:00006234 __unwindtable$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00006234                                         ; DATA XREF: .xdata$x:00006260o
.xdata$x:00006235                 db 0FFh
.xdata$x:00006236                 db 0FFh
.xdata$x:00006237                 db 0FFh
.xdata$x:00006238                 db    0
.xdata$x:00006239                 db    0
.xdata$x:0000623A                 db    0
.xdata$x:0000623B                 db    0
.xdata$x:0000623C                 db 0FFh
.xdata$x:0000623D                 db 0FFh
.xdata$x:0000623E                 db 0FFh
.xdata$x:0000623F                 db 0FFh
.xdata$x:00006240                 db    0
.xdata$x:00006241                 db    0
.xdata$x:00006242                 db    0
.xdata$x:00006243                 db    0
.xdata$x:00006244 __tryblocktable$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00006244                                         ; DATA XREF: .xdata$x:00006268o
.xdata$x:00006245                 db    0
.xdata$x:00006246                 db    0
.xdata$x:00006247                 db    0
.xdata$x:00006248                 db    0
.xdata$x:00006249                 db    0
.xdata$x:0000624A                 db    0
.xdata$x:0000624B                 db    0
.xdata$x:0000624C                 db    1
.xdata$x:0000624D                 db    0
.xdata$x:0000624E                 db    0
.xdata$x:0000624F                 db    0
.xdata$x:00006250                 db    1
.xdata$x:00006251                 db    0
.xdata$x:00006252                 db    0
.xdata$x:00006253                 db    0
.xdata$x:00006254                 dd offset __catchsym$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z$2
.xdata$x:00006258 __ehfuncinfo$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00006258                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z+11o
.xdata$x:00006259                 db    5
.xdata$x:0000625A                 db  93h ; 
.xdata$x:0000625B                 db  19h
.xdata$x:0000625C                 db    2
.xdata$x:0000625D                 db    0
.xdata$x:0000625E                 db    0
.xdata$x:0000625F                 db    0
.xdata$x:00006260                 dd offset __unwindtable$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.xdata$x:00006264                 db    1
.xdata$x:00006265                 db    0
.xdata$x:00006266                 db    0
.xdata$x:00006267                 db    0
.xdata$x:00006268                 dd offset __tryblocktable$?_Reallocate@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IAEXI@Z
.xdata$x:0000626C                 db    0
.xdata$x:0000626D                 db    0
.xdata$x:0000626E                 db    0
.xdata$x:0000626F                 db    0
.xdata$x:00006270                 db    0
.xdata$x:00006271                 db    0
.xdata$x:00006272                 db    0
.xdata$x:00006273                 db    0
.xdata$x:00006274                 db    0
.xdata$x:00006275                 db    0
.xdata$x:00006276                 db    0
.xdata$x:00006277                 db    0
.xdata$x:00006278                 db    0
.xdata$x:00006279                 db    0
.xdata$x:0000627A                 db    0
.xdata$x:0000627B                 db    0
.xdata$x:0000627B _xdata$x        ends
.xdata$x:0000627B
.xdata$x:0000627C ; ===========================================================================
.xdata$x:0000627C
.xdata$x:0000627C ; Segment type: Pure data
.xdata$x:0000627C ; Segment permissions: Read
.xdata$x:0000627C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000627C                 assume cs:_xdata$x
.xdata$x:0000627C                 ;org 627Ch
.xdata$x:0000627C ; COMDAT (pick associative to section at 4260)
.xdata$x:0000627C __unwindtable$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z db 0FFh
.xdata$x:0000627C                                         ; DATA XREF: .xdata$x:0000628Co
.xdata$x:0000627D                 db 0FFh
.xdata$x:0000627E                 db 0FFh
.xdata$x:0000627F                 db 0FFh
.xdata$x:00006280                 dd offset __unwindfunclet$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z$0
.xdata$x:00006284 __ehfuncinfo$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z db  22h ; "
.xdata$x:00006284                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z+11o
.xdata$x:00006285                 db    5
.xdata$x:00006286                 db  93h ; 
.xdata$x:00006287                 db  19h
.xdata$x:00006288                 db    1
.xdata$x:00006289                 db    0
.xdata$x:0000628A                 db    0
.xdata$x:0000628B                 db    0
.xdata$x:0000628C                 dd offset __unwindtable$?_Orphan_range@?$vector@USwitcherFileInfo@@V?$allocator@USwitcherFileInfo@@@std@@@std@@IBEXPAUSwitcherFileInfo@@0@Z
.xdata$x:00006290                 db    0
.xdata$x:00006291                 db    0
.xdata$x:00006292                 db    0
.xdata$x:00006293                 db    0
.xdata$x:00006294                 db    0
.xdata$x:00006295                 db    0
.xdata$x:00006296                 db    0
.xdata$x:00006297                 db    0
.xdata$x:00006298                 db    0
.xdata$x:00006299                 db    0
.xdata$x:0000629A                 db    0
.xdata$x:0000629B                 db    0
.xdata$x:0000629C                 db    0
.xdata$x:0000629D                 db    0
.xdata$x:0000629E                 db    0
.xdata$x:0000629F                 db    0
.xdata$x:000062A0                 db    0
.xdata$x:000062A1                 db    0
.xdata$x:000062A2                 db    0
.xdata$x:000062A3                 db    0
.xdata$x:000062A4                 db    0
.xdata$x:000062A5                 db    0
.xdata$x:000062A6                 db    0
.xdata$x:000062A7                 db    0
.xdata$x:000062A7 _xdata$x        ends
.xdata$x:000062A7
.xdata$x:000062A8 ; ===========================================================================
.xdata$x:000062A8
.xdata$x:000062A8 ; Segment type: Pure data
.xdata$x:000062A8 ; Segment permissions: Read
.xdata$x:000062A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000062A8                 assume cs:_xdata$x
.xdata$x:000062A8                 ;org 62A8h
.xdata$x:000062A8 ; COMDAT (pick associative to section at 1C08)
.xdata$x:000062A8 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000062A8                                         ; DATA XREF: .xdata$x:000062B8o
.xdata$x:000062A9                 db 0FFh
.xdata$x:000062AA                 db 0FFh
.xdata$x:000062AB                 db 0FFh
.xdata$x:000062AC                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000062B0 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000062B0                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000062B1                 db    5
.xdata$x:000062B2                 db  93h ; 
.xdata$x:000062B3                 db  19h
.xdata$x:000062B4                 db    1
.xdata$x:000062B5                 db    0
.xdata$x:000062B6                 db    0
.xdata$x:000062B7                 db    0
.xdata$x:000062B8                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000062BC                 db    0
.xdata$x:000062BD                 db    0
.xdata$x:000062BE                 db    0
.xdata$x:000062BF                 db    0
.xdata$x:000062C0                 db    0
.xdata$x:000062C1                 db    0
.xdata$x:000062C2                 db    0
.xdata$x:000062C3                 db    0
.xdata$x:000062C4                 db    0
.xdata$x:000062C5                 db    0
.xdata$x:000062C6                 db    0
.xdata$x:000062C7                 db    0
.xdata$x:000062C8                 db    0
.xdata$x:000062C9                 db    0
.xdata$x:000062CA                 db    0
.xdata$x:000062CB                 db    0
.xdata$x:000062CC                 db    0
.xdata$x:000062CD                 db    0
.xdata$x:000062CE                 db    0
.xdata$x:000062CF                 db    0
.xdata$x:000062D0                 db    0
.xdata$x:000062D1                 db    0
.xdata$x:000062D2                 db    0
.xdata$x:000062D3                 db    0
.xdata$x:000062D3 _xdata$x        ends
.xdata$x:000062D3
.xdata$x:000062D4 ; ===========================================================================
.xdata$x:000062D4
.xdata$x:000062D4 ; Segment type: Pure data
.xdata$x:000062D4 ; Segment permissions: Read
.xdata$x:000062D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000062D4                 assume cs:_xdata$x
.xdata$x:000062D4                 ;org 62D4h
.xdata$x:000062D4 ; COMDAT (pick associative to section at 1B04)
.xdata$x:000062D4 __unwindtable$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z db 0FFh
.xdata$x:000062D4                                         ; DATA XREF: .xdata$x:000062E4o
.xdata$x:000062D5                 db 0FFh
.xdata$x:000062D6                 db 0FFh
.xdata$x:000062D7                 db 0FFh
.xdata$x:000062D8                 dd offset __unwindfunclet$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z$0
.xdata$x:000062DC __ehfuncinfo$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z db  22h ; "
.xdata$x:000062DC                                         ; DATA XREF: __ehhandler$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z+11o
.xdata$x:000062DD                 db    5
.xdata$x:000062DE                 db  93h ; 
.xdata$x:000062DF                 db  19h
.xdata$x:000062E0                 db    1
.xdata$x:000062E1                 db    0
.xdata$x:000062E2                 db    0
.xdata$x:000062E3                 db    0
.xdata$x:000062E4                 dd offset __unwindtable$??$construct@USwitcherFileInfo@@U1@@?$allocator@USwitcherFileInfo@@@std@@QAEXPAUSwitcherFileInfo@@$$QAU2@@Z
.xdata$x:000062E8                 align 20h
.xdata$x:000062E8 _xdata$x        ends
.xdata$x:000062E8
.xdata$x:00006300 ; ===========================================================================
.xdata$x:00006300
.xdata$x:00006300 ; Segment type: Pure data
.xdata$x:00006300 ; Segment permissions: Read
.xdata$x:00006300 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006300                 assume cs:_xdata$x
.xdata$x:00006300                 ;org 6300h
.xdata$x:00006300 ; COMDAT (pick associative to section at 1904)
.xdata$x:00006300 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00006300                                         ; DATA XREF: .xdata$x:00006310o
.xdata$x:00006301                 db 0FFh
.xdata$x:00006302                 db 0FFh
.xdata$x:00006303                 db 0FFh
.xdata$x:00006304                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00006308 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00006308                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00006309                 db    5
.xdata$x:0000630A                 db  93h ; 
.xdata$x:0000630B                 db  19h
.xdata$x:0000630C                 db    1
.xdata$x:0000630D                 db    0
.xdata$x:0000630E                 db    0
.xdata$x:0000630F                 db    0
.xdata$x:00006310                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00006314                 db    0
.xdata$x:00006315                 db    0
.xdata$x:00006316                 db    0
.xdata$x:00006317                 db    0
.xdata$x:00006318                 db    0
.xdata$x:00006319                 db    0
.xdata$x:0000631A                 db    0
.xdata$x:0000631B                 db    0
.xdata$x:0000631C                 db    0
.xdata$x:0000631D                 db    0
.xdata$x:0000631E                 db    0
.xdata$x:0000631F                 db    0
.xdata$x:00006320                 db    0
.xdata$x:00006321                 db    0
.xdata$x:00006322                 db    0
.xdata$x:00006323                 db    0
.xdata$x:00006324                 db    0
.xdata$x:00006325                 db    0
.xdata$x:00006326                 db    0
.xdata$x:00006327                 db    0
.xdata$x:00006328                 db    0
.xdata$x:00006329                 db    0
.xdata$x:0000632A                 db    0
.xdata$x:0000632B                 db    0
.xdata$x:0000632B _xdata$x        ends
.xdata$x:0000632B
.xdata$x:0000632C ; ===========================================================================
.xdata$x:0000632C
.xdata$x:0000632C ; Segment type: Pure data
.xdata$x:0000632C ; Segment permissions: Read
.xdata$x:0000632C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000632C                 assume cs:_xdata$x
.xdata$x:0000632C                 ;org 632Ch
.xdata$x:0000632C ; COMDAT (pick associative to section at 1A04)
.xdata$x:0000632C __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000632C                                         ; DATA XREF: .xdata$x:0000633Co
.xdata$x:0000632D                 db 0FFh
.xdata$x:0000632E                 db 0FFh
.xdata$x:0000632F                 db 0FFh
.xdata$x:00006330                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00006334 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00006334                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00006335                 db    5
.xdata$x:00006336                 db  93h ; 
.xdata$x:00006337                 db  19h
.xdata$x:00006338                 db    1
.xdata$x:00006339                 db    0
.xdata$x:0000633A                 db    0
.xdata$x:0000633B                 db    0
.xdata$x:0000633C                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00006340                 db    0
.xdata$x:00006341                 db    0
.xdata$x:00006342                 db    0
.xdata$x:00006343                 db    0
.xdata$x:00006344                 db    0
.xdata$x:00006345                 db    0
.xdata$x:00006346                 db    0
.xdata$x:00006347                 db    0
.xdata$x:00006348                 db    0
.xdata$x:00006349                 db    0
.xdata$x:0000634A                 db    0
.xdata$x:0000634B                 db    0
.xdata$x:0000634C                 db    0
.xdata$x:0000634D                 db    0
.xdata$x:0000634E                 db    0
.xdata$x:0000634F                 db    0
.xdata$x:00006350                 db    0
.xdata$x:00006351                 db    0
.xdata$x:00006352                 db    0
.xdata$x:00006353                 db    0
.xdata$x:00006354                 db    0
.xdata$x:00006355                 db    0
.xdata$x:00006356                 db    0
.xdata$x:00006357                 db    0
.xdata$x:00006357 _xdata$x        ends
.xdata$x:00006357
.xdata$x:00006358 ; ===========================================================================
.xdata$x:00006358
.xdata$x:00006358 ; Segment type: Pure data
.xdata$x:00006358 ; Segment permissions: Read
.xdata$x:00006358 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006358                 assume cs:_xdata$x
.xdata$x:00006358                 ;org 6358h
.xdata$x:00006358 ; COMDAT (pick associative to section at 1768)
.xdata$x:00006358 __catchsym$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:00006358                                         ; DATA XREF: .xdata$x:00006388o
.xdata$x:00006359                 db    0
.xdata$x:0000635A                 db    0
.xdata$x:0000635B                 db    0
.xdata$x:0000635C                 db    0
.xdata$x:0000635D                 db    0
.xdata$x:0000635E                 db    0
.xdata$x:0000635F                 db    0
.xdata$x:00006360                 db    0
.xdata$x:00006361                 db    0
.xdata$x:00006362                 db    0
.xdata$x:00006363                 db    0
.xdata$x:00006364                 dd offset __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:00006368 __unwindtable$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:00006368                                         ; DATA XREF: .xdata$x:00006394o
.xdata$x:00006369                 db 0FFh
.xdata$x:0000636A                 db 0FFh
.xdata$x:0000636B                 db 0FFh
.xdata$x:0000636C                 db    0
.xdata$x:0000636D                 db    0
.xdata$x:0000636E                 db    0
.xdata$x:0000636F                 db    0
.xdata$x:00006370                 db 0FFh
.xdata$x:00006371                 db 0FFh
.xdata$x:00006372                 db 0FFh
.xdata$x:00006373                 db 0FFh
.xdata$x:00006374                 db    0
.xdata$x:00006375                 db    0
.xdata$x:00006376                 db    0
.xdata$x:00006377                 db    0
.xdata$x:00006378 __tryblocktable$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:00006378                                         ; DATA XREF: .xdata$x:0000639Co
.xdata$x:00006379                 db    0
.xdata$x:0000637A                 db    0
.xdata$x:0000637B                 db    0
.xdata$x:0000637C                 db    0
.xdata$x:0000637D                 db    0
.xdata$x:0000637E                 db    0
.xdata$x:0000637F                 db    0
.xdata$x:00006380                 db    1
.xdata$x:00006381                 db    0
.xdata$x:00006382                 db    0
.xdata$x:00006383                 db    0
.xdata$x:00006384                 db    1
.xdata$x:00006385                 db    0
.xdata$x:00006386                 db    0
.xdata$x:00006387                 db    0
.xdata$x:00006388                 dd offset __catchsym$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000638C __ehfuncinfo$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000638C                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000638D                 db    5
.xdata$x:0000638E                 db  93h ; 
.xdata$x:0000638F                 db  19h
.xdata$x:00006390                 db    2
.xdata$x:00006391                 db    0
.xdata$x:00006392                 db    0
.xdata$x:00006393                 db    0
.xdata$x:00006394                 dd offset __unwindtable$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00006398                 db    1
.xdata$x:00006399                 db    0
.xdata$x:0000639A                 db    0
.xdata$x:0000639B                 db    0
.xdata$x:0000639C                 dd offset __tryblocktable$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:000063A0                 db    0
.xdata$x:000063A1                 db    0
.xdata$x:000063A2                 db    0
.xdata$x:000063A3                 db    0
.xdata$x:000063A4                 db    0
.xdata$x:000063A5                 db    0
.xdata$x:000063A6                 db    0
.xdata$x:000063A7                 db    0
.xdata$x:000063A8                 db    0
.xdata$x:000063A9                 db    0
.xdata$x:000063AA                 db    0
.xdata$x:000063AB                 db    0
.xdata$x:000063AC                 db    0
.xdata$x:000063AD                 db    0
.xdata$x:000063AE                 db    0
.xdata$x:000063AF                 db    0
.xdata$x:000063AF _xdata$x        ends
.xdata$x:000063AF
.rdata:000063B0 ; ===========================================================================
.rdata:000063B0
.rdata:000063B0 ; Segment type: Pure data
.rdata:000063B0 ; Segment permissions: Read
.rdata:000063B0 _rdata          segment dword public 'DATA' use32
.rdata:000063B0                 assume cs:_rdata
.rdata:000063B0                 ;org 63B0h
.rdata:000063B0 ; COMDAT (pick largest)
.rdata:000063B0                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:000063B4                 public ??_7runtime_error@std@@6B@
.rdata:000063B4 ; const std::runtime_error::`vftable'
.rdata:000063B4 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:000063B4                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:000063B4                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:000063B4                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:000063B8                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:000063B8 _rdata          ends
.rdata:000063B8
.xdata$x:000063BC ; ===========================================================================
.xdata$x:000063BC
.xdata$x:000063BC ; Segment type: Pure data
.xdata$x:000063BC ; Segment permissions: Read
.xdata$x:000063BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000063BC                 assume cs:_xdata$x
.xdata$x:000063BC                 ;org 63BCh
.xdata$x:000063BC ; COMDAT (pick any)
.xdata$x:000063BC                 public __TI2?AVruntime_error@std@@
.xdata$x:000063BC __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+90o
.xdata$x:000063BD                 db    0
.xdata$x:000063BE                 db    0
.xdata$x:000063BF                 db    0
.xdata$x:000063C0                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:000063C4                 align 8
.xdata$x:000063C8                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:000063C8 _xdata$x        ends
.xdata$x:000063C8
.xdata$x:000063CC ; ===========================================================================
.xdata$x:000063CC
.xdata$x:000063CC ; Segment type: Pure data
.xdata$x:000063CC ; Segment permissions: Read
.xdata$x:000063CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000063CC                 assume cs:_xdata$x
.xdata$x:000063CC                 ;org 63CCh
.xdata$x:000063CC ; COMDAT (pick any)
.xdata$x:000063CC                 public __CTA2?AVruntime_error@std@@
.xdata$x:000063CC __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:000063C8o
.xdata$x:000063CD                 db    0
.xdata$x:000063CE                 db    0
.xdata$x:000063CF                 db    0
.xdata$x:000063D0                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:000063D4                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:000063D4 _xdata$x        ends
.xdata$x:000063D4
.data$r:000063D8 ; ===========================================================================
.data$r:000063D8
.data$r:000063D8 ; Segment type: Pure data
.data$r:000063D8 ; Segment permissions: Read/Write
.data$r:000063D8 _data$r         segment dword public 'DATA' use32
.data$r:000063D8                 assume cs:_data$r
.data$r:000063D8                 ;org 63D8h
.data$r:000063D8 ; COMDAT (pick any)
.data$r:000063D8                 public ??_R0?AVruntime_error@std@@@8
.data$r:000063D8 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:000063D8 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000063D8                                         ; DATA XREF: .xdata$x:000063FCo
.data$r:000063D8                                         ; .rdata$r:0000694Co ...
.data$r:000063D8                                         ; const type_info::`vftable'
.data$r:000063DC                 align 10h
.data$r:000063E0 a_?avruntime_er db '.?AVruntime_error@std@@',0
.data$r:000063E0 _data$r         ends
.data$r:000063E0
.xdata$x:000063F8 ; ===========================================================================
.xdata$x:000063F8
.xdata$x:000063F8 ; Segment type: Pure data
.xdata$x:000063F8 ; Segment permissions: Read
.xdata$x:000063F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000063F8                 assume cs:_xdata$x
.xdata$x:000063F8                 ;org 63F8h
.xdata$x:000063F8 ; COMDAT (pick any)
.xdata$x:000063F8                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:000063F8 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000063F8                                         ; DATA XREF: .xdata$x:000063D0o
.xdata$x:000063F9                 db    0
.xdata$x:000063FA                 db    0
.xdata$x:000063FB                 db    0
.xdata$x:000063FC                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00006400                 db    0
.xdata$x:00006401                 db    0
.xdata$x:00006402                 db    0
.xdata$x:00006403                 db    0
.xdata$x:00006404                 db 0FFh
.xdata$x:00006405                 db 0FFh
.xdata$x:00006406                 db 0FFh
.xdata$x:00006407                 db 0FFh
.xdata$x:00006408                 db    0
.xdata$x:00006409                 db    0
.xdata$x:0000640A                 db    0
.xdata$x:0000640B                 db    0
.xdata$x:0000640C                 db  0Ch
.xdata$x:0000640D                 db    0
.xdata$x:0000640E                 db    0
.xdata$x:0000640F                 db    0
.xdata$x:00006410                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00006410 _xdata$x        ends
.xdata$x:00006410
.data$r:00006414 ; ===========================================================================
.data$r:00006414
.data$r:00006414 ; Segment type: Pure data
.data$r:00006414 ; Segment permissions: Read/Write
.data$r:00006414 _data$r         segment dword public 'DATA' use32
.data$r:00006414                 assume cs:_data$r
.data$r:00006414                 ;org 6414h
.data$r:00006414 ; COMDAT (pick any)
.data$r:00006414                 public ??_R0?AVexception@std@@@8
.data$r:00006414 ; class std::exception `RTTI Type Descriptor'
.data$r:00006414 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00006414                                         ; DATA XREF: .xdata$x:00006434o
.data$r:00006414                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00006414                                         ; const type_info::`vftable'
.data$r:00006418                 db    0
.data$r:00006419                 db    0
.data$r:0000641A                 db    0
.data$r:0000641B                 db    0
.data$r:0000641C                 db  2Eh ; .
.data$r:0000641D                 db  3Fh ; ?
.data$r:0000641E                 db  41h ; A
.data$r:0000641F                 db  56h ; V
.data$r:00006420                 db  65h ; e
.data$r:00006421                 db  78h ; x
.data$r:00006422                 db  63h ; c
.data$r:00006423                 db  65h ; e
.data$r:00006424                 db  70h ; p
.data$r:00006425                 db  74h ; t
.data$r:00006426                 db  69h ; i
.data$r:00006427                 db  6Fh ; o
.data$r:00006428                 db  6Eh ; n
.data$r:00006429                 db  40h ; @
.data$r:0000642A                 db  73h ; s
.data$r:0000642B                 db  74h ; t
.data$r:0000642C                 db  64h ; d
.data$r:0000642D                 db  40h ; @
.data$r:0000642E                 db  40h ; @
.data$r:0000642F                 db    0
.data$r:0000642F _data$r         ends
.data$r:0000642F
.xdata$x:00006430 ; ===========================================================================
.xdata$x:00006430
.xdata$x:00006430 ; Segment type: Pure data
.xdata$x:00006430 ; Segment permissions: Read
.xdata$x:00006430 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006430                 assume cs:_xdata$x
.xdata$x:00006430                 ;org 6430h
.xdata$x:00006430 ; COMDAT (pick any)
.xdata$x:00006430                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00006430 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00006430                                         ; DATA XREF: .xdata$x:000063D4o
.xdata$x:00006431                 db    0
.xdata$x:00006432                 db    0
.xdata$x:00006433                 db    0
.xdata$x:00006434                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00006438                 db    0
.xdata$x:00006439                 db    0
.xdata$x:0000643A                 db    0
.xdata$x:0000643B                 db    0
.xdata$x:0000643C                 db 0FFh
.xdata$x:0000643D                 db 0FFh
.xdata$x:0000643E                 db 0FFh
.xdata$x:0000643F                 db 0FFh
.xdata$x:00006440                 db    0
.xdata$x:00006441                 db    0
.xdata$x:00006442                 db    0
.xdata$x:00006443                 db    0
.xdata$x:00006444                 db  0Ch
.xdata$x:00006445                 db    0
.xdata$x:00006446                 db    0
.xdata$x:00006447                 db    0
.xdata$x:00006448                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00006448 _xdata$x        ends
.xdata$x:00006448
.rdata:0000644C ; ===========================================================================
.rdata:0000644C
.rdata:0000644C ; Segment type: Pure data
.rdata:0000644C ; Segment permissions: Read
.rdata:0000644C _rdata          segment dword public 'DATA' use32
.rdata:0000644C                 assume cs:_rdata
.rdata:0000644C                 ;org 644Ch
.rdata:0000644C ; COMDAT (pick largest)
.rdata:0000644C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00006450                 public ??_7error_category@std@@6B@
.rdata:00006450 ; const std::error_category::`vftable'
.rdata:00006450 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00006450                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00006450                                         ; std::error_category::~error_category(void)+Ao
.rdata:00006450                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00006454                 dd offset __purecall
.rdata:00006458                 dd offset __purecall
.rdata:0000645C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00006460                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00006464                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00006464 _rdata          ends
.rdata:00006464
.rdata:00006468 ; ===========================================================================
.rdata:00006468
.rdata:00006468 ; Segment type: Pure data
.rdata:00006468 ; Segment permissions: Read
.rdata:00006468 _rdata          segment dword public 'DATA' use32
.rdata:00006468                 assume cs:_rdata
.rdata:00006468                 ;org 6468h
.rdata:00006468 ; COMDAT (pick largest)
.rdata:00006468                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000646C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000646C ; const std::_Generic_error_category::`vftable'
.rdata:0000646C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000646C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000646C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00006470                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00006474                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00006478                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000647C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00006480                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00006480 _rdata          ends
.rdata:00006480
.rdata:00006484 ; ===========================================================================
.rdata:00006484
.rdata:00006484 ; Segment type: Pure data
.rdata:00006484 ; Segment permissions: Read
.rdata:00006484 _rdata          segment dword public 'DATA' use32
.rdata:00006484                 assume cs:_rdata
.rdata:00006484                 ;org 6484h
.rdata:00006484 ; COMDAT (pick any)
.rdata:00006484                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00006484 ; `string'
.rdata:00006484 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00006484                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00006484 _rdata          ends
.rdata:00006484
.rdata:0000648C ; ===========================================================================
.rdata:0000648C
.rdata:0000648C ; Segment type: Pure data
.rdata:0000648C ; Segment permissions: Read
.rdata:0000648C _rdata          segment dword public 'DATA' use32
.rdata:0000648C                 assume cs:_rdata
.rdata:0000648C                 ;org 648Ch
.rdata:0000648C ; COMDAT (pick any)
.rdata:0000648C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000648C ; `string'
.rdata:0000648C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000648C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_5380o
.rdata:0000648C                                         ; std::_System_error_category::message(int):loc_54FCo
.rdata:0000649A                 align 4
.rdata:0000649A _rdata          ends
.rdata:0000649A
.rdata:0000649C ; ===========================================================================
.rdata:0000649C
.rdata:0000649C ; Segment type: Pure data
.rdata:0000649C ; Segment permissions: Read
.rdata:0000649C _rdata          segment dword public 'DATA' use32
.rdata:0000649C                 assume cs:_rdata
.rdata:0000649C                 ;org 649Ch
.rdata:0000649C ; COMDAT (pick largest)
.rdata:0000649C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:000064A0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:000064A0 ; const std::_Iostream_error_category::`vftable'
.rdata:000064A0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:000064A0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:000064A0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:000064A4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000064A8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000064AC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000064B0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000064B4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000064B4 _rdata          ends
.rdata:000064B4
.rdata:000064B8 ; ===========================================================================
.rdata:000064B8
.rdata:000064B8 ; Segment type: Pure data
.rdata:000064B8 ; Segment permissions: Read
.rdata:000064B8 _rdata          segment dword public 'DATA' use32
.rdata:000064B8                 assume cs:_rdata
.rdata:000064B8                 ;org 64B8h
.rdata:000064B8 ; COMDAT (pick any)
.rdata:000064B8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000064B8 ; `string'
.rdata:000064B8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000064B8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000064C1                 align 4
.rdata:000064C1 _rdata          ends
.rdata:000064C1
.rdata:000064C4 ; ===========================================================================
.rdata:000064C4
.rdata:000064C4 ; Segment type: Pure data
.rdata:000064C4 ; Segment permissions: Read
.rdata:000064C4 _rdata          segment dword public 'DATA' use32
.rdata:000064C4                 assume cs:_rdata
.rdata:000064C4                 ;org 64C4h
.rdata:000064C4 ; COMDAT (pick any)
.rdata:000064C4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000064C4 ; char `string'[]
.rdata:000064C4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000064C4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:000064DA                 align 4
.rdata:000064DA _rdata          ends
.rdata:000064DA
.rdata:000064DC ; ===========================================================================
.rdata:000064DC
.rdata:000064DC ; Segment type: Pure data
.rdata:000064DC ; Segment permissions: Read
.rdata:000064DC _rdata          segment dword public 'DATA' use32
.rdata:000064DC                 assume cs:_rdata
.rdata:000064DC                 ;org 64DCh
.rdata:000064DC ; COMDAT (pick largest)
.rdata:000064DC                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:000064E0                 public ??_7_System_error_category@std@@6B@
.rdata:000064E0 ; const std::_System_error_category::`vftable'
.rdata:000064E0 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:000064E0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:000064E0                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000064E4                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000064E8                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000064EC                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000064F0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000064F4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000064F4 _rdata          ends
.rdata:000064F4
.rdata:000064F8 ; ===========================================================================
.rdata:000064F8
.rdata:000064F8 ; Segment type: Pure data
.rdata:000064F8 ; Segment permissions: Read
.rdata:000064F8 _rdata          segment dword public 'DATA' use32
.rdata:000064F8                 assume cs:_rdata
.rdata:000064F8                 ;org 64F8h
.rdata:000064F8 ; COMDAT (pick any)
.rdata:000064F8                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000064F8 ; `string'
.rdata:000064F8 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000064F8                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000064FF                 align 10h
.rdata:000064FF _rdata          ends
.rdata:000064FF
.bss:00006500 ; ===========================================================================
.bss:00006500
.bss:00006500 ; Segment type: Uninitialized
.bss:00006500 ; Segment permissions: Read/Write
.bss:00006500 _bss            segment dword public 'BSS' use32
.bss:00006500                 assume cs:_bss
.bss:00006500                 ;org 6500h
.bss:00006500 ; COMDAT (pick any)
.bss:00006500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00006500                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00006500 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00006500 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00006500                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00006500                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00006501                 db    ? ;
.bss:00006502                 db    ? ;
.bss:00006503                 db    ? ;
.bss:00006503 _bss            ends
.bss:00006503
.bss:00006504 ; ===========================================================================
.bss:00006504
.bss:00006504 ; Segment type: Uninitialized
.bss:00006504 ; Segment permissions: Read/Write
.bss:00006504 _bss            segment dword public 'BSS' use32
.bss:00006504                 assume cs:_bss
.bss:00006504                 ;org 6504h
.bss:00006504 ; COMDAT (pick any)
.bss:00006504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00006504                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00006504 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00006504 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00006504                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00006504                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00006505                 db    ? ;
.bss:00006506                 db    ? ;
.bss:00006507                 db    ? ;
.bss:00006507 _bss            ends
.bss:00006507
.bss:00006508 ; ===========================================================================
.bss:00006508
.bss:00006508 ; Segment type: Uninitialized
.bss:00006508 ; Segment permissions: Read/Write
.bss:00006508 _bss            segment dword public 'BSS' use32
.bss:00006508                 assume cs:_bss
.bss:00006508                 ;org 6508h
.bss:00006508 ; COMDAT (pick any)
.bss:00006508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00006508                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00006508 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00006508 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00006508                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00006508                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00006509                 db    ? ;
.bss:0000650A                 db    ? ;
.bss:0000650B                 db    ? ;
.bss:0000650B _bss            ends
.bss:0000650B
.rdata:0000650C ; ===========================================================================
.rdata:0000650C
.rdata:0000650C ; Segment type: Pure data
.rdata:0000650C ; Segment permissions: Read
.rdata:0000650C _rdata          segment dword public 'DATA' use32
.rdata:0000650C                 assume cs:_rdata
.rdata:0000650C                 ;org 650Ch
.rdata:0000650C ; COMDAT (pick any)
.rdata:0000650C                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000650C ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000650C ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000650C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:0000650C _rdata          ends
.rdata:0000650C
.bss:00006510 ; ===========================================================================
.bss:00006510
.bss:00006510 ; Segment type: Uninitialized
.bss:00006510 ; Segment permissions: Read/Write
.bss:00006510 _bss            segment dword public 'BSS' use32
.bss:00006510                 assume cs:_bss
.bss:00006510                 ;org 6510h
.bss:00006510 ; COMDAT (pick any)
.bss:00006510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00006510                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00006510 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00006510 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00006510                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00006511                 db    ? ;
.bss:00006512                 db    ? ;
.bss:00006513                 db    ? ;
.bss:00006513 _bss            ends
.bss:00006513
.bss:00006514 ; ===========================================================================
.bss:00006514
.bss:00006514 ; Segment type: Uninitialized
.bss:00006514 ; Segment permissions: Read/Write
.bss:00006514 _bss            segment dword public 'BSS' use32
.bss:00006514                 assume cs:_bss
.bss:00006514                 ;org 6514h
.bss:00006514 ; COMDAT (pick any)
.bss:00006514                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00006514                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00006514 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00006514 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00006514                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00006515                 db    ? ;
.bss:00006516                 db    ? ;
.bss:00006517                 db    ? ;
.bss:00006517 _bss            ends
.bss:00006517
.bss:00006518 ; ===========================================================================
.bss:00006518
.bss:00006518 ; Segment type: Uninitialized
.bss:00006518 ; Segment permissions: Read/Write
.bss:00006518 _bss            segment dword public 'BSS' use32
.bss:00006518                 assume cs:_bss
.bss:00006518                 ;org 6518h
.bss:00006518 ; COMDAT (pick any)
.bss:00006518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00006518 ; HWND `VerticalFileSwitcherListView::initList'::`2'::nppHwnd
.bss:00006518 ?nppHwnd@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4PAUHWND__@@A dd ?
.bss:00006518                                         ; DATA XREF: VerticalFileSwitcherListView::initList(void)+70w
.bss:00006518                                         ; VerticalFileSwitcherListView::initList(void)+87r
.bss:00006518 _bss            ends
.bss:00006518
.bss:0000651C ; ===========================================================================
.bss:0000651C
.bss:0000651C ; Segment type: Uninitialized
.bss:0000651C ; Segment permissions: Read/Write
.bss:0000651C _bss            segment dword public 'BSS' use32
.bss:0000651C                 assume cs:_bss
.bss:0000651C                 ;org 651Ch
.bss:0000651C ; COMDAT (pick any)
.bss:0000651C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000651C ?$S1@?1??initList@VerticalFileSwitcherListView@@QAEXXZ@4IA dd ?
.bss:0000651C                                         ; DATA XREF: VerticalFileSwitcherListView::initList(void)+43r
.bss:0000651C                                         ; VerticalFileSwitcherListView::initList(void)+4Dr ...
.bss:0000651C _bss            ends
.bss:0000651C
.rdata:00006520 ; ===========================================================================
.rdata:00006520
.rdata:00006520 ; Segment type: Pure data
.rdata:00006520 ; Segment permissions: Read
.rdata:00006520 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00006520 _rdata          segment para public 'DATA' use32
.rdata:00006520                 assume cs:_rdata
.rdata:00006520                 ;org 6520h
.rdata:00006520 ; COMDAT (pick any)
.rdata:00006520                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00006520 ; wchar_t `string'
.rdata:00006520 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00006520                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00006520                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00006520                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00006520                 unicode 0, <clude\xstring>,0
.rdata:000065AE                 align 10h
.rdata:000065AE _rdata          ends
.rdata:000065AE
.bss:000065B0 ; ===========================================================================
.bss:000065B0
.bss:000065B0 ; Segment type: Uninitialized
.bss:000065B0 ; Segment permissions: Read/Write
.bss:000065B0 _bss            segment dword public 'BSS' use32
.bss:000065B0                 assume cs:_bss
.bss:000065B0                 ;org 65B0h
.bss:000065B0 ; COMDAT (pick any)
.bss:000065B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000065B0                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000065B0 ; std::locale::id std::numpunct<char>::id
.bss:000065B0 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000065B0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000065B1                 db    ? ;
.bss:000065B2                 db    ? ;
.bss:000065B3                 db    ? ;
.bss:000065B3 _bss            ends
.bss:000065B3
.bss:000065B4 ; ===========================================================================
.bss:000065B4
.bss:000065B4 ; Segment type: Uninitialized
.bss:000065B4 ; Segment permissions: Read/Write
.bss:000065B4 _bss            segment dword public 'BSS' use32
.bss:000065B4                 assume cs:_bss
.bss:000065B4                 ;org 65B4h
.bss:000065B4 ; COMDAT (pick any)
.bss:000065B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000065B4                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000065B4 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000065B4 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000065B4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000065B5                 db    ? ;
.bss:000065B6                 db    ? ;
.bss:000065B7                 db    ? ;
.bss:000065B7 _bss            ends
.bss:000065B7
.rdata:000065B8 ; ===========================================================================
.rdata:000065B8
.rdata:000065B8 ; Segment type: Pure data
.rdata:000065B8 ; Segment permissions: Read
.rdata:000065B8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000065B8 _rdata          segment para public 'DATA' use32
.rdata:000065B8                 assume cs:_rdata
.rdata:000065B8                 ;org 65B8h
.rdata:000065B8 ; COMDAT (pick any)
.rdata:000065B8                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000065B8 ; wchar_t `string'
.rdata:000065B8 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000065B8                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+19o
.rdata:000065B8                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+49o ...
.rdata:000065B8                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000065B8                 unicode 0, <clude\vector>,0
.rdata:000065B8 _rdata          ends
.rdata:000065B8
.rdata:00006644 ; ===========================================================================
.rdata:00006644
.rdata:00006644 ; Segment type: Pure data
.rdata:00006644 ; Segment permissions: Read
.rdata:00006644 _rdata          segment dword public 'DATA' use32
.rdata:00006644                 assume cs:_rdata
.rdata:00006644                 ;org 6644h
.rdata:00006644 ; COMDAT (pick any)
.rdata:00006644                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00006644 ; wchar_t `string'
.rdata:00006644 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00006644                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+1Eo
.rdata:00006644                 unicode 0, <vector subscript out of range>,0
.rdata:00006644 _rdata          ends
.rdata:00006644
.rdata:00006680 ; ===========================================================================
.rdata:00006680
.rdata:00006680 ; Segment type: Pure data
.rdata:00006680 ; Segment permissions: Read
.rdata:00006680 _rdata          segment dword public 'DATA' use32
.rdata:00006680                 assume cs:_rdata
.rdata:00006680                 ;org 6680h
.rdata:00006680 ; COMDAT (pick any)
.rdata:00006680                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00006680 ; `string'
.rdata:00006680 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00006680                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+2Bo
.rdata:00006680 _rdata          ends
.rdata:00006680
.rdata:000066A4 ; ===========================================================================
.rdata:000066A4
.rdata:000066A4 ; Segment type: Pure data
.rdata:000066A4 ; Segment permissions: Read
.rdata:000066A4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000066A4 _rdata          segment para public 'DATA' use32
.rdata:000066A4                 assume cs:_rdata
.rdata:000066A4                 ;org 66A4h
.rdata:000066A4 ; COMDAT (pick any)
.rdata:000066A4                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:000066A4 ; `string'
.rdata:000066A4 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:000066A4                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint):loc_3480o
.rdata:000066A4                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:000066FA                 align 4
.rdata:000066FA _rdata          ends
.rdata:000066FA
.rdata:000066FC ; ===========================================================================
.rdata:000066FC
.rdata:000066FC ; Segment type: Pure data
.rdata:000066FC ; Segment permissions: Read
.rdata:000066FC _rdata          segment dword public 'DATA' use32
.rdata:000066FC                 assume cs:_rdata
.rdata:000066FC                 ;org 66FCh
.rdata:000066FC ; COMDAT (pick any)
.rdata:000066FC                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:000066FC ; `string'
.rdata:000066FC ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:000066FC                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+3Do
.rdata:000066FC                 unicode 0, <%s>,0
.rdata:00006702                 align 4
.rdata:00006702 _rdata          ends
.rdata:00006702
.rdata:00006704 ; ===========================================================================
.rdata:00006704
.rdata:00006704 ; Segment type: Pure data
.rdata:00006704 ; Segment permissions: Read
.rdata:00006704 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00006704 _rdata          segment para public 'DATA' use32
.rdata:00006704                 assume cs:_rdata
.rdata:00006704                 ;org 6704h
.rdata:00006704 ; COMDAT (pick any)
.rdata:00006704                 public ??_C@_1LO@OIFNPDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAa?$AAs?$AAk?$AAL?$AAs?$AAt?$AAF?$AAn?$AAS?$AAt?$AAa?$AAt@
.rdata:00006704 ; `string'
.rdata:00006704 ??_C@_1LO@OIFNPDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAa?$AAs?$AAk?$AAL?$AAs?$AAt?$AAF?$AAn?$AAS?$AAt?$AAa?$AAt@:
.rdata:00006704                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+6Ao
.rdata:00006704                 unicode 0, <std::vector>
.rdata:00006704                 dw 3Ch
.rdata:00006704                 unicode 0, <struct TaskLstFnStatus,class std::allocator>
.rdata:00006704                 dw 3Ch
.rdata:00006704                 unicode 0, <struct TaskLstFnStatus>
.rdata:00006704                 dw 3Eh
.rdata:00006704                 unicode 0, < >
.rdata:00006704                 dw 3Eh
.rdata:00006704                 unicode 0, <::operator []>,0
.rdata:000067C2                 align 4
.rdata:000067C2 _rdata          ends
.rdata:000067C2
.rdata:000067C4 ; ===========================================================================
.rdata:000067C4
.rdata:000067C4 ; Segment type: Pure data
.rdata:000067C4 ; Segment permissions: Read
.rdata:000067C4 _rdata          segment dword public 'DATA' use32
.rdata:000067C4                 assume cs:_rdata
.rdata:000067C4                 ;org 67C4h
.rdata:000067C4 ; COMDAT (pick any)
.rdata:000067C4                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:000067C4 ; `string'
.rdata:000067C4 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:000067C4                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+6Fo
.rdata:000067C4                 unicode 0, <"out of range">,0
.rdata:000067E2                 align 4
.rdata:000067E2 _rdata          ends
.rdata:000067E2
.rdata:000067E4 ; ===========================================================================
.rdata:000067E4
.rdata:000067E4 ; Segment type: Pure data
.rdata:000067E4 ; Segment permissions: Read
.rdata:000067E4 _rdata          segment dword public 'DATA' use32
.rdata:000067E4                 assume cs:_rdata
.rdata:000067E4                 ;org 67E4h
.rdata:000067E4 ; COMDAT (pick any)
.rdata:000067E4                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000067E4 ; char `string'[]
.rdata:000067E4 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000067E4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000067E4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:000067E4 _rdata          ends
.rdata:000067E4
.rdata:000067F4 ; ===========================================================================
.rdata:000067F4
.rdata:000067F4 ; Segment type: Pure data
.rdata:000067F4 ; Segment permissions: Read
.rdata:000067F4 _rdata          segment dword public 'DATA' use32
.rdata:000067F4                 assume cs:_rdata
.rdata:000067F4                 ;org 67F4h
.rdata:000067F4 ; COMDAT (pick any)
.rdata:000067F4                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000067F4 ; char `string'[]
.rdata:000067F4 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000067F4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000067F4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:000067F4 _rdata          ends
.rdata:000067F4
.rdata:0000680C ; ===========================================================================
.rdata:0000680C
.rdata:0000680C ; Segment type: Pure data
.rdata:0000680C ; Segment permissions: Read
.rdata:0000680C _rdata          segment dword public 'DATA' use32
.rdata:0000680C                 assume cs:_rdata
.rdata:0000680C                 ;org 680Ch
.rdata:0000680C ; COMDAT (pick any)
.rdata:0000680C                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000680C ; char `string'[]
.rdata:0000680C ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000680C                                         ; DATA XREF: std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Xlen(void)+7o
.rdata:0000681F                 align 10h
.rdata:0000681F _rdata          ends
.rdata:0000681F
.rdata:00006820 ; ===========================================================================
.rdata:00006820
.rdata:00006820 ; Segment type: Pure data
.rdata:00006820 ; Segment permissions: Read
.rdata:00006820 _rdata          segment dword public 'DATA' use32
.rdata:00006820                 assume cs:_rdata
.rdata:00006820                 ;org 6820h
.rdata:00006820 ; COMDAT (pick any)
.rdata:00006820                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00006820 ; wchar_t `string'
.rdata:00006820 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00006820                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00006820                                         ; std::_Debug_pointer<SwitcherFileInfo>(SwitcherFileInfo *,wchar_t const *,uint)+11o ...
.rdata:00006820                 unicode 0, <invalid null pointer>,0
.rdata:0000684A                 align 4
.rdata:0000684A _rdata          ends
.rdata:0000684A
.rdata:0000684C ; ===========================================================================
.rdata:0000684C
.rdata:0000684C ; Segment type: Pure data
.rdata:0000684C ; Segment permissions: Read
.rdata:0000684C _rdata          segment dword public 'DATA' use32
.rdata:0000684C                 assume cs:_rdata
.rdata:0000684C                 ;org 684Ch
.rdata:0000684C ; COMDAT (pick any)
.rdata:0000684C                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000684C ; wchar_t `string'
.rdata:0000684C ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000684C                                         ; DATA XREF: std::_Debug_range2<SwitcherFileInfo *>(SwitcherFileInfo *,SwitcherFileInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000684C                 unicode 0, <invalid iterator range>,0
.rdata:0000687A                 align 4
.rdata:0000687A _rdata          ends
.rdata:0000687A
.rdata:0000687C ; ===========================================================================
.rdata:0000687C
.rdata:0000687C ; Segment type: Pure data
.rdata:0000687C ; Segment permissions: Read
.rdata:0000687C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000687C _rdata          segment para public 'DATA' use32
.rdata:0000687C                 assume cs:_rdata
.rdata:0000687C                 ;org 687Ch
.rdata:0000687C ; COMDAT (pick any)
.rdata:0000687C                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000687C ; wchar_t `string'
.rdata:0000687C ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000687C                                         ; DATA XREF: std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+2Fo
.rdata:0000687C                                         ; std::_Uninit_move<SwitcherFileInfo *,SwitcherFileInfo *,std::allocator<SwitcherFileInfo>,SwitcherFileInfo>(SwitcherFileInfo *,SwitcherFileInfo *,SwitcherFileInfo *,std::_Wrap_alloc<std::allocator<SwitcherFileInfo>> &,SwitcherFileInfo *,std::_Nonscalar_ptr_iterator_tag)+49o
.rdata:0000687C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000687C                 unicode 0, <clude\xmemory>,0
.rdata:0000690A                 align 4
.rdata:0000690A _rdata          ends
.rdata:0000690A
.rdata$r:0000690C ; ===========================================================================
.rdata$r:0000690C
.rdata$r:0000690C ; Segment type: Pure data
.rdata$r:0000690C ; Segment permissions: Read
.rdata$r:0000690C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000690C                 assume cs:_rdata$r
.rdata$r:0000690C                 ;org 690Ch
.rdata$r:0000690C ; COMDAT (pick any)
.rdata$r:0000690C                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0000690C ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000690C ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:0000690C                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:0000690C                                         ; .rdata$r:00006968o
.rdata$r:0000690C                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00006910                 db    0
.rdata$r:00006911                 db    0
.rdata$r:00006912                 db    0
.rdata$r:00006913                 db    0
.rdata$r:00006914                 db    0
.rdata$r:00006915                 db    0
.rdata$r:00006916                 db    0
.rdata$r:00006917                 db    0
.rdata$r:00006918                 db 0FFh
.rdata$r:00006919                 db 0FFh
.rdata$r:0000691A                 db 0FFh
.rdata$r:0000691B                 db 0FFh
.rdata$r:0000691C                 db    0
.rdata$r:0000691D                 db    0
.rdata$r:0000691E                 db    0
.rdata$r:0000691F                 db    0
.rdata$r:00006920                 db  40h ; @
.rdata$r:00006921                 db    0
.rdata$r:00006922                 db    0
.rdata$r:00006923                 db    0
.rdata$r:00006924                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006924 _rdata$r        ends
.rdata$r:00006924
.rdata$r:00006928 ; ===========================================================================
.rdata$r:00006928
.rdata$r:00006928 ; Segment type: Pure data
.rdata$r:00006928 ; Segment permissions: Read
.rdata$r:00006928 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006928                 assume cs:_rdata$r
.rdata$r:00006928                 ;org 6928h
.rdata$r:00006928 ; COMDAT (pick any)
.rdata$r:00006928                 public ??_R3exception@std@@8
.rdata$r:00006928 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006928 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00006924o
.rdata$r:00006929                 db    0
.rdata$r:0000692A                 db    0
.rdata$r:0000692B                 db    0
.rdata$r:0000692C                 db    0
.rdata$r:0000692D                 db    0
.rdata$r:0000692E                 db    0
.rdata$r:0000692F                 db    0
.rdata$r:00006930                 db    1
.rdata$r:00006931                 db    0
.rdata$r:00006932                 db    0
.rdata$r:00006933                 db    0
.rdata$r:00006934                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00006934 _rdata$r        ends
.rdata$r:00006934
.rdata$r:00006938 ; ===========================================================================
.rdata$r:00006938
.rdata$r:00006938 ; Segment type: Pure data
.rdata$r:00006938 ; Segment permissions: Read
.rdata$r:00006938 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006938                 assume cs:_rdata$r
.rdata$r:00006938                 ;org 6938h
.rdata$r:00006938 ; COMDAT (pick any)
.rdata$r:00006938                 public ??_R2exception@std@@8
.rdata$r:00006938 ; std::exception::`RTTI Base Class Array'
.rdata$r:00006938 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00006938                                         ; DATA XREF: .rdata$r:00006934o
.rdata$r:00006938                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000693C                 db    0
.rdata$r:0000693D                 align 10h
.rdata$r:0000693D _rdata$r        ends
.rdata$r:0000693D
.rdata$r:00006940 ; ===========================================================================
.rdata$r:00006940
.rdata$r:00006940 ; Segment type: Pure data
.rdata$r:00006940 ; Segment permissions: Read
.rdata$r:00006940 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006940                 assume cs:_rdata$r
.rdata$r:00006940                 ;org 6940h
.rdata$r:00006940 ; COMDAT (pick any)
.rdata$r:00006940                 public ??_R4runtime_error@std@@6B@
.rdata$r:00006940 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00006940 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:000063B0o
.rdata$r:00006941                 db    0
.rdata$r:00006942                 db    0
.rdata$r:00006943                 db    0
.rdata$r:00006944                 db    0
.rdata$r:00006945                 db    0
.rdata$r:00006946                 db    0
.rdata$r:00006947                 db    0
.rdata$r:00006948                 db    0
.rdata$r:00006949                 db    0
.rdata$r:0000694A                 db    0
.rdata$r:0000694B                 db    0
.rdata$r:0000694C                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00006950                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006950 _rdata$r        ends
.rdata$r:00006950
.rdata$r:00006954 ; ===========================================================================
.rdata$r:00006954
.rdata$r:00006954 ; Segment type: Pure data
.rdata$r:00006954 ; Segment permissions: Read
.rdata$r:00006954 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006954                 assume cs:_rdata$r
.rdata$r:00006954                 ;org 6954h
.rdata$r:00006954 ; COMDAT (pick any)
.rdata$r:00006954                 public ??_R3runtime_error@std@@8
.rdata$r:00006954 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006954 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00006950o
.rdata$r:00006954                                         ; .rdata$r:00006988o
.rdata$r:00006955                 db    0
.rdata$r:00006956                 db    0
.rdata$r:00006957                 db    0
.rdata$r:00006958                 db    0
.rdata$r:00006959                 db    0
.rdata$r:0000695A                 db    0
.rdata$r:0000695B                 db    0
.rdata$r:0000695C                 db    2
.rdata$r:0000695D                 db    0
.rdata$r:0000695E                 db    0
.rdata$r:0000695F                 db    0
.rdata$r:00006960                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00006960 _rdata$r        ends
.rdata$r:00006960
.rdata$r:00006964 ; ===========================================================================
.rdata$r:00006964
.rdata$r:00006964 ; Segment type: Pure data
.rdata$r:00006964 ; Segment permissions: Read
.rdata$r:00006964 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006964                 assume cs:_rdata$r
.rdata$r:00006964                 ;org 6964h
.rdata$r:00006964 ; COMDAT (pick any)
.rdata$r:00006964                 public ??_R2runtime_error@std@@8
.rdata$r:00006964 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00006964 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00006964                                         ; DATA XREF: .rdata$r:00006960o
.rdata$r:00006964                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006968                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000696C                 db    0
.rdata$r:0000696D                 align 10h
.rdata$r:0000696D _rdata$r        ends
.rdata$r:0000696D
.rdata$r:00006970 ; ===========================================================================
.rdata$r:00006970
.rdata$r:00006970 ; Segment type: Pure data
.rdata$r:00006970 ; Segment permissions: Read
.rdata$r:00006970 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006970                 assume cs:_rdata$r
.rdata$r:00006970                 ;org 6970h
.rdata$r:00006970 ; COMDAT (pick any)
.rdata$r:00006970                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00006970 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006970 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00006970                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00006970                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00006974                 db    1
.rdata$r:00006975                 db    0
.rdata$r:00006976                 db    0
.rdata$r:00006977                 db    0
.rdata$r:00006978                 db    0
.rdata$r:00006979                 db    0
.rdata$r:0000697A                 db    0
.rdata$r:0000697B                 db    0
.rdata$r:0000697C                 db 0FFh
.rdata$r:0000697D                 db 0FFh
.rdata$r:0000697E                 db 0FFh
.rdata$r:0000697F                 db 0FFh
.rdata$r:00006980                 db    0
.rdata$r:00006981                 db    0
.rdata$r:00006982                 db    0
.rdata$r:00006983                 db    0
.rdata$r:00006984                 db  40h ; @
.rdata$r:00006985                 db    0
.rdata$r:00006986                 db    0
.rdata$r:00006987                 db    0
.rdata$r:00006988                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006988 _rdata$r        ends
.rdata$r:00006988
.rdata$r:0000698C ; ===========================================================================
.rdata$r:0000698C
.rdata$r:0000698C ; Segment type: Pure data
.rdata$r:0000698C ; Segment permissions: Read
.rdata$r:0000698C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000698C                 assume cs:_rdata$r
.rdata$r:0000698C                 ;org 698Ch
.rdata$r:0000698C ; COMDAT (pick any)
.rdata$r:0000698C                 public ??_R4error_category@std@@6B@
.rdata$r:0000698C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000698C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000644Co
.rdata$r:0000698D                 db    0
.rdata$r:0000698E                 db    0
.rdata$r:0000698F                 db    0
.rdata$r:00006990                 db    0
.rdata$r:00006991                 db    0
.rdata$r:00006992                 db    0
.rdata$r:00006993                 db    0
.rdata$r:00006994                 db    0
.rdata$r:00006995                 db    0
.rdata$r:00006996                 db    0
.rdata$r:00006997                 db    0
.rdata$r:00006998                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000699C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000699C _rdata$r        ends
.rdata$r:0000699C
.data$r:000069A0 ; ===========================================================================
.data$r:000069A0
.data$r:000069A0 ; Segment type: Pure data
.data$r:000069A0 ; Segment permissions: Read/Write
.data$r:000069A0 _data$r         segment dword public 'DATA' use32
.data$r:000069A0                 assume cs:_data$r
.data$r:000069A0                 ;org 69A0h
.data$r:000069A0 ; COMDAT (pick any)
.data$r:000069A0                 public ??_R0?AVerror_category@std@@@8
.data$r:000069A0 ; class std::error_category `RTTI Type Descriptor'
.data$r:000069A0 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000069A0                                         ; DATA XREF: .rdata$r:00006998o
.data$r:000069A0                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000069A0                                         ; const type_info::`vftable'
.data$r:000069A4                 align 8
.data$r:000069A8 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:000069C1                 align 4
.data$r:000069C1 _data$r         ends
.data$r:000069C1
.rdata$r:000069C4 ; ===========================================================================
.rdata$r:000069C4
.rdata$r:000069C4 ; Segment type: Pure data
.rdata$r:000069C4 ; Segment permissions: Read
.rdata$r:000069C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069C4                 assume cs:_rdata$r
.rdata$r:000069C4                 ;org 69C4h
.rdata$r:000069C4 ; COMDAT (pick any)
.rdata$r:000069C4                 public ??_R3error_category@std@@8
.rdata$r:000069C4 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000069C4 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000699Co
.rdata$r:000069C4                                         ; .rdata$r:000069F4o
.rdata$r:000069C5                 db    0
.rdata$r:000069C6                 db    0
.rdata$r:000069C7                 db    0
.rdata$r:000069C8                 db    0
.rdata$r:000069C9                 db    0
.rdata$r:000069CA                 db    0
.rdata$r:000069CB                 db    0
.rdata$r:000069CC                 db    1
.rdata$r:000069CD                 db    0
.rdata$r:000069CE                 db    0
.rdata$r:000069CF                 db    0
.rdata$r:000069D0                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000069D0 _rdata$r        ends
.rdata$r:000069D0
.rdata$r:000069D4 ; ===========================================================================
.rdata$r:000069D4
.rdata$r:000069D4 ; Segment type: Pure data
.rdata$r:000069D4 ; Segment permissions: Read
.rdata$r:000069D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069D4                 assume cs:_rdata$r
.rdata$r:000069D4                 ;org 69D4h
.rdata$r:000069D4 ; COMDAT (pick any)
.rdata$r:000069D4                 public ??_R2error_category@std@@8
.rdata$r:000069D4 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000069D4 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000069D4                                         ; DATA XREF: .rdata$r:000069D0o
.rdata$r:000069D4                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000069D8                 db    0
.rdata$r:000069D9                 align 4
.rdata$r:000069D9 _rdata$r        ends
.rdata$r:000069D9
.rdata$r:000069DC ; ===========================================================================
.rdata$r:000069DC
.rdata$r:000069DC ; Segment type: Pure data
.rdata$r:000069DC ; Segment permissions: Read
.rdata$r:000069DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069DC                 assume cs:_rdata$r
.rdata$r:000069DC                 ;org 69DCh
.rdata$r:000069DC ; COMDAT (pick any)
.rdata$r:000069DC                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000069DC ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000069DC ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000069DC                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000069DC                                         ; .rdata$r:00006A4Co ...
.rdata$r:000069DC                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000069E0                 db    0
.rdata$r:000069E1                 db    0
.rdata$r:000069E2                 db    0
.rdata$r:000069E3                 db    0
.rdata$r:000069E4                 db    0
.rdata$r:000069E5                 db    0
.rdata$r:000069E6                 db    0
.rdata$r:000069E7                 db    0
.rdata$r:000069E8                 db 0FFh
.rdata$r:000069E9                 db 0FFh
.rdata$r:000069EA                 db 0FFh
.rdata$r:000069EB                 db 0FFh
.rdata$r:000069EC                 db    0
.rdata$r:000069ED                 db    0
.rdata$r:000069EE                 db    0
.rdata$r:000069EF                 db    0
.rdata$r:000069F0                 db  40h ; @
.rdata$r:000069F1                 db    0
.rdata$r:000069F2                 db    0
.rdata$r:000069F3                 db    0
.rdata$r:000069F4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000069F4 _rdata$r        ends
.rdata$r:000069F4
.rdata$r:000069F8 ; ===========================================================================
.rdata$r:000069F8
.rdata$r:000069F8 ; Segment type: Pure data
.rdata$r:000069F8 ; Segment permissions: Read
.rdata$r:000069F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069F8                 assume cs:_rdata$r
.rdata$r:000069F8                 ;org 69F8h
.rdata$r:000069F8 ; COMDAT (pick any)
.rdata$r:000069F8                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000069F8 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000069F8 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000069F8                                         ; DATA XREF: .rdata:00006468o
.rdata$r:000069F9                 db    0
.rdata$r:000069FA                 db    0
.rdata$r:000069FB                 db    0
.rdata$r:000069FC                 db    0
.rdata$r:000069FD                 db    0
.rdata$r:000069FE                 db    0
.rdata$r:000069FF                 db    0
.rdata$r:00006A00                 db    0
.rdata$r:00006A01                 db    0
.rdata$r:00006A02                 db    0
.rdata$r:00006A03                 db    0
.rdata$r:00006A04                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00006A08                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A08 _rdata$r        ends
.rdata$r:00006A08
.data$r:00006A0C ; ===========================================================================
.data$r:00006A0C
.data$r:00006A0C ; Segment type: Pure data
.data$r:00006A0C ; Segment permissions: Read/Write
.data$r:00006A0C _data$r         segment dword public 'DATA' use32
.data$r:00006A0C                 assume cs:_data$r
.data$r:00006A0C                 ;org 6A0Ch
.data$r:00006A0C ; COMDAT (pick any)
.data$r:00006A0C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00006A0C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00006A0C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00006A0C                                         ; DATA XREF: .rdata$r:00006A04o
.data$r:00006A0C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00006A0C                                         ; const type_info::`vftable'
.data$r:00006A10                 db    0
.data$r:00006A11                 db    0
.data$r:00006A12                 db    0
.data$r:00006A13                 db    0
.data$r:00006A14                 db  2Eh ; .
.data$r:00006A15                 db  3Fh ; ?
.data$r:00006A16                 db  41h ; A
.data$r:00006A17                 db  56h ; V
.data$r:00006A18                 db  5Fh ; _
.data$r:00006A19                 db  47h ; G
.data$r:00006A1A                 db  65h ; e
.data$r:00006A1B                 db  6Eh ; n
.data$r:00006A1C                 db  65h ; e
.data$r:00006A1D                 db  72h ; r
.data$r:00006A1E                 db  69h ; i
.data$r:00006A1F                 db  63h ; c
.data$r:00006A20                 db  5Fh ; _
.data$r:00006A21                 db  65h ; e
.data$r:00006A22                 db  72h ; r
.data$r:00006A23                 db  72h ; r
.data$r:00006A24                 db  6Fh ; o
.data$r:00006A25                 db  72h ; r
.data$r:00006A26                 db  5Fh ; _
.data$r:00006A27                 db  63h ; c
.data$r:00006A28                 db  61h ; a
.data$r:00006A29                 db  74h ; t
.data$r:00006A2A                 db  65h ; e
.data$r:00006A2B                 db  67h ; g
.data$r:00006A2C                 db  6Fh ; o
.data$r:00006A2D                 db  72h ; r
.data$r:00006A2E                 db  79h ; y
.data$r:00006A2F                 db  40h ; @
.data$r:00006A30                 db  73h ; s
.data$r:00006A31                 db  74h ; t
.data$r:00006A32                 db  64h ; d
.data$r:00006A33                 db  40h ; @
.data$r:00006A34                 db  40h ; @
.data$r:00006A35                 db    0
.data$r:00006A36                 align 4
.data$r:00006A36 _data$r         ends
.data$r:00006A36
.rdata$r:00006A38 ; ===========================================================================
.rdata$r:00006A38
.rdata$r:00006A38 ; Segment type: Pure data
.rdata$r:00006A38 ; Segment permissions: Read
.rdata$r:00006A38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A38                 assume cs:_rdata$r
.rdata$r:00006A38                 ;org 6A38h
.rdata$r:00006A38 ; COMDAT (pick any)
.rdata$r:00006A38                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00006A38 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A38 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00006A38                                         ; DATA XREF: .rdata$r:00006A08o
.rdata$r:00006A38                                         ; .rdata$r:00006A6Co
.rdata$r:00006A39                 db    0
.rdata$r:00006A3A                 db    0
.rdata$r:00006A3B                 db    0
.rdata$r:00006A3C                 db    0
.rdata$r:00006A3D                 db    0
.rdata$r:00006A3E                 db    0
.rdata$r:00006A3F                 db    0
.rdata$r:00006A40                 db    2
.rdata$r:00006A41                 db    0
.rdata$r:00006A42                 db    0
.rdata$r:00006A43                 db    0
.rdata$r:00006A44                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00006A44 _rdata$r        ends
.rdata$r:00006A44
.rdata$r:00006A48 ; ===========================================================================
.rdata$r:00006A48
.rdata$r:00006A48 ; Segment type: Pure data
.rdata$r:00006A48 ; Segment permissions: Read
.rdata$r:00006A48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A48                 assume cs:_rdata$r
.rdata$r:00006A48                 ;org 6A48h
.rdata$r:00006A48 ; COMDAT (pick any)
.rdata$r:00006A48                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00006A48 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00006A48 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00006A48                                         ; DATA XREF: .rdata$r:00006A44o
.rdata$r:00006A48                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006A4C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006A50                 db    0
.rdata$r:00006A51                 align 4
.rdata$r:00006A51 _rdata$r        ends
.rdata$r:00006A51
.rdata$r:00006A54 ; ===========================================================================
.rdata$r:00006A54
.rdata$r:00006A54 ; Segment type: Pure data
.rdata$r:00006A54 ; Segment permissions: Read
.rdata$r:00006A54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A54                 assume cs:_rdata$r
.rdata$r:00006A54                 ;org 6A54h
.rdata$r:00006A54 ; COMDAT (pick any)
.rdata$r:00006A54                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00006A54 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006A54 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00006A54                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00006A54                                         ; .rdata$r:00006AC4o ...
.rdata$r:00006A54                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00006A58                 db    1
.rdata$r:00006A59                 db    0
.rdata$r:00006A5A                 db    0
.rdata$r:00006A5B                 db    0
.rdata$r:00006A5C                 db    0
.rdata$r:00006A5D                 db    0
.rdata$r:00006A5E                 db    0
.rdata$r:00006A5F                 db    0
.rdata$r:00006A60                 db 0FFh
.rdata$r:00006A61                 db 0FFh
.rdata$r:00006A62                 db 0FFh
.rdata$r:00006A63                 db 0FFh
.rdata$r:00006A64                 db    0
.rdata$r:00006A65                 db    0
.rdata$r:00006A66                 db    0
.rdata$r:00006A67                 db    0
.rdata$r:00006A68                 db  40h ; @
.rdata$r:00006A69                 db    0
.rdata$r:00006A6A                 db    0
.rdata$r:00006A6B                 db    0
.rdata$r:00006A6C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A6C _rdata$r        ends
.rdata$r:00006A6C
.rdata$r:00006A70 ; ===========================================================================
.rdata$r:00006A70
.rdata$r:00006A70 ; Segment type: Pure data
.rdata$r:00006A70 ; Segment permissions: Read
.rdata$r:00006A70 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A70                 assume cs:_rdata$r
.rdata$r:00006A70                 ;org 6A70h
.rdata$r:00006A70 ; COMDAT (pick any)
.rdata$r:00006A70                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00006A70 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00006A70 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00006A70                                         ; DATA XREF: .rdata:0000649Co
.rdata$r:00006A71                 db    0
.rdata$r:00006A72                 db    0
.rdata$r:00006A73                 db    0
.rdata$r:00006A74                 db    0
.rdata$r:00006A75                 db    0
.rdata$r:00006A76                 db    0
.rdata$r:00006A77                 db    0
.rdata$r:00006A78                 db    0
.rdata$r:00006A79                 db    0
.rdata$r:00006A7A                 db    0
.rdata$r:00006A7B                 db    0
.rdata$r:00006A7C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00006A80                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A80 _rdata$r        ends
.rdata$r:00006A80
.data$r:00006A84 ; ===========================================================================
.data$r:00006A84
.data$r:00006A84 ; Segment type: Pure data
.data$r:00006A84 ; Segment permissions: Read/Write
.data$r:00006A84 _data$r         segment dword public 'DATA' use32
.data$r:00006A84                 assume cs:_data$r
.data$r:00006A84                 ;org 6A84h
.data$r:00006A84 ; COMDAT (pick any)
.data$r:00006A84                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00006A84 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00006A84 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00006A84                                         ; DATA XREF: .rdata$r:00006A7Co
.data$r:00006A84                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00006A84                                         ; const type_info::`vftable'
.data$r:00006A88                 db    0
.data$r:00006A89                 db    0
.data$r:00006A8A                 db    0
.data$r:00006A8B                 db    0
.data$r:00006A8C                 db  2Eh ; .
.data$r:00006A8D                 db  3Fh ; ?
.data$r:00006A8E                 db  41h ; A
.data$r:00006A8F                 db  56h ; V
.data$r:00006A90                 db  5Fh ; _
.data$r:00006A91                 db  49h ; I
.data$r:00006A92                 db  6Fh ; o
.data$r:00006A93                 db  73h ; s
.data$r:00006A94                 db  74h ; t
.data$r:00006A95                 db  72h ; r
.data$r:00006A96                 db  65h ; e
.data$r:00006A97                 db  61h ; a
.data$r:00006A98                 db  6Dh ; m
.data$r:00006A99                 db  5Fh ; _
.data$r:00006A9A                 db  65h ; e
.data$r:00006A9B                 db  72h ; r
.data$r:00006A9C                 db  72h ; r
.data$r:00006A9D                 db  6Fh ; o
.data$r:00006A9E                 db  72h ; r
.data$r:00006A9F                 db  5Fh ; _
.data$r:00006AA0                 db  63h ; c
.data$r:00006AA1                 db  61h ; a
.data$r:00006AA2                 db  74h ; t
.data$r:00006AA3                 db  65h ; e
.data$r:00006AA4                 db  67h ; g
.data$r:00006AA5                 db  6Fh ; o
.data$r:00006AA6                 db  72h ; r
.data$r:00006AA7                 db  79h ; y
.data$r:00006AA8                 db  40h ; @
.data$r:00006AA9                 db  73h ; s
.data$r:00006AAA                 db  74h ; t
.data$r:00006AAB                 db  64h ; d
.data$r:00006AAC                 db  40h ; @
.data$r:00006AAD                 db  40h ; @
.data$r:00006AAE                 db    0
.data$r:00006AAF                 align 10h
.data$r:00006AAF _data$r         ends
.data$r:00006AAF
.rdata$r:00006AB0 ; ===========================================================================
.rdata$r:00006AB0
.rdata$r:00006AB0 ; Segment type: Pure data
.rdata$r:00006AB0 ; Segment permissions: Read
.rdata$r:00006AB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AB0                 assume cs:_rdata$r
.rdata$r:00006AB0                 ;org 6AB0h
.rdata$r:00006AB0 ; COMDAT (pick any)
.rdata$r:00006AB0                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00006AB0 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006AB0 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00006AB0                                         ; DATA XREF: .rdata$r:00006A80o
.rdata$r:00006AB0                                         ; .rdata$r:00006AE8o
.rdata$r:00006AB1                 db    0
.rdata$r:00006AB2                 db    0
.rdata$r:00006AB3                 db    0
.rdata$r:00006AB4                 db    0
.rdata$r:00006AB5                 db    0
.rdata$r:00006AB6                 db    0
.rdata$r:00006AB7                 db    0
.rdata$r:00006AB8                 db    3
.rdata$r:00006AB9                 db    0
.rdata$r:00006ABA                 db    0
.rdata$r:00006ABB                 db    0
.rdata$r:00006ABC                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00006ABC _rdata$r        ends
.rdata$r:00006ABC
.rdata$r:00006AC0 ; ===========================================================================
.rdata$r:00006AC0
.rdata$r:00006AC0 ; Segment type: Pure data
.rdata$r:00006AC0 ; Segment permissions: Read
.rdata$r:00006AC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AC0                 assume cs:_rdata$r
.rdata$r:00006AC0                 ;org 6AC0h
.rdata$r:00006AC0 ; COMDAT (pick any)
.rdata$r:00006AC0                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00006AC0 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00006AC0 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00006AC0                                         ; DATA XREF: .rdata$r:00006ABCo
.rdata$r:00006AC0                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006AC4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006AC8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006ACC                 db    0
.rdata$r:00006ACD                 align 10h
.rdata$r:00006ACD _rdata$r        ends
.rdata$r:00006ACD
.rdata$r:00006AD0 ; ===========================================================================
.rdata$r:00006AD0
.rdata$r:00006AD0 ; Segment type: Pure data
.rdata$r:00006AD0 ; Segment permissions: Read
.rdata$r:00006AD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AD0                 assume cs:_rdata$r
.rdata$r:00006AD0                 ;org 6AD0h
.rdata$r:00006AD0 ; COMDAT (pick any)
.rdata$r:00006AD0                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00006AD0 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006AD0 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00006AD0                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00006AD0                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00006AD4                 db    2
.rdata$r:00006AD5                 db    0
.rdata$r:00006AD6                 db    0
.rdata$r:00006AD7                 db    0
.rdata$r:00006AD8                 db    0
.rdata$r:00006AD9                 db    0
.rdata$r:00006ADA                 db    0
.rdata$r:00006ADB                 db    0
.rdata$r:00006ADC                 db 0FFh
.rdata$r:00006ADD                 db 0FFh
.rdata$r:00006ADE                 db 0FFh
.rdata$r:00006ADF                 db 0FFh
.rdata$r:00006AE0                 db    0
.rdata$r:00006AE1                 db    0
.rdata$r:00006AE2                 db    0
.rdata$r:00006AE3                 db    0
.rdata$r:00006AE4                 db  40h ; @
.rdata$r:00006AE5                 db    0
.rdata$r:00006AE6                 db    0
.rdata$r:00006AE7                 db    0
.rdata$r:00006AE8                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006AE8 _rdata$r        ends
.rdata$r:00006AE8
.rdata$r:00006AEC ; ===========================================================================
.rdata$r:00006AEC
.rdata$r:00006AEC ; Segment type: Pure data
.rdata$r:00006AEC ; Segment permissions: Read
.rdata$r:00006AEC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AEC                 assume cs:_rdata$r
.rdata$r:00006AEC                 ;org 6AECh
.rdata$r:00006AEC ; COMDAT (pick any)
.rdata$r:00006AEC                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00006AEC ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00006AEC ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:000064DCo
.rdata$r:00006AED                 db    0
.rdata$r:00006AEE                 db    0
.rdata$r:00006AEF                 db    0
.rdata$r:00006AF0                 db    0
.rdata$r:00006AF1                 db    0
.rdata$r:00006AF2                 db    0
.rdata$r:00006AF3                 db    0
.rdata$r:00006AF4                 db    0
.rdata$r:00006AF5                 db    0
.rdata$r:00006AF6                 db    0
.rdata$r:00006AF7                 db    0
.rdata$r:00006AF8                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00006AFC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006AFC _rdata$r        ends
.rdata$r:00006AFC
.data$r:00006B00 ; ===========================================================================
.data$r:00006B00
.data$r:00006B00 ; Segment type: Pure data
.data$r:00006B00 ; Segment permissions: Read/Write
.data$r:00006B00 _data$r         segment dword public 'DATA' use32
.data$r:00006B00                 assume cs:_data$r
.data$r:00006B00                 ;org 6B00h
.data$r:00006B00 ; COMDAT (pick any)
.data$r:00006B00                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00006B00 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00006B00 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00006B00                                         ; DATA XREF: .rdata$r:00006AF8o
.data$r:00006B00                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00006B00                                         ; const type_info::`vftable'
.data$r:00006B04                 align 8
.data$r:00006B08 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00006B29                 align 4
.data$r:00006B29 _data$r         ends
.data$r:00006B29
.rdata$r:00006B2C ; ===========================================================================
.rdata$r:00006B2C
.rdata$r:00006B2C ; Segment type: Pure data
.rdata$r:00006B2C ; Segment permissions: Read
.rdata$r:00006B2C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006B2C                 assume cs:_rdata$r
.rdata$r:00006B2C                 ;org 6B2Ch
.rdata$r:00006B2C ; COMDAT (pick any)
.rdata$r:00006B2C                 public ??_R3_System_error_category@std@@8
.rdata$r:00006B2C ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006B2C ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00006AFCo
.rdata$r:00006B2C                                         ; .rdata$r:00006B64o
.rdata$r:00006B2D                 db    0
.rdata$r:00006B2E                 db    0
.rdata$r:00006B2F                 db    0
.rdata$r:00006B30                 db    0
.rdata$r:00006B31                 db    0
.rdata$r:00006B32                 db    0
.rdata$r:00006B33                 db    0
.rdata$r:00006B34                 db    3
.rdata$r:00006B35                 db    0
.rdata$r:00006B36                 db    0
.rdata$r:00006B37                 db    0
.rdata$r:00006B38                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00006B38 _rdata$r        ends
.rdata$r:00006B38
.rdata$r:00006B3C ; ===========================================================================
.rdata$r:00006B3C
.rdata$r:00006B3C ; Segment type: Pure data
.rdata$r:00006B3C ; Segment permissions: Read
.rdata$r:00006B3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006B3C                 assume cs:_rdata$r
.rdata$r:00006B3C                 ;org 6B3Ch
.rdata$r:00006B3C ; COMDAT (pick any)
.rdata$r:00006B3C                 public ??_R2_System_error_category@std@@8
.rdata$r:00006B3C ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00006B3C ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00006B3C                                         ; DATA XREF: .rdata$r:00006B38o
.rdata$r:00006B3C                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006B40                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006B44                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006B48                 db    0
.rdata$r:00006B49                 align 4
.rdata$r:00006B49 _rdata$r        ends
.rdata$r:00006B49
.rdata$r:00006B4C ; ===========================================================================
.rdata$r:00006B4C
.rdata$r:00006B4C ; Segment type: Pure data
.rdata$r:00006B4C ; Segment permissions: Read
.rdata$r:00006B4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006B4C                 assume cs:_rdata$r
.rdata$r:00006B4C                 ;org 6B4Ch
.rdata$r:00006B4C ; COMDAT (pick any)
.rdata$r:00006B4C                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00006B4C ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006B4C ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00006B4C                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00006B4C                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00006B50                 db    2
.rdata$r:00006B51                 db    0
.rdata$r:00006B52                 db    0
.rdata$r:00006B53                 db    0
.rdata$r:00006B54                 db    0
.rdata$r:00006B55                 db    0
.rdata$r:00006B56                 db    0
.rdata$r:00006B57                 db    0
.rdata$r:00006B58                 db 0FFh
.rdata$r:00006B59                 db 0FFh
.rdata$r:00006B5A                 db 0FFh
.rdata$r:00006B5B                 db 0FFh
.rdata$r:00006B5C                 db    0
.rdata$r:00006B5D                 db    0
.rdata$r:00006B5E                 db    0
.rdata$r:00006B5F                 db    0
.rdata$r:00006B60                 db  40h ; @
.rdata$r:00006B61                 db    0
.rdata$r:00006B62                 db    0
.rdata$r:00006B63                 db    0
.rdata$r:00006B64                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006B64 _rdata$r        ends
.rdata$r:00006B64
.CRT$XCU:00006B68 ; ===========================================================================
.CRT$XCU:00006B68
.CRT$XCU:00006B68 ; Segment type: Pure data
.CRT$XCU:00006B68 ; Segment permissions: Read
.CRT$XCU:00006B68 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B68                 assume cs:_CRT$XCU
.CRT$XCU:00006B68                 ;org 6B68h
.CRT$XCU:00006B68 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00006B6C _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00006B6C _CRT$XCU        ends
.CRT$XCU:00006B6C
.CRT$XCU:00006B70 ; ===========================================================================
.CRT$XCU:00006B70
.CRT$XCU:00006B70 ; Segment type: Pure data
.CRT$XCU:00006B70 ; Segment permissions: Read
.CRT$XCU:00006B70 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B70                 assume cs:_CRT$XCU
.CRT$XCU:00006B70                 ;org 6B70h
.CRT$XCU:00006B70 ; COMDAT (pick associative to section at 6500)
.CRT$XCU:00006B70 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00006B70 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00006B70 _CRT$XCU        ends
.CRT$XCU:00006B70
.CRT$XCU:00006B74 ; ===========================================================================
.CRT$XCU:00006B74
.CRT$XCU:00006B74 ; Segment type: Pure data
.CRT$XCU:00006B74 ; Segment permissions: Read
.CRT$XCU:00006B74 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B74                 assume cs:_CRT$XCU
.CRT$XCU:00006B74                 ;org 6B74h
.CRT$XCU:00006B74 ; COMDAT (pick associative to section at 6504)
.CRT$XCU:00006B74 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00006B74 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00006B74 _CRT$XCU        ends
.CRT$XCU:00006B74
.CRT$XCU:00006B78 ; ===========================================================================
.CRT$XCU:00006B78
.CRT$XCU:00006B78 ; Segment type: Pure data
.CRT$XCU:00006B78 ; Segment permissions: Read
.CRT$XCU:00006B78 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B78                 assume cs:_CRT$XCU
.CRT$XCU:00006B78                 ;org 6B78h
.CRT$XCU:00006B78 ; COMDAT (pick associative to section at 6508)
.CRT$XCU:00006B78 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00006B78 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00006B78 _CRT$XCU        ends
.CRT$XCU:00006B78
.CRT$XCU:00006B7C ; ===========================================================================
.CRT$XCU:00006B7C
.CRT$XCU:00006B7C ; Segment type: Pure data
.CRT$XCU:00006B7C ; Segment permissions: Read
.CRT$XCU:00006B7C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B7C                 assume cs:_CRT$XCU
.CRT$XCU:00006B7C                 ;org 6B7Ch
.CRT$XCU:00006B7C ; COMDAT (pick associative to section at 6510)
.CRT$XCU:00006B7C ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00006B7C ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00006B7C _CRT$XCU        ends
.CRT$XCU:00006B7C
.CRT$XCU:00006B80 ; ===========================================================================
.CRT$XCU:00006B80
.CRT$XCU:00006B80 ; Segment type: Pure data
.CRT$XCU:00006B80 ; Segment permissions: Read
.CRT$XCU:00006B80 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B80                 assume cs:_CRT$XCU
.CRT$XCU:00006B80                 ;org 6B80h
.CRT$XCU:00006B80 ; COMDAT (pick associative to section at 6514)
.CRT$XCU:00006B80 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00006B80 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00006B80 _CRT$XCU        ends
.CRT$XCU:00006B80
.CRT$XCU:00006B84 ; ===========================================================================
.CRT$XCU:00006B84
.CRT$XCU:00006B84 ; Segment type: Pure data
.CRT$XCU:00006B84 ; Segment permissions: Read
.CRT$XCU:00006B84 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B84                 assume cs:_CRT$XCU
.CRT$XCU:00006B84                 ;org 6B84h
.CRT$XCU:00006B84 ; COMDAT (pick associative to section at 65B0)
.CRT$XCU:00006B84 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00006B84 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00006B84 _CRT$XCU        ends
.CRT$XCU:00006B84
.CRT$XCU:00006B88 ; ===========================================================================
.CRT$XCU:00006B88
.CRT$XCU:00006B88 ; Segment type: Pure data
.CRT$XCU:00006B88 ; Segment permissions: Read
.CRT$XCU:00006B88 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006B88                 assume cs:_CRT$XCU
.CRT$XCU:00006B88                 ;org 6B88h
.CRT$XCU:00006B88 ; COMDAT (pick associative to section at 65B4)
.CRT$XCU:00006B88 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00006B88 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00006B88 _CRT$XCU        ends
.CRT$XCU:00006B88
UNDEF:00006B90 ; ===========================================================================
UNDEF:00006B90
UNDEF:00006B90 ; Segment type: Externs
UNDEF:00006B90 ; UNDEF
UNDEF:00006B90                 extrn __purecall:near   ; DATA XREF: .rdata:00006454o
UNDEF:00006B90                                         ; .rdata:00006458o
UNDEF:00006B94 ; void *__cdecl operator new(unsigned int)
UNDEF:00006B94                 extrn ??2@YAPAXI@Z:near ; CODE XREF: VerticalFileSwitcherListView::initList(void)+230p
UNDEF:00006B94                                         ; VerticalFileSwitcherListView::add(int,int)+6Cp ...
UNDEF:00006B98 ; void __cdecl operator delete(void *)
UNDEF:00006B98                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?initList@VerticalFileSwitcherListView@@QAEXXZ$4+7p
UNDEF:00006B98                                         ; __unwindfunclet$?add@VerticalFileSwitcherListView@@IAEHHH@Z$0+7p ...
UNDEF:00006B9C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00006B9C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00006B9C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00006BA0                 extrn __invalid_parameter:near
UNDEF:00006BA0                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+74p
UNDEF:00006BA4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00006BA4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00006BA4                                         ; _wmemcpy+11p
UNDEF:00006BA8 ; size_t __cdecl strlen(const char *Str)
UNDEF:00006BA8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00006BAC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00006BAC                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00006BAC                                         ; _wmemmove+11p
UNDEF:00006BB0 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:00006BB0                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00006BB4 ; LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:00006BB4                 extrn __imp__lstrcpyW@8:near
UNDEF:00006BB4                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+308p
UNDEF:00006BB4                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+3Cp ...
UNDEF:00006BB8 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00006BB8                 extrn __imp__SendMessageW@16:near
UNDEF:00006BB8                                         ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+DEp
UNDEF:00006BB8                                         ; VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+F4p ...
UNDEF:00006BBC ; LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00006BBC                 extrn __imp__CallWindowProcW@20:near
UNDEF:00006BBC                                         ; CODE XREF: VerticalFileSwitcherListView::runProc(HWND__ *,uint,uint,long)+1Ep
UNDEF:00006BBC                                         ; DATA XREF: VerticalFileSwitcherListView::runProc(HWND__ *,uint,uint,long)+1Er
UNDEF:00006BC0 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:00006BC0                 extrn __imp__CreateWindowExW@48:near
UNDEF:00006BC0                                         ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+6Ep
UNDEF:00006BC0                                         ; DATA XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+6Er
UNDEF:00006BC4 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:00006BC4                 extrn __imp__DestroyWindow@4:near
UNDEF:00006BC4                                         ; CODE XREF: VerticalFileSwitcherListView::destroy(void)+98p
UNDEF:00006BC4                                         ; DATA XREF: VerticalFileSwitcherListView::destroy(void)+98r
UNDEF:00006BC8 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00006BC8                 extrn __imp__GetClientRect@8:near
UNDEF:00006BC8                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+F9p
UNDEF:00006BC8                                         ; DATA XREF: VerticalFileSwitcherListView::initList(void)+F9r
UNDEF:00006BCC ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00006BCC                 extrn __imp__GetWindowLongW@8:near
UNDEF:00006BCC                                         ; CODE XREF: VerticalFileSwitcherListView::staticProc(HWND__ *,uint,uint,long)+19p
UNDEF:00006BCC                                         ; DATA XREF: VerticalFileSwitcherListView::staticProc(HWND__ *,uint,uint,long)+19r
UNDEF:00006BD0 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00006BD0                 extrn __imp__SetWindowLongW@12:near
UNDEF:00006BD0                                         ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+ABp
UNDEF:00006BD0                                         ; VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+BFp
UNDEF:00006BD0                                         ; DATA XREF: ...
UNDEF:00006BD4 ; HWND __stdcall GetParent(HWND hWnd)
UNDEF:00006BD4                 extrn __imp__GetParent@4:near
UNDEF:00006BD4                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+6Ap
UNDEF:00006BD4                                         ; DATA XREF: VerticalFileSwitcherListView::initList(void)+6Ar
UNDEF:00006BD8 ; LPWSTR __stdcall PathFindExtensionW(LPCWSTR pszPath)
UNDEF:00006BD8                 extrn __imp__PathFindExtensionW@4:near
UNDEF:00006BD8                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+3AFp
UNDEF:00006BD8                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+1FCp ...
UNDEF:00006BDC ; LPWSTR __stdcall PathFindFileNameW(LPCWSTR pszPath)
UNDEF:00006BDC                 extrn __imp__PathFindFileNameW@4:near
UNDEF:00006BDC                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+2FAp
UNDEF:00006BDC                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+2Ep ...
UNDEF:00006BE0 ; void __stdcall PathRemoveExtensionW(LPWSTR pszPath)
UNDEF:00006BE0                 extrn __imp__PathRemoveExtensionW@4:near
UNDEF:00006BE0                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+320p
UNDEF:00006BE0                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+8Dp ...
UNDEF:00006BE4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00006BE4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00006BE4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00006BE4                                         ; std::vector<SwitcherFileInfo,std::allocator<SwitcherFileInfo>>::_Orphan_range(SwitcherFileInfo *,SwitcherFileInfo *)+2Dp ...
UNDEF:00006BE8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00006BE8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00006BE8                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00006BE8                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j ...
UNDEF:00006BEC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00006BF0 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00006BF0                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00006BF0                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00006BF4 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00006BF4                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00006BF4                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00006BF4                                         ; DATA XREF: .xdata$x:00006448o
UNDEF:00006BF8 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00006BF8                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00006BF8                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00006BF8                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00006BFC ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00006BFC                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00006BFC                                         ; DATA XREF: .rdata:000063B8o
UNDEF:00006C00                 extrn __CrtDbgReportW:near
UNDEF:00006C00                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+50p
UNDEF:00006C04 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00006C04                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00006C04                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00006C04                                         ; std::_Debug_pointer<SwitcherFileInfo>(SwitcherFileInfo *,wchar_t const *,uint)+16p ...
UNDEF:00006C08 ; void __cdecl std::_Xbad_alloc()
UNDEF:00006C08                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00006C08                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1436p
UNDEF:00006C08                                         ; std::_Allocate<SwitcherFileInfo>(uint,SwitcherFileInfo *):loc_1478p ...
UNDEF:00006C0C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00006C0C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00006C0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00006C0C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:00006C10 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00006C10                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00006C10                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00006C10                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00006C14 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00006C14                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00006C14                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00006C18 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00006C18                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00006C18                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00006C1C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00006C1C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00006C1C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00006C1C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00006C20 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00006C20                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00006C20                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00006C24 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00006C24                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00006C24                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00006C28 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00006C28                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00006C28                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00006C2C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00006C2C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00006C2C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00006C30 ; BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce)
UNDEF:00006C30                 extrn __imp__InitCommonControlsEx@4:near
UNDEF:00006C30                                         ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+34p
UNDEF:00006C30                                         ; DATA XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+34r
UNDEF:00006C34 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall NativeLangSpeaker::getAttrNameStr(wchar_t const *, char const *, char const *)const
UNDEF:00006C34                 extrn ?getAttrNameStr@NativeLangSpeaker@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WPBD1@Z:near
UNDEF:00006C34                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+12Dp
UNDEF:00006C34                                         ; VerticalFileSwitcherListView::initList(void)+1A5p
UNDEF:00006C38 ; __fastcall __security_check_cookie(x)
UNDEF:00006C38                 extrn @__security_check_cookie@4:near
UNDEF:00006C38                                         ; CODE XREF: VerticalFileSwitcherListView::initList(void)+44Bp
UNDEF:00006C38                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+235p ...
UNDEF:00006C3C ; __stdcall _CxxThrowException(x, x)
UNDEF:00006C3C                 extrn __CxxThrowException@8:near
UNDEF:00006C3C                                         ; CODE XREF: VerticalFileSwitcherListView::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *)+99p
UNDEF:00006C3C                                         ; __catch$??$_Uninit_move@PAUSwitcherFileInfo@@PAU1@V?$allocator@USwitcherFileInfo@@@std@@U1@@std@@YAPAUSwitcherFileInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USwitcherFileInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
UNDEF:00006C40                 extrn ___CxxFrameHandler3:near
UNDEF:00006C40                                         ; CODE XREF: __ehhandler$?initList@VerticalFileSwitcherListView@@QAEXXZ+23j
UNDEF:00006C40                                         ; __ehhandler$?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z+16j ...
UNDEF:00006C44 ; const type_info::`vftable'
UNDEF:00006C44                 extrn ??_7type_info@@6B@:near
UNDEF:00006C44                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00006C44                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00006C48 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00006C48                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00006C48                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00006C4C                 extrn ___security_cookie:near
UNDEF:00006C4C                                         ; DATA XREF: VerticalFileSwitcherListView::initList(void)+17r
UNDEF:00006C4C                                         ; VerticalFileSwitcherListView::setItemIconStatus(int)+9r ...
UNDEF:00006C50                 extrn __fltused:near
UNDEF:00006C50
UNDEF:00006C50
UNDEF:00006C50                 end