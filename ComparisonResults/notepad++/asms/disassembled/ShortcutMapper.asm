.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 0CC75F24223C3486F4787FEE6F6C3FEE
.rdata:00000000 ; Input CRC32 : 8BBEF6D2
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ShortcutMapper.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; wchar_t _SG169999
.rdata:00000000 $SG169999:                              ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+FA8o
.rdata:00000000                 unicode 0, <Modify>,0
.rdata:0000000E                 align 10h
.rdata:00000010 ; wchar_t _SG170001
.rdata:00000010 $SG170001:                              ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+FF6o
.rdata:00000010                 unicode 0, <Delete>,0
.rdata:0000001E                 align 10h
.rdata:00000020 $SG143597       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:0000002B                 align 4
.rdata:0000002C $SG143598       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000AF4o
.rdata:00000038 $SG143599       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000AF8o
.rdata:00000044 $SG143600       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:00000AFCo
.rdata:00000050 $SG143601       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000B00o
.rdata:0000005C $SG143602       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000B04o
.rdata:00000068 $SG143603       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000B08o
.rdata:00000074 $SG143604       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:00000B0Co
.rdata:00000080 $SG143605       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000B10o
.rdata:0000008C $SG143606       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000B14o
.rdata:00000098 $SG143607       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000B18o
.rdata:000000A4 $SG143608       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:00000B1Co
.rdata:000000B0 $SG143609       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000B20o
.rdata:000000BC $SG143610       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000B24o
.rdata:000000C8 $SG143611       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000B28o
.rdata:000000D4 $SG143612       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:00000B2Co
.rdata:000000E0 $SG143613       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000B30o
.rdata:000000EC $SG143614       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000B34o
.rdata:000000F8 $SG143615       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000B38o
.rdata:00000104 $SG143616       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:00000B3Co
.rdata:00000110 $SG143617       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000B40o
.rdata:0000011C $SG143618       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000B44o
.rdata:00000128 $SG143619       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000B48o
.rdata:00000134 $SG143620       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:00000B4Co
.rdata:00000140 $SG143621       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000B50o
.rdata:0000014C $SG143622       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000B54o
.rdata:00000158 $SG143623       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000B58o
.rdata:00000164 $SG143624       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:00000B5Co
.rdata:00000170 $SG143625       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000B60o
.rdata:0000017C $SG143626       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000B64o
.rdata:00000188 $SG143627       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000B68o
.rdata:00000194 $SG143628       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:00000B6Co
.rdata:000001A0 $SG143629       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000B70o
.rdata:000001AC $SG143630       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000B74o
.rdata:000001B8 $SG143631       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000B78o
.rdata:000001C4 $SG143632       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:00000B7Co
.rdata:000001D0 $SG143633       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000B80o
.rdata:000001DC $SG143634       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000B84o
.rdata:000001E8 $SG143635       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000B88o
.rdata:000001F4 $SG143636       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:00000B8Co
.rdata:00000200 $SG143637       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:00000B90o
.rdata:0000020C $SG143638       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:00000B94o
.rdata:00000218 $SG143639       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:00000B98o
.rdata:00000224 $SG143640       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:00000B9Co
.rdata:00000230 $SG143641       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:00000BA0o
.rdata:0000023C $SG143642       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:00000BA4o
.rdata:00000248 $SG143643       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:00000BA8o
.rdata:00000254 $SG143644       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:00000BACo
.rdata:00000260 $SG143645       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:00000BB0o
.rdata:0000026C $SG143646       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:00000BB4o
.rdata:00000278 $SG143647       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:00000BB8o
.rdata:00000284 $SG143648       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:00000BBCo
.rdata:00000290 $SG143649       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:00000BC0o
.rdata:0000029C $SG143650       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:00000BC4o
.rdata:000002A8 $SG143651       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:00000BC8o
.rdata:000002B4 $SG143652       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:00000BCCo
.rdata:000002C0 $SG143653       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:00000BD0o
.rdata:000002CC $SG143654       db '    .+      ',0     ; DATA XREF: .data:00000BD4o
.rdata:000002D9                 align 4
.rdata:000002DC $SG143655       db '    @#$     ',0     ; DATA XREF: .data:00000BD8o
.rdata:000002E9                 align 4
.rdata:000002EC $SG143656       db '    %&*=    ',0     ; DATA XREF: .data:00000BDCo
.rdata:000002F9                 align 4
.rdata:000002FC $SG143657       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:00000BE0o
.rdata:00000309                 align 4
.rdata:0000030C $SG143658       db '    )!~{]^  ',0     ; DATA XREF: .data:00000BE4o
.rdata:00000319                 align 4
.rdata:0000031C $SG143659       db '    /(_:<[} ',0     ; DATA XREF: .data:00000BE8o
.rdata:00000329                 align 4
.rdata:0000032C $SG143660       db '    |123456 ',0     ; DATA XREF: .data:00000BECo
.rdata:00000339                 align 4
.rdata:0000033C $SG143661       db '    7890abc ',0     ; DATA XREF: .data:00000BF0o
.rdata:00000349                 align 4
.rdata:0000034C $SG143662       db '    defgh   ',0     ; DATA XREF: .data:00000BF4o
.rdata:00000359                 align 4
.rdata:0000035C $SG143663       db '    ijkl    ',0     ; DATA XREF: .data:00000BF8o
.rdata:00000369                 align 4
.rdata:0000036C $SG143664       db '    mno     ',0     ; DATA XREF: .data:00000BFCo
.rdata:00000379                 align 4
.rdata:0000037C $SG143665       db '    pq      ',0     ; DATA XREF: .data:00000C00o
.rdata:00000389                 align 4
.rdata:0000038C $SG143667       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:00000397                 align 4
.rdata:00000398 $SG143668       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000C0Co
.rdata:000003A4 $SG143669       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000C10o
.rdata:000003B0 $SG143670       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000C14o
.rdata:000003BC $SG143671       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000C18o
.rdata:000003C8 $SG143672       db '#',9,'c #6397E1',0  ; DATA XREF: .data:00000C1Co
.rdata:000003D4 $SG143673       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000C20o
.rdata:000003E0 $SG143674       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000C24o
.rdata:000003EC $SG143675       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000C28o
.rdata:000003F8 $SG143676       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:00000C2Co
.rdata:00000404 $SG143677       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000C30o
.rdata:00000410 $SG143678       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000C34o
.rdata:0000041C $SG143679       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000C38o
.rdata:00000428 $SG143680       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:00000C3Co
.rdata:00000434 $SG143681       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000C40o
.rdata:00000440 $SG143682       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000C44o
.rdata:0000044C $SG143683       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000C48o
.rdata:00000458 $SG143684       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:00000C4Co
.rdata:00000464 $SG143685       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000C50o
.rdata:00000470 $SG143686       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000C54o
.rdata:0000047C $SG143687       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000C58o
.rdata:00000488 $SG143688       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:00000C5Co
.rdata:00000494 $SG143689       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000C60o
.rdata:000004A0 $SG143690       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000C64o
.rdata:000004AC $SG143691       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000C68o
.rdata:000004B8 $SG143692       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:00000C6Co
.rdata:000004C4 $SG143693       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000C70o
.rdata:000004D0 $SG143694       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000C74o
.rdata:000004DC $SG143695       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000C78o
.rdata:000004E8 $SG143696       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:00000C7Co
.rdata:000004F4 $SG143697       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000C80o
.rdata:00000500 $SG143698       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000C84o
.rdata:0000050C $SG143699       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000C88o
.rdata:00000518 $SG143700       db '4',9,'c #195CC6',0  ; DATA XREF: .data:00000C8Co
.rdata:00000524 $SG143701       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:00000C90o
.rdata:00000530 $SG143702       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:00000C94o
.rdata:0000053C $SG143703       db '7',9,'c #4885D6',0  ; DATA XREF: .data:00000C98o
.rdata:00000548 $SG143704       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:00000C9Co
.rdata:00000554 $SG143705       db '9',9,'c #6698DB',0  ; DATA XREF: .data:00000CA0o
.rdata:00000560 $SG143706       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:00000CA4o
.rdata:0000056C $SG143707       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:00000CA8o
.rdata:00000578 $SG143708       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:00000CACo
.rdata:00000584 $SG143709       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:00000CB0o
.rdata:00000590 $SG143710       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:00000CB4o
.rdata:0000059C $SG143711       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:00000CB8o
.rdata:000005A8 $SG143712       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:00000CBCo
.rdata:000005B4 $SG143713       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:00000CC0o
.rdata:000005C0 $SG143714       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:00000CC4o
.rdata:000005CC $SG143715       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:00000CC8o
.rdata:000005D8 $SG143716       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:00000CCCo
.rdata:000005E4 $SG143717       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:00000CD0o
.rdata:000005F0 $SG143718       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:00000CD4o
.rdata:000005FC $SG143719       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:00000CD8o
.rdata:00000608 $SG143720       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:00000CDCo
.rdata:00000614 $SG143721       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:00000CE0o
.rdata:00000620 $SG143722       db '         .+ ',0     ; DATA XREF: .data:00000CE4o
.rdata:0000062D                 align 10h
.rdata:00000630 $SG143723       db '        @#$ ',0     ; DATA XREF: .data:00000CE8o
.rdata:0000063D                 align 10h
.rdata:00000640 $SG143724       db '       %&*= L',0    ; DATA XREF: .data:00000CECo
.rdata:0000064E                 align 10h
.rdata:00000650 ; wchar_t _SG169325
.rdata:00000650 $SG169325:                              ; DATA XREF: ShortcutMapper::fillOutBabyGrid(void):loc_2382o
.rdata:00000650                 unicode 0, <Name>,0
.rdata:0000065A                 align 4
.rdata:0000065C $SG143725       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000CF0o
.rdata:00000669                 align 4
.rdata:0000066C ; wchar_t _SG169326
.rdata:0000066C $SG169326:                              ; DATA XREF: ShortcutMapper::fillOutBabyGrid(void)+18Do
.rdata:0000066C                 unicode 0, <Shortcut>,0
.rdata:0000067E                 align 10h
.rdata:00000680 $SG143726       db '     )!>~{] ',0     ; DATA XREF: .data:00000CF4o
.rdata:0000068D                 align 10h
.rdata:00000690 $SG143727       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000CF8o
.rdata:0000069D                 align 10h
.rdata:000006A0 $SG143728       db '    (}|1234 ',0     ; DATA XREF: .data:00000CFCo
.rdata:000006AD                 align 10h
.rdata:000006B0 $SG143729       db '    567890a ',0     ; DATA XREF: .data:00000D00o
.rdata:000006BD                 align 10h
.rdata:000006C0 $SG143730       db '      bcdef ',0     ; DATA XREF: .data:00000D04o
.rdata:000006CD                 align 10h
.rdata:000006D0 $SG143731       db '       ghij ',0     ; DATA XREF: .data:00000D08o
.rdata:000006DD                 align 10h
.rdata:000006E0 $SG143732       db '        klm ',0     ; DATA XREF: .data:00000D0Co
.rdata:000006ED                 align 10h
.rdata:000006F0 $SG143733       db '         no ',0     ; DATA XREF: .data:00000D10o
.rdata:000006FD                 align 10h
.rdata:00000700 $SG143735       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:0000070B                 align 4
.rdata:0000070C $SG143736       db ' ',9,'c None',0     ; DATA XREF: .data:00000D1Co
.rdata:00000715                 align 4
.rdata:00000718 $SG143737       db '.',9,'c #545254',0  ; DATA XREF: .data:00000D20o
.rdata:00000724 $SG143738       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000D24o
.rdata:00000730 $SG143739       db '@',9,'c #646464',0  ; DATA XREF: .data:00000D28o
.rdata:0000073C $SG143740       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:00000D2Co
.rdata:00000748 $SG143741       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000D30o
.rdata:00000754 $SG143742       db '%',9,'c #747284',0  ; DATA XREF: .data:00000D34o
.rdata:00000760 $SG143743       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000D38o
.rdata:0000076C $SG143744       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:00000D3Co
.rdata:00000778 $SG143745       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000D40o
.rdata:00000784 $SG143746       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000D44o
.rdata:00000790 $SG143747       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000D48o
.rdata:0000079C $SG143748       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:00000D4Co
.rdata:000007A8 $SG143749       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000D50o
.rdata:000007B4 $SG143750       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000D54o
.rdata:000007C0 $SG143751       db ')',9,'c #282668',0  ; DATA XREF: .data:00000D58o
.rdata:000007CC $SG143752       db '!',9,'c #24367C',0  ; DATA XREF: .data:00000D5Co
.rdata:000007D8 $SG143753       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000D60o
.rdata:000007E4 $SG143754       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000D64o
.rdata:000007F0 $SG143755       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000D68o
.rdata:000007FC $SG143756       db '^',9,'c #142E7C',0  ; DATA XREF: .data:00000D6Co
.rdata:00000808 $SG143757       db '/',9,'c #143789',0  ; DATA XREF: .data:00000D70o
.rdata:00000814 $SG143758       db '(',9,'c #204990',0  ; DATA XREF: .data:00000D74o
.rdata:00000820 $SG143759       db '_',9,'c #174091',0  ; DATA XREF: .data:00000D78o
.rdata:0000082C $SG143760       db ':',9,'c #0C0630',0  ; DATA XREF: .data:00000D7Co
.rdata:00000838 $SG143761       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000D80o
.rdata:00000844 $SG143762       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000D84o
.rdata:00000850 $SG143763       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000D88o
.rdata:0000085C $SG143764       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:00000D8Co
.rdata:00000868 $SG143765       db '1',9,'c #141244',0  ; DATA XREF: .data:00000D90o
.rdata:00000874 $SG143766       db '2',9,'c #24428C',0  ; DATA XREF: .data:00000D94o
.rdata:00000880 $SG143767       db '3',9,'c #3462B9',0  ; DATA XREF: .data:00000D98o
.rdata:0000088C $SG143768       db '4',9,'c #4470C4',0  ; DATA XREF: .data:00000D9Co
.rdata:00000898 $SG143769       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:00000DA0o
.rdata:000008A4 $SG143770       db '6',9,'c #4472CC',0  ; DATA XREF: .data:00000DA4o
.rdata:000008B0 $SG143771       db '7',9,'c #24224C',0  ; DATA XREF: .data:00000DA8o
.rdata:000008BC $SG143772       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:00000DACo
.rdata:000008C8 $SG143773       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:00000DB0o
.rdata:000008D4 $SG143774       db '0',9,'c #5482DF',0  ; DATA XREF: .data:00000DB4o
.rdata:000008E0 $SG143775       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:00000DB8o
.rdata:000008EC $SG143776       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:00000DBCo
.rdata:000008F8 $SG143777       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:00000DC0o
.rdata:00000904 $SG143778       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:00000DC4o
.rdata:00000910 $SG143779       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:00000DC8o
.rdata:0000091C $SG143780       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:00000DCCo
.rdata:00000928 $SG143781       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:00000DD0o
.rdata:00000934 $SG143782       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:00000DD4o
.rdata:00000940 $SG143783       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:00000DD8o
.rdata:0000094C $SG143784       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:00000DDCo
.rdata:00000958 $SG143785       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:00000DE0o
.rdata:00000964 $SG143786       db 'l',9,'c #243250',0  ; DATA XREF: .data:00000DE4o
.rdata:00000970 $SG143787       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:00000DE8o
.rdata:0000097C $SG143788       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:00000DECo
.rdata:00000988 $SG143789       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000DF0o
.rdata:00000994 $SG143790       db '     .+.     ',0    ; DATA XREF: .data:00000DF4o
.rdata:000009A2                 align 4
.rdata:000009A4 $SG143791       db '   @##$##@   ',0    ; DATA XREF: .data:00000DF8o
.rdata:000009B2                 align 4
.rdata:000009B4 $SG143792       db '  @%&***&%@  ',0    ; DATA XREF: .data:00000DFCo
.rdata:000009C2                 align 4
.rdata:000009C4 $SG143793       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000E00o
.rdata:000009D2                 align 4
.rdata:000009D4 $SG143794       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:000009D4                                         ; DATA XREF: .data:00000E04o
.rdata:000009E2                 align 4
.rdata:000009E4 $SG143795       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000E08o
.rdata:000009F2                 align 4
.rdata:000009F4 $SG143796       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:00000E0Co
.rdata:00000A02                 align 4
.rdata:00000A04 $SG143797       db '12[3455563[21',0    ; DATA XREF: .data:00000E10o
.rdata:00000A12                 align 4
.rdata:00000A14 $SG143798       db '7_365899063_7',0    ; DATA XREF: .data:00000E14o
.rdata:00000A22                 align 4
.rdata:00000A24 $SG143799       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000E18o
.rdata:00000A32                 align 4
.rdata:00000A34 $SG143800       db ' d}8efgfb83d ',0    ; DATA XREF: .data:00000E1Co
.rdata:00000A42                 align 4
.rdata:00000A44 $SG143801       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000E20o
.rdata:00000A52                 align 4
.rdata:00000A54 $SG143802       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000E24o
.rdata:00000A62                 align 4
.rdata:00000A64 $SG143803       db '     o@o     ',0    ; DATA XREF: .data:00000E28o
.rdata:00000A72                 align 4
.rdata:00000A74 ; const WCHAR _SG169648
.rdata:00000A74 $SG169648:                              ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+A2Fo
.rdata:00000A74                 unicode 0, <Are you sure?>,0
.rdata:00000A90 ; const WCHAR _SG169649
.rdata:00000A90 $SG169649:                              ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+A34o
.rdata:00000A90                 unicode 0, <Are you sure you want to delete this shortcut?>,0
.rdata:00000AEE                 align 10h
.rdata:00000AEE _rdata          ends
.rdata:00000AEE
.data:00000AF0 ; ===========================================================================
.data:00000AF0
.data:00000AF0 ; Segment type: Pure data
.data:00000AF0 ; Segment permissions: Read/Write
.data:00000AF0 ; Segment alignment 'qword' can not be represented in assembly
.data:00000AF0 _data           segment para public 'DATA' use32
.data:00000AF0                 assume cs:_data
.data:00000AF0                 ;org 0AF0h
.data:00000AF0 _acTop_xpm      dd offset $SG143597     ; "12 12 56 1"
.data:00000AF4                 dd offset $SG143598     ; " \tc #FFFFFF"
.data:00000AF8                 dd offset $SG143599     ; ".\tc #8AB2E9"
.data:00000AFC                 dd offset $SG143600     ; "+\tc #CCDCF6"
.data:00000B00                 dd offset $SG143601     ; "@\tc #80ABEA"
.data:00000B04                 dd offset $SG143602     ; "#\tc #7DA9E8"
.data:00000B08                 dd offset $SG143603     ; "$\tc #C7DAF3"
.data:00000B0C                 dd offset $SG143604     ; "%\tc #79A7E6"
.data:00000B10                 dd offset $SG143605     ; "&\tc #ADC8EF"
.data:00000B14                 dd offset $SG143606     ; "*\tc #87B0E8"
.data:00000B18                 dd offset $SG143607     ; "=\tc #BBD2F0"
.data:00000B1C                 dd offset $SG143608     ; "-\tc #6EA0E2"
.data:00000B20                 dd offset $SG143609     ; ";\tc #A8C7EE"
.data:00000B24                 dd offset $SG143610     ; ">\tc #A3C2ED"
.data:00000B28                 dd offset $SG143611     ; ",\tc #75A4E3"
.data:00000B2C                 dd offset $SG143612     ; "'\tc #A7C4EB"
.data:00000B30                 dd offset $SG143613     ; ")\tc #6297E1"
.data:00000B34                 dd offset $SG143614     ; "!\tc #A1C1EC"
.data:00000B38                 dd offset $SG143615     ; "~\tc #92B7E8"
.data:00000B3C                 dd offset $SG143616     ; "{\tc #99BBE9"
.data:00000B40                 dd offset $SG143617     ; "]\tc #6197DD"
.data:00000B44                 dd offset $SG143618     ; "^\tc #96B9E6"
.data:00000B48                 dd offset $SG143619     ; "/\tc #538EDB"
.data:00000B4C                 dd offset $SG143620     ; "(\tc #99BBEA"
.data:00000B50                 dd offset $SG143621     ; "_\tc #80AAE3"
.data:00000B54                 dd offset $SG143622     ; ":\tc #81ABE3"
.data:00000B58                 dd offset $SG143623     ; "<\tc #8AB1E4"
.data:00000B5C                 dd offset $SG143624     ; "[\tc #4B88D6"
.data:00000B60                 dd offset $SG143625     ; "}\tc #4882D1"
.data:00000B64                 dd offset $SG143626     ; "|\tc #4384D6"
.data:00000B68                 dd offset $SG143627     ; "1\tc #90B5E7"
.data:00000B6C                 dd offset $SG143628     ; "2\tc #74A3E0"
.data:00000B70                 dd offset $SG143629     ; "3\tc #77A4E0"
.data:00000B74                 dd offset $SG143630     ; "4\tc #81ABE2"
.data:00000B78                 dd offset $SG143631     ; "5\tc #437FD3"
.data:00000B7C                 dd offset $SG143632     ; "6\tc #7FA2DF"
.data:00000B80                 dd offset $SG143633     ; "7\tc #3577D2"
.data:00000B84                 dd offset $SG143634     ; "8\tc #87AFE4"
.data:00000B88                 dd offset $SG143635     ; "9\tc #72A1DF"
.data:00000B8C                 dd offset $SG143636     ; "0\tc #7CA9E1"
.data:00000B90                 dd offset $SG143637     ; "a\tc #3F7AD0"
.data:00000B94                 dd offset $SG143638     ; "b\tc #85A4DE"
.data:00000B98                 dd offset $SG143639     ; "c\tc #FBFCFE"
.data:00000B9C                 dd offset $SG143640     ; "d\tc #236ECD"
.data:00000BA0                 dd offset $SG143641     ; "e\tc #7EA8E1"
.data:00000BA4                 dd offset $SG143642     ; "f\tc #79A6E0"
.data:00000BA8                 dd offset $SG143643     ; "g\tc #3D77D0"
.data:00000BAC                 dd offset $SG143644     ; "h\tc #87A4DC"
.data:00000BB0                 dd offset $SG143645     ; "i\tc #1A62C9"
.data:00000BB4                 dd offset $SG143646     ; "j\tc #75A3DF"
.data:00000BB8                 dd offset $SG143647     ; "k\tc #3C74CF"
.data:00000BBC                 dd offset $SG143648     ; "l\tc #8DA6DE"
.data:00000BC0                 dd offset $SG143649     ; "m\tc #1859C4"
.data:00000BC4                 dd offset $SG143650     ; "n\tc #3B71CC"
.data:00000BC8                 dd offset $SG143651     ; "o\tc #8EA5DD"
.data:00000BCC                 dd offset $SG143652     ; "p\tc #164EC0"
.data:00000BD0                 dd offset $SG143653     ; "q\tc #92A7DD"
.data:00000BD4                 dd offset $SG143654     ; "    .+      "
.data:00000BD8                 dd offset $SG143655     ; "    @#$     "
.data:00000BDC                 dd offset $SG143656     ; "    %&*=    "
.data:00000BE0                 dd offset $SG143657     ; "    -;>,'   "
.data:00000BE4                 dd offset $SG143658     ; "    )!~{]^  "
.data:00000BE8                 dd offset $SG143659     ; "    /(_:<[} "
.data:00000BEC                 dd offset $SG143660     ; "    |123456 "
.data:00000BF0                 dd offset $SG143661     ; "    7890abc "
.data:00000BF4                 dd offset $SG143662     ; "    defgh   "
.data:00000BF8                 dd offset $SG143663     ; "    ijkl    "
.data:00000BFC                 dd offset $SG143664     ; "    mno     "
.data:00000C00                 dd offset $SG143665     ; "    pq      "
.data:00000C04                 align 8
.data:00000C08 _acBottom_xpm   dd offset $SG143667     ; "12 12 54 1"
.data:00000C0C                 dd offset $SG143668     ; " \tc #FFFFFF"
.data:00000C10                 dd offset $SG143669     ; ".\tc #C4D7F3"
.data:00000C14                 dd offset $SG143670     ; "+\tc #72A1E3"
.data:00000C18                 dd offset $SG143671     ; "@\tc #C1D6F2"
.data:00000C1C                 dd offset $SG143672     ; "#\tc #6397E1"
.data:00000C20                 dd offset $SG143673     ; "$\tc #5990DD"
.data:00000C24                 dd offset $SG143674     ; "%\tc #BBD2F0"
.data:00000C28                 dd offset $SG143675     ; "&\tc #7AA6E5"
.data:00000C2C                 dd offset $SG143676     ; "*\tc #9ABDEA"
.data:00000C30                 dd offset $SG143677     ; "=\tc #4A87D9"
.data:00000C34                 dd offset $SG143678     ; "-\tc #B1CAEE"
.data:00000C38                 dd offset $SG143679     ; ";\tc #75A4E3"
.data:00000C3C                 dd offset $SG143680     ; ">\tc #99BBE9"
.data:00000C40                 dd offset $SG143681     ; ",\tc #95B9E8"
.data:00000C44                 dd offset $SG143682     ; "'\tc #3A7CD4"
.data:00000C48                 dd offset $SG143683     ; ")\tc #A9C6EC"
.data:00000C4C                 dd offset $SG143684     ; "!\tc #71A0E0"
.data:00000C50                 dd offset $SG143685     ; "~\tc #86AFE5"
.data:00000C54                 dd offset $SG143686     ; "{\tc #8DB2E6"
.data:00000C58                 dd offset $SG143687     ; "]\tc #2A72CF"
.data:00000C5C                 dd offset $SG143688     ; "^\tc #73A0E0"
.data:00000C60                 dd offset $SG143689     ; "/\tc #6B9DE0"
.data:00000C64                 dd offset $SG143690     ; "(\tc #95B8E8"
.data:00000C68                 dd offset $SG143691     ; "_\tc #81ABE3"
.data:00000C6C                 dd offset $SG143692     ; ":\tc #72A1DF"
.data:00000C70                 dd offset $SG143693     ; "<\tc #83ADE3"
.data:00000C74                 dd offset $SG143694     ; "[\tc #1B65C9"
.data:00000C78                 dd offset $SG143695     ; "}\tc #5F95DC"
.data:00000C7C                 dd offset $SG143696     ; "|\tc #8BB3E5"
.data:00000C80                 dd offset $SG143697     ; "1\tc #77A4E0"
.data:00000C84                 dd offset $SG143698     ; "2\tc #679ADC"
.data:00000C88                 dd offset $SG143699     ; "3\tc #7AA6E1"
.data:00000C8C                 dd offset $SG143700     ; "4\tc #195CC6"
.data:00000C90                 dd offset $SG143701     ; "5\tc #FCFDFE"
.data:00000C94                 dd offset $SG143702     ; "6\tc #8DB2E4"
.data:00000C98                 dd offset $SG143703     ; "7\tc #4885D6"
.data:00000C9C                 dd offset $SG143704     ; "8\tc #7CA9E1"
.data:00000CA0                 dd offset $SG143705     ; "9\tc #6698DB"
.data:00000CA4                 dd offset $SG143706     ; "0\tc #71A1DE"
.data:00000CA8                 dd offset $SG143707     ; "a\tc #1752C0"
.data:00000CAC                 dd offset $SG143708     ; "b\tc #88ABE0"
.data:00000CB0                 dd offset $SG143709     ; "c\tc #3D77D0"
.data:00000CB4                 dd offset $SG143710     ; "d\tc #6E9FDD"
.data:00000CB8                 dd offset $SG143711     ; "e\tc #699BDC"
.data:00000CBC                 dd offset $SG143712     ; "f\tc #1547BD"
.data:00000CC0                 dd offset $SG143713     ; "g\tc #8DA6DE"
.data:00000CC4                 dd offset $SG143714     ; "h\tc #376BC9"
.data:00000CC8                 dd offset $SG143715     ; "i\tc #6295DA"
.data:00000CCC                 dd offset $SG143716     ; "j\tc #1440B9"
.data:00000CD0                 dd offset $SG143717     ; "k\tc #8DA0DB"
.data:00000CD4                 dd offset $SG143718     ; "l\tc #315FC4"
.data:00000CD8                 dd offset $SG143719     ; "m\tc #1339B7"
.data:00000CDC                 dd offset $SG143720     ; "n\tc #909FDA"
.data:00000CE0                 dd offset $SG143721     ; "o\tc #1233B4"
.data:00000CE4                 dd offset $SG143722     ; "         .+ "
.data:00000CE8                 dd offset $SG143723     ; "        @#$ "
.data:00000CEC                 dd offset $SG143724     ; "       %&*= L"
.data:00000CF0                 dd offset $SG143725     ; "      -;>,' "
.data:00000CF4                 dd offset $SG143726     ; "     )!>~{] "
.data:00000CF8                 dd offset $SG143727     ; "    ^/(_:<[ "
.data:00000CFC                 dd offset $SG143728     ; "    (}|1234 "
.data:00000D00                 dd offset $SG143729     ; "    567890a "
.data:00000D04                 dd offset $SG143730     ; "      bcdef "
.data:00000D08                 dd offset $SG143731     ; "       ghij "
.data:00000D0C                 dd offset $SG143732     ; "        klm "
.data:00000D10                 dd offset $SG143733     ; "         no "
.data:00000D14                 align 8
.data:00000D18 _bookmark_xpm   dd offset $SG143735     ; "13 14 54 1"
.data:00000D1C                 dd offset $SG143736     ; " \tc None"
.data:00000D20                 dd offset $SG143737     ; ".\tc #545254"
.data:00000D24                 dd offset $SG143738     ; "+\tc #3C3E3C"
.data:00000D28                 dd offset $SG143739     ; "@\tc #646464"
.data:00000D2C                 dd offset $SG143740     ; "#\tc #A4A4A4"
.data:00000D30                 dd offset $SG143741     ; "$\tc #B7B8B7"
.data:00000D34                 dd offset $SG143742     ; "%\tc #747284"
.data:00000D38                 dd offset $SG143743     ; "&\tc #B4B2C4"
.data:00000D3C                 dd offset $SG143744     ; "*\tc #DCD7E4"
.data:00000D40                 dd offset $SG143745     ; "=\tc #1C1A1C"
.data:00000D44                 dd offset $SG143746     ; "-\tc #403E58"
.data:00000D48                 dd offset $SG143747     ; ";\tc #5C5A8C"
.data:00000D4C                 dd offset $SG143748     ; ">\tc #7C7EAC"
.data:00000D50                 dd offset $SG143749     ; ",\tc #7C8EBC"
.data:00000D54                 dd offset $SG143750     ; "'\tc #242644"
.data:00000D58                 dd offset $SG143751     ; ")\tc #282668"
.data:00000D5C                 dd offset $SG143752     ; "!\tc #24367C"
.data:00000D60                 dd offset $SG143753     ; "~\tc #244A84"
.data:00000D64                 dd offset $SG143754     ; "{\tc #2C5098"
.data:00000D68                 dd offset $SG143755     ; "]\tc #14162C"
.data:00000D6C                 dd offset $SG143756     ; "^\tc #142E7C"
.data:00000D70                 dd offset $SG143757     ; "/\tc #143789"
.data:00000D74                 dd offset $SG143758     ; "(\tc #204990"
.data:00000D78                 dd offset $SG143759     ; "_\tc #174091"
.data:00000D7C                 dd offset $SG143760     ; ":\tc #0C0630"
.data:00000D80                 dd offset $SG143761     ; "<\tc #24327C"
.data:00000D84                 dd offset $SG143762     ; "[\tc #2450A0"
.data:00000D88                 dd offset $SG143763     ; "}\tc #345DB4"
.data:00000D8C                 dd offset $SG143764     ; "|\tc #3C68B8"
.data:00000D90                 dd offset $SG143765     ; "1\tc #141244"
.data:00000D94                 dd offset $SG143766     ; "2\tc #24428C"
.data:00000D98                 dd offset $SG143767     ; "3\tc #3462B9"
.data:00000D9C                 dd offset $SG143768     ; "4\tc #4470C4"
.data:00000DA0                 dd offset $SG143769     ; "5\tc #4C7FD6"
.data:00000DA4                 dd offset $SG143770     ; "6\tc #4472CC"
.data:00000DA8                 dd offset $SG143771     ; "7\tc #24224C"
.data:00000DAC                 dd offset $SG143772     ; "8\tc #5C8DEC"
.data:00000DB0                 dd offset $SG143773     ; "9\tc #5C94F6"
.data:00000DB4                 dd offset $SG143774     ; "0\tc #5482DF"
.data:00000DB8                 dd offset $SG143775     ; "a\tc #619DF7"
.data:00000DBC                 dd offset $SG143776     ; "b\tc #6CA6FC"
.data:00000DC0                 dd offset $SG143777     ; "c\tc #64A2FC"
.data:00000DC4                 dd offset $SG143778     ; "d\tc #1C2E5C"
.data:00000DC8                 dd offset $SG143779     ; "e\tc #6CA2FC"
.data:00000DCC                 dd offset $SG143780     ; "f\tc #74B2FC"
.data:00000DD0                 dd offset $SG143781     ; "g\tc #7CB8FC"
.data:00000DD4                 dd offset $SG143782     ; "h\tc #1C3264"
.data:00000DD8                 dd offset $SG143783     ; "i\tc #346AD4"
.data:00000DDC                 dd offset $SG143784     ; "j\tc #7CBEFC"
.data:00000DE0                 dd offset $SG143785     ; "k\tc #3C72DC"
.data:00000DE4                 dd offset $SG143786     ; "l\tc #243250"
.data:00000DE8                 dd offset $SG143787     ; "m\tc #346AB4"
.data:00000DEC                 dd offset $SG143788     ; "n\tc #3C82DC"
.data:00000DF0                 dd offset $SG143789     ; "o\tc #6C6A6C"
.data:00000DF4                 dd offset $SG143790     ; "     .+.     "
.data:00000DF8                 dd offset $SG143791     ; "   @##$##@   "
.data:00000DFC                 dd offset $SG143792     ; "  @%&***&%@  "
.data:00000E00                 dd offset $SG143793     ; " =-;>,,,>;-= "
.data:00000E04                 dd offset $SG143794     ; " ')!~{{{~!)' "
.data:00000E08                 dd offset $SG143795     ; "])^/({{{(_^)]"
.data:00000E0C                 dd offset $SG143796     ; ":<_[}|||}[_<:"
.data:00000E10                 dd offset $SG143797     ; "12[3455563[21"
.data:00000E14                 dd offset $SG143798     ; "7_365899063_7"
.data:00000E18                 dd offset $SG143799     ; " /|09abc904/ "
.data:00000E1C                 dd offset $SG143800     ; " d}8efgfb83d "
.data:00000E20                 dd offset $SG143801     ; "  hiafjgakh  "
.data:00000E24                 dd offset $SG143802     ; "   l~mnm~l   "
.data:00000E28                 dd offset $SG143803     ; "     o@o     "
.data:00000E28 _data           ends
.data:00000E28
.text$mn:00000E2C ; ===========================================================================
.text$mn:00000E2C
.text$mn:00000E2C ; Segment type: Pure code
.text$mn:00000E2C ; Segment permissions: Read/Execute
.text$mn:00000E2C _text$mn        segment para public 'CODE' use32
.text$mn:00000E2C                 assume cs:_text$mn
.text$mn:00000E2C                 ;org 0E2Ch
.text$mn:00000E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E2C
.text$mn:00000E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E2C
.text$mn:00000E2C ; Attributes: bp-based frame
.text$mn:00000E2C
.text$mn:00000E2C ; void __thiscall ShortcutMapper::getClientRect(ShortcutMapper *this, struct tagRECT *)
.text$mn:00000E2C                 public ?getClientRect@ShortcutMapper@@UBEXAAUtagRECT@@@Z
.text$mn:00000E2C ?getClientRect@ShortcutMapper@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00000E2C
.text$mn:00000E2C var_4           = dword ptr -4
.text$mn:00000E2C arg_0           = dword ptr  8
.text$mn:00000E2C
.text$mn:00000E2C                 push    ebp
.text$mn:00000E2D                 mov     ebp, esp
.text$mn:00000E2F                 push    ecx
.text$mn:00000E30                 mov     [ebp+var_4], ecx
.text$mn:00000E33                 mov     eax, [ebp+arg_0]
.text$mn:00000E36                 push    eax             ; struct tagRECT *
.text$mn:00000E37                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E3A                 call    ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.text$mn:00000E3F                 push    28h ; '('       ; int
.text$mn:00000E41                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000E46                 add     eax, 0Ch
.text$mn:00000E49                 mov     ecx, eax        ; this
.text$mn:00000E4B                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00000E50                 mov     ecx, [ebp+arg_0]
.text$mn:00000E53                 add     eax, [ecx+4]
.text$mn:00000E56                 mov     edx, [ebp+arg_0]
.text$mn:00000E59                 mov     [edx+4], eax
.text$mn:00000E5C                 push    14h             ; int
.text$mn:00000E5E                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000E63                 add     eax, 0Ch
.text$mn:00000E66                 mov     ecx, eax        ; this
.text$mn:00000E68                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00000E6D                 mov     ecx, [ebp+arg_0]
.text$mn:00000E70                 mov     edx, [ecx+0Ch]
.text$mn:00000E73                 sub     edx, eax
.text$mn:00000E75                 mov     eax, [ebp+arg_0]
.text$mn:00000E78                 mov     [eax+0Ch], edx
.text$mn:00000E7B                 push    5               ; int
.text$mn:00000E7D                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000E82                 add     eax, 0Ch
.text$mn:00000E85                 mov     ecx, eax        ; this
.text$mn:00000E87                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00000E8C                 mov     ecx, [ebp+arg_0]
.text$mn:00000E8F                 add     eax, [ecx]
.text$mn:00000E91                 mov     edx, [ebp+arg_0]
.text$mn:00000E94                 mov     [edx], eax
.text$mn:00000E96                 mov     esp, ebp
.text$mn:00000E98                 pop     ebp
.text$mn:00000E99                 retn    4
.text$mn:00000E99 ?getClientRect@ShortcutMapper@@UBEXAAUtagRECT@@@Z endp
.text$mn:00000E99
.text$mn:00000E9C
.text$mn:00000E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E9C
.text$mn:00000E9C ; Attributes: bp-based frame
.text$mn:00000E9C
.text$mn:00000E9C ; void __thiscall ShortcutMapper::translateTab(ShortcutMapper *this, int, const wchar_t *)
.text$mn:00000E9C                 public ?translateTab@ShortcutMapper@@QAEXHPB_W@Z
.text$mn:00000E9C ?translateTab@ShortcutMapper@@QAEXHPB_W@Z proc near
.text$mn:00000E9C
.text$mn:00000E9C var_4           = dword ptr -4
.text$mn:00000E9C arg_0           = dword ptr  8
.text$mn:00000E9C Source          = dword ptr  0Ch
.text$mn:00000E9C
.text$mn:00000E9C                 push    ebp
.text$mn:00000E9D                 mov     ebp, esp
.text$mn:00000E9F                 push    ecx
.text$mn:00000EA0                 mov     [ebp+var_4], ecx
.text$mn:00000EA3                 cmp     [ebp+arg_0], 0
.text$mn:00000EA7                 jl      short loc_EAF
.text$mn:00000EA9                 cmp     [ebp+arg_0], 4
.text$mn:00000EAD                 jle     short loc_EB1
.text$mn:00000EAF
.text$mn:00000EAF loc_EAF:                                ; CODE XREF: ShortcutMapper::translateTab(int,wchar_t const *)+Bj
.text$mn:00000EAF                 jmp     short loc_ECD
.text$mn:00000EB1 ; ---------------------------------------------------------------------------
.text$mn:00000EB1
.text$mn:00000EB1 loc_EB1:                                ; CODE XREF: ShortcutMapper::translateTab(int,wchar_t const *)+11j
.text$mn:00000EB1                 push    40h ; '@'       ; Count
.text$mn:00000EB3                 mov     eax, [ebp+Source]
.text$mn:00000EB6                 push    eax             ; Source
.text$mn:00000EB7                 mov     ecx, [ebp+arg_0]
.text$mn:00000EBA                 shl     ecx, 7
.text$mn:00000EBD                 mov     edx, [ebp+var_4]
.text$mn:00000EC0                 lea     eax, [edx+ecx+50h]
.text$mn:00000EC4                 push    eax             ; Dest
.text$mn:00000EC5                 call    _wcsncpy
.text$mn:00000ECA                 add     esp, 0Ch
.text$mn:00000ECD
.text$mn:00000ECD loc_ECD:                                ; CODE XREF: ShortcutMapper::translateTab(int,wchar_t const *):loc_EAFj
.text$mn:00000ECD                 mov     esp, ebp
.text$mn:00000ECF                 pop     ebp
.text$mn:00000ED0                 retn    8
.text$mn:00000ED0 ?translateTab@ShortcutMapper@@QAEXHPB_W@Z endp
.text$mn:00000ED0
.text$mn:00000ED0 ; ---------------------------------------------------------------------------
.text$mn:00000ED3                 db 9 dup(0CCh)
.text$mn:00000EDC
.text$mn:00000EDC ; =============== S U B R O U T I N E =======================================
.text$mn:00000EDC
.text$mn:00000EDC ; Attributes: bp-based frame
.text$mn:00000EDC
.text$mn:00000EDC ; int __stdcall ShortcutMapper::run_dlgProc(ShortcutMapper *this, unsigned int, unsigned int, __int32)
.text$mn:00000EDC                 public ?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z
.text$mn:00000EDC ?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z proc near
.text$mn:00000EDC
.text$mn:00000EDC var_1164        = byte ptr -1164h
.text$mn:00000EDC var_1158        = byte ptr -1158h
.text$mn:00000EDC var_114C        = byte ptr -114Ch
.text$mn:00000EDC var_1140        = byte ptr -1140h
.text$mn:00000EDC var_1134        = byte ptr -1134h
.text$mn:00000EDC var_1128        = byte ptr -1128h
.text$mn:00000EDC var_111C        = dword ptr -111Ch
.text$mn:00000EDC var_1118        = dword ptr -1118h
.text$mn:00000EDC Point           = tagPOINT ptr -1114h
.text$mn:00000EDC var_110C        = dword ptr -110Ch
.text$mn:00000EDC var_1108        = dword ptr -1108h
.text$mn:00000EDC var_1104        = dword ptr -1104h
.text$mn:00000EDC var_1100        = dword ptr -1100h
.text$mn:00000EDC var_10FC        = byte ptr -10FCh
.text$mn:00000EDC var_10EC        = dword ptr -10ECh
.text$mn:00000EDC var_10E8        = dword ptr -10E8h
.text$mn:00000EDC var_10E4        = dword ptr -10E4h
.text$mn:00000EDC var_10E0        = dword ptr -10E0h
.text$mn:00000EDC var_10DC        = dword ptr -10DCh
.text$mn:00000EDC var_10D8        = dword ptr -10D8h
.text$mn:00000EDC var_10D4        = dword ptr -10D4h
.text$mn:00000EDC var_10D0        = dword ptr -10D0h
.text$mn:00000EDC var_10CC        = dword ptr -10CCh
.text$mn:00000EDC var_10C8        = dword ptr -10C8h
.text$mn:00000EDC var_10C4        = dword ptr -10C4h
.text$mn:00000EDC var_10C0        = dword ptr -10C0h
.text$mn:00000EDC var_10BC        = dword ptr -10BCh
.text$mn:00000EDC var_10B8        = dword ptr -10B8h
.text$mn:00000EDC var_10B4        = dword ptr -10B4h
.text$mn:00000EDC var_10B0        = dword ptr -10B0h
.text$mn:00000EDC var_10AC        = dword ptr -10ACh
.text$mn:00000EDC var_10A8        = dword ptr -10A8h
.text$mn:00000EDC var_10A4        = dword ptr -10A4h
.text$mn:00000EDC wParam          = dword ptr -10A0h
.text$mn:00000EDC var_109C        = dword ptr -109Ch
.text$mn:00000EDC var_1098        = dword ptr -1098h
.text$mn:00000EDC var_1094        = dword ptr -1094h
.text$mn:00000EDC var_1090        = dword ptr -1090h
.text$mn:00000EDC var_108C        = dword ptr -108Ch
.text$mn:00000EDC var_1088        = dword ptr -1088h
.text$mn:00000EDC var_1084        = dword ptr -1084h
.text$mn:00000EDC var_1080        = dword ptr -1080h
.text$mn:00000EDC var_107C        = dword ptr -107Ch
.text$mn:00000EDC var_1078        = dword ptr -1078h
.text$mn:00000EDC var_1074        = dword ptr -1074h
.text$mn:00000EDC var_1070        = dword ptr -1070h
.text$mn:00000EDC var_106C        = dword ptr -106Ch
.text$mn:00000EDC var_1068        = dword ptr -1068h
.text$mn:00000EDC var_1064        = dword ptr -1064h
.text$mn:00000EDC var_1060        = dword ptr -1060h
.text$mn:00000EDC var_105C        = dword ptr -105Ch
.text$mn:00000EDC var_1058        = dword ptr -1058h
.text$mn:00000EDC uPosition       = dword ptr -1054h
.text$mn:00000EDC lParam          = dword ptr -1050h
.text$mn:00000EDC var_104C        = dword ptr -104Ch
.text$mn:00000EDC var_1048        = dword ptr -1048h
.text$mn:00000EDC var_1044        = dword ptr -1044h
.text$mn:00000EDC var_1040        = dword ptr -1040h
.text$mn:00000EDC var_103C        = dword ptr -103Ch
.text$mn:00000EDC var_1038        = dword ptr -1038h
.text$mn:00000EDC var_1034        = dword ptr -1034h
.text$mn:00000EDC var_1030        = dword ptr -1030h
.text$mn:00000EDC hMenu           = dword ptr -102Ch
.text$mn:00000EDC var_1028        = dword ptr -1028h
.text$mn:00000EDC var_1024        = dword ptr -1024h
.text$mn:00000EDC var_1020        = byte ptr -1020h
.text$mn:00000EDC var_EE4         = byte ptr -0EE4h
.text$mn:00000EDC var_DA0         = byte ptr -0DA0h
.text$mn:00000EDC var_C74         = byte ptr -0C74h
.text$mn:00000EDC var_B24         = byte ptr -0B24h
.text$mn:00000EDC var_9DC         = byte ptr -9DCh
.text$mn:00000EDC var_894         = byte ptr -894h
.text$mn:00000EDC var_758         = byte ptr -758h
.text$mn:00000EDC var_614         = byte ptr -614h
.text$mn:00000EDC var_4E8         = byte ptr -4E8h
.text$mn:00000EDC var_3AC         = byte ptr -3ACh
.text$mn:00000EDC var_264         = byte ptr -264h
.text$mn:00000EDC var_228         = byte ptr -228h
.text$mn:00000EDC var_1EC         = byte ptr -1ECh
.text$mn:00000EDC var_9C          = byte ptr -9Ch
.text$mn:00000EDC var_80          = byte ptr -80h
.text$mn:00000EDC var_64          = byte ptr -64h
.text$mn:00000EDC var_48          = byte ptr -48h
.text$mn:00000EDC var_2C          = byte ptr -2Ch
.text$mn:00000EDC var_10          = dword ptr -10h
.text$mn:00000EDC var_C           = dword ptr -0Ch
.text$mn:00000EDC var_4           = dword ptr -4
.text$mn:00000EDC this            = dword ptr  8
.text$mn:00000EDC arg_4           = dword ptr  0Ch
.text$mn:00000EDC arg_8           = dword ptr  10h
.text$mn:00000EDC arg_C           = dword ptr  14h
.text$mn:00000EDC
.text$mn:00000EDC                 push    ebp
.text$mn:00000EDD                 mov     ebp, esp
.text$mn:00000EDF                 push    0FFFFFFFFh
.text$mn:00000EE1                 push    offset __ehhandler$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z
.text$mn:00000EE6                 mov     eax, large fs:0
.text$mn:00000EEC                 push    eax
.text$mn:00000EED                 mov     eax, 1158h
.text$mn:00000EF2                 call    __chkstk
.text$mn:00000EF7                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EFC                 xor     eax, ebp
.text$mn:00000EFE                 mov     [ebp+var_10], eax
.text$mn:00000F01                 push    eax
.text$mn:00000F02                 lea     eax, [ebp+var_C]
.text$mn:00000F05                 mov     large fs:0, eax
.text$mn:00000F0B                 mov     eax, [ebp+arg_4]
.text$mn:00000F0E                 mov     [ebp+var_106C], eax
.text$mn:00000F14                 cmp     [ebp+var_106C], 4Eh ; 'N'
.text$mn:00000F1B                 jz      short loc_F7B
.text$mn:00000F1D                 cmp     [ebp+var_106C], 110h
.text$mn:00000F27                 jz      short loc_F3E
.text$mn:00000F29                 cmp     [ebp+var_106C], 111h
.text$mn:00000F33                 jz      loc_103F
.text$mn:00000F39                 jmp     loc_1FAC
.text$mn:00000F3E ; ---------------------------------------------------------------------------
.text$mn:00000F3E
.text$mn:00000F3E loc_F3E:                                ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+4Bj
.text$mn:00000F3E                 mov     ecx, [ebp+this] ; this
.text$mn:00000F41                 call    ?initBabyGrid@ShortcutMapper@@AAEXXZ ; ShortcutMapper::initBabyGrid(void)
.text$mn:00000F46                 mov     ecx, [ebp+this] ; this
.text$mn:00000F49                 call    ?initTabs@ShortcutMapper@@AAEXXZ ; ShortcutMapper::initTabs(void)
.text$mn:00000F4E                 mov     ecx, [ebp+this] ; this
.text$mn:00000F51                 call    ?fillOutBabyGrid@ShortcutMapper@@AAEXXZ ; ShortcutMapper::fillOutBabyGrid(void)
.text$mn:00000F56                 push    1
.text$mn:00000F58                 mov     ecx, [ebp+this]
.text$mn:00000F5B                 add     ecx, 20h ; ' '
.text$mn:00000F5E                 mov     edx, [ebp+this]
.text$mn:00000F61                 mov     eax, [edx+20h]
.text$mn:00000F64                 mov     edx, [eax+0Ch]
.text$mn:00000F67                 call    edx
.text$mn:00000F69                 mov     ecx, [ebp+this] ; this
.text$mn:00000F6C                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:00000F71                 mov     eax, 1
.text$mn:00000F76                 jmp     loc_1FB2
.text$mn:00000F7B ; ---------------------------------------------------------------------------
.text$mn:00000F7B
.text$mn:00000F7B loc_F7B:                                ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+3Fj
.text$mn:00000F7B                 mov     eax, [ebp+arg_C]
.text$mn:00000F7E                 mov     ecx, [eax]
.text$mn:00000F80                 mov     [ebp+var_10EC], ecx
.text$mn:00000F86                 mov     edx, [eax+4]
.text$mn:00000F89                 mov     [ebp+var_10E8], edx
.text$mn:00000F8F                 mov     eax, [eax+8]
.text$mn:00000F92                 mov     [ebp+var_10E4], eax
.text$mn:00000F98                 mov     ecx, [ebp+this]
.text$mn:00000F9B                 mov     edx, [ebp+var_10EC]
.text$mn:00000FA1                 cmp     edx, [ecx+4Ch]
.text$mn:00000FA4                 jnz     loc_103A
.text$mn:00000FAA                 cmp     [ebp+var_10E4], 0FFFFFDD9h
.text$mn:00000FB4                 jnz     loc_103A
.text$mn:00000FBA                 push    0               ; lParam
.text$mn:00000FBC                 push    0               ; wParam
.text$mn:00000FBE                 push    130Bh           ; Msg
.text$mn:00000FC3                 mov     eax, [ebp+this]
.text$mn:00000FC6                 mov     ecx, [eax+4Ch]
.text$mn:00000FC9                 push    ecx             ; hWnd
.text$mn:00000FCA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000FD0                 mov     [ebp+var_10D8], eax
.text$mn:00000FD6                 mov     edx, [ebp+var_10D8]
.text$mn:00000FDC                 mov     [ebp+var_1078], edx
.text$mn:00000FE2                 cmp     [ebp+var_1078], 4 ; switch 5 cases
.text$mn:00000FE9                 ja      short loc_1032  ; jumptable 00000FF1 default case
.text$mn:00000FEB                 mov     eax, [ebp+var_1078]
.text$mn:00000FF1                 jmp     ds:$LN88[eax*4] ; switch jump
.text$mn:00000FF8 ; ---------------------------------------------------------------------------
.text$mn:00000FF8
.text$mn:00000FF8 $LN47:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+115j
.text$mn:00000FF8                                         ; DATA XREF: .text$mn:$LN88o
.text$mn:00000FF8                 mov     ecx, [ebp+this] ; jumptable 00000FF1 case 0
.text$mn:00000FFB                 mov     dword ptr [ecx+48h], 0
.text$mn:00001002                 jmp     short loc_1032  ; jumptable 00000FF1 default case
.text$mn:00001004 ; ---------------------------------------------------------------------------
.text$mn:00001004
.text$mn:00001004 $LN46:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+115j
.text$mn:00001004                                         ; DATA XREF: .text$mn:$LN88o
.text$mn:00001004                 mov     edx, [ebp+this] ; jumptable 00000FF1 case 1
.text$mn:00001007                 mov     dword ptr [edx+48h], 1
.text$mn:0000100E                 jmp     short loc_1032  ; jumptable 00000FF1 default case
.text$mn:00001010 ; ---------------------------------------------------------------------------
.text$mn:00001010
.text$mn:00001010 $LN45:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+115j
.text$mn:00001010                                         ; DATA XREF: .text$mn:$LN88o
.text$mn:00001010                 mov     eax, [ebp+this] ; jumptable 00000FF1 case 2
.text$mn:00001013                 mov     dword ptr [eax+48h], 2
.text$mn:0000101A                 jmp     short loc_1032  ; jumptable 00000FF1 default case
.text$mn:0000101C ; ---------------------------------------------------------------------------
.text$mn:0000101C
.text$mn:0000101C $LN44:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+115j
.text$mn:0000101C                                         ; DATA XREF: .text$mn:$LN88o
.text$mn:0000101C                 mov     ecx, [ebp+this] ; jumptable 00000FF1 case 3
.text$mn:0000101F                 mov     dword ptr [ecx+48h], 3
.text$mn:00001026                 jmp     short loc_1032  ; jumptable 00000FF1 default case
.text$mn:00001028 ; ---------------------------------------------------------------------------
.text$mn:00001028
.text$mn:00001028 $LN43:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+115j
.text$mn:00001028                                         ; DATA XREF: .text$mn:$LN88o
.text$mn:00001028                 mov     edx, [ebp+this] ; jumptable 00000FF1 case 4
.text$mn:0000102B                 mov     dword ptr [edx+48h], 4
.text$mn:00001032
.text$mn:00001032 loc_1032:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+10Dj
.text$mn:00001032                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+126j ...
.text$mn:00001032                 mov     ecx, [ebp+this] ; jumptable 00000FF1 default case
.text$mn:00001035                 call    ?fillOutBabyGrid@ShortcutMapper@@AAEXXZ ; ShortcutMapper::fillOutBabyGrid(void)
.text$mn:0000103A
.text$mn:0000103A loc_103A:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+C8j
.text$mn:0000103A                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+D8j
.text$mn:0000103A                 jmp     loc_1FB0
.text$mn:0000103F ; ---------------------------------------------------------------------------
.text$mn:0000103F
.text$mn:0000103F loc_103F:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+57j
.text$mn:0000103F                 mov     eax, [ebp+arg_8]
.text$mn:00001042                 and     eax, 0FFFFh
.text$mn:00001047                 movzx   ecx, ax
.text$mn:0000104A                 mov     [ebp+var_1030], ecx
.text$mn:00001050                 cmp     [ebp+var_1030], 0A29h
.text$mn:0000105A                 jg      short loc_1083
.text$mn:0000105C                 cmp     [ebp+var_1030], 0A29h
.text$mn:00001066                 jz      loc_1DF5
.text$mn:0000106C                 cmp     [ebp+var_1030], 1
.text$mn:00001073                 jz      short loc_10BD
.text$mn:00001075                 cmp     [ebp+var_1030], 2
.text$mn:0000107C                 jz      short loc_10A4
.text$mn:0000107E                 jmp     loc_1FAC
.text$mn:00001083 ; ---------------------------------------------------------------------------
.text$mn:00001083
.text$mn:00001083 loc_1083:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+17Ej
.text$mn:00001083                 cmp     [ebp+var_1030], 0A2Ah
.text$mn:0000108D                 jz      short loc_10D6
.text$mn:0000108F                 cmp     [ebp+var_1030], 0A2Bh
.text$mn:00001099                 jz      loc_18FE
.text$mn:0000109F                 jmp     loc_1FAC
.text$mn:000010A4 ; ---------------------------------------------------------------------------
.text$mn:000010A4
.text$mn:000010A4 loc_10A4:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+1A0j
.text$mn:000010A4                 push    0FFFFFFFFh      ; nResult
.text$mn:000010A6                 mov     edx, [ebp+this]
.text$mn:000010A9                 mov     eax, [edx+0Ch]
.text$mn:000010AC                 push    eax             ; hDlg
.text$mn:000010AD                 call    dword ptr ds:__imp__EndDialog@8 ; EndDialog(x,x)
.text$mn:000010B3                 mov     eax, 1
.text$mn:000010B8                 jmp     loc_1FB2
.text$mn:000010BD ; ---------------------------------------------------------------------------
.text$mn:000010BD
.text$mn:000010BD loc_10BD:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+197j
.text$mn:000010BD                 push    0               ; nResult
.text$mn:000010BF                 mov     ecx, [ebp+this]
.text$mn:000010C2                 mov     edx, [ecx+0Ch]
.text$mn:000010C5                 push    edx             ; hDlg
.text$mn:000010C6                 call    dword ptr ds:__imp__EndDialog@8 ; EndDialog(x,x)
.text$mn:000010CC                 mov     eax, 1
.text$mn:000010D1                 jmp     loc_1FB2
.text$mn:000010D6 ; ---------------------------------------------------------------------------
.text$mn:000010D6
.text$mn:000010D6 loc_10D6:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+1B1j
.text$mn:000010D6                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000010DB                 mov     [ebp+var_1028], eax
.text$mn:000010E1                 mov     ecx, [ebp+this]
.text$mn:000010E4                 add     ecx, 20h ; ' '  ; this
.text$mn:000010E7                 call    ?getSelectedRow@BabyGridWrapper@@QAEHXZ ; BabyGridWrapper::getSelectedRow(void)
.text$mn:000010EC                 mov     [ebp+var_1024], eax
.text$mn:000010F2                 mov     eax, [ebp+this]
.text$mn:000010F5                 mov     ecx, [eax+48h]
.text$mn:000010F8                 mov     [ebp+var_1074], ecx
.text$mn:000010FE                 cmp     [ebp+var_1074], 4 ; switch 5 cases
.text$mn:00001105                 ja      loc_18F4        ; jumptable 00001111 default case
.text$mn:0000110B                 mov     edx, [ebp+var_1074]
.text$mn:00001111                 jmp     ds:$LN89[edx*4] ; switch jump
.text$mn:00001118 ; ---------------------------------------------------------------------------
.text$mn:00001118
.text$mn:00001118 $LN34:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+235j
.text$mn:00001118                                         ; DATA XREF: .text$mn:$LN89o
.text$mn:00001118                 mov     ecx, [ebp+var_1028] ; jumptable 00001111 case 0
.text$mn:0000111E                 call    ?getUserShortcuts@NppParameters@@QAEAAV?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@XZ ; NppParameters::getUserShortcuts(void)
.text$mn:00001123                 mov     [ebp+var_1064], eax
.text$mn:00001129                 mov     eax, [ebp+var_1024]
.text$mn:0000112F                 sub     eax, 1
.text$mn:00001132                 push    eax
.text$mn:00001133                 mov     ecx, [ebp+var_1064]
.text$mn:00001139                 call    ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)
.text$mn:0000113E                 push    eax             ; Shortcut *
.text$mn:0000113F                 lea     ecx, [ebp+var_614]
.text$mn:00001145                 call    ??0CommandShortcut@@QAE@ABV0@@Z ; CommandShortcut::CommandShortcut(CommandShortcut const &)
.text$mn:0000114A                 mov     [ebp+var_4], 0
.text$mn:00001151                 mov     ecx, [ebp+var_1024]
.text$mn:00001157                 sub     ecx, 1
.text$mn:0000115A                 push    ecx
.text$mn:0000115B                 mov     ecx, [ebp+var_1064]
.text$mn:00001161                 call    ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)
.text$mn:00001166                 push    eax             ; Shortcut *
.text$mn:00001167                 lea     ecx, [ebp+var_DA0]
.text$mn:0000116D                 call    ??0CommandShortcut@@QAE@ABV0@@Z ; CommandShortcut::CommandShortcut(CommandShortcut const &)
.text$mn:00001172                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001176                 mov     edx, [ebp+this]
.text$mn:00001179                 mov     eax, [edx+0Ch]
.text$mn:0000117C                 push    eax             ; HWND
.text$mn:0000117D                 mov     ecx, [ebp+this]
.text$mn:00001180                 mov     edx, [ecx+4]
.text$mn:00001183                 push    edx             ; HINSTANCE
.text$mn:00001184                 lea     ecx, [ebp+var_614] ; this
.text$mn:0000118A                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:0000118F                 lea     ecx, [ebp+var_614] ; this
.text$mn:00001195                 call    ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.text$mn:0000119A                 cmp     eax, 0FFFFFFFFh
.text$mn:0000119D                 jz      loc_125F
.text$mn:000011A3                 lea     eax, [ebp+var_614]
.text$mn:000011A9                 push    eax             ; Shortcut *
.text$mn:000011AA                 lea     ecx, [ebp+var_DA0]
.text$mn:000011B0                 push    ecx             ; Shortcut *
.text$mn:000011B1                 call    ??9@YA?B_NABVShortcut@@0@Z ; operator!=(Shortcut const &,Shortcut const &)
.text$mn:000011B6                 add     esp, 8
.text$mn:000011B9                 movzx   edx, al
.text$mn:000011BC                 test    edx, edx
.text$mn:000011BE                 jz      loc_125F
.text$mn:000011C4                 mov     eax, [ebp+var_1024]
.text$mn:000011CA                 sub     eax, 1
.text$mn:000011CD                 push    eax             ; int
.text$mn:000011CE                 mov     ecx, [ebp+var_1028] ; this
.text$mn:000011D4                 call    ?addUserModifiedIndex@NppParameters@@QAEXH@Z ; NppParameters::addUserModifiedIndex(int)
.text$mn:000011D9                 lea     ecx, [ebp+var_614]
.text$mn:000011DF                 push    ecx             ; Shortcut *
.text$mn:000011E0                 mov     edx, [ebp+var_1024]
.text$mn:000011E6                 sub     edx, 1
.text$mn:000011E9                 push    edx
.text$mn:000011EA                 mov     ecx, [ebp+var_1064]
.text$mn:000011F0                 call    ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)
.text$mn:000011F5                 mov     ecx, eax
.text$mn:000011F7                 call    ??4CommandShortcut@@QAEAAV0@ABV0@@Z ; CommandShortcut::operator=(CommandShortcut const &)
.text$mn:000011FC                 lea     eax, [ebp+var_2C]
.text$mn:000011FF                 push    eax
.text$mn:00001200                 lea     ecx, [ebp+var_614]
.text$mn:00001206                 call    ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.text$mn:0000120B                 mov     [ebp+var_108C], eax
.text$mn:00001211                 mov     ecx, [ebp+var_108C]
.text$mn:00001217                 mov     [ebp+var_1094], ecx
.text$mn:0000121D                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001221                 mov     ecx, [ebp+var_1094]
.text$mn:00001227                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000122C                 push    eax             ; wchar_t *
.text$mn:0000122D                 push    2               ; unsigned int
.text$mn:0000122F                 mov     edx, [ebp+var_1024]
.text$mn:00001235                 push    edx             ; unsigned int
.text$mn:00001236                 mov     ecx, [ebp+this]
.text$mn:00001239                 add     ecx, 20h ; ' '  ; this
.text$mn:0000123C                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:00001241                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001245                 lea     ecx, [ebp+var_2C]
.text$mn:00001248                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000124D                 mov     ecx, [ebp+var_1028] ; this
.text$mn:00001253                 call    ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ ; NppParameters::getAccelerator(void)
.text$mn:00001258                 mov     ecx, eax        ; this
.text$mn:0000125A                 call    ?updateShortcuts@Accelerator@@QAEXXZ ; Accelerator::updateShortcuts(void)
.text$mn:0000125F
.text$mn:0000125F loc_125F:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+2C1j
.text$mn:0000125F                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+2E2j
.text$mn:0000125F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001263                 lea     ecx, [ebp+var_DA0] ; this
.text$mn:00001269                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:0000126E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001275                 lea     ecx, [ebp+var_614] ; this
.text$mn:0000127B                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:00001280                 jmp     loc_18F4        ; jumptable 00001111 default case
.text$mn:00001285 ; ---------------------------------------------------------------------------
.text$mn:00001285
.text$mn:00001285 $LN32:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+235j
.text$mn:00001285                                         ; DATA XREF: .text$mn:$LN89o
.text$mn:00001285                 mov     ecx, [ebp+var_1028] ; jumptable 00001111 case 1
.text$mn:0000128B                 call    ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ ; NppParameters::getMacroList(void)
.text$mn:00001290                 mov     [ebp+var_1058], eax
.text$mn:00001296                 mov     eax, [ebp+var_1024]
.text$mn:0000129C                 sub     eax, 1
.text$mn:0000129F                 push    eax
.text$mn:000012A0                 mov     ecx, [ebp+var_1058]
.text$mn:000012A6                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:000012AB                 push    eax             ; Shortcut *
.text$mn:000012AC                 lea     ecx, [ebp+var_4E8]
.text$mn:000012B2                 call    ??0MacroShortcut@@QAE@ABV0@@Z ; MacroShortcut::MacroShortcut(MacroShortcut const &)
.text$mn:000012B7                 mov     [ebp+var_4], 3
.text$mn:000012BE                 mov     ecx, [ebp+var_1024]
.text$mn:000012C4                 sub     ecx, 1
.text$mn:000012C7                 push    ecx
.text$mn:000012C8                 mov     ecx, [ebp+var_1058]
.text$mn:000012CE                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:000012D3                 push    eax             ; Shortcut *
.text$mn:000012D4                 lea     ecx, [ebp+var_1020]
.text$mn:000012DA                 call    ??0MacroShortcut@@QAE@ABV0@@Z ; MacroShortcut::MacroShortcut(MacroShortcut const &)
.text$mn:000012DF                 mov     byte ptr [ebp+var_4], 4
.text$mn:000012E3                 mov     edx, [ebp+this]
.text$mn:000012E6                 mov     eax, [edx+0Ch]
.text$mn:000012E9                 push    eax             ; HWND
.text$mn:000012EA                 mov     ecx, [ebp+this]
.text$mn:000012ED                 mov     edx, [ecx+4]
.text$mn:000012F0                 push    edx             ; HINSTANCE
.text$mn:000012F1                 lea     ecx, [ebp+var_4E8] ; this
.text$mn:000012F7                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:000012FC                 lea     ecx, [ebp+var_4E8] ; this
.text$mn:00001302                 call    ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.text$mn:00001307                 cmp     eax, 0FFFFFFFFh
.text$mn:0000130A                 jz      loc_13D7
.text$mn:00001310                 lea     eax, [ebp+var_4E8]
.text$mn:00001316                 push    eax             ; Shortcut *
.text$mn:00001317                 lea     ecx, [ebp+var_1020]
.text$mn:0000131D                 push    ecx             ; Shortcut *
.text$mn:0000131E                 call    ??9@YA?B_NABVShortcut@@0@Z ; operator!=(Shortcut const &,Shortcut const &)
.text$mn:00001323                 add     esp, 8
.text$mn:00001326                 movzx   edx, al
.text$mn:00001329                 test    edx, edx
.text$mn:0000132B                 jz      loc_13D7
.text$mn:00001331                 lea     eax, [ebp+var_4E8]
.text$mn:00001337                 push    eax             ; Shortcut *
.text$mn:00001338                 mov     ecx, [ebp+var_1024]
.text$mn:0000133E                 sub     ecx, 1
.text$mn:00001341                 push    ecx
.text$mn:00001342                 mov     ecx, [ebp+var_1058]
.text$mn:00001348                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:0000134D                 mov     ecx, eax
.text$mn:0000134F                 call    ??4MacroShortcut@@QAEAAV0@ABV0@@Z ; MacroShortcut::operator=(MacroShortcut const &)
.text$mn:00001354                 lea     ecx, [ebp+var_4E8] ; this
.text$mn:0000135A                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:0000135F                 push    eax             ; wchar_t *
.text$mn:00001360                 push    1               ; unsigned int
.text$mn:00001362                 mov     edx, [ebp+var_1024]
.text$mn:00001368                 push    edx             ; unsigned int
.text$mn:00001369                 mov     ecx, [ebp+this]
.text$mn:0000136C                 add     ecx, 20h ; ' '  ; this
.text$mn:0000136F                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:00001374                 lea     eax, [ebp+var_48]
.text$mn:00001377                 push    eax
.text$mn:00001378                 lea     ecx, [ebp+var_4E8]
.text$mn:0000137E                 call    ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.text$mn:00001383                 mov     [ebp+var_109C], eax
.text$mn:00001383                                         ; DATA XREF: Shortcut::doDialog(void)+17o
.text$mn:00001389
.text$mn:00001389 ; const WCHAR TemplateName
.text$mn:00001389 TemplateName:                           ; DATA XREF: ScintillaKeyMap::doDialog(void)+17o
.text$mn:00001389                 mov     ecx, [ebp+var_109C]
.text$mn:0000138F                 mov     [ebp+var_10C8], ecx
.text$mn:00001395                 mov     byte ptr [ebp+var_4], 5
.text$mn:00001399                 mov     ecx, [ebp+var_10C8]
.text$mn:0000139F                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000013A4                 push    eax             ; wchar_t *
.text$mn:000013A5                 push    2               ; unsigned int
.text$mn:000013A7                 mov     edx, [ebp+var_1024]
.text$mn:000013AD                 push    edx             ; unsigned int
.text$mn:000013AE                 mov     ecx, [ebp+this]
.text$mn:000013B1                 add     ecx, 20h ; ' '  ; this
.text$mn:000013B4                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000013B9                 mov     byte ptr [ebp+var_4], 4
.text$mn:000013BD                 lea     ecx, [ebp+var_48]
.text$mn:000013C0                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000013C5                 mov     ecx, [ebp+var_1028] ; this
.text$mn:000013CB                 call    ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ ; NppParameters::getAccelerator(void)
.text$mn:000013D0                 mov     ecx, eax        ; this
.text$mn:000013D2                 call    ?updateShortcuts@Accelerator@@QAEXXZ ; Accelerator::updateShortcuts(void)
.text$mn:000013D7
.text$mn:000013D7 loc_13D7:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+42Ej
.text$mn:000013D7                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+44Fj
.text$mn:000013D7                 mov     byte ptr [ebp+var_4], 3
.text$mn:000013DB                 lea     ecx, [ebp+var_1020] ; this
.text$mn:000013E1                 call    ??1MacroShortcut@@UAE@XZ ; MacroShortcut::~MacroShortcut(void)
.text$mn:000013E6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013ED                 lea     ecx, [ebp+var_4E8] ; this
.text$mn:000013F3                 call    ??1MacroShortcut@@UAE@XZ ; MacroShortcut::~MacroShortcut(void)
.text$mn:000013F8                 jmp     loc_18F4        ; jumptable 00001111 default case
.text$mn:000013FD ; ---------------------------------------------------------------------------
.text$mn:000013FD
.text$mn:000013FD $LN30:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+235j
.text$mn:000013FD                                         ; DATA XREF: .text$mn:$LN89o
.text$mn:000013FD                 mov     ecx, [ebp+var_1028] ; jumptable 00001111 case 2
.text$mn:00001403                 call    ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ ; NppParameters::getUserCommandList(void)
.text$mn:00001408                 mov     [ebp+var_1060], eax
.text$mn:0000140E                 mov     eax, [ebp+var_1024]
.text$mn:00001414                 sub     eax, 1
.text$mn:00001417                 push    eax
.text$mn:00001418                 mov     ecx, [ebp+var_1060]
.text$mn:0000141E                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:00001423                 push    eax             ; Shortcut *
.text$mn:00001424                 lea     ecx, [ebp+var_3AC]
.text$mn:0000142A                 call    ??0UserCommand@@QAE@ABV0@@Z ; UserCommand::UserCommand(UserCommand const &)
.text$mn:0000142F                 mov     [ebp+var_4], 6
.text$mn:00001436                 mov     ecx, [ebp+var_1024]
.text$mn:0000143C                 sub     ecx, 1
.text$mn:0000143F                 push    ecx
.text$mn:00001440                 mov     ecx, [ebp+var_1060]
.text$mn:00001446                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:0000144B                 push    eax             ; Shortcut *
.text$mn:0000144C                 lea     ecx, [ebp+var_B24]
.text$mn:00001452                 call    ??0UserCommand@@QAE@ABV0@@Z ; UserCommand::UserCommand(UserCommand const &)
.text$mn:00001457                 mov     byte ptr [ebp+var_4], 7
.text$mn:0000145B                 mov     edx, [ebp+this]
.text$mn:0000145E                 mov     eax, [edx+0Ch]
.text$mn:00001461                 push    eax             ; HWND
.text$mn:00001462                 mov     ecx, [ebp+this]
.text$mn:00001465                 mov     edx, [ecx+4]
.text$mn:00001468                 push    edx             ; HINSTANCE
.text$mn:00001469                 lea     ecx, [ebp+var_3AC] ; this
.text$mn:0000146F                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00001474                 lea     eax, [ebp+var_3AC]
.text$mn:0000147A                 push    eax             ; Shortcut *
.text$mn:0000147B                 lea     ecx, [ebp+var_B24]
.text$mn:00001481                 call    ??4UserCommand@@QAEAAV0@ABV0@@Z ; UserCommand::operator=(UserCommand const &)
.text$mn:00001486                 lea     ecx, [ebp+var_3AC] ; this
.text$mn:0000148C                 call    ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.text$mn:00001491                 cmp     eax, 0FFFFFFFFh
.text$mn:00001494                 jz      loc_1561
.text$mn:0000149A                 lea     ecx, [ebp+var_3AC]
.text$mn:000014A0                 push    ecx             ; Shortcut *
.text$mn:000014A1                 lea     edx, [ebp+var_B24]
.text$mn:000014A7                 push    edx             ; Shortcut *
.text$mn:000014A8                 call    ??9@YA?B_NABVShortcut@@0@Z ; operator!=(Shortcut const &,Shortcut const &)
.text$mn:000014AD                 add     esp, 8
.text$mn:000014B0                 movzx   eax, al
.text$mn:000014B3                 test    eax, eax
.text$mn:000014B5                 jz      loc_1561
.text$mn:000014BB                 lea     ecx, [ebp+var_3AC]
.text$mn:000014C1                 push    ecx             ; Shortcut *
.text$mn:000014C2                 mov     edx, [ebp+var_1024]
.text$mn:000014C8                 sub     edx, 1
.text$mn:000014CB                 push    edx
.text$mn:000014CC                 mov     ecx, [ebp+var_1060]
.text$mn:000014D2                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:000014D7                 mov     ecx, eax
.text$mn:000014D9                 call    ??4UserCommand@@QAEAAV0@ABV0@@Z ; UserCommand::operator=(UserCommand const &)
.text$mn:000014DE                 lea     ecx, [ebp+var_3AC] ; this
.text$mn:000014E4                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:000014E9                 push    eax             ; wchar_t *
.text$mn:000014EA                 push    1               ; unsigned int
.text$mn:000014EC                 mov     eax, [ebp+var_1024]
.text$mn:000014F2                 push    eax             ; unsigned int
.text$mn:000014F3                 mov     ecx, [ebp+this]
.text$mn:000014F6                 add     ecx, 20h ; ' '  ; this
.text$mn:000014F9                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000014FE                 lea     ecx, [ebp+var_80]
.text$mn:00001501                 push    ecx
.text$mn:00001502                 lea     ecx, [ebp+var_3AC]
.text$mn:00001508                 call    ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.text$mn:0000150D                 mov     [ebp+var_10B8], eax
.text$mn:00001513                 mov     edx, [ebp+var_10B8]
.text$mn:00001519                 mov     [ebp+var_10DC], edx
.text$mn:0000151F                 mov     byte ptr [ebp+var_4], 8
.text$mn:00001523                 mov     ecx, [ebp+var_10DC]
.text$mn:00001529                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000152E                 push    eax             ; wchar_t *
.text$mn:0000152F                 push    2               ; unsigned int
.text$mn:00001531                 mov     eax, [ebp+var_1024]
.text$mn:00001537                 push    eax             ; unsigned int
.text$mn:00001538                 mov     ecx, [ebp+this]
.text$mn:0000153B                 add     ecx, 20h ; ' '  ; this
.text$mn:0000153E                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:00001543                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001547                 lea     ecx, [ebp+var_80]
.text$mn:0000154A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000154F                 mov     ecx, [ebp+var_1028] ; this
.text$mn:00001555                 call    ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ ; NppParameters::getAccelerator(void)
.text$mn:0000155A                 mov     ecx, eax        ; this
.text$mn:0000155C                 call    ?updateShortcuts@Accelerator@@QAEXXZ ; Accelerator::updateShortcuts(void)
.text$mn:00001561
.text$mn:00001561 loc_1561:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+5B8j
.text$mn:00001561                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+5D9j
.text$mn:00001561                 mov     byte ptr [ebp+var_4], 6
.text$mn:00001565                 lea     ecx, [ebp+var_B24] ; this
.text$mn:0000156B                 call    ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$mn:00001570                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001577                 lea     ecx, [ebp+var_3AC] ; this
.text$mn:0000157D                 call    ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$mn:00001582                 jmp     loc_18F4        ; jumptable 00001111 default case
.text$mn:00001587 ; ---------------------------------------------------------------------------
.text$mn:00001587
.text$mn:00001587 $LN28:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+235j
.text$mn:00001587                                         ; DATA XREF: .text$mn:$LN89o
.text$mn:00001587                 mov     ecx, [ebp+var_1028] ; jumptable 00001111 case 3
.text$mn:0000158D                 call    ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ ; NppParameters::getPluginCommandList(void)
.text$mn:00001592                 mov     [ebp+var_1068], eax
.text$mn:00001598                 mov     ecx, [ebp+var_1024]
.text$mn:0000159E                 sub     ecx, 1
.text$mn:000015A1                 push    ecx
.text$mn:000015A2                 mov     ecx, [ebp+var_1068]
.text$mn:000015A8                 call    ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)
.text$mn:000015AD                 push    eax             ; Shortcut *
.text$mn:000015AE                 lea     ecx, [ebp+var_1EC]
.text$mn:000015B4                 call    ??0PluginCmdShortcut@@QAE@ABV0@@Z ; PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)
.text$mn:000015B9                 mov     [ebp+var_4], 9
.text$mn:000015C0                 mov     edx, [ebp+var_1024]
.text$mn:000015C6                 sub     edx, 1
.text$mn:000015C9                 push    edx
.text$mn:000015CA                 mov     ecx, [ebp+var_1068]
.text$mn:000015D0                 call    ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)
.text$mn:000015D5                 push    eax             ; Shortcut *
.text$mn:000015D6                 lea     ecx, [ebp+var_C74]
.text$mn:000015DC                 call    ??0PluginCmdShortcut@@QAE@ABV0@@Z ; PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)
.text$mn:000015E1                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:000015E5                 mov     eax, [ebp+this]
.text$mn:000015E8                 mov     ecx, [eax+0Ch]
.text$mn:000015EB                 push    ecx             ; HWND
.text$mn:000015EC                 mov     edx, [ebp+this]
.text$mn:000015EF                 mov     eax, [edx+4]
.text$mn:000015F2                 push    eax             ; HINSTANCE
.text$mn:000015F3                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:000015F9                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:000015FE                 lea     ecx, [ebp+var_1EC]
.text$mn:00001604                 push    ecx             ; Shortcut *
.text$mn:00001605                 lea     ecx, [ebp+var_C74]
.text$mn:0000160B                 call    ??4PluginCmdShortcut@@QAEAAV0@ABV0@@Z ; PluginCmdShortcut::operator=(PluginCmdShortcut const &)
.text$mn:00001610                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:00001616                 call    ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.text$mn:0000161B                 cmp     eax, 0FFFFFFFFh
.text$mn:0000161E                 jz      loc_1766
.text$mn:00001624                 lea     edx, [ebp+var_1EC]
.text$mn:0000162A                 push    edx             ; Shortcut *
.text$mn:0000162B                 lea     eax, [ebp+var_C74]
.text$mn:00001631                 push    eax             ; Shortcut *
.text$mn:00001632                 call    ??9@YA?B_NABVShortcut@@0@Z ; operator!=(Shortcut const &,Shortcut const &)
.text$mn:00001637                 add     esp, 8
.text$mn:0000163A                 movzx   ecx, al
.text$mn:0000163D                 test    ecx, ecx
.text$mn:0000163F                 jz      loc_1766
.text$mn:00001645                 mov     edx, [ebp+var_1024]
.text$mn:0000164B                 sub     edx, 1
.text$mn:0000164E                 push    edx             ; int
.text$mn:0000164F                 mov     ecx, [ebp+var_1028] ; this
.text$mn:00001655                 call    ?addPluginModifiedIndex@NppParameters@@QAEXH@Z ; NppParameters::addPluginModifiedIndex(int)
.text$mn:0000165A                 lea     eax, [ebp+var_1EC]
.text$mn:00001660                 push    eax             ; Shortcut *
.text$mn:00001661                 mov     ecx, [ebp+var_1024]
.text$mn:00001667                 sub     ecx, 1
.text$mn:0000166A                 push    ecx
.text$mn:0000166B                 mov     ecx, [ebp+var_1068]
.text$mn:00001671                 call    ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)
.text$mn:00001676                 mov     ecx, eax
.text$mn:00001678                 call    ??4PluginCmdShortcut@@QAEAAV0@ABV0@@Z ; PluginCmdShortcut::operator=(PluginCmdShortcut const &)
.text$mn:0000167D                 lea     edx, [ebp+var_9C]
.text$mn:00001683                 push    edx
.text$mn:00001684                 lea     ecx, [ebp+var_1EC]
.text$mn:0000168A                 call    ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.text$mn:0000168F                 mov     [ebp+var_10C0], eax
.text$mn:00001695                 mov     eax, [ebp+var_10C0]
.text$mn:0000169B                 mov     [ebp+var_10D4], eax
.text$mn:000016A1                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:000016A5                 mov     ecx, [ebp+var_10D4]
.text$mn:000016AB                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000016B0                 push    eax             ; wchar_t *
.text$mn:000016B1                 push    2               ; unsigned int
.text$mn:000016B3                 mov     ecx, [ebp+var_1024]
.text$mn:000016B9                 push    ecx             ; unsigned int
.text$mn:000016BA                 mov     ecx, [ebp+this]
.text$mn:000016BD                 add     ecx, 20h ; ' '  ; this
.text$mn:000016C0                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000016C5                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:000016C9                 lea     ecx, [ebp+var_9C]
.text$mn:000016CF                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000016D4                 mov     ecx, [ebp+var_1028] ; this
.text$mn:000016DA                 call    ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ ; NppParameters::getAccelerator(void)
.text$mn:000016DF                 mov     ecx, eax        ; this
.text$mn:000016E1                 call    ?updateShortcuts@Accelerator@@QAEXXZ ; Accelerator::updateShortcuts(void)
.text$mn:000016E6                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:000016EC                 call    ?getID@PluginCmdShortcut@@QBEKXZ ; PluginCmdShortcut::getID(void)
.text$mn:000016F1                 mov     [ebp+wParam], eax
.text$mn:000016F7                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:000016FD                 call    ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ ; Shortcut::getKeyCombo(void)
.text$mn:00001702                 mov     dl, [eax+1]
.text$mn:00001705                 mov     byte ptr [ebp+lParam+1], dl
.text$mn:0000170B                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:00001711                 call    ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ ; Shortcut::getKeyCombo(void)
.text$mn:00001716                 mov     al, [eax]
.text$mn:00001718                 mov     byte ptr [ebp+lParam], al
.text$mn:0000171E                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:00001724                 call    ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ ; Shortcut::getKeyCombo(void)
.text$mn:00001729                 mov     cl, [eax+2]
.text$mn:0000172C                 mov     byte ptr [ebp+lParam+2], cl
.text$mn:00001732                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:00001738                 call    ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ ; Shortcut::getKeyCombo(void)
.text$mn:0000173D                 mov     dl, [eax+3]
.text$mn:00001740                 mov     byte ptr [ebp+lParam+3], dl
.text$mn:00001746                 lea     eax, [ebp+lParam]
.text$mn:0000174C                 push    eax             ; lParam
.text$mn:0000174D                 mov     ecx, [ebp+wParam]
.text$mn:00001753                 push    ecx             ; wParam
.text$mn:00001754                 push    41Ah            ; Msg
.text$mn:00001759                 mov     edx, [ebp+this]
.text$mn:0000175C                 mov     eax, [edx+8]
.text$mn:0000175F                 push    eax             ; hWnd
.text$mn:00001760                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001766
.text$mn:00001766 loc_1766:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+742j
.text$mn:00001766                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+763j
.text$mn:00001766                 mov     byte ptr [ebp+var_4], 9
.text$mn:0000176A                 lea     ecx, [ebp+var_C74] ; this
.text$mn:00001770                 call    ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$mn:00001775                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000177C                 lea     ecx, [ebp+var_1EC] ; this
.text$mn:00001782                 call    ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$mn:00001787                 jmp     loc_18F4        ; jumptable 00001111 default case
.text$mn:0000178C ; ---------------------------------------------------------------------------
.text$mn:0000178C
.text$mn:0000178C $LN26:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+235j
.text$mn:0000178C                                         ; DATA XREF: .text$mn:$LN89o
.text$mn:0000178C                 mov     ecx, [ebp+var_1028] ; jumptable 00001111 case 4
.text$mn:00001792                 call    ?getScintillaKeyList@NppParameters@@QAEAAV?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@XZ ; NppParameters::getScintillaKeyList(void)
.text$mn:00001797                 mov     [ebp+var_1070], eax
.text$mn:0000179D                 mov     ecx, [ebp+var_1024]
.text$mn:000017A3                 sub     ecx, 1
.text$mn:000017A6                 push    ecx
.text$mn:000017A7                 mov     ecx, [ebp+var_1070]
.text$mn:000017AD                 call    ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)
.text$mn:000017B2                 push    eax             ; Shortcut *
.text$mn:000017B3                 lea     ecx, [ebp+var_758]
.text$mn:000017B9                 call    ??0ScintillaKeyMap@@QAE@ABV0@@Z ; ScintillaKeyMap::ScintillaKeyMap(ScintillaKeyMap const &)
.text$mn:000017BE                 mov     [ebp+var_4], 0Ch
.text$mn:000017C5                 mov     edx, [ebp+var_1024]
.text$mn:000017CB                 sub     edx, 1
.text$mn:000017CE                 push    edx
.text$mn:000017CF                 mov     ecx, [ebp+var_1070]
.text$mn:000017D5                 call    ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)
.text$mn:000017DA                 push    eax             ; Shortcut *
.text$mn:000017DB                 lea     ecx, [ebp+var_EE4]
.text$mn:000017E1                 call    ??0ScintillaKeyMap@@QAE@ABV0@@Z ; ScintillaKeyMap::ScintillaKeyMap(ScintillaKeyMap const &)
.text$mn:000017E6                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:000017EA                 mov     eax, [ebp+this]
.text$mn:000017ED                 mov     ecx, [eax+0Ch]
.text$mn:000017F0                 push    ecx             ; HWND
.text$mn:000017F1                 mov     edx, [ebp+this]
.text$mn:000017F4                 mov     eax, [edx+4]
.text$mn:000017F7                 push    eax             ; HINSTANCE
.text$mn:000017F8                 lea     ecx, [ebp+var_758] ; this
.text$mn:000017FE                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00001803                 lea     ecx, [ebp+var_758] ; this
.text$mn:00001809                 call    ?doDialog@ScintillaKeyMap@@UAEHXZ ; ScintillaKeyMap::doDialog(void)
.text$mn:0000180E                 cmp     eax, 0FFFFFFFFh
.text$mn:00001811                 jz      loc_18D3
.text$mn:00001817                 lea     ecx, [ebp+var_758]
.text$mn:0000181D                 push    ecx
.text$mn:0000181E                 lea     edx, [ebp+var_EE4]
.text$mn:00001824                 push    edx
.text$mn:00001825                 call    ??9@YA?B_NABVScintillaKeyMap@@0@Z ; operator!=(ScintillaKeyMap const &,ScintillaKeyMap const &)
.text$mn:0000182A                 add     esp, 8
.text$mn:0000182D                 movzx   eax, al
.text$mn:00001830                 test    eax, eax
.text$mn:00001832                 jz      loc_18D3
.text$mn:00001838                 mov     ecx, [ebp+var_1024]
.text$mn:0000183E                 sub     ecx, 1
.text$mn:00001841                 push    ecx             ; int
.text$mn:00001842                 mov     ecx, [ebp+var_1028] ; this
.text$mn:00001848                 call    ?addScintillaModifiedIndex@NppParameters@@QAEXH@Z ; NppParameters::addScintillaModifiedIndex(int)
.text$mn:0000184D                 lea     edx, [ebp+var_758]
.text$mn:00001853                 push    edx             ; Shortcut *
.text$mn:00001854                 mov     eax, [ebp+var_1024]
.text$mn:0000185A                 sub     eax, 1
.text$mn:0000185D                 push    eax
.text$mn:0000185E                 mov     ecx, [ebp+var_1070]
.text$mn:00001864                 call    ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)
.text$mn:00001869                 mov     ecx, eax
.text$mn:0000186B                 call    ??4ScintillaKeyMap@@QAEAAV0@ABV0@@Z ; ScintillaKeyMap::operator=(ScintillaKeyMap const &)
.text$mn:00001870                 lea     ecx, [ebp+var_64]
.text$mn:00001873                 push    ecx
.text$mn:00001874                 lea     ecx, [ebp+var_758]
.text$mn:0000187A                 call    ?toString@ScintillaKeyMap@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; ScintillaKeyMap::toString(void)
.text$mn:0000187F                 mov     [ebp+var_10A8], eax
.text$mn:00001885                 mov     edx, [ebp+var_10A8]
.text$mn:0000188B                 mov     [ebp+var_10B4], edx
.text$mn:00001891                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00001895                 mov     ecx, [ebp+var_10B4]
.text$mn:0000189B                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000018A0                 push    eax             ; wchar_t *
.text$mn:000018A1                 push    2               ; unsigned int
.text$mn:000018A3                 mov     eax, [ebp+var_1024]
.text$mn:000018A9                 push    eax             ; unsigned int
.text$mn:000018AA                 mov     ecx, [ebp+this]
.text$mn:000018AD                 add     ecx, 20h ; ' '  ; this
.text$mn:000018B0                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000018B5                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:000018B9                 lea     ecx, [ebp+var_64]
.text$mn:000018BC                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000018C1                 mov     ecx, [ebp+var_1028] ; this
.text$mn:000018C7                 call    ?getScintillaAccelerator@NppParameters@@QAEPAVScintillaAccelerator@@XZ ; NppParameters::getScintillaAccelerator(void)
.text$mn:000018CC                 mov     ecx, eax        ; this
.text$mn:000018CE                 call    ?updateKeys@ScintillaAccelerator@@QAEXXZ ; ScintillaAccelerator::updateKeys(void)
.text$mn:000018D3
.text$mn:000018D3 loc_18D3:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+935j
.text$mn:000018D3                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+956j
.text$mn:000018D3                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:000018D7                 lea     ecx, [ebp+var_EE4] ; this
.text$mn:000018DD                 call    ??1ScintillaKeyMap@@UAE@XZ ; ScintillaKeyMap::~ScintillaKeyMap(void)
.text$mn:000018E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018E9                 lea     ecx, [ebp+var_758] ; this
.text$mn:000018EF                 call    ??1ScintillaKeyMap@@UAE@XZ ; ScintillaKeyMap::~ScintillaKeyMap(void)
.text$mn:000018F4
.text$mn:000018F4 loc_18F4:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+229j
.text$mn:000018F4                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+3A4j ...
.text$mn:000018F4                 mov     eax, 1          ; jumptable 00001111 default case
.text$mn:000018F9                 jmp     loc_1FB2
.text$mn:000018FE ; ---------------------------------------------------------------------------
.text$mn:000018FE
.text$mn:000018FE loc_18FE:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+1BDj
.text$mn:000018FE                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001903                 mov     [ebp+var_105C], eax
.text$mn:00001909                 push    1               ; uType
.text$mn:0000190B                 push    offset $SG169648 ; "Are you sure?"
.text$mn:00001910                 push    offset $SG169649 ; "Are you sure you want to delete this sh"...
.text$mn:00001915                 mov     ecx, [ebp+this]
.text$mn:00001918                 mov     edx, [ecx+0Ch]
.text$mn:0000191B                 push    edx             ; hWnd
.text$mn:0000191C                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00001922                 cmp     eax, 1
.text$mn:00001925                 jnz     loc_1DEB
.text$mn:0000192B                 mov     ecx, [ebp+this]
.text$mn:0000192E                 add     ecx, 20h ; ' '  ; this
.text$mn:00001931                 call    ?getSelectedRow@BabyGridWrapper@@QAEHXZ ; BabyGridWrapper::getSelectedRow(void)
.text$mn:00001936                 mov     [ebp+var_10BC], eax
.text$mn:0000193C                 mov     eax, [ebp+var_10BC]
.text$mn:00001942                 sub     eax, 1
.text$mn:00001945                 mov     [ebp+var_1040], eax
.text$mn:0000194B                 mov     [ebp+var_1084], 0
.text$mn:00001955                 mov     [ebp+var_104C], 0
.text$mn:0000195F                 mov     [ebp+var_103C], 0
.text$mn:00001969                 mov     [ebp+hMenu], 0
.text$mn:00001973                 mov     [ebp+uPosition], 0BB91h
.text$mn:0000197D                 mov     ecx, [ebp+this]
.text$mn:00001980                 mov     edx, [ecx+48h]
.text$mn:00001983                 mov     [ebp+var_107C], edx
.text$mn:00001989                 cmp     [ebp+var_107C], 4 ; switch 5 cases
.text$mn:00001990                 ja      loc_1D63        ; jumptable 0000199C default case
.text$mn:00001996                 mov     eax, [ebp+var_107C]
.text$mn:0000199C                 jmp     ds:$LN90[eax*4] ; switch jump
.text$mn:000019A3 ; ---------------------------------------------------------------------------
.text$mn:000019A3
.text$mn:000019A3 $LN20:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+AC0j
.text$mn:000019A3                                         ; DATA XREF: .text$mn:$LN90o
.text$mn:000019A3                 xor     eax, eax        ; jumptable 0000199C cases 0,3,4
.text$mn:000019A5                 jmp     loc_1FB2
.text$mn:000019AA ; ---------------------------------------------------------------------------
.text$mn:000019AA
.text$mn:000019AA $LN19_1:                                ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+AC0j
.text$mn:000019AA                                         ; DATA XREF: .text$mn:$LN90o
.text$mn:000019AA                 mov     ecx, [ebp+var_105C] ; jumptable 0000199C case 1
.text$mn:000019B0                 call    ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ ; NppParameters::getMacroList(void)
.text$mn:000019B5                 mov     [ebp+var_1038], eax
.text$mn:000019BB                 lea     ecx, [ebp+var_1134]
.text$mn:000019C1                 push    ecx
.text$mn:000019C2                 mov     ecx, [ebp+var_1038]
.text$mn:000019C8                 call    ?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::begin(void)
.text$mn:000019CD                 mov     [ebp+var_4], 0Fh
.text$mn:000019D4                 mov     edx, [ebp+var_1040]
.text$mn:000019DA                 push    edx
.text$mn:000019DB                 mov     ecx, [ebp+var_1038]
.text$mn:000019E1                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:000019E6                 mov     ecx, eax        ; this
.text$mn:000019E8                 call    ?getID@CommandShortcut@@QBEKXZ ; CommandShortcut::getID(void)
.text$mn:000019ED                 mov     [ebp+var_1084], eax
.text$mn:000019F3                 mov     eax, [ebp+var_1040]
.text$mn:000019F9                 push    eax
.text$mn:000019FA                 lea     ecx, [ebp+var_1140]
.text$mn:00001A00                 push    ecx
.text$mn:00001A01                 lea     ecx, [ebp+var_1134]
.text$mn:00001A07                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+(int)
.text$mn:00001A0C                 mov     [ebp+var_10C4], eax
.text$mn:00001A12                 mov     edx, [ebp+var_10C4]
.text$mn:00001A18                 mov     [ebp+var_10D0], edx
.text$mn:00001A1E                 mov     byte ptr [ebp+var_4], 10h
.text$mn:00001A22                 sub     esp, 0Ch
.text$mn:00001A25                 mov     ecx, esp
.text$mn:00001A27                 mov     [ebp+var_1108], esp
.text$mn:00001A2D                 mov     eax, [ebp+var_10D0]
.text$mn:00001A33                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00001A34                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)
.text$mn:00001A39                 mov     [ebp+var_1088], eax
.text$mn:00001A3F                 mov     ecx, [ebp+var_1088]
.text$mn:00001A45                 mov     [ebp+var_1100], ecx
.text$mn:00001A4B                 mov     byte ptr [ebp+var_4], 11h
.text$mn:00001A4F                 lea     edx, [ebp+var_1164]
.text$mn:00001A55                 push    edx
.text$mn:00001A56                 mov     byte ptr [ebp+var_4], 10h
.text$mn:00001A5A                 mov     ecx, [ebp+var_1038]
.text$mn:00001A60                 call    ?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)
.text$mn:00001A65                 mov     [ebp+var_110C], eax
.text$mn:00001A6B                 lea     ecx, [ebp+var_1164]
.text$mn:00001A71                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$mn:00001A76                 mov     byte ptr [ebp+var_4], 0Fh
.text$mn:00001A7A                 lea     ecx, [ebp+var_1140]
.text$mn:00001A80                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$mn:00001A85                 mov     ecx, [ebp+this] ; this
.text$mn:00001A88                 call    ?fillOutBabyGrid@ShortcutMapper@@AAEXXZ ; ShortcutMapper::fillOutBabyGrid(void)
.text$mn:00001A8D                 mov     [ebp+var_104C], 6
.text$mn:00001A97                 mov     ecx, [ebp+var_1038]
.text$mn:00001A9D                 call    ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::size(void)
.text$mn:00001AA2                 mov     [ebp+var_103C], eax
.text$mn:00001AA8                 push    7               ; nPos
.text$mn:00001AAA                 push    0               ; lParam
.text$mn:00001AAC                 push    0               ; wParam
.text$mn:00001AAE                 push    40Eh            ; Msg
.text$mn:00001AB3                 mov     eax, [ebp+this]
.text$mn:00001AB6                 mov     ecx, [eax+8]
.text$mn:00001AB9                 push    ecx             ; hWnd
.text$mn:00001ABA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001AC0                 push    eax             ; hMenu
.text$mn:00001AC1                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:00001AC7                 mov     [ebp+hMenu], eax
.text$mn:00001ACD                 mov     [ebp+uPosition], 0BB90h
.text$mn:00001AD7                 mov     edx, [ebp+var_1040]
.text$mn:00001ADD                 mov     [ebp+var_1048], edx
.text$mn:00001AE3                 jmp     short loc_1AF4
.text$mn:00001AE5 ; ---------------------------------------------------------------------------
.text$mn:00001AE5
.text$mn:00001AE5 loc_1AE5:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+C91j
.text$mn:00001AE5                 mov     eax, [ebp+var_1048]
.text$mn:00001AEB                 add     eax, 1
.text$mn:00001AEE                 mov     [ebp+var_1048], eax
.text$mn:00001AF4
.text$mn:00001AF4 loc_1AF4:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+C07j
.text$mn:00001AF4                 mov     ecx, [ebp+var_1048]
.text$mn:00001AFA                 cmp     ecx, [ebp+var_103C]
.text$mn:00001B00                 jnb     short loc_1B72
.text$mn:00001B02                 mov     edx, [ebp+var_1048]
.text$mn:00001B08                 push    edx
.text$mn:00001B09                 mov     ecx, [ebp+var_1038]
.text$mn:00001B0F                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:00001B14                 push    eax             ; Shortcut *
.text$mn:00001B15                 lea     ecx, [ebp+var_894]
.text$mn:00001B1B                 call    ??0MacroShortcut@@QAE@ABV0@@Z ; MacroShortcut::MacroShortcut(MacroShortcut const &)
.text$mn:00001B20                 mov     byte ptr [ebp+var_4], 12h
.text$mn:00001B24                 lea     ecx, [ebp+var_894] ; this
.text$mn:00001B2A                 call    ?getID@CommandShortcut@@QBEKXZ ; CommandShortcut::getID(void)
.text$mn:00001B2F                 sub     eax, 1
.text$mn:00001B32                 push    eax             ; unsigned __int32
.text$mn:00001B33                 lea     ecx, [ebp+var_894] ; this
.text$mn:00001B39                 call    ?setID@CommandShortcut@@QAEXK@Z ; CommandShortcut::setID(ulong)
.text$mn:00001B3E                 lea     eax, [ebp+var_894]
.text$mn:00001B44                 push    eax             ; Shortcut *
.text$mn:00001B45                 mov     ecx, [ebp+var_1048]
.text$mn:00001B4B                 push    ecx
.text$mn:00001B4C                 mov     ecx, [ebp+var_1038]
.text$mn:00001B52                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:00001B57                 mov     ecx, eax
.text$mn:00001B59                 call    ??4MacroShortcut@@QAEAAV0@ABV0@@Z ; MacroShortcut::operator=(MacroShortcut const &)
.text$mn:00001B5E                 mov     byte ptr [ebp+var_4], 0Fh
.text$mn:00001B62                 lea     ecx, [ebp+var_894] ; this
.text$mn:00001B68                 call    ??1MacroShortcut@@UAE@XZ ; MacroShortcut::~MacroShortcut(void)
.text$mn:00001B6D                 jmp     loc_1AE5
.text$mn:00001B72 ; ---------------------------------------------------------------------------
.text$mn:00001B72
.text$mn:00001B72 loc_1B72:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+C24j
.text$mn:00001B72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B79                 lea     ecx, [ebp+var_1134]
.text$mn:00001B7F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$mn:00001B84                 jmp     loc_1D63        ; jumptable 0000199C default case
.text$mn:00001B89 ; ---------------------------------------------------------------------------
.text$mn:00001B89
.text$mn:00001B89 $LN15:                                  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+AC0j
.text$mn:00001B89                                         ; DATA XREF: .text$mn:$LN90o
.text$mn:00001B89                 mov     ecx, [ebp+var_105C] ; jumptable 0000199C case 2
.text$mn:00001B8F                 call    ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ ; NppParameters::getUserCommandList(void)
.text$mn:00001B94                 mov     [ebp+var_1034], eax
.text$mn:00001B9A                 lea     edx, [ebp+var_1128]
.text$mn:00001BA0                 push    edx
.text$mn:00001BA1                 mov     ecx, [ebp+var_1034]
.text$mn:00001BA7                 call    ?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ ; std::vector<UserCommand,std::allocator<UserCommand>>::begin(void)
.text$mn:00001BAC                 mov     [ebp+var_4], 13h
.text$mn:00001BB3                 mov     eax, [ebp+var_1040]
.text$mn:00001BB9                 push    eax
.text$mn:00001BBA                 mov     ecx, [ebp+var_1034]
.text$mn:00001BC0                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:00001BC5                 mov     ecx, eax        ; this
.text$mn:00001BC7                 call    ?getID@CommandShortcut@@QBEKXZ ; CommandShortcut::getID(void)
.text$mn:00001BCC                 mov     [ebp+var_1084], eax
.text$mn:00001BD2                 mov     ecx, [ebp+var_1040]
.text$mn:00001BD8                 push    ecx
.text$mn:00001BD9                 lea     edx, [ebp+var_114C]
.text$mn:00001BDF                 push    edx
.text$mn:00001BE0                 lea     ecx, [ebp+var_1128]
.text$mn:00001BE6                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+(int)
.text$mn:00001BEB                 mov     [ebp+var_10E0], eax
.text$mn:00001BF1                 mov     eax, [ebp+var_10E0]
.text$mn:00001BF7                 mov     [ebp+var_10CC], eax
.text$mn:00001BFD                 mov     byte ptr [ebp+var_4], 14h
.text$mn:00001C01                 sub     esp, 0Ch
.text$mn:00001C04                 mov     ecx, esp
.text$mn:00001C06                 mov     [ebp+var_111C], esp
.text$mn:00001C0C                 mov     edx, [ebp+var_10CC]
.text$mn:00001C12                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00001C13                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)
.text$mn:00001C18                 mov     [ebp+var_10B0], eax
.text$mn:00001C1E                 mov     eax, [ebp+var_10B0]
.text$mn:00001C24                 mov     [ebp+var_1118], eax
.text$mn:00001C2A                 mov     byte ptr [ebp+var_4], 15h
.text$mn:00001C2E                 lea     ecx, [ebp+var_1158]
.text$mn:00001C34                 push    ecx
.text$mn:00001C35                 mov     byte ptr [ebp+var_4], 14h
.text$mn:00001C39                 mov     ecx, [ebp+var_1034]
.text$mn:00001C3F                 call    ?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)
.text$mn:00001C44                 mov     [ebp+var_1104], eax
.text$mn:00001C4A                 lea     ecx, [ebp+var_1158]
.text$mn:00001C50                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$mn:00001C55                 mov     byte ptr [ebp+var_4], 13h
.text$mn:00001C59                 lea     ecx, [ebp+var_114C]
.text$mn:00001C5F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$mn:00001C64                 mov     ecx, [ebp+this] ; this
.text$mn:00001C67                 call    ?fillOutBabyGrid@ShortcutMapper@@AAEXXZ ; ShortcutMapper::fillOutBabyGrid(void)
.text$mn:00001C6C                 mov     [ebp+var_104C], 2
.text$mn:00001C76                 mov     ecx, [ebp+var_1034]
.text$mn:00001C7C                 call    ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::size(void)
.text$mn:00001C81                 mov     [ebp+var_103C], eax
.text$mn:00001C87                 push    8               ; nPos
.text$mn:00001C89                 push    0               ; lParam
.text$mn:00001C8B                 push    0               ; wParam
.text$mn:00001C8D                 push    40Eh            ; Msg
.text$mn:00001C92                 mov     edx, [ebp+this]
.text$mn:00001C95                 mov     eax, [edx+8]
.text$mn:00001C98                 push    eax             ; hWnd
.text$mn:00001C99                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001C9F                 push    eax             ; hMenu
.text$mn:00001CA0                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:00001CA6                 mov     [ebp+hMenu], eax
.text$mn:00001CAC                 mov     [ebp+uPosition], 0BB91h
.text$mn:00001CB6                 mov     ecx, [ebp+var_1040]
.text$mn:00001CBC                 mov     [ebp+var_1044], ecx
.text$mn:00001CC2                 jmp     short loc_1CD3
.text$mn:00001CC4 ; ---------------------------------------------------------------------------
.text$mn:00001CC4
.text$mn:00001CC4 loc_1CC4:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+E70j
.text$mn:00001CC4                 mov     edx, [ebp+var_1044]
.text$mn:00001CCA                 add     edx, 1
.text$mn:00001CCD                 mov     [ebp+var_1044], edx
.text$mn:00001CD3
.text$mn:00001CD3 loc_1CD3:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+DE6j
.text$mn:00001CD3                 mov     eax, [ebp+var_1044]
.text$mn:00001CD9                 cmp     eax, [ebp+var_103C]
.text$mn:00001CDF                 jnb     short loc_1D51
.text$mn:00001CE1                 mov     ecx, [ebp+var_1044]
.text$mn:00001CE7                 push    ecx
.text$mn:00001CE8                 mov     ecx, [ebp+var_1034]
.text$mn:00001CEE                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:00001CF3                 push    eax             ; Shortcut *
.text$mn:00001CF4                 lea     ecx, [ebp+var_9DC]
.text$mn:00001CFA                 call    ??0UserCommand@@QAE@ABV0@@Z ; UserCommand::UserCommand(UserCommand const &)
.text$mn:00001CFF                 mov     byte ptr [ebp+var_4], 16h
.text$mn:00001D03                 lea     ecx, [ebp+var_9DC] ; this
.text$mn:00001D09                 call    ?getID@CommandShortcut@@QBEKXZ ; CommandShortcut::getID(void)
.text$mn:00001D0E                 sub     eax, 1
.text$mn:00001D11                 push    eax             ; unsigned __int32
.text$mn:00001D12                 lea     ecx, [ebp+var_9DC] ; this
.text$mn:00001D18                 call    ?setID@CommandShortcut@@QAEXK@Z ; CommandShortcut::setID(ulong)
.text$mn:00001D1D                 lea     edx, [ebp+var_9DC]
.text$mn:00001D23                 push    edx             ; Shortcut *
.text$mn:00001D24                 mov     eax, [ebp+var_1044]
.text$mn:00001D2A                 push    eax
.text$mn:00001D2B                 mov     ecx, [ebp+var_1034]
.text$mn:00001D31                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:00001D36                 mov     ecx, eax
.text$mn:00001D38                 call    ??4UserCommand@@QAEAAV0@ABV0@@Z ; UserCommand::operator=(UserCommand const &)
.text$mn:00001D3D                 mov     byte ptr [ebp+var_4], 13h
.text$mn:00001D41                 lea     ecx, [ebp+var_9DC] ; this
.text$mn:00001D47                 call    ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$mn:00001D4C                 jmp     loc_1CC4
.text$mn:00001D51 ; ---------------------------------------------------------------------------
.text$mn:00001D51
.text$mn:00001D51 loc_1D51:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+E03j
.text$mn:00001D51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D58                 lea     ecx, [ebp+var_1128]
.text$mn:00001D5E                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$mn:00001D63
.text$mn:00001D63 loc_1D63:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+AB4j
.text$mn:00001D63                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+CA8j
.text$mn:00001D63                 mov     ecx, [ebp+var_105C] ; jumptable 0000199C default case
.text$mn:00001D69                 call    ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ ; NppParameters::getAccelerator(void)
.text$mn:00001D6E                 mov     ecx, eax        ; this
.text$mn:00001D70                 call    ?updateShortcuts@Accelerator@@QAEXXZ ; Accelerator::updateShortcuts(void)
.text$mn:00001D75                 push    400h            ; uFlags
.text$mn:00001D7A                 mov     ecx, [ebp+var_104C]
.text$mn:00001D80                 add     ecx, [ebp+var_103C]
.text$mn:00001D86                 push    ecx             ; uPosition
.text$mn:00001D87                 mov     edx, [ebp+hMenu]
.text$mn:00001D8D                 push    edx             ; hMenu
.text$mn:00001D8E                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00001D94                 cmp     [ebp+var_103C], 0
.text$mn:00001D9B                 jnz     short loc_1DEB
.text$mn:00001D9D                 push    0               ; uFlags
.text$mn:00001D9F                 mov     eax, [ebp+uPosition]
.text$mn:00001DA5                 push    eax             ; uPosition
.text$mn:00001DA6                 mov     ecx, [ebp+hMenu]
.text$mn:00001DAC                 push    ecx             ; hMenu
.text$mn:00001DAD                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00001DB3                 push    400h            ; uFlags
.text$mn:00001DB8                 mov     edx, [ebp+var_104C]
.text$mn:00001DBE                 sub     edx, 1
.text$mn:00001DC1                 push    edx             ; uPosition
.text$mn:00001DC2                 mov     eax, [ebp+hMenu]
.text$mn:00001DC8                 push    eax             ; hMenu
.text$mn:00001DC9                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00001DCF                 push    400h            ; uFlags
.text$mn:00001DD4                 mov     ecx, [ebp+var_104C]
.text$mn:00001DDA                 sub     ecx, 1
.text$mn:00001DDD                 push    ecx             ; uPosition
.text$mn:00001DDE                 mov     edx, [ebp+hMenu]
.text$mn:00001DE4                 push    edx             ; hMenu
.text$mn:00001DE5                 call    dword ptr ds:__imp__RemoveMenu@12 ; RemoveMenu(x,x,x)
.text$mn:00001DEB
.text$mn:00001DEB loc_1DEB:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+A49j
.text$mn:00001DEB                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+EBFj
.text$mn:00001DEB                 mov     eax, 1
.text$mn:00001DF0                 jmp     loc_1FB2
.text$mn:00001DF5 ; ---------------------------------------------------------------------------
.text$mn:00001DF5
.text$mn:00001DF5 loc_1DF5:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+18Aj
.text$mn:00001DF5                 mov     eax, [ebp+arg_8]
.text$mn:00001DF8                 shr     eax, 10h
.text$mn:00001DFB                 and     eax, 0FFFFh
.text$mn:00001E00                 movzx   ecx, ax
.text$mn:00001E03                 cmp     ecx, 1Ah
.text$mn:00001E06                 jnz     short loc_1E36
.text$mn:00001E08                 mov     edx, [ebp+arg_C]
.text$mn:00001E0B                 and     edx, 0FFFFh
.text$mn:00001E11                 movzx   eax, dx
.text$mn:00001E14                 push    eax             ; lParam
.text$mn:00001E15                 push    0A2Ah           ; wParam
.text$mn:00001E1A                 push    111h            ; Msg
.text$mn:00001E1F                 mov     ecx, [ebp+this]
.text$mn:00001E22                 mov     edx, [ecx+0Ch]
.text$mn:00001E25                 push    edx             ; hWnd
.text$mn:00001E26                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001E2C                 jmp     loc_1FB2
.text$mn:00001E31 ; ---------------------------------------------------------------------------
.text$mn:00001E31                 jmp     loc_1FAC
.text$mn:00001E36 ; ---------------------------------------------------------------------------
.text$mn:00001E36
.text$mn:00001E36 loc_1E36:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+F2Aj
.text$mn:00001E36                 mov     eax, [ebp+arg_8]
.text$mn:00001E39                 shr     eax, 10h
.text$mn:00001E3C                 and     eax, 0FFFFh
.text$mn:00001E41                 movzx   ecx, ax
.text$mn:00001E44                 cmp     ecx, 1Bh
.text$mn:00001E47                 jnz     loc_1FAC
.text$mn:00001E4D                 lea     edx, [ebp+Point]
.text$mn:00001E53                 push    edx             ; lpPoint
.text$mn:00001E54                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00001E5A                 mov     ecx, [ebp+this]
.text$mn:00001E5D                 add     ecx, 30h ; '0'  ; this
.text$mn:00001E60                 call    ?isCreated@ContextMenu@@QBE_NXZ ; ContextMenu::isCreated(void)
.text$mn:00001E65                 movzx   eax, al
.text$mn:00001E68                 test    eax, eax
.text$mn:00001E6A                 jnz     loc_1F4B
.text$mn:00001E70                 lea     ecx, [ebp+var_10FC]
.text$mn:00001E76                 call    ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:00001E7B                 mov     [ebp+var_4], 17h
.text$mn:00001E82                 push    0               ; wchar_t *
.text$mn:00001E84                 push    offset $SG169999 ; "Modify"
.text$mn:00001E89                 push    0A2Ah           ; unsigned __int32
.text$mn:00001E8E                 lea     ecx, [ebp+var_228] ; this
.text$mn:00001E94                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00001E99                 mov     [ebp+var_10A4], eax
.text$mn:00001E9F                 mov     ecx, [ebp+var_10A4]
.text$mn:00001EA5                 mov     [ebp+var_1090], ecx
.text$mn:00001EAB                 mov     byte ptr [ebp+var_4], 18h
.text$mn:00001EAF                 mov     edx, [ebp+var_1090]
.text$mn:00001EB5                 push    edx
.text$mn:00001EB6                 lea     ecx, [ebp+var_10FC]
.text$mn:00001EBC                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00001EC1                 mov     byte ptr [ebp+var_4], 17h
.text$mn:00001EC5                 lea     ecx, [ebp+var_228] ; this
.text$mn:00001ECB                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00001ED0                 push    0               ; wchar_t *
.text$mn:00001ED2                 push    offset $SG170001 ; "Delete"
.text$mn:00001ED7                 push    0A2Bh           ; unsigned __int32
.text$mn:00001EDC                 lea     ecx, [ebp+var_264] ; this
.text$mn:00001EE2                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00001EE7                 mov     [ebp+var_10AC], eax
.text$mn:00001EED                 mov     eax, [ebp+var_10AC]
.text$mn:00001EF3                 mov     [ebp+var_1098], eax
.text$mn:00001EF9                 mov     byte ptr [ebp+var_4], 19h
.text$mn:00001EFD                 mov     ecx, [ebp+var_1098]
.text$mn:00001F03                 push    ecx
.text$mn:00001F04                 lea     ecx, [ebp+var_10FC]
.text$mn:00001F0A                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00001F0F                 mov     byte ptr [ebp+var_4], 17h
.text$mn:00001F13                 lea     ecx, [ebp+var_264] ; this
.text$mn:00001F19                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00001F1E                 push    0
.text$mn:00001F20                 lea     edx, [ebp+var_10FC]
.text$mn:00001F26                 push    edx
.text$mn:00001F27                 mov     eax, [ebp+this]
.text$mn:00001F2A                 mov     ecx, [eax+0Ch]
.text$mn:00001F2D                 push    ecx
.text$mn:00001F2E                 mov     ecx, [ebp+this]
.text$mn:00001F31                 add     ecx, 30h ; '0'
.text$mn:00001F34                 call    ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)
.text$mn:00001F39                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F40                 lea     ecx, [ebp+var_10FC]
.text$mn:00001F46                 call    ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:00001F4B
.text$mn:00001F4B loc_1F4B:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+F8Ej
.text$mn:00001F4B                 mov     edx, [ebp+this]
.text$mn:00001F4E                 mov     eax, [edx+48h]
.text$mn:00001F51                 mov     [ebp+var_1080], eax
.text$mn:00001F57                 cmp     [ebp+var_1080], 4 ; switch 5 cases
.text$mn:00001F5E                 ja      short loc_1F93  ; jumptable 00001F66 default case
.text$mn:00001F60                 mov     ecx, [ebp+var_1080]
.text$mn:00001F66                 jmp     ds:$LN91[ecx*4] ; switch jump
.text$mn:00001F6D ; ---------------------------------------------------------------------------
.text$mn:00001F6D
.text$mn:00001F6D $LN3:                                   ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+108Aj
.text$mn:00001F6D                                         ; DATA XREF: .text$mn:$LN91o
.text$mn:00001F6D                 push    1               ; jumptable 00001F66 cases 1,2
.text$mn:00001F6F                 push    0A2Bh           ; uIDEnableItem
.text$mn:00001F74                 mov     ecx, [ebp+this]
.text$mn:00001F77                 add     ecx, 30h ; '0'  ; this
.text$mn:00001F7A                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:00001F7F                 jmp     short loc_1F93  ; jumptable 00001F66 default case
.text$mn:00001F81 ; ---------------------------------------------------------------------------
.text$mn:00001F81
.text$mn:00001F81 $LN2:                                   ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+108Aj
.text$mn:00001F81                                         ; DATA XREF: .text$mn:$LN91o
.text$mn:00001F81                 push    0               ; jumptable 00001F66 cases 0,3,4
.text$mn:00001F83                 push    0A2Bh           ; uIDEnableItem
.text$mn:00001F88                 mov     ecx, [ebp+this]
.text$mn:00001F8B                 add     ecx, 30h ; '0'  ; this
.text$mn:00001F8E                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:00001F93
.text$mn:00001F93 loc_1F93:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+1082j
.text$mn:00001F93                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+10A3j
.text$mn:00001F93                 lea     edx, [ebp+Point] ; jumptable 00001F66 default case
.text$mn:00001F99                 push    edx             ; struct tagPOINT *
.text$mn:00001F9A                 mov     ecx, [ebp+this]
.text$mn:00001F9D                 add     ecx, 30h ; '0'  ; this
.text$mn:00001FA0                 call    ?display@ContextMenu@@QBEXABUtagPOINT@@@Z ; ContextMenu::display(tagPOINT const &)
.text$mn:00001FA5                 mov     eax, 1
.text$mn:00001FAA                 jmp     short loc_1FB2
.text$mn:00001FAC ; ---------------------------------------------------------------------------
.text$mn:00001FAC
.text$mn:00001FAC loc_1FAC:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+5Dj
.text$mn:00001FAC                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+1A2j ...
.text$mn:00001FAC                 xor     eax, eax
.text$mn:00001FAE                 jmp     short loc_1FB2
.text$mn:00001FB0 ; ---------------------------------------------------------------------------
.text$mn:00001FB0
.text$mn:00001FB0 loc_1FB0:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long):loc_103Aj
.text$mn:00001FB0                 xor     eax, eax
.text$mn:00001FB2
.text$mn:00001FB2 loc_1FB2:                               ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+9Aj
.text$mn:00001FB2                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+1DCj ...
.text$mn:00001FB2                 mov     ecx, [ebp+var_C]
.text$mn:00001FB5                 mov     large fs:0, ecx
.text$mn:00001FBC                 pop     ecx
.text$mn:00001FBD                 mov     ecx, [ebp+var_10]
.text$mn:00001FC0                 xor     ecx, ebp
.text$mn:00001FC2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001FC7                 mov     esp, ebp
.text$mn:00001FC9                 pop     ebp
.text$mn:00001FCA                 retn    10h
.text$mn:00001FCA ?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z endp
.text$mn:00001FCA
.text$mn:00001FCA ; ---------------------------------------------------------------------------
.text$mn:00001FCD                 align 10h
.text$mn:00001FD0 $LN88           dd offset $LN47         ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+115r
.text$mn:00001FD0                 dd offset $LN46         ; jump table for switch statement
.text$mn:00001FD0                 dd offset $LN45
.text$mn:00001FD0                 dd offset $LN44
.text$mn:00001FD0                 dd offset $LN43
.text$mn:00001FE4 $LN89           dd offset $LN34         ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+235r
.text$mn:00001FE4                 dd offset $LN32         ; jump table for switch statement
.text$mn:00001FE4                 dd offset $LN30
.text$mn:00001FE4                 dd offset $LN28
.text$mn:00001FE4                 dd offset $LN26
.text$mn:00001FF8 $LN90           dd offset $LN20         ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+AC0r
.text$mn:00001FF8                 dd offset $LN19_1       ; jump table for switch statement
.text$mn:00001FF8                 dd offset $LN15
.text$mn:00001FF8                 dd offset $LN20
.text$mn:00001FF8                 dd offset $LN20
.text$mn:0000200C $LN91           dd offset $LN2          ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+108Ar
.text$mn:0000200C                 dd offset $LN3          ; jump table for switch statement
.text$mn:0000200C                 dd offset $LN3
.text$mn:0000200C                 dd offset $LN2
.text$mn:0000200C                 dd offset $LN2
.text$mn:00002020                 db 0Ch dup(0CCh)
.text$mn:0000202C
.text$mn:0000202C ; =============== S U B R O U T I N E =======================================
.text$mn:0000202C
.text$mn:0000202C ; Attributes: bp-based frame
.text$mn:0000202C
.text$mn:0000202C ; void __thiscall ShortcutMapper::initTabs(ShortcutMapper *__hidden this)
.text$mn:0000202C                 public ?initTabs@ShortcutMapper@@AAEXXZ
.text$mn:0000202C ?initTabs@ShortcutMapper@@AAEXXZ proc near
.text$mn:0000202C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+6Dp
.text$mn:0000202C
.text$mn:0000202C lParam          = dword ptr -28h
.text$mn:0000202C var_1C          = dword ptr -1Ch
.text$mn:0000202C var_C           = dword ptr -0Ch
.text$mn:0000202C hWnd            = dword ptr -8
.text$mn:0000202C var_4           = dword ptr -4
.text$mn:0000202C
.text$mn:0000202C                 push    ebp
.text$mn:0000202D                 mov     ebp, esp
.text$mn:0000202F                 sub     esp, 28h
.text$mn:00002032                 mov     [ebp+var_4], ecx
.text$mn:00002035                 push    0A2Ch           ; nIDDlgItem
.text$mn:0000203A                 mov     eax, [ebp+var_4]
.text$mn:0000203D                 mov     ecx, [eax+0Ch]
.text$mn:00002040                 push    ecx             ; hDlg
.text$mn:00002041                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002047                 mov     [ebp+var_C], eax
.text$mn:0000204A                 mov     edx, [ebp+var_4]
.text$mn:0000204D                 mov     eax, [ebp+var_C]
.text$mn:00002050                 mov     [edx+4Ch], eax
.text$mn:00002053                 mov     ecx, [ebp+var_C]
.text$mn:00002056                 mov     [ebp+hWnd], ecx
.text$mn:00002059                 mov     [ebp+lParam], 1
.text$mn:00002060                 mov     edx, 80h ; 'Ç'
.text$mn:00002065                 imul    eax, edx, 0
.text$mn:00002068                 mov     ecx, [ebp+var_4]
.text$mn:0000206B                 lea     edx, [ecx+eax+50h]
.text$mn:0000206F                 mov     [ebp+var_1C], edx
.text$mn:00002072                 lea     eax, [ebp+lParam]
.text$mn:00002075                 push    eax             ; lParam
.text$mn:00002076                 push    0               ; wParam
.text$mn:00002078                 push    133Eh           ; Msg
.text$mn:0000207D                 mov     ecx, [ebp+hWnd]
.text$mn:00002080                 push    ecx             ; hWnd
.text$mn:00002081                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00002087                 mov     edx, 80h ; 'Ç'
.text$mn:0000208C                 shl     edx, 0
.text$mn:0000208F                 mov     eax, [ebp+var_4]
.text$mn:00002092                 lea     ecx, [eax+edx+50h]
.text$mn:00002096                 mov     [ebp+var_1C], ecx
.text$mn:00002099                 lea     edx, [ebp+lParam]
.text$mn:0000209C                 push    edx             ; lParam
.text$mn:0000209D                 push    1               ; wParam
.text$mn:0000209F                 push    133Eh           ; Msg
.text$mn:000020A4                 mov     eax, [ebp+hWnd]
.text$mn:000020A7                 push    eax             ; hWnd
.text$mn:000020A8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000020AE                 mov     ecx, 80h ; 'Ç'
.text$mn:000020B3                 shl     ecx, 1
.text$mn:000020B5                 mov     edx, [ebp+var_4]
.text$mn:000020B8                 lea     eax, [edx+ecx+50h]
.text$mn:000020BC                 mov     [ebp+var_1C], eax
.text$mn:000020BF                 lea     ecx, [ebp+lParam]
.text$mn:000020C2                 push    ecx             ; lParam
.text$mn:000020C3                 push    2               ; wParam
.text$mn:000020C5                 push    133Eh           ; Msg
.text$mn:000020CA                 mov     edx, [ebp+hWnd]
.text$mn:000020CD                 push    edx             ; hWnd
.text$mn:000020CE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000020D4                 mov     eax, 80h ; 'Ç'
.text$mn:000020D9                 imul    ecx, eax, 3
.text$mn:000020DC                 mov     edx, [ebp+var_4]
.text$mn:000020DF                 lea     eax, [edx+ecx+50h]
.text$mn:000020E3                 mov     [ebp+var_1C], eax
.text$mn:000020E6                 lea     ecx, [ebp+lParam]
.text$mn:000020E9                 push    ecx             ; lParam
.text$mn:000020EA                 push    3               ; wParam
.text$mn:000020EC                 push    133Eh           ; Msg
.text$mn:000020F1                 mov     edx, [ebp+hWnd]
.text$mn:000020F4                 push    edx             ; hWnd
.text$mn:000020F5                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000020FB                 mov     eax, 80h ; 'Ç'
.text$mn:00002100                 shl     eax, 2
.text$mn:00002103                 mov     ecx, [ebp+var_4]
.text$mn:00002106                 lea     edx, [ecx+eax+50h]
.text$mn:0000210A                 mov     [ebp+var_1C], edx
.text$mn:0000210D                 lea     eax, [ebp+lParam]
.text$mn:00002110                 push    eax             ; lParam
.text$mn:00002111                 push    4               ; wParam
.text$mn:00002113                 push    133Eh           ; Msg
.text$mn:00002118                 mov     ecx, [ebp+hWnd]
.text$mn:0000211B                 push    ecx             ; hWnd
.text$mn:0000211C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00002122                 push    0               ; lParam
.text$mn:00002124                 mov     edx, [ebp+var_4]
.text$mn:00002127                 mov     eax, [edx+48h]
.text$mn:0000212A                 push    eax             ; wParam
.text$mn:0000212B                 push    130Ch           ; Msg
.text$mn:00002130                 mov     ecx, [ebp+var_4]
.text$mn:00002133                 mov     edx, [ecx+4Ch]
.text$mn:00002136                 push    edx             ; hWnd
.text$mn:00002137                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000213D                 mov     esp, ebp
.text$mn:0000213F                 pop     ebp
.text$mn:00002140                 retn
.text$mn:00002140 ?initTabs@ShortcutMapper@@AAEXXZ endp
.text$mn:00002140
.text$mn:00002140 ; ---------------------------------------------------------------------------
.text$mn:00002141                 db 0Bh dup(0CCh)
.text$mn:0000214C
.text$mn:0000214C ; =============== S U B R O U T I N E =======================================
.text$mn:0000214C
.text$mn:0000214C ; Attributes: bp-based frame
.text$mn:0000214C
.text$mn:0000214C ; void __thiscall ShortcutMapper::initBabyGrid(ShortcutMapper *__hidden this)
.text$mn:0000214C                 public ?initBabyGrid@ShortcutMapper@@AAEXXZ
.text$mn:0000214C ?initBabyGrid@ShortcutMapper@@AAEXXZ proc near
.text$mn:0000214C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+65p
.text$mn:0000214C
.text$mn:0000214C var_18          = dword ptr -18h
.text$mn:0000214C var_14          = byte ptr -14h
.text$mn:0000214C var_4           = dword ptr -4
.text$mn:0000214C
.text$mn:0000214C                 push    ebp
.text$mn:0000214D                 mov     ebp, esp
.text$mn:0000214F                 sub     esp, 18h
.text$mn:00002152                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002157                 xor     eax, ebp
.text$mn:00002159                 mov     [ebp+var_4], eax
.text$mn:0000215C                 mov     [ebp+var_18], ecx
.text$mn:0000215F                 lea     eax, [ebp+var_14]
.text$mn:00002162                 push    eax
.text$mn:00002163                 mov     ecx, [ebp+var_18]
.text$mn:00002166                 mov     edx, [ecx]
.text$mn:00002168                 mov     ecx, [ebp+var_18]
.text$mn:0000216B                 mov     eax, [edx+1Ch]
.text$mn:0000216E                 call    eax
.text$mn:00002170                 push    0A29h
.text$mn:00002175                 mov     ecx, [ebp+var_18]
.text$mn:00002178                 mov     edx, [ecx+0Ch]
.text$mn:0000217B                 push    edx
.text$mn:0000217C                 mov     eax, [ebp+var_18]
.text$mn:0000217F                 mov     ecx, [eax+4]
.text$mn:00002182                 push    ecx
.text$mn:00002183                 mov     ecx, [ebp+var_18]
.text$mn:00002186                 add     ecx, 20h ; ' '
.text$mn:00002189                 mov     edx, [ebp+var_18]
.text$mn:0000218C                 mov     eax, [edx+20h]
.text$mn:0000218F                 mov     edx, [eax+30h]
.text$mn:00002192                 call    edx
.text$mn:00002194                 lea     eax, [ebp+var_14]
.text$mn:00002197                 push    eax
.text$mn:00002198                 mov     ecx, [ebp+var_18]
.text$mn:0000219B                 add     ecx, 20h ; ' '
.text$mn:0000219E                 mov     edx, [ebp+var_18]
.text$mn:000021A1                 mov     eax, [edx+20h]
.text$mn:000021A4                 mov     edx, [eax+14h]
.text$mn:000021A7                 call    edx
.text$mn:000021A9                 mov     ecx, [ebp+var_18]
.text$mn:000021AC                 add     ecx, 20h ; ' '  ; this
.text$mn:000021AF                 call    ?hideCursor@BabyGridWrapper@@QAEXXZ ; BabyGridWrapper::hideCursor(void)
.text$mn:000021B4                 push    1               ; bool
.text$mn:000021B6                 mov     ecx, [ebp+var_18]
.text$mn:000021B9                 add     ecx, 20h ; ' '  ; this
.text$mn:000021BC                 call    ?makeColAutoWidth@BabyGridWrapper@@QAEX_N@Z ; BabyGridWrapper::makeColAutoWidth(bool)
.text$mn:000021C1                 push    0               ; bool
.text$mn:000021C3                 mov     ecx, [ebp+var_18]
.text$mn:000021C6                 add     ecx, 20h ; ' '  ; this
.text$mn:000021C9                 call    ?setColsNumbered@BabyGridWrapper@@QAEX_N@Z ; BabyGridWrapper::setColsNumbered(bool)
.text$mn:000021CE                 push    1Eh             ; unsigned int
.text$mn:000021D0                 push    0               ; wParam
.text$mn:000021D2                 mov     ecx, [ebp+var_18]
.text$mn:000021D5                 add     ecx, 20h ; ' '  ; this
.text$mn:000021D8                 call    ?setColWidth@BabyGridWrapper@@QAEXII@Z ; BabyGridWrapper::setColWidth(uint,uint)
.text$mn:000021DD                 push    0FAh ; '·'      ; unsigned int
.text$mn:000021E2                 push    1               ; wParam
.text$mn:000021E4                 mov     ecx, [ebp+var_18]
.text$mn:000021E7                 add     ecx, 20h ; ' '  ; this
.text$mn:000021EA                 call    ?setColWidth@BabyGridWrapper@@QAEXII@Z ; BabyGridWrapper::setColWidth(uint,uint)
.text$mn:000021EF                 mov     ecx, [ebp+var_4]
.text$mn:000021F2                 xor     ecx, ebp
.text$mn:000021F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000021F9                 mov     esp, ebp
.text$mn:000021FB                 pop     ebp
.text$mn:000021FC                 retn
.text$mn:000021FC ?initBabyGrid@ShortcutMapper@@AAEXXZ endp
.text$mn:000021FC
.text$mn:000021FC ; ---------------------------------------------------------------------------
.text$mn:000021FD                 db 0Fh dup(0CCh)
.text$mn:0000220C
.text$mn:0000220C ; =============== S U B R O U T I N E =======================================
.text$mn:0000220C
.text$mn:0000220C ; Attributes: bp-based frame
.text$mn:0000220C
.text$mn:0000220C ; void __thiscall ShortcutMapper::fillOutBabyGrid(ShortcutMapper *__hidden this)
.text$mn:0000220C                 public ?fillOutBabyGrid@ShortcutMapper@@AAEXXZ
.text$mn:0000220C ?fillOutBabyGrid@ShortcutMapper@@AAEXXZ proc near
.text$mn:0000220C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+75p
.text$mn:0000220C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+159p ...
.text$mn:0000220C
.text$mn:0000220C var_128         = dword ptr -128h
.text$mn:0000220C var_124         = dword ptr -124h
.text$mn:0000220C var_120         = dword ptr -120h
.text$mn:0000220C var_11C         = dword ptr -11Ch
.text$mn:0000220C var_118         = dword ptr -118h
.text$mn:0000220C var_114         = dword ptr -114h
.text$mn:0000220C var_110         = dword ptr -110h
.text$mn:0000220C var_10C         = dword ptr -10Ch
.text$mn:0000220C var_108         = dword ptr -108h
.text$mn:0000220C var_104         = dword ptr -104h
.text$mn:0000220C var_100         = dword ptr -100h
.text$mn:0000220C var_FC          = dword ptr -0FCh
.text$mn:0000220C var_F8          = dword ptr -0F8h
.text$mn:0000220C var_F4          = dword ptr -0F4h
.text$mn:0000220C var_F0          = dword ptr -0F0h
.text$mn:0000220C var_EC          = dword ptr -0ECh
.text$mn:0000220C var_E8          = dword ptr -0E8h
.text$mn:0000220C var_E4          = dword ptr -0E4h
.text$mn:0000220C var_E0          = dword ptr -0E0h
.text$mn:0000220C var_DC          = dword ptr -0DCh
.text$mn:0000220C var_D8          = dword ptr -0D8h
.text$mn:0000220C var_D4          = dword ptr -0D4h
.text$mn:0000220C var_D0          = dword ptr -0D0h
.text$mn:0000220C var_CC          = dword ptr -0CCh
.text$mn:0000220C var_C8          = dword ptr -0C8h
.text$mn:0000220C var_C4          = dword ptr -0C4h
.text$mn:0000220C var_BD          = byte ptr -0BDh
.text$mn:0000220C var_BC          = dword ptr -0BCh
.text$mn:0000220C var_B8          = dword ptr -0B8h
.text$mn:0000220C var_B4          = dword ptr -0B4h
.text$mn:0000220C var_B0          = dword ptr -0B0h
.text$mn:0000220C var_AC          = dword ptr -0ACh
.text$mn:0000220C var_A6          = byte ptr -0A6h
.text$mn:0000220C var_A5          = byte ptr -0A5h
.text$mn:0000220C wParam          = dword ptr -0A4h
.text$mn:0000220C var_A0          = dword ptr -0A0h
.text$mn:0000220C var_9C          = byte ptr -9Ch
.text$mn:0000220C var_80          = byte ptr -80h
.text$mn:0000220C var_64          = byte ptr -64h
.text$mn:0000220C var_48          = byte ptr -48h
.text$mn:0000220C var_2C          = byte ptr -2Ch
.text$mn:0000220C var_10          = dword ptr -10h
.text$mn:0000220C var_C           = dword ptr -0Ch
.text$mn:0000220C var_4           = dword ptr -4
.text$mn:0000220C
.text$mn:0000220C                 push    ebp
.text$mn:0000220D                 mov     ebp, esp
.text$mn:0000220F                 push    0FFFFFFFFh
.text$mn:00002211                 push    offset __ehhandler$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ
.text$mn:00002216                 mov     eax, large fs:0
.text$mn:0000221C                 push    eax
.text$mn:0000221D                 sub     esp, 11Ch
.text$mn:00002223                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002228                 xor     eax, ebp
.text$mn:0000222A                 mov     [ebp+var_10], eax
.text$mn:0000222D                 push    eax
.text$mn:0000222E                 lea     eax, [ebp+var_C]
.text$mn:00002231                 mov     large fs:0, eax
.text$mn:00002237                 mov     [ebp+var_A0], ecx
.text$mn:0000223D                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00002242                 mov     [ebp+var_AC], eax
.text$mn:00002248                 mov     ecx, [ebp+var_A0]
.text$mn:0000224E                 add     ecx, 20h ; ' '  ; this
.text$mn:00002251                 call    ?clear@BabyGridWrapper@@QAEXXZ ; BabyGridWrapper::clear(void)
.text$mn:00002256                 mov     [ebp+wParam], 0
.text$mn:00002260                 mov     eax, [ebp+var_A0]
.text$mn:00002266                 mov     ecx, [eax+48h]
.text$mn:00002269                 mov     [ebp+var_DC], ecx
.text$mn:0000226F                 cmp     [ebp+var_DC], 4 ; switch 5 cases
.text$mn:00002276                 ja      loc_2382        ; jumptable 00002282 default case
.text$mn:0000227C                 mov     edx, [ebp+var_DC]
.text$mn:00002282                 jmp     ds:$LN44_0[edx*4] ; switch jump
.text$mn:00002289 ; ---------------------------------------------------------------------------
.text$mn:00002289
.text$mn:00002289 $LN27:                                  ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+76j
.text$mn:00002289                                         ; DATA XREF: .text$mn:$LN44_0o
.text$mn:00002289                 mov     ecx, [ebp+var_AC] ; jumptable 00002282 case 0
.text$mn:0000228F                 call    ?getUserShortcuts@NppParameters@@QAEAAV?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@XZ ; NppParameters::getUserShortcuts(void)
.text$mn:00002294                 mov     ecx, eax
.text$mn:00002296                 call    ?size@?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QBEIXZ ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::size(void)
.text$mn:0000229B                 mov     [ebp+wParam], eax
.text$mn:000022A1                 push    2               ; unsigned int
.text$mn:000022A3                 mov     eax, [ebp+wParam]
.text$mn:000022A9                 push    eax             ; wParam
.text$mn:000022AA                 mov     ecx, [ebp+var_A0]
.text$mn:000022B0                 add     ecx, 20h ; ' '  ; this
.text$mn:000022B3                 call    ?setLineColNumber@BabyGridWrapper@@QAEXII@Z ; BabyGridWrapper::setLineColNumber(uint,uint)
.text$mn:000022B8                 jmp     loc_2382        ; jumptable 00002282 default case
.text$mn:000022BD ; ---------------------------------------------------------------------------
.text$mn:000022BD
.text$mn:000022BD $LN26_0:                                ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+76j
.text$mn:000022BD                                         ; DATA XREF: .text$mn:$LN44_0o
.text$mn:000022BD                 mov     ecx, [ebp+var_AC] ; jumptable 00002282 case 1
.text$mn:000022C3                 call    ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ ; NppParameters::getMacroList(void)
.text$mn:000022C8                 mov     ecx, eax
.text$mn:000022CA                 call    ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::size(void)
.text$mn:000022CF                 mov     [ebp+wParam], eax
.text$mn:000022D5                 push    2               ; unsigned int
.text$mn:000022D7                 mov     ecx, [ebp+wParam]
.text$mn:000022DD                 push    ecx             ; wParam
.text$mn:000022DE                 mov     ecx, [ebp+var_A0]
.text$mn:000022E4                 add     ecx, 20h ; ' '  ; this
.text$mn:000022E7                 call    ?setLineColNumber@BabyGridWrapper@@QAEXII@Z ; BabyGridWrapper::setLineColNumber(uint,uint)
.text$mn:000022EC                 jmp     loc_2382        ; jumptable 00002282 default case
.text$mn:000022F1 ; ---------------------------------------------------------------------------
.text$mn:000022F1
.text$mn:000022F1 $LN25:                                  ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+76j
.text$mn:000022F1                                         ; DATA XREF: .text$mn:$LN44_0o
.text$mn:000022F1                 mov     ecx, [ebp+var_AC] ; jumptable 00002282 case 2
.text$mn:000022F7                 call    ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ ; NppParameters::getUserCommandList(void)
.text$mn:000022FC                 mov     ecx, eax
.text$mn:000022FE                 call    ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::size(void)
.text$mn:00002303                 mov     [ebp+wParam], eax
.text$mn:00002309                 push    2               ; unsigned int
.text$mn:0000230B                 mov     edx, [ebp+wParam]
.text$mn:00002311                 push    edx             ; wParam
.text$mn:00002312                 mov     ecx, [ebp+var_A0]
.text$mn:00002318                 add     ecx, 20h ; ' '  ; this
.text$mn:0000231B                 call    ?setLineColNumber@BabyGridWrapper@@QAEXII@Z ; BabyGridWrapper::setLineColNumber(uint,uint)
.text$mn:00002320                 jmp     short loc_2382  ; jumptable 00002282 default case
.text$mn:00002322 ; ---------------------------------------------------------------------------
.text$mn:00002322
.text$mn:00002322 $LN24:                                  ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+76j
.text$mn:00002322                                         ; DATA XREF: .text$mn:$LN44_0o
.text$mn:00002322                 mov     ecx, [ebp+var_AC] ; jumptable 00002282 case 3
.text$mn:00002328                 call    ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ ; NppParameters::getPluginCommandList(void)
.text$mn:0000232D                 mov     ecx, eax
.text$mn:0000232F                 call    ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::size(void)
.text$mn:00002334                 mov     [ebp+wParam], eax
.text$mn:0000233A                 push    2               ; unsigned int
.text$mn:0000233C                 mov     eax, [ebp+wParam]
.text$mn:00002342                 push    eax             ; wParam
.text$mn:00002343                 mov     ecx, [ebp+var_A0]
.text$mn:00002349                 add     ecx, 20h ; ' '  ; this
.text$mn:0000234C                 call    ?setLineColNumber@BabyGridWrapper@@QAEXII@Z ; BabyGridWrapper::setLineColNumber(uint,uint)
.text$mn:00002351                 jmp     short loc_2382  ; jumptable 00002282 default case
.text$mn:00002353 ; ---------------------------------------------------------------------------
.text$mn:00002353
.text$mn:00002353 $LN23:                                  ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+76j
.text$mn:00002353                                         ; DATA XREF: .text$mn:$LN44_0o
.text$mn:00002353                 mov     ecx, [ebp+var_AC] ; jumptable 00002282 case 4
.text$mn:00002359                 call    ?getScintillaKeyList@NppParameters@@QAEAAV?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@XZ ; NppParameters::getScintillaKeyList(void)
.text$mn:0000235E                 mov     ecx, eax
.text$mn:00002360                 call    ?size@?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QBEIXZ ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::size(void)
.text$mn:00002365                 mov     [ebp+wParam], eax
.text$mn:0000236B                 push    2               ; unsigned int
.text$mn:0000236D                 mov     ecx, [ebp+wParam]
.text$mn:00002373                 push    ecx             ; wParam
.text$mn:00002374                 mov     ecx, [ebp+var_A0]
.text$mn:0000237A                 add     ecx, 20h ; ' '  ; this
.text$mn:0000237D                 call    ?setLineColNumber@BabyGridWrapper@@QAEXII@Z ; BabyGridWrapper::setLineColNumber(uint,uint)
.text$mn:00002382
.text$mn:00002382 loc_2382:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+6Aj
.text$mn:00002382                                         ; ShortcutMapper::fillOutBabyGrid(void)+ACj ...
.text$mn:00002382                 push    offset $SG169325 ; jumptable 00002282 default case
.text$mn:00002387                 push    1               ; unsigned int
.text$mn:00002389                 push    0               ; unsigned int
.text$mn:0000238B                 mov     ecx, [ebp+var_A0]
.text$mn:00002391                 add     ecx, 20h ; ' '  ; this
.text$mn:00002394                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:00002399                 push    offset $SG169326 ; "Shortcut"
.text$mn:0000239E                 push    2               ; unsigned int
.text$mn:000023A0                 push    0               ; unsigned int
.text$mn:000023A2                 mov     ecx, [ebp+var_A0]
.text$mn:000023A8                 add     ecx, 20h ; ' '  ; this
.text$mn:000023AB                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000023B0                 mov     edx, [ebp+var_A0]
.text$mn:000023B6                 mov     eax, [edx+48h]
.text$mn:000023B9                 mov     [ebp+var_E8], eax
.text$mn:000023BF                 cmp     [ebp+var_E8], 4 ; switch 5 cases
.text$mn:000023C6                 ja      loc_2A82        ; jumptable 000023D2 default case
.text$mn:000023CC                 mov     ecx, [ebp+var_E8]
.text$mn:000023D2                 jmp     ds:$LN45_0[ecx*4] ; switch jump
.text$mn:000023D9 ; ---------------------------------------------------------------------------
.text$mn:000023D9
.text$mn:000023D9 $LN20_0:                                ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+1C6j
.text$mn:000023D9                                         ; DATA XREF: .text$mn:$LN45_0o
.text$mn:000023D9                 mov     ecx, [ebp+var_AC] ; jumptable 000023D2 case 0
.text$mn:000023DF                 call    ?getUserShortcuts@NppParameters@@QAEAAV?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@XZ ; NppParameters::getUserShortcuts(void)
.text$mn:000023E4                 mov     [ebp+var_F0], eax
.text$mn:000023EA                 mov     [ebp+var_B8], 0
.text$mn:000023F4                 jmp     short loc_2405
.text$mn:000023F6 ; ---------------------------------------------------------------------------
.text$mn:000023F6
.text$mn:000023F6 loc_23F6:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+2C2j
.text$mn:000023F6                 mov     edx, [ebp+var_B8]
.text$mn:000023FC                 add     edx, 1
.text$mn:000023FF                 mov     [ebp+var_B8], edx
.text$mn:00002405
.text$mn:00002405 loc_2405:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+1E8j
.text$mn:00002405                 mov     eax, [ebp+var_B8]
.text$mn:0000240B                 cmp     eax, [ebp+wParam]
.text$mn:00002411                 jnb     loc_24D3
.text$mn:00002417                 mov     ecx, [ebp+var_B8]
.text$mn:0000241D                 push    ecx
.text$mn:0000241E                 mov     ecx, [ebp+var_F0]
.text$mn:00002424                 call    ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)
.text$mn:00002429                 mov     ecx, eax        ; this
.text$mn:0000242B                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:00002430                 push    eax             ; wchar_t *
.text$mn:00002431                 push    1               ; unsigned int
.text$mn:00002433                 mov     edx, [ebp+var_B8]
.text$mn:00002439                 add     edx, 1
.text$mn:0000243C                 push    edx             ; unsigned int
.text$mn:0000243D                 mov     ecx, [ebp+var_A0]
.text$mn:00002443                 add     ecx, 20h ; ' '  ; this
.text$mn:00002446                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:0000244B                 mov     eax, [ebp+var_B8]
.text$mn:00002451                 push    eax
.text$mn:00002452                 mov     ecx, [ebp+var_F0]
.text$mn:00002458                 call    ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)
.text$mn:0000245D                 mov     [ebp+var_F8], eax
.text$mn:00002463                 lea     ecx, [ebp+var_9C]
.text$mn:00002469                 push    ecx
.text$mn:0000246A                 mov     edx, [ebp+var_F8]
.text$mn:00002470                 mov     eax, [edx]
.text$mn:00002472                 mov     ecx, [ebp+var_F8]
.text$mn:00002478                 mov     edx, [eax+48h]
.text$mn:0000247B                 call    edx
.text$mn:0000247D                 mov     [ebp+var_110], eax
.text$mn:00002483                 mov     eax, [ebp+var_110]
.text$mn:00002489                 mov     [ebp+var_108], eax
.text$mn:0000248F                 mov     [ebp+var_4], 0
.text$mn:00002496                 mov     ecx, [ebp+var_108]
.text$mn:0000249C                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000024A1                 push    eax             ; wchar_t *
.text$mn:000024A2                 push    2               ; unsigned int
.text$mn:000024A4                 mov     ecx, [ebp+var_B8]
.text$mn:000024AA                 add     ecx, 1
.text$mn:000024AD                 push    ecx             ; unsigned int
.text$mn:000024AE                 mov     ecx, [ebp+var_A0]
.text$mn:000024B4                 add     ecx, 20h ; ' '  ; this
.text$mn:000024B7                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000024BC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000024C3                 lea     ecx, [ebp+var_9C]
.text$mn:000024C9                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000024CE                 jmp     loc_23F6
.text$mn:000024D3 ; ---------------------------------------------------------------------------
.text$mn:000024D3
.text$mn:000024D3 loc_24D3:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+205j
.text$mn:000024D3                 push    1               ; bEnable
.text$mn:000024D5                 push    0A2Ah           ; nIDDlgItem
.text$mn:000024DA                 mov     edx, [ebp+var_A0]
.text$mn:000024E0                 mov     eax, [edx+0Ch]
.text$mn:000024E3                 push    eax             ; hDlg
.text$mn:000024E4                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000024EA                 push    eax             ; hWnd
.text$mn:000024EB                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:000024F1                 push    0               ; bEnable
.text$mn:000024F3                 push    0A2Bh           ; nIDDlgItem
.text$mn:000024F8                 mov     ecx, [ebp+var_A0]
.text$mn:000024FE                 mov     edx, [ecx+0Ch]
.text$mn:00002501                 push    edx             ; hDlg
.text$mn:00002502                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002508                 push    eax             ; hWnd
.text$mn:00002509                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:0000250F                 jmp     loc_2A82        ; jumptable 000023D2 default case
.text$mn:00002514 ; ---------------------------------------------------------------------------
.text$mn:00002514
.text$mn:00002514 $LN16:                                  ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+1C6j
.text$mn:00002514                                         ; DATA XREF: .text$mn:$LN45_0o
.text$mn:00002514                 mov     ecx, [ebp+var_AC] ; jumptable 000023D2 case 1
.text$mn:0000251A                 call    ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ ; NppParameters::getMacroList(void)
.text$mn:0000251F                 mov     [ebp+var_100], eax
.text$mn:00002525                 mov     [ebp+var_B0], 0
.text$mn:0000252F                 jmp     short loc_2540
.text$mn:00002531 ; ---------------------------------------------------------------------------
.text$mn:00002531
.text$mn:00002531 loc_2531:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+3F7j
.text$mn:00002531                 mov     eax, [ebp+var_B0]
.text$mn:00002537                 add     eax, 1
.text$mn:0000253A                 mov     [ebp+var_B0], eax
.text$mn:00002540
.text$mn:00002540 loc_2540:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+323j
.text$mn:00002540                 mov     ecx, [ebp+var_B0]
.text$mn:00002546                 cmp     ecx, [ebp+wParam]
.text$mn:0000254C                 jnb     loc_2608
.text$mn:00002552                 mov     edx, [ebp+var_B0]
.text$mn:00002558                 push    edx
.text$mn:00002559                 mov     ecx, [ebp+var_100]
.text$mn:0000255F                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:00002564                 mov     ecx, eax        ; this
.text$mn:00002566                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:0000256B                 push    eax             ; wchar_t *
.text$mn:0000256C                 push    1               ; unsigned int
.text$mn:0000256E                 mov     eax, [ebp+var_B0]
.text$mn:00002574                 add     eax, 1
.text$mn:00002577                 push    eax             ; unsigned int
.text$mn:00002578                 mov     ecx, [ebp+var_A0]
.text$mn:0000257E                 add     ecx, 20h ; ' '  ; this
.text$mn:00002581                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:00002586                 mov     ecx, [ebp+var_B0]
.text$mn:0000258C                 push    ecx
.text$mn:0000258D                 mov     ecx, [ebp+var_100]
.text$mn:00002593                 call    ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)
.text$mn:00002598                 mov     [ebp+var_F4], eax
.text$mn:0000259E                 lea     edx, [ebp+var_80]
.text$mn:000025A1                 push    edx
.text$mn:000025A2                 mov     eax, [ebp+var_F4]
.text$mn:000025A8                 mov     edx, [eax]
.text$mn:000025AA                 mov     ecx, [ebp+var_F4]
.text$mn:000025B0                 mov     eax, [edx+48h]
.text$mn:000025B3                 call    eax
.text$mn:000025B5                 mov     [ebp+var_104], eax
.text$mn:000025BB                 mov     ecx, [ebp+var_104]
.text$mn:000025C1                 mov     [ebp+var_118], ecx
.text$mn:000025C7                 mov     [ebp+var_4], 1
.text$mn:000025CE                 mov     ecx, [ebp+var_118]
.text$mn:000025D4                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000025D9                 push    eax             ; wchar_t *
.text$mn:000025DA                 push    2               ; unsigned int
.text$mn:000025DC                 mov     edx, [ebp+var_B0]
.text$mn:000025E2                 add     edx, 1
.text$mn:000025E5                 push    edx             ; unsigned int
.text$mn:000025E6                 mov     ecx, [ebp+var_A0]
.text$mn:000025EC                 add     ecx, 20h ; ' '  ; this
.text$mn:000025EF                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000025F4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000025FB                 lea     ecx, [ebp+var_80]
.text$mn:000025FE                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002603                 jmp     loc_2531
.text$mn:00002608 ; ---------------------------------------------------------------------------
.text$mn:00002608
.text$mn:00002608 loc_2608:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+340j
.text$mn:00002608                 cmp     [ebp+wParam], 0
.text$mn:0000260F                 jbe     short loc_261D
.text$mn:00002611                 mov     [ebp+var_E0], 1
.text$mn:0000261B                 jmp     short loc_2627
.text$mn:0000261D ; ---------------------------------------------------------------------------
.text$mn:0000261D
.text$mn:0000261D loc_261D:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+403j
.text$mn:0000261D                 mov     [ebp+var_E0], 0
.text$mn:00002627
.text$mn:00002627 loc_2627:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+40Fj
.text$mn:00002627                 mov     al, byte ptr [ebp+var_E0]
.text$mn:0000262D                 mov     [ebp+var_A6], al
.text$mn:00002633                 movzx   ecx, [ebp+var_A6]
.text$mn:0000263A                 push    ecx             ; bEnable
.text$mn:0000263B                 push    0A2Ah           ; nIDDlgItem
.text$mn:00002640                 mov     edx, [ebp+var_A0]
.text$mn:00002646                 mov     eax, [edx+0Ch]
.text$mn:00002649                 push    eax             ; hDlg
.text$mn:0000264A                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002650                 push    eax             ; hWnd
.text$mn:00002651                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00002657                 movzx   ecx, [ebp+var_A6]
.text$mn:0000265E                 push    ecx             ; bEnable
.text$mn:0000265F                 push    0A2Bh           ; nIDDlgItem
.text$mn:00002664                 mov     edx, [ebp+var_A0]
.text$mn:0000266A                 mov     eax, [edx+0Ch]
.text$mn:0000266D                 push    eax             ; hDlg
.text$mn:0000266E                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002674                 push    eax             ; hWnd
.text$mn:00002675                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:0000267B                 jmp     loc_2A82        ; jumptable 000023D2 default case
.text$mn:00002680 ; ---------------------------------------------------------------------------
.text$mn:00002680
.text$mn:00002680 $LN12:                                  ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+1C6j
.text$mn:00002680                                         ; DATA XREF: .text$mn:$LN45_0o
.text$mn:00002680                 mov     ecx, [ebp+var_AC] ; jumptable 000023D2 case 2
.text$mn:00002686                 call    ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ ; NppParameters::getUserCommandList(void)
.text$mn:0000268B                 mov     [ebp+var_D4], eax
.text$mn:00002691                 mov     [ebp+var_B4], 0
.text$mn:0000269B                 jmp     short loc_26AC
.text$mn:0000269D ; ---------------------------------------------------------------------------
.text$mn:0000269D
.text$mn:0000269D loc_269D:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+563j
.text$mn:0000269D                 mov     ecx, [ebp+var_B4]
.text$mn:000026A3                 add     ecx, 1
.text$mn:000026A6                 mov     [ebp+var_B4], ecx
.text$mn:000026AC
.text$mn:000026AC loc_26AC:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+48Fj
.text$mn:000026AC                 mov     edx, [ebp+var_B4]
.text$mn:000026B2                 cmp     edx, [ebp+wParam]
.text$mn:000026B8                 jnb     loc_2774
.text$mn:000026BE                 mov     eax, [ebp+var_B4]
.text$mn:000026C4                 push    eax
.text$mn:000026C5                 mov     ecx, [ebp+var_D4]
.text$mn:000026CB                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:000026D0                 mov     ecx, eax        ; this
.text$mn:000026D2                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:000026D7                 push    eax             ; wchar_t *
.text$mn:000026D8                 push    1               ; unsigned int
.text$mn:000026DA                 mov     ecx, [ebp+var_B4]
.text$mn:000026E0                 add     ecx, 1
.text$mn:000026E3                 push    ecx             ; unsigned int
.text$mn:000026E4                 mov     ecx, [ebp+var_A0]
.text$mn:000026EA                 add     ecx, 20h ; ' '  ; this
.text$mn:000026ED                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000026F2                 mov     edx, [ebp+var_B4]
.text$mn:000026F8                 push    edx
.text$mn:000026F9                 mov     ecx, [ebp+var_D4]
.text$mn:000026FF                 call    ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)
.text$mn:00002704                 mov     [ebp+var_EC], eax
.text$mn:0000270A                 lea     eax, [ebp+var_48]
.text$mn:0000270D                 push    eax
.text$mn:0000270E                 mov     ecx, [ebp+var_EC]
.text$mn:00002714                 mov     edx, [ecx]
.text$mn:00002716                 mov     ecx, [ebp+var_EC]
.text$mn:0000271C                 mov     eax, [edx+48h]
.text$mn:0000271F                 call    eax
.text$mn:00002721                 mov     [ebp+var_120], eax
.text$mn:00002727                 mov     ecx, [ebp+var_120]
.text$mn:0000272D                 mov     [ebp+var_128], ecx
.text$mn:00002733                 mov     [ebp+var_4], 2
.text$mn:0000273A                 mov     ecx, [ebp+var_128]
.text$mn:00002740                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002745                 push    eax             ; wchar_t *
.text$mn:00002746                 push    2               ; unsigned int
.text$mn:00002748                 mov     edx, [ebp+var_B4]
.text$mn:0000274E                 add     edx, 1
.text$mn:00002751                 push    edx             ; unsigned int
.text$mn:00002752                 mov     ecx, [ebp+var_A0]
.text$mn:00002758                 add     ecx, 20h ; ' '  ; this
.text$mn:0000275B                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:00002760                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002767                 lea     ecx, [ebp+var_48]
.text$mn:0000276A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000276F                 jmp     loc_269D
.text$mn:00002774 ; ---------------------------------------------------------------------------
.text$mn:00002774
.text$mn:00002774 loc_2774:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+4ACj
.text$mn:00002774                 cmp     [ebp+wParam], 0
.text$mn:0000277B                 jbe     short loc_2789
.text$mn:0000277D                 mov     [ebp+var_C8], 1
.text$mn:00002787                 jmp     short loc_2793
.text$mn:00002789 ; ---------------------------------------------------------------------------
.text$mn:00002789
.text$mn:00002789 loc_2789:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+56Fj
.text$mn:00002789                 mov     [ebp+var_C8], 0
.text$mn:00002793
.text$mn:00002793 loc_2793:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+57Bj
.text$mn:00002793                 mov     al, byte ptr [ebp+var_C8]
.text$mn:00002799                 mov     [ebp+var_A5], al
.text$mn:0000279F                 movzx   ecx, [ebp+var_A5]
.text$mn:000027A6                 push    ecx             ; bEnable
.text$mn:000027A7                 push    0A2Ah           ; nIDDlgItem
.text$mn:000027AC                 mov     edx, [ebp+var_A0]
.text$mn:000027B2                 mov     eax, [edx+0Ch]
.text$mn:000027B5                 push    eax             ; hDlg
.text$mn:000027B6                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000027BC                 push    eax             ; hWnd
.text$mn:000027BD                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:000027C3                 movzx   ecx, [ebp+var_A5]
.text$mn:000027CA                 push    ecx             ; bEnable
.text$mn:000027CB                 push    0A2Bh           ; nIDDlgItem
.text$mn:000027D0                 mov     edx, [ebp+var_A0]
.text$mn:000027D6                 mov     eax, [edx+0Ch]
.text$mn:000027D9                 push    eax             ; hDlg
.text$mn:000027DA                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000027E0                 push    eax             ; hWnd
.text$mn:000027E1                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:000027E7                 jmp     loc_2A82        ; jumptable 000023D2 default case
.text$mn:000027EC ; ---------------------------------------------------------------------------
.text$mn:000027EC
.text$mn:000027EC $LN8:                                   ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+1C6j
.text$mn:000027EC                                         ; DATA XREF: .text$mn:$LN45_0o
.text$mn:000027EC                 mov     ecx, [ebp+var_AC] ; jumptable 000023D2 case 3
.text$mn:000027F2                 call    ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ ; NppParameters::getPluginCommandList(void)
.text$mn:000027F7                 mov     [ebp+var_FC], eax
.text$mn:000027FD                 mov     [ebp+var_BC], 0
.text$mn:00002807                 jmp     short loc_2818
.text$mn:00002809 ; ---------------------------------------------------------------------------
.text$mn:00002809
.text$mn:00002809 loc_2809:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+6CFj
.text$mn:00002809                 mov     ecx, [ebp+var_BC]
.text$mn:0000280F                 add     ecx, 1
.text$mn:00002812                 mov     [ebp+var_BC], ecx
.text$mn:00002818
.text$mn:00002818 loc_2818:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+5FBj
.text$mn:00002818                 mov     edx, [ebp+var_BC]
.text$mn:0000281E                 cmp     edx, [ebp+wParam]
.text$mn:00002824                 jnb     loc_28E0
.text$mn:0000282A                 mov     eax, [ebp+var_BC]
.text$mn:00002830                 push    eax
.text$mn:00002831                 mov     ecx, [ebp+var_FC]
.text$mn:00002837                 call    ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)
.text$mn:0000283C                 mov     ecx, eax        ; this
.text$mn:0000283E                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:00002843                 push    eax             ; wchar_t *
.text$mn:00002844                 push    1               ; unsigned int
.text$mn:00002846                 mov     ecx, [ebp+var_BC]
.text$mn:0000284C                 add     ecx, 1
.text$mn:0000284F                 push    ecx             ; unsigned int
.text$mn:00002850                 mov     ecx, [ebp+var_A0]
.text$mn:00002856                 add     ecx, 20h ; ' '  ; this
.text$mn:00002859                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:0000285E                 mov     edx, [ebp+var_BC]
.text$mn:00002864                 push    edx
.text$mn:00002865                 mov     ecx, [ebp+var_FC]
.text$mn:0000286B                 call    ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)
.text$mn:00002870                 mov     [ebp+var_E4], eax
.text$mn:00002876                 lea     eax, [ebp+var_2C]
.text$mn:00002879                 push    eax
.text$mn:0000287A                 mov     ecx, [ebp+var_E4]
.text$mn:00002880                 mov     edx, [ecx]
.text$mn:00002882                 mov     ecx, [ebp+var_E4]
.text$mn:00002888                 mov     eax, [edx+48h]
.text$mn:0000288B                 call    eax
.text$mn:0000288D                 mov     [ebp+var_10C], eax
.text$mn:00002893                 mov     ecx, [ebp+var_10C]
.text$mn:00002899                 mov     [ebp+var_11C], ecx
.text$mn:0000289F                 mov     [ebp+var_4], 3
.text$mn:000028A6                 mov     ecx, [ebp+var_11C]
.text$mn:000028AC                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000028B1                 push    eax             ; wchar_t *
.text$mn:000028B2                 push    2               ; unsigned int
.text$mn:000028B4                 mov     edx, [ebp+var_BC]
.text$mn:000028BA                 add     edx, 1
.text$mn:000028BD                 push    edx             ; unsigned int
.text$mn:000028BE                 mov     ecx, [ebp+var_A0]
.text$mn:000028C4                 add     ecx, 20h ; ' '  ; this
.text$mn:000028C7                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000028CC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028D3                 lea     ecx, [ebp+var_2C]
.text$mn:000028D6                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000028DB                 jmp     loc_2809
.text$mn:000028E0 ; ---------------------------------------------------------------------------
.text$mn:000028E0
.text$mn:000028E0 loc_28E0:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+618j
.text$mn:000028E0                 cmp     [ebp+wParam], 0
.text$mn:000028E7                 jbe     short loc_28F5
.text$mn:000028E9                 mov     [ebp+var_CC], 1
.text$mn:000028F3                 jmp     short loc_28FF
.text$mn:000028F5 ; ---------------------------------------------------------------------------
.text$mn:000028F5
.text$mn:000028F5 loc_28F5:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+6DBj
.text$mn:000028F5                 mov     [ebp+var_CC], 0
.text$mn:000028FF
.text$mn:000028FF loc_28FF:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+6E7j
.text$mn:000028FF                 mov     al, byte ptr [ebp+var_CC]
.text$mn:00002905                 mov     [ebp+var_BD], al
.text$mn:0000290B                 movzx   ecx, [ebp+var_BD]
.text$mn:00002912                 push    ecx             ; bEnable
.text$mn:00002913                 push    0A2Ah           ; nIDDlgItem
.text$mn:00002918                 mov     edx, [ebp+var_A0]
.text$mn:0000291E                 mov     eax, [edx+0Ch]
.text$mn:00002921                 push    eax             ; hDlg
.text$mn:00002922                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002928                 push    eax             ; hWnd
.text$mn:00002929                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:0000292F                 push    0               ; bEnable
.text$mn:00002931                 push    0A2Bh           ; nIDDlgItem
.text$mn:00002936                 mov     ecx, [ebp+var_A0]
.text$mn:0000293C                 mov     edx, [ecx+0Ch]
.text$mn:0000293F                 push    edx             ; hDlg
.text$mn:00002940                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002946                 push    eax             ; hWnd
.text$mn:00002947                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:0000294D                 jmp     loc_2A82        ; jumptable 000023D2 default case
.text$mn:00002952 ; ---------------------------------------------------------------------------
.text$mn:00002952
.text$mn:00002952 $LN4_3:                                 ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+1C6j
.text$mn:00002952                                         ; DATA XREF: .text$mn:$LN45_0o
.text$mn:00002952                 mov     ecx, [ebp+var_AC] ; jumptable 000023D2 case 4
.text$mn:00002958                 call    ?getScintillaKeyList@NppParameters@@QAEAAV?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@XZ ; NppParameters::getScintillaKeyList(void)
.text$mn:0000295D                 mov     [ebp+var_D0], eax
.text$mn:00002963                 mov     [ebp+var_C4], 0
.text$mn:0000296D                 jmp     short loc_297E
.text$mn:0000296F ; ---------------------------------------------------------------------------
.text$mn:0000296F
.text$mn:0000296F loc_296F:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+835j
.text$mn:0000296F                 mov     eax, [ebp+var_C4]
.text$mn:00002975                 add     eax, 1
.text$mn:00002978                 mov     [ebp+var_C4], eax
.text$mn:0000297E
.text$mn:0000297E loc_297E:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+761j
.text$mn:0000297E                 mov     ecx, [ebp+var_C4]
.text$mn:00002984                 cmp     ecx, [ebp+wParam]
.text$mn:0000298A                 jnb     loc_2A46
.text$mn:00002990                 mov     edx, [ebp+var_C4]
.text$mn:00002996                 push    edx
.text$mn:00002997                 mov     ecx, [ebp+var_D0]
.text$mn:0000299D                 call    ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)
.text$mn:000029A2                 mov     ecx, eax        ; this
.text$mn:000029A4                 call    ?getName@Shortcut@@QBEPB_WXZ ; Shortcut::getName(void)
.text$mn:000029A9                 push    eax             ; wchar_t *
.text$mn:000029AA                 push    1               ; unsigned int
.text$mn:000029AC                 mov     eax, [ebp+var_C4]
.text$mn:000029B2                 add     eax, 1
.text$mn:000029B5                 push    eax             ; unsigned int
.text$mn:000029B6                 mov     ecx, [ebp+var_A0]
.text$mn:000029BC                 add     ecx, 20h ; ' '  ; this
.text$mn:000029BF                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:000029C4                 mov     ecx, [ebp+var_C4]
.text$mn:000029CA                 push    ecx
.text$mn:000029CB                 mov     ecx, [ebp+var_D0]
.text$mn:000029D1                 call    ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)
.text$mn:000029D6                 mov     [ebp+var_D8], eax
.text$mn:000029DC                 lea     edx, [ebp+var_64]
.text$mn:000029DF                 push    edx
.text$mn:000029E0                 mov     eax, [ebp+var_D8]
.text$mn:000029E6                 mov     edx, [eax]
.text$mn:000029E8                 mov     ecx, [ebp+var_D8]
.text$mn:000029EE                 mov     eax, [edx+48h]
.text$mn:000029F1                 call    eax
.text$mn:000029F3                 mov     [ebp+var_114], eax
.text$mn:000029F9                 mov     ecx, [ebp+var_114]
.text$mn:000029FF                 mov     [ebp+var_124], ecx
.text$mn:00002A05                 mov     [ebp+var_4], 4
.text$mn:00002A0C                 mov     ecx, [ebp+var_124]
.text$mn:00002A12                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002A17                 push    eax             ; wchar_t *
.text$mn:00002A18                 push    2               ; unsigned int
.text$mn:00002A1A                 mov     edx, [ebp+var_C4]
.text$mn:00002A20                 add     edx, 1
.text$mn:00002A23                 push    edx             ; unsigned int
.text$mn:00002A24                 mov     ecx, [ebp+var_A0]
.text$mn:00002A2A                 add     ecx, 20h ; ' '  ; this
.text$mn:00002A2D                 call    ?setText@BabyGridWrapper@@QAEXIIPB_W@Z ; BabyGridWrapper::setText(uint,uint,wchar_t const *)
.text$mn:00002A32                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A39                 lea     ecx, [ebp+var_64]
.text$mn:00002A3C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002A41                 jmp     loc_296F
.text$mn:00002A46 ; ---------------------------------------------------------------------------
.text$mn:00002A46
.text$mn:00002A46 loc_2A46:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+77Ej
.text$mn:00002A46                 push    1               ; bEnable
.text$mn:00002A48                 push    0A2Ah           ; nIDDlgItem
.text$mn:00002A4D                 mov     eax, [ebp+var_A0]
.text$mn:00002A53                 mov     ecx, [eax+0Ch]
.text$mn:00002A56                 push    ecx             ; hDlg
.text$mn:00002A57                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002A5D                 push    eax             ; hWnd
.text$mn:00002A5E                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00002A64                 push    0               ; bEnable
.text$mn:00002A66                 push    0A2Bh           ; nIDDlgItem
.text$mn:00002A6B                 mov     edx, [ebp+var_A0]
.text$mn:00002A71                 mov     eax, [edx+0Ch]
.text$mn:00002A74                 push    eax             ; hDlg
.text$mn:00002A75                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00002A7B                 push    eax             ; hWnd
.text$mn:00002A7C                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00002A82
.text$mn:00002A82 loc_2A82:                               ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+1BAj
.text$mn:00002A82                                         ; ShortcutMapper::fillOutBabyGrid(void)+303j ...
.text$mn:00002A82                 mov     ecx, [ebp+var_C] ; jumptable 000023D2 default case
.text$mn:00002A85                 mov     large fs:0, ecx
.text$mn:00002A8C                 pop     ecx
.text$mn:00002A8D                 mov     ecx, [ebp+var_10]
.text$mn:00002A90                 xor     ecx, ebp
.text$mn:00002A92                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002A97                 mov     esp, ebp
.text$mn:00002A99                 pop     ebp
.text$mn:00002A9A                 retn
.text$mn:00002A9A ?fillOutBabyGrid@ShortcutMapper@@AAEXXZ endp
.text$mn:00002A9A
.text$mn:00002A9A ; ---------------------------------------------------------------------------
.text$mn:00002A9B                 align 4
.text$mn:00002A9C $LN44_0         dd offset $LN27         ; DATA XREF: ShortcutMapper::fillOutBabyGrid(void)+76r
.text$mn:00002A9C                 dd offset $LN26_0       ; jump table for switch statement
.text$mn:00002A9C                 dd offset $LN25
.text$mn:00002A9C                 dd offset $LN24
.text$mn:00002A9C                 dd offset $LN23
.text$mn:00002AB0 $LN45_0         dd offset $LN20_0       ; DATA XREF: ShortcutMapper::fillOutBabyGrid(void)+1C6r
.text$mn:00002AB0                 dd offset $LN16         ; jump table for switch statement
.text$mn:00002AB0                 dd offset $LN12
.text$mn:00002AB0                 dd offset $LN8
.text$mn:00002AB0                 dd offset $LN4_3
.text$mn:00002AB0 _text$mn        ends
.text$mn:00002AB0
.text$x:00002AC4 ; ===========================================================================
.text$x:00002AC4
.text$x:00002AC4 ; Segment type: Pure code
.text$x:00002AC4 ; Segment permissions: Read/Execute
.text$x:00002AC4 _text$x         segment para public 'CODE' use32
.text$x:00002AC4                 assume cs:_text$x
.text$x:00002AC4                 ;org 2AC4h
.text$x:00002AC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AC4
.text$x:00002AC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AC4
.text$x:00002AC4
.text$x:00002AC4 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$0 proc near
.text$x:00002AC4                                         ; DATA XREF: .xdata$x:0000DADCo
.text$x:00002AC4                 lea     ecx, [ebp-614h] ; this
.text$x:00002ACA                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00002ACA __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$0 endp
.text$x:00002ACA
.text$x:00002ACF
.text$x:00002ACF ; =============== S U B R O U T I N E =======================================
.text$x:00002ACF
.text$x:00002ACF
.text$x:00002ACF __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$1 proc near
.text$x:00002ACF                                         ; DATA XREF: .xdata$x:0000DAE4o
.text$x:00002ACF                 lea     ecx, [ebp-0DA0h] ; this
.text$x:00002AD5                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00002AD5 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$1 endp
.text$x:00002AD5
.text$x:00002ADA
.text$x:00002ADA ; =============== S U B R O U T I N E =======================================
.text$x:00002ADA
.text$x:00002ADA
.text$x:00002ADA __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$2 proc near
.text$x:00002ADA                                         ; DATA XREF: .xdata$x:0000DAECo
.text$x:00002ADA                 lea     ecx, [ebp-2Ch]
.text$x:00002ADD                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002ADD __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$2 endp
.text$x:00002ADD
.text$x:00002AE2
.text$x:00002AE2 ; =============== S U B R O U T I N E =======================================
.text$x:00002AE2
.text$x:00002AE2
.text$x:00002AE2 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$3 proc near
.text$x:00002AE2                                         ; DATA XREF: .xdata$x:0000DAF4o
.text$x:00002AE2                 lea     ecx, [ebp-4E8h] ; this
.text$x:00002AE8                 jmp     ??1MacroShortcut@@UAE@XZ ; MacroShortcut::~MacroShortcut(void)
.text$x:00002AE8 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$3 endp
.text$x:00002AE8
.text$x:00002AED
.text$x:00002AED ; =============== S U B R O U T I N E =======================================
.text$x:00002AED
.text$x:00002AED
.text$x:00002AED __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$4 proc near
.text$x:00002AED                                         ; DATA XREF: .xdata$x:0000DAFCo
.text$x:00002AED                 lea     ecx, [ebp-1020h] ; this
.text$x:00002AF3                 jmp     ??1MacroShortcut@@UAE@XZ ; MacroShortcut::~MacroShortcut(void)
.text$x:00002AF3 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$4 endp
.text$x:00002AF3
.text$x:00002AF8
.text$x:00002AF8 ; =============== S U B R O U T I N E =======================================
.text$x:00002AF8
.text$x:00002AF8
.text$x:00002AF8 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$5 proc near
.text$x:00002AF8                                         ; DATA XREF: .xdata$x:0000DB04o
.text$x:00002AF8                 lea     ecx, [ebp-48h]
.text$x:00002AFB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002AFB __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$5 endp
.text$x:00002AFB
.text$x:00002B00
.text$x:00002B00 ; =============== S U B R O U T I N E =======================================
.text$x:00002B00
.text$x:00002B00
.text$x:00002B00 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$6 proc near
.text$x:00002B00                                         ; DATA XREF: .xdata$x:0000DB0Co
.text$x:00002B00                 lea     ecx, [ebp-3ACh] ; this
.text$x:00002B06                 jmp     ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$x:00002B06 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$6 endp
.text$x:00002B06
.text$x:00002B0B
.text$x:00002B0B ; =============== S U B R O U T I N E =======================================
.text$x:00002B0B
.text$x:00002B0B
.text$x:00002B0B __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$7 proc near
.text$x:00002B0B                                         ; DATA XREF: .xdata$x:0000DB14o
.text$x:00002B0B                 lea     ecx, [ebp-0B24h] ; this
.text$x:00002B11                 jmp     ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$x:00002B11 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$7 endp
.text$x:00002B11
.text$x:00002B16
.text$x:00002B16 ; =============== S U B R O U T I N E =======================================
.text$x:00002B16
.text$x:00002B16
.text$x:00002B16 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$8 proc near
.text$x:00002B16                                         ; DATA XREF: .xdata$x:0000DB1Co
.text$x:00002B16                 lea     ecx, [ebp-80h]
.text$x:00002B19                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002B19 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$8 endp
.text$x:00002B19
.text$x:00002B1E
.text$x:00002B1E ; =============== S U B R O U T I N E =======================================
.text$x:00002B1E
.text$x:00002B1E
.text$x:00002B1E __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$9 proc near
.text$x:00002B1E                                         ; DATA XREF: .xdata$x:0000DB24o
.text$x:00002B1E                 lea     ecx, [ebp-1ECh] ; this
.text$x:00002B24                 jmp     ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$x:00002B24 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$9 endp
.text$x:00002B24
.text$x:00002B29
.text$x:00002B29 ; =============== S U B R O U T I N E =======================================
.text$x:00002B29
.text$x:00002B29
.text$x:00002B29 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$10 proc near
.text$x:00002B29                                         ; DATA XREF: .xdata$x:0000DB2Co
.text$x:00002B29                 lea     ecx, [ebp-0C74h] ; this
.text$x:00002B2F                 jmp     ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$x:00002B2F __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$10 endp
.text$x:00002B2F
.text$x:00002B34
.text$x:00002B34 ; =============== S U B R O U T I N E =======================================
.text$x:00002B34
.text$x:00002B34
.text$x:00002B34 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$11 proc near
.text$x:00002B34                                         ; DATA XREF: .xdata$x:0000DB34o
.text$x:00002B34                 lea     ecx, [ebp-9Ch]
.text$x:00002B3A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002B3A __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$11 endp
.text$x:00002B3A
.text$x:00002B3F
.text$x:00002B3F ; =============== S U B R O U T I N E =======================================
.text$x:00002B3F
.text$x:00002B3F
.text$x:00002B3F __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$12 proc near
.text$x:00002B3F                                         ; DATA XREF: .xdata$x:0000DB3Co
.text$x:00002B3F                 lea     ecx, [ebp-758h] ; this
.text$x:00002B45                 jmp     ??1ScintillaKeyMap@@UAE@XZ ; ScintillaKeyMap::~ScintillaKeyMap(void)
.text$x:00002B45 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$12 endp
.text$x:00002B45
.text$x:00002B4A
.text$x:00002B4A ; =============== S U B R O U T I N E =======================================
.text$x:00002B4A
.text$x:00002B4A
.text$x:00002B4A __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$13 proc near
.text$x:00002B4A                                         ; DATA XREF: .xdata$x:0000DB44o
.text$x:00002B4A                 lea     ecx, [ebp-0EE4h] ; this
.text$x:00002B50                 jmp     ??1ScintillaKeyMap@@UAE@XZ ; ScintillaKeyMap::~ScintillaKeyMap(void)
.text$x:00002B50 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$13 endp
.text$x:00002B50
.text$x:00002B55
.text$x:00002B55 ; =============== S U B R O U T I N E =======================================
.text$x:00002B55
.text$x:00002B55
.text$x:00002B55 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$14 proc near
.text$x:00002B55                                         ; DATA XREF: .xdata$x:0000DB4Co
.text$x:00002B55                 lea     ecx, [ebp-64h]
.text$x:00002B58                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002B58 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$14 endp
.text$x:00002B58
.text$x:00002B5D
.text$x:00002B5D ; =============== S U B R O U T I N E =======================================
.text$x:00002B5D
.text$x:00002B5D
.text$x:00002B5D __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$15 proc near
.text$x:00002B5D                                         ; DATA XREF: .xdata$x:0000DB54o
.text$x:00002B5D                 lea     ecx, [ebp-1134h]
.text$x:00002B63                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:00002B63 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$15 endp
.text$x:00002B63
.text$x:00002B68
.text$x:00002B68 ; =============== S U B R O U T I N E =======================================
.text$x:00002B68
.text$x:00002B68
.text$x:00002B68 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$16 proc near
.text$x:00002B68                                         ; DATA XREF: .xdata$x:0000DB5Co
.text$x:00002B68                 lea     ecx, [ebp-1140h]
.text$x:00002B6E                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:00002B6E __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$16 endp
.text$x:00002B6E
.text$x:00002B73
.text$x:00002B73 ; =============== S U B R O U T I N E =======================================
.text$x:00002B73
.text$x:00002B73
.text$x:00002B73 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$17 proc near
.text$x:00002B73                                         ; DATA XREF: .xdata$x:0000DB64o
.text$x:00002B73                 mov     ecx, [ebp-1108h]
.text$x:00002B79                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:00002B79 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$17 endp
.text$x:00002B79
.text$x:00002B7E
.text$x:00002B7E ; =============== S U B R O U T I N E =======================================
.text$x:00002B7E
.text$x:00002B7E
.text$x:00002B7E __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$19 proc near
.text$x:00002B7E                                         ; DATA XREF: .xdata$x:0000DB6Co
.text$x:00002B7E                 lea     ecx, [ebp-894h] ; this
.text$x:00002B84                 jmp     ??1MacroShortcut@@UAE@XZ ; MacroShortcut::~MacroShortcut(void)
.text$x:00002B84 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$19 endp
.text$x:00002B84
.text$x:00002B89
.text$x:00002B89 ; =============== S U B R O U T I N E =======================================
.text$x:00002B89
.text$x:00002B89
.text$x:00002B89 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$20 proc near
.text$x:00002B89                                         ; DATA XREF: .xdata$x:0000DB74o
.text$x:00002B89                 lea     ecx, [ebp-1128h]
.text$x:00002B8F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:00002B8F __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$20 endp
.text$x:00002B8F
.text$x:00002B94
.text$x:00002B94 ; =============== S U B R O U T I N E =======================================
.text$x:00002B94
.text$x:00002B94
.text$x:00002B94 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$21 proc near
.text$x:00002B94                                         ; DATA XREF: .xdata$x:0000DB7Co
.text$x:00002B94                 lea     ecx, [ebp-114Ch]
.text$x:00002B9A                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:00002B9A __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$21 endp
.text$x:00002B9A
.text$x:00002B9F
.text$x:00002B9F ; =============== S U B R O U T I N E =======================================
.text$x:00002B9F
.text$x:00002B9F
.text$x:00002B9F __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$22 proc near
.text$x:00002B9F                                         ; DATA XREF: .xdata$x:0000DB84o
.text$x:00002B9F                 mov     ecx, [ebp-111Ch]
.text$x:00002BA5                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:00002BA5 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$22 endp
.text$x:00002BA5
.text$x:00002BAA
.text$x:00002BAA ; =============== S U B R O U T I N E =======================================
.text$x:00002BAA
.text$x:00002BAA
.text$x:00002BAA __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$24 proc near
.text$x:00002BAA                                         ; DATA XREF: .xdata$x:0000DB8Co
.text$x:00002BAA                 lea     ecx, [ebp-9DCh] ; this
.text$x:00002BB0                 jmp     ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$x:00002BB0 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$24 endp
.text$x:00002BB0
.text$x:00002BB5
.text$x:00002BB5 ; =============== S U B R O U T I N E =======================================
.text$x:00002BB5
.text$x:00002BB5
.text$x:00002BB5 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$25 proc near
.text$x:00002BB5                                         ; DATA XREF: .xdata$x:0000DB94o
.text$x:00002BB5                 lea     ecx, [ebp-10FCh]
.text$x:00002BBB                 jmp     ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$x:00002BBB __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$25 endp
.text$x:00002BBB
.text$x:00002BC0
.text$x:00002BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC0
.text$x:00002BC0
.text$x:00002BC0 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$26 proc near
.text$x:00002BC0                                         ; DATA XREF: .xdata$x:0000DB9Co
.text$x:00002BC0                 lea     ecx, [ebp-228h] ; this
.text$x:00002BC6                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00002BC6 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$26 endp
.text$x:00002BC6
.text$x:00002BCB
.text$x:00002BCB ; =============== S U B R O U T I N E =======================================
.text$x:00002BCB
.text$x:00002BCB
.text$x:00002BCB __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$27 proc near
.text$x:00002BCB                                         ; DATA XREF: .xdata$x:0000DBA4o
.text$x:00002BCB                 lea     ecx, [ebp-264h] ; this
.text$x:00002BD1                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00002BD1 __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$27 endp
.text$x:00002BD1
.text$x:00002BD6
.text$x:00002BD6 ; =============== S U B R O U T I N E =======================================
.text$x:00002BD6
.text$x:00002BD6
.text$x:00002BD6 __ehhandler$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z proc near
.text$x:00002BD6                                         ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+5o
.text$x:00002BD6
.text$x:00002BD6 arg_4           = dword ptr  8
.text$x:00002BD6
.text$x:00002BD6                 mov     edx, [esp+arg_4]
.text$x:00002BDA                 lea     eax, [edx+0Ch]
.text$x:00002BDD                 mov     ecx, [edx-115Ch]
.text$x:00002BE3                 xor     ecx, eax
.text$x:00002BE5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BEA                 mov     ecx, [edx-4]
.text$x:00002BED                 xor     ecx, eax
.text$x:00002BEF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BF4                 mov     eax, offset __ehfuncinfo$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z
.text$x:00002BF9                 jmp     ___CxxFrameHandler3
.text$x:00002BF9 __ehhandler$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z endp
.text$x:00002BF9
.text$x:00002BFE
.text$x:00002BFE ; =============== S U B R O U T I N E =======================================
.text$x:00002BFE
.text$x:00002BFE
.text$x:00002BFE __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$0 proc near
.text$x:00002BFE                                         ; DATA XREF: .xdata$x:0000DAB4o
.text$x:00002BFE                 lea     ecx, [ebp-9Ch]
.text$x:00002C04                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C04 __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$0 endp
.text$x:00002C04
.text$x:00002C09
.text$x:00002C09 ; =============== S U B R O U T I N E =======================================
.text$x:00002C09
.text$x:00002C09
.text$x:00002C09 __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$1 proc near
.text$x:00002C09                                         ; DATA XREF: .xdata$x:0000DABCo
.text$x:00002C09                 lea     ecx, [ebp-80h]
.text$x:00002C0C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C0C __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$1 endp
.text$x:00002C0C
.text$x:00002C11
.text$x:00002C11 ; =============== S U B R O U T I N E =======================================
.text$x:00002C11
.text$x:00002C11
.text$x:00002C11 __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$2 proc near
.text$x:00002C11                                         ; DATA XREF: .xdata$x:0000DAC4o
.text$x:00002C11                 lea     ecx, [ebp-48h]
.text$x:00002C14                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C14 __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$2 endp
.text$x:00002C14
.text$x:00002C19
.text$x:00002C19 ; =============== S U B R O U T I N E =======================================
.text$x:00002C19
.text$x:00002C19
.text$x:00002C19 __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$3 proc near
.text$x:00002C19                                         ; DATA XREF: .xdata$x:0000DACCo
.text$x:00002C19                 lea     ecx, [ebp-2Ch]
.text$x:00002C1C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C1C __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$3 endp
.text$x:00002C1C
.text$x:00002C21
.text$x:00002C21 ; =============== S U B R O U T I N E =======================================
.text$x:00002C21
.text$x:00002C21
.text$x:00002C21 __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$4 proc near
.text$x:00002C21                                         ; DATA XREF: .xdata$x:0000DAD4o
.text$x:00002C21                 lea     ecx, [ebp-64h]
.text$x:00002C24                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002C24 __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$4 endp
.text$x:00002C24
.text$x:00002C29
.text$x:00002C29 ; =============== S U B R O U T I N E =======================================
.text$x:00002C29
.text$x:00002C29
.text$x:00002C29 __ehhandler$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ proc near
.text$x:00002C29                                         ; DATA XREF: ShortcutMapper::fillOutBabyGrid(void)+5o
.text$x:00002C29
.text$x:00002C29 arg_4           = dword ptr  8
.text$x:00002C29
.text$x:00002C29                 mov     edx, [esp+arg_4]
.text$x:00002C2D                 lea     eax, [edx+0Ch]
.text$x:00002C30                 mov     ecx, [edx-120h]
.text$x:00002C36                 xor     ecx, eax
.text$x:00002C38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C3D                 mov     ecx, [edx-4]
.text$x:00002C40                 xor     ecx, eax
.text$x:00002C42                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C47                 mov     eax, offset __ehfuncinfo$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ
.text$x:00002C4C                 jmp     ___CxxFrameHandler3
.text$x:00002C4C __ehhandler$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ endp
.text$x:00002C4C
.text$x:00002C4C ; ---------------------------------------------------------------------------
.text$x:00002C51                 align 4
.text$x:00002C51 _text$x         ends
.text$x:00002C51
.text$mn:00002C54 ; ===========================================================================
.text$mn:00002C54
.text$mn:00002C54 ; Segment type: Pure code
.text$mn:00002C54 ; Segment permissions: Read/Execute
.text$mn:00002C54 _text$mn        segment para public 'CODE' use32
.text$mn:00002C54                 assume cs:_text$mn
.text$mn:00002C54                 ;org 2C54h
.text$mn:00002C54 ; COMDAT (pick any)
.text$mn:00002C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C54
.text$mn:00002C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C54
.text$mn:00002C54 ; Attributes: bp-based frame
.text$mn:00002C54
.text$mn:00002C54 ; bool __cdecl std::operator==<struct KeyCombo, struct KeyCombo>(class std::allocator<struct KeyCombo> const &, class std::allocator<struct KeyCombo> const &)
.text$mn:00002C54                 public ??$?8UKeyCombo@@U0@@std@@YA_NABV?$allocator@UKeyCombo@@@0@0@Z
.text$mn:00002C54 ??$?8UKeyCombo@@U0@@std@@YA_NABV?$allocator@UKeyCombo@@@0@0@Z proc near
.text$mn:00002C54                                         ; CODE XREF: std::operator==<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)+1Ep
.text$mn:00002C54                 push    ebp
.text$mn:00002C55                 mov     ebp, esp
.text$mn:00002C57                 mov     al, 1
.text$mn:00002C59                 pop     ebp
.text$mn:00002C5A                 retn
.text$mn:00002C5A ??$?8UKeyCombo@@U0@@std@@YA_NABV?$allocator@UKeyCombo@@@0@0@Z endp
.text$mn:00002C5A
.text$mn:00002C5A ; ---------------------------------------------------------------------------
.text$mn:00002C5B                 align 4
.text$mn:00002C5B _text$mn        ends
.text$mn:00002C5B
.text$mn:00002C5C ; ===========================================================================
.text$mn:00002C5C
.text$mn:00002C5C ; Segment type: Pure code
.text$mn:00002C5C ; Segment permissions: Read/Execute
.text$mn:00002C5C _text$mn        segment para public 'CODE' use32
.text$mn:00002C5C                 assume cs:_text$mn
.text$mn:00002C5C                 ;org 2C5Ch
.text$mn:00002C5C ; COMDAT (pick any)
.text$mn:00002C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C5C
.text$mn:00002C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C5C
.text$mn:00002C5C ; Attributes: bp-based frame
.text$mn:00002C5C
.text$mn:00002C5C ; bool __cdecl std::operator==<struct recordedMacroStep, struct recordedMacroStep>(class std::allocator<struct recordedMacroStep> const &, class std::allocator<struct recordedMacroStep> const &)
.text$mn:00002C5C                 public ??$?8UrecordedMacroStep@@U0@@std@@YA_NABV?$allocator@UrecordedMacroStep@@@0@0@Z
.text$mn:00002C5C ??$?8UrecordedMacroStep@@U0@@std@@YA_NABV?$allocator@UrecordedMacroStep@@@0@0@Z proc near
.text$mn:00002C5C                                         ; CODE XREF: std::operator==<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)+1Ep
.text$mn:00002C5C                 push    ebp
.text$mn:00002C5D                 mov     ebp, esp
.text$mn:00002C5F                 mov     al, 1
.text$mn:00002C61                 pop     ebp
.text$mn:00002C62                 retn
.text$mn:00002C62 ??$?8UrecordedMacroStep@@U0@@std@@YA_NABV?$allocator@UrecordedMacroStep@@@0@0@Z endp
.text$mn:00002C62
.text$mn:00002C62 ; ---------------------------------------------------------------------------
.text$mn:00002C63                 align 4
.text$mn:00002C63 _text$mn        ends
.text$mn:00002C63
.text$mn:00002C64 ; ===========================================================================
.text$mn:00002C64
.text$mn:00002C64 ; Segment type: Pure code
.text$mn:00002C64 ; Segment permissions: Read/Execute
.text$mn:00002C64 _text$mn        segment para public 'CODE' use32
.text$mn:00002C64                 assume cs:_text$mn
.text$mn:00002C64                 ;org 2C64h
.text$mn:00002C64 ; COMDAT (pick any)
.text$mn:00002C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C64
.text$mn:00002C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C64
.text$mn:00002C64 ; Attributes: bp-based frame
.text$mn:00002C64
.text$mn:00002C64 ; bool __cdecl std::operator==<class std::allocator<struct KeyCombo>, class std::allocator<struct KeyCombo>>(struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> const &, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> const &)
.text$mn:00002C64                 public ??$?8V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z
.text$mn:00002C64 ??$?8V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z proc near
.text$mn:00002C64                                         ; CODE XREF: std::operator!=<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)+Cp
.text$mn:00002C64
.text$mn:00002C64 var_2           = byte ptr -2
.text$mn:00002C64 var_1           = byte ptr -1
.text$mn:00002C64 arg_0           = dword ptr  8
.text$mn:00002C64 arg_4           = dword ptr  0Ch
.text$mn:00002C64
.text$mn:00002C64                 push    ebp
.text$mn:00002C65                 mov     ebp, esp
.text$mn:00002C67                 push    ecx
.text$mn:00002C68                 mov     eax, [ebp+arg_4]
.text$mn:00002C6B                 push    eax
.text$mn:00002C6C                 lea     ecx, [ebp+var_1]
.text$mn:00002C6F                 call    ??0?$allocator@UKeyCombo@@@std@@QAE@ABV01@@Z ; std::allocator<KeyCombo>::allocator<KeyCombo>(std::allocator<KeyCombo> const &)
.text$mn:00002C74                 push    eax
.text$mn:00002C75                 mov     ecx, [ebp+arg_0]
.text$mn:00002C78                 push    ecx
.text$mn:00002C79                 lea     ecx, [ebp+var_2]
.text$mn:00002C7C                 call    ??0?$allocator@UKeyCombo@@@std@@QAE@ABV01@@Z ; std::allocator<KeyCombo>::allocator<KeyCombo>(std::allocator<KeyCombo> const &)
.text$mn:00002C81                 push    eax
.text$mn:00002C82                 call    ??$?8UKeyCombo@@U0@@std@@YA_NABV?$allocator@UKeyCombo@@@0@0@Z ; std::operator==<KeyCombo,KeyCombo>(std::allocator<KeyCombo> const &,std::allocator<KeyCombo> const &)
.text$mn:00002C87                 add     esp, 8
.text$mn:00002C8A                 mov     esp, ebp
.text$mn:00002C8C                 pop     ebp
.text$mn:00002C8D                 retn
.text$mn:00002C8D ??$?8V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z endp
.text$mn:00002C8D
.text$mn:00002C8D ; ---------------------------------------------------------------------------
.text$mn:00002C8E                 align 10h
.text$mn:00002C8E _text$mn        ends
.text$mn:00002C8E
.text$mn:00002C90 ; ===========================================================================
.text$mn:00002C90
.text$mn:00002C90 ; Segment type: Pure code
.text$mn:00002C90 ; Segment permissions: Read/Execute
.text$mn:00002C90 _text$mn        segment para public 'CODE' use32
.text$mn:00002C90                 assume cs:_text$mn
.text$mn:00002C90                 ;org 2C90h
.text$mn:00002C90 ; COMDAT (pick any)
.text$mn:00002C90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C90
.text$mn:00002C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C90
.text$mn:00002C90 ; Attributes: bp-based frame
.text$mn:00002C90
.text$mn:00002C90 ; bool __cdecl std::operator==<class std::allocator<struct recordedMacroStep>, class std::allocator<struct recordedMacroStep>>(struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> const &, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> const &)
.text$mn:00002C90                 public ??$?8V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z
.text$mn:00002C90 ??$?8V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z proc near
.text$mn:00002C90                                         ; CODE XREF: std::operator!=<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)+Cp
.text$mn:00002C90
.text$mn:00002C90 var_2           = byte ptr -2
.text$mn:00002C90 var_1           = byte ptr -1
.text$mn:00002C90 arg_0           = dword ptr  8
.text$mn:00002C90 arg_4           = dword ptr  0Ch
.text$mn:00002C90
.text$mn:00002C90                 push    ebp
.text$mn:00002C91                 mov     ebp, esp
.text$mn:00002C93                 push    ecx
.text$mn:00002C94                 mov     eax, [ebp+arg_4]
.text$mn:00002C97                 push    eax
.text$mn:00002C98                 lea     ecx, [ebp+var_1]
.text$mn:00002C9B                 call    ??0?$allocator@UrecordedMacroStep@@@std@@QAE@ABV01@@Z ; std::allocator<recordedMacroStep>::allocator<recordedMacroStep>(std::allocator<recordedMacroStep> const &)
.text$mn:00002CA0                 push    eax
.text$mn:00002CA1                 mov     ecx, [ebp+arg_0]
.text$mn:00002CA4                 push    ecx
.text$mn:00002CA5                 lea     ecx, [ebp+var_2]
.text$mn:00002CA8                 call    ??0?$allocator@UrecordedMacroStep@@@std@@QAE@ABV01@@Z ; std::allocator<recordedMacroStep>::allocator<recordedMacroStep>(std::allocator<recordedMacroStep> const &)
.text$mn:00002CAD                 push    eax
.text$mn:00002CAE                 call    ??$?8UrecordedMacroStep@@U0@@std@@YA_NABV?$allocator@UrecordedMacroStep@@@0@0@Z ; std::operator==<recordedMacroStep,recordedMacroStep>(std::allocator<recordedMacroStep> const &,std::allocator<recordedMacroStep> const &)
.text$mn:00002CB3                 add     esp, 8
.text$mn:00002CB6                 mov     esp, ebp
.text$mn:00002CB8                 pop     ebp
.text$mn:00002CB9                 retn
.text$mn:00002CB9 ??$?8V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z endp
.text$mn:00002CB9
.text$mn:00002CB9 ; ---------------------------------------------------------------------------
.text$mn:00002CBA                 align 4
.text$mn:00002CBA _text$mn        ends
.text$mn:00002CBA
.text$mn:00002CBC ; ===========================================================================
.text$mn:00002CBC
.text$mn:00002CBC ; Segment type: Pure code
.text$mn:00002CBC ; Segment permissions: Read/Execute
.text$mn:00002CBC _text$mn        segment para public 'CODE' use32
.text$mn:00002CBC                 assume cs:_text$mn
.text$mn:00002CBC                 ;org 2CBCh
.text$mn:00002CBC ; COMDAT (pick any)
.text$mn:00002CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CBC
.text$mn:00002CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CBC
.text$mn:00002CBC ; Attributes: bp-based frame
.text$mn:00002CBC
.text$mn:00002CBC ; bool __cdecl std::operator==<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00002CBC                 public ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00002CBC ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00002CBC                                         ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Cp
.text$mn:00002CBC
.text$mn:00002CBC var_2           = byte ptr -2
.text$mn:00002CBC var_1           = byte ptr -1
.text$mn:00002CBC arg_0           = dword ptr  8
.text$mn:00002CBC arg_4           = dword ptr  0Ch
.text$mn:00002CBC
.text$mn:00002CBC                 push    ebp
.text$mn:00002CBD                 mov     ebp, esp
.text$mn:00002CBF                 push    ecx
.text$mn:00002CC0                 mov     eax, [ebp+arg_4]
.text$mn:00002CC3                 push    eax
.text$mn:00002CC4                 lea     ecx, [ebp+var_1]
.text$mn:00002CC7                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00002CCC                 push    eax
.text$mn:00002CCD                 mov     ecx, [ebp+arg_0]
.text$mn:00002CD0                 push    ecx
.text$mn:00002CD1                 lea     ecx, [ebp+var_2]
.text$mn:00002CD4                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00002CD9                 push    eax
.text$mn:00002CDA                 call    ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>(std::allocator<wchar_t> const &,std::allocator<wchar_t> const &)
.text$mn:00002CDF                 add     esp, 8
.text$mn:00002CE2                 mov     esp, ebp
.text$mn:00002CE4                 pop     ebp
.text$mn:00002CE5                 retn
.text$mn:00002CE5 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00002CE5
.text$mn:00002CE5 ; ---------------------------------------------------------------------------
.text$mn:00002CE6                 align 4
.text$mn:00002CE6 _text$mn        ends
.text$mn:00002CE6
.text$mn:00002CE8 ; ===========================================================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Segment type: Pure code
.text$mn:00002CE8 ; Segment permissions: Read/Execute
.text$mn:00002CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CE8                 assume cs:_text$mn
.text$mn:00002CE8                 ;org 2CE8h
.text$mn:00002CE8 ; COMDAT (pick any)
.text$mn:00002CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CE8
.text$mn:00002CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Attributes: bp-based frame
.text$mn:00002CE8
.text$mn:00002CE8 ; bool __cdecl std::operator==<wchar_t, wchar_t>(class std::allocator<wchar_t> const &, class std::allocator<wchar_t> const &)
.text$mn:00002CE8                 public ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
.text$mn:00002CE8 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z proc near
.text$mn:00002CE8                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+1Ep
.text$mn:00002CE8                 push    ebp
.text$mn:00002CE9                 mov     ebp, esp
.text$mn:00002CEB                 mov     al, 1
.text$mn:00002CED                 pop     ebp
.text$mn:00002CEE                 retn
.text$mn:00002CEE ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z endp
.text$mn:00002CEE
.text$mn:00002CEE ; ---------------------------------------------------------------------------
.text$mn:00002CEF                 align 10h
.text$mn:00002CEF _text$mn        ends
.text$mn:00002CEF
.text$mn:00002CF0 ; ===========================================================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Segment type: Pure code
.text$mn:00002CF0 ; Segment permissions: Read/Execute
.text$mn:00002CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CF0                 assume cs:_text$mn
.text$mn:00002CF0                 ;org 2CF0h
.text$mn:00002CF0 ; COMDAT (pick any)
.text$mn:00002CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CF0
.text$mn:00002CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Attributes: bp-based frame
.text$mn:00002CF0
.text$mn:00002CF0 ; bool __cdecl std::operator!=<class std::allocator<struct KeyCombo>, class std::allocator<struct KeyCombo>>(struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> const &, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> const &)
.text$mn:00002CF0                 public ??$?9V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z
.text$mn:00002CF0 ??$?9V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z proc near
.text$mn:00002CF0                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+55p
.text$mn:00002CF0
.text$mn:00002CF0 var_4           = dword ptr -4
.text$mn:00002CF0 arg_0           = dword ptr  8
.text$mn:00002CF0 arg_4           = dword ptr  0Ch
.text$mn:00002CF0
.text$mn:00002CF0                 push    ebp
.text$mn:00002CF1                 mov     ebp, esp
.text$mn:00002CF3                 push    ecx
.text$mn:00002CF4                 mov     eax, [ebp+arg_4]
.text$mn:00002CF7                 push    eax
.text$mn:00002CF8                 mov     ecx, [ebp+arg_0]
.text$mn:00002CFB                 push    ecx
.text$mn:00002CFC                 call    ??$?8V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z ; std::operator==<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)
.text$mn:00002D01                 add     esp, 8
.text$mn:00002D04                 movzx   edx, al
.text$mn:00002D07                 test    edx, edx
.text$mn:00002D09                 jnz     short loc_2D14
.text$mn:00002D0B                 mov     [ebp+var_4], 1
.text$mn:00002D12                 jmp     short loc_2D1B
.text$mn:00002D14 ; ---------------------------------------------------------------------------
.text$mn:00002D14
.text$mn:00002D14 loc_2D14:                               ; CODE XREF: std::operator!=<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)+19j
.text$mn:00002D14                 mov     [ebp+var_4], 0
.text$mn:00002D1B
.text$mn:00002D1B loc_2D1B:                               ; CODE XREF: std::operator!=<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)+22j
.text$mn:00002D1B                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002D1E                 mov     esp, ebp
.text$mn:00002D20                 pop     ebp
.text$mn:00002D21                 retn
.text$mn:00002D21 ??$?9V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z endp
.text$mn:00002D21
.text$mn:00002D21 ; ---------------------------------------------------------------------------
.text$mn:00002D22                 align 4
.text$mn:00002D22 _text$mn        ends
.text$mn:00002D22
.text$mn:00002D24 ; ===========================================================================
.text$mn:00002D24
.text$mn:00002D24 ; Segment type: Pure code
.text$mn:00002D24 ; Segment permissions: Read/Execute
.text$mn:00002D24 _text$mn        segment para public 'CODE' use32
.text$mn:00002D24                 assume cs:_text$mn
.text$mn:00002D24                 ;org 2D24h
.text$mn:00002D24 ; COMDAT (pick any)
.text$mn:00002D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D24
.text$mn:00002D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D24
.text$mn:00002D24 ; Attributes: bp-based frame
.text$mn:00002D24
.text$mn:00002D24 ; bool __cdecl std::operator!=<class std::allocator<struct recordedMacroStep>, class std::allocator<struct recordedMacroStep>>(struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> const &, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> const &)
.text$mn:00002D24                 public ??$?9V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z
.text$mn:00002D24 ??$?9V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z proc near
.text$mn:00002D24                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+55p
.text$mn:00002D24
.text$mn:00002D24 var_4           = dword ptr -4
.text$mn:00002D24 arg_0           = dword ptr  8
.text$mn:00002D24 arg_4           = dword ptr  0Ch
.text$mn:00002D24
.text$mn:00002D24                 push    ebp
.text$mn:00002D25                 mov     ebp, esp
.text$mn:00002D27                 push    ecx
.text$mn:00002D28                 mov     eax, [ebp+arg_4]
.text$mn:00002D2B                 push    eax
.text$mn:00002D2C                 mov     ecx, [ebp+arg_0]
.text$mn:00002D2F                 push    ecx
.text$mn:00002D30                 call    ??$?8V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z ; std::operator==<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)
.text$mn:00002D35                 add     esp, 8
.text$mn:00002D38                 movzx   edx, al
.text$mn:00002D3B                 test    edx, edx
.text$mn:00002D3D                 jnz     short loc_2D48
.text$mn:00002D3F                 mov     [ebp+var_4], 1
.text$mn:00002D46                 jmp     short loc_2D4F
.text$mn:00002D48 ; ---------------------------------------------------------------------------
.text$mn:00002D48
.text$mn:00002D48 loc_2D48:                               ; CODE XREF: std::operator!=<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)+19j
.text$mn:00002D48                 mov     [ebp+var_4], 0
.text$mn:00002D4F
.text$mn:00002D4F loc_2D4F:                               ; CODE XREF: std::operator!=<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)+22j
.text$mn:00002D4F                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002D52                 mov     esp, ebp
.text$mn:00002D54                 pop     ebp
.text$mn:00002D55                 retn
.text$mn:00002D55 ??$?9V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z endp
.text$mn:00002D55
.text$mn:00002D55 ; ---------------------------------------------------------------------------
.text$mn:00002D56                 align 4
.text$mn:00002D56 _text$mn        ends
.text$mn:00002D56
.text$mn:00002D58 ; ===========================================================================
.text$mn:00002D58
.text$mn:00002D58 ; Segment type: Pure code
.text$mn:00002D58 ; Segment permissions: Read/Execute
.text$mn:00002D58 _text$mn        segment para public 'CODE' use32
.text$mn:00002D58                 assume cs:_text$mn
.text$mn:00002D58                 ;org 2D58h
.text$mn:00002D58 ; COMDAT (pick any)
.text$mn:00002D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D58
.text$mn:00002D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D58
.text$mn:00002D58 ; Attributes: bp-based frame
.text$mn:00002D58
.text$mn:00002D58 ; bool __cdecl std::operator!=<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00002D58                 public ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00002D58 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00002D58                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Bp
.text$mn:00002D58
.text$mn:00002D58 var_4           = dword ptr -4
.text$mn:00002D58 arg_0           = dword ptr  8
.text$mn:00002D58 arg_4           = dword ptr  0Ch
.text$mn:00002D58
.text$mn:00002D58                 push    ebp
.text$mn:00002D59                 mov     ebp, esp
.text$mn:00002D5B                 push    ecx
.text$mn:00002D5C                 mov     eax, [ebp+arg_4]
.text$mn:00002D5F                 push    eax
.text$mn:00002D60                 mov     ecx, [ebp+arg_0]
.text$mn:00002D63                 push    ecx
.text$mn:00002D64                 call    ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00002D69                 add     esp, 8
.text$mn:00002D6C                 movzx   edx, al
.text$mn:00002D6F                 test    edx, edx
.text$mn:00002D71                 jnz     short loc_2D7C
.text$mn:00002D73                 mov     [ebp+var_4], 1
.text$mn:00002D7A                 jmp     short loc_2D83
.text$mn:00002D7C ; ---------------------------------------------------------------------------
.text$mn:00002D7C
.text$mn:00002D7C loc_2D7C:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+19j
.text$mn:00002D7C                 mov     [ebp+var_4], 0
.text$mn:00002D83
.text$mn:00002D83 loc_2D83:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+22j
.text$mn:00002D83                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002D86                 mov     esp, ebp
.text$mn:00002D88                 pop     ebp
.text$mn:00002D89                 retn
.text$mn:00002D89 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00002D89
.text$mn:00002D89 ; ---------------------------------------------------------------------------
.text$mn:00002D8A                 align 4
.text$mn:00002D8A _text$mn        ends
.text$mn:00002D8A
.text$mn:00002D8C ; ===========================================================================
.text$mn:00002D8C
.text$mn:00002D8C ; Segment type: Pure code
.text$mn:00002D8C ; Segment permissions: Read/Execute
.text$mn:00002D8C _text$mn        segment para public 'CODE' use32
.text$mn:00002D8C                 assume cs:_text$mn
.text$mn:00002D8C                 ;org 2D8Ch
.text$mn:00002D8C ; COMDAT (pick any)
.text$mn:00002D8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D8C
.text$mn:00002D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D8C
.text$mn:00002D8C ; Attributes: bp-based frame
.text$mn:00002D8C
.text$mn:00002D8C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00002D8C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00002D8C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00002D8C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00002D8C
.text$mn:00002D8C var_4           = dword ptr -4
.text$mn:00002D8C arg_0           = dword ptr  8
.text$mn:00002D8C
.text$mn:00002D8C                 push    ebp
.text$mn:00002D8D                 mov     ebp, esp
.text$mn:00002D8F                 push    ecx
.text$mn:00002D90                 mov     [ebp+var_4], 0
.text$mn:00002D97                 cmp     [ebp+arg_0], 0
.text$mn:00002D9B                 jnz     short loc_2D9F
.text$mn:00002D9D                 jmp     short loc_2DBF
.text$mn:00002D9F ; ---------------------------------------------------------------------------
.text$mn:00002D9F
.text$mn:00002D9F loc_2D9F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00002D9F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00002DA3                 ja      short loc_2DBA
.text$mn:00002DA5                 mov     eax, [ebp+arg_0]
.text$mn:00002DA8                 push    eax             ; unsigned int
.text$mn:00002DA9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002DAE                 add     esp, 4
.text$mn:00002DB1                 mov     [ebp+var_4], eax
.text$mn:00002DB4                 cmp     [ebp+var_4], 0
.text$mn:00002DB8                 jnz     short loc_2DBF
.text$mn:00002DBA
.text$mn:00002DBA loc_2DBA:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00002DBA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002DBF
.text$mn:00002DBF loc_2DBF:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00002DBF                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00002DBF                 mov     eax, [ebp+var_4]
.text$mn:00002DC2                 mov     esp, ebp
.text$mn:00002DC4                 pop     ebp
.text$mn:00002DC5                 retn
.text$mn:00002DC5 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00002DC5
.text$mn:00002DC5 ; ---------------------------------------------------------------------------
.text$mn:00002DC6                 align 4
.text$mn:00002DC6 _text$mn        ends
.text$mn:00002DC6
.text$mn:00002DC8 ; ===========================================================================
.text$mn:00002DC8
.text$mn:00002DC8 ; Segment type: Pure code
.text$mn:00002DC8 ; Segment permissions: Read/Execute
.text$mn:00002DC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DC8                 assume cs:_text$mn
.text$mn:00002DC8                 ;org 2DC8h
.text$mn:00002DC8 ; COMDAT (pick any)
.text$mn:00002DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DC8
.text$mn:00002DC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DC8
.text$mn:00002DC8 ; Attributes: bp-based frame
.text$mn:00002DC8
.text$mn:00002DC8 ; struct KeyCombo * __cdecl std::_Allocate<struct KeyCombo>(unsigned int, struct KeyCombo *)
.text$mn:00002DC8                 public ??$_Allocate@UKeyCombo@@@std@@YAPAUKeyCombo@@IPAU1@@Z
.text$mn:00002DC8 ??$_Allocate@UKeyCombo@@@std@@YAPAUKeyCombo@@IPAU1@@Z proc near
.text$mn:00002DC8                                         ; CODE XREF: std::allocator<KeyCombo>::allocate(uint)+Dp
.text$mn:00002DC8
.text$mn:00002DC8 var_4           = dword ptr -4
.text$mn:00002DC8 arg_0           = dword ptr  8
.text$mn:00002DC8
.text$mn:00002DC8                 push    ebp
.text$mn:00002DC9                 mov     ebp, esp
.text$mn:00002DCB                 push    ecx
.text$mn:00002DCC                 mov     [ebp+var_4], 0
.text$mn:00002DD3                 cmp     [ebp+arg_0], 0
.text$mn:00002DD7                 jnz     short loc_2DDB
.text$mn:00002DD9                 jmp     short loc_2E01
.text$mn:00002DDB ; ---------------------------------------------------------------------------
.text$mn:00002DDB
.text$mn:00002DDB loc_2DDB:                               ; CODE XREF: std::_Allocate<KeyCombo>(uint,KeyCombo *)+Fj
.text$mn:00002DDB                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00002DE2                 ja      short loc_2DFC
.text$mn:00002DE4                 mov     eax, [ebp+arg_0]
.text$mn:00002DE7                 shl     eax, 2
.text$mn:00002DEA                 push    eax             ; unsigned int
.text$mn:00002DEB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002DF0                 add     esp, 4
.text$mn:00002DF3                 mov     [ebp+var_4], eax
.text$mn:00002DF6                 cmp     [ebp+var_4], 0
.text$mn:00002DFA                 jnz     short loc_2E01
.text$mn:00002DFC
.text$mn:00002DFC loc_2DFC:                               ; CODE XREF: std::_Allocate<KeyCombo>(uint,KeyCombo *)+1Aj
.text$mn:00002DFC                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002E01
.text$mn:00002E01 loc_2E01:                               ; CODE XREF: std::_Allocate<KeyCombo>(uint,KeyCombo *)+11j
.text$mn:00002E01                                         ; std::_Allocate<KeyCombo>(uint,KeyCombo *)+32j
.text$mn:00002E01                 mov     eax, [ebp+var_4]
.text$mn:00002E04                 mov     esp, ebp
.text$mn:00002E06                 pop     ebp
.text$mn:00002E07                 retn
.text$mn:00002E07 ??$_Allocate@UKeyCombo@@@std@@YAPAUKeyCombo@@IPAU1@@Z endp
.text$mn:00002E07
.text$mn:00002E07 _text$mn        ends
.text$mn:00002E07
.text$mn:00002E08 ; ===========================================================================
.text$mn:00002E08
.text$mn:00002E08 ; Segment type: Pure code
.text$mn:00002E08 ; Segment permissions: Read/Execute
.text$mn:00002E08 _text$mn        segment para public 'CODE' use32
.text$mn:00002E08                 assume cs:_text$mn
.text$mn:00002E08                 ;org 2E08h
.text$mn:00002E08 ; COMDAT (pick any)
.text$mn:00002E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E08
.text$mn:00002E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E08
.text$mn:00002E08 ; Attributes: bp-based frame
.text$mn:00002E08
.text$mn:00002E08 ; struct MenuItemUnit * __cdecl std::_Allocate<struct MenuItemUnit>(unsigned int, struct MenuItemUnit *)
.text$mn:00002E08                 public ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z
.text$mn:00002E08 ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z proc near
.text$mn:00002E08                                         ; CODE XREF: std::allocator<MenuItemUnit>::allocate(uint)+Dp
.text$mn:00002E08
.text$mn:00002E08 var_4           = dword ptr -4
.text$mn:00002E08 arg_0           = dword ptr  8
.text$mn:00002E08
.text$mn:00002E08                 push    ebp
.text$mn:00002E09                 mov     ebp, esp
.text$mn:00002E0B                 push    ecx
.text$mn:00002E0C                 mov     [ebp+var_4], 0
.text$mn:00002E13                 cmp     [ebp+arg_0], 0
.text$mn:00002E17                 jnz     short loc_2E1B
.text$mn:00002E19                 jmp     short loc_2E3F
.text$mn:00002E1B ; ---------------------------------------------------------------------------
.text$mn:00002E1B
.text$mn:00002E1B loc_2E1B:                               ; CODE XREF: std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+Fj
.text$mn:00002E1B                 cmp     [ebp+arg_0], 4444444h
.text$mn:00002E22                 ja      short loc_2E3A
.text$mn:00002E24                 imul    eax, [ebp+arg_0], 3Ch
.text$mn:00002E28                 push    eax             ; unsigned int
.text$mn:00002E29                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002E2E                 add     esp, 4
.text$mn:00002E31                 mov     [ebp+var_4], eax
.text$mn:00002E34                 cmp     [ebp+var_4], 0
.text$mn:00002E38                 jnz     short loc_2E3F
.text$mn:00002E3A
.text$mn:00002E3A loc_2E3A:                               ; CODE XREF: std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+1Aj
.text$mn:00002E3A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002E3F
.text$mn:00002E3F loc_2E3F:                               ; CODE XREF: std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+11j
.text$mn:00002E3F                                         ; std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+30j
.text$mn:00002E3F                 mov     eax, [ebp+var_4]
.text$mn:00002E42                 mov     esp, ebp
.text$mn:00002E44                 pop     ebp
.text$mn:00002E45                 retn
.text$mn:00002E45 ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z endp
.text$mn:00002E45
.text$mn:00002E45 ; ---------------------------------------------------------------------------
.text$mn:00002E46                 align 4
.text$mn:00002E46 _text$mn        ends
.text$mn:00002E46
.text$mn:00002E48 ; ===========================================================================
.text$mn:00002E48
.text$mn:00002E48 ; Segment type: Pure code
.text$mn:00002E48 ; Segment permissions: Read/Execute
.text$mn:00002E48 _text$mn        segment para public 'CODE' use32
.text$mn:00002E48                 assume cs:_text$mn
.text$mn:00002E48                 ;org 2E48h
.text$mn:00002E48 ; COMDAT (pick any)
.text$mn:00002E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E48
.text$mn:00002E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E48
.text$mn:00002E48 ; Attributes: bp-based frame
.text$mn:00002E48
.text$mn:00002E48 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00002E48                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00002E48 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00002E48                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00002E48
.text$mn:00002E48 var_4           = dword ptr -4
.text$mn:00002E48 arg_0           = dword ptr  8
.text$mn:00002E48
.text$mn:00002E48                 push    ebp
.text$mn:00002E49                 mov     ebp, esp
.text$mn:00002E4B                 push    ecx
.text$mn:00002E4C                 mov     [ebp+var_4], 0
.text$mn:00002E53                 cmp     [ebp+arg_0], 0
.text$mn:00002E57                 jnz     short loc_2E5B
.text$mn:00002E59                 jmp     short loc_2E81
.text$mn:00002E5B ; ---------------------------------------------------------------------------
.text$mn:00002E5B
.text$mn:00002E5B loc_2E5B:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00002E5B                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00002E62                 ja      short loc_2E7C
.text$mn:00002E64                 mov     eax, [ebp+arg_0]
.text$mn:00002E67                 shl     eax, 3
.text$mn:00002E6A                 push    eax             ; unsigned int
.text$mn:00002E6B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002E70                 add     esp, 4
.text$mn:00002E73                 mov     [ebp+var_4], eax
.text$mn:00002E76                 cmp     [ebp+var_4], 0
.text$mn:00002E7A                 jnz     short loc_2E81
.text$mn:00002E7C
.text$mn:00002E7C loc_2E7C:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00002E7C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002E81
.text$mn:00002E81 loc_2E81:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00002E81                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00002E81                 mov     eax, [ebp+var_4]
.text$mn:00002E84                 mov     esp, ebp
.text$mn:00002E86                 pop     ebp
.text$mn:00002E87                 retn
.text$mn:00002E87 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00002E87
.text$mn:00002E87 _text$mn        ends
.text$mn:00002E87
.text$mn:00002E88 ; ===========================================================================
.text$mn:00002E88
.text$mn:00002E88 ; Segment type: Pure code
.text$mn:00002E88 ; Segment permissions: Read/Execute
.text$mn:00002E88 _text$mn        segment para public 'CODE' use32
.text$mn:00002E88                 assume cs:_text$mn
.text$mn:00002E88                 ;org 2E88h
.text$mn:00002E88 ; COMDAT (pick any)
.text$mn:00002E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E88
.text$mn:00002E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E88
.text$mn:00002E88 ; Attributes: bp-based frame
.text$mn:00002E88
.text$mn:00002E88 ; struct recordedMacroStep * __cdecl std::_Allocate<struct recordedMacroStep>(unsigned int, struct recordedMacroStep *)
.text$mn:00002E88                 public ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z
.text$mn:00002E88 ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z proc near
.text$mn:00002E88                                         ; CODE XREF: std::allocator<recordedMacroStep>::allocate(uint)+Dp
.text$mn:00002E88
.text$mn:00002E88 var_4           = dword ptr -4
.text$mn:00002E88 arg_0           = dword ptr  8
.text$mn:00002E88
.text$mn:00002E88                 push    ebp
.text$mn:00002E89                 mov     ebp, esp
.text$mn:00002E8B                 push    ecx
.text$mn:00002E8C                 mov     [ebp+var_4], 0
.text$mn:00002E93                 cmp     [ebp+arg_0], 0
.text$mn:00002E97                 jnz     short loc_2E9B
.text$mn:00002E99                 jmp     short loc_2EBF
.text$mn:00002E9B ; ---------------------------------------------------------------------------
.text$mn:00002E9B
.text$mn:00002E9B loc_2E9B:                               ; CODE XREF: std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+Fj
.text$mn:00002E9B                 cmp     [ebp+arg_0], 5D1745Dh
.text$mn:00002EA2                 ja      short loc_2EBA
.text$mn:00002EA4                 imul    eax, [ebp+arg_0], 2Ch
.text$mn:00002EA8                 push    eax             ; unsigned int
.text$mn:00002EA9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002EAE                 add     esp, 4
.text$mn:00002EB1                 mov     [ebp+var_4], eax
.text$mn:00002EB4                 cmp     [ebp+var_4], 0
.text$mn:00002EB8                 jnz     short loc_2EBF
.text$mn:00002EBA
.text$mn:00002EBA loc_2EBA:                               ; CODE XREF: std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+1Aj
.text$mn:00002EBA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002EBF
.text$mn:00002EBF loc_2EBF:                               ; CODE XREF: std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+11j
.text$mn:00002EBF                                         ; std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+30j
.text$mn:00002EBF                 mov     eax, [ebp+var_4]
.text$mn:00002EC2                 mov     esp, ebp
.text$mn:00002EC4                 pop     ebp
.text$mn:00002EC5                 retn
.text$mn:00002EC5 ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z endp
.text$mn:00002EC5
.text$mn:00002EC5 ; ---------------------------------------------------------------------------
.text$mn:00002EC6                 align 4
.text$mn:00002EC6 _text$mn        ends
.text$mn:00002EC6
.text$mn:00002EC8 ; ===========================================================================
.text$mn:00002EC8
.text$mn:00002EC8 ; Segment type: Pure code
.text$mn:00002EC8 ; Segment permissions: Read/Execute
.text$mn:00002EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EC8                 assume cs:_text$mn
.text$mn:00002EC8                 ;org 2EC8h
.text$mn:00002EC8 ; COMDAT (pick any)
.text$mn:00002EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EC8
.text$mn:00002EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EC8
.text$mn:00002EC8 ; Attributes: bp-based frame
.text$mn:00002EC8
.text$mn:00002EC8 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00002EC8                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00002EC8 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00002EC8                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00002EC8
.text$mn:00002EC8 var_4           = dword ptr -4
.text$mn:00002EC8 arg_0           = dword ptr  8
.text$mn:00002EC8
.text$mn:00002EC8                 push    ebp
.text$mn:00002EC9                 mov     ebp, esp
.text$mn:00002ECB                 push    ecx
.text$mn:00002ECC                 mov     [ebp+var_4], 0
.text$mn:00002ED3                 cmp     [ebp+arg_0], 0
.text$mn:00002ED7                 jnz     short loc_2EDB
.text$mn:00002ED9                 jmp     short loc_2F00
.text$mn:00002EDB ; ---------------------------------------------------------------------------
.text$mn:00002EDB
.text$mn:00002EDB loc_2EDB:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00002EDB                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00002EE2                 ja      short loc_2EFB
.text$mn:00002EE4                 mov     eax, [ebp+arg_0]
.text$mn:00002EE7                 shl     eax, 1
.text$mn:00002EE9                 push    eax             ; unsigned int
.text$mn:00002EEA                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002EEF                 add     esp, 4
.text$mn:00002EF2                 mov     [ebp+var_4], eax
.text$mn:00002EF5                 cmp     [ebp+var_4], 0
.text$mn:00002EF9                 jnz     short loc_2F00
.text$mn:00002EFB
.text$mn:00002EFB loc_2EFB:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00002EFB                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002F00
.text$mn:00002F00 loc_2F00:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00002F00                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00002F00                 mov     eax, [ebp+var_4]
.text$mn:00002F03                 mov     esp, ebp
.text$mn:00002F05                 pop     ebp
.text$mn:00002F06                 retn
.text$mn:00002F06 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00002F06
.text$mn:00002F06 ; ---------------------------------------------------------------------------
.text$mn:00002F07                 align 4
.text$mn:00002F07 _text$mn        ends
.text$mn:00002F07
.text$mn:00002F08 ; ===========================================================================
.text$mn:00002F08
.text$mn:00002F08 ; Segment type: Pure code
.text$mn:00002F08 ; Segment permissions: Read/Execute
.text$mn:00002F08 _text$mn        segment para public 'CODE' use32
.text$mn:00002F08                 assume cs:_text$mn
.text$mn:00002F08                 ;org 2F08h
.text$mn:00002F08 ; COMDAT (pick any)
.text$mn:00002F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F08
.text$mn:00002F08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F08
.text$mn:00002F08 ; Attributes: bp-based frame
.text$mn:00002F08
.text$mn:00002F08 ; struct KeyCombo * __cdecl std::_Copy_impl<struct KeyCombo *, struct KeyCombo *>(struct KeyCombo *, struct KeyCombo *, struct KeyCombo *)
.text$mn:00002F08                 public ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00@Z
.text$mn:00002F08 ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00@Z proc near
.text$mn:00002F08                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+D4p
.text$mn:00002F08                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+14Ap
.text$mn:00002F08
.text$mn:00002F08 var_1           = byte ptr -1
.text$mn:00002F08 arg_0           = dword ptr  8
.text$mn:00002F08 arg_4           = dword ptr  0Ch
.text$mn:00002F08 arg_8           = dword ptr  10h
.text$mn:00002F08
.text$mn:00002F08                 push    ebp
.text$mn:00002F09                 mov     ebp, esp
.text$mn:00002F0B                 push    ecx
.text$mn:00002F0C                 mov     eax, [ebp+arg_8]
.text$mn:00002F0F                 push    eax
.text$mn:00002F10                 mov     ecx, [ebp+arg_0]
.text$mn:00002F13                 push    ecx
.text$mn:00002F14                 call    ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUKeyCombo@@0@Z ; std::_Ptr_cat<KeyCombo,KeyCombo>(KeyCombo *,KeyCombo *)
.text$mn:00002F19                 add     esp, 8
.text$mn:00002F1C                 mov     [ebp+var_1], al
.text$mn:00002F1F                 movzx   edx, [ebp+var_1]
.text$mn:00002F23                 push    edx
.text$mn:00002F24                 mov     eax, [ebp+arg_8]
.text$mn:00002F27                 push    eax
.text$mn:00002F28                 mov     ecx, [ebp+arg_4]
.text$mn:00002F2B                 push    ecx
.text$mn:00002F2C                 mov     edx, [ebp+arg_0]
.text$mn:00002F2F                 push    edx
.text$mn:00002F30                 call    ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002F35                 add     esp, 10h
.text$mn:00002F38                 mov     esp, ebp
.text$mn:00002F3A                 pop     ebp
.text$mn:00002F3B                 retn
.text$mn:00002F3B ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00@Z endp
.text$mn:00002F3B
.text$mn:00002F3B _text$mn        ends
.text$mn:00002F3B
.text$mn:00002F3C ; ===========================================================================
.text$mn:00002F3C
.text$mn:00002F3C ; Segment type: Pure code
.text$mn:00002F3C ; Segment permissions: Read/Execute
.text$mn:00002F3C _text$mn        segment para public 'CODE' use32
.text$mn:00002F3C                 assume cs:_text$mn
.text$mn:00002F3C                 ;org 2F3Ch
.text$mn:00002F3C ; COMDAT (pick any)
.text$mn:00002F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F3C
.text$mn:00002F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F3C
.text$mn:00002F3C ; Attributes: bp-based frame
.text$mn:00002F3C
.text$mn:00002F3C ; struct KeyCombo * __cdecl std::_Copy_impl<struct KeyCombo *, struct KeyCombo *>(struct KeyCombo *, struct KeyCombo *, struct KeyCombo *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002F3C                 public ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002F3C ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002F3C                                         ; CODE XREF: std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)+28p
.text$mn:00002F3C
.text$mn:00002F3C arg_0           = dword ptr  8
.text$mn:00002F3C arg_4           = dword ptr  0Ch
.text$mn:00002F3C arg_8           = dword ptr  10h
.text$mn:00002F3C
.text$mn:00002F3C                 push    ebp
.text$mn:00002F3D                 mov     ebp, esp
.text$mn:00002F3F                 jmp     short loc_2F53
.text$mn:00002F41 ; ---------------------------------------------------------------------------
.text$mn:00002F41
.text$mn:00002F41 loc_2F41:                               ; CODE XREF: std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Nonscalar_ptr_iterator_tag)+29j
.text$mn:00002F41                 mov     eax, [ebp+arg_8]
.text$mn:00002F44                 add     eax, 4
.text$mn:00002F47                 mov     [ebp+arg_8], eax
.text$mn:00002F4A                 mov     ecx, [ebp+arg_0]
.text$mn:00002F4D                 add     ecx, 4
.text$mn:00002F50                 mov     [ebp+arg_0], ecx
.text$mn:00002F53
.text$mn:00002F53 loc_2F53:                               ; CODE XREF: std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00002F53                 mov     edx, [ebp+arg_0]
.text$mn:00002F56                 cmp     edx, [ebp+arg_4]
.text$mn:00002F59                 jz      short loc_2F67
.text$mn:00002F5B                 mov     eax, [ebp+arg_0]
.text$mn:00002F5E                 mov     ecx, [eax]
.text$mn:00002F60                 mov     edx, [ebp+arg_8]
.text$mn:00002F63                 mov     [edx], ecx
.text$mn:00002F65                 jmp     short loc_2F41
.text$mn:00002F67 ; ---------------------------------------------------------------------------
.text$mn:00002F67
.text$mn:00002F67 loc_2F67:                               ; CODE XREF: std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Nonscalar_ptr_iterator_tag)+1Dj
.text$mn:00002F67                 mov     eax, [ebp+arg_8]
.text$mn:00002F6A                 pop     ebp
.text$mn:00002F6B                 retn
.text$mn:00002F6B ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002F6B
.text$mn:00002F6B _text$mn        ends
.text$mn:00002F6B
.text$mn:00002F6C ; ===========================================================================
.text$mn:00002F6C
.text$mn:00002F6C ; Segment type: Pure code
.text$mn:00002F6C ; Segment permissions: Read/Execute
.text$mn:00002F6C _text$mn        segment para public 'CODE' use32
.text$mn:00002F6C                 assume cs:_text$mn
.text$mn:00002F6C                 ;org 2F6Ch
.text$mn:00002F6C ; COMDAT (pick any)
.text$mn:00002F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F6C
.text$mn:00002F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F6C
.text$mn:00002F6C ; Attributes: bp-based frame
.text$mn:00002F6C
.text$mn:00002F6C ; struct recordedMacroStep * __cdecl std::_Copy_impl<struct recordedMacroStep *, struct recordedMacroStep *>(struct recordedMacroStep *, struct recordedMacroStep *, struct recordedMacroStep *)
.text$mn:00002F6C                 public ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00@Z
.text$mn:00002F6C ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00@Z proc near
.text$mn:00002F6C                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+D4p
.text$mn:00002F6C                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+14Ap
.text$mn:00002F6C
.text$mn:00002F6C var_1           = byte ptr -1
.text$mn:00002F6C arg_0           = dword ptr  8
.text$mn:00002F6C arg_4           = dword ptr  0Ch
.text$mn:00002F6C arg_8           = dword ptr  10h
.text$mn:00002F6C
.text$mn:00002F6C                 push    ebp
.text$mn:00002F6D                 mov     ebp, esp
.text$mn:00002F6F                 push    ecx
.text$mn:00002F70                 mov     eax, [ebp+arg_8]
.text$mn:00002F73                 push    eax
.text$mn:00002F74                 mov     ecx, [ebp+arg_0]
.text$mn:00002F77                 push    ecx
.text$mn:00002F78                 call    ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z ; std::_Ptr_cat<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *)
.text$mn:00002F7D                 add     esp, 8
.text$mn:00002F80                 mov     [ebp+var_1], al
.text$mn:00002F83                 movzx   edx, [ebp+var_1]
.text$mn:00002F87                 push    edx
.text$mn:00002F88                 mov     eax, [ebp+arg_8]
.text$mn:00002F8B                 push    eax
.text$mn:00002F8C                 mov     ecx, [ebp+arg_4]
.text$mn:00002F8F                 push    ecx
.text$mn:00002F90                 mov     edx, [ebp+arg_0]
.text$mn:00002F93                 push    edx
.text$mn:00002F94                 call    ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002F99                 add     esp, 10h
.text$mn:00002F9C                 mov     esp, ebp
.text$mn:00002F9E                 pop     ebp
.text$mn:00002F9F                 retn
.text$mn:00002F9F ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00@Z endp
.text$mn:00002F9F
.text$mn:00002F9F _text$mn        ends
.text$mn:00002F9F
.text$mn:00002FA0 ; ===========================================================================
.text$mn:00002FA0
.text$mn:00002FA0 ; Segment type: Pure code
.text$mn:00002FA0 ; Segment permissions: Read/Execute
.text$mn:00002FA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002FA0                 assume cs:_text$mn
.text$mn:00002FA0                 ;org 2FA0h
.text$mn:00002FA0 ; COMDAT (pick any)
.text$mn:00002FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FA0
.text$mn:00002FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FA0
.text$mn:00002FA0 ; Attributes: bp-based frame
.text$mn:00002FA0
.text$mn:00002FA0 ; struct recordedMacroStep * __cdecl std::_Copy_impl<struct recordedMacroStep *, struct recordedMacroStep *>(struct recordedMacroStep *, struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002FA0                 public ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002FA0 ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002FA0                                         ; CODE XREF: std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)+28p
.text$mn:00002FA0
.text$mn:00002FA0 arg_0           = dword ptr  8
.text$mn:00002FA0 arg_4           = dword ptr  0Ch
.text$mn:00002FA0 arg_8           = dword ptr  10h
.text$mn:00002FA0
.text$mn:00002FA0                 push    ebp
.text$mn:00002FA1                 mov     ebp, esp
.text$mn:00002FA3                 jmp     short loc_2FB7
.text$mn:00002FA5 ; ---------------------------------------------------------------------------
.text$mn:00002FA5
.text$mn:00002FA5 loc_2FA5:                               ; CODE XREF: std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+2Bj
.text$mn:00002FA5                 mov     eax, [ebp+arg_8]
.text$mn:00002FA8                 add     eax, 2Ch ; ','
.text$mn:00002FAB                 mov     [ebp+arg_8], eax
.text$mn:00002FAE                 mov     ecx, [ebp+arg_0]
.text$mn:00002FB1                 add     ecx, 2Ch ; ','
.text$mn:00002FB4                 mov     [ebp+arg_0], ecx
.text$mn:00002FB7
.text$mn:00002FB7 loc_2FB7:                               ; CODE XREF: std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00002FB7                 mov     edx, [ebp+arg_0]
.text$mn:00002FBA                 cmp     edx, [ebp+arg_4]
.text$mn:00002FBD                 jz      short loc_2FCD
.text$mn:00002FBF                 mov     eax, [ebp+arg_0]
.text$mn:00002FC2                 push    eax
.text$mn:00002FC3                 mov     ecx, [ebp+arg_8]
.text$mn:00002FC6                 call    ??4recordedMacroStep@@QAEAAU0@ABU0@@Z ; recordedMacroStep::operator=(recordedMacroStep const &)
.text$mn:00002FCB                 jmp     short loc_2FA5
.text$mn:00002FCD ; ---------------------------------------------------------------------------
.text$mn:00002FCD
.text$mn:00002FCD loc_2FCD:                               ; CODE XREF: std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+1Dj
.text$mn:00002FCD                 mov     eax, [ebp+arg_8]
.text$mn:00002FD0                 pop     ebp
.text$mn:00002FD1                 retn
.text$mn:00002FD1 ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002FD1
.text$mn:00002FD1 ; ---------------------------------------------------------------------------
.text$mn:00002FD2                 align 4
.text$mn:00002FD2 _text$mn        ends
.text$mn:00002FD2
.text$mn:00002FD4 ; ===========================================================================
.text$mn:00002FD4
.text$mn:00002FD4 ; Segment type: Pure code
.text$mn:00002FD4 ; Segment permissions: Read/Execute
.text$mn:00002FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00002FD4                 assume cs:_text$mn
.text$mn:00002FD4                 ;org 2FD4h
.text$mn:00002FD4 ; COMDAT (pick any)
.text$mn:00002FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FD4
.text$mn:00002FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD4
.text$mn:00002FD4 ; Attributes: bp-based frame
.text$mn:00002FD4
.text$mn:00002FD4 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00002FD4                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00002FD4 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00002FD4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00002FD4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00002FD4
.text$mn:00002FD4 arg_0           = dword ptr  8
.text$mn:00002FD4 arg_4           = dword ptr  0Ch
.text$mn:00002FD4 arg_8           = dword ptr  10h
.text$mn:00002FD4
.text$mn:00002FD4                 push    ebp
.text$mn:00002FD5                 mov     ebp, esp
.text$mn:00002FD7                 cmp     [ebp+arg_0], 0
.text$mn:00002FDB                 jnz     short loc_2FF2
.text$mn:00002FDD                 mov     eax, [ebp+arg_8]
.text$mn:00002FE0                 push    eax             ; unsigned int
.text$mn:00002FE1                 mov     ecx, [ebp+arg_4]
.text$mn:00002FE4                 push    ecx             ; wchar_t *
.text$mn:00002FE5                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002FEA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002FEF                 add     esp, 0Ch
.text$mn:00002FF2
.text$mn:00002FF2 loc_2FF2:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00002FF2                 pop     ebp
.text$mn:00002FF3                 retn
.text$mn:00002FF3 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00002FF3
.text$mn:00002FF3 _text$mn        ends
.text$mn:00002FF3
.text$mn:00002FF4 ; ===========================================================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Segment type: Pure code
.text$mn:00002FF4 ; Segment permissions: Read/Execute
.text$mn:00002FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00002FF4                 assume cs:_text$mn
.text$mn:00002FF4                 ;org 2FF4h
.text$mn:00002FF4 ; COMDAT (pick any)
.text$mn:00002FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FF4
.text$mn:00002FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Attributes: bp-based frame
.text$mn:00002FF4
.text$mn:00002FF4 ; int __cdecl std::_Debug_pointer<KeyCombo>(int, wchar_t *, unsigned int)
.text$mn:00002FF4                 public ??$_Debug_pointer@UKeyCombo@@@std@@YAXPAUKeyCombo@@PB_WI@Z
.text$mn:00002FF4 ??$_Debug_pointer@UKeyCombo@@@std@@YAXPAUKeyCombo@@PB_WI@Z proc near
.text$mn:00002FF4                                         ; CODE XREF: std::_Debug_range2<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002FF4                                         ; std::_Debug_range2<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00002FF4
.text$mn:00002FF4 arg_0           = dword ptr  8
.text$mn:00002FF4 arg_4           = dword ptr  0Ch
.text$mn:00002FF4 arg_8           = dword ptr  10h
.text$mn:00002FF4
.text$mn:00002FF4                 push    ebp
.text$mn:00002FF5                 mov     ebp, esp
.text$mn:00002FF7                 cmp     [ebp+arg_0], 0
.text$mn:00002FFB                 jnz     short loc_3012
.text$mn:00002FFD                 mov     eax, [ebp+arg_8]
.text$mn:00003000                 push    eax             ; unsigned int
.text$mn:00003001                 mov     ecx, [ebp+arg_4]
.text$mn:00003004                 push    ecx             ; wchar_t *
.text$mn:00003005                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000300A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000300F                 add     esp, 0Ch
.text$mn:00003012
.text$mn:00003012 loc_3012:                               ; CODE XREF: std::_Debug_pointer<KeyCombo>(KeyCombo *,wchar_t const *,uint)+7j
.text$mn:00003012                 pop     ebp
.text$mn:00003013                 retn
.text$mn:00003013 ??$_Debug_pointer@UKeyCombo@@@std@@YAXPAUKeyCombo@@PB_WI@Z endp
.text$mn:00003013
.text$mn:00003013 _text$mn        ends
.text$mn:00003013
.text$mn:00003014 ; ===========================================================================
.text$mn:00003014
.text$mn:00003014 ; Segment type: Pure code
.text$mn:00003014 ; Segment permissions: Read/Execute
.text$mn:00003014 _text$mn        segment para public 'CODE' use32
.text$mn:00003014                 assume cs:_text$mn
.text$mn:00003014                 ;org 3014h
.text$mn:00003014 ; COMDAT (pick any)
.text$mn:00003014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003014
.text$mn:00003014 ; =============== S U B R O U T I N E =======================================
.text$mn:00003014
.text$mn:00003014 ; Attributes: bp-based frame
.text$mn:00003014
.text$mn:00003014 ; int __cdecl std::_Debug_pointer<KeyCombo>(int, wchar_t *, unsigned int)
.text$mn:00003014                 public ??$_Debug_pointer@UKeyCombo@@@std@@YAXPBUKeyCombo@@PB_WI@Z
.text$mn:00003014 ??$_Debug_pointer@UKeyCombo@@@std@@YAXPBUKeyCombo@@PB_WI@Z proc near
.text$mn:00003014                                         ; CODE XREF: std::_Debug_range2<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00003014                                         ; std::_Debug_range2<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:00003014
.text$mn:00003014 arg_0           = dword ptr  8
.text$mn:00003014 arg_4           = dword ptr  0Ch
.text$mn:00003014 arg_8           = dword ptr  10h
.text$mn:00003014
.text$mn:00003014                 push    ebp
.text$mn:00003015                 mov     ebp, esp
.text$mn:00003017                 cmp     [ebp+arg_0], 0
.text$mn:0000301B                 jnz     short loc_3032
.text$mn:0000301D                 mov     eax, [ebp+arg_8]
.text$mn:00003020                 push    eax             ; unsigned int
.text$mn:00003021                 mov     ecx, [ebp+arg_4]
.text$mn:00003024                 push    ecx             ; wchar_t *
.text$mn:00003025                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000302A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000302F                 add     esp, 0Ch
.text$mn:00003032
.text$mn:00003032 loc_3032:                               ; CODE XREF: std::_Debug_pointer<KeyCombo>(KeyCombo const *,wchar_t const *,uint)+7j
.text$mn:00003032                 pop     ebp
.text$mn:00003033                 retn
.text$mn:00003033 ??$_Debug_pointer@UKeyCombo@@@std@@YAXPBUKeyCombo@@PB_WI@Z endp
.text$mn:00003033
.text$mn:00003033 _text$mn        ends
.text$mn:00003033
.text$mn:00003034 ; ===========================================================================
.text$mn:00003034
.text$mn:00003034 ; Segment type: Pure code
.text$mn:00003034 ; Segment permissions: Read/Execute
.text$mn:00003034 _text$mn        segment para public 'CODE' use32
.text$mn:00003034                 assume cs:_text$mn
.text$mn:00003034                 ;org 3034h
.text$mn:00003034 ; COMDAT (pick any)
.text$mn:00003034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003034
.text$mn:00003034 ; =============== S U B R O U T I N E =======================================
.text$mn:00003034
.text$mn:00003034 ; Attributes: bp-based frame
.text$mn:00003034
.text$mn:00003034 ; int __cdecl std::_Debug_pointer<MenuItemUnit>(int, wchar_t *, unsigned int)
.text$mn:00003034                 public ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z
.text$mn:00003034 ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z proc near
.text$mn:00003034                                         ; CODE XREF: std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00003034                                         ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00003034
.text$mn:00003034 arg_0           = dword ptr  8
.text$mn:00003034 arg_4           = dword ptr  0Ch
.text$mn:00003034 arg_8           = dword ptr  10h
.text$mn:00003034
.text$mn:00003034                 push    ebp
.text$mn:00003035                 mov     ebp, esp
.text$mn:00003037                 cmp     [ebp+arg_0], 0
.text$mn:0000303B                 jnz     short loc_3052
.text$mn:0000303D                 mov     eax, [ebp+arg_8]
.text$mn:00003040                 push    eax             ; unsigned int
.text$mn:00003041                 mov     ecx, [ebp+arg_4]
.text$mn:00003044                 push    ecx             ; wchar_t *
.text$mn:00003045                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000304A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000304F                 add     esp, 0Ch
.text$mn:00003052
.text$mn:00003052 loc_3052:                               ; CODE XREF: std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)+7j
.text$mn:00003052                 pop     ebp
.text$mn:00003053                 retn
.text$mn:00003053 ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z endp
.text$mn:00003053
.text$mn:00003053 _text$mn        ends
.text$mn:00003053
.text$mn:00003054 ; ===========================================================================
.text$mn:00003054
.text$mn:00003054 ; Segment type: Pure code
.text$mn:00003054 ; Segment permissions: Read/Execute
.text$mn:00003054 _text$mn        segment para public 'CODE' use32
.text$mn:00003054                 assume cs:_text$mn
.text$mn:00003054                 ;org 3054h
.text$mn:00003054 ; COMDAT (pick any)
.text$mn:00003054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003054
.text$mn:00003054 ; =============== S U B R O U T I N E =======================================
.text$mn:00003054
.text$mn:00003054 ; Attributes: bp-based frame
.text$mn:00003054
.text$mn:00003054 ; int __cdecl std::_Debug_pointer<recordedMacroStep>(int, wchar_t *, unsigned int)
.text$mn:00003054                 public ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z
.text$mn:00003054 ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z proc near
.text$mn:00003054                                         ; CODE XREF: std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00003054                                         ; std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00003054
.text$mn:00003054 arg_0           = dword ptr  8
.text$mn:00003054 arg_4           = dword ptr  0Ch
.text$mn:00003054 arg_8           = dword ptr  10h
.text$mn:00003054
.text$mn:00003054                 push    ebp
.text$mn:00003055                 mov     ebp, esp
.text$mn:00003057                 cmp     [ebp+arg_0], 0
.text$mn:0000305B                 jnz     short loc_3072
.text$mn:0000305D                 mov     eax, [ebp+arg_8]
.text$mn:00003060                 push    eax             ; unsigned int
.text$mn:00003061                 mov     ecx, [ebp+arg_4]
.text$mn:00003064                 push    ecx             ; wchar_t *
.text$mn:00003065                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000306A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000306F                 add     esp, 0Ch
.text$mn:00003072
.text$mn:00003072 loc_3072:                               ; CODE XREF: std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)+7j
.text$mn:00003072                 pop     ebp
.text$mn:00003073                 retn
.text$mn:00003073 ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z endp
.text$mn:00003073
.text$mn:00003073 _text$mn        ends
.text$mn:00003073
.text$mn:00003074 ; ===========================================================================
.text$mn:00003074
.text$mn:00003074 ; Segment type: Pure code
.text$mn:00003074 ; Segment permissions: Read/Execute
.text$mn:00003074 _text$mn        segment para public 'CODE' use32
.text$mn:00003074                 assume cs:_text$mn
.text$mn:00003074                 ;org 3074h
.text$mn:00003074 ; COMDAT (pick any)
.text$mn:00003074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003074
.text$mn:00003074 ; =============== S U B R O U T I N E =======================================
.text$mn:00003074
.text$mn:00003074 ; Attributes: bp-based frame
.text$mn:00003074
.text$mn:00003074 ; int __cdecl std::_Debug_pointer<recordedMacroStep>(int, wchar_t *, unsigned int)
.text$mn:00003074                 public ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@PB_WI@Z
.text$mn:00003074 ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@PB_WI@Z proc near
.text$mn:00003074                                         ; CODE XREF: std::_Debug_range2<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00003074                                         ; std::_Debug_range2<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:00003074
.text$mn:00003074 arg_0           = dword ptr  8
.text$mn:00003074 arg_4           = dword ptr  0Ch
.text$mn:00003074 arg_8           = dword ptr  10h
.text$mn:00003074
.text$mn:00003074                 push    ebp
.text$mn:00003075                 mov     ebp, esp
.text$mn:00003077                 cmp     [ebp+arg_0], 0
.text$mn:0000307B                 jnz     short loc_3092
.text$mn:0000307D                 mov     eax, [ebp+arg_8]
.text$mn:00003080                 push    eax             ; unsigned int
.text$mn:00003081                 mov     ecx, [ebp+arg_4]
.text$mn:00003084                 push    ecx             ; wchar_t *
.text$mn:00003085                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000308A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000308F                 add     esp, 0Ch
.text$mn:00003092
.text$mn:00003092 loc_3092:                               ; CODE XREF: std::_Debug_pointer<recordedMacroStep>(recordedMacroStep const *,wchar_t const *,uint)+7j
.text$mn:00003092                 pop     ebp
.text$mn:00003093                 retn
.text$mn:00003093 ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@PB_WI@Z endp
.text$mn:00003093
.text$mn:00003093 _text$mn        ends
.text$mn:00003093
.text$mn:00003094 ; ===========================================================================
.text$mn:00003094
.text$mn:00003094 ; Segment type: Pure code
.text$mn:00003094 ; Segment permissions: Read/Execute
.text$mn:00003094 _text$mn        segment para public 'CODE' use32
.text$mn:00003094                 assume cs:_text$mn
.text$mn:00003094                 ;org 3094h
.text$mn:00003094 ; COMDAT (pick any)
.text$mn:00003094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003094
.text$mn:00003094 ; =============== S U B R O U T I N E =======================================
.text$mn:00003094
.text$mn:00003094 ; Attributes: bp-based frame
.text$mn:00003094
.text$mn:00003094 ; int __cdecl std::_Debug_range2<KeyCombo *>(int, int, wchar_t *, unsigned int)
.text$mn:00003094                 public ??$_Debug_range2@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003094 ??$_Debug_range2@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003094                                         ; CODE XREF: std::_Debug_range<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint)+2Ap
.text$mn:00003094
.text$mn:00003094 arg_0           = dword ptr  8
.text$mn:00003094 arg_4           = dword ptr  0Ch
.text$mn:00003094 arg_8           = dword ptr  10h
.text$mn:00003094 arg_C           = dword ptr  14h
.text$mn:00003094
.text$mn:00003094                 push    ebp
.text$mn:00003095                 mov     ebp, esp
.text$mn:00003097                 mov     eax, [ebp+arg_0]
.text$mn:0000309A                 cmp     eax, [ebp+arg_4]
.text$mn:0000309D                 jz      short loc_30E4
.text$mn:0000309F                 mov     ecx, [ebp+arg_C]
.text$mn:000030A2                 push    ecx             ; unsigned int
.text$mn:000030A3                 mov     edx, [ebp+arg_8]
.text$mn:000030A6                 push    edx             ; wchar_t *
.text$mn:000030A7                 mov     eax, [ebp+arg_0]
.text$mn:000030AA                 push    eax             ; int
.text$mn:000030AB                 call    ??$_Debug_pointer@UKeyCombo@@@std@@YAXPAUKeyCombo@@PB_WI@Z ; std::_Debug_pointer<KeyCombo>(KeyCombo *,wchar_t const *,uint)
.text$mn:000030B0                 add     esp, 0Ch
.text$mn:000030B3                 mov     ecx, [ebp+arg_C]
.text$mn:000030B6                 push    ecx             ; unsigned int
.text$mn:000030B7                 mov     edx, [ebp+arg_8]
.text$mn:000030BA                 push    edx             ; wchar_t *
.text$mn:000030BB                 mov     eax, [ebp+arg_4]
.text$mn:000030BE                 push    eax             ; int
.text$mn:000030BF                 call    ??$_Debug_pointer@UKeyCombo@@@std@@YAXPAUKeyCombo@@PB_WI@Z ; std::_Debug_pointer<KeyCombo>(KeyCombo *,wchar_t const *,uint)
.text$mn:000030C4                 add     esp, 0Ch
.text$mn:000030C7                 mov     ecx, [ebp+arg_4]
.text$mn:000030CA                 cmp     ecx, [ebp+arg_0]
.text$mn:000030CD                 jnb     short loc_30E4
.text$mn:000030CF                 mov     edx, [ebp+arg_C]
.text$mn:000030D2                 push    edx             ; unsigned int
.text$mn:000030D3                 mov     eax, [ebp+arg_8]
.text$mn:000030D6                 push    eax             ; wchar_t *
.text$mn:000030D7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000030DC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000030E1                 add     esp, 0Ch
.text$mn:000030E4
.text$mn:000030E4 loc_30E4:                               ; CODE XREF: std::_Debug_range2<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000030E4                                         ; std::_Debug_range2<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000030E4                 pop     ebp
.text$mn:000030E5                 retn
.text$mn:000030E5 ??$_Debug_range2@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000030E5
.text$mn:000030E5 ; ---------------------------------------------------------------------------
.text$mn:000030E6                 align 4
.text$mn:000030E6 _text$mn        ends
.text$mn:000030E6
.text$mn:000030E8 ; ===========================================================================
.text$mn:000030E8
.text$mn:000030E8 ; Segment type: Pure code
.text$mn:000030E8 ; Segment permissions: Read/Execute
.text$mn:000030E8 _text$mn        segment para public 'CODE' use32
.text$mn:000030E8                 assume cs:_text$mn
.text$mn:000030E8                 ;org 30E8h
.text$mn:000030E8 ; COMDAT (pick any)
.text$mn:000030E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030E8
.text$mn:000030E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000030E8
.text$mn:000030E8 ; Attributes: bp-based frame
.text$mn:000030E8
.text$mn:000030E8 ; int __cdecl std::_Debug_range2<MenuItemUnit *>(int, int, wchar_t *, unsigned int)
.text$mn:000030E8                 public ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000030E8 ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000030E8                                         ; CODE XREF: std::_Debug_range<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint)+2Ap
.text$mn:000030E8
.text$mn:000030E8 arg_0           = dword ptr  8
.text$mn:000030E8 arg_4           = dword ptr  0Ch
.text$mn:000030E8 arg_8           = dword ptr  10h
.text$mn:000030E8 arg_C           = dword ptr  14h
.text$mn:000030E8
.text$mn:000030E8                 push    ebp
.text$mn:000030E9                 mov     ebp, esp
.text$mn:000030EB                 mov     eax, [ebp+arg_0]
.text$mn:000030EE                 cmp     eax, [ebp+arg_4]
.text$mn:000030F1                 jz      short loc_3138
.text$mn:000030F3                 mov     ecx, [ebp+arg_C]
.text$mn:000030F6                 push    ecx             ; unsigned int
.text$mn:000030F7                 mov     edx, [ebp+arg_8]
.text$mn:000030FA                 push    edx             ; wchar_t *
.text$mn:000030FB                 mov     eax, [ebp+arg_0]
.text$mn:000030FE                 push    eax             ; int
.text$mn:000030FF                 call    ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z ; std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)
.text$mn:00003104                 add     esp, 0Ch
.text$mn:00003107                 mov     ecx, [ebp+arg_C]
.text$mn:0000310A                 push    ecx             ; unsigned int
.text$mn:0000310B                 mov     edx, [ebp+arg_8]
.text$mn:0000310E                 push    edx             ; wchar_t *
.text$mn:0000310F                 mov     eax, [ebp+arg_4]
.text$mn:00003112                 push    eax             ; int
.text$mn:00003113                 call    ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z ; std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)
.text$mn:00003118                 add     esp, 0Ch
.text$mn:0000311B                 mov     ecx, [ebp+arg_4]
.text$mn:0000311E                 cmp     ecx, [ebp+arg_0]
.text$mn:00003121                 jnb     short loc_3138
.text$mn:00003123                 mov     edx, [ebp+arg_C]
.text$mn:00003126                 push    edx             ; unsigned int
.text$mn:00003127                 mov     eax, [ebp+arg_8]
.text$mn:0000312A                 push    eax             ; wchar_t *
.text$mn:0000312B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003130                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003135                 add     esp, 0Ch
.text$mn:00003138
.text$mn:00003138 loc_3138:                               ; CODE XREF: std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00003138                                         ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00003138                 pop     ebp
.text$mn:00003139                 retn
.text$mn:00003139 ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003139
.text$mn:00003139 ; ---------------------------------------------------------------------------
.text$mn:0000313A                 align 4
.text$mn:0000313A _text$mn        ends
.text$mn:0000313A
.text$mn:0000313C ; ===========================================================================
.text$mn:0000313C
.text$mn:0000313C ; Segment type: Pure code
.text$mn:0000313C ; Segment permissions: Read/Execute
.text$mn:0000313C _text$mn        segment para public 'CODE' use32
.text$mn:0000313C                 assume cs:_text$mn
.text$mn:0000313C                 ;org 313Ch
.text$mn:0000313C ; COMDAT (pick any)
.text$mn:0000313C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000313C
.text$mn:0000313C ; =============== S U B R O U T I N E =======================================
.text$mn:0000313C
.text$mn:0000313C ; Attributes: bp-based frame
.text$mn:0000313C
.text$mn:0000313C ; int __cdecl std::_Debug_range2<recordedMacroStep *>(int, int, wchar_t *, unsigned int)
.text$mn:0000313C                 public ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000313C ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:0000313C                                         ; CODE XREF: std::_Debug_range<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint)+2Ap
.text$mn:0000313C
.text$mn:0000313C arg_0           = dword ptr  8
.text$mn:0000313C arg_4           = dword ptr  0Ch
.text$mn:0000313C arg_8           = dword ptr  10h
.text$mn:0000313C arg_C           = dword ptr  14h
.text$mn:0000313C
.text$mn:0000313C                 push    ebp
.text$mn:0000313D                 mov     ebp, esp
.text$mn:0000313F                 mov     eax, [ebp+arg_0]
.text$mn:00003142                 cmp     eax, [ebp+arg_4]
.text$mn:00003145                 jz      short loc_318C
.text$mn:00003147                 mov     ecx, [ebp+arg_C]
.text$mn:0000314A                 push    ecx             ; unsigned int
.text$mn:0000314B                 mov     edx, [ebp+arg_8]
.text$mn:0000314E                 push    edx             ; wchar_t *
.text$mn:0000314F                 mov     eax, [ebp+arg_0]
.text$mn:00003152                 push    eax             ; int
.text$mn:00003153                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)
.text$mn:00003158                 add     esp, 0Ch
.text$mn:0000315B                 mov     ecx, [ebp+arg_C]
.text$mn:0000315E                 push    ecx             ; unsigned int
.text$mn:0000315F                 mov     edx, [ebp+arg_8]
.text$mn:00003162                 push    edx             ; wchar_t *
.text$mn:00003163                 mov     eax, [ebp+arg_4]
.text$mn:00003166                 push    eax             ; int
.text$mn:00003167                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)
.text$mn:0000316C                 add     esp, 0Ch
.text$mn:0000316F                 mov     ecx, [ebp+arg_4]
.text$mn:00003172                 cmp     ecx, [ebp+arg_0]
.text$mn:00003175                 jnb     short loc_318C
.text$mn:00003177                 mov     edx, [ebp+arg_C]
.text$mn:0000317A                 push    edx             ; unsigned int
.text$mn:0000317B                 mov     eax, [ebp+arg_8]
.text$mn:0000317E                 push    eax             ; wchar_t *
.text$mn:0000317F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003184                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003189                 add     esp, 0Ch
.text$mn:0000318C
.text$mn:0000318C loc_318C:                               ; CODE XREF: std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000318C                                         ; std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000318C                 pop     ebp
.text$mn:0000318D                 retn
.text$mn:0000318D ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000318D
.text$mn:0000318D ; ---------------------------------------------------------------------------
.text$mn:0000318E                 align 10h
.text$mn:0000318E _text$mn        ends
.text$mn:0000318E
.text$mn:00003190 ; ===========================================================================
.text$mn:00003190
.text$mn:00003190 ; Segment type: Pure code
.text$mn:00003190 ; Segment permissions: Read/Execute
.text$mn:00003190 _text$mn        segment para public 'CODE' use32
.text$mn:00003190                 assume cs:_text$mn
.text$mn:00003190                 ;org 3190h
.text$mn:00003190 ; COMDAT (pick any)
.text$mn:00003190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003190
.text$mn:00003190 ; =============== S U B R O U T I N E =======================================
.text$mn:00003190
.text$mn:00003190 ; Attributes: bp-based frame
.text$mn:00003190
.text$mn:00003190 ; int __cdecl std::_Debug_range2<KeyCombo const *>(int, int, wchar_t *, unsigned int)
.text$mn:00003190                 public ??$_Debug_range2@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003190 ??$_Debug_range2@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003190                                         ; CODE XREF: std::_Debug_range<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint)+2Ap
.text$mn:00003190
.text$mn:00003190 arg_0           = dword ptr  8
.text$mn:00003190 arg_4           = dword ptr  0Ch
.text$mn:00003190 arg_8           = dword ptr  10h
.text$mn:00003190 arg_C           = dword ptr  14h
.text$mn:00003190
.text$mn:00003190                 push    ebp
.text$mn:00003191                 mov     ebp, esp
.text$mn:00003193                 mov     eax, [ebp+arg_0]
.text$mn:00003196                 cmp     eax, [ebp+arg_4]
.text$mn:00003199                 jz      short loc_31E0
.text$mn:0000319B                 mov     ecx, [ebp+arg_C]
.text$mn:0000319E                 push    ecx             ; unsigned int
.text$mn:0000319F                 mov     edx, [ebp+arg_8]
.text$mn:000031A2                 push    edx             ; wchar_t *
.text$mn:000031A3                 mov     eax, [ebp+arg_0]
.text$mn:000031A6                 push    eax             ; int
.text$mn:000031A7                 call    ??$_Debug_pointer@UKeyCombo@@@std@@YAXPBUKeyCombo@@PB_WI@Z ; std::_Debug_pointer<KeyCombo>(KeyCombo const *,wchar_t const *,uint)
.text$mn:000031AC                 add     esp, 0Ch
.text$mn:000031AF                 mov     ecx, [ebp+arg_C]
.text$mn:000031B2                 push    ecx             ; unsigned int
.text$mn:000031B3                 mov     edx, [ebp+arg_8]
.text$mn:000031B6                 push    edx             ; wchar_t *
.text$mn:000031B7                 mov     eax, [ebp+arg_4]
.text$mn:000031BA                 push    eax             ; int
.text$mn:000031BB                 call    ??$_Debug_pointer@UKeyCombo@@@std@@YAXPBUKeyCombo@@PB_WI@Z ; std::_Debug_pointer<KeyCombo>(KeyCombo const *,wchar_t const *,uint)
.text$mn:000031C0                 add     esp, 0Ch
.text$mn:000031C3                 mov     ecx, [ebp+arg_4]
.text$mn:000031C6                 cmp     ecx, [ebp+arg_0]
.text$mn:000031C9                 jnb     short loc_31E0
.text$mn:000031CB                 mov     edx, [ebp+arg_C]
.text$mn:000031CE                 push    edx             ; unsigned int
.text$mn:000031CF                 mov     eax, [ebp+arg_8]
.text$mn:000031D2                 push    eax             ; wchar_t *
.text$mn:000031D3                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000031D8                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000031DD                 add     esp, 0Ch
.text$mn:000031E0
.text$mn:000031E0 loc_31E0:                               ; CODE XREF: std::_Debug_range2<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000031E0                                         ; std::_Debug_range2<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000031E0                 pop     ebp
.text$mn:000031E1                 retn
.text$mn:000031E1 ??$_Debug_range2@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000031E1
.text$mn:000031E1 ; ---------------------------------------------------------------------------
.text$mn:000031E2                 align 4
.text$mn:000031E2 _text$mn        ends
.text$mn:000031E2
.text$mn:000031E4 ; ===========================================================================
.text$mn:000031E4
.text$mn:000031E4 ; Segment type: Pure code
.text$mn:000031E4 ; Segment permissions: Read/Execute
.text$mn:000031E4 _text$mn        segment para public 'CODE' use32
.text$mn:000031E4                 assume cs:_text$mn
.text$mn:000031E4                 ;org 31E4h
.text$mn:000031E4 ; COMDAT (pick any)
.text$mn:000031E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031E4
.text$mn:000031E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000031E4
.text$mn:000031E4 ; Attributes: bp-based frame
.text$mn:000031E4
.text$mn:000031E4 ; int __cdecl std::_Debug_range2<recordedMacroStep const *>(int, int, wchar_t *, unsigned int)
.text$mn:000031E4                 public ??$_Debug_range2@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000031E4 ??$_Debug_range2@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000031E4                                         ; CODE XREF: std::_Debug_range<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint)+2Ap
.text$mn:000031E4
.text$mn:000031E4 arg_0           = dword ptr  8
.text$mn:000031E4 arg_4           = dword ptr  0Ch
.text$mn:000031E4 arg_8           = dword ptr  10h
.text$mn:000031E4 arg_C           = dword ptr  14h
.text$mn:000031E4
.text$mn:000031E4                 push    ebp
.text$mn:000031E5                 mov     ebp, esp
.text$mn:000031E7                 mov     eax, [ebp+arg_0]
.text$mn:000031EA                 cmp     eax, [ebp+arg_4]
.text$mn:000031ED                 jz      short loc_3234
.text$mn:000031EF                 mov     ecx, [ebp+arg_C]
.text$mn:000031F2                 push    ecx             ; unsigned int
.text$mn:000031F3                 mov     edx, [ebp+arg_8]
.text$mn:000031F6                 push    edx             ; wchar_t *
.text$mn:000031F7                 mov     eax, [ebp+arg_0]
.text$mn:000031FA                 push    eax             ; int
.text$mn:000031FB                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep const *,wchar_t const *,uint)
.text$mn:00003200                 add     esp, 0Ch
.text$mn:00003203                 mov     ecx, [ebp+arg_C]
.text$mn:00003206                 push    ecx             ; unsigned int
.text$mn:00003207                 mov     edx, [ebp+arg_8]
.text$mn:0000320A                 push    edx             ; wchar_t *
.text$mn:0000320B                 mov     eax, [ebp+arg_4]
.text$mn:0000320E                 push    eax             ; int
.text$mn:0000320F                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep const *,wchar_t const *,uint)
.text$mn:00003214                 add     esp, 0Ch
.text$mn:00003217                 mov     ecx, [ebp+arg_4]
.text$mn:0000321A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000321D                 jnb     short loc_3234
.text$mn:0000321F                 mov     edx, [ebp+arg_C]
.text$mn:00003222                 push    edx             ; unsigned int
.text$mn:00003223                 mov     eax, [ebp+arg_8]
.text$mn:00003226                 push    eax             ; wchar_t *
.text$mn:00003227                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:0000322C                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003231                 add     esp, 0Ch
.text$mn:00003234
.text$mn:00003234 loc_3234:                               ; CODE XREF: std::_Debug_range2<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00003234                                         ; std::_Debug_range2<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00003234                 pop     ebp
.text$mn:00003235                 retn
.text$mn:00003235 ??$_Debug_range2@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003235
.text$mn:00003235 ; ---------------------------------------------------------------------------
.text$mn:00003236                 align 4
.text$mn:00003236 _text$mn        ends
.text$mn:00003236
.text$mn:00003238 ; ===========================================================================
.text$mn:00003238
.text$mn:00003238 ; Segment type: Pure code
.text$mn:00003238 ; Segment permissions: Read/Execute
.text$mn:00003238 _text$mn        segment para public 'CODE' use32
.text$mn:00003238                 assume cs:_text$mn
.text$mn:00003238                 ;org 3238h
.text$mn:00003238 ; COMDAT (pick any)
.text$mn:00003238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003238
.text$mn:00003238 ; =============== S U B R O U T I N E =======================================
.text$mn:00003238
.text$mn:00003238 ; Attributes: bp-based frame
.text$mn:00003238
.text$mn:00003238 ; int __cdecl std::_Debug_range<KeyCombo *>(int, int, wchar_t *, unsigned int)
.text$mn:00003238                 public ??$_Debug_range@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WI@Z
.text$mn:00003238 ??$_Debug_range@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WI@Z proc near
.text$mn:00003238                                         ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00003238
.text$mn:00003238 var_1           = byte ptr -1
.text$mn:00003238 arg_0           = dword ptr  8
.text$mn:00003238 arg_4           = dword ptr  0Ch
.text$mn:00003238 arg_8           = dword ptr  10h
.text$mn:00003238 arg_C           = dword ptr  14h
.text$mn:00003238
.text$mn:00003238                 push    ebp
.text$mn:00003239                 mov     ebp, esp
.text$mn:0000323B                 push    ecx
.text$mn:0000323C                 lea     eax, [ebp+arg_0]
.text$mn:0000323F                 push    eax
.text$mn:00003240                 lea     ecx, [ebp+var_1]
.text$mn:00003243                 push    ecx
.text$mn:00003244                 call    ??$_Iter_cat@PAUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKeyCombo@@@Z ; std::_Iter_cat<KeyCombo *>(KeyCombo * const &)
.text$mn:00003249                 add     esp, 8
.text$mn:0000324C                 mov     dl, [eax]
.text$mn:0000324E                 movzx   eax, dl
.text$mn:00003251                 push    eax
.text$mn:00003252                 mov     ecx, [ebp+arg_C]
.text$mn:00003255                 push    ecx             ; unsigned int
.text$mn:00003256                 mov     edx, [ebp+arg_8]
.text$mn:00003259                 push    edx             ; wchar_t *
.text$mn:0000325A                 mov     eax, [ebp+arg_4]
.text$mn:0000325D                 push    eax             ; int
.text$mn:0000325E                 mov     ecx, [ebp+arg_0]
.text$mn:00003261                 push    ecx             ; int
.text$mn:00003262                 call    ??$_Debug_range2@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00003267                 add     esp, 14h
.text$mn:0000326A                 mov     esp, ebp
.text$mn:0000326C                 pop     ebp
.text$mn:0000326D                 retn
.text$mn:0000326D ??$_Debug_range@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WI@Z endp
.text$mn:0000326D
.text$mn:0000326D ; ---------------------------------------------------------------------------
.text$mn:0000326E                 align 10h
.text$mn:0000326E _text$mn        ends
.text$mn:0000326E
.text$mn:00003270 ; ===========================================================================
.text$mn:00003270
.text$mn:00003270 ; Segment type: Pure code
.text$mn:00003270 ; Segment permissions: Read/Execute
.text$mn:00003270 _text$mn        segment para public 'CODE' use32
.text$mn:00003270                 assume cs:_text$mn
.text$mn:00003270                 ;org 3270h
.text$mn:00003270 ; COMDAT (pick any)
.text$mn:00003270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003270
.text$mn:00003270 ; =============== S U B R O U T I N E =======================================
.text$mn:00003270
.text$mn:00003270 ; Attributes: bp-based frame
.text$mn:00003270
.text$mn:00003270 ; int __cdecl std::_Debug_range<MenuItemUnit *>(int, int, wchar_t *, unsigned int)
.text$mn:00003270                 public ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z
.text$mn:00003270 ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z proc near
.text$mn:00003270                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00003270
.text$mn:00003270 var_1           = byte ptr -1
.text$mn:00003270 arg_0           = dword ptr  8
.text$mn:00003270 arg_4           = dword ptr  0Ch
.text$mn:00003270 arg_8           = dword ptr  10h
.text$mn:00003270 arg_C           = dword ptr  14h
.text$mn:00003270
.text$mn:00003270                 push    ebp
.text$mn:00003271                 mov     ebp, esp
.text$mn:00003273                 push    ecx
.text$mn:00003274                 lea     eax, [ebp+arg_0]
.text$mn:00003277                 push    eax
.text$mn:00003278                 lea     ecx, [ebp+var_1]
.text$mn:0000327B                 push    ecx
.text$mn:0000327C                 call    ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z ; std::_Iter_cat<MenuItemUnit *>(MenuItemUnit * const &)
.text$mn:00003281                 add     esp, 8
.text$mn:00003284                 mov     dl, [eax]
.text$mn:00003286                 movzx   eax, dl
.text$mn:00003289                 push    eax
.text$mn:0000328A                 mov     ecx, [ebp+arg_C]
.text$mn:0000328D                 push    ecx             ; unsigned int
.text$mn:0000328E                 mov     edx, [ebp+arg_8]
.text$mn:00003291                 push    edx             ; wchar_t *
.text$mn:00003292                 mov     eax, [ebp+arg_4]
.text$mn:00003295                 push    eax             ; int
.text$mn:00003296                 mov     ecx, [ebp+arg_0]
.text$mn:00003299                 push    ecx             ; int
.text$mn:0000329A                 call    ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000329F                 add     esp, 14h
.text$mn:000032A2                 mov     esp, ebp
.text$mn:000032A4                 pop     ebp
.text$mn:000032A5                 retn
.text$mn:000032A5 ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z endp
.text$mn:000032A5
.text$mn:000032A5 ; ---------------------------------------------------------------------------
.text$mn:000032A6                 align 4
.text$mn:000032A6 _text$mn        ends
.text$mn:000032A6
.text$mn:000032A8 ; ===========================================================================
.text$mn:000032A8
.text$mn:000032A8 ; Segment type: Pure code
.text$mn:000032A8 ; Segment permissions: Read/Execute
.text$mn:000032A8 _text$mn        segment para public 'CODE' use32
.text$mn:000032A8                 assume cs:_text$mn
.text$mn:000032A8                 ;org 32A8h
.text$mn:000032A8 ; COMDAT (pick any)
.text$mn:000032A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032A8
.text$mn:000032A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032A8
.text$mn:000032A8 ; Attributes: bp-based frame
.text$mn:000032A8
.text$mn:000032A8 ; int __cdecl std::_Debug_range<recordedMacroStep *>(int, int, wchar_t *, unsigned int)
.text$mn:000032A8                 public ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z
.text$mn:000032A8 ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z proc near
.text$mn:000032A8                                         ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000032A8
.text$mn:000032A8 var_1           = byte ptr -1
.text$mn:000032A8 arg_0           = dword ptr  8
.text$mn:000032A8 arg_4           = dword ptr  0Ch
.text$mn:000032A8 arg_8           = dword ptr  10h
.text$mn:000032A8 arg_C           = dword ptr  14h
.text$mn:000032A8
.text$mn:000032A8                 push    ebp
.text$mn:000032A9                 mov     ebp, esp
.text$mn:000032AB                 push    ecx
.text$mn:000032AC                 lea     eax, [ebp+arg_0]
.text$mn:000032AF                 push    eax
.text$mn:000032B0                 lea     ecx, [ebp+var_1]
.text$mn:000032B3                 push    ecx
.text$mn:000032B4                 call    ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z ; std::_Iter_cat<recordedMacroStep *>(recordedMacroStep * const &)
.text$mn:000032B9                 add     esp, 8
.text$mn:000032BC                 mov     dl, [eax]
.text$mn:000032BE                 movzx   eax, dl
.text$mn:000032C1                 push    eax
.text$mn:000032C2                 mov     ecx, [ebp+arg_C]
.text$mn:000032C5                 push    ecx             ; unsigned int
.text$mn:000032C6                 mov     edx, [ebp+arg_8]
.text$mn:000032C9                 push    edx             ; wchar_t *
.text$mn:000032CA                 mov     eax, [ebp+arg_4]
.text$mn:000032CD                 push    eax             ; int
.text$mn:000032CE                 mov     ecx, [ebp+arg_0]
.text$mn:000032D1                 push    ecx             ; int
.text$mn:000032D2                 call    ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000032D7                 add     esp, 14h
.text$mn:000032DA                 mov     esp, ebp
.text$mn:000032DC                 pop     ebp
.text$mn:000032DD                 retn
.text$mn:000032DD ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z endp
.text$mn:000032DD
.text$mn:000032DD ; ---------------------------------------------------------------------------
.text$mn:000032DE                 align 10h
.text$mn:000032DE _text$mn        ends
.text$mn:000032DE
.text$mn:000032E0 ; ===========================================================================
.text$mn:000032E0
.text$mn:000032E0 ; Segment type: Pure code
.text$mn:000032E0 ; Segment permissions: Read/Execute
.text$mn:000032E0 _text$mn        segment para public 'CODE' use32
.text$mn:000032E0                 assume cs:_text$mn
.text$mn:000032E0                 ;org 32E0h
.text$mn:000032E0 ; COMDAT (pick any)
.text$mn:000032E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032E0
.text$mn:000032E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000032E0
.text$mn:000032E0 ; Attributes: bp-based frame
.text$mn:000032E0
.text$mn:000032E0 ; int __cdecl std::_Debug_range<KeyCombo const *>(int, int, wchar_t *, unsigned int)
.text$mn:000032E0                 public ??$_Debug_range@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WI@Z
.text$mn:000032E0 ??$_Debug_range@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WI@Z proc near
.text$mn:000032E0                                         ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000032E0
.text$mn:000032E0 var_1           = byte ptr -1
.text$mn:000032E0 arg_0           = dword ptr  8
.text$mn:000032E0 arg_4           = dword ptr  0Ch
.text$mn:000032E0 arg_8           = dword ptr  10h
.text$mn:000032E0 arg_C           = dword ptr  14h
.text$mn:000032E0
.text$mn:000032E0                 push    ebp
.text$mn:000032E1                 mov     ebp, esp
.text$mn:000032E3                 push    ecx
.text$mn:000032E4                 lea     eax, [ebp+arg_0]
.text$mn:000032E7                 push    eax
.text$mn:000032E8                 lea     ecx, [ebp+var_1]
.text$mn:000032EB                 push    ecx
.text$mn:000032EC                 call    ??$_Iter_cat@PBUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUKeyCombo@@@Z ; std::_Iter_cat<KeyCombo const *>(KeyCombo const * const &)
.text$mn:000032F1                 add     esp, 8
.text$mn:000032F4                 mov     dl, [eax]
.text$mn:000032F6                 movzx   eax, dl
.text$mn:000032F9                 push    eax
.text$mn:000032FA                 mov     ecx, [ebp+arg_C]
.text$mn:000032FD                 push    ecx             ; unsigned int
.text$mn:000032FE                 mov     edx, [ebp+arg_8]
.text$mn:00003301                 push    edx             ; wchar_t *
.text$mn:00003302                 mov     eax, [ebp+arg_4]
.text$mn:00003305                 push    eax             ; int
.text$mn:00003306                 mov     ecx, [ebp+arg_0]
.text$mn:00003309                 push    ecx             ; int
.text$mn:0000330A                 call    ??$_Debug_range2@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000330F                 add     esp, 14h
.text$mn:00003312                 mov     esp, ebp
.text$mn:00003314                 pop     ebp
.text$mn:00003315                 retn
.text$mn:00003315 ??$_Debug_range@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WI@Z endp
.text$mn:00003315
.text$mn:00003315 ; ---------------------------------------------------------------------------
.text$mn:00003316                 align 4
.text$mn:00003316 _text$mn        ends
.text$mn:00003316
.text$mn:00003318 ; ===========================================================================
.text$mn:00003318
.text$mn:00003318 ; Segment type: Pure code
.text$mn:00003318 ; Segment permissions: Read/Execute
.text$mn:00003318 _text$mn        segment para public 'CODE' use32
.text$mn:00003318                 assume cs:_text$mn
.text$mn:00003318                 ;org 3318h
.text$mn:00003318 ; COMDAT (pick any)
.text$mn:00003318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003318
.text$mn:00003318 ; =============== S U B R O U T I N E =======================================
.text$mn:00003318
.text$mn:00003318 ; Attributes: bp-based frame
.text$mn:00003318
.text$mn:00003318 ; int __cdecl std::_Debug_range<recordedMacroStep const *>(int, int, wchar_t *, unsigned int)
.text$mn:00003318                 public ??$_Debug_range@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WI@Z
.text$mn:00003318 ??$_Debug_range@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WI@Z proc near
.text$mn:00003318                                         ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00003318
.text$mn:00003318 var_1           = byte ptr -1
.text$mn:00003318 arg_0           = dword ptr  8
.text$mn:00003318 arg_4           = dword ptr  0Ch
.text$mn:00003318 arg_8           = dword ptr  10h
.text$mn:00003318 arg_C           = dword ptr  14h
.text$mn:00003318
.text$mn:00003318                 push    ebp
.text$mn:00003319                 mov     ebp, esp
.text$mn:0000331B                 push    ecx
.text$mn:0000331C                 lea     eax, [ebp+arg_0]
.text$mn:0000331F                 push    eax
.text$mn:00003320                 lea     ecx, [ebp+var_1]
.text$mn:00003323                 push    ecx
.text$mn:00003324                 call    ??$_Iter_cat@PBUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUrecordedMacroStep@@@Z ; std::_Iter_cat<recordedMacroStep const *>(recordedMacroStep const * const &)
.text$mn:00003329                 add     esp, 8
.text$mn:0000332C                 mov     dl, [eax]
.text$mn:0000332E                 movzx   eax, dl
.text$mn:00003331                 push    eax
.text$mn:00003332                 mov     ecx, [ebp+arg_C]
.text$mn:00003335                 push    ecx             ; unsigned int
.text$mn:00003336                 mov     edx, [ebp+arg_8]
.text$mn:00003339                 push    edx             ; wchar_t *
.text$mn:0000333A                 mov     eax, [ebp+arg_4]
.text$mn:0000333D                 push    eax             ; int
.text$mn:0000333E                 mov     ecx, [ebp+arg_0]
.text$mn:00003341                 push    ecx             ; int
.text$mn:00003342                 call    ??$_Debug_range2@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00003347                 add     esp, 14h
.text$mn:0000334A                 mov     esp, ebp
.text$mn:0000334C                 pop     ebp
.text$mn:0000334D                 retn
.text$mn:0000334D ??$_Debug_range@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WI@Z endp
.text$mn:0000334D
.text$mn:0000334D ; ---------------------------------------------------------------------------
.text$mn:0000334E                 align 10h
.text$mn:0000334E _text$mn        ends
.text$mn:0000334E
.text$mn:00003350 ; ===========================================================================
.text$mn:00003350
.text$mn:00003350 ; Segment type: Pure code
.text$mn:00003350 ; Segment permissions: Read/Execute
.text$mn:00003350 _text$mn        segment para public 'CODE' use32
.text$mn:00003350                 assume cs:_text$mn
.text$mn:00003350                 ;org 3350h
.text$mn:00003350 ; COMDAT (pick any)
.text$mn:00003350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003350
.text$mn:00003350 ; =============== S U B R O U T I N E =======================================
.text$mn:00003350
.text$mn:00003350 ; Attributes: bp-based frame
.text$mn:00003350
.text$mn:00003350 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>>>(struct KeyCombo *, struct KeyCombo *, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> &)
.text$mn:00003350                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.text$mn:00003350 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z proc near
.text$mn:00003350                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Destroy(KeyCombo *,KeyCombo *)+21p
.text$mn:00003350
.text$mn:00003350 var_1           = byte ptr -1
.text$mn:00003350 arg_0           = dword ptr  8
.text$mn:00003350 arg_4           = dword ptr  0Ch
.text$mn:00003350 arg_8           = dword ptr  10h
.text$mn:00003350
.text$mn:00003350                 push    ebp
.text$mn:00003351                 mov     ebp, esp
.text$mn:00003353                 push    ecx
.text$mn:00003354                 mov     eax, [ebp+arg_4]
.text$mn:00003357                 push    eax
.text$mn:00003358                 mov     ecx, [ebp+arg_0]
.text$mn:0000335B                 push    ecx
.text$mn:0000335C                 call    ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUKeyCombo@@0@Z ; std::_Ptr_cat<KeyCombo,KeyCombo>(KeyCombo *,KeyCombo *)
.text$mn:00003361                 add     esp, 8
.text$mn:00003364                 mov     [ebp+var_1], al
.text$mn:00003367                 movzx   edx, [ebp+var_1]
.text$mn:0000336B                 push    edx
.text$mn:0000336C                 mov     eax, [ebp+arg_8]
.text$mn:0000336F                 push    eax
.text$mn:00003370                 mov     ecx, [ebp+arg_4]
.text$mn:00003373                 push    ecx
.text$mn:00003374                 mov     edx, [ebp+arg_0]
.text$mn:00003377                 push    edx
.text$mn:00003378                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000337D                 add     esp, 10h
.text$mn:00003380                 mov     esp, ebp
.text$mn:00003382                 pop     ebp
.text$mn:00003383                 retn
.text$mn:00003383 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z endp
.text$mn:00003383
.text$mn:00003383 _text$mn        ends
.text$mn:00003383
.text$mn:00003384 ; ===========================================================================
.text$mn:00003384
.text$mn:00003384 ; Segment type: Pure code
.text$mn:00003384 ; Segment permissions: Read/Execute
.text$mn:00003384 _text$mn        segment para public 'CODE' use32
.text$mn:00003384                 assume cs:_text$mn
.text$mn:00003384                 ;org 3384h
.text$mn:00003384 ; COMDAT (pick any)
.text$mn:00003384                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003384
.text$mn:00003384 ; =============== S U B R O U T I N E =======================================
.text$mn:00003384
.text$mn:00003384 ; Attributes: bp-based frame
.text$mn:00003384
.text$mn:00003384 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>>>(struct KeyCombo *, struct KeyCombo *, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003384                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003384 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003384                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+28p
.text$mn:00003384
.text$mn:00003384 arg_0           = dword ptr  8
.text$mn:00003384 arg_4           = dword ptr  0Ch
.text$mn:00003384 arg_8           = dword ptr  10h
.text$mn:00003384
.text$mn:00003384                 push    ebp
.text$mn:00003385                 mov     ebp, esp
.text$mn:00003387                 jmp     short loc_3392
.text$mn:00003389 ; ---------------------------------------------------------------------------
.text$mn:00003389
.text$mn:00003389 loc_3389:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00003389                 mov     eax, [ebp+arg_0]
.text$mn:0000338C                 add     eax, 4
.text$mn:0000338F                 mov     [ebp+arg_0], eax
.text$mn:00003392
.text$mn:00003392 loc_3392:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00003392                 mov     ecx, [ebp+arg_0]
.text$mn:00003395                 cmp     ecx, [ebp+arg_4]
.text$mn:00003398                 jz      short loc_33A8
.text$mn:0000339A                 mov     edx, [ebp+arg_0]
.text$mn:0000339D                 push    edx
.text$mn:0000339E                 mov     ecx, [ebp+arg_8]
.text$mn:000033A1                 call    ??$destroy@UKeyCombo@@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::destroy<KeyCombo>(KeyCombo *)
.text$mn:000033A6                 jmp     short loc_3389
.text$mn:000033A8 ; ---------------------------------------------------------------------------
.text$mn:000033A8
.text$mn:000033A8 loc_33A8:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:000033A8                 pop     ebp
.text$mn:000033A9                 retn
.text$mn:000033A9 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000033A9
.text$mn:000033A9 ; ---------------------------------------------------------------------------
.text$mn:000033AA                 align 4
.text$mn:000033AA _text$mn        ends
.text$mn:000033AA
.text$mn:000033AC ; ===========================================================================
.text$mn:000033AC
.text$mn:000033AC ; Segment type: Pure code
.text$mn:000033AC ; Segment permissions: Read/Execute
.text$mn:000033AC _text$mn        segment para public 'CODE' use32
.text$mn:000033AC                 assume cs:_text$mn
.text$mn:000033AC                 ;org 33ACh
.text$mn:000033AC ; COMDAT (pick any)
.text$mn:000033AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033AC
.text$mn:000033AC ; =============== S U B R O U T I N E =======================================
.text$mn:000033AC
.text$mn:000033AC ; Attributes: bp-based frame
.text$mn:000033AC
.text$mn:000033AC ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>>(struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> &)
.text$mn:000033AC                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z
.text$mn:000033AC ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z proc near
.text$mn:000033AC                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)+21p
.text$mn:000033AC
.text$mn:000033AC var_1           = byte ptr -1
.text$mn:000033AC arg_0           = dword ptr  8
.text$mn:000033AC arg_4           = dword ptr  0Ch
.text$mn:000033AC arg_8           = dword ptr  10h
.text$mn:000033AC
.text$mn:000033AC                 push    ebp
.text$mn:000033AD                 mov     ebp, esp
.text$mn:000033AF                 push    ecx
.text$mn:000033B0                 mov     eax, [ebp+arg_4]
.text$mn:000033B3                 push    eax
.text$mn:000033B4                 mov     ecx, [ebp+arg_0]
.text$mn:000033B7                 push    ecx
.text$mn:000033B8                 call    ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z ; std::_Ptr_cat<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *)
.text$mn:000033BD                 add     esp, 8
.text$mn:000033C0                 mov     [ebp+var_1], al
.text$mn:000033C3                 movzx   edx, [ebp+var_1]
.text$mn:000033C7                 push    edx
.text$mn:000033C8                 mov     eax, [ebp+arg_8]
.text$mn:000033CB                 push    eax
.text$mn:000033CC                 mov     ecx, [ebp+arg_4]
.text$mn:000033CF                 push    ecx
.text$mn:000033D0                 mov     edx, [ebp+arg_0]
.text$mn:000033D3                 push    edx
.text$mn:000033D4                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000033D9                 add     esp, 10h
.text$mn:000033DC                 mov     esp, ebp
.text$mn:000033DE                 pop     ebp
.text$mn:000033DF                 retn
.text$mn:000033DF ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z endp
.text$mn:000033DF
.text$mn:000033DF _text$mn        ends
.text$mn:000033DF
.text$mn:000033E0 ; ===========================================================================
.text$mn:000033E0
.text$mn:000033E0 ; Segment type: Pure code
.text$mn:000033E0 ; Segment permissions: Read/Execute
.text$mn:000033E0 _text$mn        segment para public 'CODE' use32
.text$mn:000033E0                 assume cs:_text$mn
.text$mn:000033E0                 ;org 33E0h
.text$mn:000033E0 ; COMDAT (pick any)
.text$mn:000033E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033E0
.text$mn:000033E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033E0
.text$mn:000033E0 ; Attributes: bp-based frame
.text$mn:000033E0
.text$mn:000033E0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>>(struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:000033E0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000033E0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000033E0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+28p
.text$mn:000033E0
.text$mn:000033E0 arg_0           = dword ptr  8
.text$mn:000033E0 arg_4           = dword ptr  0Ch
.text$mn:000033E0 arg_8           = dword ptr  10h
.text$mn:000033E0
.text$mn:000033E0                 push    ebp
.text$mn:000033E1                 mov     ebp, esp
.text$mn:000033E3                 jmp     short loc_33EE
.text$mn:000033E5 ; ---------------------------------------------------------------------------
.text$mn:000033E5
.text$mn:000033E5 loc_33E5:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:000033E5                 mov     eax, [ebp+arg_0]
.text$mn:000033E8                 add     eax, 3Ch ; '<'
.text$mn:000033EB                 mov     [ebp+arg_0], eax
.text$mn:000033EE
.text$mn:000033EE loc_33EE:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:000033EE                 mov     ecx, [ebp+arg_0]
.text$mn:000033F1                 cmp     ecx, [ebp+arg_4]
.text$mn:000033F4                 jz      short loc_3404
.text$mn:000033F6                 mov     edx, [ebp+arg_0]
.text$mn:000033F9                 push    edx
.text$mn:000033FA                 mov     ecx, [ebp+arg_8]
.text$mn:000033FD                 call    ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(MenuItemUnit *)
.text$mn:00003402                 jmp     short loc_33E5
.text$mn:00003404 ; ---------------------------------------------------------------------------
.text$mn:00003404
.text$mn:00003404 loc_3404:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00003404                 pop     ebp
.text$mn:00003405                 retn
.text$mn:00003405 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003405
.text$mn:00003405 ; ---------------------------------------------------------------------------
.text$mn:00003406                 align 4
.text$mn:00003406 _text$mn        ends
.text$mn:00003406
.text$mn:00003408 ; ===========================================================================
.text$mn:00003408
.text$mn:00003408 ; Segment type: Pure code
.text$mn:00003408 ; Segment permissions: Read/Execute
.text$mn:00003408 _text$mn        segment para public 'CODE' use32
.text$mn:00003408                 assume cs:_text$mn
.text$mn:00003408                 ;org 3408h
.text$mn:00003408 ; COMDAT (pick any)
.text$mn:00003408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003408
.text$mn:00003408 ; =============== S U B R O U T I N E =======================================
.text$mn:00003408
.text$mn:00003408 ; Attributes: bp-based frame
.text$mn:00003408
.text$mn:00003408 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>>(struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> &)
.text$mn:00003408                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:00003408 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:00003408                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)+21p
.text$mn:00003408
.text$mn:00003408 var_1           = byte ptr -1
.text$mn:00003408 arg_0           = dword ptr  8
.text$mn:00003408 arg_4           = dword ptr  0Ch
.text$mn:00003408 arg_8           = dword ptr  10h
.text$mn:00003408
.text$mn:00003408                 push    ebp
.text$mn:00003409                 mov     ebp, esp
.text$mn:0000340B                 push    ecx
.text$mn:0000340C                 mov     eax, [ebp+arg_4]
.text$mn:0000340F                 push    eax
.text$mn:00003410                 mov     ecx, [ebp+arg_0]
.text$mn:00003413                 push    ecx
.text$mn:00003414                 call    ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z ; std::_Ptr_cat<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *)
.text$mn:00003419                 add     esp, 8
.text$mn:0000341C                 mov     [ebp+var_1], al
.text$mn:0000341F                 movzx   edx, [ebp+var_1]
.text$mn:00003423                 push    edx
.text$mn:00003424                 mov     eax, [ebp+arg_8]
.text$mn:00003427                 push    eax
.text$mn:00003428                 mov     ecx, [ebp+arg_4]
.text$mn:0000342B                 push    ecx
.text$mn:0000342C                 mov     edx, [ebp+arg_0]
.text$mn:0000342F                 push    edx
.text$mn:00003430                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003435                 add     esp, 10h
.text$mn:00003438                 mov     esp, ebp
.text$mn:0000343A                 pop     ebp
.text$mn:0000343B                 retn
.text$mn:0000343B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:0000343B
.text$mn:0000343B _text$mn        ends
.text$mn:0000343B
.text$mn:0000343C ; ===========================================================================
.text$mn:0000343C
.text$mn:0000343C ; Segment type: Pure code
.text$mn:0000343C ; Segment permissions: Read/Execute
.text$mn:0000343C _text$mn        segment para public 'CODE' use32
.text$mn:0000343C                 assume cs:_text$mn
.text$mn:0000343C                 ;org 343Ch
.text$mn:0000343C ; COMDAT (pick any)
.text$mn:0000343C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000343C
.text$mn:0000343C ; =============== S U B R O U T I N E =======================================
.text$mn:0000343C
.text$mn:0000343C ; Attributes: bp-based frame
.text$mn:0000343C
.text$mn:0000343C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>>(struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000343C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000343C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000343C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+28p
.text$mn:0000343C
.text$mn:0000343C arg_0           = dword ptr  8
.text$mn:0000343C arg_4           = dword ptr  0Ch
.text$mn:0000343C arg_8           = dword ptr  10h
.text$mn:0000343C
.text$mn:0000343C                 push    ebp
.text$mn:0000343D                 mov     ebp, esp
.text$mn:0000343F                 jmp     short loc_344A
.text$mn:00003441 ; ---------------------------------------------------------------------------
.text$mn:00003441
.text$mn:00003441 loc_3441:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00003441                 mov     eax, [ebp+arg_0]
.text$mn:00003444                 add     eax, 2Ch ; ','
.text$mn:00003447                 mov     [ebp+arg_0], eax
.text$mn:0000344A
.text$mn:0000344A loc_344A:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000344A                 mov     ecx, [ebp+arg_0]
.text$mn:0000344D                 cmp     ecx, [ebp+arg_4]
.text$mn:00003450                 jz      short loc_3460
.text$mn:00003452                 mov     edx, [ebp+arg_0]
.text$mn:00003455                 push    edx
.text$mn:00003456                 mov     ecx, [ebp+arg_8]
.text$mn:00003459                 call    ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(recordedMacroStep *)
.text$mn:0000345E                 jmp     short loc_3441
.text$mn:00003460 ; ---------------------------------------------------------------------------
.text$mn:00003460
.text$mn:00003460 loc_3460:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00003460                 pop     ebp
.text$mn:00003461                 retn
.text$mn:00003461 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003461
.text$mn:00003461 ; ---------------------------------------------------------------------------
.text$mn:00003462                 align 4
.text$mn:00003462 _text$mn        ends
.text$mn:00003462
.text$mn:00003464 ; ===========================================================================
.text$mn:00003464
.text$mn:00003464 ; Segment type: Pure code
.text$mn:00003464 ; Segment permissions: Read/Execute
.text$mn:00003464 _text$mn        segment para public 'CODE' use32
.text$mn:00003464                 assume cs:_text$mn
.text$mn:00003464                 ;org 3464h
.text$mn:00003464 ; COMDAT (pick any)
.text$mn:00003464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003464
.text$mn:00003464 ; =============== S U B R O U T I N E =======================================
.text$mn:00003464
.text$mn:00003464 ; Attributes: bp-based frame
.text$mn:00003464
.text$mn:00003464 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class MacroShortcut>>>(class MacroShortcut *, class MacroShortcut *, struct std::_Wrap_alloc<class std::allocator<class MacroShortcut>> &)
.text$mn:00003464                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@@Z
.text$mn:00003464 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@@Z proc near
.text$mn:00003464                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Destroy(MacroShortcut *,MacroShortcut *)+21p
.text$mn:00003464
.text$mn:00003464 var_1           = byte ptr -1
.text$mn:00003464 arg_0           = dword ptr  8
.text$mn:00003464 arg_4           = dword ptr  0Ch
.text$mn:00003464 arg_8           = dword ptr  10h
.text$mn:00003464
.text$mn:00003464                 push    ebp
.text$mn:00003465                 mov     ebp, esp
.text$mn:00003467                 push    ecx
.text$mn:00003468                 mov     eax, [ebp+arg_4]
.text$mn:0000346B                 push    eax
.text$mn:0000346C                 mov     ecx, [ebp+arg_0]
.text$mn:0000346F                 push    ecx
.text$mn:00003470                 call    ??$_Ptr_cat@VMacroShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVMacroShortcut@@0@Z ; std::_Ptr_cat<MacroShortcut,MacroShortcut>(MacroShortcut *,MacroShortcut *)
.text$mn:00003475                 add     esp, 8
.text$mn:00003478                 mov     [ebp+var_1], al
.text$mn:0000347B                 movzx   edx, [ebp+var_1]
.text$mn:0000347F                 push    edx
.text$mn:00003480                 mov     eax, [ebp+arg_8]
.text$mn:00003483                 push    eax
.text$mn:00003484                 mov     ecx, [ebp+arg_4]
.text$mn:00003487                 push    ecx
.text$mn:00003488                 mov     edx, [ebp+arg_0]
.text$mn:0000348B                 push    edx
.text$mn:0000348C                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003491                 add     esp, 10h
.text$mn:00003494                 mov     esp, ebp
.text$mn:00003496                 pop     ebp
.text$mn:00003497                 retn
.text$mn:00003497 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@@Z endp
.text$mn:00003497
.text$mn:00003497 _text$mn        ends
.text$mn:00003497
.text$mn:00003498 ; ===========================================================================
.text$mn:00003498
.text$mn:00003498 ; Segment type: Pure code
.text$mn:00003498 ; Segment permissions: Read/Execute
.text$mn:00003498 _text$mn        segment para public 'CODE' use32
.text$mn:00003498                 assume cs:_text$mn
.text$mn:00003498                 ;org 3498h
.text$mn:00003498 ; COMDAT (pick any)
.text$mn:00003498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003498
.text$mn:00003498 ; =============== S U B R O U T I N E =======================================
.text$mn:00003498
.text$mn:00003498 ; Attributes: bp-based frame
.text$mn:00003498
.text$mn:00003498 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class MacroShortcut>>>(class MacroShortcut *, class MacroShortcut *, struct std::_Wrap_alloc<class std::allocator<class MacroShortcut>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003498                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003498 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003498                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &)+28p
.text$mn:00003498
.text$mn:00003498 arg_0           = dword ptr  8
.text$mn:00003498 arg_4           = dword ptr  0Ch
.text$mn:00003498 arg_8           = dword ptr  10h
.text$mn:00003498
.text$mn:00003498                 push    ebp
.text$mn:00003499                 mov     ebp, esp
.text$mn:0000349B                 jmp     short loc_34A8
.text$mn:0000349D ; ---------------------------------------------------------------------------
.text$mn:0000349D
.text$mn:0000349D loc_349D:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+24j
.text$mn:0000349D                 mov     eax, [ebp+arg_0]
.text$mn:000034A0                 add     eax, 13Ch
.text$mn:000034A5                 mov     [ebp+arg_0], eax
.text$mn:000034A8
.text$mn:000034A8 loc_34A8:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:000034A8                 mov     ecx, [ebp+arg_0]
.text$mn:000034AB                 cmp     ecx, [ebp+arg_4]
.text$mn:000034AE                 jz      short loc_34BE
.text$mn:000034B0                 mov     edx, [ebp+arg_0]
.text$mn:000034B3                 push    edx
.text$mn:000034B4                 mov     ecx, [ebp+arg_8]
.text$mn:000034B7                 call    ??$destroy@VMacroShortcut@@@?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAEXPAVMacroShortcut@@@Z ; std::_Wrap_alloc<std::allocator<MacroShortcut>>::destroy<MacroShortcut>(MacroShortcut *)
.text$mn:000034BC                 jmp     short loc_349D
.text$mn:000034BE ; ---------------------------------------------------------------------------
.text$mn:000034BE
.text$mn:000034BE loc_34BE:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+16j
.text$mn:000034BE                 pop     ebp
.text$mn:000034BF                 retn
.text$mn:000034BF ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000034BF
.text$mn:000034BF _text$mn        ends
.text$mn:000034BF
.text$mn:000034C0 ; ===========================================================================
.text$mn:000034C0
.text$mn:000034C0 ; Segment type: Pure code
.text$mn:000034C0 ; Segment permissions: Read/Execute
.text$mn:000034C0 _text$mn        segment para public 'CODE' use32
.text$mn:000034C0                 assume cs:_text$mn
.text$mn:000034C0                 ;org 34C0h
.text$mn:000034C0 ; COMDAT (pick any)
.text$mn:000034C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034C0
.text$mn:000034C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000034C0
.text$mn:000034C0 ; Attributes: bp-based frame
.text$mn:000034C0
.text$mn:000034C0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class UserCommand>>>(class UserCommand *, class UserCommand *, struct std::_Wrap_alloc<class std::allocator<class UserCommand>> &)
.text$mn:000034C0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z
.text$mn:000034C0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z proc near
.text$mn:000034C0                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Destroy(UserCommand *,UserCommand *)+21p
.text$mn:000034C0
.text$mn:000034C0 var_1           = byte ptr -1
.text$mn:000034C0 arg_0           = dword ptr  8
.text$mn:000034C0 arg_4           = dword ptr  0Ch
.text$mn:000034C0 arg_8           = dword ptr  10h
.text$mn:000034C0
.text$mn:000034C0                 push    ebp
.text$mn:000034C1                 mov     ebp, esp
.text$mn:000034C3                 push    ecx
.text$mn:000034C4                 mov     eax, [ebp+arg_4]
.text$mn:000034C7                 push    eax
.text$mn:000034C8                 mov     ecx, [ebp+arg_0]
.text$mn:000034CB                 push    ecx
.text$mn:000034CC                 call    ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z ; std::_Ptr_cat<UserCommand,UserCommand>(UserCommand *,UserCommand *)
.text$mn:000034D1                 add     esp, 8
.text$mn:000034D4                 mov     [ebp+var_1], al
.text$mn:000034D7                 movzx   edx, [ebp+var_1]
.text$mn:000034DB                 push    edx
.text$mn:000034DC                 mov     eax, [ebp+arg_8]
.text$mn:000034DF                 push    eax
.text$mn:000034E0                 mov     ecx, [ebp+arg_4]
.text$mn:000034E3                 push    ecx
.text$mn:000034E4                 mov     edx, [ebp+arg_0]
.text$mn:000034E7                 push    edx
.text$mn:000034E8                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000034ED                 add     esp, 10h
.text$mn:000034F0                 mov     esp, ebp
.text$mn:000034F2                 pop     ebp
.text$mn:000034F3                 retn
.text$mn:000034F3 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z endp
.text$mn:000034F3
.text$mn:000034F3 _text$mn        ends
.text$mn:000034F3
.text$mn:000034F4 ; ===========================================================================
.text$mn:000034F4
.text$mn:000034F4 ; Segment type: Pure code
.text$mn:000034F4 ; Segment permissions: Read/Execute
.text$mn:000034F4 _text$mn        segment para public 'CODE' use32
.text$mn:000034F4                 assume cs:_text$mn
.text$mn:000034F4                 ;org 34F4h
.text$mn:000034F4 ; COMDAT (pick any)
.text$mn:000034F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034F4
.text$mn:000034F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034F4
.text$mn:000034F4 ; Attributes: bp-based frame
.text$mn:000034F4
.text$mn:000034F4 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class UserCommand>>>(class UserCommand *, class UserCommand *, struct std::_Wrap_alloc<class std::allocator<class UserCommand>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:000034F4                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000034F4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000034F4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+28p
.text$mn:000034F4
.text$mn:000034F4 arg_0           = dword ptr  8
.text$mn:000034F4 arg_4           = dword ptr  0Ch
.text$mn:000034F4 arg_8           = dword ptr  10h
.text$mn:000034F4
.text$mn:000034F4                 push    ebp
.text$mn:000034F5                 mov     ebp, esp
.text$mn:000034F7                 jmp     short loc_3504
.text$mn:000034F9 ; ---------------------------------------------------------------------------
.text$mn:000034F9
.text$mn:000034F9 loc_34F9:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+24j
.text$mn:000034F9                 mov     eax, [ebp+arg_0]
.text$mn:000034FC                 add     eax, 148h
.text$mn:00003501                 mov     [ebp+arg_0], eax
.text$mn:00003504
.text$mn:00003504 loc_3504:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00003504                 mov     ecx, [ebp+arg_0]
.text$mn:00003507                 cmp     ecx, [ebp+arg_4]
.text$mn:0000350A                 jz      short loc_351A
.text$mn:0000350C                 mov     edx, [ebp+arg_0]
.text$mn:0000350F                 push    edx
.text$mn:00003510                 mov     ecx, [ebp+arg_8]
.text$mn:00003513                 call    ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::destroy<UserCommand>(UserCommand *)
.text$mn:00003518                 jmp     short loc_34F9
.text$mn:0000351A ; ---------------------------------------------------------------------------
.text$mn:0000351A
.text$mn:0000351A loc_351A:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+16j
.text$mn:0000351A                 pop     ebp
.text$mn:0000351B                 retn
.text$mn:0000351B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000351B
.text$mn:0000351B _text$mn        ends
.text$mn:0000351B
.text$mn:0000351C ; ===========================================================================
.text$mn:0000351C
.text$mn:0000351C ; Segment type: Pure code
.text$mn:0000351C ; Segment permissions: Read/Execute
.text$mn:0000351C _text$mn        segment para public 'CODE' use32
.text$mn:0000351C                 assume cs:_text$mn
.text$mn:0000351C                 ;org 351Ch
.text$mn:0000351C ; COMDAT (pick any)
.text$mn:0000351C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000351C
.text$mn:0000351C ; =============== S U B R O U T I N E =======================================
.text$mn:0000351C
.text$mn:0000351C ; Attributes: bp-based frame
.text$mn:0000351C
.text$mn:0000351C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct KeyCombo *>(struct KeyCombo * const &)
.text$mn:0000351C                 public ??$_Iter_cat@PAUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKeyCombo@@@Z
.text$mn:0000351C ??$_Iter_cat@PAUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKeyCombo@@@Z proc near
.text$mn:0000351C                                         ; CODE XREF: std::_Debug_range<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint)+Cp
.text$mn:0000351C
.text$mn:0000351C var_1           = byte ptr -1
.text$mn:0000351C arg_0           = dword ptr  8
.text$mn:0000351C
.text$mn:0000351C                 push    ebp
.text$mn:0000351D                 mov     ebp, esp
.text$mn:0000351F                 push    ecx
.text$mn:00003520                 mov     eax, [ebp+arg_0]
.text$mn:00003523                 mov     cl, [ebp+var_1]
.text$mn:00003526                 mov     [eax], cl
.text$mn:00003528                 mov     eax, [ebp+arg_0]
.text$mn:0000352B                 mov     esp, ebp
.text$mn:0000352D                 pop     ebp
.text$mn:0000352E                 retn
.text$mn:0000352E ??$_Iter_cat@PAUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKeyCombo@@@Z endp
.text$mn:0000352E
.text$mn:0000352E ; ---------------------------------------------------------------------------
.text$mn:0000352F                 align 10h
.text$mn:0000352F _text$mn        ends
.text$mn:0000352F
.text$mn:00003530 ; ===========================================================================
.text$mn:00003530
.text$mn:00003530 ; Segment type: Pure code
.text$mn:00003530 ; Segment permissions: Read/Execute
.text$mn:00003530 _text$mn        segment para public 'CODE' use32
.text$mn:00003530                 assume cs:_text$mn
.text$mn:00003530                 ;org 3530h
.text$mn:00003530 ; COMDAT (pick any)
.text$mn:00003530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003530
.text$mn:00003530 ; =============== S U B R O U T I N E =======================================
.text$mn:00003530
.text$mn:00003530 ; Attributes: bp-based frame
.text$mn:00003530
.text$mn:00003530 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct MenuItemUnit *>(struct MenuItemUnit * const &)
.text$mn:00003530                 public ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z
.text$mn:00003530 ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z proc near
.text$mn:00003530                                         ; CODE XREF: std::_Debug_range<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint)+Cp
.text$mn:00003530
.text$mn:00003530 var_1           = byte ptr -1
.text$mn:00003530 arg_0           = dword ptr  8
.text$mn:00003530
.text$mn:00003530                 push    ebp
.text$mn:00003531                 mov     ebp, esp
.text$mn:00003533                 push    ecx
.text$mn:00003534                 mov     eax, [ebp+arg_0]
.text$mn:00003537                 mov     cl, [ebp+var_1]
.text$mn:0000353A                 mov     [eax], cl
.text$mn:0000353C                 mov     eax, [ebp+arg_0]
.text$mn:0000353F                 mov     esp, ebp
.text$mn:00003541                 pop     ebp
.text$mn:00003542                 retn
.text$mn:00003542 ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z endp
.text$mn:00003542
.text$mn:00003542 ; ---------------------------------------------------------------------------
.text$mn:00003543                 align 4
.text$mn:00003543 _text$mn        ends
.text$mn:00003543
.text$mn:00003544 ; ===========================================================================
.text$mn:00003544
.text$mn:00003544 ; Segment type: Pure code
.text$mn:00003544 ; Segment permissions: Read/Execute
.text$mn:00003544 _text$mn        segment para public 'CODE' use32
.text$mn:00003544                 assume cs:_text$mn
.text$mn:00003544                 ;org 3544h
.text$mn:00003544 ; COMDAT (pick any)
.text$mn:00003544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003544
.text$mn:00003544 ; =============== S U B R O U T I N E =======================================
.text$mn:00003544
.text$mn:00003544 ; Attributes: bp-based frame
.text$mn:00003544
.text$mn:00003544 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct recordedMacroStep *>(struct recordedMacroStep * const &)
.text$mn:00003544                 public ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z
.text$mn:00003544 ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z proc near
.text$mn:00003544                                         ; CODE XREF: std::_Debug_range<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint)+Cp
.text$mn:00003544
.text$mn:00003544 var_1           = byte ptr -1
.text$mn:00003544 arg_0           = dword ptr  8
.text$mn:00003544
.text$mn:00003544                 push    ebp
.text$mn:00003545                 mov     ebp, esp
.text$mn:00003547                 push    ecx
.text$mn:00003548                 mov     eax, [ebp+arg_0]
.text$mn:0000354B                 mov     cl, [ebp+var_1]
.text$mn:0000354E                 mov     [eax], cl
.text$mn:00003550                 mov     eax, [ebp+arg_0]
.text$mn:00003553                 mov     esp, ebp
.text$mn:00003555                 pop     ebp
.text$mn:00003556                 retn
.text$mn:00003556 ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z endp
.text$mn:00003556
.text$mn:00003556 ; ---------------------------------------------------------------------------
.text$mn:00003557                 align 4
.text$mn:00003557 _text$mn        ends
.text$mn:00003557
.text$mn:00003558 ; ===========================================================================
.text$mn:00003558
.text$mn:00003558 ; Segment type: Pure code
.text$mn:00003558 ; Segment permissions: Read/Execute
.text$mn:00003558 _text$mn        segment para public 'CODE' use32
.text$mn:00003558                 assume cs:_text$mn
.text$mn:00003558                 ;org 3558h
.text$mn:00003558 ; COMDAT (pick any)
.text$mn:00003558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003558
.text$mn:00003558 ; =============== S U B R O U T I N E =======================================
.text$mn:00003558
.text$mn:00003558 ; Attributes: bp-based frame
.text$mn:00003558
.text$mn:00003558 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct KeyCombo const *>(struct KeyCombo const * const &)
.text$mn:00003558                 public ??$_Iter_cat@PBUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUKeyCombo@@@Z
.text$mn:00003558 ??$_Iter_cat@PBUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUKeyCombo@@@Z proc near
.text$mn:00003558                                         ; CODE XREF: std::_Debug_range<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint)+Cp
.text$mn:00003558
.text$mn:00003558 var_1           = byte ptr -1
.text$mn:00003558 arg_0           = dword ptr  8
.text$mn:00003558
.text$mn:00003558                 push    ebp
.text$mn:00003559                 mov     ebp, esp
.text$mn:0000355B                 push    ecx
.text$mn:0000355C                 mov     eax, [ebp+arg_0]
.text$mn:0000355F                 mov     cl, [ebp+var_1]
.text$mn:00003562                 mov     [eax], cl
.text$mn:00003564                 mov     eax, [ebp+arg_0]
.text$mn:00003567                 mov     esp, ebp
.text$mn:00003569                 pop     ebp
.text$mn:0000356A                 retn
.text$mn:0000356A ??$_Iter_cat@PBUKeyCombo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUKeyCombo@@@Z endp
.text$mn:0000356A
.text$mn:0000356A ; ---------------------------------------------------------------------------
.text$mn:0000356B                 align 4
.text$mn:0000356B _text$mn        ends
.text$mn:0000356B
.text$mn:0000356C ; ===========================================================================
.text$mn:0000356C
.text$mn:0000356C ; Segment type: Pure code
.text$mn:0000356C ; Segment permissions: Read/Execute
.text$mn:0000356C _text$mn        segment para public 'CODE' use32
.text$mn:0000356C                 assume cs:_text$mn
.text$mn:0000356C                 ;org 356Ch
.text$mn:0000356C ; COMDAT (pick any)
.text$mn:0000356C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000356C
.text$mn:0000356C ; =============== S U B R O U T I N E =======================================
.text$mn:0000356C
.text$mn:0000356C ; Attributes: bp-based frame
.text$mn:0000356C
.text$mn:0000356C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct recordedMacroStep const *>(struct recordedMacroStep const * const &)
.text$mn:0000356C                 public ??$_Iter_cat@PBUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUrecordedMacroStep@@@Z
.text$mn:0000356C ??$_Iter_cat@PBUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUrecordedMacroStep@@@Z proc near
.text$mn:0000356C                                         ; CODE XREF: std::_Debug_range<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint)+Cp
.text$mn:0000356C
.text$mn:0000356C var_1           = byte ptr -1
.text$mn:0000356C arg_0           = dword ptr  8
.text$mn:0000356C
.text$mn:0000356C                 push    ebp
.text$mn:0000356D                 mov     ebp, esp
.text$mn:0000356F                 push    ecx
.text$mn:00003570                 mov     eax, [ebp+arg_0]
.text$mn:00003573                 mov     cl, [ebp+var_1]
.text$mn:00003576                 mov     [eax], cl
.text$mn:00003578                 mov     eax, [ebp+arg_0]
.text$mn:0000357B                 mov     esp, ebp
.text$mn:0000357D                 pop     ebp
.text$mn:0000357E                 retn
.text$mn:0000357E ??$_Iter_cat@PBUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBUrecordedMacroStep@@@Z endp
.text$mn:0000357E
.text$mn:0000357E ; ---------------------------------------------------------------------------
.text$mn:0000357F                 align 10h
.text$mn:0000357F _text$mn        ends
.text$mn:0000357F
.text$mn:00003580 ; ===========================================================================
.text$mn:00003580
.text$mn:00003580 ; Segment type: Pure code
.text$mn:00003580 ; Segment permissions: Read/Execute
.text$mn:00003580 _text$mn        segment para public 'CODE' use32
.text$mn:00003580                 assume cs:_text$mn
.text$mn:00003580                 ;org 3580h
.text$mn:00003580 ; COMDAT (pick any)
.text$mn:00003580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003580
.text$mn:00003580 ; =============== S U B R O U T I N E =======================================
.text$mn:00003580
.text$mn:00003580 ; Attributes: bp-based frame
.text$mn:00003580
.text$mn:00003580 ; class MacroShortcut * __cdecl std::_Move<class MacroShortcut *, class MacroShortcut *>(class MacroShortcut *, class MacroShortcut *, class MacroShortcut *)
.text$mn:00003580                 public ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00@Z
.text$mn:00003580 ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00@Z proc near
.text$mn:00003580                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+85p
.text$mn:00003580
.text$mn:00003580 var_1           = byte ptr -1
.text$mn:00003580 arg_0           = dword ptr  8
.text$mn:00003580 arg_4           = dword ptr  0Ch
.text$mn:00003580 arg_8           = dword ptr  10h
.text$mn:00003580
.text$mn:00003580                 push    ebp
.text$mn:00003581                 mov     ebp, esp
.text$mn:00003583                 push    ecx
.text$mn:00003584                 mov     eax, [ebp+arg_8]
.text$mn:00003587                 push    eax
.text$mn:00003588                 mov     ecx, [ebp+arg_0]
.text$mn:0000358B                 push    ecx
.text$mn:0000358C                 call    ??$_Ptr_cat@VMacroShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVMacroShortcut@@0@Z ; std::_Ptr_cat<MacroShortcut,MacroShortcut>(MacroShortcut *,MacroShortcut *)
.text$mn:00003591                 add     esp, 8
.text$mn:00003594                 mov     [ebp+var_1], al
.text$mn:00003597                 movzx   edx, [ebp+var_1]
.text$mn:0000359B                 push    edx
.text$mn:0000359C                 mov     eax, [ebp+arg_8]
.text$mn:0000359F                 push    eax
.text$mn:000035A0                 mov     ecx, [ebp+arg_4]
.text$mn:000035A3                 push    ecx
.text$mn:000035A4                 mov     edx, [ebp+arg_0]
.text$mn:000035A7                 push    edx
.text$mn:000035A8                 call    ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000035AD                 add     esp, 10h
.text$mn:000035B0                 mov     esp, ebp
.text$mn:000035B2                 pop     ebp
.text$mn:000035B3                 retn
.text$mn:000035B3 ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00@Z endp
.text$mn:000035B3
.text$mn:000035B3 _text$mn        ends
.text$mn:000035B3
.text$mn:000035B4 ; ===========================================================================
.text$mn:000035B4
.text$mn:000035B4 ; Segment type: Pure code
.text$mn:000035B4 ; Segment permissions: Read/Execute
.text$mn:000035B4 _text$mn        segment para public 'CODE' use32
.text$mn:000035B4                 assume cs:_text$mn
.text$mn:000035B4                 ;org 35B4h
.text$mn:000035B4 ; COMDAT (pick any)
.text$mn:000035B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035B4
.text$mn:000035B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000035B4
.text$mn:000035B4 ; Attributes: bp-based frame
.text$mn:000035B4
.text$mn:000035B4 ; class MacroShortcut * __cdecl std::_Move<class MacroShortcut *, class MacroShortcut *>(class MacroShortcut *, class MacroShortcut *, class MacroShortcut *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:000035B4                 public ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000035B4 ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000035B4                                         ; CODE XREF: std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *)+28p
.text$mn:000035B4
.text$mn:000035B4 arg_0           = dword ptr  8
.text$mn:000035B4 arg_4           = dword ptr  0Ch
.text$mn:000035B4 arg_8           = dword ptr  10h
.text$mn:000035B4
.text$mn:000035B4                 push    ebp
.text$mn:000035B5                 mov     ebp, esp
.text$mn:000035B7                 jmp     short loc_35D0
.text$mn:000035B9 ; ---------------------------------------------------------------------------
.text$mn:000035B9
.text$mn:000035B9 loc_35B9:                               ; CODE XREF: std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *,std::_Nonscalar_ptr_iterator_tag)+39j
.text$mn:000035B9                 mov     eax, [ebp+arg_8]
.text$mn:000035BC                 add     eax, 13Ch
.text$mn:000035C1                 mov     [ebp+arg_8], eax
.text$mn:000035C4                 mov     ecx, [ebp+arg_0]
.text$mn:000035C7                 add     ecx, 13Ch
.text$mn:000035CD                 mov     [ebp+arg_0], ecx
.text$mn:000035D0
.text$mn:000035D0 loc_35D0:                               ; CODE XREF: std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:000035D0                 mov     edx, [ebp+arg_0]
.text$mn:000035D3                 cmp     edx, [ebp+arg_4]
.text$mn:000035D6                 jz      short loc_35EF
.text$mn:000035D8                 mov     eax, [ebp+arg_0]
.text$mn:000035DB                 push    eax
.text$mn:000035DC                 call    ??$move@AAVMacroShortcut@@@std@@YA$$QAVMacroShortcut@@AAV1@@Z ; std::move<MacroShortcut &>(MacroShortcut &)
.text$mn:000035E1                 add     esp, 4
.text$mn:000035E4                 push    eax             ; Shortcut *
.text$mn:000035E5                 mov     ecx, [ebp+arg_8]
.text$mn:000035E8                 call    ??4MacroShortcut@@QAEAAV0@ABV0@@Z ; MacroShortcut::operator=(MacroShortcut const &)
.text$mn:000035ED                 jmp     short loc_35B9
.text$mn:000035EF ; ---------------------------------------------------------------------------
.text$mn:000035EF
.text$mn:000035EF loc_35EF:                               ; CODE XREF: std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:000035EF                 mov     eax, [ebp+arg_8]
.text$mn:000035F2                 pop     ebp
.text$mn:000035F3                 retn
.text$mn:000035F3 ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000035F3
.text$mn:000035F3 _text$mn        ends
.text$mn:000035F3
.text$mn:000035F4 ; ===========================================================================
.text$mn:000035F4
.text$mn:000035F4 ; Segment type: Pure code
.text$mn:000035F4 ; Segment permissions: Read/Execute
.text$mn:000035F4 _text$mn        segment para public 'CODE' use32
.text$mn:000035F4                 assume cs:_text$mn
.text$mn:000035F4                 ;org 35F4h
.text$mn:000035F4 ; COMDAT (pick any)
.text$mn:000035F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035F4
.text$mn:000035F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000035F4
.text$mn:000035F4 ; Attributes: bp-based frame
.text$mn:000035F4
.text$mn:000035F4 ; class UserCommand * __cdecl std::_Move<class UserCommand *, class UserCommand *>(class UserCommand *, class UserCommand *, class UserCommand *)
.text$mn:000035F4                 public ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00@Z
.text$mn:000035F4 ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00@Z proc near
.text$mn:000035F4                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+85p
.text$mn:000035F4
.text$mn:000035F4 var_1           = byte ptr -1
.text$mn:000035F4 arg_0           = dword ptr  8
.text$mn:000035F4 arg_4           = dword ptr  0Ch
.text$mn:000035F4 arg_8           = dword ptr  10h
.text$mn:000035F4
.text$mn:000035F4                 push    ebp
.text$mn:000035F5                 mov     ebp, esp
.text$mn:000035F7                 push    ecx
.text$mn:000035F8                 mov     eax, [ebp+arg_8]
.text$mn:000035FB                 push    eax
.text$mn:000035FC                 mov     ecx, [ebp+arg_0]
.text$mn:000035FF                 push    ecx
.text$mn:00003600                 call    ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z ; std::_Ptr_cat<UserCommand,UserCommand>(UserCommand *,UserCommand *)
.text$mn:00003605                 add     esp, 8
.text$mn:00003608                 mov     [ebp+var_1], al
.text$mn:0000360B                 movzx   edx, [ebp+var_1]
.text$mn:0000360F                 push    edx
.text$mn:00003610                 mov     eax, [ebp+arg_8]
.text$mn:00003613                 push    eax
.text$mn:00003614                 mov     ecx, [ebp+arg_4]
.text$mn:00003617                 push    ecx
.text$mn:00003618                 mov     edx, [ebp+arg_0]
.text$mn:0000361B                 push    edx
.text$mn:0000361C                 call    ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003621                 add     esp, 10h
.text$mn:00003624                 mov     esp, ebp
.text$mn:00003626                 pop     ebp
.text$mn:00003627                 retn
.text$mn:00003627 ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00@Z endp
.text$mn:00003627
.text$mn:00003627 _text$mn        ends
.text$mn:00003627
.text$mn:00003628 ; ===========================================================================
.text$mn:00003628
.text$mn:00003628 ; Segment type: Pure code
.text$mn:00003628 ; Segment permissions: Read/Execute
.text$mn:00003628 _text$mn        segment para public 'CODE' use32
.text$mn:00003628                 assume cs:_text$mn
.text$mn:00003628                 ;org 3628h
.text$mn:00003628 ; COMDAT (pick any)
.text$mn:00003628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003628
.text$mn:00003628 ; =============== S U B R O U T I N E =======================================
.text$mn:00003628
.text$mn:00003628 ; Attributes: bp-based frame
.text$mn:00003628
.text$mn:00003628 ; class UserCommand * __cdecl std::_Move<class UserCommand *, class UserCommand *>(class UserCommand *, class UserCommand *, class UserCommand *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003628                 public ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003628 ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003628                                         ; CODE XREF: std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *)+28p
.text$mn:00003628
.text$mn:00003628 arg_0           = dword ptr  8
.text$mn:00003628 arg_4           = dword ptr  0Ch
.text$mn:00003628 arg_8           = dword ptr  10h
.text$mn:00003628
.text$mn:00003628                 push    ebp
.text$mn:00003629                 mov     ebp, esp
.text$mn:0000362B                 jmp     short loc_3644
.text$mn:0000362D ; ---------------------------------------------------------------------------
.text$mn:0000362D
.text$mn:0000362D loc_362D:                               ; CODE XREF: std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+39j
.text$mn:0000362D                 mov     eax, [ebp+arg_8]
.text$mn:00003630                 add     eax, 148h
.text$mn:00003635                 mov     [ebp+arg_8], eax
.text$mn:00003638                 mov     ecx, [ebp+arg_0]
.text$mn:0000363B                 add     ecx, 148h
.text$mn:00003641                 mov     [ebp+arg_0], ecx
.text$mn:00003644
.text$mn:00003644 loc_3644:                               ; CODE XREF: std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00003644                 mov     edx, [ebp+arg_0]
.text$mn:00003647                 cmp     edx, [ebp+arg_4]
.text$mn:0000364A                 jz      short loc_3663
.text$mn:0000364C                 mov     eax, [ebp+arg_0]
.text$mn:0000364F                 push    eax
.text$mn:00003650                 call    ??$move@AAVUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z ; std::move<UserCommand &>(UserCommand &)
.text$mn:00003655                 add     esp, 4
.text$mn:00003658                 push    eax             ; Shortcut *
.text$mn:00003659                 mov     ecx, [ebp+arg_8]
.text$mn:0000365C                 call    ??4UserCommand@@QAEAAV0@ABV0@@Z ; UserCommand::operator=(UserCommand const &)
.text$mn:00003661                 jmp     short loc_362D
.text$mn:00003663 ; ---------------------------------------------------------------------------
.text$mn:00003663
.text$mn:00003663 loc_3663:                               ; CODE XREF: std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00003663                 mov     eax, [ebp+arg_8]
.text$mn:00003666                 pop     ebp
.text$mn:00003667                 retn
.text$mn:00003667 ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003667
.text$mn:00003667 _text$mn        ends
.text$mn:00003667
.text$mn:00003668 ; ===========================================================================
.text$mn:00003668
.text$mn:00003668 ; Segment type: Pure code
.text$mn:00003668 ; Segment permissions: Read/Execute
.text$mn:00003668 _text$mn        segment para public 'CODE' use32
.text$mn:00003668                 assume cs:_text$mn
.text$mn:00003668                 ;org 3668h
.text$mn:00003668 ; COMDAT (pick any)
.text$mn:00003668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003668
.text$mn:00003668 ; =============== S U B R O U T I N E =======================================
.text$mn:00003668
.text$mn:00003668 ; Attributes: bp-based frame
.text$mn:00003668
.text$mn:00003668 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct KeyCombo, struct KeyCombo>(struct KeyCombo *, struct KeyCombo *)
.text$mn:00003668                 public ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUKeyCombo@@0@Z
.text$mn:00003668 ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUKeyCombo@@0@Z proc near
.text$mn:00003668                                         ; CODE XREF: std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)+Cp
.text$mn:00003668                                         ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+Cp ...
.text$mn:00003668
.text$mn:00003668 var_1           = byte ptr -1
.text$mn:00003668
.text$mn:00003668                 push    ebp
.text$mn:00003669                 mov     ebp, esp
.text$mn:0000366B                 push    ecx
.text$mn:0000366C                 mov     al, [ebp+var_1]
.text$mn:0000366F                 mov     esp, ebp
.text$mn:00003671                 pop     ebp
.text$mn:00003672                 retn
.text$mn:00003672 ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUKeyCombo@@0@Z endp
.text$mn:00003672
.text$mn:00003672 ; ---------------------------------------------------------------------------
.text$mn:00003673                 align 4
.text$mn:00003673 _text$mn        ends
.text$mn:00003673
.text$mn:00003674 ; ===========================================================================
.text$mn:00003674
.text$mn:00003674 ; Segment type: Pure code
.text$mn:00003674 ; Segment permissions: Read/Execute
.text$mn:00003674 _text$mn        segment para public 'CODE' use32
.text$mn:00003674                 assume cs:_text$mn
.text$mn:00003674                 ;org 3674h
.text$mn:00003674 ; COMDAT (pick any)
.text$mn:00003674                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003674
.text$mn:00003674 ; =============== S U B R O U T I N E =======================================
.text$mn:00003674
.text$mn:00003674 ; Attributes: bp-based frame
.text$mn:00003674
.text$mn:00003674 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct KeyCombo, struct KeyCombo>(struct KeyCombo const *, struct KeyCombo *)
.text$mn:00003674                 public ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUKeyCombo@@PAU2@@Z
.text$mn:00003674 ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUKeyCombo@@PAU2@@Z proc near
.text$mn:00003674                                         ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+Cp
.text$mn:00003674
.text$mn:00003674 var_1           = byte ptr -1
.text$mn:00003674
.text$mn:00003674                 push    ebp
.text$mn:00003675                 mov     ebp, esp
.text$mn:00003677                 push    ecx
.text$mn:00003678                 mov     al, [ebp+var_1]
.text$mn:0000367B                 mov     esp, ebp
.text$mn:0000367D                 pop     ebp
.text$mn:0000367E                 retn
.text$mn:0000367E ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUKeyCombo@@PAU2@@Z endp
.text$mn:0000367E
.text$mn:0000367E ; ---------------------------------------------------------------------------
.text$mn:0000367F                 align 10h
.text$mn:0000367F _text$mn        ends
.text$mn:0000367F
.text$mn:00003680 ; ===========================================================================
.text$mn:00003680
.text$mn:00003680 ; Segment type: Pure code
.text$mn:00003680 ; Segment permissions: Read/Execute
.text$mn:00003680 _text$mn        segment para public 'CODE' use32
.text$mn:00003680                 assume cs:_text$mn
.text$mn:00003680                 ;org 3680h
.text$mn:00003680 ; COMDAT (pick any)
.text$mn:00003680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003680
.text$mn:00003680 ; =============== S U B R O U T I N E =======================================
.text$mn:00003680
.text$mn:00003680 ; Attributes: bp-based frame
.text$mn:00003680
.text$mn:00003680 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct MenuItemUnit, struct MenuItemUnit>(struct MenuItemUnit *, struct MenuItemUnit *)
.text$mn:00003680                 public ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z
.text$mn:00003680 ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z proc near
.text$mn:00003680                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+Cp
.text$mn:00003680                                         ; std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+Cp
.text$mn:00003680
.text$mn:00003680 var_1           = byte ptr -1
.text$mn:00003680
.text$mn:00003680                 push    ebp
.text$mn:00003681                 mov     ebp, esp
.text$mn:00003683                 push    ecx
.text$mn:00003684                 mov     al, [ebp+var_1]
.text$mn:00003687                 mov     esp, ebp
.text$mn:00003689                 pop     ebp
.text$mn:0000368A                 retn
.text$mn:0000368A ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z endp
.text$mn:0000368A
.text$mn:0000368A ; ---------------------------------------------------------------------------
.text$mn:0000368B                 align 4
.text$mn:0000368B _text$mn        ends
.text$mn:0000368B
.text$mn:0000368C ; ===========================================================================
.text$mn:0000368C
.text$mn:0000368C ; Segment type: Pure code
.text$mn:0000368C ; Segment permissions: Read/Execute
.text$mn:0000368C _text$mn        segment para public 'CODE' use32
.text$mn:0000368C                 assume cs:_text$mn
.text$mn:0000368C                 ;org 368Ch
.text$mn:0000368C ; COMDAT (pick any)
.text$mn:0000368C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000368C
.text$mn:0000368C ; =============== S U B R O U T I N E =======================================
.text$mn:0000368C
.text$mn:0000368C ; Attributes: bp-based frame
.text$mn:0000368C
.text$mn:0000368C ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct recordedMacroStep, struct recordedMacroStep>(struct recordedMacroStep *, struct recordedMacroStep *)
.text$mn:0000368C                 public ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z
.text$mn:0000368C ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z proc near
.text$mn:0000368C                                         ; CODE XREF: std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)+Cp
.text$mn:0000368C                                         ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+Cp ...
.text$mn:0000368C
.text$mn:0000368C var_1           = byte ptr -1
.text$mn:0000368C
.text$mn:0000368C                 push    ebp
.text$mn:0000368D                 mov     ebp, esp
.text$mn:0000368F                 push    ecx
.text$mn:00003690                 mov     al, [ebp+var_1]
.text$mn:00003693                 mov     esp, ebp
.text$mn:00003695                 pop     ebp
.text$mn:00003696                 retn
.text$mn:00003696 ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z endp
.text$mn:00003696
.text$mn:00003696 ; ---------------------------------------------------------------------------
.text$mn:00003697                 align 4
.text$mn:00003697 _text$mn        ends
.text$mn:00003697
.text$mn:00003698 ; ===========================================================================
.text$mn:00003698
.text$mn:00003698 ; Segment type: Pure code
.text$mn:00003698 ; Segment permissions: Read/Execute
.text$mn:00003698 _text$mn        segment para public 'CODE' use32
.text$mn:00003698                 assume cs:_text$mn
.text$mn:00003698                 ;org 3698h
.text$mn:00003698 ; COMDAT (pick any)
.text$mn:00003698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003698
.text$mn:00003698 ; =============== S U B R O U T I N E =======================================
.text$mn:00003698
.text$mn:00003698 ; Attributes: bp-based frame
.text$mn:00003698
.text$mn:00003698 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct recordedMacroStep, struct recordedMacroStep>(struct recordedMacroStep const *, struct recordedMacroStep *)
.text$mn:00003698                 public ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUrecordedMacroStep@@PAU2@@Z
.text$mn:00003698 ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUrecordedMacroStep@@PAU2@@Z proc near
.text$mn:00003698                                         ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+Cp
.text$mn:00003698
.text$mn:00003698 var_1           = byte ptr -1
.text$mn:00003698
.text$mn:00003698                 push    ebp
.text$mn:00003699                 mov     ebp, esp
.text$mn:0000369B                 push    ecx
.text$mn:0000369C                 mov     al, [ebp+var_1]
.text$mn:0000369F                 mov     esp, ebp
.text$mn:000036A1                 pop     ebp
.text$mn:000036A2                 retn
.text$mn:000036A2 ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUrecordedMacroStep@@PAU2@@Z endp
.text$mn:000036A2
.text$mn:000036A2 ; ---------------------------------------------------------------------------
.text$mn:000036A3                 align 4
.text$mn:000036A3 _text$mn        ends
.text$mn:000036A3
.text$mn:000036A4 ; ===========================================================================
.text$mn:000036A4
.text$mn:000036A4 ; Segment type: Pure code
.text$mn:000036A4 ; Segment permissions: Read/Execute
.text$mn:000036A4 _text$mn        segment para public 'CODE' use32
.text$mn:000036A4                 assume cs:_text$mn
.text$mn:000036A4                 ;org 36A4h
.text$mn:000036A4 ; COMDAT (pick any)
.text$mn:000036A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036A4
.text$mn:000036A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036A4
.text$mn:000036A4 ; Attributes: bp-based frame
.text$mn:000036A4
.text$mn:000036A4 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class MacroShortcut, class MacroShortcut>(class MacroShortcut *, class MacroShortcut *)
.text$mn:000036A4                 public ??$_Ptr_cat@VMacroShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVMacroShortcut@@0@Z
.text$mn:000036A4 ??$_Ptr_cat@VMacroShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVMacroShortcut@@0@Z proc near
.text$mn:000036A4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &)+Cp
.text$mn:000036A4                                         ; std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *)+Cp
.text$mn:000036A4
.text$mn:000036A4 var_1           = byte ptr -1
.text$mn:000036A4
.text$mn:000036A4                 push    ebp
.text$mn:000036A5                 mov     ebp, esp
.text$mn:000036A7                 push    ecx
.text$mn:000036A8                 mov     al, [ebp+var_1]
.text$mn:000036AB                 mov     esp, ebp
.text$mn:000036AD                 pop     ebp
.text$mn:000036AE                 retn
.text$mn:000036AE ??$_Ptr_cat@VMacroShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVMacroShortcut@@0@Z endp
.text$mn:000036AE
.text$mn:000036AE ; ---------------------------------------------------------------------------
.text$mn:000036AF                 align 10h
.text$mn:000036AF _text$mn        ends
.text$mn:000036AF
.text$mn:000036B0 ; ===========================================================================
.text$mn:000036B0
.text$mn:000036B0 ; Segment type: Pure code
.text$mn:000036B0 ; Segment permissions: Read/Execute
.text$mn:000036B0 _text$mn        segment para public 'CODE' use32
.text$mn:000036B0                 assume cs:_text$mn
.text$mn:000036B0                 ;org 36B0h
.text$mn:000036B0 ; COMDAT (pick any)
.text$mn:000036B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036B0
.text$mn:000036B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036B0
.text$mn:000036B0 ; Attributes: bp-based frame
.text$mn:000036B0
.text$mn:000036B0 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class UserCommand, class UserCommand>(class UserCommand *, class UserCommand *)
.text$mn:000036B0                 public ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z
.text$mn:000036B0 ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z proc near
.text$mn:000036B0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+Cp
.text$mn:000036B0                                         ; std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *)+Cp
.text$mn:000036B0
.text$mn:000036B0 var_1           = byte ptr -1
.text$mn:000036B0
.text$mn:000036B0                 push    ebp
.text$mn:000036B1                 mov     ebp, esp
.text$mn:000036B3                 push    ecx
.text$mn:000036B4                 mov     al, [ebp+var_1]
.text$mn:000036B7                 mov     esp, ebp
.text$mn:000036B9                 pop     ebp
.text$mn:000036BA                 retn
.text$mn:000036BA ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z endp
.text$mn:000036BA
.text$mn:000036BA ; ---------------------------------------------------------------------------
.text$mn:000036BB                 align 4
.text$mn:000036BB _text$mn        ends
.text$mn:000036BB
.text$mn:000036BC ; ===========================================================================
.text$mn:000036BC
.text$mn:000036BC ; Segment type: Pure code
.text$mn:000036BC ; Segment permissions: Read/Execute
.text$mn:000036BC _text$mn        segment para public 'CODE' use32
.text$mn:000036BC                 assume cs:_text$mn
.text$mn:000036BC                 ;org 36BCh
.text$mn:000036BC ; COMDAT (pick any)
.text$mn:000036BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036BC
.text$mn:000036BC ; =============== S U B R O U T I N E =======================================
.text$mn:000036BC
.text$mn:000036BC ; Attributes: bp-based frame
.text$mn:000036BC
.text$mn:000036BC ; struct KeyCombo * & __cdecl std::_Rechecked<struct KeyCombo *, struct KeyCombo *>(struct KeyCombo * &, struct KeyCombo *)
.text$mn:000036BC                 public ??$_Rechecked@PAUKeyCombo@@PAU1@@std@@YAAAPAUKeyCombo@@AAPAU1@PAU1@@Z
.text$mn:000036BC ??$_Rechecked@PAUKeyCombo@@PAU1@@std@@YAAAPAUKeyCombo@@AAPAU1@PAU1@@Z proc near
.text$mn:000036BC                                         ; CODE XREF: std::_Uninitialized_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+3Bp
.text$mn:000036BC                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+B2p
.text$mn:000036BC
.text$mn:000036BC arg_0           = dword ptr  8
.text$mn:000036BC arg_4           = dword ptr  0Ch
.text$mn:000036BC
.text$mn:000036BC                 push    ebp
.text$mn:000036BD                 mov     ebp, esp
.text$mn:000036BF                 mov     eax, [ebp+arg_0]
.text$mn:000036C2                 mov     ecx, [ebp+arg_4]
.text$mn:000036C5                 mov     [eax], ecx
.text$mn:000036C7                 mov     eax, [ebp+arg_0]
.text$mn:000036CA                 pop     ebp
.text$mn:000036CB                 retn
.text$mn:000036CB ??$_Rechecked@PAUKeyCombo@@PAU1@@std@@YAAAPAUKeyCombo@@AAPAU1@PAU1@@Z endp
.text$mn:000036CB
.text$mn:000036CB _text$mn        ends
.text$mn:000036CB
.text$mn:000036CC ; ===========================================================================
.text$mn:000036CC
.text$mn:000036CC ; Segment type: Pure code
.text$mn:000036CC ; Segment permissions: Read/Execute
.text$mn:000036CC _text$mn        segment para public 'CODE' use32
.text$mn:000036CC                 assume cs:_text$mn
.text$mn:000036CC                 ;org 36CCh
.text$mn:000036CC ; COMDAT (pick any)
.text$mn:000036CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036CC
.text$mn:000036CC ; =============== S U B R O U T I N E =======================================
.text$mn:000036CC
.text$mn:000036CC ; Attributes: bp-based frame
.text$mn:000036CC
.text$mn:000036CC ; struct MenuItemUnit * & __cdecl std::_Rechecked<struct MenuItemUnit *, struct MenuItemUnit *>(struct MenuItemUnit * &, struct MenuItemUnit *)
.text$mn:000036CC                 public ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z
.text$mn:000036CC ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z proc near
.text$mn:000036CC                                         ; CODE XREF: std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+3Bp
.text$mn:000036CC
.text$mn:000036CC arg_0           = dword ptr  8
.text$mn:000036CC arg_4           = dword ptr  0Ch
.text$mn:000036CC
.text$mn:000036CC                 push    ebp
.text$mn:000036CD                 mov     ebp, esp
.text$mn:000036CF                 mov     eax, [ebp+arg_0]
.text$mn:000036D2                 mov     ecx, [ebp+arg_4]
.text$mn:000036D5                 mov     [eax], ecx
.text$mn:000036D7                 mov     eax, [ebp+arg_0]
.text$mn:000036DA                 pop     ebp
.text$mn:000036DB                 retn
.text$mn:000036DB ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z endp
.text$mn:000036DB
.text$mn:000036DB _text$mn        ends
.text$mn:000036DB
.text$mn:000036DC ; ===========================================================================
.text$mn:000036DC
.text$mn:000036DC ; Segment type: Pure code
.text$mn:000036DC ; Segment permissions: Read/Execute
.text$mn:000036DC _text$mn        segment para public 'CODE' use32
.text$mn:000036DC                 assume cs:_text$mn
.text$mn:000036DC                 ;org 36DCh
.text$mn:000036DC ; COMDAT (pick any)
.text$mn:000036DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036DC
.text$mn:000036DC ; =============== S U B R O U T I N E =======================================
.text$mn:000036DC
.text$mn:000036DC ; Attributes: bp-based frame
.text$mn:000036DC
.text$mn:000036DC ; struct recordedMacroStep * & __cdecl std::_Rechecked<struct recordedMacroStep *, struct recordedMacroStep *>(struct recordedMacroStep * &, struct recordedMacroStep *)
.text$mn:000036DC                 public ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z
.text$mn:000036DC ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z proc near
.text$mn:000036DC                                         ; CODE XREF: std::_Uninitialized_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+3Bp
.text$mn:000036DC                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+B2p
.text$mn:000036DC
.text$mn:000036DC arg_0           = dword ptr  8
.text$mn:000036DC arg_4           = dword ptr  0Ch
.text$mn:000036DC
.text$mn:000036DC                 push    ebp
.text$mn:000036DD                 mov     ebp, esp
.text$mn:000036DF                 mov     eax, [ebp+arg_0]
.text$mn:000036E2                 mov     ecx, [ebp+arg_4]
.text$mn:000036E5                 mov     [eax], ecx
.text$mn:000036E7                 mov     eax, [ebp+arg_0]
.text$mn:000036EA                 pop     ebp
.text$mn:000036EB                 retn
.text$mn:000036EB ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z endp
.text$mn:000036EB
.text$mn:000036EB _text$mn        ends
.text$mn:000036EB
.text$mn:000036EC ; ===========================================================================
.text$mn:000036EC
.text$mn:000036EC ; Segment type: Pure code
.text$mn:000036EC ; Segment permissions: Read/Execute
.text$mn:000036EC _text$mn        segment para public 'CODE' use32
.text$mn:000036EC                 assume cs:_text$mn
.text$mn:000036EC                 ;org 36ECh
.text$mn:000036EC ; COMDAT (pick any)
.text$mn:000036EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036EC
.text$mn:000036EC ; =============== S U B R O U T I N E =======================================
.text$mn:000036EC
.text$mn:000036EC ; Attributes: bp-based frame
.text$mn:000036EC
.text$mn:000036EC ; protected: struct KeyCombo * __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::_Ucopy<struct KeyCombo *>(struct KeyCombo *, struct KeyCombo *, struct KeyCombo *)
.text$mn:000036EC                 public ??$_Ucopy@PAUKeyCombo@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@PAU2@00@Z
.text$mn:000036EC ??$_Ucopy@PAUKeyCombo@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@PAU2@00@Z proc near
.text$mn:000036EC                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+167p
.text$mn:000036EC                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+1F7p
.text$mn:000036EC
.text$mn:000036EC var_8           = dword ptr -8
.text$mn:000036EC var_1           = byte ptr -1
.text$mn:000036EC arg_0           = dword ptr  8
.text$mn:000036EC arg_4           = dword ptr  0Ch
.text$mn:000036EC arg_8           = dword ptr  10h
.text$mn:000036EC
.text$mn:000036EC                 push    ebp
.text$mn:000036ED                 mov     ebp, esp
.text$mn:000036EF                 sub     esp, 8
.text$mn:000036F2                 mov     [ebp+var_8], ecx
.text$mn:000036F5                 lea     eax, [ebp+var_1]
.text$mn:000036F8                 push    eax
.text$mn:000036F9                 mov     ecx, [ebp+var_8]
.text$mn:000036FC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:00003701                 lea     ecx, [ebp+var_1]
.text$mn:00003704                 push    ecx
.text$mn:00003705                 mov     edx, [ebp+arg_8]
.text$mn:00003708                 push    edx
.text$mn:00003709                 mov     eax, [ebp+arg_4]
.text$mn:0000370C                 push    eax
.text$mn:0000370D                 mov     ecx, [ebp+arg_0]
.text$mn:00003710                 push    ecx
.text$mn:00003711                 call    ??$_Uninitialized_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z ; std::_Uninitialized_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)
.text$mn:00003716                 add     esp, 10h
.text$mn:00003719                 mov     esp, ebp
.text$mn:0000371B                 pop     ebp
.text$mn:0000371C                 retn    0Ch
.text$mn:0000371C ??$_Ucopy@PAUKeyCombo@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@PAU2@00@Z endp
.text$mn:0000371C
.text$mn:0000371C ; ---------------------------------------------------------------------------
.text$mn:0000371F                 align 10h
.text$mn:0000371F _text$mn        ends
.text$mn:0000371F
.text$mn:00003720 ; ===========================================================================
.text$mn:00003720
.text$mn:00003720 ; Segment type: Pure code
.text$mn:00003720 ; Segment permissions: Read/Execute
.text$mn:00003720 _text$mn        segment para public 'CODE' use32
.text$mn:00003720                 assume cs:_text$mn
.text$mn:00003720                 ;org 3720h
.text$mn:00003720 ; COMDAT (pick any)
.text$mn:00003720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003720
.text$mn:00003720 ; =============== S U B R O U T I N E =======================================
.text$mn:00003720
.text$mn:00003720 ; Attributes: bp-based frame
.text$mn:00003720
.text$mn:00003720 ; protected: struct recordedMacroStep * __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Ucopy<struct recordedMacroStep *>(struct recordedMacroStep *, struct recordedMacroStep *, struct recordedMacroStep *)
.text$mn:00003720                 public ??$_Ucopy@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z
.text$mn:00003720 ??$_Ucopy@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z proc near
.text$mn:00003720                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+167p
.text$mn:00003720                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+1FCp
.text$mn:00003720
.text$mn:00003720 var_8           = dword ptr -8
.text$mn:00003720 var_1           = byte ptr -1
.text$mn:00003720 arg_0           = dword ptr  8
.text$mn:00003720 arg_4           = dword ptr  0Ch
.text$mn:00003720 arg_8           = dword ptr  10h
.text$mn:00003720
.text$mn:00003720                 push    ebp
.text$mn:00003721                 mov     ebp, esp
.text$mn:00003723                 sub     esp, 8
.text$mn:00003726                 mov     [ebp+var_8], ecx
.text$mn:00003729                 lea     eax, [ebp+var_1]
.text$mn:0000372C                 push    eax
.text$mn:0000372D                 mov     ecx, [ebp+var_8]
.text$mn:00003730                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:00003735                 lea     ecx, [ebp+var_1]
.text$mn:00003738                 push    ecx
.text$mn:00003739                 mov     edx, [ebp+arg_8]
.text$mn:0000373C                 push    edx
.text$mn:0000373D                 mov     eax, [ebp+arg_4]
.text$mn:00003740                 push    eax
.text$mn:00003741                 mov     ecx, [ebp+arg_0]
.text$mn:00003744                 push    ecx
.text$mn:00003745                 call    ??$_Uninitialized_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Uninitialized_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:0000374A                 add     esp, 10h
.text$mn:0000374D                 mov     esp, ebp
.text$mn:0000374F                 pop     ebp
.text$mn:00003750                 retn    0Ch
.text$mn:00003750 ??$_Ucopy@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z endp
.text$mn:00003750
.text$mn:00003750 ; ---------------------------------------------------------------------------
.text$mn:00003753                 align 4
.text$mn:00003753 _text$mn        ends
.text$mn:00003753
.text$mn:00003754 ; ===========================================================================
.text$mn:00003754
.text$mn:00003754 ; Segment type: Pure code
.text$mn:00003754 ; Segment permissions: Read/Execute
.text$mn:00003754 _text$mn        segment para public 'CODE' use32
.text$mn:00003754                 assume cs:_text$mn
.text$mn:00003754                 ;org 3754h
.text$mn:00003754 ; COMDAT (pick any)
.text$mn:00003754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003754
.text$mn:00003754 ; =============== S U B R O U T I N E =======================================
.text$mn:00003754
.text$mn:00003754 ; Attributes: bp-based frame
.text$mn:00003754
.text$mn:00003754 ; protected: struct KeyCombo * __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>, struct KeyCombo *)
.text$mn:00003754                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z
.text$mn:00003754 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z proc near
.text$mn:00003754                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+C0p
.text$mn:00003754
.text$mn:00003754 var_34          = dword ptr -34h
.text$mn:00003754 var_30          = dword ptr -30h
.text$mn:00003754 var_2C          = dword ptr -2Ch
.text$mn:00003754 var_28          = dword ptr -28h
.text$mn:00003754 var_24          = dword ptr -24h
.text$mn:00003754 var_20          = dword ptr -20h
.text$mn:00003754 var_1C          = dword ptr -1Ch
.text$mn:00003754 var_18          = dword ptr -18h
.text$mn:00003754 var_14          = dword ptr -14h
.text$mn:00003754 var_D           = byte ptr -0Dh
.text$mn:00003754 var_C           = dword ptr -0Ch
.text$mn:00003754 var_4           = dword ptr -4
.text$mn:00003754 arg_0           = byte ptr  8
.text$mn:00003754 arg_C           = byte ptr  14h
.text$mn:00003754 arg_18          = dword ptr  20h
.text$mn:00003754
.text$mn:00003754                 push    ebp
.text$mn:00003755                 mov     ebp, esp
.text$mn:00003757                 push    0FFFFFFFFh
.text$mn:00003759                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z
.text$mn:0000375E                 mov     eax, large fs:0
.text$mn:00003764                 push    eax
.text$mn:00003765                 sub     esp, 28h
.text$mn:00003768                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000376D                 xor     eax, ebp
.text$mn:0000376F                 push    eax
.text$mn:00003770                 lea     eax, [ebp+var_C]
.text$mn:00003773                 mov     large fs:0, eax
.text$mn:00003779                 mov     [ebp+var_14], ecx
.text$mn:0000377C                 mov     [ebp+var_4], 1
.text$mn:00003783                 lea     eax, [ebp+var_D]
.text$mn:00003786                 push    eax
.text$mn:00003787                 mov     ecx, [ebp+var_14]
.text$mn:0000378A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:0000378F                 lea     ecx, [ebp+var_D]
.text$mn:00003792                 push    ecx
.text$mn:00003793                 mov     edx, [ebp+arg_18]
.text$mn:00003796                 push    edx
.text$mn:00003797                 sub     esp, 0Ch
.text$mn:0000379A                 mov     ecx, esp
.text$mn:0000379C                 mov     [ebp+var_28], esp
.text$mn:0000379F                 lea     eax, [ebp+arg_C]
.text$mn:000037A2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000037A3                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>> const &)
.text$mn:000037A8                 mov     [ebp+var_18], eax
.text$mn:000037AB                 mov     ecx, [ebp+var_18]
.text$mn:000037AE                 mov     [ebp+var_2C], ecx
.text$mn:000037B1                 mov     byte ptr [ebp+var_4], 2
.text$mn:000037B5                 sub     esp, 0Ch
.text$mn:000037B8                 mov     ecx, esp
.text$mn:000037BA                 mov     [ebp+var_30], esp
.text$mn:000037BD                 lea     edx, [ebp+arg_0]
.text$mn:000037C0                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000037C1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>> const &)
.text$mn:000037C6                 mov     [ebp+var_1C], eax
.text$mn:000037C9                 mov     eax, [ebp+var_1C]
.text$mn:000037CC                 mov     [ebp+var_34], eax
.text$mn:000037CF                 mov     byte ptr [ebp+var_4], 3
.text$mn:000037D3                 mov     byte ptr [ebp+var_4], 1
.text$mn:000037D7                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)
.text$mn:000037DC                 add     esp, 20h
.text$mn:000037DF                 mov     [ebp+var_20], eax
.text$mn:000037E2                 mov     ecx, [ebp+var_20]
.text$mn:000037E5                 mov     [ebp+var_24], ecx
.text$mn:000037E8                 mov     byte ptr [ebp+var_4], 0
.text$mn:000037EC                 lea     ecx, [ebp+arg_0]
.text$mn:000037EF                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$mn:000037F4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000037FB                 lea     ecx, [ebp+arg_C]
.text$mn:000037FE                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$mn:00003803                 mov     eax, [ebp+var_24]
.text$mn:00003806                 mov     ecx, [ebp+var_C]
.text$mn:00003809                 mov     large fs:0, ecx
.text$mn:00003810                 pop     ecx
.text$mn:00003811                 mov     esp, ebp
.text$mn:00003813                 pop     ebp
.text$mn:00003814                 retn    1Ch
.text$mn:00003814 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z endp
.text$mn:00003814
.text$mn:00003814 ; ---------------------------------------------------------------------------
.text$mn:00003817                 align 4
.text$mn:00003817 _text$mn        ends
.text$mn:00003817
.text$x:00003818 ; ===========================================================================
.text$x:00003818
.text$x:00003818 ; Segment type: Pure code
.text$x:00003818 ; Segment permissions: Read/Execute
.text$x:00003818 _text$x         segment para public 'CODE' use32
.text$x:00003818                 assume cs:_text$x
.text$x:00003818                 ;org 3818h
.text$x:00003818 ; COMDAT (pick associative to section at 3754)
.text$x:00003818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003818
.text$x:00003818 ; =============== S U B R O U T I N E =======================================
.text$x:00003818
.text$x:00003818
.text$x:00003818 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$0 proc near
.text$x:00003818                                         ; DATA XREF: .xdata$x:0000E248o
.text$x:00003818                 lea     ecx, [ebp+14h]
.text$x:0000381B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:0000381B __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$0 endp
.text$x:0000381B
.text$x:00003820
.text$x:00003820 ; =============== S U B R O U T I N E =======================================
.text$x:00003820
.text$x:00003820
.text$x:00003820 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$1 proc near
.text$x:00003820                                         ; DATA XREF: .xdata$x:0000E250o
.text$x:00003820                 lea     ecx, [ebp+8]
.text$x:00003823                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:00003823 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$1 endp
.text$x:00003823
.text$x:00003828
.text$x:00003828 ; =============== S U B R O U T I N E =======================================
.text$x:00003828
.text$x:00003828
.text$x:00003828 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$2 proc near
.text$x:00003828                                         ; DATA XREF: .xdata$x:0000E258o
.text$x:00003828                 mov     ecx, [ebp-28h]
.text$x:0000382B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:0000382B __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$2 endp
.text$x:0000382B
.text$x:00003830
.text$x:00003830 ; =============== S U B R O U T I N E =======================================
.text$x:00003830
.text$x:00003830
.text$x:00003830 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$3 proc near
.text$x:00003830                                         ; DATA XREF: .xdata$x:0000E260o
.text$x:00003830                 mov     ecx, [ebp-30h]
.text$x:00003833                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:00003833 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$3 endp
.text$x:00003833
.text$x:00003838
.text$x:00003838 ; =============== S U B R O U T I N E =======================================
.text$x:00003838
.text$x:00003838
.text$x:00003838 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z proc near
.text$x:00003838                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)+5o
.text$x:00003838
.text$x:00003838 arg_4           = dword ptr  8
.text$x:00003838
.text$x:00003838                 mov     edx, [esp+arg_4]
.text$x:0000383C                 lea     eax, [edx+0Ch]
.text$x:0000383F                 mov     ecx, [edx-2Ch]
.text$x:00003842                 xor     ecx, eax
.text$x:00003844                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003849                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z
.text$x:0000384E                 jmp     ___CxxFrameHandler3
.text$x:0000384E __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z endp
.text$x:0000384E
.text$x:0000384E ; ---------------------------------------------------------------------------
.text$x:00003853                 align 4
.text$x:00003853 _text$x         ends
.text$x:00003853
.text$mn:00003854 ; ===========================================================================
.text$mn:00003854
.text$mn:00003854 ; Segment type: Pure code
.text$mn:00003854 ; Segment permissions: Read/Execute
.text$mn:00003854 _text$mn        segment para public 'CODE' use32
.text$mn:00003854                 assume cs:_text$mn
.text$mn:00003854                 ;org 3854h
.text$mn:00003854 ; COMDAT (pick any)
.text$mn:00003854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003854
.text$mn:00003854 ; =============== S U B R O U T I N E =======================================
.text$mn:00003854
.text$mn:00003854 ; Attributes: bp-based frame
.text$mn:00003854
.text$mn:00003854 ; protected: struct recordedMacroStep * __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>, struct recordedMacroStep *)
.text$mn:00003854                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z
.text$mn:00003854 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z proc near
.text$mn:00003854                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+C0p
.text$mn:00003854
.text$mn:00003854 var_34          = dword ptr -34h
.text$mn:00003854 var_30          = dword ptr -30h
.text$mn:00003854 var_2C          = dword ptr -2Ch
.text$mn:00003854 var_28          = dword ptr -28h
.text$mn:00003854 var_24          = dword ptr -24h
.text$mn:00003854 var_20          = dword ptr -20h
.text$mn:00003854 var_1C          = dword ptr -1Ch
.text$mn:00003854 var_18          = dword ptr -18h
.text$mn:00003854 var_14          = dword ptr -14h
.text$mn:00003854 var_D           = byte ptr -0Dh
.text$mn:00003854 var_C           = dword ptr -0Ch
.text$mn:00003854 var_4           = dword ptr -4
.text$mn:00003854 arg_0           = byte ptr  8
.text$mn:00003854 arg_C           = byte ptr  14h
.text$mn:00003854 arg_18          = dword ptr  20h
.text$mn:00003854
.text$mn:00003854                 push    ebp
.text$mn:00003855                 mov     ebp, esp
.text$mn:00003857                 push    0FFFFFFFFh
.text$mn:00003859                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z
.text$mn:0000385E                 mov     eax, large fs:0
.text$mn:00003864                 push    eax
.text$mn:00003865                 sub     esp, 28h
.text$mn:00003868                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000386D                 xor     eax, ebp
.text$mn:0000386F                 push    eax
.text$mn:00003870                 lea     eax, [ebp+var_C]
.text$mn:00003873                 mov     large fs:0, eax
.text$mn:00003879                 mov     [ebp+var_14], ecx
.text$mn:0000387C                 mov     [ebp+var_4], 1
.text$mn:00003883                 lea     eax, [ebp+var_D]
.text$mn:00003886                 push    eax
.text$mn:00003887                 mov     ecx, [ebp+var_14]
.text$mn:0000388A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000388F                 lea     ecx, [ebp+var_D]
.text$mn:00003892                 push    ecx
.text$mn:00003893                 mov     edx, [ebp+arg_18]
.text$mn:00003896                 push    edx
.text$mn:00003897                 sub     esp, 0Ch
.text$mn:0000389A                 mov     ecx, esp
.text$mn:0000389C                 mov     [ebp+var_28], esp
.text$mn:0000389F                 lea     eax, [ebp+arg_C]
.text$mn:000038A2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000038A3                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>> const &)
.text$mn:000038A8                 mov     [ebp+var_18], eax
.text$mn:000038AB                 mov     ecx, [ebp+var_18]
.text$mn:000038AE                 mov     [ebp+var_2C], ecx
.text$mn:000038B1                 mov     byte ptr [ebp+var_4], 2
.text$mn:000038B5                 sub     esp, 0Ch
.text$mn:000038B8                 mov     ecx, esp
.text$mn:000038BA                 mov     [ebp+var_30], esp
.text$mn:000038BD                 lea     edx, [ebp+arg_0]
.text$mn:000038C0                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000038C1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>> const &)
.text$mn:000038C6                 mov     [ebp+var_1C], eax
.text$mn:000038C9                 mov     eax, [ebp+var_1C]
.text$mn:000038CC                 mov     [ebp+var_34], eax
.text$mn:000038CF                 mov     byte ptr [ebp+var_4], 3
.text$mn:000038D3                 mov     byte ptr [ebp+var_4], 1
.text$mn:000038D7                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:000038DC                 add     esp, 20h
.text$mn:000038DF                 mov     [ebp+var_20], eax
.text$mn:000038E2                 mov     ecx, [ebp+var_20]
.text$mn:000038E5                 mov     [ebp+var_24], ecx
.text$mn:000038E8                 mov     byte ptr [ebp+var_4], 0
.text$mn:000038EC                 lea     ecx, [ebp+arg_0]
.text$mn:000038EF                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$mn:000038F4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000038FB                 lea     ecx, [ebp+arg_C]
.text$mn:000038FE                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$mn:00003903                 mov     eax, [ebp+var_24]
.text$mn:00003906                 mov     ecx, [ebp+var_C]
.text$mn:00003909                 mov     large fs:0, ecx
.text$mn:00003910                 pop     ecx
.text$mn:00003911                 mov     esp, ebp
.text$mn:00003913                 pop     ebp
.text$mn:00003914                 retn    1Ch
.text$mn:00003914 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z endp
.text$mn:00003914
.text$mn:00003914 ; ---------------------------------------------------------------------------
.text$mn:00003917                 align 4
.text$mn:00003917 _text$mn        ends
.text$mn:00003917
.text$x:00003918 ; ===========================================================================
.text$x:00003918
.text$x:00003918 ; Segment type: Pure code
.text$x:00003918 ; Segment permissions: Read/Execute
.text$x:00003918 _text$x         segment para public 'CODE' use32
.text$x:00003918                 assume cs:_text$x
.text$x:00003918                 ;org 3918h
.text$x:00003918 ; COMDAT (pick associative to section at 3854)
.text$x:00003918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003918
.text$x:00003918 ; =============== S U B R O U T I N E =======================================
.text$x:00003918
.text$x:00003918
.text$x:00003918 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$0 proc near
.text$x:00003918                                         ; DATA XREF: .xdata$x:0000E394o
.text$x:00003918                 lea     ecx, [ebp+14h]
.text$x:0000391B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:0000391B __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$0 endp
.text$x:0000391B
.text$x:00003920
.text$x:00003920 ; =============== S U B R O U T I N E =======================================
.text$x:00003920
.text$x:00003920
.text$x:00003920 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$1 proc near
.text$x:00003920                                         ; DATA XREF: .xdata$x:0000E39Co
.text$x:00003920                 lea     ecx, [ebp+8]
.text$x:00003923                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:00003923 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$1 endp
.text$x:00003923
.text$x:00003928
.text$x:00003928 ; =============== S U B R O U T I N E =======================================
.text$x:00003928
.text$x:00003928
.text$x:00003928 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$2 proc near
.text$x:00003928                                         ; DATA XREF: .xdata$x:0000E3A4o
.text$x:00003928                 mov     ecx, [ebp-28h]
.text$x:0000392B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:0000392B __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$2 endp
.text$x:0000392B
.text$x:00003930
.text$x:00003930 ; =============== S U B R O U T I N E =======================================
.text$x:00003930
.text$x:00003930
.text$x:00003930 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$3 proc near
.text$x:00003930                                         ; DATA XREF: .xdata$x:0000E3ACo
.text$x:00003930                 mov     ecx, [ebp-30h]
.text$x:00003933                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:00003933 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$3 endp
.text$x:00003933
.text$x:00003938
.text$x:00003938 ; =============== S U B R O U T I N E =======================================
.text$x:00003938
.text$x:00003938
.text$x:00003938 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z proc near
.text$x:00003938                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)+5o
.text$x:00003938
.text$x:00003938 arg_4           = dword ptr  8
.text$x:00003938
.text$x:00003938                 mov     edx, [esp+arg_4]
.text$x:0000393C                 lea     eax, [edx+0Ch]
.text$x:0000393F                 mov     ecx, [edx-2Ch]
.text$x:00003942                 xor     ecx, eax
.text$x:00003944                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003949                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z
.text$x:0000394E                 jmp     ___CxxFrameHandler3
.text$x:0000394E __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z endp
.text$x:0000394E
.text$x:0000394E ; ---------------------------------------------------------------------------
.text$x:00003953                 align 4
.text$x:00003953 _text$x         ends
.text$x:00003953
.text$mn:00003954 ; ===========================================================================
.text$mn:00003954
.text$mn:00003954 ; Segment type: Pure code
.text$mn:00003954 ; Segment permissions: Read/Execute
.text$mn:00003954 _text$mn        segment para public 'CODE' use32
.text$mn:00003954                 assume cs:_text$mn
.text$mn:00003954                 ;org 3954h
.text$mn:00003954 ; COMDAT (pick any)
.text$mn:00003954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003954
.text$mn:00003954 ; =============== S U B R O U T I N E =======================================
.text$mn:00003954
.text$mn:00003954 ; Attributes: bp-based frame
.text$mn:00003954
.text$mn:00003954 ; protected: struct MenuItemUnit * __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Umove<struct MenuItemUnit *>(struct MenuItemUnit *, struct MenuItemUnit *, struct MenuItemUnit *)
.text$mn:00003954                 public ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z
.text$mn:00003954 ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z proc near
.text$mn:00003954                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+65p
.text$mn:00003954
.text$mn:00003954 var_8           = dword ptr -8
.text$mn:00003954 var_1           = byte ptr -1
.text$mn:00003954 arg_0           = dword ptr  8
.text$mn:00003954 arg_4           = dword ptr  0Ch
.text$mn:00003954 arg_8           = dword ptr  10h
.text$mn:00003954
.text$mn:00003954                 push    ebp
.text$mn:00003955                 mov     ebp, esp
.text$mn:00003957                 sub     esp, 8
.text$mn:0000395A                 mov     [ebp+var_8], ecx
.text$mn:0000395D                 lea     eax, [ebp+var_1]
.text$mn:00003960                 push    eax
.text$mn:00003961                 mov     ecx, [ebp+var_8]
.text$mn:00003964                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:00003969                 lea     ecx, [ebp+var_1]
.text$mn:0000396C                 push    ecx
.text$mn:0000396D                 mov     edx, [ebp+arg_8]
.text$mn:00003970                 push    edx
.text$mn:00003971                 mov     eax, [ebp+arg_4]
.text$mn:00003974                 push    eax
.text$mn:00003975                 mov     ecx, [ebp+arg_0]
.text$mn:00003978                 push    ecx
.text$mn:00003979                 call    ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z ; std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)
.text$mn:0000397E                 add     esp, 10h
.text$mn:00003981                 mov     esp, ebp
.text$mn:00003983                 pop     ebp
.text$mn:00003984                 retn    0Ch
.text$mn:00003984 ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z endp
.text$mn:00003984
.text$mn:00003984 ; ---------------------------------------------------------------------------
.text$mn:00003987                 align 4
.text$mn:00003987 _text$mn        ends
.text$mn:00003987
.text$mn:00003988 ; ===========================================================================
.text$mn:00003988
.text$mn:00003988 ; Segment type: Pure code
.text$mn:00003988 ; Segment permissions: Read/Execute
.text$mn:00003988 _text$mn        segment para public 'CODE' use32
.text$mn:00003988                 assume cs:_text$mn
.text$mn:00003988                 ;org 3988h
.text$mn:00003988 ; COMDAT (pick any)
.text$mn:00003988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003988
.text$mn:00003988 ; =============== S U B R O U T I N E =======================================
.text$mn:00003988
.text$mn:00003988 ; Attributes: bp-based frame
.text$mn:00003988
.text$mn:00003988 ; struct KeyCombo * __cdecl std::_Unchecked<struct KeyCombo *>(struct KeyCombo *)
.text$mn:00003988                 public ??$_Unchecked@PAUKeyCombo@@@std@@YAPAUKeyCombo@@PAU1@@Z
.text$mn:00003988 ??$_Unchecked@PAUKeyCombo@@@std@@YAPAUKeyCombo@@PAU1@@Z proc near
.text$mn:00003988                                         ; CODE XREF: std::_Uninitialized_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+Bp
.text$mn:00003988                                         ; std::_Uninitialized_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+18p ...
.text$mn:00003988
.text$mn:00003988 arg_0           = dword ptr  8
.text$mn:00003988
.text$mn:00003988                 push    ebp
.text$mn:00003989                 mov     ebp, esp
.text$mn:0000398B                 mov     eax, [ebp+arg_0]
.text$mn:0000398E                 pop     ebp
.text$mn:0000398F                 retn
.text$mn:0000398F ??$_Unchecked@PAUKeyCombo@@@std@@YAPAUKeyCombo@@PAU1@@Z endp
.text$mn:0000398F
.text$mn:0000398F _text$mn        ends
.text$mn:0000398F
.text$mn:00003990 ; ===========================================================================
.text$mn:00003990
.text$mn:00003990 ; Segment type: Pure code
.text$mn:00003990 ; Segment permissions: Read/Execute
.text$mn:00003990 _text$mn        segment para public 'CODE' use32
.text$mn:00003990                 assume cs:_text$mn
.text$mn:00003990                 ;org 3990h
.text$mn:00003990 ; COMDAT (pick any)
.text$mn:00003990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003990
.text$mn:00003990 ; =============== S U B R O U T I N E =======================================
.text$mn:00003990
.text$mn:00003990 ; Attributes: bp-based frame
.text$mn:00003990
.text$mn:00003990 ; struct MenuItemUnit * __cdecl std::_Unchecked<struct MenuItemUnit *>(struct MenuItemUnit *)
.text$mn:00003990                 public ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z
.text$mn:00003990 ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z proc near
.text$mn:00003990                                         ; CODE XREF: std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+Bp
.text$mn:00003990                                         ; std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+18p ...
.text$mn:00003990
.text$mn:00003990 arg_0           = dword ptr  8
.text$mn:00003990
.text$mn:00003990                 push    ebp
.text$mn:00003991                 mov     ebp, esp
.text$mn:00003993                 mov     eax, [ebp+arg_0]
.text$mn:00003996                 pop     ebp
.text$mn:00003997                 retn
.text$mn:00003997 ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z endp
.text$mn:00003997
.text$mn:00003997 _text$mn        ends
.text$mn:00003997
.text$mn:00003998 ; ===========================================================================
.text$mn:00003998
.text$mn:00003998 ; Segment type: Pure code
.text$mn:00003998 ; Segment permissions: Read/Execute
.text$mn:00003998 _text$mn        segment para public 'CODE' use32
.text$mn:00003998                 assume cs:_text$mn
.text$mn:00003998                 ;org 3998h
.text$mn:00003998 ; COMDAT (pick any)
.text$mn:00003998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003998
.text$mn:00003998 ; =============== S U B R O U T I N E =======================================
.text$mn:00003998
.text$mn:00003998 ; Attributes: bp-based frame
.text$mn:00003998
.text$mn:00003998 ; struct recordedMacroStep * __cdecl std::_Unchecked<struct recordedMacroStep *>(struct recordedMacroStep *)
.text$mn:00003998                 public ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z
.text$mn:00003998 ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z proc near
.text$mn:00003998                                         ; CODE XREF: std::_Uninitialized_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+Bp
.text$mn:00003998                                         ; std::_Uninitialized_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+18p ...
.text$mn:00003998
.text$mn:00003998 arg_0           = dword ptr  8
.text$mn:00003998
.text$mn:00003998                 push    ebp
.text$mn:00003999                 mov     ebp, esp
.text$mn:0000399B                 mov     eax, [ebp+arg_0]
.text$mn:0000399E                 pop     ebp
.text$mn:0000399F                 retn
.text$mn:0000399F ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z endp
.text$mn:0000399F
.text$mn:0000399F _text$mn        ends
.text$mn:0000399F
.text$mn:000039A0 ; ===========================================================================
.text$mn:000039A0
.text$mn:000039A0 ; Segment type: Pure code
.text$mn:000039A0 ; Segment permissions: Read/Execute
.text$mn:000039A0 _text$mn        segment para public 'CODE' use32
.text$mn:000039A0                 assume cs:_text$mn
.text$mn:000039A0                 ;org 39A0h
.text$mn:000039A0 ; COMDAT (pick any)
.text$mn:000039A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039A0
.text$mn:000039A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000039A0
.text$mn:000039A0 ; Attributes: bp-based frame
.text$mn:000039A0
.text$mn:000039A0 ; struct KeyCombo const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>)
.text$mn:000039A0                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z
.text$mn:000039A0 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z proc near
.text$mn:000039A0                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+5Fp
.text$mn:000039A0                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+90p
.text$mn:000039A0
.text$mn:000039A0 var_10          = dword ptr -10h
.text$mn:000039A0 var_C           = dword ptr -0Ch
.text$mn:000039A0 var_4           = dword ptr -4
.text$mn:000039A0 arg_0           = byte ptr  8
.text$mn:000039A0
.text$mn:000039A0                 push    ebp
.text$mn:000039A1                 mov     ebp, esp
.text$mn:000039A3                 push    0FFFFFFFFh
.text$mn:000039A5                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z
.text$mn:000039AA                 mov     eax, large fs:0
.text$mn:000039B0                 push    eax
.text$mn:000039B1                 push    ecx
.text$mn:000039B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000039B7                 xor     eax, ebp
.text$mn:000039B9                 push    eax
.text$mn:000039BA                 lea     eax, [ebp+var_C]
.text$mn:000039BD                 mov     large fs:0, eax
.text$mn:000039C3                 mov     [ebp+var_4], 0
.text$mn:000039CA                 lea     ecx, [ebp+arg_0]
.text$mn:000039CD                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QBEPBUKeyCombo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Unchecked(void)
.text$mn:000039D2                 mov     [ebp+var_10], eax
.text$mn:000039D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039DC                 lea     ecx, [ebp+arg_0]
.text$mn:000039DF                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$mn:000039E4                 mov     eax, [ebp+var_10]
.text$mn:000039E7                 mov     ecx, [ebp+var_C]
.text$mn:000039EA                 mov     large fs:0, ecx
.text$mn:000039F1                 pop     ecx
.text$mn:000039F2                 mov     esp, ebp
.text$mn:000039F4                 pop     ebp
.text$mn:000039F5                 retn
.text$mn:000039F5 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z endp
.text$mn:000039F5
.text$mn:000039F5 ; ---------------------------------------------------------------------------
.text$mn:000039F6                 align 4
.text$mn:000039F6 _text$mn        ends
.text$mn:000039F6
.text$x:000039F8 ; ===========================================================================
.text$x:000039F8
.text$x:000039F8 ; Segment type: Pure code
.text$x:000039F8 ; Segment permissions: Read/Execute
.text$x:000039F8 _text$x         segment para public 'CODE' use32
.text$x:000039F8                 assume cs:_text$x
.text$x:000039F8                 ;org 39F8h
.text$x:000039F8 ; COMDAT (pick associative to section at 39A0)
.text$x:000039F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039F8
.text$x:000039F8 ; =============== S U B R O U T I N E =======================================
.text$x:000039F8
.text$x:000039F8
.text$x:000039F8 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z$0 proc near
.text$x:000039F8                                         ; DATA XREF: .xdata$x:0000E48Co
.text$x:000039F8                 lea     ecx, [ebp+8]
.text$x:000039FB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:000039FB __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z$0 endp
.text$x:000039FB
.text$x:00003A00
.text$x:00003A00 ; =============== S U B R O U T I N E =======================================
.text$x:00003A00
.text$x:00003A00
.text$x:00003A00 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z proc near
.text$x:00003A00                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>)+5o
.text$x:00003A00
.text$x:00003A00 arg_4           = dword ptr  8
.text$x:00003A00
.text$x:00003A00                 mov     edx, [esp+arg_4]
.text$x:00003A04                 lea     eax, [edx+0Ch]
.text$x:00003A07                 mov     ecx, [edx-8]
.text$x:00003A0A                 xor     ecx, eax
.text$x:00003A0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A11                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z
.text$x:00003A16                 jmp     ___CxxFrameHandler3
.text$x:00003A16 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z endp
.text$x:00003A16
.text$x:00003A16 ; ---------------------------------------------------------------------------
.text$x:00003A1B                 align 4
.text$x:00003A1B _text$x         ends
.text$x:00003A1B
.text$mn:00003A1C ; ===========================================================================
.text$mn:00003A1C
.text$mn:00003A1C ; Segment type: Pure code
.text$mn:00003A1C ; Segment permissions: Read/Execute
.text$mn:00003A1C _text$mn        segment para public 'CODE' use32
.text$mn:00003A1C                 assume cs:_text$mn
.text$mn:00003A1C                 ;org 3A1Ch
.text$mn:00003A1C ; COMDAT (pick any)
.text$mn:00003A1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A1C
.text$mn:00003A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A1C
.text$mn:00003A1C ; Attributes: bp-based frame
.text$mn:00003A1C
.text$mn:00003A1C ; struct recordedMacroStep const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>)
.text$mn:00003A1C                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z
.text$mn:00003A1C ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z proc near
.text$mn:00003A1C                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+5Fp
.text$mn:00003A1C                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+90p
.text$mn:00003A1C
.text$mn:00003A1C var_10          = dword ptr -10h
.text$mn:00003A1C var_C           = dword ptr -0Ch
.text$mn:00003A1C var_4           = dword ptr -4
.text$mn:00003A1C arg_0           = byte ptr  8
.text$mn:00003A1C
.text$mn:00003A1C                 push    ebp
.text$mn:00003A1D                 mov     ebp, esp
.text$mn:00003A1F                 push    0FFFFFFFFh
.text$mn:00003A21                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z
.text$mn:00003A26                 mov     eax, large fs:0
.text$mn:00003A2C                 push    eax
.text$mn:00003A2D                 push    ecx
.text$mn:00003A2E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A33                 xor     eax, ebp
.text$mn:00003A35                 push    eax
.text$mn:00003A36                 lea     eax, [ebp+var_C]
.text$mn:00003A39                 mov     large fs:0, eax
.text$mn:00003A3F                 mov     [ebp+var_4], 0
.text$mn:00003A46                 lea     ecx, [ebp+arg_0]
.text$mn:00003A49                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QBEPBUrecordedMacroStep@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Unchecked(void)
.text$mn:00003A4E                 mov     [ebp+var_10], eax
.text$mn:00003A51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A58                 lea     ecx, [ebp+arg_0]
.text$mn:00003A5B                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$mn:00003A60                 mov     eax, [ebp+var_10]
.text$mn:00003A63                 mov     ecx, [ebp+var_C]
.text$mn:00003A66                 mov     large fs:0, ecx
.text$mn:00003A6D                 pop     ecx
.text$mn:00003A6E                 mov     esp, ebp
.text$mn:00003A70                 pop     ebp
.text$mn:00003A71                 retn
.text$mn:00003A71 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z endp
.text$mn:00003A71
.text$mn:00003A71 ; ---------------------------------------------------------------------------
.text$mn:00003A72                 align 4
.text$mn:00003A72 _text$mn        ends
.text$mn:00003A72
.text$x:00003A74 ; ===========================================================================
.text$x:00003A74
.text$x:00003A74 ; Segment type: Pure code
.text$x:00003A74 ; Segment permissions: Read/Execute
.text$x:00003A74 _text$x         segment para public 'CODE' use32
.text$x:00003A74                 assume cs:_text$x
.text$x:00003A74                 ;org 3A74h
.text$x:00003A74 ; COMDAT (pick associative to section at 3A1C)
.text$x:00003A74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003A74
.text$x:00003A74 ; =============== S U B R O U T I N E =======================================
.text$x:00003A74
.text$x:00003A74
.text$x:00003A74 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z$0 proc near
.text$x:00003A74                                         ; DATA XREF: .xdata$x:0000E4E4o
.text$x:00003A74                 lea     ecx, [ebp+8]
.text$x:00003A77                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:00003A77 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z$0 endp
.text$x:00003A77
.text$x:00003A7C
.text$x:00003A7C ; =============== S U B R O U T I N E =======================================
.text$x:00003A7C
.text$x:00003A7C
.text$x:00003A7C __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z proc near
.text$x:00003A7C                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>)+5o
.text$x:00003A7C
.text$x:00003A7C arg_4           = dword ptr  8
.text$x:00003A7C
.text$x:00003A7C                 mov     edx, [esp+arg_4]
.text$x:00003A80                 lea     eax, [edx+0Ch]
.text$x:00003A83                 mov     ecx, [edx-8]
.text$x:00003A86                 xor     ecx, eax
.text$x:00003A88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A8D                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z
.text$x:00003A92                 jmp     ___CxxFrameHandler3
.text$x:00003A92 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z endp
.text$x:00003A92
.text$x:00003A92 ; ---------------------------------------------------------------------------
.text$x:00003A97                 align 4
.text$x:00003A97 _text$x         ends
.text$x:00003A97
.text$mn:00003A98 ; ===========================================================================
.text$mn:00003A98
.text$mn:00003A98 ; Segment type: Pure code
.text$mn:00003A98 ; Segment permissions: Read/Execute
.text$mn:00003A98 _text$mn        segment para public 'CODE' use32
.text$mn:00003A98                 assume cs:_text$mn
.text$mn:00003A98                 ;org 3A98h
.text$mn:00003A98 ; COMDAT (pick any)
.text$mn:00003A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A98
.text$mn:00003A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A98
.text$mn:00003A98 ; Attributes: bp-based frame
.text$mn:00003A98
.text$mn:00003A98 ; int __cdecl std::_Uninit_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(int, int, void *, int)
.text$mn:00003A98                 public ??$_Uninit_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.text$mn:00003A98 ??$_Uninit_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z proc near
.text$mn:00003A98                                         ; CODE XREF: std::_Uninitialized_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+2Ep
.text$mn:00003A98
.text$mn:00003A98 var_1           = byte ptr -1
.text$mn:00003A98 arg_0           = dword ptr  8
.text$mn:00003A98 arg_4           = dword ptr  0Ch
.text$mn:00003A98 arg_8           = dword ptr  10h
.text$mn:00003A98 arg_C           = dword ptr  14h
.text$mn:00003A98
.text$mn:00003A98                 push    ebp
.text$mn:00003A99                 mov     ebp, esp
.text$mn:00003A9B                 push    ecx
.text$mn:00003A9C                 mov     eax, [ebp+arg_8]
.text$mn:00003A9F                 push    eax
.text$mn:00003AA0                 mov     ecx, [ebp+arg_0]
.text$mn:00003AA3                 push    ecx
.text$mn:00003AA4                 call    ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUKeyCombo@@0@Z ; std::_Ptr_cat<KeyCombo,KeyCombo>(KeyCombo *,KeyCombo *)
.text$mn:00003AA9                 add     esp, 8
.text$mn:00003AAC                 mov     [ebp+var_1], al
.text$mn:00003AAF                 movzx   edx, [ebp+var_1]
.text$mn:00003AB3                 push    edx
.text$mn:00003AB4                 mov     eax, [ebp+arg_C]
.text$mn:00003AB7                 push    eax             ; int
.text$mn:00003AB8                 mov     ecx, [ebp+arg_8]
.text$mn:00003ABB                 push    ecx             ; void *
.text$mn:00003ABC                 mov     edx, [ebp+arg_4]
.text$mn:00003ABF                 push    edx             ; int
.text$mn:00003AC0                 mov     eax, [ebp+arg_0]
.text$mn:00003AC3                 push    eax             ; int
.text$mn:00003AC4                 call    ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003AC9                 add     esp, 14h
.text$mn:00003ACC                 mov     esp, ebp
.text$mn:00003ACE                 pop     ebp
.text$mn:00003ACF                 retn
.text$mn:00003ACF ??$_Uninit_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z endp
.text$mn:00003ACF
.text$mn:00003ACF _text$mn        ends
.text$mn:00003ACF
.text$mn:00003AD0 ; ===========================================================================
.text$mn:00003AD0
.text$mn:00003AD0 ; Segment type: Pure code
.text$mn:00003AD0 ; Segment permissions: Read/Execute
.text$mn:00003AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00003AD0                 assume cs:_text$mn
.text$mn:00003AD0                 ;org 3AD0h
.text$mn:00003AD0 ; COMDAT (pick any)
.text$mn:00003AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AD0
.text$mn:00003AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AD0
.text$mn:00003AD0 ; Attributes: bp-based frame
.text$mn:00003AD0
.text$mn:00003AD0 ; int __cdecl std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(int, int, void *, int)
.text$mn:00003AD0                 public ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003AD0 ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003AD0                                         ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+2Cp
.text$mn:00003AD0
.text$mn:00003AD0 var_14          = dword ptr -14h
.text$mn:00003AD0 var_10          = dword ptr -10h
.text$mn:00003AD0 var_C           = dword ptr -0Ch
.text$mn:00003AD0 var_4           = dword ptr -4
.text$mn:00003AD0 arg_0           = dword ptr  8
.text$mn:00003AD0 arg_4           = dword ptr  0Ch
.text$mn:00003AD0 arg_8           = dword ptr  10h
.text$mn:00003AD0 arg_C           = dword ptr  14h
.text$mn:00003AD0
.text$mn:00003AD0 ; FUNCTION CHUNK AT .text$mn:00003B97 SIZE 00000009 BYTES
.text$mn:00003AD0 ; FUNCTION CHUNK AT .text$mn:00003BA7 SIZE 00000015 BYTES
.text$mn:00003AD0
.text$mn:00003AD0                 push    ebp
.text$mn:00003AD1                 mov     ebp, esp
.text$mn:00003AD3                 push    0FFFFFFFFh
.text$mn:00003AD5                 push    offset __ehhandler$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003ADA                 mov     eax, large fs:0
.text$mn:00003AE0                 push    eax
.text$mn:00003AE1                 push    ecx
.text$mn:00003AE2                 push    ecx
.text$mn:00003AE3                 push    ebx
.text$mn:00003AE4                 push    esi
.text$mn:00003AE5                 push    edi
.text$mn:00003AE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AEB                 xor     eax, ebp
.text$mn:00003AED                 push    eax
.text$mn:00003AEE                 lea     eax, [ebp+var_C]
.text$mn:00003AF1                 mov     large fs:0, eax
.text$mn:00003AF7                 mov     [ebp+var_10], esp
.text$mn:00003AFA                 push    174h            ; unsigned int
.text$mn:00003AFF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003B04                 mov     eax, [ebp+arg_4]
.text$mn:00003B07                 push    eax             ; int
.text$mn:00003B08                 mov     ecx, [ebp+arg_0]
.text$mn:00003B0B                 push    ecx             ; int
.text$mn:00003B0C                 call    ??$_Debug_range@PAUKeyCombo@@@std@@YAXPAUKeyCombo@@0PB_WI@Z ; std::_Debug_range<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint)
.text$mn:00003B11                 add     esp, 10h
.text$mn:00003B14                 push    175h            ; unsigned int
.text$mn:00003B19                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003B1E                 mov     edx, [ebp+arg_8]
.text$mn:00003B21                 push    edx             ; int
.text$mn:00003B22                 call    ??$_Debug_pointer@UKeyCombo@@@std@@YAXPAUKeyCombo@@PB_WI@Z ; std::_Debug_pointer<KeyCombo>(KeyCombo *,wchar_t const *,uint)
.text$mn:00003B27                 add     esp, 0Ch
.text$mn:00003B2A                 mov     eax, [ebp+arg_8]
.text$mn:00003B2D                 mov     [ebp+var_14], eax
.text$mn:00003B30                 mov     [ebp+var_4], 0
.text$mn:00003B37                 jmp     short loc_3B4B
.text$mn:00003B39 ; ---------------------------------------------------------------------------
.text$mn:00003B39
.text$mn:00003B39 loc_3B39:                               ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00003B39                 mov     ecx, [ebp+arg_8]
.text$mn:00003B3C                 add     ecx, 4
.text$mn:00003B3F                 mov     [ebp+arg_8], ecx
.text$mn:00003B42                 mov     edx, [ebp+arg_0]
.text$mn:00003B45                 add     edx, 4
.text$mn:00003B48                 mov     [ebp+arg_0], edx
.text$mn:00003B4B
.text$mn:00003B4B loc_3B4B:                               ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00003B4B                 mov     eax, [ebp+arg_0]
.text$mn:00003B4E                 cmp     eax, [ebp+arg_4]
.text$mn:00003B51                 jz      short loc_3B65
.text$mn:00003B53                 mov     ecx, [ebp+arg_0]
.text$mn:00003B56                 push    ecx             ; int
.text$mn:00003B57                 mov     edx, [ebp+arg_8]
.text$mn:00003B5A                 push    edx             ; void *
.text$mn:00003B5B                 mov     ecx, [ebp+arg_C]
.text$mn:00003B5E                 call    ??$construct@UKeyCombo@@AAU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)
.text$mn:00003B63                 jmp     short loc_3B39
.text$mn:00003B65 ; ---------------------------------------------------------------------------
.text$mn:00003B65
.text$mn:00003B65 loc_3B65:                               ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00003B65                 jmp     short loc_3B97
.text$mn:00003B65 ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003B65
.text$mn:00003B67
.text$mn:00003B67 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B67
.text$mn:00003B67 ; Attributes: noreturn
.text$mn:00003B67
.text$mn:00003B67 __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00003B67                                         ; DATA XREF: .xdata$x:0000E5F4o
.text$mn:00003B67                 jmp     short loc_3B72
.text$mn:00003B69 ; ---------------------------------------------------------------------------
.text$mn:00003B69
.text$mn:00003B69 loc_3B69:                               ; CODE XREF: __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00003B69                 mov     eax, [ebp-14h]
.text$mn:00003B6C                 add     eax, 4
.text$mn:00003B6F                 mov     [ebp-14h], eax
.text$mn:00003B72
.text$mn:00003B72 loc_3B72:                               ; CODE XREF: __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00003B72                 mov     ecx, [ebp-14h]
.text$mn:00003B75                 cmp     ecx, [ebp+10h]
.text$mn:00003B78                 jz      short loc_3B88
.text$mn:00003B7A                 mov     edx, [ebp-14h]
.text$mn:00003B7D                 push    edx
.text$mn:00003B7E                 mov     ecx, [ebp+14h]
.text$mn:00003B81                 call    ??$destroy@UKeyCombo@@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::destroy<KeyCombo>(KeyCombo *)
.text$mn:00003B86                 jmp     short loc_3B69
.text$mn:00003B88 ; ---------------------------------------------------------------------------
.text$mn:00003B88
.text$mn:00003B88 loc_3B88:                               ; CODE XREF: __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00003B88                 push    0
.text$mn:00003B8A                 push    0
.text$mn:00003B8C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003B8C __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00003B8C
.text$mn:00003B91 ; ---------------------------------------------------------------------------
.text$mn:00003B91                 mov     eax, offset $LN13_0
.text$mn:00003B96                 retn
.text$mn:00003B97 ; ---------------------------------------------------------------------------
.text$mn:00003B97 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003B97
.text$mn:00003B97 loc_3B97:                               ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag):loc_3B65j
.text$mn:00003B97                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B9E                 jmp     short loc_3BA7
.text$mn:00003B9E ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003BA0
.text$mn:00003BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BA0
.text$mn:00003BA0
.text$mn:00003BA0 $LN13_0         proc near               ; DATA XREF: .text$mn:00003B91o
.text$mn:00003BA0                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003BA0 $LN13_0         endp ; sp-analysis failed
.text$mn:00003BA0
.text$mn:00003BA7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003BA7
.text$mn:00003BA7 loc_3BA7:                               ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00003BA7                 mov     eax, [ebp+arg_8]
.text$mn:00003BAA                 mov     ecx, [ebp+var_C]
.text$mn:00003BAD                 mov     large fs:0, ecx
.text$mn:00003BB4                 pop     ecx
.text$mn:00003BB5                 pop     edi
.text$mn:00003BB6                 pop     esi
.text$mn:00003BB7                 pop     ebx
.text$mn:00003BB8                 mov     esp, ebp
.text$mn:00003BBA                 pop     ebp
.text$mn:00003BBB                 retn
.text$mn:00003BBB ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003BBB _text$mn        ends
.text$mn:00003BBB
.text$x:00003BBC ; ===========================================================================
.text$x:00003BBC
.text$x:00003BBC ; Segment type: Pure code
.text$x:00003BBC ; Segment permissions: Read/Execute
.text$x:00003BBC _text$x         segment para public 'CODE' use32
.text$x:00003BBC                 assume cs:_text$x
.text$x:00003BBC                 ;org 3BBCh
.text$x:00003BBC ; COMDAT (pick associative to section at 3AD0)
.text$x:00003BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BBC
.text$x:00003BBC ; =============== S U B R O U T I N E =======================================
.text$x:00003BBC
.text$x:00003BBC
.text$x:00003BBC __ehhandler$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00003BBC                                         ; DATA XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00003BBC
.text$x:00003BBC arg_4           = dword ptr  8
.text$x:00003BBC
.text$x:00003BBC                 mov     edx, [esp+arg_4]
.text$x:00003BC0                 lea     eax, [edx+0Ch]
.text$x:00003BC3                 mov     ecx, [edx-18h]
.text$x:00003BC6                 xor     ecx, eax
.text$x:00003BC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BCD                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00003BD2                 jmp     ___CxxFrameHandler3
.text$x:00003BD2 __ehhandler$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00003BD2
.text$x:00003BD2 ; ---------------------------------------------------------------------------
.text$x:00003BD7                 align 4
.text$x:00003BD7 _text$x         ends
.text$x:00003BD7
.text$mn:00003BD8 ; ===========================================================================
.text$mn:00003BD8
.text$mn:00003BD8 ; Segment type: Pure code
.text$mn:00003BD8 ; Segment permissions: Read/Execute
.text$mn:00003BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00003BD8                 assume cs:_text$mn
.text$mn:00003BD8                 ;org 3BD8h
.text$mn:00003BD8 ; COMDAT (pick any)
.text$mn:00003BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BD8
.text$mn:00003BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BD8
.text$mn:00003BD8 ; Attributes: bp-based frame
.text$mn:00003BD8
.text$mn:00003BD8 ; int __cdecl std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(int, int, void *, int)
.text$mn:00003BD8                 public ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:00003BD8 ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:00003BD8                                         ; CODE XREF: std::_Uninitialized_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+2Ep
.text$mn:00003BD8
.text$mn:00003BD8 var_1           = byte ptr -1
.text$mn:00003BD8 arg_0           = dword ptr  8
.text$mn:00003BD8 arg_4           = dword ptr  0Ch
.text$mn:00003BD8 arg_8           = dword ptr  10h
.text$mn:00003BD8 arg_C           = dword ptr  14h
.text$mn:00003BD8
.text$mn:00003BD8                 push    ebp
.text$mn:00003BD9                 mov     ebp, esp
.text$mn:00003BDB                 push    ecx
.text$mn:00003BDC                 mov     eax, [ebp+arg_8]
.text$mn:00003BDF                 push    eax
.text$mn:00003BE0                 mov     ecx, [ebp+arg_0]
.text$mn:00003BE3                 push    ecx
.text$mn:00003BE4                 call    ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z ; std::_Ptr_cat<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *)
.text$mn:00003BE9                 add     esp, 8
.text$mn:00003BEC                 mov     [ebp+var_1], al
.text$mn:00003BEF                 movzx   edx, [ebp+var_1]
.text$mn:00003BF3                 push    edx
.text$mn:00003BF4                 mov     eax, [ebp+arg_C]
.text$mn:00003BF7                 push    eax             ; int
.text$mn:00003BF8                 mov     ecx, [ebp+arg_8]
.text$mn:00003BFB                 push    ecx             ; void *
.text$mn:00003BFC                 mov     edx, [ebp+arg_4]
.text$mn:00003BFF                 push    edx             ; int
.text$mn:00003C00                 mov     eax, [ebp+arg_0]
.text$mn:00003C03                 push    eax             ; int
.text$mn:00003C04                 call    ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003C09                 add     esp, 14h
.text$mn:00003C0C                 mov     esp, ebp
.text$mn:00003C0E                 pop     ebp
.text$mn:00003C0F                 retn
.text$mn:00003C0F ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:00003C0F
.text$mn:00003C0F _text$mn        ends
.text$mn:00003C0F
.text$mn:00003C10 ; ===========================================================================
.text$mn:00003C10
.text$mn:00003C10 ; Segment type: Pure code
.text$mn:00003C10 ; Segment permissions: Read/Execute
.text$mn:00003C10 _text$mn        segment para public 'CODE' use32
.text$mn:00003C10                 assume cs:_text$mn
.text$mn:00003C10                 ;org 3C10h
.text$mn:00003C10 ; COMDAT (pick any)
.text$mn:00003C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C10
.text$mn:00003C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C10
.text$mn:00003C10 ; Attributes: bp-based frame
.text$mn:00003C10
.text$mn:00003C10 ; int __cdecl std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(int, int, void *, int)
.text$mn:00003C10                 public ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003C10 ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003C10                                         ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+2Cp
.text$mn:00003C10
.text$mn:00003C10 var_14          = dword ptr -14h
.text$mn:00003C10 var_10          = dword ptr -10h
.text$mn:00003C10 var_C           = dword ptr -0Ch
.text$mn:00003C10 var_4           = dword ptr -4
.text$mn:00003C10 arg_0           = dword ptr  8
.text$mn:00003C10 arg_4           = dword ptr  0Ch
.text$mn:00003C10 arg_8           = dword ptr  10h
.text$mn:00003C10 arg_C           = dword ptr  14h
.text$mn:00003C10
.text$mn:00003C10 ; FUNCTION CHUNK AT .text$mn:00003CD7 SIZE 00000009 BYTES
.text$mn:00003C10 ; FUNCTION CHUNK AT .text$mn:00003CE7 SIZE 00000015 BYTES
.text$mn:00003C10
.text$mn:00003C10                 push    ebp
.text$mn:00003C11                 mov     ebp, esp
.text$mn:00003C13                 push    0FFFFFFFFh
.text$mn:00003C15                 push    offset __ehhandler$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003C1A                 mov     eax, large fs:0
.text$mn:00003C20                 push    eax
.text$mn:00003C21                 push    ecx
.text$mn:00003C22                 push    ecx
.text$mn:00003C23                 push    ebx
.text$mn:00003C24                 push    esi
.text$mn:00003C25                 push    edi
.text$mn:00003C26                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C2B                 xor     eax, ebp
.text$mn:00003C2D                 push    eax
.text$mn:00003C2E                 lea     eax, [ebp+var_C]
.text$mn:00003C31                 mov     large fs:0, eax
.text$mn:00003C37                 mov     [ebp+var_10], esp
.text$mn:00003C3A                 push    174h            ; unsigned int
.text$mn:00003C3F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003C44                 mov     eax, [ebp+arg_4]
.text$mn:00003C47                 push    eax             ; int
.text$mn:00003C48                 mov     ecx, [ebp+arg_0]
.text$mn:00003C4B                 push    ecx             ; int
.text$mn:00003C4C                 call    ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z ; std::_Debug_range<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint)
.text$mn:00003C51                 add     esp, 10h
.text$mn:00003C54                 push    175h            ; unsigned int
.text$mn:00003C59                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003C5E                 mov     edx, [ebp+arg_8]
.text$mn:00003C61                 push    edx             ; int
.text$mn:00003C62                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)
.text$mn:00003C67                 add     esp, 0Ch
.text$mn:00003C6A                 mov     eax, [ebp+arg_8]
.text$mn:00003C6D                 mov     [ebp+var_14], eax
.text$mn:00003C70                 mov     [ebp+var_4], 0
.text$mn:00003C77                 jmp     short loc_3C8B
.text$mn:00003C79 ; ---------------------------------------------------------------------------
.text$mn:00003C79
.text$mn:00003C79 loc_3C79:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00003C79                 mov     ecx, [ebp+arg_8]
.text$mn:00003C7C                 add     ecx, 2Ch ; ','
.text$mn:00003C7F                 mov     [ebp+arg_8], ecx
.text$mn:00003C82                 mov     edx, [ebp+arg_0]
.text$mn:00003C85                 add     edx, 2Ch ; ','
.text$mn:00003C88                 mov     [ebp+arg_0], edx
.text$mn:00003C8B
.text$mn:00003C8B loc_3C8B:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00003C8B                 mov     eax, [ebp+arg_0]
.text$mn:00003C8E                 cmp     eax, [ebp+arg_4]
.text$mn:00003C91                 jz      short loc_3CA5
.text$mn:00003C93                 mov     ecx, [ebp+arg_0]
.text$mn:00003C96                 push    ecx             ; int
.text$mn:00003C97                 mov     edx, [ebp+arg_8]
.text$mn:00003C9A                 push    edx             ; void *
.text$mn:00003C9B                 mov     ecx, [ebp+arg_C]
.text$mn:00003C9E                 call    ??$construct@UrecordedMacroStep@@AAU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)
.text$mn:00003CA3                 jmp     short loc_3C79
.text$mn:00003CA5 ; ---------------------------------------------------------------------------
.text$mn:00003CA5
.text$mn:00003CA5 loc_3CA5:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00003CA5                 jmp     short loc_3CD7
.text$mn:00003CA5 ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003CA5
.text$mn:00003CA7
.text$mn:00003CA7 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA7
.text$mn:00003CA7 ; Attributes: noreturn
.text$mn:00003CA7
.text$mn:00003CA7 __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00003CA7                                         ; DATA XREF: .xdata$x:0000E6A4o
.text$mn:00003CA7                 jmp     short loc_3CB2
.text$mn:00003CA9 ; ---------------------------------------------------------------------------
.text$mn:00003CA9
.text$mn:00003CA9 loc_3CA9:                               ; CODE XREF: __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00003CA9                 mov     eax, [ebp-14h]
.text$mn:00003CAC                 add     eax, 2Ch ; ','
.text$mn:00003CAF                 mov     [ebp-14h], eax
.text$mn:00003CB2
.text$mn:00003CB2 loc_3CB2:                               ; CODE XREF: __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00003CB2                 mov     ecx, [ebp-14h]
.text$mn:00003CB5                 cmp     ecx, [ebp+10h]
.text$mn:00003CB8                 jz      short loc_3CC8
.text$mn:00003CBA                 mov     edx, [ebp-14h]
.text$mn:00003CBD                 push    edx
.text$mn:00003CBE                 mov     ecx, [ebp+14h]
.text$mn:00003CC1                 call    ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(recordedMacroStep *)
.text$mn:00003CC6                 jmp     short loc_3CA9
.text$mn:00003CC8 ; ---------------------------------------------------------------------------
.text$mn:00003CC8
.text$mn:00003CC8 loc_3CC8:                               ; CODE XREF: __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00003CC8                 push    0
.text$mn:00003CCA                 push    0
.text$mn:00003CCC                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003CCC __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00003CCC
.text$mn:00003CD1 ; ---------------------------------------------------------------------------
.text$mn:00003CD1                 mov     eax, offset $LN13_2
.text$mn:00003CD6                 retn
.text$mn:00003CD7 ; ---------------------------------------------------------------------------
.text$mn:00003CD7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003CD7
.text$mn:00003CD7 loc_3CD7:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag):loc_3CA5j
.text$mn:00003CD7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003CDE                 jmp     short loc_3CE7
.text$mn:00003CDE ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003CE0
.text$mn:00003CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CE0
.text$mn:00003CE0
.text$mn:00003CE0 $LN13_2         proc near               ; DATA XREF: .text$mn:00003CD1o
.text$mn:00003CE0                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003CE0 $LN13_2         endp ; sp-analysis failed
.text$mn:00003CE0
.text$mn:00003CE7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003CE7
.text$mn:00003CE7 loc_3CE7:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00003CE7                 mov     eax, [ebp+arg_8]
.text$mn:00003CEA                 mov     ecx, [ebp+var_C]
.text$mn:00003CED                 mov     large fs:0, ecx
.text$mn:00003CF4                 pop     ecx
.text$mn:00003CF5                 pop     edi
.text$mn:00003CF6                 pop     esi
.text$mn:00003CF7                 pop     ebx
.text$mn:00003CF8                 mov     esp, ebp
.text$mn:00003CFA                 pop     ebp
.text$mn:00003CFB                 retn
.text$mn:00003CFB ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003CFB _text$mn        ends
.text$mn:00003CFB
.text$x:00003CFC ; ===========================================================================
.text$x:00003CFC
.text$x:00003CFC ; Segment type: Pure code
.text$x:00003CFC ; Segment permissions: Read/Execute
.text$x:00003CFC _text$x         segment para public 'CODE' use32
.text$x:00003CFC                 assume cs:_text$x
.text$x:00003CFC                 ;org 3CFCh
.text$x:00003CFC ; COMDAT (pick associative to section at 3C10)
.text$x:00003CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003CFC
.text$x:00003CFC ; =============== S U B R O U T I N E =======================================
.text$x:00003CFC
.text$x:00003CFC
.text$x:00003CFC __ehhandler$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00003CFC                                         ; DATA XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00003CFC
.text$x:00003CFC arg_4           = dword ptr  8
.text$x:00003CFC
.text$x:00003CFC                 mov     edx, [esp+arg_4]
.text$x:00003D00                 lea     eax, [edx+0Ch]
.text$x:00003D03                 mov     ecx, [edx-18h]
.text$x:00003D06                 xor     ecx, eax
.text$x:00003D08                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D0D                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00003D12                 jmp     ___CxxFrameHandler3
.text$x:00003D12 __ehhandler$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00003D12
.text$x:00003D12 ; ---------------------------------------------------------------------------
.text$x:00003D17                 align 4
.text$x:00003D17 _text$x         ends
.text$x:00003D17
.text$mn:00003D18 ; ===========================================================================
.text$mn:00003D18
.text$mn:00003D18 ; Segment type: Pure code
.text$mn:00003D18 ; Segment permissions: Read/Execute
.text$mn:00003D18 _text$mn        segment para public 'CODE' use32
.text$mn:00003D18                 assume cs:_text$mn
.text$mn:00003D18                 ;org 3D18h
.text$mn:00003D18 ; COMDAT (pick any)
.text$mn:00003D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D18
.text$mn:00003D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D18
.text$mn:00003D18 ; Attributes: bp-based frame
.text$mn:00003D18
.text$mn:00003D18 ; int __cdecl std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(int, int, void *, int)
.text$mn:00003D18                 public ??$_Uninit_copy@PBUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.text$mn:00003D18 ??$_Uninit_copy@PBUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z proc near
.text$mn:00003D18                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+9Fp
.text$mn:00003D18
.text$mn:00003D18 var_1           = byte ptr -1
.text$mn:00003D18 arg_0           = dword ptr  8
.text$mn:00003D18 arg_4           = dword ptr  0Ch
.text$mn:00003D18 arg_8           = dword ptr  10h
.text$mn:00003D18 arg_C           = dword ptr  14h
.text$mn:00003D18
.text$mn:00003D18                 push    ebp
.text$mn:00003D19                 mov     ebp, esp
.text$mn:00003D1B                 push    ecx
.text$mn:00003D1C                 mov     eax, [ebp+arg_8]
.text$mn:00003D1F                 push    eax
.text$mn:00003D20                 mov     ecx, [ebp+arg_0]
.text$mn:00003D23                 push    ecx
.text$mn:00003D24                 call    ??$_Ptr_cat@UKeyCombo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUKeyCombo@@PAU2@@Z ; std::_Ptr_cat<KeyCombo,KeyCombo>(KeyCombo const *,KeyCombo *)
.text$mn:00003D29                 add     esp, 8
.text$mn:00003D2C                 mov     [ebp+var_1], al
.text$mn:00003D2F                 movzx   edx, [ebp+var_1]
.text$mn:00003D33                 push    edx
.text$mn:00003D34                 mov     eax, [ebp+arg_C]
.text$mn:00003D37                 push    eax             ; int
.text$mn:00003D38                 mov     ecx, [ebp+arg_8]
.text$mn:00003D3B                 push    ecx             ; void *
.text$mn:00003D3C                 mov     edx, [ebp+arg_4]
.text$mn:00003D3F                 push    edx             ; int
.text$mn:00003D40                 mov     eax, [ebp+arg_0]
.text$mn:00003D43                 push    eax             ; int
.text$mn:00003D44                 call    ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003D49                 add     esp, 14h
.text$mn:00003D4C                 mov     esp, ebp
.text$mn:00003D4E                 pop     ebp
.text$mn:00003D4F                 retn
.text$mn:00003D4F ??$_Uninit_copy@PBUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z endp
.text$mn:00003D4F
.text$mn:00003D4F _text$mn        ends
.text$mn:00003D4F
.text$mn:00003D50 ; ===========================================================================
.text$mn:00003D50
.text$mn:00003D50 ; Segment type: Pure code
.text$mn:00003D50 ; Segment permissions: Read/Execute
.text$mn:00003D50 _text$mn        segment para public 'CODE' use32
.text$mn:00003D50                 assume cs:_text$mn
.text$mn:00003D50                 ;org 3D50h
.text$mn:00003D50 ; COMDAT (pick any)
.text$mn:00003D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D50
.text$mn:00003D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D50
.text$mn:00003D50 ; Attributes: bp-based frame
.text$mn:00003D50
.text$mn:00003D50 ; int __cdecl std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(int, int, void *, int)
.text$mn:00003D50                 public ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003D50 ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003D50                                         ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+2Cp
.text$mn:00003D50
.text$mn:00003D50 var_14          = dword ptr -14h
.text$mn:00003D50 var_10          = dword ptr -10h
.text$mn:00003D50 var_C           = dword ptr -0Ch
.text$mn:00003D50 var_4           = dword ptr -4
.text$mn:00003D50 arg_0           = dword ptr  8
.text$mn:00003D50 arg_4           = dword ptr  0Ch
.text$mn:00003D50 arg_8           = dword ptr  10h
.text$mn:00003D50 arg_C           = dword ptr  14h
.text$mn:00003D50
.text$mn:00003D50 ; FUNCTION CHUNK AT .text$mn:00003E17 SIZE 00000009 BYTES
.text$mn:00003D50 ; FUNCTION CHUNK AT .text$mn:00003E27 SIZE 00000015 BYTES
.text$mn:00003D50
.text$mn:00003D50                 push    ebp
.text$mn:00003D51                 mov     ebp, esp
.text$mn:00003D53                 push    0FFFFFFFFh
.text$mn:00003D55                 push    offset __ehhandler$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003D5A                 mov     eax, large fs:0
.text$mn:00003D60                 push    eax
.text$mn:00003D61                 push    ecx
.text$mn:00003D62                 push    ecx
.text$mn:00003D63                 push    ebx
.text$mn:00003D64                 push    esi
.text$mn:00003D65                 push    edi
.text$mn:00003D66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D6B                 xor     eax, ebp
.text$mn:00003D6D                 push    eax
.text$mn:00003D6E                 lea     eax, [ebp+var_C]
.text$mn:00003D71                 mov     large fs:0, eax
.text$mn:00003D77                 mov     [ebp+var_10], esp
.text$mn:00003D7A                 push    174h            ; unsigned int
.text$mn:00003D7F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D84                 mov     eax, [ebp+arg_4]
.text$mn:00003D87                 push    eax             ; int
.text$mn:00003D88                 mov     ecx, [ebp+arg_0]
.text$mn:00003D8B                 push    ecx             ; int
.text$mn:00003D8C                 call    ??$_Debug_range@PBUKeyCombo@@@std@@YAXPBUKeyCombo@@0PB_WI@Z ; std::_Debug_range<KeyCombo const *>(KeyCombo const *,KeyCombo const *,wchar_t const *,uint)
.text$mn:00003D91                 add     esp, 10h
.text$mn:00003D94                 push    175h            ; unsigned int
.text$mn:00003D99                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D9E                 mov     edx, [ebp+arg_8]
.text$mn:00003DA1                 push    edx             ; int
.text$mn:00003DA2                 call    ??$_Debug_pointer@UKeyCombo@@@std@@YAXPAUKeyCombo@@PB_WI@Z ; std::_Debug_pointer<KeyCombo>(KeyCombo *,wchar_t const *,uint)
.text$mn:00003DA7                 add     esp, 0Ch
.text$mn:00003DAA                 mov     eax, [ebp+arg_8]
.text$mn:00003DAD                 mov     [ebp+var_14], eax
.text$mn:00003DB0                 mov     [ebp+var_4], 0
.text$mn:00003DB7                 jmp     short loc_3DCB
.text$mn:00003DB9 ; ---------------------------------------------------------------------------
.text$mn:00003DB9
.text$mn:00003DB9 loc_3DB9:                               ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00003DB9                 mov     ecx, [ebp+arg_8]
.text$mn:00003DBC                 add     ecx, 4
.text$mn:00003DBF                 mov     [ebp+arg_8], ecx
.text$mn:00003DC2                 mov     edx, [ebp+arg_0]
.text$mn:00003DC5                 add     edx, 4
.text$mn:00003DC8                 mov     [ebp+arg_0], edx
.text$mn:00003DCB
.text$mn:00003DCB loc_3DCB:                               ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00003DCB                 mov     eax, [ebp+arg_0]
.text$mn:00003DCE                 cmp     eax, [ebp+arg_4]
.text$mn:00003DD1                 jz      short loc_3DE5
.text$mn:00003DD3                 mov     ecx, [ebp+arg_0]
.text$mn:00003DD6                 push    ecx             ; int
.text$mn:00003DD7                 mov     edx, [ebp+arg_8]
.text$mn:00003DDA                 push    edx             ; void *
.text$mn:00003DDB                 mov     ecx, [ebp+arg_C]
.text$mn:00003DDE                 call    ??$construct@UKeyCombo@@ABU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(KeyCombo *,KeyCombo const &)
.text$mn:00003DE3                 jmp     short loc_3DB9
.text$mn:00003DE5 ; ---------------------------------------------------------------------------
.text$mn:00003DE5
.text$mn:00003DE5 loc_3DE5:                               ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00003DE5                 jmp     short loc_3E17
.text$mn:00003DE5 ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003DE5
.text$mn:00003DE7
.text$mn:00003DE7 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DE7
.text$mn:00003DE7 ; Attributes: noreturn
.text$mn:00003DE7
.text$mn:00003DE7 __catch$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00003DE7                                         ; DATA XREF: .xdata$x:0000E59Co
.text$mn:00003DE7                 jmp     short loc_3DF2
.text$mn:00003DE9 ; ---------------------------------------------------------------------------
.text$mn:00003DE9
.text$mn:00003DE9 loc_3DE9:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00003DE9                 mov     eax, [ebp-14h]
.text$mn:00003DEC                 add     eax, 4
.text$mn:00003DEF                 mov     [ebp-14h], eax
.text$mn:00003DF2
.text$mn:00003DF2 loc_3DF2:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00003DF2                 mov     ecx, [ebp-14h]
.text$mn:00003DF5                 cmp     ecx, [ebp+10h]
.text$mn:00003DF8                 jz      short loc_3E08
.text$mn:00003DFA                 mov     edx, [ebp-14h]
.text$mn:00003DFD                 push    edx
.text$mn:00003DFE                 mov     ecx, [ebp+14h]
.text$mn:00003E01                 call    ??$destroy@UKeyCombo@@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::destroy<KeyCombo>(KeyCombo *)
.text$mn:00003E06                 jmp     short loc_3DE9
.text$mn:00003E08 ; ---------------------------------------------------------------------------
.text$mn:00003E08
.text$mn:00003E08 loc_3E08:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00003E08                 push    0
.text$mn:00003E0A                 push    0
.text$mn:00003E0C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003E0C __catch$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00003E0C
.text$mn:00003E11 ; ---------------------------------------------------------------------------
.text$mn:00003E11                 mov     eax, offset $LN13
.text$mn:00003E16                 retn
.text$mn:00003E17 ; ---------------------------------------------------------------------------
.text$mn:00003E17 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E17
.text$mn:00003E17 loc_3E17:                               ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag):loc_3DE5j
.text$mn:00003E17                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E1E                 jmp     short loc_3E27
.text$mn:00003E1E ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E20
.text$mn:00003E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E20
.text$mn:00003E20
.text$mn:00003E20 $LN13           proc near               ; DATA XREF: .text$mn:00003E11o
.text$mn:00003E20                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003E20 $LN13           endp ; sp-analysis failed
.text$mn:00003E20
.text$mn:00003E27 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E27
.text$mn:00003E27 loc_3E27:                               ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00003E27                 mov     eax, [ebp+arg_8]
.text$mn:00003E2A                 mov     ecx, [ebp+var_C]
.text$mn:00003E2D                 mov     large fs:0, ecx
.text$mn:00003E34                 pop     ecx
.text$mn:00003E35                 pop     edi
.text$mn:00003E36                 pop     esi
.text$mn:00003E37                 pop     ebx
.text$mn:00003E38                 mov     esp, ebp
.text$mn:00003E3A                 pop     ebp
.text$mn:00003E3B                 retn
.text$mn:00003E3B ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E3B _text$mn        ends
.text$mn:00003E3B
.text$x:00003E3C ; ===========================================================================
.text$x:00003E3C
.text$x:00003E3C ; Segment type: Pure code
.text$x:00003E3C ; Segment permissions: Read/Execute
.text$x:00003E3C _text$x         segment para public 'CODE' use32
.text$x:00003E3C                 assume cs:_text$x
.text$x:00003E3C                 ;org 3E3Ch
.text$x:00003E3C ; COMDAT (pick associative to section at 3D50)
.text$x:00003E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003E3C
.text$x:00003E3C ; =============== S U B R O U T I N E =======================================
.text$x:00003E3C
.text$x:00003E3C
.text$x:00003E3C __ehhandler$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00003E3C                                         ; DATA XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00003E3C
.text$x:00003E3C arg_4           = dword ptr  8
.text$x:00003E3C
.text$x:00003E3C                 mov     edx, [esp+arg_4]
.text$x:00003E40                 lea     eax, [edx+0Ch]
.text$x:00003E43                 mov     ecx, [edx-18h]
.text$x:00003E46                 xor     ecx, eax
.text$x:00003E48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E4D                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00003E52                 jmp     ___CxxFrameHandler3
.text$x:00003E52 __ehhandler$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00003E52
.text$x:00003E52 ; ---------------------------------------------------------------------------
.text$x:00003E57                 align 4
.text$x:00003E57 _text$x         ends
.text$x:00003E57
.text$mn:00003E58 ; ===========================================================================
.text$mn:00003E58
.text$mn:00003E58 ; Segment type: Pure code
.text$mn:00003E58 ; Segment permissions: Read/Execute
.text$mn:00003E58 _text$mn        segment para public 'CODE' use32
.text$mn:00003E58                 assume cs:_text$mn
.text$mn:00003E58                 ;org 3E58h
.text$mn:00003E58 ; COMDAT (pick any)
.text$mn:00003E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E58
.text$mn:00003E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E58
.text$mn:00003E58 ; Attributes: bp-based frame
.text$mn:00003E58
.text$mn:00003E58 ; int __cdecl std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(int, int, void *, int)
.text$mn:00003E58                 public ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:00003E58 ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:00003E58                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+9Fp
.text$mn:00003E58
.text$mn:00003E58 var_1           = byte ptr -1
.text$mn:00003E58 arg_0           = dword ptr  8
.text$mn:00003E58 arg_4           = dword ptr  0Ch
.text$mn:00003E58 arg_8           = dword ptr  10h
.text$mn:00003E58 arg_C           = dword ptr  14h
.text$mn:00003E58
.text$mn:00003E58                 push    ebp
.text$mn:00003E59                 mov     ebp, esp
.text$mn:00003E5B                 push    ecx
.text$mn:00003E5C                 mov     eax, [ebp+arg_8]
.text$mn:00003E5F                 push    eax
.text$mn:00003E60                 mov     ecx, [ebp+arg_0]
.text$mn:00003E63                 push    ecx
.text$mn:00003E64                 call    ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUrecordedMacroStep@@PAU2@@Z ; std::_Ptr_cat<recordedMacroStep,recordedMacroStep>(recordedMacroStep const *,recordedMacroStep *)
.text$mn:00003E69                 add     esp, 8
.text$mn:00003E6C                 mov     [ebp+var_1], al
.text$mn:00003E6F                 movzx   edx, [ebp+var_1]
.text$mn:00003E73                 push    edx
.text$mn:00003E74                 mov     eax, [ebp+arg_C]
.text$mn:00003E77                 push    eax             ; int
.text$mn:00003E78                 mov     ecx, [ebp+arg_8]
.text$mn:00003E7B                 push    ecx             ; void *
.text$mn:00003E7C                 mov     edx, [ebp+arg_4]
.text$mn:00003E7F                 push    edx             ; int
.text$mn:00003E80                 mov     eax, [ebp+arg_0]
.text$mn:00003E83                 push    eax             ; int
.text$mn:00003E84                 call    ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003E89                 add     esp, 14h
.text$mn:00003E8C                 mov     esp, ebp
.text$mn:00003E8E                 pop     ebp
.text$mn:00003E8F                 retn
.text$mn:00003E8F ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:00003E8F
.text$mn:00003E8F _text$mn        ends
.text$mn:00003E8F
.text$mn:00003E90 ; ===========================================================================
.text$mn:00003E90
.text$mn:00003E90 ; Segment type: Pure code
.text$mn:00003E90 ; Segment permissions: Read/Execute
.text$mn:00003E90 _text$mn        segment para public 'CODE' use32
.text$mn:00003E90                 assume cs:_text$mn
.text$mn:00003E90                 ;org 3E90h
.text$mn:00003E90 ; COMDAT (pick any)
.text$mn:00003E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E90
.text$mn:00003E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E90
.text$mn:00003E90 ; Attributes: bp-based frame
.text$mn:00003E90
.text$mn:00003E90 ; int __cdecl std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(int, int, void *, int)
.text$mn:00003E90                 public ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E90 ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003E90                                         ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+2Cp
.text$mn:00003E90
.text$mn:00003E90 var_14          = dword ptr -14h
.text$mn:00003E90 var_10          = dword ptr -10h
.text$mn:00003E90 var_C           = dword ptr -0Ch
.text$mn:00003E90 var_4           = dword ptr -4
.text$mn:00003E90 arg_0           = dword ptr  8
.text$mn:00003E90 arg_4           = dword ptr  0Ch
.text$mn:00003E90 arg_8           = dword ptr  10h
.text$mn:00003E90 arg_C           = dword ptr  14h
.text$mn:00003E90
.text$mn:00003E90 ; FUNCTION CHUNK AT .text$mn:00003F57 SIZE 00000009 BYTES
.text$mn:00003E90 ; FUNCTION CHUNK AT .text$mn:00003F67 SIZE 00000015 BYTES
.text$mn:00003E90
.text$mn:00003E90                 push    ebp
.text$mn:00003E91                 mov     ebp, esp
.text$mn:00003E93                 push    0FFFFFFFFh
.text$mn:00003E95                 push    offset __ehhandler$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E9A                 mov     eax, large fs:0
.text$mn:00003EA0                 push    eax
.text$mn:00003EA1                 push    ecx
.text$mn:00003EA2                 push    ecx
.text$mn:00003EA3                 push    ebx
.text$mn:00003EA4                 push    esi
.text$mn:00003EA5                 push    edi
.text$mn:00003EA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003EAB                 xor     eax, ebp
.text$mn:00003EAD                 push    eax
.text$mn:00003EAE                 lea     eax, [ebp+var_C]
.text$mn:00003EB1                 mov     large fs:0, eax
.text$mn:00003EB7                 mov     [ebp+var_10], esp
.text$mn:00003EBA                 push    174h            ; unsigned int
.text$mn:00003EBF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003EC4                 mov     eax, [ebp+arg_4]
.text$mn:00003EC7                 push    eax             ; int
.text$mn:00003EC8                 mov     ecx, [ebp+arg_0]
.text$mn:00003ECB                 push    ecx             ; int
.text$mn:00003ECC                 call    ??$_Debug_range@PBUrecordedMacroStep@@@std@@YAXPBUrecordedMacroStep@@0PB_WI@Z ; std::_Debug_range<recordedMacroStep const *>(recordedMacroStep const *,recordedMacroStep const *,wchar_t const *,uint)
.text$mn:00003ED1                 add     esp, 10h
.text$mn:00003ED4                 push    175h            ; unsigned int
.text$mn:00003ED9                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003EDE                 mov     edx, [ebp+arg_8]
.text$mn:00003EE1                 push    edx             ; int
.text$mn:00003EE2                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)
.text$mn:00003EE7                 add     esp, 0Ch
.text$mn:00003EEA                 mov     eax, [ebp+arg_8]
.text$mn:00003EED                 mov     [ebp+var_14], eax
.text$mn:00003EF0                 mov     [ebp+var_4], 0
.text$mn:00003EF7                 jmp     short loc_3F0B
.text$mn:00003EF9 ; ---------------------------------------------------------------------------
.text$mn:00003EF9
.text$mn:00003EF9 loc_3EF9:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00003EF9                 mov     ecx, [ebp+arg_8]
.text$mn:00003EFC                 add     ecx, 2Ch ; ','
.text$mn:00003EFF                 mov     [ebp+arg_8], ecx
.text$mn:00003F02                 mov     edx, [ebp+arg_0]
.text$mn:00003F05                 add     edx, 2Ch ; ','
.text$mn:00003F08                 mov     [ebp+arg_0], edx
.text$mn:00003F0B
.text$mn:00003F0B loc_3F0B:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00003F0B                 mov     eax, [ebp+arg_0]
.text$mn:00003F0E                 cmp     eax, [ebp+arg_4]
.text$mn:00003F11                 jz      short loc_3F25
.text$mn:00003F13                 mov     ecx, [ebp+arg_0]
.text$mn:00003F16                 push    ecx             ; int
.text$mn:00003F17                 mov     edx, [ebp+arg_8]
.text$mn:00003F1A                 push    edx             ; void *
.text$mn:00003F1B                 mov     ecx, [ebp+arg_C]
.text$mn:00003F1E                 call    ??$construct@UrecordedMacroStep@@ABU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(recordedMacroStep *,recordedMacroStep const &)
.text$mn:00003F23                 jmp     short loc_3EF9
.text$mn:00003F25 ; ---------------------------------------------------------------------------
.text$mn:00003F25
.text$mn:00003F25 loc_3F25:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00003F25                 jmp     short loc_3F57
.text$mn:00003F25 ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003F25
.text$mn:00003F27
.text$mn:00003F27 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F27
.text$mn:00003F27 ; Attributes: noreturn
.text$mn:00003F27
.text$mn:00003F27 __catch$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00003F27                                         ; DATA XREF: .xdata$x:0000E64Co
.text$mn:00003F27                 jmp     short loc_3F32
.text$mn:00003F29 ; ---------------------------------------------------------------------------
.text$mn:00003F29
.text$mn:00003F29 loc_3F29:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00003F29                 mov     eax, [ebp-14h]
.text$mn:00003F2C                 add     eax, 2Ch ; ','
.text$mn:00003F2F                 mov     [ebp-14h], eax
.text$mn:00003F32
.text$mn:00003F32 loc_3F32:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00003F32                 mov     ecx, [ebp-14h]
.text$mn:00003F35                 cmp     ecx, [ebp+10h]
.text$mn:00003F38                 jz      short loc_3F48
.text$mn:00003F3A                 mov     edx, [ebp-14h]
.text$mn:00003F3D                 push    edx
.text$mn:00003F3E                 mov     ecx, [ebp+14h]
.text$mn:00003F41                 call    ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(recordedMacroStep *)
.text$mn:00003F46                 jmp     short loc_3F29
.text$mn:00003F48 ; ---------------------------------------------------------------------------
.text$mn:00003F48
.text$mn:00003F48 loc_3F48:                               ; CODE XREF: __catch$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00003F48                 push    0
.text$mn:00003F4A                 push    0
.text$mn:00003F4C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003F4C __catch$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00003F4C
.text$mn:00003F51 ; ---------------------------------------------------------------------------
.text$mn:00003F51                 mov     eax, offset $LN13_1
.text$mn:00003F56                 retn
.text$mn:00003F57 ; ---------------------------------------------------------------------------
.text$mn:00003F57 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F57
.text$mn:00003F57 loc_3F57:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag):loc_3F25j
.text$mn:00003F57                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F5E                 jmp     short loc_3F67
.text$mn:00003F5E ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F60
.text$mn:00003F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F60
.text$mn:00003F60
.text$mn:00003F60 $LN13_1         proc near               ; DATA XREF: .text$mn:00003F51o
.text$mn:00003F60                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003F60 $LN13_1         endp ; sp-analysis failed
.text$mn:00003F60
.text$mn:00003F67 ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F67
.text$mn:00003F67 loc_3F67:                               ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00003F67                 mov     eax, [ebp+arg_8]
.text$mn:00003F6A                 mov     ecx, [ebp+var_C]
.text$mn:00003F6D                 mov     large fs:0, ecx
.text$mn:00003F74                 pop     ecx
.text$mn:00003F75                 pop     edi
.text$mn:00003F76                 pop     esi
.text$mn:00003F77                 pop     ebx
.text$mn:00003F78                 mov     esp, ebp
.text$mn:00003F7A                 pop     ebp
.text$mn:00003F7B                 retn
.text$mn:00003F7B ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F7B _text$mn        ends
.text$mn:00003F7B
.text$x:00003F7C ; ===========================================================================
.text$x:00003F7C
.text$x:00003F7C ; Segment type: Pure code
.text$x:00003F7C ; Segment permissions: Read/Execute
.text$x:00003F7C _text$x         segment para public 'CODE' use32
.text$x:00003F7C                 assume cs:_text$x
.text$x:00003F7C                 ;org 3F7Ch
.text$x:00003F7C ; COMDAT (pick associative to section at 3E90)
.text$x:00003F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F7C
.text$x:00003F7C ; =============== S U B R O U T I N E =======================================
.text$x:00003F7C
.text$x:00003F7C
.text$x:00003F7C __ehhandler$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00003F7C                                         ; DATA XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00003F7C
.text$x:00003F7C arg_4           = dword ptr  8
.text$x:00003F7C
.text$x:00003F7C                 mov     edx, [esp+arg_4]
.text$x:00003F80                 lea     eax, [edx+0Ch]
.text$x:00003F83                 mov     ecx, [edx-18h]
.text$x:00003F86                 xor     ecx, eax
.text$x:00003F88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F8D                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00003F92                 jmp     ___CxxFrameHandler3
.text$x:00003F92 __ehhandler$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00003F92
.text$x:00003F92 ; ---------------------------------------------------------------------------
.text$x:00003F97                 align 4
.text$x:00003F97 _text$x         ends
.text$x:00003F97
.text$mn:00003F98 ; ===========================================================================
.text$mn:00003F98
.text$mn:00003F98 ; Segment type: Pure code
.text$mn:00003F98 ; Segment permissions: Read/Execute
.text$mn:00003F98 _text$mn        segment para public 'CODE' use32
.text$mn:00003F98                 assume cs:_text$mn
.text$mn:00003F98                 ;org 3F98h
.text$mn:00003F98 ; COMDAT (pick any)
.text$mn:00003F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F98
.text$mn:00003F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F98
.text$mn:00003F98 ; Attributes: bp-based frame
.text$mn:00003F98
.text$mn:00003F98 ; int __cdecl std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(int, int, void *, int)
.text$mn:00003F98                 public ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z
.text$mn:00003F98 ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z proc near
.text$mn:00003F98                                         ; CODE XREF: std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+2Ep
.text$mn:00003F98
.text$mn:00003F98 var_1           = byte ptr -1
.text$mn:00003F98 arg_0           = dword ptr  8
.text$mn:00003F98 arg_4           = dword ptr  0Ch
.text$mn:00003F98 arg_8           = dword ptr  10h
.text$mn:00003F98 arg_C           = dword ptr  14h
.text$mn:00003F98
.text$mn:00003F98                 push    ebp
.text$mn:00003F99                 mov     ebp, esp
.text$mn:00003F9B                 push    ecx
.text$mn:00003F9C                 mov     eax, [ebp+arg_8]
.text$mn:00003F9F                 push    eax
.text$mn:00003FA0                 mov     ecx, [ebp+arg_0]
.text$mn:00003FA3                 push    ecx
.text$mn:00003FA4                 call    ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z ; std::_Ptr_cat<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *)
.text$mn:00003FA9                 add     esp, 8
.text$mn:00003FAC                 mov     [ebp+var_1], al
.text$mn:00003FAF                 movzx   edx, [ebp+var_1]
.text$mn:00003FB3                 push    edx
.text$mn:00003FB4                 mov     eax, [ebp+arg_0]
.text$mn:00003FB7                 push    eax
.text$mn:00003FB8                 call    ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Val_type<MenuItemUnit *>(MenuItemUnit *)
.text$mn:00003FBD                 add     esp, 4
.text$mn:00003FC0                 push    eax
.text$mn:00003FC1                 mov     ecx, [ebp+arg_C]
.text$mn:00003FC4                 push    ecx             ; int
.text$mn:00003FC5                 mov     edx, [ebp+arg_8]
.text$mn:00003FC8                 push    edx             ; void *
.text$mn:00003FC9                 mov     eax, [ebp+arg_4]
.text$mn:00003FCC                 push    eax             ; int
.text$mn:00003FCD                 mov     ecx, [ebp+arg_0]
.text$mn:00003FD0                 push    ecx             ; int
.text$mn:00003FD1                 call    ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003FD6                 add     esp, 18h
.text$mn:00003FD9                 mov     esp, ebp
.text$mn:00003FDB                 pop     ebp
.text$mn:00003FDC                 retn
.text$mn:00003FDC ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z endp
.text$mn:00003FDC
.text$mn:00003FDC ; ---------------------------------------------------------------------------
.text$mn:00003FDD                 align 10h
.text$mn:00003FDD _text$mn        ends
.text$mn:00003FDD
.text$mn:00003FE0 ; ===========================================================================
.text$mn:00003FE0
.text$mn:00003FE0 ; Segment type: Pure code
.text$mn:00003FE0 ; Segment permissions: Read/Execute
.text$mn:00003FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FE0                 assume cs:_text$mn
.text$mn:00003FE0                 ;org 3FE0h
.text$mn:00003FE0 ; COMDAT (pick any)
.text$mn:00003FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FE0
.text$mn:00003FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FE0
.text$mn:00003FE0 ; Attributes: bp-based frame
.text$mn:00003FE0
.text$mn:00003FE0 ; int __cdecl std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(int, int, void *, int)
.text$mn:00003FE0                 public ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003FE0 ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003FE0                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+39p
.text$mn:00003FE0
.text$mn:00003FE0 var_14          = dword ptr -14h
.text$mn:00003FE0 var_10          = dword ptr -10h
.text$mn:00003FE0 var_C           = dword ptr -0Ch
.text$mn:00003FE0 var_4           = dword ptr -4
.text$mn:00003FE0 arg_0           = dword ptr  8
.text$mn:00003FE0 arg_4           = dword ptr  0Ch
.text$mn:00003FE0 arg_8           = dword ptr  10h
.text$mn:00003FE0 arg_C           = dword ptr  14h
.text$mn:00003FE0
.text$mn:00003FE0 ; FUNCTION CHUNK AT .text$mn:000040A7 SIZE 00000009 BYTES
.text$mn:00003FE0 ; FUNCTION CHUNK AT .text$mn:000040B7 SIZE 00000015 BYTES
.text$mn:00003FE0
.text$mn:00003FE0                 push    ebp
.text$mn:00003FE1                 mov     ebp, esp
.text$mn:00003FE3                 push    0FFFFFFFFh
.text$mn:00003FE5                 push    offset __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003FEA                 mov     eax, large fs:0
.text$mn:00003FF0                 push    eax
.text$mn:00003FF1                 push    ecx
.text$mn:00003FF2                 push    ecx
.text$mn:00003FF3                 push    ebx
.text$mn:00003FF4                 push    esi
.text$mn:00003FF5                 push    edi
.text$mn:00003FF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FFB                 xor     eax, ebp
.text$mn:00003FFD                 push    eax
.text$mn:00003FFE                 lea     eax, [ebp+var_C]
.text$mn:00004001                 mov     large fs:0, eax
.text$mn:00004007                 mov     [ebp+var_10], esp
.text$mn:0000400A                 push    1B6h            ; unsigned int
.text$mn:0000400F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004014                 mov     eax, [ebp+arg_4]
.text$mn:00004017                 push    eax             ; int
.text$mn:00004018                 mov     ecx, [ebp+arg_0]
.text$mn:0000401B                 push    ecx             ; int
.text$mn:0000401C                 call    ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z ; std::_Debug_range<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint)
.text$mn:00004021                 add     esp, 10h
.text$mn:00004024                 push    1B7h            ; unsigned int
.text$mn:00004029                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000402E                 mov     edx, [ebp+arg_8]
.text$mn:00004031                 push    edx             ; int
.text$mn:00004032                 call    ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z ; std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)
.text$mn:00004037                 add     esp, 0Ch
.text$mn:0000403A                 mov     eax, [ebp+arg_8]
.text$mn:0000403D                 mov     [ebp+var_14], eax
.text$mn:00004040                 mov     [ebp+var_4], 0
.text$mn:00004047                 jmp     short loc_405B
.text$mn:00004049 ; ---------------------------------------------------------------------------
.text$mn:00004049
.text$mn:00004049 loc_4049:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00004049                 mov     ecx, [ebp+arg_8]
.text$mn:0000404C                 add     ecx, 3Ch ; '<'
.text$mn:0000404F                 mov     [ebp+arg_8], ecx
.text$mn:00004052                 mov     edx, [ebp+arg_0]
.text$mn:00004055                 add     edx, 3Ch ; '<'
.text$mn:00004058                 mov     [ebp+arg_0], edx
.text$mn:0000405B
.text$mn:0000405B loc_405B:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:0000405B                 mov     eax, [ebp+arg_0]
.text$mn:0000405E                 cmp     eax, [ebp+arg_4]
.text$mn:00004061                 jz      short loc_4075
.text$mn:00004063                 mov     ecx, [ebp+arg_0]
.text$mn:00004066                 push    ecx             ; int
.text$mn:00004067                 mov     edx, [ebp+arg_8]
.text$mn:0000406A                 push    edx             ; void *
.text$mn:0000406B                 mov     ecx, [ebp+arg_C]
.text$mn:0000406E                 call    ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:00004073                 jmp     short loc_4049
.text$mn:00004075 ; ---------------------------------------------------------------------------
.text$mn:00004075
.text$mn:00004075 loc_4075:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00004075                 jmp     short loc_40A7
.text$mn:00004075 ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004075
.text$mn:00004077
.text$mn:00004077 ; =============== S U B R O U T I N E =======================================
.text$mn:00004077
.text$mn:00004077 ; Attributes: noreturn
.text$mn:00004077
.text$mn:00004077 __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00004077                                         ; DATA XREF: .xdata$x:0000E6FCo
.text$mn:00004077                 jmp     short loc_4082
.text$mn:00004079 ; ---------------------------------------------------------------------------
.text$mn:00004079
.text$mn:00004079 loc_4079:                               ; CODE XREF: __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00004079                 mov     eax, [ebp-14h]
.text$mn:0000407C                 add     eax, 3Ch ; '<'
.text$mn:0000407F                 mov     [ebp-14h], eax
.text$mn:00004082
.text$mn:00004082 loc_4082:                               ; CODE XREF: __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00004082                 mov     ecx, [ebp-14h]
.text$mn:00004085                 cmp     ecx, [ebp+10h]
.text$mn:00004088                 jz      short loc_4098
.text$mn:0000408A                 mov     edx, [ebp-14h]
.text$mn:0000408D                 push    edx
.text$mn:0000408E                 mov     ecx, [ebp+14h]
.text$mn:00004091                 call    ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(MenuItemUnit *)
.text$mn:00004096                 jmp     short loc_4079
.text$mn:00004098 ; ---------------------------------------------------------------------------
.text$mn:00004098
.text$mn:00004098 loc_4098:                               ; CODE XREF: __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00004098                 push    0
.text$mn:0000409A                 push    0
.text$mn:0000409C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000409C __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:0000409C
.text$mn:000040A1 ; ---------------------------------------------------------------------------
.text$mn:000040A1                 mov     eax, offset $LN13_3
.text$mn:000040A6                 retn
.text$mn:000040A7 ; ---------------------------------------------------------------------------
.text$mn:000040A7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000040A7
.text$mn:000040A7 loc_40A7:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag):loc_4075j
.text$mn:000040A7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040AE                 jmp     short loc_40B7
.text$mn:000040AE ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000040B0
.text$mn:000040B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040B0
.text$mn:000040B0
.text$mn:000040B0 $LN13_3         proc near               ; DATA XREF: .text$mn:000040A1o
.text$mn:000040B0                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000040B0 $LN13_3         endp ; sp-analysis failed
.text$mn:000040B0
.text$mn:000040B7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000040B7
.text$mn:000040B7 loc_40B7:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:000040B7                 mov     eax, [ebp+arg_8]
.text$mn:000040BA                 mov     ecx, [ebp+var_C]
.text$mn:000040BD                 mov     large fs:0, ecx
.text$mn:000040C4                 pop     ecx
.text$mn:000040C5                 pop     edi
.text$mn:000040C6                 pop     esi
.text$mn:000040C7                 pop     ebx
.text$mn:000040C8                 mov     esp, ebp
.text$mn:000040CA                 pop     ebp
.text$mn:000040CB                 retn
.text$mn:000040CB ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000040CB _text$mn        ends
.text$mn:000040CB
.text$x:000040CC ; ===========================================================================
.text$x:000040CC
.text$x:000040CC ; Segment type: Pure code
.text$x:000040CC ; Segment permissions: Read/Execute
.text$x:000040CC _text$x         segment para public 'CODE' use32
.text$x:000040CC                 assume cs:_text$x
.text$x:000040CC                 ;org 40CCh
.text$x:000040CC ; COMDAT (pick associative to section at 3FE0)
.text$x:000040CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000040CC
.text$x:000040CC ; =============== S U B R O U T I N E =======================================
.text$x:000040CC
.text$x:000040CC
.text$x:000040CC __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:000040CC                                         ; DATA XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:000040CC
.text$x:000040CC arg_4           = dword ptr  8
.text$x:000040CC
.text$x:000040CC                 mov     edx, [esp+arg_4]
.text$x:000040D0                 lea     eax, [edx+0Ch]
.text$x:000040D3                 mov     ecx, [edx-18h]
.text$x:000040D6                 xor     ecx, eax
.text$x:000040D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040DD                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:000040E2                 jmp     ___CxxFrameHandler3
.text$x:000040E2 __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:000040E2
.text$x:000040E2 ; ---------------------------------------------------------------------------
.text$x:000040E7                 align 4
.text$x:000040E7 _text$x         ends
.text$x:000040E7
.text$mn:000040E8 ; ===========================================================================
.text$mn:000040E8
.text$mn:000040E8 ; Segment type: Pure code
.text$mn:000040E8 ; Segment permissions: Read/Execute
.text$mn:000040E8 _text$mn        segment para public 'CODE' use32
.text$mn:000040E8                 assume cs:_text$mn
.text$mn:000040E8                 ;org 40E8h
.text$mn:000040E8 ; COMDAT (pick any)
.text$mn:000040E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040E8
.text$mn:000040E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000040E8
.text$mn:000040E8 ; Attributes: bp-based frame
.text$mn:000040E8
.text$mn:000040E8 ; struct KeyCombo * __cdecl std::_Uninitialized_copy<struct KeyCombo *, struct KeyCombo *, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>>>(struct KeyCombo *, struct KeyCombo *, struct KeyCombo *, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> &)
.text$mn:000040E8                 public ??$_Uninitialized_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.text$mn:000040E8 ??$_Uninitialized_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z proc near
.text$mn:000040E8                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)+25p
.text$mn:000040E8
.text$mn:000040E8 arg_0           = dword ptr  8
.text$mn:000040E8 arg_4           = dword ptr  0Ch
.text$mn:000040E8 arg_8           = dword ptr  10h
.text$mn:000040E8 arg_C           = dword ptr  14h
.text$mn:000040E8
.text$mn:000040E8                 push    ebp
.text$mn:000040E9                 mov     ebp, esp
.text$mn:000040EB                 mov     eax, [ebp+arg_C]
.text$mn:000040EE                 push    eax             ; int
.text$mn:000040EF                 mov     ecx, [ebp+arg_8]
.text$mn:000040F2                 push    ecx
.text$mn:000040F3                 call    ??$_Unchecked@PAUKeyCombo@@@std@@YAPAUKeyCombo@@PAU1@@Z ; std::_Unchecked<KeyCombo *>(KeyCombo *)
.text$mn:000040F8                 add     esp, 4
.text$mn:000040FB                 push    eax             ; void *
.text$mn:000040FC                 mov     edx, [ebp+arg_4]
.text$mn:000040FF                 push    edx
.text$mn:00004100                 call    ??$_Unchecked@PAUKeyCombo@@@std@@YAPAUKeyCombo@@PAU1@@Z ; std::_Unchecked<KeyCombo *>(KeyCombo *)
.text$mn:00004105                 add     esp, 4
.text$mn:00004108                 push    eax             ; int
.text$mn:00004109                 mov     eax, [ebp+arg_0]
.text$mn:0000410C                 push    eax
.text$mn:0000410D                 call    ??$_Unchecked@PAUKeyCombo@@@std@@YAPAUKeyCombo@@PAU1@@Z ; std::_Unchecked<KeyCombo *>(KeyCombo *)
.text$mn:00004112                 add     esp, 4
.text$mn:00004115                 push    eax             ; int
.text$mn:00004116                 call    ??$_Uninit_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z ; std::_Uninit_copy<KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)
.text$mn:0000411B                 add     esp, 10h
.text$mn:0000411E                 push    eax
.text$mn:0000411F                 lea     ecx, [ebp+arg_8]
.text$mn:00004122                 push    ecx
.text$mn:00004123                 call    ??$_Rechecked@PAUKeyCombo@@PAU1@@std@@YAAAPAUKeyCombo@@AAPAU1@PAU1@@Z ; std::_Rechecked<KeyCombo *,KeyCombo *>(KeyCombo * &,KeyCombo *)
.text$mn:00004128                 add     esp, 8
.text$mn:0000412B                 mov     eax, [eax]
.text$mn:0000412D                 pop     ebp
.text$mn:0000412E                 retn
.text$mn:0000412E ??$_Uninitialized_copy@PAUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z endp
.text$mn:0000412E
.text$mn:0000412E ; ---------------------------------------------------------------------------
.text$mn:0000412F                 align 10h
.text$mn:0000412F _text$mn        ends
.text$mn:0000412F
.text$mn:00004130 ; ===========================================================================
.text$mn:00004130
.text$mn:00004130 ; Segment type: Pure code
.text$mn:00004130 ; Segment permissions: Read/Execute
.text$mn:00004130 _text$mn        segment para public 'CODE' use32
.text$mn:00004130                 assume cs:_text$mn
.text$mn:00004130                 ;org 4130h
.text$mn:00004130 ; COMDAT (pick any)
.text$mn:00004130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004130
.text$mn:00004130 ; =============== S U B R O U T I N E =======================================
.text$mn:00004130
.text$mn:00004130 ; Attributes: bp-based frame
.text$mn:00004130
.text$mn:00004130 ; struct recordedMacroStep * __cdecl std::_Uninitialized_copy<struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>>(struct recordedMacroStep *, struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> &)
.text$mn:00004130                 public ??$_Uninitialized_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:00004130 ??$_Uninitialized_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:00004130                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)+25p
.text$mn:00004130
.text$mn:00004130 arg_0           = dword ptr  8
.text$mn:00004130 arg_4           = dword ptr  0Ch
.text$mn:00004130 arg_8           = dword ptr  10h
.text$mn:00004130 arg_C           = dword ptr  14h
.text$mn:00004130
.text$mn:00004130                 push    ebp
.text$mn:00004131                 mov     ebp, esp
.text$mn:00004133                 mov     eax, [ebp+arg_C]
.text$mn:00004136                 push    eax             ; int
.text$mn:00004137                 mov     ecx, [ebp+arg_8]
.text$mn:0000413A                 push    ecx
.text$mn:0000413B                 call    ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Unchecked<recordedMacroStep *>(recordedMacroStep *)
.text$mn:00004140                 add     esp, 4
.text$mn:00004143                 push    eax             ; void *
.text$mn:00004144                 mov     edx, [ebp+arg_4]
.text$mn:00004147                 push    edx
.text$mn:00004148                 call    ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Unchecked<recordedMacroStep *>(recordedMacroStep *)
.text$mn:0000414D                 add     esp, 4
.text$mn:00004150                 push    eax             ; int
.text$mn:00004151                 mov     eax, [ebp+arg_0]
.text$mn:00004154                 push    eax
.text$mn:00004155                 call    ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Unchecked<recordedMacroStep *>(recordedMacroStep *)
.text$mn:0000415A                 add     esp, 4
.text$mn:0000415D                 push    eax             ; int
.text$mn:0000415E                 call    ??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:00004163                 add     esp, 10h
.text$mn:00004166                 push    eax
.text$mn:00004167                 lea     ecx, [ebp+arg_8]
.text$mn:0000416A                 push    ecx
.text$mn:0000416B                 call    ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z ; std::_Rechecked<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep * &,recordedMacroStep *)
.text$mn:00004170                 add     esp, 8
.text$mn:00004173                 mov     eax, [eax]
.text$mn:00004175                 pop     ebp
.text$mn:00004176                 retn
.text$mn:00004176 ??$_Uninitialized_copy@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:00004176
.text$mn:00004176 ; ---------------------------------------------------------------------------
.text$mn:00004177                 align 4
.text$mn:00004177 _text$mn        ends
.text$mn:00004177
.text$mn:00004178 ; ===========================================================================
.text$mn:00004178
.text$mn:00004178 ; Segment type: Pure code
.text$mn:00004178 ; Segment permissions: Read/Execute
.text$mn:00004178 _text$mn        segment para public 'CODE' use32
.text$mn:00004178                 assume cs:_text$mn
.text$mn:00004178                 ;org 4178h
.text$mn:00004178 ; COMDAT (pick any)
.text$mn:00004178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004178
.text$mn:00004178 ; =============== S U B R O U T I N E =======================================
.text$mn:00004178
.text$mn:00004178 ; Attributes: bp-based frame
.text$mn:00004178
.text$mn:00004178 ; struct KeyCombo * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>, struct KeyCombo *, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>, struct KeyCombo *, struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> &)
.text$mn:00004178                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.text$mn:00004178 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z proc near
.text$mn:00004178                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)+83p
.text$mn:00004178
.text$mn:00004178 var_34          = dword ptr -34h
.text$mn:00004178 var_30          = dword ptr -30h
.text$mn:00004178 var_2C          = dword ptr -2Ch
.text$mn:00004178 var_28          = dword ptr -28h
.text$mn:00004178 var_24          = dword ptr -24h
.text$mn:00004178 var_20          = dword ptr -20h
.text$mn:00004178 var_1C          = dword ptr -1Ch
.text$mn:00004178 var_18          = dword ptr -18h
.text$mn:00004178 var_14          = dword ptr -14h
.text$mn:00004178 var_10          = dword ptr -10h
.text$mn:00004178 var_C           = dword ptr -0Ch
.text$mn:00004178 var_4           = dword ptr -4
.text$mn:00004178 arg_0           = byte ptr  8
.text$mn:00004178 arg_C           = byte ptr  14h
.text$mn:00004178 arg_18          = dword ptr  20h
.text$mn:00004178 arg_1C          = dword ptr  24h
.text$mn:00004178
.text$mn:00004178                 push    ebp
.text$mn:00004179                 mov     ebp, esp
.text$mn:0000417B                 push    0FFFFFFFFh
.text$mn:0000417D                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.text$mn:00004182                 mov     eax, large fs:0
.text$mn:00004188                 push    eax
.text$mn:00004189                 sub     esp, 28h
.text$mn:0000418C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004191                 xor     eax, ebp
.text$mn:00004193                 push    eax
.text$mn:00004194                 lea     eax, [ebp+var_C]
.text$mn:00004197                 mov     large fs:0, eax
.text$mn:0000419D                 mov     [ebp+var_4], 1
.text$mn:000041A4                 mov     eax, [ebp+arg_1C]
.text$mn:000041A7                 push    eax             ; int
.text$mn:000041A8                 mov     ecx, [ebp+arg_18]
.text$mn:000041AB                 push    ecx
.text$mn:000041AC                 call    ??$_Unchecked@PAUKeyCombo@@@std@@YAPAUKeyCombo@@PAU1@@Z ; std::_Unchecked<KeyCombo *>(KeyCombo *)
.text$mn:000041B1                 add     esp, 4
.text$mn:000041B4                 push    eax             ; void *
.text$mn:000041B5                 sub     esp, 0Ch
.text$mn:000041B8                 mov     ecx, esp
.text$mn:000041BA                 mov     [ebp+var_28], esp
.text$mn:000041BD                 lea     edx, [ebp+arg_C]
.text$mn:000041C0                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000041C1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>> const &)
.text$mn:000041C6                 mov     [ebp+var_10], eax
.text$mn:000041C9                 mov     eax, [ebp+var_10]
.text$mn:000041CC                 mov     [ebp+var_2C], eax
.text$mn:000041CF                 mov     byte ptr [ebp+var_4], 2
.text$mn:000041D3                 mov     byte ptr [ebp+var_4], 1
.text$mn:000041D7                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>)
.text$mn:000041DC                 add     esp, 0Ch
.text$mn:000041DF                 mov     [ebp+var_14], eax
.text$mn:000041E2                 mov     ecx, [ebp+var_14]
.text$mn:000041E5                 push    ecx             ; int
.text$mn:000041E6                 sub     esp, 0Ch
.text$mn:000041E9                 mov     ecx, esp
.text$mn:000041EB                 mov     [ebp+var_30], esp
.text$mn:000041EE                 lea     edx, [ebp+arg_0]
.text$mn:000041F1                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000041F2                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>> const &)
.text$mn:000041F7                 mov     [ebp+var_18], eax
.text$mn:000041FA                 mov     eax, [ebp+var_18]
.text$mn:000041FD                 mov     [ebp+var_34], eax
.text$mn:00004200                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004204                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004208                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>)
.text$mn:0000420D                 add     esp, 0Ch
.text$mn:00004210                 mov     [ebp+var_1C], eax
.text$mn:00004213                 mov     ecx, [ebp+var_1C]
.text$mn:00004216                 push    ecx             ; int
.text$mn:00004217                 call    ??$_Uninit_copy@PBUKeyCombo@@PAU1@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z ; std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)
.text$mn:0000421C                 add     esp, 10h
.text$mn:0000421F                 mov     [ebp+var_20], eax
.text$mn:00004222                 mov     edx, [ebp+var_20]
.text$mn:00004225                 push    edx
.text$mn:00004226                 lea     eax, [ebp+arg_18]
.text$mn:00004229                 push    eax
.text$mn:0000422A                 call    ??$_Rechecked@PAUKeyCombo@@PAU1@@std@@YAAAPAUKeyCombo@@AAPAU1@PAU1@@Z ; std::_Rechecked<KeyCombo *,KeyCombo *>(KeyCombo * &,KeyCombo *)
.text$mn:0000422F                 add     esp, 8
.text$mn:00004232                 mov     ecx, [eax]
.text$mn:00004234                 mov     [ebp+var_24], ecx
.text$mn:00004237                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000423B                 lea     ecx, [ebp+arg_0]
.text$mn:0000423E                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$mn:00004243                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000424A                 lea     ecx, [ebp+arg_C]
.text$mn:0000424D                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$mn:00004252                 mov     eax, [ebp+var_24]
.text$mn:00004255                 mov     ecx, [ebp+var_C]
.text$mn:00004258                 mov     large fs:0, ecx
.text$mn:0000425F                 pop     ecx
.text$mn:00004260                 mov     esp, ebp
.text$mn:00004262                 pop     ebp
.text$mn:00004263                 retn
.text$mn:00004263 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z endp
.text$mn:00004263
.text$mn:00004263 _text$mn        ends
.text$mn:00004263
.text$x:00004264 ; ===========================================================================
.text$x:00004264
.text$x:00004264 ; Segment type: Pure code
.text$x:00004264 ; Segment permissions: Read/Execute
.text$x:00004264 _text$x         segment para public 'CODE' use32
.text$x:00004264                 assume cs:_text$x
.text$x:00004264                 ;org 4264h
.text$x:00004264 ; COMDAT (pick associative to section at 4178)
.text$x:00004264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004264
.text$x:00004264 ; =============== S U B R O U T I N E =======================================
.text$x:00004264
.text$x:00004264
.text$x:00004264 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$0 proc near
.text$x:00004264                                         ; DATA XREF: .xdata$x:0000E404o
.text$x:00004264                 lea     ecx, [ebp+14h]
.text$x:00004267                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:00004267 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$0 endp
.text$x:00004267
.text$x:0000426C
.text$x:0000426C ; =============== S U B R O U T I N E =======================================
.text$x:0000426C
.text$x:0000426C
.text$x:0000426C __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$1 proc near
.text$x:0000426C                                         ; DATA XREF: .xdata$x:0000E40Co
.text$x:0000426C                 lea     ecx, [ebp+8]
.text$x:0000426F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:0000426F __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$1 endp
.text$x:0000426F
.text$x:00004274
.text$x:00004274 ; =============== S U B R O U T I N E =======================================
.text$x:00004274
.text$x:00004274
.text$x:00004274 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$2 proc near
.text$x:00004274                                         ; DATA XREF: .xdata$x:0000E414o
.text$x:00004274                 mov     ecx, [ebp-28h]
.text$x:00004277                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:00004277 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$2 endp
.text$x:00004277
.text$x:0000427C
.text$x:0000427C ; =============== S U B R O U T I N E =======================================
.text$x:0000427C
.text$x:0000427C
.text$x:0000427C __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$3 proc near
.text$x:0000427C                                         ; DATA XREF: .xdata$x:0000E41Co
.text$x:0000427C                 mov     ecx, [ebp-30h]
.text$x:0000427F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:0000427F __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$3 endp
.text$x:0000427F
.text$x:00004284
.text$x:00004284 ; =============== S U B R O U T I N E =======================================
.text$x:00004284
.text$x:00004284
.text$x:00004284 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z proc near
.text$x:00004284                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)+5o
.text$x:00004284
.text$x:00004284 arg_4           = dword ptr  8
.text$x:00004284
.text$x:00004284                 mov     edx, [esp+arg_4]
.text$x:00004288                 lea     eax, [edx+0Ch]
.text$x:0000428B                 mov     ecx, [edx-2Ch]
.text$x:0000428E                 xor     ecx, eax
.text$x:00004290                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004295                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.text$x:0000429A                 jmp     ___CxxFrameHandler3
.text$x:0000429A __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z endp
.text$x:0000429A
.text$x:0000429A ; ---------------------------------------------------------------------------
.text$x:0000429F                 align 10h
.text$x:0000429F _text$x         ends
.text$x:0000429F
.text$mn:000042A0 ; ===========================================================================
.text$mn:000042A0
.text$mn:000042A0 ; Segment type: Pure code
.text$mn:000042A0 ; Segment permissions: Read/Execute
.text$mn:000042A0 _text$mn        segment para public 'CODE' use32
.text$mn:000042A0                 assume cs:_text$mn
.text$mn:000042A0                 ;org 42A0h
.text$mn:000042A0 ; COMDAT (pick any)
.text$mn:000042A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042A0
.text$mn:000042A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000042A0
.text$mn:000042A0 ; Attributes: bp-based frame
.text$mn:000042A0
.text$mn:000042A0 ; struct recordedMacroStep * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> &)
.text$mn:000042A0                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:000042A0 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:000042A0                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)+83p
.text$mn:000042A0
.text$mn:000042A0 var_34          = dword ptr -34h
.text$mn:000042A0 var_30          = dword ptr -30h
.text$mn:000042A0 var_2C          = dword ptr -2Ch
.text$mn:000042A0 var_28          = dword ptr -28h
.text$mn:000042A0 var_24          = dword ptr -24h
.text$mn:000042A0 var_20          = dword ptr -20h
.text$mn:000042A0 var_1C          = dword ptr -1Ch
.text$mn:000042A0 var_18          = dword ptr -18h
.text$mn:000042A0 var_14          = dword ptr -14h
.text$mn:000042A0 var_10          = dword ptr -10h
.text$mn:000042A0 var_C           = dword ptr -0Ch
.text$mn:000042A0 var_4           = dword ptr -4
.text$mn:000042A0 arg_0           = byte ptr  8
.text$mn:000042A0 arg_C           = byte ptr  14h
.text$mn:000042A0 arg_18          = dword ptr  20h
.text$mn:000042A0 arg_1C          = dword ptr  24h
.text$mn:000042A0
.text$mn:000042A0                 push    ebp
.text$mn:000042A1                 mov     ebp, esp
.text$mn:000042A3                 push    0FFFFFFFFh
.text$mn:000042A5                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:000042AA                 mov     eax, large fs:0
.text$mn:000042B0                 push    eax
.text$mn:000042B1                 sub     esp, 28h
.text$mn:000042B4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000042B9                 xor     eax, ebp
.text$mn:000042BB                 push    eax
.text$mn:000042BC                 lea     eax, [ebp+var_C]
.text$mn:000042BF                 mov     large fs:0, eax
.text$mn:000042C5                 mov     [ebp+var_4], 1
.text$mn:000042CC                 mov     eax, [ebp+arg_1C]
.text$mn:000042CF                 push    eax             ; int
.text$mn:000042D0                 mov     ecx, [ebp+arg_18]
.text$mn:000042D3                 push    ecx
.text$mn:000042D4                 call    ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Unchecked<recordedMacroStep *>(recordedMacroStep *)
.text$mn:000042D9                 add     esp, 4
.text$mn:000042DC                 push    eax             ; void *
.text$mn:000042DD                 sub     esp, 0Ch
.text$mn:000042E0                 mov     ecx, esp
.text$mn:000042E2                 mov     [ebp+var_28], esp
.text$mn:000042E5                 lea     edx, [ebp+arg_C]
.text$mn:000042E8                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000042E9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>> const &)
.text$mn:000042EE                 mov     [ebp+var_10], eax
.text$mn:000042F1                 mov     eax, [ebp+var_10]
.text$mn:000042F4                 mov     [ebp+var_2C], eax
.text$mn:000042F7                 mov     byte ptr [ebp+var_4], 2
.text$mn:000042FB                 mov     byte ptr [ebp+var_4], 1
.text$mn:000042FF                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>)
.text$mn:00004304                 add     esp, 0Ch
.text$mn:00004307                 mov     [ebp+var_14], eax
.text$mn:0000430A                 mov     ecx, [ebp+var_14]
.text$mn:0000430D                 push    ecx             ; int
.text$mn:0000430E                 sub     esp, 0Ch
.text$mn:00004311                 mov     ecx, esp
.text$mn:00004313                 mov     [ebp+var_30], esp
.text$mn:00004316                 lea     edx, [ebp+arg_0]
.text$mn:00004319                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000431A                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>> const &)
.text$mn:0000431F                 mov     [ebp+var_18], eax
.text$mn:00004322                 mov     eax, [ebp+var_18]
.text$mn:00004325                 mov     [ebp+var_34], eax
.text$mn:00004328                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000432C                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004330                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>)
.text$mn:00004335                 add     esp, 0Ch
.text$mn:00004338                 mov     [ebp+var_1C], eax
.text$mn:0000433B                 mov     ecx, [ebp+var_1C]
.text$mn:0000433E                 push    ecx             ; int
.text$mn:0000433F                 call    ??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:00004344                 add     esp, 10h
.text$mn:00004347                 mov     [ebp+var_20], eax
.text$mn:0000434A                 mov     edx, [ebp+var_20]
.text$mn:0000434D                 push    edx
.text$mn:0000434E                 lea     eax, [ebp+arg_18]
.text$mn:00004351                 push    eax
.text$mn:00004352                 call    ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z ; std::_Rechecked<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep * &,recordedMacroStep *)
.text$mn:00004357                 add     esp, 8
.text$mn:0000435A                 mov     ecx, [eax]
.text$mn:0000435C                 mov     [ebp+var_24], ecx
.text$mn:0000435F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004363                 lea     ecx, [ebp+arg_0]
.text$mn:00004366                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$mn:0000436B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004372                 lea     ecx, [ebp+arg_C]
.text$mn:00004375                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$mn:0000437A                 mov     eax, [ebp+var_24]
.text$mn:0000437D                 mov     ecx, [ebp+var_C]
.text$mn:00004380                 mov     large fs:0, ecx
.text$mn:00004387                 pop     ecx
.text$mn:00004388                 mov     esp, ebp
.text$mn:0000438A                 pop     ebp
.text$mn:0000438B                 retn
.text$mn:0000438B ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:0000438B
.text$mn:0000438B _text$mn        ends
.text$mn:0000438B
.text$x:0000438C ; ===========================================================================
.text$x:0000438C
.text$x:0000438C ; Segment type: Pure code
.text$x:0000438C ; Segment permissions: Read/Execute
.text$x:0000438C _text$x         segment para public 'CODE' use32
.text$x:0000438C                 assume cs:_text$x
.text$x:0000438C                 ;org 438Ch
.text$x:0000438C ; COMDAT (pick associative to section at 42A0)
.text$x:0000438C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000438C
.text$x:0000438C ; =============== S U B R O U T I N E =======================================
.text$x:0000438C
.text$x:0000438C
.text$x:0000438C __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$0 proc near
.text$x:0000438C                                         ; DATA XREF: .xdata$x:0000E448o
.text$x:0000438C                 lea     ecx, [ebp+14h]
.text$x:0000438F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:0000438F __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$0 endp
.text$x:0000438F
.text$x:00004394
.text$x:00004394 ; =============== S U B R O U T I N E =======================================
.text$x:00004394
.text$x:00004394
.text$x:00004394 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$1 proc near
.text$x:00004394                                         ; DATA XREF: .xdata$x:0000E450o
.text$x:00004394                 lea     ecx, [ebp+8]
.text$x:00004397                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:00004397 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$1 endp
.text$x:00004397
.text$x:0000439C
.text$x:0000439C ; =============== S U B R O U T I N E =======================================
.text$x:0000439C
.text$x:0000439C
.text$x:0000439C __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$2 proc near
.text$x:0000439C                                         ; DATA XREF: .xdata$x:0000E458o
.text$x:0000439C                 mov     ecx, [ebp-28h]
.text$x:0000439F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:0000439F __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$2 endp
.text$x:0000439F
.text$x:000043A4
.text$x:000043A4 ; =============== S U B R O U T I N E =======================================
.text$x:000043A4
.text$x:000043A4
.text$x:000043A4 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$3 proc near
.text$x:000043A4                                         ; DATA XREF: .xdata$x:0000E460o
.text$x:000043A4                 mov     ecx, [ebp-30h]
.text$x:000043A7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:000043A7 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$3 endp
.text$x:000043A7
.text$x:000043AC
.text$x:000043AC ; =============== S U B R O U T I N E =======================================
.text$x:000043AC
.text$x:000043AC
.text$x:000043AC __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$x:000043AC                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+5o
.text$x:000043AC
.text$x:000043AC arg_4           = dword ptr  8
.text$x:000043AC
.text$x:000043AC                 mov     edx, [esp+arg_4]
.text$x:000043B0                 lea     eax, [edx+0Ch]
.text$x:000043B3                 mov     ecx, [edx-2Ch]
.text$x:000043B6                 xor     ecx, eax
.text$x:000043B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000043BD                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$x:000043C2                 jmp     ___CxxFrameHandler3
.text$x:000043C2 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$x:000043C2
.text$x:000043C2 ; ---------------------------------------------------------------------------
.text$x:000043C7                 align 4
.text$x:000043C7 _text$x         ends
.text$x:000043C7
.text$mn:000043C8 ; ===========================================================================
.text$mn:000043C8
.text$mn:000043C8 ; Segment type: Pure code
.text$mn:000043C8 ; Segment permissions: Read/Execute
.text$mn:000043C8 _text$mn        segment para public 'CODE' use32
.text$mn:000043C8                 assume cs:_text$mn
.text$mn:000043C8                 ;org 43C8h
.text$mn:000043C8 ; COMDAT (pick any)
.text$mn:000043C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043C8
.text$mn:000043C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043C8
.text$mn:000043C8 ; Attributes: bp-based frame
.text$mn:000043C8
.text$mn:000043C8 ; struct MenuItemUnit * __cdecl std::_Uninitialized_move<struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>>(struct MenuItemUnit *, struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> &)
.text$mn:000043C8                 public ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z
.text$mn:000043C8 ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z proc near
.text$mn:000043C8                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Umove<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *)+25p
.text$mn:000043C8
.text$mn:000043C8 arg_0           = dword ptr  8
.text$mn:000043C8 arg_4           = dword ptr  0Ch
.text$mn:000043C8 arg_8           = dword ptr  10h
.text$mn:000043C8 arg_C           = dword ptr  14h
.text$mn:000043C8
.text$mn:000043C8                 push    ebp
.text$mn:000043C9                 mov     ebp, esp
.text$mn:000043CB                 mov     eax, [ebp+arg_C]
.text$mn:000043CE                 push    eax             ; int
.text$mn:000043CF                 mov     ecx, [ebp+arg_8]
.text$mn:000043D2                 push    ecx
.text$mn:000043D3                 call    ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Unchecked<MenuItemUnit *>(MenuItemUnit *)
.text$mn:000043D8                 add     esp, 4
.text$mn:000043DB                 push    eax             ; void *
.text$mn:000043DC                 mov     edx, [ebp+arg_4]
.text$mn:000043DF                 push    edx
.text$mn:000043E0                 call    ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Unchecked<MenuItemUnit *>(MenuItemUnit *)
.text$mn:000043E5                 add     esp, 4
.text$mn:000043E8                 push    eax             ; int
.text$mn:000043E9                 mov     eax, [ebp+arg_0]
.text$mn:000043EC                 push    eax
.text$mn:000043ED                 call    ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Unchecked<MenuItemUnit *>(MenuItemUnit *)
.text$mn:000043F2                 add     esp, 4
.text$mn:000043F5                 push    eax             ; int
.text$mn:000043F6                 call    ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z ; std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)
.text$mn:000043FB                 add     esp, 10h
.text$mn:000043FE                 push    eax
.text$mn:000043FF                 lea     ecx, [ebp+arg_8]
.text$mn:00004402                 push    ecx
.text$mn:00004403                 call    ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z ; std::_Rechecked<MenuItemUnit *,MenuItemUnit *>(MenuItemUnit * &,MenuItemUnit *)
.text$mn:00004408                 add     esp, 8
.text$mn:0000440B                 mov     eax, [eax]
.text$mn:0000440D                 pop     ebp
.text$mn:0000440E                 retn
.text$mn:0000440E ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z endp
.text$mn:0000440E
.text$mn:0000440E ; ---------------------------------------------------------------------------
.text$mn:0000440F                 align 10h
.text$mn:0000440F _text$mn        ends
.text$mn:0000440F
.text$mn:00004410 ; ===========================================================================
.text$mn:00004410
.text$mn:00004410 ; Segment type: Pure code
.text$mn:00004410 ; Segment permissions: Read/Execute
.text$mn:00004410 _text$mn        segment para public 'CODE' use32
.text$mn:00004410                 assume cs:_text$mn
.text$mn:00004410                 ;org 4410h
.text$mn:00004410 ; COMDAT (pick any)
.text$mn:00004410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004410
.text$mn:00004410 ; =============== S U B R O U T I N E =======================================
.text$mn:00004410
.text$mn:00004410 ; Attributes: bp-based frame
.text$mn:00004410
.text$mn:00004410 ; struct MenuItemUnit * __cdecl std::_Val_type<struct MenuItemUnit *>(struct MenuItemUnit *)
.text$mn:00004410                 public ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z
.text$mn:00004410 ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z proc near
.text$mn:00004410                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+20p
.text$mn:00004410                 push    ebp
.text$mn:00004411                 mov     ebp, esp
.text$mn:00004413                 xor     eax, eax
.text$mn:00004415                 pop     ebp
.text$mn:00004416                 retn
.text$mn:00004416 ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z endp
.text$mn:00004416
.text$mn:00004416 ; ---------------------------------------------------------------------------
.text$mn:00004417                 align 4
.text$mn:00004417 _text$mn        ends
.text$mn:00004417
.text$mn:00004418 ; ===========================================================================
.text$mn:00004418
.text$mn:00004418 ; Segment type: Pure code
.text$mn:00004418 ; Segment permissions: Read/Execute
.text$mn:00004418 _text$mn        segment para public 'CODE' use32
.text$mn:00004418                 assume cs:_text$mn
.text$mn:00004418                 ;org 4418h
.text$mn:00004418 ; COMDAT (pick any)
.text$mn:00004418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004418
.text$mn:00004418 ; =============== S U B R O U T I N E =======================================
.text$mn:00004418
.text$mn:00004418 ; Attributes: bp-based frame
.text$mn:00004418
.text$mn:00004418 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00004418                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00004418 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00004418                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00004418                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00004418
.text$mn:00004418 arg_0           = dword ptr  8
.text$mn:00004418
.text$mn:00004418                 push    ebp
.text$mn:00004419                 mov     ebp, esp
.text$mn:0000441B                 mov     eax, [ebp+arg_0]
.text$mn:0000441E                 pop     ebp
.text$mn:0000441F                 retn
.text$mn:0000441F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000441F
.text$mn:0000441F _text$mn        ends
.text$mn:0000441F
.text$mn:00004420 ; ===========================================================================
.text$mn:00004420
.text$mn:00004420 ; Segment type: Pure code
.text$mn:00004420 ; Segment permissions: Read/Execute
.text$mn:00004420 _text$mn        segment para public 'CODE' use32
.text$mn:00004420                 assume cs:_text$mn
.text$mn:00004420                 ;org 4420h
.text$mn:00004420 ; COMDAT (pick any)
.text$mn:00004420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004420
.text$mn:00004420 ; =============== S U B R O U T I N E =======================================
.text$mn:00004420
.text$mn:00004420 ; Attributes: bp-based frame
.text$mn:00004420
.text$mn:00004420 ; struct MenuItemUnit * __cdecl std::addressof<struct MenuItemUnit>(struct MenuItemUnit &)
.text$mn:00004420                 public ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z
.text$mn:00004420 ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z proc near
.text$mn:00004420                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+Dp
.text$mn:00004420                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+2Dp
.text$mn:00004420
.text$mn:00004420 arg_0           = dword ptr  8
.text$mn:00004420
.text$mn:00004420                 push    ebp
.text$mn:00004421                 mov     ebp, esp
.text$mn:00004423                 mov     eax, [ebp+arg_0]
.text$mn:00004426                 pop     ebp
.text$mn:00004427                 retn
.text$mn:00004427 ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z endp
.text$mn:00004427
.text$mn:00004427 _text$mn        ends
.text$mn:00004427
.text$mn:00004428 ; ===========================================================================
.text$mn:00004428
.text$mn:00004428 ; Segment type: Pure code
.text$mn:00004428 ; Segment permissions: Read/Execute
.text$mn:00004428 _text$mn        segment para public 'CODE' use32
.text$mn:00004428                 assume cs:_text$mn
.text$mn:00004428                 ;org 4428h
.text$mn:00004428 ; COMDAT (pick any)
.text$mn:00004428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004428
.text$mn:00004428 ; =============== S U B R O U T I N E =======================================
.text$mn:00004428
.text$mn:00004428 ; Attributes: bp-based frame
.text$mn:00004428
.text$mn:00004428 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00004428                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00004428 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00004428                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00004428                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00004428
.text$mn:00004428 arg_0           = dword ptr  8
.text$mn:00004428
.text$mn:00004428                 push    ebp
.text$mn:00004429                 mov     ebp, esp
.text$mn:0000442B                 mov     eax, [ebp+arg_0]
.text$mn:0000442E                 pop     ebp
.text$mn:0000442F                 retn
.text$mn:0000442F ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000442F
.text$mn:0000442F _text$mn        ends
.text$mn:0000442F
.text$mn:00004430 ; ===========================================================================
.text$mn:00004430
.text$mn:00004430 ; Segment type: Pure code
.text$mn:00004430 ; Segment permissions: Read/Execute
.text$mn:00004430 _text$mn        segment para public 'CODE' use32
.text$mn:00004430                 assume cs:_text$mn
.text$mn:00004430                 ;org 4430h
.text$mn:00004430 ; COMDAT (pick any)
.text$mn:00004430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004430
.text$mn:00004430 ; =============== S U B R O U T I N E =======================================
.text$mn:00004430
.text$mn:00004430 ; Attributes: bp-based frame
.text$mn:00004430
.text$mn:00004430 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00004430                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00004430 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00004430                                         ; CODE XREF: $LN19+4Bp
.text$mn:00004430
.text$mn:00004430 var_4           = dword ptr -4
.text$mn:00004430 arg_0           = dword ptr  8
.text$mn:00004430 arg_4           = dword ptr  0Ch
.text$mn:00004430
.text$mn:00004430                 push    ebp
.text$mn:00004431                 mov     ebp, esp
.text$mn:00004433                 push    ecx
.text$mn:00004434                 mov     [ebp+var_4], ecx
.text$mn:00004437                 mov     eax, [ebp+arg_4]
.text$mn:0000443A                 push    eax
.text$mn:0000443B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00004440                 add     esp, 4
.text$mn:00004443                 push    eax             ; int
.text$mn:00004444                 mov     ecx, [ebp+arg_0]
.text$mn:00004447                 push    ecx             ; void *
.text$mn:00004448                 mov     edx, [ebp+var_4]
.text$mn:0000444B                 push    edx             ; int
.text$mn:0000444C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00004451                 add     esp, 0Ch
.text$mn:00004454                 mov     esp, ebp
.text$mn:00004456                 pop     ebp
.text$mn:00004457                 retn    8
.text$mn:00004457 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00004457
.text$mn:00004457 ; ---------------------------------------------------------------------------
.text$mn:0000445A                 align 4
.text$mn:0000445A _text$mn        ends
.text$mn:0000445A
.text$mn:0000445C ; ===========================================================================
.text$mn:0000445C
.text$mn:0000445C ; Segment type: Pure code
.text$mn:0000445C ; Segment permissions: Read/Execute
.text$mn:0000445C _text$mn        segment para public 'CODE' use32
.text$mn:0000445C                 assume cs:_text$mn
.text$mn:0000445C                 ;org 445Ch
.text$mn:0000445C ; COMDAT (pick any)
.text$mn:0000445C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000445C
.text$mn:0000445C ; =============== S U B R O U T I N E =======================================
.text$mn:0000445C
.text$mn:0000445C ; Attributes: bp-based frame
.text$mn:0000445C
.text$mn:0000445C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000445C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000445C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000445C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000445C
.text$mn:0000445C var_1C          = dword ptr -1Ch
.text$mn:0000445C var_18          = dword ptr -18h
.text$mn:0000445C var_14          = dword ptr -14h
.text$mn:0000445C var_10          = dword ptr -10h
.text$mn:0000445C var_C           = dword ptr -0Ch
.text$mn:0000445C var_4           = dword ptr -4
.text$mn:0000445C arg_0           = dword ptr  8
.text$mn:0000445C arg_4           = dword ptr  0Ch
.text$mn:0000445C
.text$mn:0000445C                 push    ebp
.text$mn:0000445D                 mov     ebp, esp
.text$mn:0000445F                 push    0FFFFFFFFh
.text$mn:00004461                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00004466                 mov     eax, large fs:0
.text$mn:0000446C                 push    eax
.text$mn:0000446D                 sub     esp, 10h
.text$mn:00004470                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004475                 xor     eax, ebp
.text$mn:00004477                 push    eax
.text$mn:00004478                 lea     eax, [ebp+var_C]
.text$mn:0000447B                 mov     large fs:0, eax
.text$mn:00004481                 mov     [ebp+var_18], ecx
.text$mn:00004484                 mov     eax, [ebp+arg_0]
.text$mn:00004487                 push    eax             ; void *
.text$mn:00004488                 push    4               ; unsigned int
.text$mn:0000448A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000448F                 add     esp, 8
.text$mn:00004492                 mov     [ebp+var_10], eax
.text$mn:00004495                 mov     [ebp+var_4], 0
.text$mn:0000449C                 cmp     [ebp+var_10], 0
.text$mn:000044A0                 jz      short loc_44BD
.text$mn:000044A2                 mov     ecx, [ebp+arg_4]
.text$mn:000044A5                 push    ecx
.text$mn:000044A6                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000044AB                 add     esp, 4
.text$mn:000044AE                 mov     edx, [ebp+var_10]
.text$mn:000044B1                 mov     eax, [eax]
.text$mn:000044B3                 mov     [edx], eax
.text$mn:000044B5                 mov     ecx, [ebp+var_10]
.text$mn:000044B8                 mov     [ebp+var_14], ecx
.text$mn:000044BB                 jmp     short loc_44C4
.text$mn:000044BD ; ---------------------------------------------------------------------------
.text$mn:000044BD
.text$mn:000044BD loc_44BD:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000044BD                 mov     [ebp+var_14], 0
.text$mn:000044C4
.text$mn:000044C4 loc_44C4:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000044C4                 mov     edx, [ebp+var_14]
.text$mn:000044C7                 mov     [ebp+var_1C], edx
.text$mn:000044CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044D1                 mov     ecx, [ebp+var_C]
.text$mn:000044D4                 mov     large fs:0, ecx
.text$mn:000044DB                 pop     ecx
.text$mn:000044DC                 mov     esp, ebp
.text$mn:000044DE                 pop     ebp
.text$mn:000044DF                 retn    8
.text$mn:000044DF ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000044DF
.text$mn:000044DF ; ---------------------------------------------------------------------------
.text$mn:000044E2                 align 4
.text$mn:000044E2 _text$mn        ends
.text$mn:000044E2
.text$x:000044E4 ; ===========================================================================
.text$x:000044E4
.text$x:000044E4 ; Segment type: Pure code
.text$x:000044E4 ; Segment permissions: Read/Execute
.text$x:000044E4 _text$x         segment para public 'CODE' use32
.text$x:000044E4                 assume cs:_text$x
.text$x:000044E4                 ;org 44E4h
.text$x:000044E4 ; COMDAT (pick associative to section at 445C)
.text$x:000044E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000044E4
.text$x:000044E4 ; =============== S U B R O U T I N E =======================================
.text$x:000044E4
.text$x:000044E4
.text$x:000044E4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000044E4                                         ; DATA XREF: .xdata$x:0000E53Co
.text$x:000044E4                 mov     eax, [ebp+8]
.text$x:000044E7                 push    eax
.text$x:000044E8                 mov     eax, [ebp-10h]
.text$x:000044EB                 push    eax             ; void *
.text$x:000044EC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000044F1                 add     esp, 8
.text$x:000044F4                 retn
.text$x:000044F4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000044F4
.text$x:000044F5
.text$x:000044F5 ; =============== S U B R O U T I N E =======================================
.text$x:000044F5
.text$x:000044F5
.text$x:000044F5 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000044F5                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000044F5
.text$x:000044F5 arg_4           = dword ptr  8
.text$x:000044F5
.text$x:000044F5                 mov     edx, [esp+arg_4]
.text$x:000044F9                 lea     eax, [edx+0Ch]
.text$x:000044FC                 mov     ecx, [edx-14h]
.text$x:000044FF                 xor     ecx, eax
.text$x:00004501                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004506                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000450B                 jmp     ___CxxFrameHandler3
.text$x:0000450B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000450B
.text$x:0000450B _text$x         ends
.text$x:0000450B
.text$mn:00004510 ; ===========================================================================
.text$mn:00004510
.text$mn:00004510 ; Segment type: Pure code
.text$mn:00004510 ; Segment permissions: Read/Execute
.text$mn:00004510 _text$mn        segment para public 'CODE' use32
.text$mn:00004510                 assume cs:_text$mn
.text$mn:00004510                 ;org 4510h
.text$mn:00004510 ; COMDAT (pick any)
.text$mn:00004510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004510
.text$mn:00004510 ; =============== S U B R O U T I N E =======================================
.text$mn:00004510
.text$mn:00004510 ; Attributes: bp-based frame
.text$mn:00004510
.text$mn:00004510 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00004510                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00004510 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00004510                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00004510
.text$mn:00004510 arg_0           = dword ptr  8
.text$mn:00004510 arg_4           = dword ptr  0Ch
.text$mn:00004510 arg_8           = dword ptr  10h
.text$mn:00004510
.text$mn:00004510                 push    ebp
.text$mn:00004511                 mov     ebp, esp
.text$mn:00004513                 mov     eax, [ebp+arg_8]
.text$mn:00004516                 push    eax
.text$mn:00004517                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000451C                 add     esp, 4
.text$mn:0000451F                 push    eax             ; int
.text$mn:00004520                 mov     ecx, [ebp+arg_4]
.text$mn:00004523                 push    ecx             ; void *
.text$mn:00004524                 mov     ecx, [ebp+arg_0]
.text$mn:00004527                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000452C                 pop     ebp
.text$mn:0000452D                 retn
.text$mn:0000452D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000452D
.text$mn:0000452D ; ---------------------------------------------------------------------------
.text$mn:0000452E                 align 10h
.text$mn:0000452E _text$mn        ends
.text$mn:0000452E
.text$mn:00004530 ; ===========================================================================
.text$mn:00004530
.text$mn:00004530 ; Segment type: Pure code
.text$mn:00004530 ; Segment permissions: Read/Execute
.text$mn:00004530 _text$mn        segment para public 'CODE' use32
.text$mn:00004530                 assume cs:_text$mn
.text$mn:00004530                 ;org 4530h
.text$mn:00004530 ; COMDAT (pick any)
.text$mn:00004530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004530
.text$mn:00004530 ; =============== S U B R O U T I N E =======================================
.text$mn:00004530
.text$mn:00004530 ; Attributes: bp-based frame
.text$mn:00004530
.text$mn:00004530 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00004530                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00004530 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00004530                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00004530
.text$mn:00004530 var_4           = dword ptr -4
.text$mn:00004530 arg_0           = dword ptr  8
.text$mn:00004530 arg_4           = dword ptr  0Ch
.text$mn:00004530
.text$mn:00004530                 push    ebp
.text$mn:00004531                 mov     ebp, esp
.text$mn:00004533                 push    ecx
.text$mn:00004534                 mov     [ebp+var_4], ecx
.text$mn:00004537                 mov     eax, [ebp+arg_4]
.text$mn:0000453A                 push    eax
.text$mn:0000453B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00004540                 add     esp, 4
.text$mn:00004543                 push    eax             ; int
.text$mn:00004544                 mov     ecx, [ebp+arg_0]
.text$mn:00004547                 push    ecx             ; void *
.text$mn:00004548                 mov     edx, [ebp+var_4]
.text$mn:0000454B                 push    edx             ; int
.text$mn:0000454C                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00004551                 add     esp, 0Ch
.text$mn:00004554                 mov     esp, ebp
.text$mn:00004556                 pop     ebp
.text$mn:00004557                 retn    8
.text$mn:00004557 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00004557
.text$mn:00004557 ; ---------------------------------------------------------------------------
.text$mn:0000455A                 align 4
.text$mn:0000455A _text$mn        ends
.text$mn:0000455A
.text$mn:0000455C ; ===========================================================================
.text$mn:0000455C
.text$mn:0000455C ; Segment type: Pure code
.text$mn:0000455C ; Segment permissions: Read/Execute
.text$mn:0000455C _text$mn        segment para public 'CODE' use32
.text$mn:0000455C                 assume cs:_text$mn
.text$mn:0000455C                 ;org 455Ch
.text$mn:0000455C ; COMDAT (pick any)
.text$mn:0000455C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000455C
.text$mn:0000455C ; =============== S U B R O U T I N E =======================================
.text$mn:0000455C
.text$mn:0000455C ; Attributes: bp-based frame
.text$mn:0000455C
.text$mn:0000455C ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:0000455C                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000455C ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:0000455C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:0000455C
.text$mn:0000455C var_1C          = dword ptr -1Ch
.text$mn:0000455C var_18          = dword ptr -18h
.text$mn:0000455C var_14          = dword ptr -14h
.text$mn:0000455C var_10          = dword ptr -10h
.text$mn:0000455C var_C           = dword ptr -0Ch
.text$mn:0000455C var_4           = dword ptr -4
.text$mn:0000455C arg_0           = dword ptr  8
.text$mn:0000455C arg_4           = dword ptr  0Ch
.text$mn:0000455C
.text$mn:0000455C                 push    ebp
.text$mn:0000455D                 mov     ebp, esp
.text$mn:0000455F                 push    0FFFFFFFFh
.text$mn:00004561                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00004566                 mov     eax, large fs:0
.text$mn:0000456C                 push    eax
.text$mn:0000456D                 sub     esp, 10h
.text$mn:00004570                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004575                 xor     eax, ebp
.text$mn:00004577                 push    eax
.text$mn:00004578                 lea     eax, [ebp+var_C]
.text$mn:0000457B                 mov     large fs:0, eax
.text$mn:00004581                 mov     [ebp+var_18], ecx
.text$mn:00004584                 mov     eax, [ebp+arg_0]
.text$mn:00004587                 push    eax             ; void *
.text$mn:00004588                 push    4               ; unsigned int
.text$mn:0000458A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000458F                 add     esp, 8
.text$mn:00004592                 mov     [ebp+var_10], eax
.text$mn:00004595                 mov     [ebp+var_4], 0
.text$mn:0000459C                 cmp     [ebp+var_10], 0
.text$mn:000045A0                 jz      short loc_45BD
.text$mn:000045A2                 mov     ecx, [ebp+arg_4]
.text$mn:000045A5                 push    ecx
.text$mn:000045A6                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000045AB                 add     esp, 4
.text$mn:000045AE                 mov     edx, [ebp+var_10]
.text$mn:000045B1                 mov     eax, [eax]
.text$mn:000045B3                 mov     [edx], eax
.text$mn:000045B5                 mov     ecx, [ebp+var_10]
.text$mn:000045B8                 mov     [ebp+var_14], ecx
.text$mn:000045BB                 jmp     short loc_45C4
.text$mn:000045BD ; ---------------------------------------------------------------------------
.text$mn:000045BD
.text$mn:000045BD loc_45BD:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:000045BD                 mov     [ebp+var_14], 0
.text$mn:000045C4
.text$mn:000045C4 loc_45C4:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:000045C4                 mov     edx, [ebp+var_14]
.text$mn:000045C7                 mov     [ebp+var_1C], edx
.text$mn:000045CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000045D1                 mov     ecx, [ebp+var_C]
.text$mn:000045D4                 mov     large fs:0, ecx
.text$mn:000045DB                 pop     ecx
.text$mn:000045DC                 mov     esp, ebp
.text$mn:000045DE                 pop     ebp
.text$mn:000045DF                 retn    8
.text$mn:000045DF ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000045DF
.text$mn:000045DF ; ---------------------------------------------------------------------------
.text$mn:000045E2                 align 4
.text$mn:000045E2 _text$mn        ends
.text$mn:000045E2
.text$x:000045E4 ; ===========================================================================
.text$x:000045E4
.text$x:000045E4 ; Segment type: Pure code
.text$x:000045E4 ; Segment permissions: Read/Execute
.text$x:000045E4 _text$x         segment para public 'CODE' use32
.text$x:000045E4                 assume cs:_text$x
.text$x:000045E4                 ;org 45E4h
.text$x:000045E4 ; COMDAT (pick associative to section at 455C)
.text$x:000045E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000045E4
.text$x:000045E4 ; =============== S U B R O U T I N E =======================================
.text$x:000045E4
.text$x:000045E4
.text$x:000045E4 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000045E4                                         ; DATA XREF: .xdata$x:0000E568o
.text$x:000045E4                 mov     eax, [ebp+8]
.text$x:000045E7                 push    eax
.text$x:000045E8                 mov     eax, [ebp-10h]
.text$x:000045EB                 push    eax             ; void *
.text$x:000045EC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000045F1                 add     esp, 8
.text$x:000045F4                 retn
.text$x:000045F4 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:000045F4
.text$x:000045F5
.text$x:000045F5 ; =============== S U B R O U T I N E =======================================
.text$x:000045F5
.text$x:000045F5
.text$x:000045F5 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:000045F5                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:000045F5
.text$x:000045F5 arg_4           = dword ptr  8
.text$x:000045F5
.text$x:000045F5                 mov     edx, [esp+arg_4]
.text$x:000045F9                 lea     eax, [edx+0Ch]
.text$x:000045FC                 mov     ecx, [edx-14h]
.text$x:000045FF                 xor     ecx, eax
.text$x:00004601                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004606                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:0000460B                 jmp     ___CxxFrameHandler3
.text$x:0000460B __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:0000460B
.text$x:0000460B _text$x         ends
.text$x:0000460B
.text$mn:00004610 ; ===========================================================================
.text$mn:00004610
.text$mn:00004610 ; Segment type: Pure code
.text$mn:00004610 ; Segment permissions: Read/Execute
.text$mn:00004610 _text$mn        segment para public 'CODE' use32
.text$mn:00004610                 assume cs:_text$mn
.text$mn:00004610                 ;org 4610h
.text$mn:00004610 ; COMDAT (pick any)
.text$mn:00004610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004610
.text$mn:00004610 ; =============== S U B R O U T I N E =======================================
.text$mn:00004610
.text$mn:00004610 ; Attributes: bp-based frame
.text$mn:00004610
.text$mn:00004610 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00004610                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00004610 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00004610                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00004610
.text$mn:00004610 arg_0           = dword ptr  8
.text$mn:00004610 arg_4           = dword ptr  0Ch
.text$mn:00004610 arg_8           = dword ptr  10h
.text$mn:00004610
.text$mn:00004610                 push    ebp
.text$mn:00004611                 mov     ebp, esp
.text$mn:00004613                 mov     eax, [ebp+arg_8]
.text$mn:00004616                 push    eax
.text$mn:00004617                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000461C                 add     esp, 4
.text$mn:0000461F                 push    eax             ; int
.text$mn:00004620                 mov     ecx, [ebp+arg_4]
.text$mn:00004623                 push    ecx             ; void *
.text$mn:00004624                 mov     ecx, [ebp+arg_0]
.text$mn:00004627                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000462C                 pop     ebp
.text$mn:0000462D                 retn
.text$mn:0000462D ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:0000462D
.text$mn:0000462D ; ---------------------------------------------------------------------------
.text$mn:0000462E                 align 10h
.text$mn:0000462E _text$mn        ends
.text$mn:0000462E
.text$mn:00004630 ; ===========================================================================
.text$mn:00004630
.text$mn:00004630 ; Segment type: Pure code
.text$mn:00004630 ; Segment permissions: Read/Execute
.text$mn:00004630 _text$mn        segment para public 'CODE' use32
.text$mn:00004630                 assume cs:_text$mn
.text$mn:00004630                 ;org 4630h
.text$mn:00004630 ; COMDAT (pick any)
.text$mn:00004630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004630
.text$mn:00004630 ; =============== S U B R O U T I N E =======================================
.text$mn:00004630
.text$mn:00004630 ; Attributes: bp-based frame
.text$mn:00004630
.text$mn:00004630 ; int __stdcall std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo &>(void *, int)
.text$mn:00004630                 public ??$construct@UKeyCombo@@AAU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@AAU2@@Z
.text$mn:00004630 ??$construct@UKeyCombo@@AAU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@AAU2@@Z proc near
.text$mn:00004630                                         ; CODE XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004630
.text$mn:00004630 var_4           = dword ptr -4
.text$mn:00004630 arg_0           = dword ptr  8
.text$mn:00004630 arg_4           = dword ptr  0Ch
.text$mn:00004630
.text$mn:00004630                 push    ebp
.text$mn:00004631                 mov     ebp, esp
.text$mn:00004633                 push    ecx
.text$mn:00004634                 mov     [ebp+var_4], ecx
.text$mn:00004637                 mov     eax, [ebp+arg_4]
.text$mn:0000463A                 push    eax
.text$mn:0000463B                 call    ??$forward@AAUKeyCombo@@@std@@YAAAUKeyCombo@@AAU1@@Z ; std::forward<KeyCombo &>(KeyCombo &)
.text$mn:00004640                 add     esp, 4
.text$mn:00004643                 push    eax             ; int
.text$mn:00004644                 mov     ecx, [ebp+arg_0]
.text$mn:00004647                 push    ecx             ; void *
.text$mn:00004648                 mov     edx, [ebp+var_4]
.text$mn:0000464B                 push    edx             ; int
.text$mn:0000464C                 call    ??$construct@UKeyCombo@@AAU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@AAU3@@Z ; std::allocator_traits<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo &>(std::allocator<KeyCombo> &,KeyCombo *,KeyCombo &)
.text$mn:00004651                 add     esp, 0Ch
.text$mn:00004654                 mov     esp, ebp
.text$mn:00004656                 pop     ebp
.text$mn:00004657                 retn    8
.text$mn:00004657 ??$construct@UKeyCombo@@AAU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@AAU2@@Z endp
.text$mn:00004657
.text$mn:00004657 ; ---------------------------------------------------------------------------
.text$mn:0000465A                 align 4
.text$mn:0000465A _text$mn        ends
.text$mn:0000465A
.text$mn:0000465C ; ===========================================================================
.text$mn:0000465C
.text$mn:0000465C ; Segment type: Pure code
.text$mn:0000465C ; Segment permissions: Read/Execute
.text$mn:0000465C _text$mn        segment para public 'CODE' use32
.text$mn:0000465C                 assume cs:_text$mn
.text$mn:0000465C                 ;org 465Ch
.text$mn:0000465C ; COMDAT (pick any)
.text$mn:0000465C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000465C
.text$mn:0000465C ; =============== S U B R O U T I N E =======================================
.text$mn:0000465C
.text$mn:0000465C ; Attributes: bp-based frame
.text$mn:0000465C
.text$mn:0000465C ; int __stdcall std::allocator<KeyCombo>::construct<KeyCombo,KeyCombo &>(void *, int)
.text$mn:0000465C                 public ??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z
.text$mn:0000465C ??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z proc near
.text$mn:0000465C                                         ; CODE XREF: std::allocator_traits<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo &>(std::allocator<KeyCombo> &,KeyCombo *,KeyCombo &)+17p
.text$mn:0000465C
.text$mn:0000465C var_1C          = dword ptr -1Ch
.text$mn:0000465C var_18          = dword ptr -18h
.text$mn:0000465C var_14          = dword ptr -14h
.text$mn:0000465C var_10          = dword ptr -10h
.text$mn:0000465C var_C           = dword ptr -0Ch
.text$mn:0000465C var_4           = dword ptr -4
.text$mn:0000465C arg_0           = dword ptr  8
.text$mn:0000465C arg_4           = dword ptr  0Ch
.text$mn:0000465C
.text$mn:0000465C                 push    ebp
.text$mn:0000465D                 mov     ebp, esp
.text$mn:0000465F                 push    0FFFFFFFFh
.text$mn:00004661                 push    offset __ehhandler$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z
.text$mn:00004666                 mov     eax, large fs:0
.text$mn:0000466C                 push    eax
.text$mn:0000466D                 sub     esp, 10h
.text$mn:00004670                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004675                 xor     eax, ebp
.text$mn:00004677                 push    eax
.text$mn:00004678                 lea     eax, [ebp+var_C]
.text$mn:0000467B                 mov     large fs:0, eax
.text$mn:00004681                 mov     [ebp+var_18], ecx
.text$mn:00004684                 mov     eax, [ebp+arg_0]
.text$mn:00004687                 push    eax             ; void *
.text$mn:00004688                 push    4               ; unsigned int
.text$mn:0000468A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000468F                 add     esp, 8
.text$mn:00004692                 mov     [ebp+var_10], eax
.text$mn:00004695                 mov     [ebp+var_4], 0
.text$mn:0000469C                 cmp     [ebp+var_10], 0
.text$mn:000046A0                 jz      short loc_46BD
.text$mn:000046A2                 mov     ecx, [ebp+arg_4]
.text$mn:000046A5                 push    ecx
.text$mn:000046A6                 call    ??$forward@AAUKeyCombo@@@std@@YAAAUKeyCombo@@AAU1@@Z ; std::forward<KeyCombo &>(KeyCombo &)
.text$mn:000046AB                 add     esp, 4
.text$mn:000046AE                 mov     edx, [eax]
.text$mn:000046B0                 mov     eax, [ebp+var_10]
.text$mn:000046B3                 mov     [eax], edx
.text$mn:000046B5                 mov     ecx, [ebp+var_10]
.text$mn:000046B8                 mov     [ebp+var_14], ecx
.text$mn:000046BB                 jmp     short loc_46C4
.text$mn:000046BD ; ---------------------------------------------------------------------------
.text$mn:000046BD
.text$mn:000046BD loc_46BD:                               ; CODE XREF: std::allocator<KeyCombo>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)+44j
.text$mn:000046BD                 mov     [ebp+var_14], 0
.text$mn:000046C4
.text$mn:000046C4 loc_46C4:                               ; CODE XREF: std::allocator<KeyCombo>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)+5Fj
.text$mn:000046C4                 mov     edx, [ebp+var_14]
.text$mn:000046C7                 mov     [ebp+var_1C], edx
.text$mn:000046CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000046D1                 mov     ecx, [ebp+var_C]
.text$mn:000046D4                 mov     large fs:0, ecx
.text$mn:000046DB                 pop     ecx
.text$mn:000046DC                 mov     esp, ebp
.text$mn:000046DE                 pop     ebp
.text$mn:000046DF                 retn    8
.text$mn:000046DF ??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z endp
.text$mn:000046DF
.text$mn:000046DF ; ---------------------------------------------------------------------------
.text$mn:000046E2                 align 4
.text$mn:000046E2 _text$mn        ends
.text$mn:000046E2
.text$x:000046E4 ; ===========================================================================
.text$x:000046E4
.text$x:000046E4 ; Segment type: Pure code
.text$x:000046E4 ; Segment permissions: Read/Execute
.text$x:000046E4 _text$x         segment para public 'CODE' use32
.text$x:000046E4                 assume cs:_text$x
.text$x:000046E4                 ;org 46E4h
.text$x:000046E4 ; COMDAT (pick associative to section at 465C)
.text$x:000046E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000046E4
.text$x:000046E4 ; =============== S U B R O U T I N E =======================================
.text$x:000046E4
.text$x:000046E4
.text$x:000046E4 __unwindfunclet$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z$0 proc near
.text$x:000046E4                                         ; DATA XREF: .xdata$x:0000E4B8o
.text$x:000046E4                 mov     eax, [ebp+8]
.text$x:000046E7                 push    eax
.text$x:000046E8                 mov     eax, [ebp-10h]
.text$x:000046EB                 push    eax             ; void *
.text$x:000046EC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000046F1                 add     esp, 8
.text$x:000046F4                 retn
.text$x:000046F4 __unwindfunclet$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z$0 endp
.text$x:000046F4
.text$x:000046F5
.text$x:000046F5 ; =============== S U B R O U T I N E =======================================
.text$x:000046F5
.text$x:000046F5
.text$x:000046F5 __ehhandler$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z proc near
.text$x:000046F5                                         ; DATA XREF: std::allocator<KeyCombo>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)+5o
.text$x:000046F5
.text$x:000046F5 arg_4           = dword ptr  8
.text$x:000046F5
.text$x:000046F5                 mov     edx, [esp+arg_4]
.text$x:000046F9                 lea     eax, [edx+0Ch]
.text$x:000046FC                 mov     ecx, [edx-14h]
.text$x:000046FF                 xor     ecx, eax
.text$x:00004701                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004706                 mov     eax, offset __ehfuncinfo$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z
.text$x:0000470B                 jmp     ___CxxFrameHandler3
.text$x:0000470B __ehhandler$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z endp
.text$x:0000470B
.text$x:0000470B _text$x         ends
.text$x:0000470B
.text$mn:00004710 ; ===========================================================================
.text$mn:00004710
.text$mn:00004710 ; Segment type: Pure code
.text$mn:00004710 ; Segment permissions: Read/Execute
.text$mn:00004710 _text$mn        segment para public 'CODE' use32
.text$mn:00004710                 assume cs:_text$mn
.text$mn:00004710                 ;org 4710h
.text$mn:00004710 ; COMDAT (pick any)
.text$mn:00004710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004710
.text$mn:00004710 ; =============== S U B R O U T I N E =======================================
.text$mn:00004710
.text$mn:00004710 ; Attributes: bp-based frame
.text$mn:00004710
.text$mn:00004710 ; int __cdecl std::allocator_traits<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo &>(int, void *, int)
.text$mn:00004710                 public ??$construct@UKeyCombo@@AAU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@AAU3@@Z
.text$mn:00004710 ??$construct@UKeyCombo@@AAU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@AAU3@@Z proc near
.text$mn:00004710                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)+1Cp
.text$mn:00004710
.text$mn:00004710 arg_0           = dword ptr  8
.text$mn:00004710 arg_4           = dword ptr  0Ch
.text$mn:00004710 arg_8           = dword ptr  10h
.text$mn:00004710
.text$mn:00004710                 push    ebp
.text$mn:00004711                 mov     ebp, esp
.text$mn:00004713                 mov     eax, [ebp+arg_8]
.text$mn:00004716                 push    eax
.text$mn:00004717                 call    ??$forward@AAUKeyCombo@@@std@@YAAAUKeyCombo@@AAU1@@Z ; std::forward<KeyCombo &>(KeyCombo &)
.text$mn:0000471C                 add     esp, 4
.text$mn:0000471F                 push    eax             ; int
.text$mn:00004720                 mov     ecx, [ebp+arg_4]
.text$mn:00004723                 push    ecx             ; void *
.text$mn:00004724                 mov     ecx, [ebp+arg_0]
.text$mn:00004727                 call    ??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z ; std::allocator<KeyCombo>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)
.text$mn:0000472C                 pop     ebp
.text$mn:0000472D                 retn
.text$mn:0000472D ??$construct@UKeyCombo@@AAU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@AAU3@@Z endp
.text$mn:0000472D
.text$mn:0000472D ; ---------------------------------------------------------------------------
.text$mn:0000472E                 align 10h
.text$mn:0000472E _text$mn        ends
.text$mn:0000472E
.text$mn:00004730 ; ===========================================================================
.text$mn:00004730
.text$mn:00004730 ; Segment type: Pure code
.text$mn:00004730 ; Segment permissions: Read/Execute
.text$mn:00004730 _text$mn        segment para public 'CODE' use32
.text$mn:00004730                 assume cs:_text$mn
.text$mn:00004730                 ;org 4730h
.text$mn:00004730 ; COMDAT (pick any)
.text$mn:00004730                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004730
.text$mn:00004730 ; =============== S U B R O U T I N E =======================================
.text$mn:00004730
.text$mn:00004730 ; Attributes: bp-based frame
.text$mn:00004730
.text$mn:00004730 ; int __stdcall std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(void *, int)
.text$mn:00004730                 public ??$construct@UKeyCombo@@ABU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@ABU2@@Z
.text$mn:00004730 ??$construct@UKeyCombo@@ABU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@ABU2@@Z proc near
.text$mn:00004730                                         ; CODE XREF: std::_Uninit_copy<KeyCombo const *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo const *,KeyCombo const *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004730
.text$mn:00004730 var_4           = dword ptr -4
.text$mn:00004730 arg_0           = dword ptr  8
.text$mn:00004730 arg_4           = dword ptr  0Ch
.text$mn:00004730
.text$mn:00004730                 push    ebp
.text$mn:00004731                 mov     ebp, esp
.text$mn:00004733                 push    ecx
.text$mn:00004734                 mov     [ebp+var_4], ecx
.text$mn:00004737                 mov     eax, [ebp+arg_4]
.text$mn:0000473A                 push    eax
.text$mn:0000473B                 call    ??$forward@ABUKeyCombo@@@std@@YAABUKeyCombo@@ABU1@@Z ; std::forward<KeyCombo const &>(KeyCombo const &)
.text$mn:00004740                 add     esp, 4
.text$mn:00004743                 push    eax             ; int
.text$mn:00004744                 mov     ecx, [ebp+arg_0]
.text$mn:00004747                 push    ecx             ; void *
.text$mn:00004748                 mov     edx, [ebp+var_4]
.text$mn:0000474B                 push    edx             ; int
.text$mn:0000474C                 call    ??$construct@UKeyCombo@@ABU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@ABU3@@Z ; std::allocator_traits<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(std::allocator<KeyCombo> &,KeyCombo *,KeyCombo const &)
.text$mn:00004751                 add     esp, 0Ch
.text$mn:00004754                 mov     esp, ebp
.text$mn:00004756                 pop     ebp
.text$mn:00004757                 retn    8
.text$mn:00004757 ??$construct@UKeyCombo@@ABU1@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@ABU2@@Z endp
.text$mn:00004757
.text$mn:00004757 ; ---------------------------------------------------------------------------
.text$mn:0000475A                 align 4
.text$mn:0000475A _text$mn        ends
.text$mn:0000475A
.text$mn:0000475C ; ===========================================================================
.text$mn:0000475C
.text$mn:0000475C ; Segment type: Pure code
.text$mn:0000475C ; Segment permissions: Read/Execute
.text$mn:0000475C _text$mn        segment para public 'CODE' use32
.text$mn:0000475C                 assume cs:_text$mn
.text$mn:0000475C                 ;org 475Ch
.text$mn:0000475C ; COMDAT (pick any)
.text$mn:0000475C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000475C
.text$mn:0000475C ; =============== S U B R O U T I N E =======================================
.text$mn:0000475C
.text$mn:0000475C ; Attributes: bp-based frame
.text$mn:0000475C
.text$mn:0000475C ; int __cdecl std::allocator_traits<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(int, void *, int)
.text$mn:0000475C                 public ??$construct@UKeyCombo@@ABU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@ABU3@@Z
.text$mn:0000475C ??$construct@UKeyCombo@@ABU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@ABU3@@Z proc near
.text$mn:0000475C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(KeyCombo *,KeyCombo const &)+1Cp
.text$mn:0000475C
.text$mn:0000475C arg_0           = dword ptr  8
.text$mn:0000475C arg_4           = dword ptr  0Ch
.text$mn:0000475C arg_8           = dword ptr  10h
.text$mn:0000475C
.text$mn:0000475C                 push    ebp
.text$mn:0000475D                 mov     ebp, esp
.text$mn:0000475F                 mov     eax, [ebp+arg_8]
.text$mn:00004762                 push    eax
.text$mn:00004763                 call    ??$forward@ABUKeyCombo@@@std@@YAABUKeyCombo@@ABU1@@Z ; std::forward<KeyCombo const &>(KeyCombo const &)
.text$mn:00004768                 add     esp, 4
.text$mn:0000476B                 push    eax             ; int
.text$mn:0000476C                 mov     ecx, [ebp+arg_4]
.text$mn:0000476F                 push    ecx             ; void *
.text$mn:00004770                 mov     ecx, [ebp+arg_0]
.text$mn:00004773                 call    ?construct@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@ABU3@@Z ; std::allocator<KeyCombo>::construct(KeyCombo *,KeyCombo const &)
.text$mn:00004778                 pop     ebp
.text$mn:00004779                 retn
.text$mn:00004779 ??$construct@UKeyCombo@@ABU1@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@ABU3@@Z endp
.text$mn:00004779
.text$mn:00004779 ; ---------------------------------------------------------------------------
.text$mn:0000477A                 align 4
.text$mn:0000477A _text$mn        ends
.text$mn:0000477A
.text$mn:0000477C ; ===========================================================================
.text$mn:0000477C
.text$mn:0000477C ; Segment type: Pure code
.text$mn:0000477C ; Segment permissions: Read/Execute
.text$mn:0000477C _text$mn        segment para public 'CODE' use32
.text$mn:0000477C                 assume cs:_text$mn
.text$mn:0000477C                 ;org 477Ch
.text$mn:0000477C ; COMDAT (pick any)
.text$mn:0000477C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000477C
.text$mn:0000477C ; =============== S U B R O U T I N E =======================================
.text$mn:0000477C
.text$mn:0000477C ; Attributes: bp-based frame
.text$mn:0000477C
.text$mn:0000477C ; int __stdcall std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(void *, int)
.text$mn:0000477C                 public ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$mn:0000477C ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z proc near
.text$mn:0000477C                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:0000477C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+9Dp ...
.text$mn:0000477C
.text$mn:0000477C var_4           = dword ptr -4
.text$mn:0000477C arg_0           = dword ptr  8
.text$mn:0000477C arg_4           = dword ptr  0Ch
.text$mn:0000477C
.text$mn:0000477C                 push    ebp
.text$mn:0000477D                 mov     ebp, esp
.text$mn:0000477F                 push    ecx
.text$mn:00004780                 mov     [ebp+var_4], ecx
.text$mn:00004783                 mov     eax, [ebp+arg_4]
.text$mn:00004786                 push    eax
.text$mn:00004787                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000478C                 add     esp, 4
.text$mn:0000478F                 push    eax             ; int
.text$mn:00004790                 mov     ecx, [ebp+arg_0]
.text$mn:00004793                 push    ecx             ; void *
.text$mn:00004794                 mov     edx, [ebp+var_4]
.text$mn:00004797                 push    edx             ; int
.text$mn:00004798                 call    ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z ; std::allocator_traits<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *,MenuItemUnit &&)
.text$mn:0000479D                 add     esp, 0Ch
.text$mn:000047A0                 mov     esp, ebp
.text$mn:000047A2                 pop     ebp
.text$mn:000047A3                 retn    8
.text$mn:000047A3 ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z endp
.text$mn:000047A3
.text$mn:000047A3 ; ---------------------------------------------------------------------------
.text$mn:000047A6                 align 4
.text$mn:000047A6 _text$mn        ends
.text$mn:000047A6
.text$mn:000047A8 ; ===========================================================================
.text$mn:000047A8
.text$mn:000047A8 ; Segment type: Pure code
.text$mn:000047A8 ; Segment permissions: Read/Execute
.text$mn:000047A8 _text$mn        segment para public 'CODE' use32
.text$mn:000047A8                 assume cs:_text$mn
.text$mn:000047A8                 ;org 47A8h
.text$mn:000047A8 ; COMDAT (pick any)
.text$mn:000047A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047A8
.text$mn:000047A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000047A8
.text$mn:000047A8 ; Attributes: bp-based frame
.text$mn:000047A8
.text$mn:000047A8 ; int __stdcall std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(void *, int)
.text$mn:000047A8                 public ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$mn:000047A8 ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z proc near
.text$mn:000047A8                                         ; CODE XREF: std::allocator_traits<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *,MenuItemUnit &&)+17p
.text$mn:000047A8
.text$mn:000047A8 var_1C          = dword ptr -1Ch
.text$mn:000047A8 var_18          = dword ptr -18h
.text$mn:000047A8 var_14          = dword ptr -14h
.text$mn:000047A8 var_10          = dword ptr -10h
.text$mn:000047A8 var_C           = dword ptr -0Ch
.text$mn:000047A8 var_4           = dword ptr -4
.text$mn:000047A8 arg_0           = dword ptr  8
.text$mn:000047A8 arg_4           = dword ptr  0Ch
.text$mn:000047A8
.text$mn:000047A8                 push    ebp
.text$mn:000047A9                 mov     ebp, esp
.text$mn:000047AB                 push    0FFFFFFFFh
.text$mn:000047AD                 push    offset __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$mn:000047B2                 mov     eax, large fs:0
.text$mn:000047B8                 push    eax
.text$mn:000047B9                 sub     esp, 10h
.text$mn:000047BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000047C1                 xor     eax, ebp
.text$mn:000047C3                 push    eax
.text$mn:000047C4                 lea     eax, [ebp+var_C]
.text$mn:000047C7                 mov     large fs:0, eax
.text$mn:000047CD                 mov     [ebp+var_18], ecx
.text$mn:000047D0                 mov     eax, [ebp+arg_0]
.text$mn:000047D3                 push    eax             ; void *
.text$mn:000047D4                 push    3Ch ; '<'       ; unsigned int
.text$mn:000047D6                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000047DB                 add     esp, 8
.text$mn:000047DE                 mov     [ebp+var_10], eax
.text$mn:000047E1                 mov     [ebp+var_4], 0
.text$mn:000047E8                 cmp     [ebp+var_10], 0
.text$mn:000047EC                 jz      short loc_4808
.text$mn:000047EE                 mov     ecx, [ebp+arg_4]
.text$mn:000047F1                 push    ecx
.text$mn:000047F2                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:000047F7                 add     esp, 4
.text$mn:000047FA                 push    eax
.text$mn:000047FB                 mov     ecx, [ebp+var_10]
.text$mn:000047FE                 call    ??0MenuItemUnit@@QAE@ABU0@@Z ; MenuItemUnit::MenuItemUnit(MenuItemUnit const &)
.text$mn:00004803                 mov     [ebp+var_14], eax
.text$mn:00004806                 jmp     short loc_480F
.text$mn:00004808 ; ---------------------------------------------------------------------------
.text$mn:00004808
.text$mn:00004808 loc_4808:                               ; CODE XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+44j
.text$mn:00004808                 mov     [ebp+var_14], 0
.text$mn:0000480F
.text$mn:0000480F loc_480F:                               ; CODE XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+5Ej
.text$mn:0000480F                 mov     edx, [ebp+var_14]
.text$mn:00004812                 mov     [ebp+var_1C], edx
.text$mn:00004815                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000481C                 mov     ecx, [ebp+var_C]
.text$mn:0000481F                 mov     large fs:0, ecx
.text$mn:00004826                 pop     ecx
.text$mn:00004827                 mov     esp, ebp
.text$mn:00004829                 pop     ebp
.text$mn:0000482A                 retn    8
.text$mn:0000482A ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z endp
.text$mn:0000482A
.text$mn:0000482A ; ---------------------------------------------------------------------------
.text$mn:0000482D                 align 10h
.text$mn:0000482D _text$mn        ends
.text$mn:0000482D
.text$x:00004830 ; ===========================================================================
.text$x:00004830
.text$x:00004830 ; Segment type: Pure code
.text$x:00004830 ; Segment permissions: Read/Execute
.text$x:00004830 _text$x         segment para public 'CODE' use32
.text$x:00004830                 assume cs:_text$x
.text$x:00004830                 ;org 4830h
.text$x:00004830 ; COMDAT (pick associative to section at 47A8)
.text$x:00004830                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004830
.text$x:00004830 ; =============== S U B R O U T I N E =======================================
.text$x:00004830
.text$x:00004830
.text$x:00004830 __unwindfunclet$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z$0 proc near
.text$x:00004830                                         ; DATA XREF: .xdata$x:0000E510o
.text$x:00004830                 mov     eax, [ebp+8]
.text$x:00004833                 push    eax
.text$x:00004834                 mov     eax, [ebp-10h]
.text$x:00004837                 push    eax             ; void *
.text$x:00004838                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000483D                 add     esp, 8
.text$x:00004840                 retn
.text$x:00004840 __unwindfunclet$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z$0 endp
.text$x:00004840
.text$x:00004841
.text$x:00004841 ; =============== S U B R O U T I N E =======================================
.text$x:00004841
.text$x:00004841
.text$x:00004841 __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z proc near
.text$x:00004841                                         ; DATA XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+5o
.text$x:00004841
.text$x:00004841 arg_4           = dword ptr  8
.text$x:00004841
.text$x:00004841                 mov     edx, [esp+arg_4]
.text$x:00004845                 lea     eax, [edx+0Ch]
.text$x:00004848                 mov     ecx, [edx-14h]
.text$x:0000484B                 xor     ecx, eax
.text$x:0000484D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004852                 mov     eax, offset __ehfuncinfo$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$x:00004857                 jmp     ___CxxFrameHandler3
.text$x:00004857 __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z endp
.text$x:00004857
.text$x:00004857 _text$x         ends
.text$x:00004857
.text$mn:0000485C ; ===========================================================================
.text$mn:0000485C
.text$mn:0000485C ; Segment type: Pure code
.text$mn:0000485C ; Segment permissions: Read/Execute
.text$mn:0000485C _text$mn        segment para public 'CODE' use32
.text$mn:0000485C                 assume cs:_text$mn
.text$mn:0000485C                 ;org 485Ch
.text$mn:0000485C ; COMDAT (pick any)
.text$mn:0000485C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000485C
.text$mn:0000485C ; =============== S U B R O U T I N E =======================================
.text$mn:0000485C
.text$mn:0000485C ; Attributes: bp-based frame
.text$mn:0000485C
.text$mn:0000485C ; int __cdecl std::allocator_traits<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(int, void *, int)
.text$mn:0000485C                 public ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z
.text$mn:0000485C ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z proc near
.text$mn:0000485C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+1Cp
.text$mn:0000485C
.text$mn:0000485C arg_0           = dword ptr  8
.text$mn:0000485C arg_4           = dword ptr  0Ch
.text$mn:0000485C arg_8           = dword ptr  10h
.text$mn:0000485C
.text$mn:0000485C                 push    ebp
.text$mn:0000485D                 mov     ebp, esp
.text$mn:0000485F                 mov     eax, [ebp+arg_8]
.text$mn:00004862                 push    eax
.text$mn:00004863                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:00004868                 add     esp, 4
.text$mn:0000486B                 push    eax             ; int
.text$mn:0000486C                 mov     ecx, [ebp+arg_4]
.text$mn:0000486F                 push    ecx             ; void *
.text$mn:00004870                 mov     ecx, [ebp+arg_0]
.text$mn:00004873                 call    ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:00004878                 pop     ebp
.text$mn:00004879                 retn
.text$mn:00004879 ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z endp
.text$mn:00004879
.text$mn:00004879 ; ---------------------------------------------------------------------------
.text$mn:0000487A                 align 4
.text$mn:0000487A _text$mn        ends
.text$mn:0000487A
.text$mn:0000487C ; ===========================================================================
.text$mn:0000487C
.text$mn:0000487C ; Segment type: Pure code
.text$mn:0000487C ; Segment permissions: Read/Execute
.text$mn:0000487C _text$mn        segment para public 'CODE' use32
.text$mn:0000487C                 assume cs:_text$mn
.text$mn:0000487C                 ;org 487Ch
.text$mn:0000487C ; COMDAT (pick any)
.text$mn:0000487C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000487C
.text$mn:0000487C ; =============== S U B R O U T I N E =======================================
.text$mn:0000487C
.text$mn:0000487C ; Attributes: bp-based frame
.text$mn:0000487C
.text$mn:0000487C ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:0000487C                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000487C ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:0000487C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Alloc_proxy(void)+32p
.text$mn:0000487C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)+32p ...
.text$mn:0000487C
.text$mn:0000487C var_4           = dword ptr -4
.text$mn:0000487C arg_0           = dword ptr  8
.text$mn:0000487C arg_4           = dword ptr  0Ch
.text$mn:0000487C
.text$mn:0000487C                 push    ebp
.text$mn:0000487D                 mov     ebp, esp
.text$mn:0000487F                 push    ecx
.text$mn:00004880                 mov     [ebp+var_4], ecx
.text$mn:00004883                 mov     eax, [ebp+arg_4]
.text$mn:00004886                 push    eax
.text$mn:00004887                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000488C                 add     esp, 4
.text$mn:0000488F                 push    eax             ; int
.text$mn:00004890                 mov     ecx, [ebp+arg_0]
.text$mn:00004893                 push    ecx             ; void *
.text$mn:00004894                 mov     edx, [ebp+var_4]
.text$mn:00004897                 push    edx             ; int
.text$mn:00004898                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000489D                 add     esp, 0Ch
.text$mn:000048A0                 mov     esp, ebp
.text$mn:000048A2                 pop     ebp
.text$mn:000048A3                 retn    8
.text$mn:000048A3 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000048A3
.text$mn:000048A3 ; ---------------------------------------------------------------------------
.text$mn:000048A6                 align 4
.text$mn:000048A6 _text$mn        ends
.text$mn:000048A6
.text$mn:000048A8 ; ===========================================================================
.text$mn:000048A8
.text$mn:000048A8 ; Segment type: Pure code
.text$mn:000048A8 ; Segment permissions: Read/Execute
.text$mn:000048A8 _text$mn        segment para public 'CODE' use32
.text$mn:000048A8                 assume cs:_text$mn
.text$mn:000048A8                 ;org 48A8h
.text$mn:000048A8 ; COMDAT (pick any)
.text$mn:000048A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048A8
.text$mn:000048A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048A8
.text$mn:000048A8 ; Attributes: bp-based frame
.text$mn:000048A8
.text$mn:000048A8 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000048A8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000048A8 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000048A8                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:000048A8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:000048A8
.text$mn:000048A8 var_1C          = dword ptr -1Ch
.text$mn:000048A8 var_18          = dword ptr -18h
.text$mn:000048A8 var_14          = dword ptr -14h
.text$mn:000048A8 var_10          = dword ptr -10h
.text$mn:000048A8 var_C           = dword ptr -0Ch
.text$mn:000048A8 var_4           = dword ptr -4
.text$mn:000048A8 arg_0           = dword ptr  8
.text$mn:000048A8 arg_4           = dword ptr  0Ch
.text$mn:000048A8
.text$mn:000048A8                 push    ebp
.text$mn:000048A9                 mov     ebp, esp
.text$mn:000048AB                 push    0FFFFFFFFh
.text$mn:000048AD                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000048B2                 mov     eax, large fs:0
.text$mn:000048B8                 push    eax
.text$mn:000048B9                 sub     esp, 10h
.text$mn:000048BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000048C1                 xor     eax, ebp
.text$mn:000048C3                 push    eax
.text$mn:000048C4                 lea     eax, [ebp+var_C]
.text$mn:000048C7                 mov     large fs:0, eax
.text$mn:000048CD                 mov     [ebp+var_18], ecx
.text$mn:000048D0                 mov     eax, [ebp+arg_0]
.text$mn:000048D3                 push    eax             ; void *
.text$mn:000048D4                 push    8               ; unsigned int
.text$mn:000048D6                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000048DB                 add     esp, 8
.text$mn:000048DE                 mov     [ebp+var_10], eax
.text$mn:000048E1                 mov     [ebp+var_4], 0
.text$mn:000048E8                 cmp     [ebp+var_10], 0
.text$mn:000048EC                 jz      short loc_490F
.text$mn:000048EE                 mov     ecx, [ebp+arg_4]
.text$mn:000048F1                 push    ecx
.text$mn:000048F2                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000048F7                 add     esp, 4
.text$mn:000048FA                 mov     edx, [eax]
.text$mn:000048FC                 mov     eax, [eax+4]
.text$mn:000048FF                 mov     ecx, [ebp+var_10]
.text$mn:00004902                 mov     [ecx], edx
.text$mn:00004904                 mov     [ecx+4], eax
.text$mn:00004907                 mov     edx, [ebp+var_10]
.text$mn:0000490A                 mov     [ebp+var_14], edx
.text$mn:0000490D                 jmp     short loc_4916
.text$mn:0000490F ; ---------------------------------------------------------------------------
.text$mn:0000490F
.text$mn:0000490F loc_490F:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000490F                 mov     [ebp+var_14], 0
.text$mn:00004916
.text$mn:00004916 loc_4916:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00004916                 mov     eax, [ebp+var_14]
.text$mn:00004919                 mov     [ebp+var_1C], eax
.text$mn:0000491C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004923                 mov     ecx, [ebp+var_C]
.text$mn:00004926                 mov     large fs:0, ecx
.text$mn:0000492D                 pop     ecx
.text$mn:0000492E                 mov     esp, ebp
.text$mn:00004930                 pop     ebp
.text$mn:00004931                 retn    8
.text$mn:00004931 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00004931
.text$mn:00004931 _text$mn        ends
.text$mn:00004931
.text$x:00004934 ; ===========================================================================
.text$x:00004934
.text$x:00004934 ; Segment type: Pure code
.text$x:00004934 ; Segment permissions: Read/Execute
.text$x:00004934 _text$x         segment para public 'CODE' use32
.text$x:00004934                 assume cs:_text$x
.text$x:00004934                 ;org 4934h
.text$x:00004934 ; COMDAT (pick associative to section at 48A8)
.text$x:00004934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004934
.text$x:00004934 ; =============== S U B R O U T I N E =======================================
.text$x:00004934
.text$x:00004934
.text$x:00004934 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00004934                                         ; DATA XREF: .xdata$x:0000E3D8o
.text$x:00004934                 mov     eax, [ebp+8]
.text$x:00004937                 push    eax
.text$x:00004938                 mov     eax, [ebp-10h]
.text$x:0000493B                 push    eax             ; void *
.text$x:0000493C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004941                 add     esp, 8
.text$x:00004944                 retn
.text$x:00004944 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00004944
.text$x:00004945
.text$x:00004945 ; =============== S U B R O U T I N E =======================================
.text$x:00004945
.text$x:00004945
.text$x:00004945 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00004945                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00004945
.text$x:00004945 arg_4           = dword ptr  8
.text$x:00004945
.text$x:00004945                 mov     edx, [esp+arg_4]
.text$x:00004949                 lea     eax, [edx+0Ch]
.text$x:0000494C                 mov     ecx, [edx-14h]
.text$x:0000494F                 xor     ecx, eax
.text$x:00004951                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004956                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000495B                 jmp     ___CxxFrameHandler3
.text$x:0000495B __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000495B
.text$x:0000495B _text$x         ends
.text$x:0000495B
.text$mn:00004960 ; ===========================================================================
.text$mn:00004960
.text$mn:00004960 ; Segment type: Pure code
.text$mn:00004960 ; Segment permissions: Read/Execute
.text$mn:00004960 _text$mn        segment para public 'CODE' use32
.text$mn:00004960                 assume cs:_text$mn
.text$mn:00004960                 ;org 4960h
.text$mn:00004960 ; COMDAT (pick any)
.text$mn:00004960                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004960
.text$mn:00004960 ; =============== S U B R O U T I N E =======================================
.text$mn:00004960
.text$mn:00004960 ; Attributes: bp-based frame
.text$mn:00004960
.text$mn:00004960 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00004960                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00004960 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00004960                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00004960
.text$mn:00004960 arg_0           = dword ptr  8
.text$mn:00004960 arg_4           = dword ptr  0Ch
.text$mn:00004960 arg_8           = dword ptr  10h
.text$mn:00004960
.text$mn:00004960                 push    ebp
.text$mn:00004961                 mov     ebp, esp
.text$mn:00004963                 mov     eax, [ebp+arg_8]
.text$mn:00004966                 push    eax
.text$mn:00004967                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000496C                 add     esp, 4
.text$mn:0000496F                 push    eax             ; int
.text$mn:00004970                 mov     ecx, [ebp+arg_4]
.text$mn:00004973                 push    ecx             ; void *
.text$mn:00004974                 mov     ecx, [ebp+arg_0]
.text$mn:00004977                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000497C                 pop     ebp
.text$mn:0000497D                 retn
.text$mn:0000497D ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:0000497D
.text$mn:0000497D ; ---------------------------------------------------------------------------
.text$mn:0000497E                 align 10h
.text$mn:0000497E _text$mn        ends
.text$mn:0000497E
.text$mn:00004980 ; ===========================================================================
.text$mn:00004980
.text$mn:00004980 ; Segment type: Pure code
.text$mn:00004980 ; Segment permissions: Read/Execute
.text$mn:00004980 _text$mn        segment para public 'CODE' use32
.text$mn:00004980                 assume cs:_text$mn
.text$mn:00004980                 ;org 4980h
.text$mn:00004980 ; COMDAT (pick any)
.text$mn:00004980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004980
.text$mn:00004980 ; =============== S U B R O U T I N E =======================================
.text$mn:00004980
.text$mn:00004980 ; Attributes: bp-based frame
.text$mn:00004980
.text$mn:00004980 ; int __stdcall std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep &>(void *, int)
.text$mn:00004980                 public ??$construct@UrecordedMacroStep@@AAU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z
.text$mn:00004980 ??$construct@UrecordedMacroStep@@AAU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z proc near
.text$mn:00004980                                         ; CODE XREF: std::_Uninit_copy<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004980
.text$mn:00004980 var_4           = dword ptr -4
.text$mn:00004980 arg_0           = dword ptr  8
.text$mn:00004980 arg_4           = dword ptr  0Ch
.text$mn:00004980
.text$mn:00004980                 push    ebp
.text$mn:00004981                 mov     ebp, esp
.text$mn:00004983                 push    ecx
.text$mn:00004984                 mov     [ebp+var_4], ecx
.text$mn:00004987                 mov     eax, [ebp+arg_4]
.text$mn:0000498A                 push    eax
.text$mn:0000498B                 call    ??$forward@AAUrecordedMacroStep@@@std@@YAAAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep &>(recordedMacroStep &)
.text$mn:00004990                 add     esp, 4
.text$mn:00004993                 push    eax             ; int
.text$mn:00004994                 mov     ecx, [ebp+arg_0]
.text$mn:00004997                 push    ecx             ; void *
.text$mn:00004998                 mov     edx, [ebp+var_4]
.text$mn:0000499B                 push    edx             ; int
.text$mn:0000499C                 call    ??$construct@UrecordedMacroStep@@AAU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@AAU3@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep &>(std::allocator<recordedMacroStep> &,recordedMacroStep *,recordedMacroStep &)
.text$mn:000049A1                 add     esp, 0Ch
.text$mn:000049A4                 mov     esp, ebp
.text$mn:000049A6                 pop     ebp
.text$mn:000049A7                 retn    8
.text$mn:000049A7 ??$construct@UrecordedMacroStep@@AAU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z endp
.text$mn:000049A7
.text$mn:000049A7 ; ---------------------------------------------------------------------------
.text$mn:000049AA                 align 4
.text$mn:000049AA _text$mn        ends
.text$mn:000049AA
.text$mn:000049AC ; ===========================================================================
.text$mn:000049AC
.text$mn:000049AC ; Segment type: Pure code
.text$mn:000049AC ; Segment permissions: Read/Execute
.text$mn:000049AC _text$mn        segment para public 'CODE' use32
.text$mn:000049AC                 assume cs:_text$mn
.text$mn:000049AC                 ;org 49ACh
.text$mn:000049AC ; COMDAT (pick any)
.text$mn:000049AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049AC
.text$mn:000049AC ; =============== S U B R O U T I N E =======================================
.text$mn:000049AC
.text$mn:000049AC ; Attributes: bp-based frame
.text$mn:000049AC
.text$mn:000049AC ; int __stdcall std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep &>(void *, int)
.text$mn:000049AC                 public ??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z
.text$mn:000049AC ??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z proc near
.text$mn:000049AC                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep &>(std::allocator<recordedMacroStep> &,recordedMacroStep *,recordedMacroStep &)+17p
.text$mn:000049AC
.text$mn:000049AC var_1C          = dword ptr -1Ch
.text$mn:000049AC var_18          = dword ptr -18h
.text$mn:000049AC var_14          = dword ptr -14h
.text$mn:000049AC var_10          = dword ptr -10h
.text$mn:000049AC var_C           = dword ptr -0Ch
.text$mn:000049AC var_4           = dword ptr -4
.text$mn:000049AC arg_0           = dword ptr  8
.text$mn:000049AC arg_4           = dword ptr  0Ch
.text$mn:000049AC
.text$mn:000049AC                 push    ebp
.text$mn:000049AD                 mov     ebp, esp
.text$mn:000049AF                 push    0FFFFFFFFh
.text$mn:000049B1                 push    offset __ehhandler$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z
.text$mn:000049B6                 mov     eax, large fs:0
.text$mn:000049BC                 push    eax
.text$mn:000049BD                 sub     esp, 10h
.text$mn:000049C0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000049C5                 xor     eax, ebp
.text$mn:000049C7                 push    eax
.text$mn:000049C8                 lea     eax, [ebp+var_C]
.text$mn:000049CB                 mov     large fs:0, eax
.text$mn:000049D1                 mov     [ebp+var_18], ecx
.text$mn:000049D4                 mov     eax, [ebp+arg_0]
.text$mn:000049D7                 push    eax             ; void *
.text$mn:000049D8                 push    2Ch ; ','       ; unsigned int
.text$mn:000049DA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000049DF                 add     esp, 8
.text$mn:000049E2                 mov     [ebp+var_10], eax
.text$mn:000049E5                 mov     [ebp+var_4], 0
.text$mn:000049EC                 cmp     [ebp+var_10], 0
.text$mn:000049F0                 jz      short loc_4A0C
.text$mn:000049F2                 mov     ecx, [ebp+arg_4]
.text$mn:000049F5                 push    ecx
.text$mn:000049F6                 call    ??$forward@AAUrecordedMacroStep@@@std@@YAAAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep &>(recordedMacroStep &)
.text$mn:000049FB                 add     esp, 4
.text$mn:000049FE                 push    eax
.text$mn:000049FF                 mov     ecx, [ebp+var_10]
.text$mn:00004A02                 call    ??0recordedMacroStep@@QAE@ABU0@@Z ; recordedMacroStep::recordedMacroStep(recordedMacroStep const &)
.text$mn:00004A07                 mov     [ebp+var_14], eax
.text$mn:00004A0A                 jmp     short loc_4A13
.text$mn:00004A0C ; ---------------------------------------------------------------------------
.text$mn:00004A0C
.text$mn:00004A0C loc_4A0C:                               ; CODE XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)+44j
.text$mn:00004A0C                 mov     [ebp+var_14], 0
.text$mn:00004A13
.text$mn:00004A13 loc_4A13:                               ; CODE XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)+5Ej
.text$mn:00004A13                 mov     edx, [ebp+var_14]
.text$mn:00004A16                 mov     [ebp+var_1C], edx
.text$mn:00004A19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A20                 mov     ecx, [ebp+var_C]
.text$mn:00004A23                 mov     large fs:0, ecx
.text$mn:00004A2A                 pop     ecx
.text$mn:00004A2B                 mov     esp, ebp
.text$mn:00004A2D                 pop     ebp
.text$mn:00004A2E                 retn    8
.text$mn:00004A2E ??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z endp
.text$mn:00004A2E
.text$mn:00004A2E ; ---------------------------------------------------------------------------
.text$mn:00004A31                 align 4
.text$mn:00004A31 _text$mn        ends
.text$mn:00004A31
.text$x:00004A34 ; ===========================================================================
.text$x:00004A34
.text$x:00004A34 ; Segment type: Pure code
.text$x:00004A34 ; Segment permissions: Read/Execute
.text$x:00004A34 _text$x         segment para public 'CODE' use32
.text$x:00004A34                 assume cs:_text$x
.text$x:00004A34                 ;org 4A34h
.text$x:00004A34 ; COMDAT (pick associative to section at 49AC)
.text$x:00004A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004A34
.text$x:00004A34 ; =============== S U B R O U T I N E =======================================
.text$x:00004A34
.text$x:00004A34
.text$x:00004A34 __unwindfunclet$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z$0 proc near
.text$x:00004A34                                         ; DATA XREF: .xdata$x:0000E74Co
.text$x:00004A34                 mov     eax, [ebp+8]
.text$x:00004A37                 push    eax
.text$x:00004A38                 mov     eax, [ebp-10h]
.text$x:00004A3B                 push    eax             ; void *
.text$x:00004A3C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004A41                 add     esp, 8
.text$x:00004A44                 retn
.text$x:00004A44 __unwindfunclet$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z$0 endp
.text$x:00004A44
.text$x:00004A45
.text$x:00004A45 ; =============== S U B R O U T I N E =======================================
.text$x:00004A45
.text$x:00004A45
.text$x:00004A45 __ehhandler$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z proc near
.text$x:00004A45                                         ; DATA XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)+5o
.text$x:00004A45
.text$x:00004A45 arg_4           = dword ptr  8
.text$x:00004A45
.text$x:00004A45                 mov     edx, [esp+arg_4]
.text$x:00004A49                 lea     eax, [edx+0Ch]
.text$x:00004A4C                 mov     ecx, [edx-14h]
.text$x:00004A4F                 xor     ecx, eax
.text$x:00004A51                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A56                 mov     eax, offset __ehfuncinfo$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z
.text$x:00004A5B                 jmp     ___CxxFrameHandler3
.text$x:00004A5B __ehhandler$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z endp
.text$x:00004A5B
.text$x:00004A5B _text$x         ends
.text$x:00004A5B
.text$mn:00004A60 ; ===========================================================================
.text$mn:00004A60
.text$mn:00004A60 ; Segment type: Pure code
.text$mn:00004A60 ; Segment permissions: Read/Execute
.text$mn:00004A60 _text$mn        segment para public 'CODE' use32
.text$mn:00004A60                 assume cs:_text$mn
.text$mn:00004A60                 ;org 4A60h
.text$mn:00004A60 ; COMDAT (pick any)
.text$mn:00004A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A60
.text$mn:00004A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A60
.text$mn:00004A60 ; Attributes: bp-based frame
.text$mn:00004A60
.text$mn:00004A60 ; int __cdecl std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep &>(int, void *, int)
.text$mn:00004A60                 public ??$construct@UrecordedMacroStep@@AAU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@AAU3@@Z
.text$mn:00004A60 ??$construct@UrecordedMacroStep@@AAU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@AAU3@@Z proc near
.text$mn:00004A60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)+1Cp
.text$mn:00004A60
.text$mn:00004A60 arg_0           = dword ptr  8
.text$mn:00004A60 arg_4           = dword ptr  0Ch
.text$mn:00004A60 arg_8           = dword ptr  10h
.text$mn:00004A60
.text$mn:00004A60                 push    ebp
.text$mn:00004A61                 mov     ebp, esp
.text$mn:00004A63                 mov     eax, [ebp+arg_8]
.text$mn:00004A66                 push    eax
.text$mn:00004A67                 call    ??$forward@AAUrecordedMacroStep@@@std@@YAAAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep &>(recordedMacroStep &)
.text$mn:00004A6C                 add     esp, 4
.text$mn:00004A6F                 push    eax             ; int
.text$mn:00004A70                 mov     ecx, [ebp+arg_4]
.text$mn:00004A73                 push    ecx             ; void *
.text$mn:00004A74                 mov     ecx, [ebp+arg_0]
.text$mn:00004A77                 call    ??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z ; std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)
.text$mn:00004A7C                 pop     ebp
.text$mn:00004A7D                 retn
.text$mn:00004A7D ??$construct@UrecordedMacroStep@@AAU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@AAU3@@Z endp
.text$mn:00004A7D
.text$mn:00004A7D ; ---------------------------------------------------------------------------
.text$mn:00004A7E                 align 10h
.text$mn:00004A7E _text$mn        ends
.text$mn:00004A7E
.text$mn:00004A80 ; ===========================================================================
.text$mn:00004A80
.text$mn:00004A80 ; Segment type: Pure code
.text$mn:00004A80 ; Segment permissions: Read/Execute
.text$mn:00004A80 _text$mn        segment para public 'CODE' use32
.text$mn:00004A80                 assume cs:_text$mn
.text$mn:00004A80                 ;org 4A80h
.text$mn:00004A80 ; COMDAT (pick any)
.text$mn:00004A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A80
.text$mn:00004A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A80
.text$mn:00004A80 ; Attributes: bp-based frame
.text$mn:00004A80
.text$mn:00004A80 ; int __stdcall std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(void *, int)
.text$mn:00004A80                 public ??$construct@UrecordedMacroStep@@ABU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@ABU2@@Z
.text$mn:00004A80 ??$construct@UrecordedMacroStep@@ABU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@ABU2@@Z proc near
.text$mn:00004A80                                         ; CODE XREF: std::_Uninit_copy<recordedMacroStep const *,recordedMacroStep *,std::allocator<recordedMacroStep>>(recordedMacroStep const *,recordedMacroStep const *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004A80
.text$mn:00004A80 var_4           = dword ptr -4
.text$mn:00004A80 arg_0           = dword ptr  8
.text$mn:00004A80 arg_4           = dword ptr  0Ch
.text$mn:00004A80
.text$mn:00004A80                 push    ebp
.text$mn:00004A81                 mov     ebp, esp
.text$mn:00004A83                 push    ecx
.text$mn:00004A84                 mov     [ebp+var_4], ecx
.text$mn:00004A87                 mov     eax, [ebp+arg_4]
.text$mn:00004A8A                 push    eax
.text$mn:00004A8B                 call    ??$forward@ABUrecordedMacroStep@@@std@@YAABUrecordedMacroStep@@ABU1@@Z ; std::forward<recordedMacroStep const &>(recordedMacroStep const &)
.text$mn:00004A90                 add     esp, 4
.text$mn:00004A93                 push    eax             ; int
.text$mn:00004A94                 mov     ecx, [ebp+arg_0]
.text$mn:00004A97                 push    ecx             ; void *
.text$mn:00004A98                 mov     edx, [ebp+var_4]
.text$mn:00004A9B                 push    edx             ; int
.text$mn:00004A9C                 call    ??$construct@UrecordedMacroStep@@ABU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@ABU3@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(std::allocator<recordedMacroStep> &,recordedMacroStep *,recordedMacroStep const &)
.text$mn:00004AA1                 add     esp, 0Ch
.text$mn:00004AA4                 mov     esp, ebp
.text$mn:00004AA6                 pop     ebp
.text$mn:00004AA7                 retn    8
.text$mn:00004AA7 ??$construct@UrecordedMacroStep@@ABU1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@ABU2@@Z endp
.text$mn:00004AA7
.text$mn:00004AA7 ; ---------------------------------------------------------------------------
.text$mn:00004AAA                 align 4
.text$mn:00004AAA _text$mn        ends
.text$mn:00004AAA
.text$mn:00004AAC ; ===========================================================================
.text$mn:00004AAC
.text$mn:00004AAC ; Segment type: Pure code
.text$mn:00004AAC ; Segment permissions: Read/Execute
.text$mn:00004AAC _text$mn        segment para public 'CODE' use32
.text$mn:00004AAC                 assume cs:_text$mn
.text$mn:00004AAC                 ;org 4AACh
.text$mn:00004AAC ; COMDAT (pick any)
.text$mn:00004AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AAC
.text$mn:00004AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00004AAC
.text$mn:00004AAC ; Attributes: bp-based frame
.text$mn:00004AAC
.text$mn:00004AAC ; int __cdecl std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(int, void *, int)
.text$mn:00004AAC                 public ??$construct@UrecordedMacroStep@@ABU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@ABU3@@Z
.text$mn:00004AAC ??$construct@UrecordedMacroStep@@ABU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@ABU3@@Z proc near
.text$mn:00004AAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(recordedMacroStep *,recordedMacroStep const &)+1Cp
.text$mn:00004AAC
.text$mn:00004AAC arg_0           = dword ptr  8
.text$mn:00004AAC arg_4           = dword ptr  0Ch
.text$mn:00004AAC arg_8           = dword ptr  10h
.text$mn:00004AAC
.text$mn:00004AAC                 push    ebp
.text$mn:00004AAD                 mov     ebp, esp
.text$mn:00004AAF                 mov     eax, [ebp+arg_8]
.text$mn:00004AB2                 push    eax
.text$mn:00004AB3                 call    ??$forward@ABUrecordedMacroStep@@@std@@YAABUrecordedMacroStep@@ABU1@@Z ; std::forward<recordedMacroStep const &>(recordedMacroStep const &)
.text$mn:00004AB8                 add     esp, 4
.text$mn:00004ABB                 push    eax             ; int
.text$mn:00004ABC                 mov     ecx, [ebp+arg_4]
.text$mn:00004ABF                 push    ecx             ; void *
.text$mn:00004AC0                 mov     ecx, [ebp+arg_0]
.text$mn:00004AC3                 call    ?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z ; std::allocator<recordedMacroStep>::construct(recordedMacroStep *,recordedMacroStep const &)
.text$mn:00004AC8                 pop     ebp
.text$mn:00004AC9                 retn
.text$mn:00004AC9 ??$construct@UrecordedMacroStep@@ABU1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@ABU3@@Z endp
.text$mn:00004AC9
.text$mn:00004AC9 ; ---------------------------------------------------------------------------
.text$mn:00004ACA                 align 4
.text$mn:00004ACA _text$mn        ends
.text$mn:00004ACA
.text$mn:00004ACC ; ===========================================================================
.text$mn:00004ACC
.text$mn:00004ACC ; Segment type: Pure code
.text$mn:00004ACC ; Segment permissions: Read/Execute
.text$mn:00004ACC _text$mn        segment para public 'CODE' use32
.text$mn:00004ACC                 assume cs:_text$mn
.text$mn:00004ACC                 ;org 4ACCh
.text$mn:00004ACC ; COMDAT (pick any)
.text$mn:00004ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004ACC
.text$mn:00004ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00004ACC
.text$mn:00004ACC ; Attributes: bp-based frame
.text$mn:00004ACC
.text$mn:00004ACC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00004ACC                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00004ACC ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00004ACC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00004ACC
.text$mn:00004ACC var_4           = dword ptr -4
.text$mn:00004ACC arg_0           = dword ptr  8
.text$mn:00004ACC
.text$mn:00004ACC                 push    ebp
.text$mn:00004ACD                 mov     ebp, esp
.text$mn:00004ACF                 push    ecx
.text$mn:00004AD0                 mov     [ebp+var_4], ecx
.text$mn:00004AD3                 mov     eax, [ebp+arg_0]
.text$mn:00004AD6                 push    eax
.text$mn:00004AD7                 mov     ecx, [ebp+var_4]
.text$mn:00004ADA                 push    ecx
.text$mn:00004ADB                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00004AE0                 add     esp, 8
.text$mn:00004AE3                 mov     esp, ebp
.text$mn:00004AE5                 pop     ebp
.text$mn:00004AE6                 retn    4
.text$mn:00004AE6 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00004AE6
.text$mn:00004AE6 ; ---------------------------------------------------------------------------
.text$mn:00004AE9                 align 4
.text$mn:00004AE9 _text$mn        ends
.text$mn:00004AE9
.text$mn:00004AEC ; ===========================================================================
.text$mn:00004AEC
.text$mn:00004AEC ; Segment type: Pure code
.text$mn:00004AEC ; Segment permissions: Read/Execute
.text$mn:00004AEC _text$mn        segment para public 'CODE' use32
.text$mn:00004AEC                 assume cs:_text$mn
.text$mn:00004AEC                 ;org 4AECh
.text$mn:00004AEC ; COMDAT (pick any)
.text$mn:00004AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AEC
.text$mn:00004AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00004AEC
.text$mn:00004AEC ; Attributes: bp-based frame
.text$mn:00004AEC
.text$mn:00004AEC ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00004AEC                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00004AEC ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00004AEC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00004AEC
.text$mn:00004AEC var_4           = dword ptr -4
.text$mn:00004AEC
.text$mn:00004AEC                 push    ebp
.text$mn:00004AED                 mov     ebp, esp
.text$mn:00004AEF                 push    ecx
.text$mn:00004AF0                 mov     [ebp+var_4], ecx
.text$mn:00004AF3                 mov     esp, ebp
.text$mn:00004AF5                 pop     ebp
.text$mn:00004AF6                 retn    4
.text$mn:00004AF6 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00004AF6
.text$mn:00004AF6 ; ---------------------------------------------------------------------------
.text$mn:00004AF9                 align 4
.text$mn:00004AF9 _text$mn        ends
.text$mn:00004AF9
.text$mn:00004AFC ; ===========================================================================
.text$mn:00004AFC
.text$mn:00004AFC ; Segment type: Pure code
.text$mn:00004AFC ; Segment permissions: Read/Execute
.text$mn:00004AFC _text$mn        segment para public 'CODE' use32
.text$mn:00004AFC                 assume cs:_text$mn
.text$mn:00004AFC                 ;org 4AFCh
.text$mn:00004AFC ; COMDAT (pick any)
.text$mn:00004AFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AFC
.text$mn:00004AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00004AFC
.text$mn:00004AFC ; Attributes: bp-based frame
.text$mn:00004AFC
.text$mn:00004AFC ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00004AFC                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00004AFC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00004AFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00004AFC
.text$mn:00004AFC arg_0           = dword ptr  8
.text$mn:00004AFC arg_4           = dword ptr  0Ch
.text$mn:00004AFC
.text$mn:00004AFC                 push    ebp
.text$mn:00004AFD                 mov     ebp, esp
.text$mn:00004AFF                 mov     eax, [ebp+arg_4]
.text$mn:00004B02                 push    eax
.text$mn:00004B03                 mov     ecx, [ebp+arg_0]
.text$mn:00004B06                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00004B0B                 pop     ebp
.text$mn:00004B0C                 retn
.text$mn:00004B0C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00004B0C
.text$mn:00004B0C ; ---------------------------------------------------------------------------
.text$mn:00004B0D                 align 10h
.text$mn:00004B0D _text$mn        ends
.text$mn:00004B0D
.text$mn:00004B10 ; ===========================================================================
.text$mn:00004B10
.text$mn:00004B10 ; Segment type: Pure code
.text$mn:00004B10 ; Segment permissions: Read/Execute
.text$mn:00004B10 _text$mn        segment para public 'CODE' use32
.text$mn:00004B10                 assume cs:_text$mn
.text$mn:00004B10                 ;org 4B10h
.text$mn:00004B10 ; COMDAT (pick any)
.text$mn:00004B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B10
.text$mn:00004B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B10
.text$mn:00004B10 ; Attributes: bp-based frame
.text$mn:00004B10
.text$mn:00004B10 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00004B10                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00004B10 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00004B10                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00004B10
.text$mn:00004B10 var_4           = dword ptr -4
.text$mn:00004B10 arg_0           = dword ptr  8
.text$mn:00004B10
.text$mn:00004B10                 push    ebp
.text$mn:00004B11                 mov     ebp, esp
.text$mn:00004B13                 push    ecx
.text$mn:00004B14                 mov     [ebp+var_4], ecx
.text$mn:00004B17                 mov     eax, [ebp+arg_0]
.text$mn:00004B1A                 push    eax
.text$mn:00004B1B                 mov     ecx, [ebp+var_4]
.text$mn:00004B1E                 push    ecx
.text$mn:00004B1F                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00004B24                 add     esp, 8
.text$mn:00004B27                 mov     esp, ebp
.text$mn:00004B29                 pop     ebp
.text$mn:00004B2A                 retn    4
.text$mn:00004B2A ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00004B2A
.text$mn:00004B2A ; ---------------------------------------------------------------------------
.text$mn:00004B2D                 align 10h
.text$mn:00004B2D _text$mn        ends
.text$mn:00004B2D
.text$mn:00004B30 ; ===========================================================================
.text$mn:00004B30
.text$mn:00004B30 ; Segment type: Pure code
.text$mn:00004B30 ; Segment permissions: Read/Execute
.text$mn:00004B30 _text$mn        segment para public 'CODE' use32
.text$mn:00004B30                 assume cs:_text$mn
.text$mn:00004B30                 ;org 4B30h
.text$mn:00004B30 ; COMDAT (pick any)
.text$mn:00004B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B30
.text$mn:00004B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B30
.text$mn:00004B30 ; Attributes: bp-based frame
.text$mn:00004B30
.text$mn:00004B30 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00004B30                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00004B30 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00004B30                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00004B30
.text$mn:00004B30 var_4           = dword ptr -4
.text$mn:00004B30
.text$mn:00004B30                 push    ebp
.text$mn:00004B31                 mov     ebp, esp
.text$mn:00004B33                 push    ecx
.text$mn:00004B34                 mov     [ebp+var_4], ecx
.text$mn:00004B37                 mov     esp, ebp
.text$mn:00004B39                 pop     ebp
.text$mn:00004B3A                 retn    4
.text$mn:00004B3A ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00004B3A
.text$mn:00004B3A ; ---------------------------------------------------------------------------
.text$mn:00004B3D                 align 10h
.text$mn:00004B3D _text$mn        ends
.text$mn:00004B3D
.text$mn:00004B40 ; ===========================================================================
.text$mn:00004B40
.text$mn:00004B40 ; Segment type: Pure code
.text$mn:00004B40 ; Segment permissions: Read/Execute
.text$mn:00004B40 _text$mn        segment para public 'CODE' use32
.text$mn:00004B40                 assume cs:_text$mn
.text$mn:00004B40                 ;org 4B40h
.text$mn:00004B40 ; COMDAT (pick any)
.text$mn:00004B40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B40
.text$mn:00004B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B40
.text$mn:00004B40 ; Attributes: bp-based frame
.text$mn:00004B40
.text$mn:00004B40 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00004B40                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00004B40 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00004B40                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00004B40
.text$mn:00004B40 arg_0           = dword ptr  8
.text$mn:00004B40 arg_4           = dword ptr  0Ch
.text$mn:00004B40
.text$mn:00004B40                 push    ebp
.text$mn:00004B41                 mov     ebp, esp
.text$mn:00004B43                 mov     eax, [ebp+arg_4]
.text$mn:00004B46                 push    eax
.text$mn:00004B47                 mov     ecx, [ebp+arg_0]
.text$mn:00004B4A                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00004B4F                 pop     ebp
.text$mn:00004B50                 retn
.text$mn:00004B50 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00004B50
.text$mn:00004B50 ; ---------------------------------------------------------------------------
.text$mn:00004B51                 align 4
.text$mn:00004B51 _text$mn        ends
.text$mn:00004B51
.text$mn:00004B54 ; ===========================================================================
.text$mn:00004B54
.text$mn:00004B54 ; Segment type: Pure code
.text$mn:00004B54 ; Segment permissions: Read/Execute
.text$mn:00004B54 _text$mn        segment para public 'CODE' use32
.text$mn:00004B54                 assume cs:_text$mn
.text$mn:00004B54                 ;org 4B54h
.text$mn:00004B54 ; COMDAT (pick any)
.text$mn:00004B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B54
.text$mn:00004B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B54
.text$mn:00004B54 ; Attributes: bp-based frame
.text$mn:00004B54
.text$mn:00004B54 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct KeyCombo>>::destroy<struct KeyCombo>(struct KeyCombo *)
.text$mn:00004B54                 public ??$destroy@UKeyCombo@@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@@Z
.text$mn:00004B54 ??$destroy@UKeyCombo@@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@@Z proc near
.text$mn:00004B54                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00004B54                                         ; __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap ...
.text$mn:00004B54
.text$mn:00004B54 var_4           = dword ptr -4
.text$mn:00004B54 arg_0           = dword ptr  8
.text$mn:00004B54
.text$mn:00004B54                 push    ebp
.text$mn:00004B55                 mov     ebp, esp
.text$mn:00004B57                 push    ecx
.text$mn:00004B58                 mov     [ebp+var_4], ecx
.text$mn:00004B5B                 mov     eax, [ebp+arg_0]
.text$mn:00004B5E                 push    eax
.text$mn:00004B5F                 mov     ecx, [ebp+var_4]
.text$mn:00004B62                 push    ecx
.text$mn:00004B63                 call    ??$destroy@UKeyCombo@@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@@Z ; std::allocator_traits<std::allocator<KeyCombo>>::destroy<KeyCombo>(std::allocator<KeyCombo> &,KeyCombo *)
.text$mn:00004B68                 add     esp, 8
.text$mn:00004B6B                 mov     esp, ebp
.text$mn:00004B6D                 pop     ebp
.text$mn:00004B6E                 retn    4
.text$mn:00004B6E ??$destroy@UKeyCombo@@@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@@Z endp
.text$mn:00004B6E
.text$mn:00004B6E ; ---------------------------------------------------------------------------
.text$mn:00004B71                 align 4
.text$mn:00004B71 _text$mn        ends
.text$mn:00004B71
.text$mn:00004B74 ; ===========================================================================
.text$mn:00004B74
.text$mn:00004B74 ; Segment type: Pure code
.text$mn:00004B74 ; Segment permissions: Read/Execute
.text$mn:00004B74 _text$mn        segment para public 'CODE' use32
.text$mn:00004B74                 assume cs:_text$mn
.text$mn:00004B74                 ;org 4B74h
.text$mn:00004B74 ; COMDAT (pick any)
.text$mn:00004B74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B74
.text$mn:00004B74 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B74
.text$mn:00004B74 ; Attributes: bp-based frame
.text$mn:00004B74
.text$mn:00004B74 ; public: void __thiscall std::allocator<struct KeyCombo>::destroy<struct KeyCombo>(struct KeyCombo *)
.text$mn:00004B74                 public ??$destroy@UKeyCombo@@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@@Z
.text$mn:00004B74 ??$destroy@UKeyCombo@@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@@Z proc near
.text$mn:00004B74                                         ; CODE XREF: std::allocator_traits<std::allocator<KeyCombo>>::destroy<KeyCombo>(std::allocator<KeyCombo> &,KeyCombo *)+Ap
.text$mn:00004B74
.text$mn:00004B74 var_4           = dword ptr -4
.text$mn:00004B74
.text$mn:00004B74                 push    ebp
.text$mn:00004B75                 mov     ebp, esp
.text$mn:00004B77                 push    ecx
.text$mn:00004B78                 mov     [ebp+var_4], ecx
.text$mn:00004B7B                 mov     esp, ebp
.text$mn:00004B7D                 pop     ebp
.text$mn:00004B7E                 retn    4
.text$mn:00004B7E ??$destroy@UKeyCombo@@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@@Z endp
.text$mn:00004B7E
.text$mn:00004B7E ; ---------------------------------------------------------------------------
.text$mn:00004B81                 align 4
.text$mn:00004B81 _text$mn        ends
.text$mn:00004B81
.text$mn:00004B84 ; ===========================================================================
.text$mn:00004B84
.text$mn:00004B84 ; Segment type: Pure code
.text$mn:00004B84 ; Segment permissions: Read/Execute
.text$mn:00004B84 _text$mn        segment para public 'CODE' use32
.text$mn:00004B84                 assume cs:_text$mn
.text$mn:00004B84                 ;org 4B84h
.text$mn:00004B84 ; COMDAT (pick any)
.text$mn:00004B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B84
.text$mn:00004B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B84
.text$mn:00004B84 ; Attributes: bp-based frame
.text$mn:00004B84
.text$mn:00004B84 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct KeyCombo>>::destroy<struct KeyCombo>(class std::allocator<struct KeyCombo> &, struct KeyCombo *)
.text$mn:00004B84                 public ??$destroy@UKeyCombo@@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@@Z
.text$mn:00004B84 ??$destroy@UKeyCombo@@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@@Z proc near
.text$mn:00004B84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::destroy<KeyCombo>(KeyCombo *)+Fp
.text$mn:00004B84
.text$mn:00004B84 arg_0           = dword ptr  8
.text$mn:00004B84 arg_4           = dword ptr  0Ch
.text$mn:00004B84
.text$mn:00004B84                 push    ebp
.text$mn:00004B85                 mov     ebp, esp
.text$mn:00004B87                 mov     eax, [ebp+arg_4]
.text$mn:00004B8A                 push    eax
.text$mn:00004B8B                 mov     ecx, [ebp+arg_0]
.text$mn:00004B8E                 call    ??$destroy@UKeyCombo@@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@@Z ; std::allocator<KeyCombo>::destroy<KeyCombo>(KeyCombo *)
.text$mn:00004B93                 pop     ebp
.text$mn:00004B94                 retn
.text$mn:00004B94 ??$destroy@UKeyCombo@@@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAXAAV?$allocator@UKeyCombo@@@1@PAUKeyCombo@@@Z endp
.text$mn:00004B94
.text$mn:00004B94 ; ---------------------------------------------------------------------------
.text$mn:00004B95                 align 4
.text$mn:00004B95 _text$mn        ends
.text$mn:00004B95
.text$mn:00004B98 ; ===========================================================================
.text$mn:00004B98
.text$mn:00004B98 ; Segment type: Pure code
.text$mn:00004B98 ; Segment permissions: Read/Execute
.text$mn:00004B98 _text$mn        segment para public 'CODE' use32
.text$mn:00004B98                 assume cs:_text$mn
.text$mn:00004B98                 ;org 4B98h
.text$mn:00004B98 ; COMDAT (pick any)
.text$mn:00004B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B98
.text$mn:00004B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B98
.text$mn:00004B98 ; Attributes: bp-based frame
.text$mn:00004B98
.text$mn:00004B98 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::destroy<struct MenuItemUnit>(struct MenuItemUnit *)
.text$mn:00004B98                 public ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z
.text$mn:00004B98 ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z proc near
.text$mn:00004B98                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00004B98                                         ; __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00004B98
.text$mn:00004B98 var_4           = dword ptr -4
.text$mn:00004B98 arg_0           = dword ptr  8
.text$mn:00004B98
.text$mn:00004B98                 push    ebp
.text$mn:00004B99                 mov     ebp, esp
.text$mn:00004B9B                 push    ecx
.text$mn:00004B9C                 mov     [ebp+var_4], ecx
.text$mn:00004B9F                 mov     eax, [ebp+arg_0]
.text$mn:00004BA2                 push    eax
.text$mn:00004BA3                 mov     ecx, [ebp+var_4]
.text$mn:00004BA6                 push    ecx
.text$mn:00004BA7                 call    ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z ; std::allocator_traits<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *)
.text$mn:00004BAC                 add     esp, 8
.text$mn:00004BAF                 mov     esp, ebp
.text$mn:00004BB1                 pop     ebp
.text$mn:00004BB2                 retn    4
.text$mn:00004BB2 ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z endp
.text$mn:00004BB2
.text$mn:00004BB2 ; ---------------------------------------------------------------------------
.text$mn:00004BB5                 align 4
.text$mn:00004BB5 _text$mn        ends
.text$mn:00004BB5
.text$mn:00004BB8 ; ===========================================================================
.text$mn:00004BB8
.text$mn:00004BB8 ; Segment type: Pure code
.text$mn:00004BB8 ; Segment permissions: Read/Execute
.text$mn:00004BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00004BB8                 assume cs:_text$mn
.text$mn:00004BB8                 ;org 4BB8h
.text$mn:00004BB8 ; COMDAT (pick any)
.text$mn:00004BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BB8
.text$mn:00004BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BB8
.text$mn:00004BB8 ; Attributes: bp-based frame
.text$mn:00004BB8
.text$mn:00004BB8 ; public: void __thiscall std::allocator<struct MenuItemUnit>::destroy<struct MenuItemUnit>(struct MenuItemUnit *)
.text$mn:00004BB8                 public ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z
.text$mn:00004BB8 ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z proc near
.text$mn:00004BB8                                         ; CODE XREF: std::allocator_traits<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *)+Ap
.text$mn:00004BB8
.text$mn:00004BB8 var_4           = dword ptr -4
.text$mn:00004BB8 arg_0           = dword ptr  8
.text$mn:00004BB8
.text$mn:00004BB8                 push    ebp
.text$mn:00004BB9                 mov     ebp, esp
.text$mn:00004BBB                 push    ecx
.text$mn:00004BBC                 mov     [ebp+var_4], ecx
.text$mn:00004BBF                 push    0
.text$mn:00004BC1                 mov     ecx, [ebp+arg_0]
.text$mn:00004BC4                 call    ??_GMenuItemUnit@@QAEPAXI@Z ; MenuItemUnit::`scalar deleting destructor'(uint)
.text$mn:00004BC9                 mov     esp, ebp
.text$mn:00004BCB                 pop     ebp
.text$mn:00004BCC                 retn    4
.text$mn:00004BCC ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z endp
.text$mn:00004BCC
.text$mn:00004BCC ; ---------------------------------------------------------------------------
.text$mn:00004BCF                 align 10h
.text$mn:00004BCF _text$mn        ends
.text$mn:00004BCF
.text$mn:00004BD0 ; ===========================================================================
.text$mn:00004BD0
.text$mn:00004BD0 ; Segment type: Pure code
.text$mn:00004BD0 ; Segment permissions: Read/Execute
.text$mn:00004BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BD0                 assume cs:_text$mn
.text$mn:00004BD0                 ;org 4BD0h
.text$mn:00004BD0 ; COMDAT (pick any)
.text$mn:00004BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BD0
.text$mn:00004BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BD0
.text$mn:00004BD0 ; Attributes: bp-based frame
.text$mn:00004BD0
.text$mn:00004BD0 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct MenuItemUnit>>::destroy<struct MenuItemUnit>(class std::allocator<struct MenuItemUnit> &, struct MenuItemUnit *)
.text$mn:00004BD0                 public ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z
.text$mn:00004BD0 ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z proc near
.text$mn:00004BD0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(MenuItemUnit *)+Fp
.text$mn:00004BD0
.text$mn:00004BD0 arg_0           = dword ptr  8
.text$mn:00004BD0 arg_4           = dword ptr  0Ch
.text$mn:00004BD0
.text$mn:00004BD0                 push    ebp
.text$mn:00004BD1                 mov     ebp, esp
.text$mn:00004BD3                 mov     eax, [ebp+arg_4]
.text$mn:00004BD6                 push    eax
.text$mn:00004BD7                 mov     ecx, [ebp+arg_0]
.text$mn:00004BDA                 call    ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z ; std::allocator<MenuItemUnit>::destroy<MenuItemUnit>(MenuItemUnit *)
.text$mn:00004BDF                 pop     ebp
.text$mn:00004BE0                 retn
.text$mn:00004BE0 ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z endp
.text$mn:00004BE0
.text$mn:00004BE0 ; ---------------------------------------------------------------------------
.text$mn:00004BE1                 align 4
.text$mn:00004BE1 _text$mn        ends
.text$mn:00004BE1
.text$mn:00004BE4 ; ===========================================================================
.text$mn:00004BE4
.text$mn:00004BE4 ; Segment type: Pure code
.text$mn:00004BE4 ; Segment permissions: Read/Execute
.text$mn:00004BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BE4                 assume cs:_text$mn
.text$mn:00004BE4                 ;org 4BE4h
.text$mn:00004BE4 ; COMDAT (pick any)
.text$mn:00004BE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BE4
.text$mn:00004BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BE4
.text$mn:00004BE4 ; Attributes: bp-based frame
.text$mn:00004BE4
.text$mn:00004BE4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00004BE4                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00004BE4 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00004BE4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Free_proxy(void)+22p
.text$mn:00004BE4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Free_proxy(void)+22p ...
.text$mn:00004BE4
.text$mn:00004BE4 var_4           = dword ptr -4
.text$mn:00004BE4 arg_0           = dword ptr  8
.text$mn:00004BE4
.text$mn:00004BE4                 push    ebp
.text$mn:00004BE5                 mov     ebp, esp
.text$mn:00004BE7                 push    ecx
.text$mn:00004BE8                 mov     [ebp+var_4], ecx
.text$mn:00004BEB                 mov     eax, [ebp+arg_0]
.text$mn:00004BEE                 push    eax
.text$mn:00004BEF                 mov     ecx, [ebp+var_4]
.text$mn:00004BF2                 push    ecx
.text$mn:00004BF3                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00004BF8                 add     esp, 8
.text$mn:00004BFB                 mov     esp, ebp
.text$mn:00004BFD                 pop     ebp
.text$mn:00004BFE                 retn    4
.text$mn:00004BFE ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00004BFE
.text$mn:00004BFE ; ---------------------------------------------------------------------------
.text$mn:00004C01                 align 4
.text$mn:00004C01 _text$mn        ends
.text$mn:00004C01
.text$mn:00004C04 ; ===========================================================================
.text$mn:00004C04
.text$mn:00004C04 ; Segment type: Pure code
.text$mn:00004C04 ; Segment permissions: Read/Execute
.text$mn:00004C04 _text$mn        segment para public 'CODE' use32
.text$mn:00004C04                 assume cs:_text$mn
.text$mn:00004C04                 ;org 4C04h
.text$mn:00004C04 ; COMDAT (pick any)
.text$mn:00004C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C04
.text$mn:00004C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C04
.text$mn:00004C04 ; Attributes: bp-based frame
.text$mn:00004C04
.text$mn:00004C04 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00004C04                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00004C04 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00004C04                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00004C04                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00004C04
.text$mn:00004C04 var_4           = dword ptr -4
.text$mn:00004C04
.text$mn:00004C04                 push    ebp
.text$mn:00004C05                 mov     ebp, esp
.text$mn:00004C07                 push    ecx
.text$mn:00004C08                 mov     [ebp+var_4], ecx
.text$mn:00004C0B                 mov     esp, ebp
.text$mn:00004C0D                 pop     ebp
.text$mn:00004C0E                 retn    4
.text$mn:00004C0E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00004C0E
.text$mn:00004C0E ; ---------------------------------------------------------------------------
.text$mn:00004C11                 align 4
.text$mn:00004C11 _text$mn        ends
.text$mn:00004C11
.text$mn:00004C14 ; ===========================================================================
.text$mn:00004C14
.text$mn:00004C14 ; Segment type: Pure code
.text$mn:00004C14 ; Segment permissions: Read/Execute
.text$mn:00004C14 _text$mn        segment para public 'CODE' use32
.text$mn:00004C14                 assume cs:_text$mn
.text$mn:00004C14                 ;org 4C14h
.text$mn:00004C14 ; COMDAT (pick any)
.text$mn:00004C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C14
.text$mn:00004C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C14
.text$mn:00004C14 ; Attributes: bp-based frame
.text$mn:00004C14
.text$mn:00004C14 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00004C14                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00004C14 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00004C14                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00004C14
.text$mn:00004C14 arg_0           = dword ptr  8
.text$mn:00004C14 arg_4           = dword ptr  0Ch
.text$mn:00004C14
.text$mn:00004C14                 push    ebp
.text$mn:00004C15                 mov     ebp, esp
.text$mn:00004C17                 mov     eax, [ebp+arg_4]
.text$mn:00004C1A                 push    eax
.text$mn:00004C1B                 mov     ecx, [ebp+arg_0]
.text$mn:00004C1E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00004C23                 pop     ebp
.text$mn:00004C24                 retn
.text$mn:00004C24 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00004C24
.text$mn:00004C24 ; ---------------------------------------------------------------------------
.text$mn:00004C25                 align 4
.text$mn:00004C25 _text$mn        ends
.text$mn:00004C25
.text$mn:00004C28 ; ===========================================================================
.text$mn:00004C28
.text$mn:00004C28 ; Segment type: Pure code
.text$mn:00004C28 ; Segment permissions: Read/Execute
.text$mn:00004C28 _text$mn        segment para public 'CODE' use32
.text$mn:00004C28                 assume cs:_text$mn
.text$mn:00004C28                 ;org 4C28h
.text$mn:00004C28 ; COMDAT (pick any)
.text$mn:00004C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C28
.text$mn:00004C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C28
.text$mn:00004C28 ; Attributes: bp-based frame
.text$mn:00004C28
.text$mn:00004C28 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::destroy<struct recordedMacroStep>(struct recordedMacroStep *)
.text$mn:00004C28                 public ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z
.text$mn:00004C28 ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z proc near
.text$mn:00004C28                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00004C28                                         ; __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap ...
.text$mn:00004C28
.text$mn:00004C28 var_4           = dword ptr -4
.text$mn:00004C28 arg_0           = dword ptr  8
.text$mn:00004C28
.text$mn:00004C28                 push    ebp
.text$mn:00004C29                 mov     ebp, esp
.text$mn:00004C2B                 push    ecx
.text$mn:00004C2C                 mov     [ebp+var_4], ecx
.text$mn:00004C2F                 mov     eax, [ebp+arg_0]
.text$mn:00004C32                 push    eax
.text$mn:00004C33                 mov     ecx, [ebp+var_4]
.text$mn:00004C36                 push    ecx
.text$mn:00004C37                 call    ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(std::allocator<recordedMacroStep> &,recordedMacroStep *)
.text$mn:00004C3C                 add     esp, 8
.text$mn:00004C3F                 mov     esp, ebp
.text$mn:00004C41                 pop     ebp
.text$mn:00004C42                 retn    4
.text$mn:00004C42 ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z endp
.text$mn:00004C42
.text$mn:00004C42 ; ---------------------------------------------------------------------------
.text$mn:00004C45                 align 4
.text$mn:00004C45 _text$mn        ends
.text$mn:00004C45
.text$mn:00004C48 ; ===========================================================================
.text$mn:00004C48
.text$mn:00004C48 ; Segment type: Pure code
.text$mn:00004C48 ; Segment permissions: Read/Execute
.text$mn:00004C48 _text$mn        segment para public 'CODE' use32
.text$mn:00004C48                 assume cs:_text$mn
.text$mn:00004C48                 ;org 4C48h
.text$mn:00004C48 ; COMDAT (pick any)
.text$mn:00004C48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C48
.text$mn:00004C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C48
.text$mn:00004C48 ; Attributes: bp-based frame
.text$mn:00004C48
.text$mn:00004C48 ; public: void __thiscall std::allocator<struct recordedMacroStep>::destroy<struct recordedMacroStep>(struct recordedMacroStep *)
.text$mn:00004C48                 public ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z
.text$mn:00004C48 ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z proc near
.text$mn:00004C48                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(std::allocator<recordedMacroStep> &,recordedMacroStep *)+Ap
.text$mn:00004C48
.text$mn:00004C48 var_4           = dword ptr -4
.text$mn:00004C48 arg_0           = dword ptr  8
.text$mn:00004C48
.text$mn:00004C48                 push    ebp
.text$mn:00004C49                 mov     ebp, esp
.text$mn:00004C4B                 push    ecx
.text$mn:00004C4C                 mov     [ebp+var_4], ecx
.text$mn:00004C4F                 push    0
.text$mn:00004C51                 mov     ecx, [ebp+arg_0]
.text$mn:00004C54                 call    ??_GrecordedMacroStep@@QAEPAXI@Z ; recordedMacroStep::`scalar deleting destructor'(uint)
.text$mn:00004C59                 mov     esp, ebp
.text$mn:00004C5B                 pop     ebp
.text$mn:00004C5C                 retn    4
.text$mn:00004C5C ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z endp
.text$mn:00004C5C
.text$mn:00004C5C ; ---------------------------------------------------------------------------
.text$mn:00004C5F                 align 10h
.text$mn:00004C5F _text$mn        ends
.text$mn:00004C5F
.text$mn:00004C60 ; ===========================================================================
.text$mn:00004C60
.text$mn:00004C60 ; Segment type: Pure code
.text$mn:00004C60 ; Segment permissions: Read/Execute
.text$mn:00004C60 _text$mn        segment para public 'CODE' use32
.text$mn:00004C60                 assume cs:_text$mn
.text$mn:00004C60                 ;org 4C60h
.text$mn:00004C60 ; COMDAT (pick any)
.text$mn:00004C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C60
.text$mn:00004C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C60
.text$mn:00004C60 ; Attributes: bp-based frame
.text$mn:00004C60
.text$mn:00004C60 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct recordedMacroStep>>::destroy<struct recordedMacroStep>(class std::allocator<struct recordedMacroStep> &, struct recordedMacroStep *)
.text$mn:00004C60                 public ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z
.text$mn:00004C60 ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z proc near
.text$mn:00004C60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(recordedMacroStep *)+Fp
.text$mn:00004C60
.text$mn:00004C60 arg_0           = dword ptr  8
.text$mn:00004C60 arg_4           = dword ptr  0Ch
.text$mn:00004C60
.text$mn:00004C60                 push    ebp
.text$mn:00004C61                 mov     ebp, esp
.text$mn:00004C63                 mov     eax, [ebp+arg_4]
.text$mn:00004C66                 push    eax
.text$mn:00004C67                 mov     ecx, [ebp+arg_0]
.text$mn:00004C6A                 call    ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z ; std::allocator<recordedMacroStep>::destroy<recordedMacroStep>(recordedMacroStep *)
.text$mn:00004C6F                 pop     ebp
.text$mn:00004C70                 retn
.text$mn:00004C70 ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z endp
.text$mn:00004C70
.text$mn:00004C70 ; ---------------------------------------------------------------------------
.text$mn:00004C71                 align 4
.text$mn:00004C71 _text$mn        ends
.text$mn:00004C71
.text$mn:00004C74 ; ===========================================================================
.text$mn:00004C74
.text$mn:00004C74 ; Segment type: Pure code
.text$mn:00004C74 ; Segment permissions: Read/Execute
.text$mn:00004C74 _text$mn        segment para public 'CODE' use32
.text$mn:00004C74                 assume cs:_text$mn
.text$mn:00004C74                 ;org 4C74h
.text$mn:00004C74 ; COMDAT (pick any)
.text$mn:00004C74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C74
.text$mn:00004C74 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C74
.text$mn:00004C74 ; Attributes: bp-based frame
.text$mn:00004C74
.text$mn:00004C74 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class MacroShortcut>>::destroy<class MacroShortcut>(class MacroShortcut *)
.text$mn:00004C74                 public ??$destroy@VMacroShortcut@@@?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAEXPAVMacroShortcut@@@Z
.text$mn:00004C74 ??$destroy@VMacroShortcut@@@?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAEXPAVMacroShortcut@@@Z proc near
.text$mn:00004C74                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+1Fp
.text$mn:00004C74
.text$mn:00004C74 var_4           = dword ptr -4
.text$mn:00004C74 arg_0           = dword ptr  8
.text$mn:00004C74
.text$mn:00004C74                 push    ebp
.text$mn:00004C75                 mov     ebp, esp
.text$mn:00004C77                 push    ecx
.text$mn:00004C78                 mov     [ebp+var_4], ecx
.text$mn:00004C7B                 mov     eax, [ebp+arg_0]
.text$mn:00004C7E                 push    eax
.text$mn:00004C7F                 mov     ecx, [ebp+var_4]
.text$mn:00004C82                 push    ecx
.text$mn:00004C83                 call    ??$destroy@VMacroShortcut@@@?$allocator_traits@V?$allocator@VMacroShortcut@@@std@@@std@@SAXAAV?$allocator@VMacroShortcut@@@1@PAVMacroShortcut@@@Z ; std::allocator_traits<std::allocator<MacroShortcut>>::destroy<MacroShortcut>(std::allocator<MacroShortcut> &,MacroShortcut *)
.text$mn:00004C88                 add     esp, 8
.text$mn:00004C8B                 mov     esp, ebp
.text$mn:00004C8D                 pop     ebp
.text$mn:00004C8E                 retn    4
.text$mn:00004C8E ??$destroy@VMacroShortcut@@@?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAEXPAVMacroShortcut@@@Z endp
.text$mn:00004C8E
.text$mn:00004C8E ; ---------------------------------------------------------------------------
.text$mn:00004C91                 align 4
.text$mn:00004C91 _text$mn        ends
.text$mn:00004C91
.text$mn:00004C94 ; ===========================================================================
.text$mn:00004C94
.text$mn:00004C94 ; Segment type: Pure code
.text$mn:00004C94 ; Segment permissions: Read/Execute
.text$mn:00004C94 _text$mn        segment para public 'CODE' use32
.text$mn:00004C94                 assume cs:_text$mn
.text$mn:00004C94                 ;org 4C94h
.text$mn:00004C94 ; COMDAT (pick any)
.text$mn:00004C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C94
.text$mn:00004C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C94
.text$mn:00004C94 ; Attributes: bp-based frame
.text$mn:00004C94
.text$mn:00004C94 ; public: void __thiscall std::allocator<class MacroShortcut>::destroy<class MacroShortcut>(class MacroShortcut *)
.text$mn:00004C94                 public ??$destroy@VMacroShortcut@@@?$allocator@VMacroShortcut@@@std@@QAEXPAVMacroShortcut@@@Z
.text$mn:00004C94 ??$destroy@VMacroShortcut@@@?$allocator@VMacroShortcut@@@std@@QAEXPAVMacroShortcut@@@Z proc near
.text$mn:00004C94                                         ; CODE XREF: std::allocator_traits<std::allocator<MacroShortcut>>::destroy<MacroShortcut>(std::allocator<MacroShortcut> &,MacroShortcut *)+Ap
.text$mn:00004C94
.text$mn:00004C94 var_4           = dword ptr -4
.text$mn:00004C94 arg_0           = dword ptr  8
.text$mn:00004C94
.text$mn:00004C94                 push    ebp
.text$mn:00004C95                 mov     ebp, esp
.text$mn:00004C97                 push    ecx
.text$mn:00004C98                 mov     [ebp+var_4], ecx
.text$mn:00004C9B                 push    0
.text$mn:00004C9D                 mov     eax, [ebp+arg_0]
.text$mn:00004CA0                 mov     edx, [eax]
.text$mn:00004CA2                 mov     ecx, [ebp+arg_0]
.text$mn:00004CA5                 mov     eax, [edx]
.text$mn:00004CA7                 call    eax
.text$mn:00004CA9                 mov     esp, ebp
.text$mn:00004CAB                 pop     ebp
.text$mn:00004CAC                 retn    4
.text$mn:00004CAC ??$destroy@VMacroShortcut@@@?$allocator@VMacroShortcut@@@std@@QAEXPAVMacroShortcut@@@Z endp
.text$mn:00004CAC
.text$mn:00004CAC ; ---------------------------------------------------------------------------
.text$mn:00004CAF                 align 10h
.text$mn:00004CAF _text$mn        ends
.text$mn:00004CAF
.text$mn:00004CB0 ; ===========================================================================
.text$mn:00004CB0
.text$mn:00004CB0 ; Segment type: Pure code
.text$mn:00004CB0 ; Segment permissions: Read/Execute
.text$mn:00004CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00004CB0                 assume cs:_text$mn
.text$mn:00004CB0                 ;org 4CB0h
.text$mn:00004CB0 ; COMDAT (pick any)
.text$mn:00004CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CB0
.text$mn:00004CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CB0
.text$mn:00004CB0 ; Attributes: bp-based frame
.text$mn:00004CB0
.text$mn:00004CB0 ; public: static void __cdecl std::allocator_traits<class std::allocator<class MacroShortcut>>::destroy<class MacroShortcut>(class std::allocator<class MacroShortcut> &, class MacroShortcut *)
.text$mn:00004CB0                 public ??$destroy@VMacroShortcut@@@?$allocator_traits@V?$allocator@VMacroShortcut@@@std@@@std@@SAXAAV?$allocator@VMacroShortcut@@@1@PAVMacroShortcut@@@Z
.text$mn:00004CB0 ??$destroy@VMacroShortcut@@@?$allocator_traits@V?$allocator@VMacroShortcut@@@std@@@std@@SAXAAV?$allocator@VMacroShortcut@@@1@PAVMacroShortcut@@@Z proc near
.text$mn:00004CB0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MacroShortcut>>::destroy<MacroShortcut>(MacroShortcut *)+Fp
.text$mn:00004CB0
.text$mn:00004CB0 arg_0           = dword ptr  8
.text$mn:00004CB0 arg_4           = dword ptr  0Ch
.text$mn:00004CB0
.text$mn:00004CB0                 push    ebp
.text$mn:00004CB1                 mov     ebp, esp
.text$mn:00004CB3                 mov     eax, [ebp+arg_4]
.text$mn:00004CB6                 push    eax
.text$mn:00004CB7                 mov     ecx, [ebp+arg_0]
.text$mn:00004CBA                 call    ??$destroy@VMacroShortcut@@@?$allocator@VMacroShortcut@@@std@@QAEXPAVMacroShortcut@@@Z ; std::allocator<MacroShortcut>::destroy<MacroShortcut>(MacroShortcut *)
.text$mn:00004CBF                 pop     ebp
.text$mn:00004CC0                 retn
.text$mn:00004CC0 ??$destroy@VMacroShortcut@@@?$allocator_traits@V?$allocator@VMacroShortcut@@@std@@@std@@SAXAAV?$allocator@VMacroShortcut@@@1@PAVMacroShortcut@@@Z endp
.text$mn:00004CC0
.text$mn:00004CC0 ; ---------------------------------------------------------------------------
.text$mn:00004CC1                 align 4
.text$mn:00004CC1 _text$mn        ends
.text$mn:00004CC1
.text$mn:00004CC4 ; ===========================================================================
.text$mn:00004CC4
.text$mn:00004CC4 ; Segment type: Pure code
.text$mn:00004CC4 ; Segment permissions: Read/Execute
.text$mn:00004CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CC4                 assume cs:_text$mn
.text$mn:00004CC4                 ;org 4CC4h
.text$mn:00004CC4 ; COMDAT (pick any)
.text$mn:00004CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CC4
.text$mn:00004CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CC4
.text$mn:00004CC4 ; Attributes: bp-based frame
.text$mn:00004CC4
.text$mn:00004CC4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class UserCommand>>::destroy<class UserCommand>(class UserCommand *)
.text$mn:00004CC4                 public ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z
.text$mn:00004CC4 ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z proc near
.text$mn:00004CC4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+1Fp
.text$mn:00004CC4
.text$mn:00004CC4 var_4           = dword ptr -4
.text$mn:00004CC4 arg_0           = dword ptr  8
.text$mn:00004CC4
.text$mn:00004CC4                 push    ebp
.text$mn:00004CC5                 mov     ebp, esp
.text$mn:00004CC7                 push    ecx
.text$mn:00004CC8                 mov     [ebp+var_4], ecx
.text$mn:00004CCB                 mov     eax, [ebp+arg_0]
.text$mn:00004CCE                 push    eax
.text$mn:00004CCF                 mov     ecx, [ebp+var_4]
.text$mn:00004CD2                 push    ecx
.text$mn:00004CD3                 call    ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z ; std::allocator_traits<std::allocator<UserCommand>>::destroy<UserCommand>(std::allocator<UserCommand> &,UserCommand *)
.text$mn:00004CD8                 add     esp, 8
.text$mn:00004CDB                 mov     esp, ebp
.text$mn:00004CDD                 pop     ebp
.text$mn:00004CDE                 retn    4
.text$mn:00004CDE ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z endp
.text$mn:00004CDE
.text$mn:00004CDE ; ---------------------------------------------------------------------------
.text$mn:00004CE1                 align 4
.text$mn:00004CE1 _text$mn        ends
.text$mn:00004CE1
.text$mn:00004CE4 ; ===========================================================================
.text$mn:00004CE4
.text$mn:00004CE4 ; Segment type: Pure code
.text$mn:00004CE4 ; Segment permissions: Read/Execute
.text$mn:00004CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CE4                 assume cs:_text$mn
.text$mn:00004CE4                 ;org 4CE4h
.text$mn:00004CE4 ; COMDAT (pick any)
.text$mn:00004CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CE4
.text$mn:00004CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CE4
.text$mn:00004CE4 ; Attributes: bp-based frame
.text$mn:00004CE4
.text$mn:00004CE4 ; public: void __thiscall std::allocator<class UserCommand>::destroy<class UserCommand>(class UserCommand *)
.text$mn:00004CE4                 public ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z
.text$mn:00004CE4 ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z proc near
.text$mn:00004CE4                                         ; CODE XREF: std::allocator_traits<std::allocator<UserCommand>>::destroy<UserCommand>(std::allocator<UserCommand> &,UserCommand *)+Ap
.text$mn:00004CE4
.text$mn:00004CE4 var_4           = dword ptr -4
.text$mn:00004CE4 arg_0           = dword ptr  8
.text$mn:00004CE4
.text$mn:00004CE4                 push    ebp
.text$mn:00004CE5                 mov     ebp, esp
.text$mn:00004CE7                 push    ecx
.text$mn:00004CE8                 mov     [ebp+var_4], ecx
.text$mn:00004CEB                 push    0
.text$mn:00004CED                 mov     eax, [ebp+arg_0]
.text$mn:00004CF0                 mov     edx, [eax]
.text$mn:00004CF2                 mov     ecx, [ebp+arg_0]
.text$mn:00004CF5                 mov     eax, [edx]
.text$mn:00004CF7                 call    eax
.text$mn:00004CF9                 mov     esp, ebp
.text$mn:00004CFB                 pop     ebp
.text$mn:00004CFC                 retn    4
.text$mn:00004CFC ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z endp
.text$mn:00004CFC
.text$mn:00004CFC ; ---------------------------------------------------------------------------
.text$mn:00004CFF                 align 10h
.text$mn:00004CFF _text$mn        ends
.text$mn:00004CFF
.text$mn:00004D00 ; ===========================================================================
.text$mn:00004D00
.text$mn:00004D00 ; Segment type: Pure code
.text$mn:00004D00 ; Segment permissions: Read/Execute
.text$mn:00004D00 _text$mn        segment para public 'CODE' use32
.text$mn:00004D00                 assume cs:_text$mn
.text$mn:00004D00                 ;org 4D00h
.text$mn:00004D00 ; COMDAT (pick any)
.text$mn:00004D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D00
.text$mn:00004D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D00
.text$mn:00004D00 ; Attributes: bp-based frame
.text$mn:00004D00
.text$mn:00004D00 ; public: static void __cdecl std::allocator_traits<class std::allocator<class UserCommand>>::destroy<class UserCommand>(class std::allocator<class UserCommand> &, class UserCommand *)
.text$mn:00004D00                 public ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z
.text$mn:00004D00 ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z proc near
.text$mn:00004D00                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::destroy<UserCommand>(UserCommand *)+Fp
.text$mn:00004D00
.text$mn:00004D00 arg_0           = dword ptr  8
.text$mn:00004D00 arg_4           = dword ptr  0Ch
.text$mn:00004D00
.text$mn:00004D00                 push    ebp
.text$mn:00004D01                 mov     ebp, esp
.text$mn:00004D03                 mov     eax, [ebp+arg_4]
.text$mn:00004D06                 push    eax
.text$mn:00004D07                 mov     ecx, [ebp+arg_0]
.text$mn:00004D0A                 call    ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z ; std::allocator<UserCommand>::destroy<UserCommand>(UserCommand *)
.text$mn:00004D0F                 pop     ebp
.text$mn:00004D10                 retn
.text$mn:00004D10 ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z endp
.text$mn:00004D10
.text$mn:00004D10 ; ---------------------------------------------------------------------------
.text$mn:00004D11                 align 4
.text$mn:00004D11 _text$mn        ends
.text$mn:00004D11
.text$mn:00004D14 ; ===========================================================================
.text$mn:00004D14
.text$mn:00004D14 ; Segment type: Pure code
.text$mn:00004D14 ; Segment permissions: Read/Execute
.text$mn:00004D14 _text$mn        segment para public 'CODE' use32
.text$mn:00004D14                 assume cs:_text$mn
.text$mn:00004D14                 ;org 4D14h
.text$mn:00004D14 ; COMDAT (pick any)
.text$mn:00004D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D14
.text$mn:00004D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D14
.text$mn:00004D14 ; Attributes: bp-based frame
.text$mn:00004D14
.text$mn:00004D14 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00004D14                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00004D14 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00004D14                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00004D14                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00004D14
.text$mn:00004D14 arg_0           = dword ptr  8
.text$mn:00004D14
.text$mn:00004D14                 push    ebp
.text$mn:00004D15                 mov     ebp, esp
.text$mn:00004D17                 mov     eax, [ebp+arg_0]
.text$mn:00004D1A                 pop     ebp
.text$mn:00004D1B                 retn
.text$mn:00004D1B ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00004D1B
.text$mn:00004D1B _text$mn        ends
.text$mn:00004D1B
.text$mn:00004D1C ; ===========================================================================
.text$mn:00004D1C
.text$mn:00004D1C ; Segment type: Pure code
.text$mn:00004D1C ; Segment permissions: Read/Execute
.text$mn:00004D1C _text$mn        segment para public 'CODE' use32
.text$mn:00004D1C                 assume cs:_text$mn
.text$mn:00004D1C                 ;org 4D1Ch
.text$mn:00004D1C ; COMDAT (pick any)
.text$mn:00004D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D1C
.text$mn:00004D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D1C
.text$mn:00004D1C ; Attributes: bp-based frame
.text$mn:00004D1C
.text$mn:00004D1C ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00004D1C                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00004D1C ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00004D1C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00004D1C                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00004D1C
.text$mn:00004D1C arg_0           = dword ptr  8
.text$mn:00004D1C
.text$mn:00004D1C                 push    ebp
.text$mn:00004D1D                 mov     ebp, esp
.text$mn:00004D1F                 mov     eax, [ebp+arg_0]
.text$mn:00004D22                 pop     ebp
.text$mn:00004D23                 retn
.text$mn:00004D23 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00004D23
.text$mn:00004D23 _text$mn        ends
.text$mn:00004D23
.text$mn:00004D24 ; ===========================================================================
.text$mn:00004D24
.text$mn:00004D24 ; Segment type: Pure code
.text$mn:00004D24 ; Segment permissions: Read/Execute
.text$mn:00004D24 _text$mn        segment para public 'CODE' use32
.text$mn:00004D24                 assume cs:_text$mn
.text$mn:00004D24                 ;org 4D24h
.text$mn:00004D24 ; COMDAT (pick any)
.text$mn:00004D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D24
.text$mn:00004D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D24
.text$mn:00004D24 ; Attributes: bp-based frame
.text$mn:00004D24
.text$mn:00004D24 ; struct KeyCombo & __cdecl std::forward<struct KeyCombo &>(struct KeyCombo &)
.text$mn:00004D24                 public ??$forward@AAUKeyCombo@@@std@@YAAAUKeyCombo@@AAU1@@Z
.text$mn:00004D24 ??$forward@AAUKeyCombo@@@std@@YAAAUKeyCombo@@AAU1@@Z proc near
.text$mn:00004D24                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)+Bp
.text$mn:00004D24                                         ; std::allocator<KeyCombo>::construct<KeyCombo,KeyCombo &>(KeyCombo *,KeyCombo &)+4Ap ...
.text$mn:00004D24
.text$mn:00004D24 arg_0           = dword ptr  8
.text$mn:00004D24
.text$mn:00004D24                 push    ebp
.text$mn:00004D25                 mov     ebp, esp
.text$mn:00004D27                 mov     eax, [ebp+arg_0]
.text$mn:00004D2A                 pop     ebp
.text$mn:00004D2B                 retn
.text$mn:00004D2B ??$forward@AAUKeyCombo@@@std@@YAAAUKeyCombo@@AAU1@@Z endp
.text$mn:00004D2B
.text$mn:00004D2B _text$mn        ends
.text$mn:00004D2B
.text$mn:00004D2C ; ===========================================================================
.text$mn:00004D2C
.text$mn:00004D2C ; Segment type: Pure code
.text$mn:00004D2C ; Segment permissions: Read/Execute
.text$mn:00004D2C _text$mn        segment para public 'CODE' use32
.text$mn:00004D2C                 assume cs:_text$mn
.text$mn:00004D2C                 ;org 4D2Ch
.text$mn:00004D2C ; COMDAT (pick any)
.text$mn:00004D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D2C
.text$mn:00004D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D2C
.text$mn:00004D2C ; Attributes: bp-based frame
.text$mn:00004D2C
.text$mn:00004D2C ; struct recordedMacroStep & __cdecl std::forward<struct recordedMacroStep &>(struct recordedMacroStep &)
.text$mn:00004D2C                 public ??$forward@AAUrecordedMacroStep@@@std@@YAAAUrecordedMacroStep@@AAU1@@Z
.text$mn:00004D2C ??$forward@AAUrecordedMacroStep@@@std@@YAAAUrecordedMacroStep@@AAU1@@Z proc near
.text$mn:00004D2C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)+Bp
.text$mn:00004D2C                                         ; std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)+4Ap ...
.text$mn:00004D2C
.text$mn:00004D2C arg_0           = dword ptr  8
.text$mn:00004D2C
.text$mn:00004D2C                 push    ebp
.text$mn:00004D2D                 mov     ebp, esp
.text$mn:00004D2F                 mov     eax, [ebp+arg_0]
.text$mn:00004D32                 pop     ebp
.text$mn:00004D33                 retn
.text$mn:00004D33 ??$forward@AAUrecordedMacroStep@@@std@@YAAAUrecordedMacroStep@@AAU1@@Z endp
.text$mn:00004D33
.text$mn:00004D33 _text$mn        ends
.text$mn:00004D33
.text$mn:00004D34 ; ===========================================================================
.text$mn:00004D34
.text$mn:00004D34 ; Segment type: Pure code
.text$mn:00004D34 ; Segment permissions: Read/Execute
.text$mn:00004D34 _text$mn        segment para public 'CODE' use32
.text$mn:00004D34                 assume cs:_text$mn
.text$mn:00004D34                 ;org 4D34h
.text$mn:00004D34 ; COMDAT (pick any)
.text$mn:00004D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D34
.text$mn:00004D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D34
.text$mn:00004D34 ; Attributes: bp-based frame
.text$mn:00004D34
.text$mn:00004D34 ; struct KeyCombo const & __cdecl std::forward<struct KeyCombo const &>(struct KeyCombo const &)
.text$mn:00004D34                 public ??$forward@ABUKeyCombo@@@std@@YAABUKeyCombo@@ABU1@@Z
.text$mn:00004D34 ??$forward@ABUKeyCombo@@@std@@YAABUKeyCombo@@ABU1@@Z proc near
.text$mn:00004D34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(KeyCombo *,KeyCombo const &)+Bp
.text$mn:00004D34                                         ; std::allocator_traits<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(std::allocator<KeyCombo> &,KeyCombo *,KeyCombo const &)+7p
.text$mn:00004D34
.text$mn:00004D34 arg_0           = dword ptr  8
.text$mn:00004D34
.text$mn:00004D34                 push    ebp
.text$mn:00004D35                 mov     ebp, esp
.text$mn:00004D37                 mov     eax, [ebp+arg_0]
.text$mn:00004D3A                 pop     ebp
.text$mn:00004D3B                 retn
.text$mn:00004D3B ??$forward@ABUKeyCombo@@@std@@YAABUKeyCombo@@ABU1@@Z endp
.text$mn:00004D3B
.text$mn:00004D3B _text$mn        ends
.text$mn:00004D3B
.text$mn:00004D3C ; ===========================================================================
.text$mn:00004D3C
.text$mn:00004D3C ; Segment type: Pure code
.text$mn:00004D3C ; Segment permissions: Read/Execute
.text$mn:00004D3C _text$mn        segment para public 'CODE' use32
.text$mn:00004D3C                 assume cs:_text$mn
.text$mn:00004D3C                 ;org 4D3Ch
.text$mn:00004D3C ; COMDAT (pick any)
.text$mn:00004D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D3C
.text$mn:00004D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D3C
.text$mn:00004D3C ; Attributes: bp-based frame
.text$mn:00004D3C
.text$mn:00004D3C ; struct recordedMacroStep const & __cdecl std::forward<struct recordedMacroStep const &>(struct recordedMacroStep const &)
.text$mn:00004D3C                 public ??$forward@ABUrecordedMacroStep@@@std@@YAABUrecordedMacroStep@@ABU1@@Z
.text$mn:00004D3C ??$forward@ABUrecordedMacroStep@@@std@@YAABUrecordedMacroStep@@ABU1@@Z proc near
.text$mn:00004D3C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(recordedMacroStep *,recordedMacroStep const &)+Bp
.text$mn:00004D3C                                         ; std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(std::allocator<recordedMacroStep> &,recordedMacroStep *,recordedMacroStep const &)+7p
.text$mn:00004D3C
.text$mn:00004D3C arg_0           = dword ptr  8
.text$mn:00004D3C
.text$mn:00004D3C                 push    ebp
.text$mn:00004D3D                 mov     ebp, esp
.text$mn:00004D3F                 mov     eax, [ebp+arg_0]
.text$mn:00004D42                 pop     ebp
.text$mn:00004D43                 retn
.text$mn:00004D43 ??$forward@ABUrecordedMacroStep@@@std@@YAABUrecordedMacroStep@@ABU1@@Z endp
.text$mn:00004D43
.text$mn:00004D43 _text$mn        ends
.text$mn:00004D43
.text$mn:00004D44 ; ===========================================================================
.text$mn:00004D44
.text$mn:00004D44 ; Segment type: Pure code
.text$mn:00004D44 ; Segment permissions: Read/Execute
.text$mn:00004D44 _text$mn        segment para public 'CODE' use32
.text$mn:00004D44                 assume cs:_text$mn
.text$mn:00004D44                 ;org 4D44h
.text$mn:00004D44 ; COMDAT (pick any)
.text$mn:00004D44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D44
.text$mn:00004D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D44
.text$mn:00004D44 ; Attributes: bp-based frame
.text$mn:00004D44
.text$mn:00004D44 ; struct MenuItemUnit && __cdecl std::forward<struct MenuItemUnit>(struct MenuItemUnit &)
.text$mn:00004D44                 public ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z
.text$mn:00004D44 ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z proc near
.text$mn:00004D44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+Bp
.text$mn:00004D44                                         ; std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+4Ap ...
.text$mn:00004D44
.text$mn:00004D44 arg_0           = dword ptr  8
.text$mn:00004D44
.text$mn:00004D44                 push    ebp
.text$mn:00004D45                 mov     ebp, esp
.text$mn:00004D47                 mov     eax, [ebp+arg_0]
.text$mn:00004D4A                 pop     ebp
.text$mn:00004D4B                 retn
.text$mn:00004D4B ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z endp
.text$mn:00004D4B
.text$mn:00004D4B _text$mn        ends
.text$mn:00004D4B
.text$mn:00004D4C ; ===========================================================================
.text$mn:00004D4C
.text$mn:00004D4C ; Segment type: Pure code
.text$mn:00004D4C ; Segment permissions: Read/Execute
.text$mn:00004D4C _text$mn        segment para public 'CODE' use32
.text$mn:00004D4C                 assume cs:_text$mn
.text$mn:00004D4C                 ;org 4D4Ch
.text$mn:00004D4C ; COMDAT (pick any)
.text$mn:00004D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D4C
.text$mn:00004D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D4C
.text$mn:00004D4C ; Attributes: bp-based frame
.text$mn:00004D4C
.text$mn:00004D4C ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00004D4C                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00004D4C ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00004D4C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00004D4C                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00004D4C
.text$mn:00004D4C arg_0           = dword ptr  8
.text$mn:00004D4C
.text$mn:00004D4C                 push    ebp
.text$mn:00004D4D                 mov     ebp, esp
.text$mn:00004D4F                 mov     eax, [ebp+arg_0]
.text$mn:00004D52                 pop     ebp
.text$mn:00004D53                 retn
.text$mn:00004D53 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00004D53
.text$mn:00004D53 _text$mn        ends
.text$mn:00004D53
.text$mn:00004D54 ; ===========================================================================
.text$mn:00004D54
.text$mn:00004D54 ; Segment type: Pure code
.text$mn:00004D54 ; Segment permissions: Read/Execute
.text$mn:00004D54 _text$mn        segment para public 'CODE' use32
.text$mn:00004D54                 assume cs:_text$mn
.text$mn:00004D54                 ;org 4D54h
.text$mn:00004D54 ; COMDAT (pick any)
.text$mn:00004D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D54
.text$mn:00004D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D54
.text$mn:00004D54 ; Attributes: bp-based frame
.text$mn:00004D54
.text$mn:00004D54 ; class MacroShortcut && __cdecl std::move<class MacroShortcut &>(class MacroShortcut &)
.text$mn:00004D54                 public ??$move@AAVMacroShortcut@@@std@@YA$$QAVMacroShortcut@@AAV1@@Z
.text$mn:00004D54 ??$move@AAVMacroShortcut@@@std@@YA$$QAVMacroShortcut@@AAV1@@Z proc near
.text$mn:00004D54                                         ; CODE XREF: std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *,std::_Nonscalar_ptr_iterator_tag)+28p
.text$mn:00004D54
.text$mn:00004D54 arg_0           = dword ptr  8
.text$mn:00004D54
.text$mn:00004D54                 push    ebp
.text$mn:00004D55                 mov     ebp, esp
.text$mn:00004D57                 mov     eax, [ebp+arg_0]
.text$mn:00004D5A                 pop     ebp
.text$mn:00004D5B                 retn
.text$mn:00004D5B ??$move@AAVMacroShortcut@@@std@@YA$$QAVMacroShortcut@@AAV1@@Z endp
.text$mn:00004D5B
.text$mn:00004D5B _text$mn        ends
.text$mn:00004D5B
.text$mn:00004D5C ; ===========================================================================
.text$mn:00004D5C
.text$mn:00004D5C ; Segment type: Pure code
.text$mn:00004D5C ; Segment permissions: Read/Execute
.text$mn:00004D5C _text$mn        segment para public 'CODE' use32
.text$mn:00004D5C                 assume cs:_text$mn
.text$mn:00004D5C                 ;org 4D5Ch
.text$mn:00004D5C ; COMDAT (pick any)
.text$mn:00004D5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D5C
.text$mn:00004D5C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D5C
.text$mn:00004D5C ; Attributes: bp-based frame
.text$mn:00004D5C
.text$mn:00004D5C ; class UserCommand && __cdecl std::move<class UserCommand &>(class UserCommand &)
.text$mn:00004D5C                 public ??$move@AAVUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z
.text$mn:00004D5C ??$move@AAVUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z proc near
.text$mn:00004D5C                                         ; CODE XREF: std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+28p
.text$mn:00004D5C
.text$mn:00004D5C arg_0           = dword ptr  8
.text$mn:00004D5C
.text$mn:00004D5C                 push    ebp
.text$mn:00004D5D                 mov     ebp, esp
.text$mn:00004D5F                 mov     eax, [ebp+arg_0]
.text$mn:00004D62                 pop     ebp
.text$mn:00004D63                 retn
.text$mn:00004D63 ??$move@AAVUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z endp
.text$mn:00004D63
.text$mn:00004D63 _text$mn        ends
.text$mn:00004D63
.text$mn:00004D64 ; ===========================================================================
.text$mn:00004D64
.text$mn:00004D64 ; Segment type: Pure code
.text$mn:00004D64 ; Segment permissions: Read/Execute
.text$mn:00004D64 _text$mn        segment para public 'CODE' use32
.text$mn:00004D64                 assume cs:_text$mn
.text$mn:00004D64                 ;org 4D64h
.text$mn:00004D64 ; COMDAT (pick any)
.text$mn:00004D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D64
.text$mn:00004D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D64
.text$mn:00004D64 ; Attributes: bp-based frame
.text$mn:00004D64
.text$mn:00004D64 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00004D64                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004D64 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00004D64                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>> const &)+2Dp
.text$mn:00004D64
.text$mn:00004D64 var_10          = dword ptr -10h
.text$mn:00004D64 var_C           = dword ptr -0Ch
.text$mn:00004D64 var_4           = dword ptr -4
.text$mn:00004D64 arg_0           = dword ptr  8
.text$mn:00004D64
.text$mn:00004D64                 push    ebp
.text$mn:00004D65                 mov     ebp, esp
.text$mn:00004D67                 push    0FFFFFFFFh
.text$mn:00004D69                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004D6E                 mov     eax, large fs:0
.text$mn:00004D74                 push    eax
.text$mn:00004D75                 push    ecx
.text$mn:00004D76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D7B                 xor     eax, ebp
.text$mn:00004D7D                 push    eax
.text$mn:00004D7E                 lea     eax, [ebp+var_C]
.text$mn:00004D81                 mov     large fs:0, eax
.text$mn:00004D87                 mov     [ebp+var_10], ecx
.text$mn:00004D8A                 mov     eax, [ebp+arg_0]
.text$mn:00004D8D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004D8E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004D91                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00004D96                 mov     [ebp+var_4], 0
.text$mn:00004D9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004DA4                 mov     eax, [ebp+var_10]
.text$mn:00004DA7                 mov     ecx, [ebp+var_C]
.text$mn:00004DAA                 mov     large fs:0, ecx
.text$mn:00004DB1                 pop     ecx
.text$mn:00004DB2                 mov     esp, ebp
.text$mn:00004DB4                 pop     ebp
.text$mn:00004DB5                 retn    4
.text$mn:00004DB5 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00004DB5
.text$mn:00004DB5 _text$mn        ends
.text$mn:00004DB5
.text$x:00004DB8 ; ===========================================================================
.text$x:00004DB8
.text$x:00004DB8 ; Segment type: Pure code
.text$x:00004DB8 ; Segment permissions: Read/Execute
.text$x:00004DB8 _text$x         segment para public 'CODE' use32
.text$x:00004DB8                 assume cs:_text$x
.text$x:00004DB8                 ;org 4DB8h
.text$x:00004DB8 ; COMDAT (pick associative to section at 4D64)
.text$x:00004DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004DB8
.text$x:00004DB8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DB8
.text$x:00004DB8
.text$x:00004DB8 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00004DB8                                         ; DATA XREF: .xdata$x:0000D59Co
.text$x:00004DB8                 mov     ecx, [ebp-10h]  ; this
.text$x:00004DBB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004DBB __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00004DBB
.text$x:00004DC0
.text$x:00004DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00004DC0
.text$x:00004DC0
.text$x:00004DC0 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00004DC0                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12> const &)+5o
.text$x:00004DC0
.text$x:00004DC0 arg_4           = dword ptr  8
.text$x:00004DC0
.text$x:00004DC0                 mov     edx, [esp+arg_4]
.text$x:00004DC4                 lea     eax, [edx+0Ch]
.text$x:00004DC7                 mov     ecx, [edx-8]
.text$x:00004DCA                 xor     ecx, eax
.text$x:00004DCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004DD1                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00004DD6                 jmp     ___CxxFrameHandler3
.text$x:00004DD6 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00004DD6
.text$x:00004DD6 ; ---------------------------------------------------------------------------
.text$x:00004DDB                 align 4
.text$x:00004DDB _text$x         ends
.text$x:00004DDB
.text$mn:00004DDC ; ===========================================================================
.text$mn:00004DDC
.text$mn:00004DDC ; Segment type: Pure code
.text$mn:00004DDC ; Segment permissions: Read/Execute
.text$mn:00004DDC _text$mn        segment para public 'CODE' use32
.text$mn:00004DDC                 assume cs:_text$mn
.text$mn:00004DDC                 ;org 4DDCh
.text$mn:00004DDC ; COMDAT (pick any)
.text$mn:00004DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DDC
.text$mn:00004DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DDC
.text$mn:00004DDC ; Attributes: bp-based frame
.text$mn:00004DDC
.text$mn:00004DDC ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct KeyCombo, int, struct KeyCombo const *, struct KeyCombo const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct KeyCombo, int, struct KeyCombo const *, struct KeyCombo const &, struct std::_Iterator_base12>(void)
.text$mn:00004DDC                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004DDC ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004DDC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(KeyCombo *,std::_Container_base12 const *)+29p
.text$mn:00004DDC
.text$mn:00004DDC var_10          = dword ptr -10h
.text$mn:00004DDC var_C           = dword ptr -0Ch
.text$mn:00004DDC var_4           = dword ptr -4
.text$mn:00004DDC
.text$mn:00004DDC                 push    ebp
.text$mn:00004DDD                 mov     ebp, esp
.text$mn:00004DDF                 push    0FFFFFFFFh
.text$mn:00004DE1                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004DE6                 mov     eax, large fs:0
.text$mn:00004DEC                 push    eax
.text$mn:00004DED                 push    ecx
.text$mn:00004DEE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004DF3                 xor     eax, ebp
.text$mn:00004DF5                 push    eax
.text$mn:00004DF6                 lea     eax, [ebp+var_C]
.text$mn:00004DF9                 mov     large fs:0, eax
.text$mn:00004DFF                 mov     [ebp+var_10], ecx
.text$mn:00004E02                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004E05                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00004E0A                 mov     [ebp+var_4], 0
.text$mn:00004E11                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E18                 mov     eax, [ebp+var_10]
.text$mn:00004E1B                 mov     ecx, [ebp+var_C]
.text$mn:00004E1E                 mov     large fs:0, ecx
.text$mn:00004E25                 pop     ecx
.text$mn:00004E26                 mov     esp, ebp
.text$mn:00004E28                 pop     ebp
.text$mn:00004E29                 retn
.text$mn:00004E29 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00004E29
.text$mn:00004E29 ; ---------------------------------------------------------------------------
.text$mn:00004E2A                 align 4
.text$mn:00004E2A _text$mn        ends
.text$mn:00004E2A
.text$x:00004E2C ; ===========================================================================
.text$x:00004E2C
.text$x:00004E2C ; Segment type: Pure code
.text$x:00004E2C ; Segment permissions: Read/Execute
.text$x:00004E2C _text$x         segment para public 'CODE' use32
.text$x:00004E2C                 assume cs:_text$x
.text$x:00004E2C                 ;org 4E2Ch
.text$x:00004E2C ; COMDAT (pick associative to section at 4DDC)
.text$x:00004E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004E2C
.text$x:00004E2C ; =============== S U B R O U T I N E =======================================
.text$x:00004E2C
.text$x:00004E2C
.text$x:00004E2C __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004E2C                                         ; DATA XREF: .xdata$x:0000D544o
.text$x:00004E2C                 mov     ecx, [ebp-10h]  ; this
.text$x:00004E2F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004E2F __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00004E2F
.text$x:00004E34
.text$x:00004E34 ; =============== S U B R O U T I N E =======================================
.text$x:00004E34
.text$x:00004E34
.text$x:00004E34 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004E34                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)+5o
.text$x:00004E34
.text$x:00004E34 arg_4           = dword ptr  8
.text$x:00004E34
.text$x:00004E34                 mov     edx, [esp+arg_4]
.text$x:00004E38                 lea     eax, [edx+0Ch]
.text$x:00004E3B                 mov     ecx, [edx-8]
.text$x:00004E3E                 xor     ecx, eax
.text$x:00004E40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E45                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00004E4A                 jmp     ___CxxFrameHandler3
.text$x:00004E4A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00004E4A
.text$x:00004E4A ; ---------------------------------------------------------------------------
.text$x:00004E4F                 align 10h
.text$x:00004E4F _text$x         ends
.text$x:00004E4F
.text$mn:00004E50 ; ===========================================================================
.text$mn:00004E50
.text$mn:00004E50 ; Segment type: Pure code
.text$mn:00004E50 ; Segment permissions: Read/Execute
.text$mn:00004E50 _text$mn        segment para public 'CODE' use32
.text$mn:00004E50                 assume cs:_text$mn
.text$mn:00004E50                 ;org 4E50h
.text$mn:00004E50 ; COMDAT (pick any)
.text$mn:00004E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E50
.text$mn:00004E50 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E50
.text$mn:00004E50 ; Attributes: bp-based frame
.text$mn:00004E50
.text$mn:00004E50 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00004E50                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004E50 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00004E50                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>> const &)+2Dp
.text$mn:00004E50
.text$mn:00004E50 var_10          = dword ptr -10h
.text$mn:00004E50 var_C           = dword ptr -0Ch
.text$mn:00004E50 var_4           = dword ptr -4
.text$mn:00004E50 arg_0           = dword ptr  8
.text$mn:00004E50
.text$mn:00004E50                 push    ebp
.text$mn:00004E51                 mov     ebp, esp
.text$mn:00004E53                 push    0FFFFFFFFh
.text$mn:00004E55                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004E5A                 mov     eax, large fs:0
.text$mn:00004E60                 push    eax
.text$mn:00004E61                 push    ecx
.text$mn:00004E62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E67                 xor     eax, ebp
.text$mn:00004E69                 push    eax
.text$mn:00004E6A                 lea     eax, [ebp+var_C]
.text$mn:00004E6D                 mov     large fs:0, eax
.text$mn:00004E73                 mov     [ebp+var_10], ecx
.text$mn:00004E76                 mov     eax, [ebp+arg_0]
.text$mn:00004E79                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004E7A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004E7D                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00004E82                 mov     [ebp+var_4], 0
.text$mn:00004E89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E90                 mov     eax, [ebp+var_10]
.text$mn:00004E93                 mov     ecx, [ebp+var_C]
.text$mn:00004E96                 mov     large fs:0, ecx
.text$mn:00004E9D                 pop     ecx
.text$mn:00004E9E                 mov     esp, ebp
.text$mn:00004EA0                 pop     ebp
.text$mn:00004EA1                 retn    4
.text$mn:00004EA1 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00004EA1
.text$mn:00004EA1 _text$mn        ends
.text$mn:00004EA1
.text$x:00004EA4 ; ===========================================================================
.text$x:00004EA4
.text$x:00004EA4 ; Segment type: Pure code
.text$x:00004EA4 ; Segment permissions: Read/Execute
.text$x:00004EA4 _text$x         segment para public 'CODE' use32
.text$x:00004EA4                 assume cs:_text$x
.text$x:00004EA4                 ;org 4EA4h
.text$x:00004EA4 ; COMDAT (pick associative to section at 4E50)
.text$x:00004EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004EA4
.text$x:00004EA4 ; =============== S U B R O U T I N E =======================================
.text$x:00004EA4
.text$x:00004EA4
.text$x:00004EA4 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00004EA4                                         ; DATA XREF: .xdata$x:0000E2E4o
.text$x:00004EA4                 mov     ecx, [ebp-10h]  ; this
.text$x:00004EA7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004EA7 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00004EA7
.text$x:00004EAC
.text$x:00004EAC ; =============== S U B R O U T I N E =======================================
.text$x:00004EAC
.text$x:00004EAC
.text$x:00004EAC __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00004EAC                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12> const &)+5o
.text$x:00004EAC
.text$x:00004EAC arg_4           = dword ptr  8
.text$x:00004EAC
.text$x:00004EAC                 mov     edx, [esp+arg_4]
.text$x:00004EB0                 lea     eax, [edx+0Ch]
.text$x:00004EB3                 mov     ecx, [edx-8]
.text$x:00004EB6                 xor     ecx, eax
.text$x:00004EB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004EBD                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00004EC2                 jmp     ___CxxFrameHandler3
.text$x:00004EC2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00004EC2
.text$x:00004EC2 ; ---------------------------------------------------------------------------
.text$x:00004EC7                 align 4
.text$x:00004EC7 _text$x         ends
.text$x:00004EC7
.text$mn:00004EC8 ; ===========================================================================
.text$mn:00004EC8
.text$mn:00004EC8 ; Segment type: Pure code
.text$mn:00004EC8 ; Segment permissions: Read/Execute
.text$mn:00004EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00004EC8                 assume cs:_text$mn
.text$mn:00004EC8                 ;org 4EC8h
.text$mn:00004EC8 ; COMDAT (pick any)
.text$mn:00004EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EC8
.text$mn:00004EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EC8
.text$mn:00004EC8 ; Attributes: bp-based frame
.text$mn:00004EC8
.text$mn:00004EC8 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct recordedMacroStep, int, struct recordedMacroStep const *, struct recordedMacroStep const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct recordedMacroStep, int, struct recordedMacroStep const *, struct recordedMacroStep const &, struct std::_Iterator_base12>(void)
.text$mn:00004EC8                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004EC8 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004EC8                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(recordedMacroStep *,std::_Container_base12 const *)+29p
.text$mn:00004EC8
.text$mn:00004EC8 var_10          = dword ptr -10h
.text$mn:00004EC8 var_C           = dword ptr -0Ch
.text$mn:00004EC8 var_4           = dword ptr -4
.text$mn:00004EC8
.text$mn:00004EC8                 push    ebp
.text$mn:00004EC9                 mov     ebp, esp
.text$mn:00004ECB                 push    0FFFFFFFFh
.text$mn:00004ECD                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004ED2                 mov     eax, large fs:0
.text$mn:00004ED8                 push    eax
.text$mn:00004ED9                 push    ecx
.text$mn:00004EDA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004EDF                 xor     eax, ebp
.text$mn:00004EE1                 push    eax
.text$mn:00004EE2                 lea     eax, [ebp+var_C]
.text$mn:00004EE5                 mov     large fs:0, eax
.text$mn:00004EEB                 mov     [ebp+var_10], ecx
.text$mn:00004EEE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004EF1                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00004EF6                 mov     [ebp+var_4], 0
.text$mn:00004EFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F04                 mov     eax, [ebp+var_10]
.text$mn:00004F07                 mov     ecx, [ebp+var_C]
.text$mn:00004F0A                 mov     large fs:0, ecx
.text$mn:00004F11                 pop     ecx
.text$mn:00004F12                 mov     esp, ebp
.text$mn:00004F14                 pop     ebp
.text$mn:00004F15                 retn
.text$mn:00004F15 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00004F15
.text$mn:00004F15 ; ---------------------------------------------------------------------------
.text$mn:00004F16                 align 4
.text$mn:00004F16 _text$mn        ends
.text$mn:00004F16
.text$x:00004F18 ; ===========================================================================
.text$x:00004F18
.text$x:00004F18 ; Segment type: Pure code
.text$x:00004F18 ; Segment permissions: Read/Execute
.text$x:00004F18 _text$x         segment para public 'CODE' use32
.text$x:00004F18                 assume cs:_text$x
.text$x:00004F18                 ;org 4F18h
.text$x:00004F18 ; COMDAT (pick associative to section at 4EC8)
.text$x:00004F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004F18
.text$x:00004F18 ; =============== S U B R O U T I N E =======================================
.text$x:00004F18
.text$x:00004F18
.text$x:00004F18 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004F18                                         ; DATA XREF: .xdata$x:0000E28Co
.text$x:00004F18                 mov     ecx, [ebp-10h]  ; this
.text$x:00004F1B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004F1B __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00004F1B
.text$x:00004F20
.text$x:00004F20 ; =============== S U B R O U T I N E =======================================
.text$x:00004F20
.text$x:00004F20
.text$x:00004F20 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004F20                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)+5o
.text$x:00004F20
.text$x:00004F20 arg_4           = dword ptr  8
.text$x:00004F20
.text$x:00004F20                 mov     edx, [esp+arg_4]
.text$x:00004F24                 lea     eax, [edx+0Ch]
.text$x:00004F27                 mov     ecx, [edx-8]
.text$x:00004F2A                 xor     ecx, eax
.text$x:00004F2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004F31                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00004F36                 jmp     ___CxxFrameHandler3
.text$x:00004F36 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00004F36
.text$x:00004F36 ; ---------------------------------------------------------------------------
.text$x:00004F3B                 align 4
.text$x:00004F3B _text$x         ends
.text$x:00004F3B
.text$mn:00004F3C ; ===========================================================================
.text$mn:00004F3C
.text$mn:00004F3C ; Segment type: Pure code
.text$mn:00004F3C ; Segment permissions: Read/Execute
.text$mn:00004F3C _text$mn        segment para public 'CODE' use32
.text$mn:00004F3C                 assume cs:_text$mn
.text$mn:00004F3C                 ;org 4F3Ch
.text$mn:00004F3C ; COMDAT (pick any)
.text$mn:00004F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F3C
.text$mn:00004F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F3C
.text$mn:00004F3C ; Attributes: bp-based frame
.text$mn:00004F3C
.text$mn:00004F3C ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00004F3C                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004F3C ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00004F3C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)+2Dp
.text$mn:00004F3C
.text$mn:00004F3C var_10          = dword ptr -10h
.text$mn:00004F3C var_C           = dword ptr -0Ch
.text$mn:00004F3C var_4           = dword ptr -4
.text$mn:00004F3C arg_0           = dword ptr  8
.text$mn:00004F3C
.text$mn:00004F3C                 push    ebp
.text$mn:00004F3D                 mov     ebp, esp
.text$mn:00004F3F                 push    0FFFFFFFFh
.text$mn:00004F41                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004F46                 mov     eax, large fs:0
.text$mn:00004F4C                 push    eax
.text$mn:00004F4D                 push    ecx
.text$mn:00004F4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004F53                 xor     eax, ebp
.text$mn:00004F55                 push    eax
.text$mn:00004F56                 lea     eax, [ebp+var_C]
.text$mn:00004F59                 mov     large fs:0, eax
.text$mn:00004F5F                 mov     [ebp+var_10], ecx
.text$mn:00004F62                 mov     eax, [ebp+arg_0]
.text$mn:00004F65                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004F66                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004F69                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00004F6E                 mov     [ebp+var_4], 0
.text$mn:00004F75                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F7C                 mov     eax, [ebp+var_10]
.text$mn:00004F7F                 mov     ecx, [ebp+var_C]
.text$mn:00004F82                 mov     large fs:0, ecx
.text$mn:00004F89                 pop     ecx
.text$mn:00004F8A                 mov     esp, ebp
.text$mn:00004F8C                 pop     ebp
.text$mn:00004F8D                 retn    4
.text$mn:00004F8D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00004F8D
.text$mn:00004F8D _text$mn        ends
.text$mn:00004F8D
.text$x:00004F90 ; ===========================================================================
.text$x:00004F90
.text$x:00004F90 ; Segment type: Pure code
.text$x:00004F90 ; Segment permissions: Read/Execute
.text$x:00004F90 _text$x         segment para public 'CODE' use32
.text$x:00004F90                 assume cs:_text$x
.text$x:00004F90                 ;org 4F90h
.text$x:00004F90 ; COMDAT (pick associative to section at 4F3C)
.text$x:00004F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004F90
.text$x:00004F90 ; =============== S U B R O U T I N E =======================================
.text$x:00004F90
.text$x:00004F90
.text$x:00004F90 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00004F90                                         ; DATA XREF: .xdata$x:0000DF20o
.text$x:00004F90                 mov     ecx, [ebp-10h]  ; this
.text$x:00004F93                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004F93 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00004F93
.text$x:00004F98
.text$x:00004F98 ; =============== S U B R O U T I N E =======================================
.text$x:00004F98
.text$x:00004F98
.text$x:00004F98 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00004F98                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12> const &)+5o
.text$x:00004F98
.text$x:00004F98 arg_4           = dword ptr  8
.text$x:00004F98
.text$x:00004F98                 mov     edx, [esp+arg_4]
.text$x:00004F9C                 lea     eax, [edx+0Ch]
.text$x:00004F9F                 mov     ecx, [edx-8]
.text$x:00004FA2                 xor     ecx, eax
.text$x:00004FA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004FA9                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00004FAE                 jmp     ___CxxFrameHandler3
.text$x:00004FAE __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00004FAE
.text$x:00004FAE ; ---------------------------------------------------------------------------
.text$x:00004FB3                 align 4
.text$x:00004FB3 _text$x         ends
.text$x:00004FB3
.text$mn:00004FB4 ; ===========================================================================
.text$mn:00004FB4
.text$mn:00004FB4 ; Segment type: Pure code
.text$mn:00004FB4 ; Segment permissions: Read/Execute
.text$mn:00004FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004FB4                 assume cs:_text$mn
.text$mn:00004FB4                 ;org 4FB4h
.text$mn:00004FB4 ; COMDAT (pick any)
.text$mn:00004FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FB4
.text$mn:00004FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FB4
.text$mn:00004FB4 ; Attributes: bp-based frame
.text$mn:00004FB4
.text$mn:00004FB4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class MacroShortcut, int, class MacroShortcut const *, class MacroShortcut const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, class MacroShortcut, int, class MacroShortcut const *, class MacroShortcut const &, struct std::_Iterator_base12>(void)
.text$mn:00004FB4                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004FB4 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004FB4                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(MacroShortcut *,std::_Container_base12 const *)+29p
.text$mn:00004FB4
.text$mn:00004FB4 var_10          = dword ptr -10h
.text$mn:00004FB4 var_C           = dword ptr -0Ch
.text$mn:00004FB4 var_4           = dword ptr -4
.text$mn:00004FB4
.text$mn:00004FB4                 push    ebp
.text$mn:00004FB5                 mov     ebp, esp
.text$mn:00004FB7                 push    0FFFFFFFFh
.text$mn:00004FB9                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004FBE                 mov     eax, large fs:0
.text$mn:00004FC4                 push    eax
.text$mn:00004FC5                 push    ecx
.text$mn:00004FC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004FCB                 xor     eax, ebp
.text$mn:00004FCD                 push    eax
.text$mn:00004FCE                 lea     eax, [ebp+var_C]
.text$mn:00004FD1                 mov     large fs:0, eax
.text$mn:00004FD7                 mov     [ebp+var_10], ecx
.text$mn:00004FDA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004FDD                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00004FE2                 mov     [ebp+var_4], 0
.text$mn:00004FE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FF0                 mov     eax, [ebp+var_10]
.text$mn:00004FF3                 mov     ecx, [ebp+var_C]
.text$mn:00004FF6                 mov     large fs:0, ecx
.text$mn:00004FFD                 pop     ecx
.text$mn:00004FFE                 mov     esp, ebp
.text$mn:00005000                 pop     ebp
.text$mn:00005001                 retn
.text$mn:00005001 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00005001
.text$mn:00005001 ; ---------------------------------------------------------------------------
.text$mn:00005002                 align 4
.text$mn:00005002 _text$mn        ends
.text$mn:00005002
.text$x:00005004 ; ===========================================================================
.text$x:00005004
.text$x:00005004 ; Segment type: Pure code
.text$x:00005004 ; Segment permissions: Read/Execute
.text$x:00005004 _text$x         segment para public 'CODE' use32
.text$x:00005004                 assume cs:_text$x
.text$x:00005004                 ;org 5004h
.text$x:00005004 ; COMDAT (pick associative to section at 4FB4)
.text$x:00005004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005004
.text$x:00005004 ; =============== S U B R O U T I N E =======================================
.text$x:00005004
.text$x:00005004
.text$x:00005004 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00005004                                         ; DATA XREF: .xdata$x:0000DEC8o
.text$x:00005004                 mov     ecx, [ebp-10h]  ; this
.text$x:00005007                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00005007 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00005007
.text$x:0000500C
.text$x:0000500C ; =============== S U B R O U T I N E =======================================
.text$x:0000500C
.text$x:0000500C
.text$x:0000500C __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000500C                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(void)+5o
.text$x:0000500C
.text$x:0000500C arg_4           = dword ptr  8
.text$x:0000500C
.text$x:0000500C                 mov     edx, [esp+arg_4]
.text$x:00005010                 lea     eax, [edx+0Ch]
.text$x:00005013                 mov     ecx, [edx-8]
.text$x:00005016                 xor     ecx, eax
.text$x:00005018                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000501D                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00005022                 jmp     ___CxxFrameHandler3
.text$x:00005022 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00005022
.text$x:00005022 ; ---------------------------------------------------------------------------
.text$x:00005027                 align 4
.text$x:00005027 _text$x         ends
.text$x:00005027
.text$mn:00005028 ; ===========================================================================
.text$mn:00005028
.text$mn:00005028 ; Segment type: Pure code
.text$mn:00005028 ; Segment permissions: Read/Execute
.text$mn:00005028 _text$mn        segment para public 'CODE' use32
.text$mn:00005028                 assume cs:_text$mn
.text$mn:00005028                 ;org 5028h
.text$mn:00005028 ; COMDAT (pick any)
.text$mn:00005028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005028
.text$mn:00005028 ; =============== S U B R O U T I N E =======================================
.text$mn:00005028
.text$mn:00005028 ; Attributes: bp-based frame
.text$mn:00005028
.text$mn:00005028 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00005028                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00005028 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00005028                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)+2Dp
.text$mn:00005028
.text$mn:00005028 var_10          = dword ptr -10h
.text$mn:00005028 var_C           = dword ptr -0Ch
.text$mn:00005028 var_4           = dword ptr -4
.text$mn:00005028 arg_0           = dword ptr  8
.text$mn:00005028
.text$mn:00005028                 push    ebp
.text$mn:00005029                 mov     ebp, esp
.text$mn:0000502B                 push    0FFFFFFFFh
.text$mn:0000502D                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00005032                 mov     eax, large fs:0
.text$mn:00005038                 push    eax
.text$mn:00005039                 push    ecx
.text$mn:0000503A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000503F                 xor     eax, ebp
.text$mn:00005041                 push    eax
.text$mn:00005042                 lea     eax, [ebp+var_C]
.text$mn:00005045                 mov     large fs:0, eax
.text$mn:0000504B                 mov     [ebp+var_10], ecx
.text$mn:0000504E                 mov     eax, [ebp+arg_0]
.text$mn:00005051                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005052                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005055                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:0000505A                 mov     [ebp+var_4], 0
.text$mn:00005061                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005068                 mov     eax, [ebp+var_10]
.text$mn:0000506B                 mov     ecx, [ebp+var_C]
.text$mn:0000506E                 mov     large fs:0, ecx
.text$mn:00005075                 pop     ecx
.text$mn:00005076                 mov     esp, ebp
.text$mn:00005078                 pop     ebp
.text$mn:00005079                 retn    4
.text$mn:00005079 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00005079
.text$mn:00005079 _text$mn        ends
.text$mn:00005079
.text$x:0000507C ; ===========================================================================
.text$x:0000507C
.text$x:0000507C ; Segment type: Pure code
.text$x:0000507C ; Segment permissions: Read/Execute
.text$x:0000507C _text$x         segment para public 'CODE' use32
.text$x:0000507C                 assume cs:_text$x
.text$x:0000507C                 ;org 507Ch
.text$x:0000507C ; COMDAT (pick associative to section at 5028)
.text$x:0000507C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000507C
.text$x:0000507C ; =============== S U B R O U T I N E =======================================
.text$x:0000507C
.text$x:0000507C
.text$x:0000507C __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:0000507C                                         ; DATA XREF: .xdata$x:0000E0E0o
.text$x:0000507C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000507F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000507F __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:0000507F
.text$x:00005084
.text$x:00005084 ; =============== S U B R O U T I N E =======================================
.text$x:00005084
.text$x:00005084
.text$x:00005084 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00005084                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12> const &)+5o
.text$x:00005084
.text$x:00005084 arg_4           = dword ptr  8
.text$x:00005084
.text$x:00005084                 mov     edx, [esp+arg_4]
.text$x:00005088                 lea     eax, [edx+0Ch]
.text$x:0000508B                 mov     ecx, [edx-8]
.text$x:0000508E                 xor     ecx, eax
.text$x:00005090                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005095                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:0000509A                 jmp     ___CxxFrameHandler3
.text$x:0000509A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:0000509A
.text$x:0000509A ; ---------------------------------------------------------------------------
.text$x:0000509F                 align 10h
.text$x:0000509F _text$x         ends
.text$x:0000509F
.text$mn:000050A0 ; ===========================================================================
.text$mn:000050A0
.text$mn:000050A0 ; Segment type: Pure code
.text$mn:000050A0 ; Segment permissions: Read/Execute
.text$mn:000050A0 _text$mn        segment para public 'CODE' use32
.text$mn:000050A0                 assume cs:_text$mn
.text$mn:000050A0                 ;org 50A0h
.text$mn:000050A0 ; COMDAT (pick any)
.text$mn:000050A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050A0
.text$mn:000050A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000050A0
.text$mn:000050A0 ; Attributes: bp-based frame
.text$mn:000050A0
.text$mn:000050A0 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class UserCommand, int, class UserCommand const *, class UserCommand const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, class UserCommand, int, class UserCommand const *, class UserCommand const &, struct std::_Iterator_base12>(void)
.text$mn:000050A0                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000050A0 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000050A0                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(UserCommand *,std::_Container_base12 const *)+29p
.text$mn:000050A0
.text$mn:000050A0 var_10          = dword ptr -10h
.text$mn:000050A0 var_C           = dword ptr -0Ch
.text$mn:000050A0 var_4           = dword ptr -4
.text$mn:000050A0
.text$mn:000050A0                 push    ebp
.text$mn:000050A1                 mov     ebp, esp
.text$mn:000050A3                 push    0FFFFFFFFh
.text$mn:000050A5                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000050AA                 mov     eax, large fs:0
.text$mn:000050B0                 push    eax
.text$mn:000050B1                 push    ecx
.text$mn:000050B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000050B7                 xor     eax, ebp
.text$mn:000050B9                 push    eax
.text$mn:000050BA                 lea     eax, [ebp+var_C]
.text$mn:000050BD                 mov     large fs:0, eax
.text$mn:000050C3                 mov     [ebp+var_10], ecx
.text$mn:000050C6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000050C9                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:000050CE                 mov     [ebp+var_4], 0
.text$mn:000050D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050DC                 mov     eax, [ebp+var_10]
.text$mn:000050DF                 mov     ecx, [ebp+var_C]
.text$mn:000050E2                 mov     large fs:0, ecx
.text$mn:000050E9                 pop     ecx
.text$mn:000050EA                 mov     esp, ebp
.text$mn:000050EC                 pop     ebp
.text$mn:000050ED                 retn
.text$mn:000050ED ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:000050ED
.text$mn:000050ED ; ---------------------------------------------------------------------------
.text$mn:000050EE                 align 10h
.text$mn:000050EE _text$mn        ends
.text$mn:000050EE
.text$x:000050F0 ; ===========================================================================
.text$x:000050F0
.text$x:000050F0 ; Segment type: Pure code
.text$x:000050F0 ; Segment permissions: Read/Execute
.text$x:000050F0 _text$x         segment para public 'CODE' use32
.text$x:000050F0                 assume cs:_text$x
.text$x:000050F0                 ;org 50F0h
.text$x:000050F0 ; COMDAT (pick associative to section at 50A0)
.text$x:000050F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000050F0
.text$x:000050F0 ; =============== S U B R O U T I N E =======================================
.text$x:000050F0
.text$x:000050F0
.text$x:000050F0 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000050F0                                         ; DATA XREF: .xdata$x:0000E088o
.text$x:000050F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000050F3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000050F3 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000050F3
.text$x:000050F8
.text$x:000050F8 ; =============== S U B R O U T I N E =======================================
.text$x:000050F8
.text$x:000050F8
.text$x:000050F8 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:000050F8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(void)+5o
.text$x:000050F8
.text$x:000050F8 arg_4           = dword ptr  8
.text$x:000050F8
.text$x:000050F8                 mov     edx, [esp+arg_4]
.text$x:000050FC                 lea     eax, [edx+0Ch]
.text$x:000050FF                 mov     ecx, [edx-8]
.text$x:00005102                 xor     ecx, eax
.text$x:00005104                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005109                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000510E                 jmp     ___CxxFrameHandler3
.text$x:0000510E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000510E
.text$x:0000510E ; ---------------------------------------------------------------------------
.text$x:00005113                 align 4
.text$x:00005113 _text$x         ends
.text$x:00005113
.text$mn:00005114 ; ===========================================================================
.text$mn:00005114
.text$mn:00005114 ; Segment type: Pure code
.text$mn:00005114 ; Segment permissions: Read/Execute
.text$mn:00005114 _text$mn        segment para public 'CODE' use32
.text$mn:00005114                 assume cs:_text$mn
.text$mn:00005114                 ;org 5114h
.text$mn:00005114 ; COMDAT (pick any)
.text$mn:00005114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005114
.text$mn:00005114 ; =============== S U B R O U T I N E =======================================
.text$mn:00005114
.text$mn:00005114 ; Attributes: bp-based frame
.text$mn:00005114
.text$mn:00005114 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00005114                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00005114 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00005114                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00005114
.text$mn:00005114 var_10          = dword ptr -10h
.text$mn:00005114 var_C           = dword ptr -0Ch
.text$mn:00005114 var_4           = dword ptr -4
.text$mn:00005114
.text$mn:00005114                 push    ebp
.text$mn:00005115                 mov     ebp, esp
.text$mn:00005117                 push    0FFFFFFFFh
.text$mn:00005119                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000511E                 mov     eax, large fs:0
.text$mn:00005124                 push    eax
.text$mn:00005125                 push    ecx
.text$mn:00005126                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000512B                 xor     eax, ebp
.text$mn:0000512D                 push    eax
.text$mn:0000512E                 lea     eax, [ebp+var_C]
.text$mn:00005131                 mov     large fs:0, eax
.text$mn:00005137                 mov     [ebp+var_10], ecx
.text$mn:0000513A                 mov     ecx, [ebp+var_10]
.text$mn:0000513D                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00005142                 mov     [ebp+var_4], 0
.text$mn:00005149                 mov     ecx, [ebp+var_10]
.text$mn:0000514C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00005151                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005158                 mov     eax, [ebp+var_10]
.text$mn:0000515B                 mov     ecx, [ebp+var_C]
.text$mn:0000515E                 mov     large fs:0, ecx
.text$mn:00005165                 pop     ecx
.text$mn:00005166                 mov     esp, ebp
.text$mn:00005168                 pop     ebp
.text$mn:00005169                 retn    4
.text$mn:00005169 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00005169
.text$mn:00005169 _text$mn        ends
.text$mn:00005169
.text$x:0000516C ; ===========================================================================
.text$x:0000516C
.text$x:0000516C ; Segment type: Pure code
.text$x:0000516C ; Segment permissions: Read/Execute
.text$x:0000516C _text$x         segment para public 'CODE' use32
.text$x:0000516C                 assume cs:_text$x
.text$x:0000516C                 ;org 516Ch
.text$x:0000516C ; COMDAT (pick associative to section at 5114)
.text$x:0000516C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000516C
.text$x:0000516C ; =============== S U B R O U T I N E =======================================
.text$x:0000516C
.text$x:0000516C
.text$x:0000516C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:0000516C                                         ; DATA XREF: .xdata$x:0000CDD4o
.text$x:0000516C                 mov     ecx, [ebp-10h]
.text$x:0000516F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000516F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:0000516F
.text$x:00005174
.text$x:00005174 ; =============== S U B R O U T I N E =======================================
.text$x:00005174
.text$x:00005174
.text$x:00005174 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00005174                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00005174
.text$x:00005174 arg_4           = dword ptr  8
.text$x:00005174
.text$x:00005174                 mov     edx, [esp+arg_4]
.text$x:00005178                 lea     eax, [edx+0Ch]
.text$x:0000517B                 mov     ecx, [edx-8]
.text$x:0000517E                 xor     ecx, eax
.text$x:00005180                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005185                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000518A                 jmp     ___CxxFrameHandler3
.text$x:0000518A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000518A
.text$x:0000518A ; ---------------------------------------------------------------------------
.text$x:0000518F                 align 10h
.text$x:0000518F _text$x         ends
.text$x:0000518F
.text$mn:00005190 ; ===========================================================================
.text$mn:00005190
.text$mn:00005190 ; Segment type: Pure code
.text$mn:00005190 ; Segment permissions: Read/Execute
.text$mn:00005190 _text$mn        segment para public 'CODE' use32
.text$mn:00005190                 assume cs:_text$mn
.text$mn:00005190                 ;org 5190h
.text$mn:00005190 ; COMDAT (pick any)
.text$mn:00005190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005190
.text$mn:00005190 ; =============== S U B R O U T I N E =======================================
.text$mn:00005190
.text$mn:00005190 ; Attributes: bp-based frame
.text$mn:00005190
.text$mn:00005190 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00005190                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005190 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005190                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p
.text$mn:00005190
.text$mn:00005190 var_10          = dword ptr -10h
.text$mn:00005190 var_C           = dword ptr -0Ch
.text$mn:00005190 var_4           = dword ptr -4
.text$mn:00005190
.text$mn:00005190                 push    ebp
.text$mn:00005191                 mov     ebp, esp
.text$mn:00005193                 push    0FFFFFFFFh
.text$mn:00005195                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000519A                 mov     eax, large fs:0
.text$mn:000051A0                 push    eax
.text$mn:000051A1                 push    ecx
.text$mn:000051A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000051A7                 xor     eax, ebp
.text$mn:000051A9                 push    eax
.text$mn:000051AA                 lea     eax, [ebp+var_C]
.text$mn:000051AD                 mov     large fs:0, eax
.text$mn:000051B3                 mov     [ebp+var_10], ecx
.text$mn:000051B6                 mov     ecx, [ebp+var_10]
.text$mn:000051B9                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000051BE                 mov     [ebp+var_4], 0
.text$mn:000051C5                 mov     ecx, [ebp+var_10]
.text$mn:000051C8                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000051CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051D4                 mov     eax, [ebp+var_10]
.text$mn:000051D7                 mov     ecx, [ebp+var_C]
.text$mn:000051DA                 mov     large fs:0, ecx
.text$mn:000051E1                 pop     ecx
.text$mn:000051E2                 mov     esp, ebp
.text$mn:000051E4                 pop     ebp
.text$mn:000051E5                 retn    4
.text$mn:000051E5 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:000051E5
.text$mn:000051E5 _text$mn        ends
.text$mn:000051E5
.text$x:000051E8 ; ===========================================================================
.text$x:000051E8
.text$x:000051E8 ; Segment type: Pure code
.text$x:000051E8 ; Segment permissions: Read/Execute
.text$x:000051E8 _text$x         segment para public 'CODE' use32
.text$x:000051E8                 assume cs:_text$x
.text$x:000051E8                 ;org 51E8h
.text$x:000051E8 ; COMDAT (pick associative to section at 5190)
.text$x:000051E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000051E8
.text$x:000051E8 ; =============== S U B R O U T I N E =======================================
.text$x:000051E8
.text$x:000051E8
.text$x:000051E8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:000051E8                                         ; DATA XREF: .xdata$x:0000D0F4o
.text$x:000051E8                 mov     ecx, [ebp-10h]
.text$x:000051EB                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000051EB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:000051EB
.text$x:000051F0
.text$x:000051F0 ; =============== S U B R O U T I N E =======================================
.text$x:000051F0
.text$x:000051F0
.text$x:000051F0 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:000051F0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:000051F0
.text$x:000051F0 arg_4           = dword ptr  8
.text$x:000051F0
.text$x:000051F0                 mov     edx, [esp+arg_4]
.text$x:000051F4                 lea     eax, [edx+0Ch]
.text$x:000051F7                 mov     ecx, [edx-8]
.text$x:000051FA                 xor     ecx, eax
.text$x:000051FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005201                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00005206                 jmp     ___CxxFrameHandler3
.text$x:00005206 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00005206
.text$x:00005206 ; ---------------------------------------------------------------------------
.text$x:0000520B                 align 4
.text$x:0000520B _text$x         ends
.text$x:0000520B
.text$mn:0000520C ; ===========================================================================
.text$mn:0000520C
.text$mn:0000520C ; Segment type: Pure code
.text$mn:0000520C ; Segment permissions: Read/Execute
.text$mn:0000520C _text$mn        segment para public 'CODE' use32
.text$mn:0000520C                 assume cs:_text$mn
.text$mn:0000520C                 ;org 520Ch
.text$mn:0000520C ; COMDAT (pick any)
.text$mn:0000520C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000520C
.text$mn:0000520C ; =============== S U B R O U T I N E =======================================
.text$mn:0000520C
.text$mn:0000520C ; Attributes: bp-based frame
.text$mn:0000520C
.text$mn:0000520C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000520C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000520C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000520C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:0000520C
.text$mn:0000520C var_10          = dword ptr -10h
.text$mn:0000520C var_C           = dword ptr -0Ch
.text$mn:0000520C var_4           = dword ptr -4
.text$mn:0000520C
.text$mn:0000520C                 push    ebp
.text$mn:0000520D                 mov     ebp, esp
.text$mn:0000520F                 push    0FFFFFFFFh
.text$mn:00005211                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005216                 mov     eax, large fs:0
.text$mn:0000521C                 push    eax
.text$mn:0000521D                 push    ecx
.text$mn:0000521E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005223                 xor     eax, ebp
.text$mn:00005225                 push    eax
.text$mn:00005226                 lea     eax, [ebp+var_C]
.text$mn:00005229                 mov     large fs:0, eax
.text$mn:0000522F                 mov     [ebp+var_10], ecx
.text$mn:00005232                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005235                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000523A                 mov     [ebp+var_4], 0
.text$mn:00005241                 mov     eax, [ebp+var_10]
.text$mn:00005244                 mov     dword ptr [eax+14h], 0
.text$mn:0000524B                 mov     ecx, [ebp+var_10]
.text$mn:0000524E                 mov     dword ptr [ecx+18h], 0
.text$mn:00005255                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000525C                 mov     eax, [ebp+var_10]
.text$mn:0000525F                 mov     ecx, [ebp+var_C]
.text$mn:00005262                 mov     large fs:0, ecx
.text$mn:00005269                 pop     ecx
.text$mn:0000526A                 mov     esp, ebp
.text$mn:0000526C                 pop     ebp
.text$mn:0000526D                 retn
.text$mn:0000526D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000526D
.text$mn:0000526D ; ---------------------------------------------------------------------------
.text$mn:0000526E                 align 10h
.text$mn:0000526E _text$mn        ends
.text$mn:0000526E
.text$x:00005270 ; ===========================================================================
.text$x:00005270
.text$x:00005270 ; Segment type: Pure code
.text$x:00005270 ; Segment permissions: Read/Execute
.text$x:00005270 _text$x         segment para public 'CODE' use32
.text$x:00005270                 assume cs:_text$x
.text$x:00005270                 ;org 5270h
.text$x:00005270 ; COMDAT (pick associative to section at 520C)
.text$x:00005270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005270
.text$x:00005270 ; =============== S U B R O U T I N E =======================================
.text$x:00005270
.text$x:00005270
.text$x:00005270 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00005270                                         ; DATA XREF: .xdata$x:0000CD7Co
.text$x:00005270                 mov     ecx, [ebp-10h]  ; this
.text$x:00005273                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005273 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00005273
.text$x:00005278
.text$x:00005278 ; =============== S U B R O U T I N E =======================================
.text$x:00005278
.text$x:00005278
.text$x:00005278 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00005278                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00005278
.text$x:00005278 arg_4           = dword ptr  8
.text$x:00005278
.text$x:00005278                 mov     edx, [esp+arg_4]
.text$x:0000527C                 lea     eax, [edx+0Ch]
.text$x:0000527F                 mov     ecx, [edx-8]
.text$x:00005282                 xor     ecx, eax
.text$x:00005284                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005289                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000528E                 jmp     ___CxxFrameHandler3
.text$x:0000528E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000528E
.text$x:0000528E ; ---------------------------------------------------------------------------
.text$x:00005293                 align 4
.text$x:00005293 _text$x         ends
.text$x:00005293
.text$mn:00005294 ; ===========================================================================
.text$mn:00005294
.text$mn:00005294 ; Segment type: Pure code
.text$mn:00005294 ; Segment permissions: Read/Execute
.text$mn:00005294 _text$mn        segment para public 'CODE' use32
.text$mn:00005294                 assume cs:_text$mn
.text$mn:00005294                 ;org 5294h
.text$mn:00005294 ; COMDAT (pick any)
.text$mn:00005294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005294
.text$mn:00005294 ; =============== S U B R O U T I N E =======================================
.text$mn:00005294
.text$mn:00005294 ; Attributes: bp-based frame
.text$mn:00005294
.text$mn:00005294 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00005294                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00005294 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005294                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00005294
.text$mn:00005294 var_10          = dword ptr -10h
.text$mn:00005294 var_C           = dword ptr -0Ch
.text$mn:00005294 var_4           = dword ptr -4
.text$mn:00005294
.text$mn:00005294                 push    ebp
.text$mn:00005295                 mov     ebp, esp
.text$mn:00005297                 push    0FFFFFFFFh
.text$mn:00005299                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000529E                 mov     eax, large fs:0
.text$mn:000052A4                 push    eax
.text$mn:000052A5                 push    ecx
.text$mn:000052A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000052AB                 xor     eax, ebp
.text$mn:000052AD                 push    eax
.text$mn:000052AE                 lea     eax, [ebp+var_C]
.text$mn:000052B1                 mov     large fs:0, eax
.text$mn:000052B7                 mov     [ebp+var_10], ecx
.text$mn:000052BA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000052BD                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000052C2                 mov     [ebp+var_4], 0
.text$mn:000052C9                 mov     eax, [ebp+var_10]
.text$mn:000052CC                 mov     dword ptr [eax+14h], 0
.text$mn:000052D3                 mov     ecx, [ebp+var_10]
.text$mn:000052D6                 mov     dword ptr [ecx+18h], 0
.text$mn:000052DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000052E4                 mov     eax, [ebp+var_10]
.text$mn:000052E7                 mov     ecx, [ebp+var_C]
.text$mn:000052EA                 mov     large fs:0, ecx
.text$mn:000052F1                 pop     ecx
.text$mn:000052F2                 mov     esp, ebp
.text$mn:000052F4                 pop     ebp
.text$mn:000052F5                 retn
.text$mn:000052F5 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000052F5
.text$mn:000052F5 ; ---------------------------------------------------------------------------
.text$mn:000052F6                 align 4
.text$mn:000052F6 _text$mn        ends
.text$mn:000052F6
.text$x:000052F8 ; ===========================================================================
.text$x:000052F8
.text$x:000052F8 ; Segment type: Pure code
.text$x:000052F8 ; Segment permissions: Read/Execute
.text$x:000052F8 _text$x         segment para public 'CODE' use32
.text$x:000052F8                 assume cs:_text$x
.text$x:000052F8                 ;org 52F8h
.text$x:000052F8 ; COMDAT (pick associative to section at 5294)
.text$x:000052F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000052F8
.text$x:000052F8 ; =============== S U B R O U T I N E =======================================
.text$x:000052F8
.text$x:000052F8
.text$x:000052F8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000052F8                                         ; DATA XREF: .xdata$x:0000D09Co
.text$x:000052F8                 mov     ecx, [ebp-10h]  ; this
.text$x:000052FB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000052FB __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000052FB
.text$x:00005300
.text$x:00005300 ; =============== S U B R O U T I N E =======================================
.text$x:00005300
.text$x:00005300
.text$x:00005300 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00005300                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00005300
.text$x:00005300 arg_4           = dword ptr  8
.text$x:00005300
.text$x:00005300                 mov     edx, [esp+arg_4]
.text$x:00005304                 lea     eax, [edx+0Ch]
.text$x:00005307                 mov     ecx, [edx-8]
.text$x:0000530A                 xor     ecx, eax
.text$x:0000530C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005311                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00005316                 jmp     ___CxxFrameHandler3
.text$x:00005316 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00005316
.text$x:00005316 ; ---------------------------------------------------------------------------
.text$x:0000531B                 align 4
.text$x:0000531B _text$x         ends
.text$x:0000531B
.text$mn:0000531C ; ===========================================================================
.text$mn:0000531C
.text$mn:0000531C ; Segment type: Pure code
.text$mn:0000531C ; Segment permissions: Read/Execute
.text$mn:0000531C _text$mn        segment para public 'CODE' use32
.text$mn:0000531C                 assume cs:_text$mn
.text$mn:0000531C                 ;org 531Ch
.text$mn:0000531C ; COMDAT (pick any)
.text$mn:0000531C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000531C
.text$mn:0000531C ; =============== S U B R O U T I N E =======================================
.text$mn:0000531C
.text$mn:0000531C ; Attributes: bp-based frame
.text$mn:0000531C
.text$mn:0000531C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>(class std::allocator<struct KeyCombo> const &)
.text$mn:0000531C                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z
.text$mn:0000531C ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z proc near
.text$mn:0000531C                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+4Ap
.text$mn:0000531C
.text$mn:0000531C var_10          = dword ptr -10h
.text$mn:0000531C var_C           = dword ptr -0Ch
.text$mn:0000531C var_4           = dword ptr -4
.text$mn:0000531C
.text$mn:0000531C                 push    ebp
.text$mn:0000531D                 mov     ebp, esp
.text$mn:0000531F                 push    0FFFFFFFFh
.text$mn:00005321                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z
.text$mn:00005326                 mov     eax, large fs:0
.text$mn:0000532C                 push    eax
.text$mn:0000532D                 push    ecx
.text$mn:0000532E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005333                 xor     eax, ebp
.text$mn:00005335                 push    eax
.text$mn:00005336                 lea     eax, [ebp+var_C]
.text$mn:00005339                 mov     large fs:0, eax
.text$mn:0000533F                 mov     [ebp+var_10], ecx
.text$mn:00005342                 mov     ecx, [ebp+var_10]
.text$mn:00005345                 call    ??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<KeyCombo>>::_Vector_val<std::_Simple_types<KeyCombo>>(void)
.text$mn:0000534A                 mov     [ebp+var_4], 0
.text$mn:00005351                 mov     ecx, [ebp+var_10]
.text$mn:00005354                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Alloc_proxy(void)
.text$mn:00005359                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005360                 mov     eax, [ebp+var_10]
.text$mn:00005363                 mov     ecx, [ebp+var_C]
.text$mn:00005366                 mov     large fs:0, ecx
.text$mn:0000536D                 pop     ecx
.text$mn:0000536E                 mov     esp, ebp
.text$mn:00005370                 pop     ebp
.text$mn:00005371                 retn    4
.text$mn:00005371 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z endp
.text$mn:00005371
.text$mn:00005371 _text$mn        ends
.text$mn:00005371
.text$x:00005374 ; ===========================================================================
.text$x:00005374
.text$x:00005374 ; Segment type: Pure code
.text$x:00005374 ; Segment permissions: Read/Execute
.text$x:00005374 _text$x         segment para public 'CODE' use32
.text$x:00005374                 assume cs:_text$x
.text$x:00005374                 ;org 5374h
.text$x:00005374 ; COMDAT (pick associative to section at 531C)
.text$x:00005374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005374
.text$x:00005374 ; =============== S U B R O U T I N E =======================================
.text$x:00005374
.text$x:00005374
.text$x:00005374 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z$0 proc near
.text$x:00005374                                         ; DATA XREF: .xdata$x:0000D338o
.text$x:00005374                 mov     ecx, [ebp-10h]
.text$x:00005377                 jmp     ??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<KeyCombo>>::~_Vector_val<std::_Simple_types<KeyCombo>>(void)
.text$x:00005377 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z$0 endp
.text$x:00005377
.text$x:0000537C
.text$x:0000537C ; =============== S U B R O U T I N E =======================================
.text$x:0000537C
.text$x:0000537C
.text$x:0000537C __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z proc near
.text$x:0000537C                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(std::allocator<KeyCombo> const &)+5o
.text$x:0000537C
.text$x:0000537C arg_4           = dword ptr  8
.text$x:0000537C
.text$x:0000537C                 mov     edx, [esp+arg_4]
.text$x:00005380                 lea     eax, [edx+0Ch]
.text$x:00005383                 mov     ecx, [edx-8]
.text$x:00005386                 xor     ecx, eax
.text$x:00005388                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000538D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z
.text$x:00005392                 jmp     ___CxxFrameHandler3
.text$x:00005392 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z endp
.text$x:00005392
.text$x:00005392 ; ---------------------------------------------------------------------------
.text$x:00005397                 align 4
.text$x:00005397 _text$x         ends
.text$x:00005397
.text$mn:00005398 ; ===========================================================================
.text$mn:00005398
.text$mn:00005398 ; Segment type: Pure code
.text$mn:00005398 ; Segment permissions: Read/Execute
.text$mn:00005398 _text$mn        segment para public 'CODE' use32
.text$mn:00005398                 assume cs:_text$mn
.text$mn:00005398                 ;org 5398h
.text$mn:00005398 ; COMDAT (pick any)
.text$mn:00005398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005398
.text$mn:00005398 ; =============== S U B R O U T I N E =======================================
.text$mn:00005398
.text$mn:00005398 ; Attributes: bp-based frame
.text$mn:00005398
.text$mn:00005398 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>(class std::allocator<struct MenuItemUnit> const &)
.text$mn:00005398                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.text$mn:00005398 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z proc near
.text$mn:00005398                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+34p
.text$mn:00005398
.text$mn:00005398 var_10          = dword ptr -10h
.text$mn:00005398 var_C           = dword ptr -0Ch
.text$mn:00005398 var_4           = dword ptr -4
.text$mn:00005398
.text$mn:00005398                 push    ebp
.text$mn:00005399                 mov     ebp, esp
.text$mn:0000539B                 push    0FFFFFFFFh
.text$mn:0000539D                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.text$mn:000053A2                 mov     eax, large fs:0
.text$mn:000053A8                 push    eax
.text$mn:000053A9                 push    ecx
.text$mn:000053AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000053AF                 xor     eax, ebp
.text$mn:000053B1                 push    eax
.text$mn:000053B2                 lea     eax, [ebp+var_C]
.text$mn:000053B5                 mov     large fs:0, eax
.text$mn:000053BB                 mov     [ebp+var_10], ecx
.text$mn:000053BE                 mov     ecx, [ebp+var_10]
.text$mn:000053C1                 call    ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$mn:000053C6                 mov     [ebp+var_4], 0
.text$mn:000053CD                 mov     ecx, [ebp+var_10]
.text$mn:000053D0                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)
.text$mn:000053D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000053DC                 mov     eax, [ebp+var_10]
.text$mn:000053DF                 mov     ecx, [ebp+var_C]
.text$mn:000053E2                 mov     large fs:0, ecx
.text$mn:000053E9                 pop     ecx
.text$mn:000053EA                 mov     esp, ebp
.text$mn:000053EC                 pop     ebp
.text$mn:000053ED                 retn    4
.text$mn:000053ED ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z endp
.text$mn:000053ED
.text$mn:000053ED _text$mn        ends
.text$mn:000053ED
.text$x:000053F0 ; ===========================================================================
.text$x:000053F0
.text$x:000053F0 ; Segment type: Pure code
.text$x:000053F0 ; Segment permissions: Read/Execute
.text$x:000053F0 _text$x         segment para public 'CODE' use32
.text$x:000053F0                 assume cs:_text$x
.text$x:000053F0                 ;org 53F0h
.text$x:000053F0 ; COMDAT (pick associative to section at 5398)
.text$x:000053F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000053F0
.text$x:000053F0 ; =============== S U B R O U T I N E =======================================
.text$x:000053F0
.text$x:000053F0
.text$x:000053F0 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0 proc near
.text$x:000053F0                                         ; DATA XREF: .xdata$x:0000DD94o
.text$x:000053F0                 mov     ecx, [ebp-10h]
.text$x:000053F3                 jmp     ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$x:000053F3 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0 endp
.text$x:000053F3
.text$x:000053F8
.text$x:000053F8 ; =============== S U B R O U T I N E =======================================
.text$x:000053F8
.text$x:000053F8
.text$x:000053F8 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z proc near
.text$x:000053F8                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)+5o
.text$x:000053F8
.text$x:000053F8 arg_4           = dword ptr  8
.text$x:000053F8
.text$x:000053F8                 mov     edx, [esp+arg_4]
.text$x:000053FC                 lea     eax, [edx+0Ch]
.text$x:000053FF                 mov     ecx, [edx-8]
.text$x:00005402                 xor     ecx, eax
.text$x:00005404                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005409                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.text$x:0000540E                 jmp     ___CxxFrameHandler3
.text$x:0000540E __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z endp
.text$x:0000540E
.text$x:0000540E ; ---------------------------------------------------------------------------
.text$x:00005413                 align 4
.text$x:00005413 _text$x         ends
.text$x:00005413
.text$mn:00005414 ; ===========================================================================
.text$mn:00005414
.text$mn:00005414 ; Segment type: Pure code
.text$mn:00005414 ; Segment permissions: Read/Execute
.text$mn:00005414 _text$mn        segment para public 'CODE' use32
.text$mn:00005414                 assume cs:_text$mn
.text$mn:00005414                 ;org 5414h
.text$mn:00005414 ; COMDAT (pick any)
.text$mn:00005414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005414
.text$mn:00005414 ; =============== S U B R O U T I N E =======================================
.text$mn:00005414
.text$mn:00005414 ; Attributes: bp-based frame
.text$mn:00005414
.text$mn:00005414 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>(class std::allocator<struct recordedMacroStep> const &)
.text$mn:00005414                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z
.text$mn:00005414 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z proc near
.text$mn:00005414                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+4Ap
.text$mn:00005414
.text$mn:00005414 var_10          = dword ptr -10h
.text$mn:00005414 var_C           = dword ptr -0Ch
.text$mn:00005414 var_4           = dword ptr -4
.text$mn:00005414
.text$mn:00005414                 push    ebp
.text$mn:00005415                 mov     ebp, esp
.text$mn:00005417                 push    0FFFFFFFFh
.text$mn:00005419                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z
.text$mn:0000541E                 mov     eax, large fs:0
.text$mn:00005424                 push    eax
.text$mn:00005425                 push    ecx
.text$mn:00005426                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000542B                 xor     eax, ebp
.text$mn:0000542D                 push    eax
.text$mn:0000542E                 lea     eax, [ebp+var_C]
.text$mn:00005431                 mov     large fs:0, eax
.text$mn:00005437                 mov     [ebp+var_10], ecx
.text$mn:0000543A                 mov     ecx, [ebp+var_10]
.text$mn:0000543D                 call    ??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<recordedMacroStep>>::_Vector_val<std::_Simple_types<recordedMacroStep>>(void)
.text$mn:00005442                 mov     [ebp+var_4], 0
.text$mn:00005449                 mov     ecx, [ebp+var_10]
.text$mn:0000544C                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Alloc_proxy(void)
.text$mn:00005451                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005458                 mov     eax, [ebp+var_10]
.text$mn:0000545B                 mov     ecx, [ebp+var_C]
.text$mn:0000545E                 mov     large fs:0, ecx
.text$mn:00005465                 pop     ecx
.text$mn:00005466                 mov     esp, ebp
.text$mn:00005468                 pop     ebp
.text$mn:00005469                 retn    4
.text$mn:00005469 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z endp
.text$mn:00005469
.text$mn:00005469 _text$mn        ends
.text$mn:00005469
.text$x:0000546C ; ===========================================================================
.text$x:0000546C
.text$x:0000546C ; Segment type: Pure code
.text$x:0000546C ; Segment permissions: Read/Execute
.text$x:0000546C _text$x         segment para public 'CODE' use32
.text$x:0000546C                 assume cs:_text$x
.text$x:0000546C                 ;org 546Ch
.text$x:0000546C ; COMDAT (pick associative to section at 5414)
.text$x:0000546C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000546C
.text$x:0000546C ; =============== S U B R O U T I N E =======================================
.text$x:0000546C
.text$x:0000546C
.text$x:0000546C __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z$0 proc near
.text$x:0000546C                                         ; DATA XREF: .xdata$x:0000D728o
.text$x:0000546C                 mov     ecx, [ebp-10h]
.text$x:0000546F                 jmp     ??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<recordedMacroStep>>::~_Vector_val<std::_Simple_types<recordedMacroStep>>(void)
.text$x:0000546F __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z$0 endp
.text$x:0000546F
.text$x:00005474
.text$x:00005474 ; =============== S U B R O U T I N E =======================================
.text$x:00005474
.text$x:00005474
.text$x:00005474 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z proc near
.text$x:00005474                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(std::allocator<recordedMacroStep> const &)+5o
.text$x:00005474
.text$x:00005474 arg_4           = dword ptr  8
.text$x:00005474
.text$x:00005474                 mov     edx, [esp+arg_4]
.text$x:00005478                 lea     eax, [edx+0Ch]
.text$x:0000547B                 mov     ecx, [edx-8]
.text$x:0000547E                 xor     ecx, eax
.text$x:00005480                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005485                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z
.text$x:0000548A                 jmp     ___CxxFrameHandler3
.text$x:0000548A __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z endp
.text$x:0000548A
.text$x:0000548A ; ---------------------------------------------------------------------------
.text$x:0000548F                 align 10h
.text$x:0000548F _text$x         ends
.text$x:0000548F
.text$mn:00005490 ; ===========================================================================
.text$mn:00005490
.text$mn:00005490 ; Segment type: Pure code
.text$mn:00005490 ; Segment permissions: Read/Execute
.text$mn:00005490 _text$mn        segment para public 'CODE' use32
.text$mn:00005490                 assume cs:_text$mn
.text$mn:00005490                 ;org 5490h
.text$mn:00005490 ; COMDAT (pick any)
.text$mn:00005490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005490
.text$mn:00005490 ; =============== S U B R O U T I N E =======================================
.text$mn:00005490
.text$mn:00005490 ; Attributes: bp-based frame
.text$mn:00005490
.text$mn:00005490 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(struct std::_Iterator_base12 *)
.text$mn:00005490                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005490 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005490                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)+4Fp
.text$mn:00005490                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)+6Dp ...
.text$mn:00005490
.text$mn:00005490 var_10          = dword ptr -10h
.text$mn:00005490 var_C           = dword ptr -0Ch
.text$mn:00005490 var_4           = dword ptr -4
.text$mn:00005490 arg_0           = dword ptr  8
.text$mn:00005490
.text$mn:00005490                 push    ebp
.text$mn:00005491                 mov     ebp, esp
.text$mn:00005493                 push    0FFFFFFFFh
.text$mn:00005495                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000549A                 mov     eax, large fs:0
.text$mn:000054A0                 push    eax
.text$mn:000054A1                 push    ecx
.text$mn:000054A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000054A7                 xor     eax, ebp
.text$mn:000054A9                 push    eax
.text$mn:000054AA                 lea     eax, [ebp+var_C]
.text$mn:000054AD                 mov     large fs:0, eax
.text$mn:000054B3                 mov     [ebp+var_10], ecx
.text$mn:000054B6                 mov     eax, [ebp+arg_0]
.text$mn:000054B9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000054BA                 mov     ecx, [ebp+var_10]
.text$mn:000054BD                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12> const &)
.text$mn:000054C2                 mov     [ebp+var_4], 0
.text$mn:000054C9                 mov     ecx, [ebp+var_10]
.text$mn:000054CC                 mov     edx, [ebp+arg_0]
.text$mn:000054CF                 mov     eax, [edx+8]
.text$mn:000054D2                 mov     [ecx+8], eax
.text$mn:000054D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000054DC                 mov     eax, [ebp+var_10]
.text$mn:000054DF                 mov     ecx, [ebp+var_C]
.text$mn:000054E2                 mov     large fs:0, ecx
.text$mn:000054E9                 pop     ecx
.text$mn:000054EA                 mov     esp, ebp
.text$mn:000054EC                 pop     ebp
.text$mn:000054ED                 retn    4
.text$mn:000054ED ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000054ED
.text$mn:000054ED _text$mn        ends
.text$mn:000054ED
.text$x:000054F0 ; ===========================================================================
.text$x:000054F0
.text$x:000054F0 ; Segment type: Pure code
.text$x:000054F0 ; Segment permissions: Read/Execute
.text$x:000054F0 _text$x         segment para public 'CODE' use32
.text$x:000054F0                 assume cs:_text$x
.text$x:000054F0                 ;org 54F0h
.text$x:000054F0 ; COMDAT (pick associative to section at 5490)
.text$x:000054F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000054F0
.text$x:000054F0 ; =============== S U B R O U T I N E =======================================
.text$x:000054F0
.text$x:000054F0
.text$x:000054F0 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000054F0                                         ; DATA XREF: .xdata$x:0000D620o
.text$x:000054F0                 mov     ecx, [ebp-10h]
.text$x:000054F3                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)
.text$x:000054F3 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000054F3
.text$x:000054F8
.text$x:000054F8 ; =============== S U B R O U T I N E =======================================
.text$x:000054F8
.text$x:000054F8
.text$x:000054F8 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000054F8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>> const &)+5o
.text$x:000054F8
.text$x:000054F8 arg_4           = dword ptr  8
.text$x:000054F8
.text$x:000054F8                 mov     edx, [esp+arg_4]
.text$x:000054FC                 lea     eax, [edx+0Ch]
.text$x:000054FF                 mov     ecx, [edx-8]
.text$x:00005502                 xor     ecx, eax
.text$x:00005504                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005509                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000550E                 jmp     ___CxxFrameHandler3
.text$x:0000550E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000550E
.text$x:0000550E ; ---------------------------------------------------------------------------
.text$x:00005513                 align 4
.text$x:00005513 _text$x         ends
.text$x:00005513
.text$mn:00005514 ; ===========================================================================
.text$mn:00005514
.text$mn:00005514 ; Segment type: Pure code
.text$mn:00005514 ; Segment permissions: Read/Execute
.text$mn:00005514 _text$mn        segment para public 'CODE' use32
.text$mn:00005514                 assume cs:_text$mn
.text$mn:00005514                 ;org 5514h
.text$mn:00005514 ; COMDAT (pick any)
.text$mn:00005514                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005514
.text$mn:00005514 ; =============== S U B R O U T I N E =======================================
.text$mn:00005514
.text$mn:00005514 ; Attributes: bp-based frame
.text$mn:00005514
.text$mn:00005514 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(int, struct std::_Container_base12 *)
.text$mn:00005514                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z
.text$mn:00005514 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z proc near
.text$mn:00005514                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::begin(void)+3Dp
.text$mn:00005514                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::end(void)+3Dp
.text$mn:00005514
.text$mn:00005514 var_10          = dword ptr -10h
.text$mn:00005514 var_C           = dword ptr -0Ch
.text$mn:00005514 var_4           = dword ptr -4
.text$mn:00005514 arg_0           = dword ptr  8
.text$mn:00005514 arg_4           = dword ptr  0Ch
.text$mn:00005514
.text$mn:00005514                 push    ebp
.text$mn:00005515                 mov     ebp, esp
.text$mn:00005517                 push    0FFFFFFFFh
.text$mn:00005519                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z
.text$mn:0000551E                 mov     eax, large fs:0
.text$mn:00005524                 push    eax
.text$mn:00005525                 push    ecx
.text$mn:00005526                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000552B                 xor     eax, ebp
.text$mn:0000552D                 push    eax
.text$mn:0000552E                 lea     eax, [ebp+var_C]
.text$mn:00005531                 mov     large fs:0, eax
.text$mn:00005537                 mov     [ebp+var_10], ecx
.text$mn:0000553A                 mov     ecx, [ebp+var_10]
.text$mn:0000553D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)
.text$mn:00005542                 mov     [ebp+var_4], 0
.text$mn:00005549                 mov     eax, [ebp+var_10]
.text$mn:0000554C                 mov     ecx, [ebp+arg_0]
.text$mn:0000554F                 mov     [eax+8], ecx
.text$mn:00005552                 mov     edx, [ebp+arg_4]
.text$mn:00005555                 push    edx             ; struct std::_Container_base12 *
.text$mn:00005556                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005559                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000555E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005565                 mov     eax, [ebp+var_10]
.text$mn:00005568                 mov     ecx, [ebp+var_C]
.text$mn:0000556B                 mov     large fs:0, ecx
.text$mn:00005572                 pop     ecx
.text$mn:00005573                 mov     esp, ebp
.text$mn:00005575                 pop     ebp
.text$mn:00005576                 retn    8
.text$mn:00005576 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z endp
.text$mn:00005576
.text$mn:00005576 ; ---------------------------------------------------------------------------
.text$mn:00005579                 align 4
.text$mn:00005579 _text$mn        ends
.text$mn:00005579
.text$x:0000557C ; ===========================================================================
.text$x:0000557C
.text$x:0000557C ; Segment type: Pure code
.text$x:0000557C ; Segment permissions: Read/Execute
.text$x:0000557C _text$x         segment para public 'CODE' use32
.text$x:0000557C                 assume cs:_text$x
.text$x:0000557C                 ;org 557Ch
.text$x:0000557C ; COMDAT (pick associative to section at 5514)
.text$x:0000557C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000557C
.text$x:0000557C ; =============== S U B R O U T I N E =======================================
.text$x:0000557C
.text$x:0000557C
.text$x:0000557C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z$0 proc near
.text$x:0000557C                                         ; DATA XREF: .xdata$x:0000D5C8o
.text$x:0000557C                 mov     ecx, [ebp-10h]
.text$x:0000557F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)
.text$x:0000557F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z$0 endp
.text$x:0000557F
.text$x:00005584
.text$x:00005584 ; =============== S U B R O U T I N E =======================================
.text$x:00005584
.text$x:00005584
.text$x:00005584 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z proc near
.text$x:00005584                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(KeyCombo *,std::_Container_base12 const *)+5o
.text$x:00005584
.text$x:00005584 arg_4           = dword ptr  8
.text$x:00005584
.text$x:00005584                 mov     edx, [esp+arg_4]
.text$x:00005588                 lea     eax, [edx+0Ch]
.text$x:0000558B                 mov     ecx, [edx-8]
.text$x:0000558E                 xor     ecx, eax
.text$x:00005590                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005595                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z
.text$x:0000559A                 jmp     ___CxxFrameHandler3
.text$x:0000559A __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z endp
.text$x:0000559A
.text$x:0000559A ; ---------------------------------------------------------------------------
.text$x:0000559F                 align 10h
.text$x:0000559F _text$x         ends
.text$x:0000559F
.text$mn:000055A0 ; ===========================================================================
.text$mn:000055A0
.text$mn:000055A0 ; Segment type: Pure code
.text$mn:000055A0 ; Segment permissions: Read/Execute
.text$mn:000055A0 _text$mn        segment para public 'CODE' use32
.text$mn:000055A0                 assume cs:_text$mn
.text$mn:000055A0                 ;org 55A0h
.text$mn:000055A0 ; COMDAT (pick any)
.text$mn:000055A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055A0
.text$mn:000055A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000055A0
.text$mn:000055A0 ; Attributes: bp-based frame
.text$mn:000055A0
.text$mn:000055A0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(struct std::_Iterator_base12 *)
.text$mn:000055A0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000055A0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000055A0                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)+4Fp
.text$mn:000055A0                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)+6Dp ...
.text$mn:000055A0
.text$mn:000055A0 var_10          = dword ptr -10h
.text$mn:000055A0 var_C           = dword ptr -0Ch
.text$mn:000055A0 var_4           = dword ptr -4
.text$mn:000055A0 arg_0           = dword ptr  8
.text$mn:000055A0
.text$mn:000055A0                 push    ebp
.text$mn:000055A1                 mov     ebp, esp
.text$mn:000055A3                 push    0FFFFFFFFh
.text$mn:000055A5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000055AA                 mov     eax, large fs:0
.text$mn:000055B0                 push    eax
.text$mn:000055B1                 push    ecx
.text$mn:000055B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055B7                 xor     eax, ebp
.text$mn:000055B9                 push    eax
.text$mn:000055BA                 lea     eax, [ebp+var_C]
.text$mn:000055BD                 mov     large fs:0, eax
.text$mn:000055C3                 mov     [ebp+var_10], ecx
.text$mn:000055C6                 mov     eax, [ebp+arg_0]
.text$mn:000055C9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000055CA                 mov     ecx, [ebp+var_10]
.text$mn:000055CD                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12> const &)
.text$mn:000055D2                 mov     [ebp+var_4], 0
.text$mn:000055D9                 mov     ecx, [ebp+var_10]
.text$mn:000055DC                 mov     edx, [ebp+arg_0]
.text$mn:000055DF                 mov     eax, [edx+8]
.text$mn:000055E2                 mov     [ecx+8], eax
.text$mn:000055E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055EC                 mov     eax, [ebp+var_10]
.text$mn:000055EF                 mov     ecx, [ebp+var_C]
.text$mn:000055F2                 mov     large fs:0, ecx
.text$mn:000055F9                 pop     ecx
.text$mn:000055FA                 mov     esp, ebp
.text$mn:000055FC                 pop     ebp
.text$mn:000055FD                 retn    4
.text$mn:000055FD ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000055FD
.text$mn:000055FD _text$mn        ends
.text$mn:000055FD
.text$x:00005600 ; ===========================================================================
.text$x:00005600
.text$x:00005600 ; Segment type: Pure code
.text$x:00005600 ; Segment permissions: Read/Execute
.text$x:00005600 _text$x         segment para public 'CODE' use32
.text$x:00005600                 assume cs:_text$x
.text$x:00005600                 ;org 5600h
.text$x:00005600 ; COMDAT (pick associative to section at 55A0)
.text$x:00005600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005600
.text$x:00005600 ; =============== S U B R O U T I N E =======================================
.text$x:00005600
.text$x:00005600
.text$x:00005600 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005600                                         ; DATA XREF: .xdata$x:0000E368o
.text$x:00005600                 mov     ecx, [ebp-10h]
.text$x:00005603                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)
.text$x:00005603 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005603
.text$x:00005608
.text$x:00005608 ; =============== S U B R O U T I N E =======================================
.text$x:00005608
.text$x:00005608
.text$x:00005608 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005608                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>> const &)+5o
.text$x:00005608
.text$x:00005608 arg_4           = dword ptr  8
.text$x:00005608
.text$x:00005608                 mov     edx, [esp+arg_4]
.text$x:0000560C                 lea     eax, [edx+0Ch]
.text$x:0000560F                 mov     ecx, [edx-8]
.text$x:00005612                 xor     ecx, eax
.text$x:00005614                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005619                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000561E                 jmp     ___CxxFrameHandler3
.text$x:0000561E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000561E
.text$x:0000561E ; ---------------------------------------------------------------------------
.text$x:00005623                 align 4
.text$x:00005623 _text$x         ends
.text$x:00005623
.text$mn:00005624 ; ===========================================================================
.text$mn:00005624
.text$mn:00005624 ; Segment type: Pure code
.text$mn:00005624 ; Segment permissions: Read/Execute
.text$mn:00005624 _text$mn        segment para public 'CODE' use32
.text$mn:00005624                 assume cs:_text$mn
.text$mn:00005624                 ;org 5624h
.text$mn:00005624 ; COMDAT (pick any)
.text$mn:00005624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005624
.text$mn:00005624 ; =============== S U B R O U T I N E =======================================
.text$mn:00005624
.text$mn:00005624 ; Attributes: bp-based frame
.text$mn:00005624
.text$mn:00005624 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(int, struct std::_Container_base12 *)
.text$mn:00005624                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z
.text$mn:00005624 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z proc near
.text$mn:00005624                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::begin(void)+3Dp
.text$mn:00005624                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::end(void)+3Dp
.text$mn:00005624
.text$mn:00005624 var_10          = dword ptr -10h
.text$mn:00005624 var_C           = dword ptr -0Ch
.text$mn:00005624 var_4           = dword ptr -4
.text$mn:00005624 arg_0           = dword ptr  8
.text$mn:00005624 arg_4           = dword ptr  0Ch
.text$mn:00005624
.text$mn:00005624                 push    ebp
.text$mn:00005625                 mov     ebp, esp
.text$mn:00005627                 push    0FFFFFFFFh
.text$mn:00005629                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z
.text$mn:0000562E                 mov     eax, large fs:0
.text$mn:00005634                 push    eax
.text$mn:00005635                 push    ecx
.text$mn:00005636                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000563B                 xor     eax, ebp
.text$mn:0000563D                 push    eax
.text$mn:0000563E                 lea     eax, [ebp+var_C]
.text$mn:00005641                 mov     large fs:0, eax
.text$mn:00005647                 mov     [ebp+var_10], ecx
.text$mn:0000564A                 mov     ecx, [ebp+var_10]
.text$mn:0000564D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)
.text$mn:00005652                 mov     [ebp+var_4], 0
.text$mn:00005659                 mov     eax, [ebp+var_10]
.text$mn:0000565C                 mov     ecx, [ebp+arg_0]
.text$mn:0000565F                 mov     [eax+8], ecx
.text$mn:00005662                 mov     edx, [ebp+arg_4]
.text$mn:00005665                 push    edx             ; struct std::_Container_base12 *
.text$mn:00005666                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005669                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000566E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005675                 mov     eax, [ebp+var_10]
.text$mn:00005678                 mov     ecx, [ebp+var_C]
.text$mn:0000567B                 mov     large fs:0, ecx
.text$mn:00005682                 pop     ecx
.text$mn:00005683                 mov     esp, ebp
.text$mn:00005685                 pop     ebp
.text$mn:00005686                 retn    8
.text$mn:00005686 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z endp
.text$mn:00005686
.text$mn:00005686 ; ---------------------------------------------------------------------------
.text$mn:00005689                 align 4
.text$mn:00005689 _text$mn        ends
.text$mn:00005689
.text$x:0000568C ; ===========================================================================
.text$x:0000568C
.text$x:0000568C ; Segment type: Pure code
.text$x:0000568C ; Segment permissions: Read/Execute
.text$x:0000568C _text$x         segment para public 'CODE' use32
.text$x:0000568C                 assume cs:_text$x
.text$x:0000568C                 ;org 568Ch
.text$x:0000568C ; COMDAT (pick associative to section at 5624)
.text$x:0000568C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000568C
.text$x:0000568C ; =============== S U B R O U T I N E =======================================
.text$x:0000568C
.text$x:0000568C
.text$x:0000568C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z$0 proc near
.text$x:0000568C                                         ; DATA XREF: .xdata$x:0000E310o
.text$x:0000568C                 mov     ecx, [ebp-10h]
.text$x:0000568F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)
.text$x:0000568F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z$0 endp
.text$x:0000568F
.text$x:00005694
.text$x:00005694 ; =============== S U B R O U T I N E =======================================
.text$x:00005694
.text$x:00005694
.text$x:00005694 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z proc near
.text$x:00005694                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(recordedMacroStep *,std::_Container_base12 const *)+5o
.text$x:00005694
.text$x:00005694 arg_4           = dword ptr  8
.text$x:00005694
.text$x:00005694                 mov     edx, [esp+arg_4]
.text$x:00005698                 lea     eax, [edx+0Ch]
.text$x:0000569B                 mov     ecx, [edx-8]
.text$x:0000569E                 xor     ecx, eax
.text$x:000056A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000056A5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z
.text$x:000056AA                 jmp     ___CxxFrameHandler3
.text$x:000056AA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z endp
.text$x:000056AA
.text$x:000056AA ; ---------------------------------------------------------------------------
.text$x:000056AF                 align 10h
.text$x:000056AF _text$x         ends
.text$x:000056AF
.text$mn:000056B0 ; ===========================================================================
.text$mn:000056B0
.text$mn:000056B0 ; Segment type: Pure code
.text$mn:000056B0 ; Segment permissions: Read/Execute
.text$mn:000056B0 _text$mn        segment para public 'CODE' use32
.text$mn:000056B0                 assume cs:_text$mn
.text$mn:000056B0                 ;org 56B0h
.text$mn:000056B0 ; COMDAT (pick any)
.text$mn:000056B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056B0
.text$mn:000056B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000056B0
.text$mn:000056B0 ; Attributes: bp-based frame
.text$mn:000056B0
.text$mn:000056B0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(struct std::_Iterator_base12 *)
.text$mn:000056B0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000056B0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000056B0                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+B58p
.text$mn:000056B0                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)+2Dp ...
.text$mn:000056B0
.text$mn:000056B0 var_10          = dword ptr -10h
.text$mn:000056B0 var_C           = dword ptr -0Ch
.text$mn:000056B0 var_4           = dword ptr -4
.text$mn:000056B0 arg_0           = dword ptr  8
.text$mn:000056B0
.text$mn:000056B0                 push    ebp
.text$mn:000056B1                 mov     ebp, esp
.text$mn:000056B3                 push    0FFFFFFFFh
.text$mn:000056B5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000056BA                 mov     eax, large fs:0
.text$mn:000056C0                 push    eax
.text$mn:000056C1                 push    ecx
.text$mn:000056C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000056C7                 xor     eax, ebp
.text$mn:000056C9                 push    eax
.text$mn:000056CA                 lea     eax, [ebp+var_C]
.text$mn:000056CD                 mov     large fs:0, eax
.text$mn:000056D3                 mov     [ebp+var_10], ecx
.text$mn:000056D6                 mov     eax, [ebp+arg_0]
.text$mn:000056D9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000056DA                 mov     ecx, [ebp+var_10]
.text$mn:000056DD                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12> const &)
.text$mn:000056E2                 mov     [ebp+var_4], 0
.text$mn:000056E9                 mov     ecx, [ebp+var_10]
.text$mn:000056EC                 mov     edx, [ebp+arg_0]
.text$mn:000056EF                 mov     eax, [edx+8]
.text$mn:000056F2                 mov     [ecx+8], eax
.text$mn:000056F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056FC                 mov     eax, [ebp+var_10]
.text$mn:000056FF                 mov     ecx, [ebp+var_C]
.text$mn:00005702                 mov     large fs:0, ecx
.text$mn:00005709                 pop     ecx
.text$mn:0000570A                 mov     esp, ebp
.text$mn:0000570C                 pop     ebp
.text$mn:0000570D                 retn    4
.text$mn:0000570D ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000570D
.text$mn:0000570D _text$mn        ends
.text$mn:0000570D
.text$x:00005710 ; ===========================================================================
.text$x:00005710
.text$x:00005710 ; Segment type: Pure code
.text$x:00005710 ; Segment permissions: Read/Execute
.text$x:00005710 _text$x         segment para public 'CODE' use32
.text$x:00005710                 assume cs:_text$x
.text$x:00005710                 ;org 5710h
.text$x:00005710 ; COMDAT (pick associative to section at 56B0)
.text$x:00005710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005710
.text$x:00005710 ; =============== S U B R O U T I N E =======================================
.text$x:00005710
.text$x:00005710
.text$x:00005710 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005710                                         ; DATA XREF: .xdata$x:0000DFA4o
.text$x:00005710                 mov     ecx, [ebp-10h]
.text$x:00005713                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(void)
.text$x:00005713 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005713
.text$x:00005718
.text$x:00005718 ; =============== S U B R O U T I N E =======================================
.text$x:00005718
.text$x:00005718
.text$x:00005718 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005718                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)+5o
.text$x:00005718
.text$x:00005718 arg_4           = dword ptr  8
.text$x:00005718
.text$x:00005718                 mov     edx, [esp+arg_4]
.text$x:0000571C                 lea     eax, [edx+0Ch]
.text$x:0000571F                 mov     ecx, [edx-8]
.text$x:00005722                 xor     ecx, eax
.text$x:00005724                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005729                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000572E                 jmp     ___CxxFrameHandler3
.text$x:0000572E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000572E
.text$x:0000572E ; ---------------------------------------------------------------------------
.text$x:00005733                 align 4
.text$x:00005733 _text$x         ends
.text$x:00005733
.text$mn:00005734 ; ===========================================================================
.text$mn:00005734
.text$mn:00005734 ; Segment type: Pure code
.text$mn:00005734 ; Segment permissions: Read/Execute
.text$mn:00005734 _text$mn        segment para public 'CODE' use32
.text$mn:00005734                 assume cs:_text$mn
.text$mn:00005734                 ;org 5734h
.text$mn:00005734 ; COMDAT (pick any)
.text$mn:00005734                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005734
.text$mn:00005734 ; =============== S U B R O U T I N E =======================================
.text$mn:00005734
.text$mn:00005734 ; Attributes: bp-based frame
.text$mn:00005734
.text$mn:00005734 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(int, struct std::_Container_base12 *)
.text$mn:00005734                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.text$mn:00005734 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z proc near
.text$mn:00005734                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(MacroShortcut *,std::_Container_base12 const *)+31p
.text$mn:00005734
.text$mn:00005734 var_10          = dword ptr -10h
.text$mn:00005734 var_C           = dword ptr -0Ch
.text$mn:00005734 var_4           = dword ptr -4
.text$mn:00005734 arg_0           = dword ptr  8
.text$mn:00005734 arg_4           = dword ptr  0Ch
.text$mn:00005734
.text$mn:00005734                 push    ebp
.text$mn:00005735                 mov     ebp, esp
.text$mn:00005737                 push    0FFFFFFFFh
.text$mn:00005739                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.text$mn:0000573E                 mov     eax, large fs:0
.text$mn:00005744                 push    eax
.text$mn:00005745                 push    ecx
.text$mn:00005746                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000574B                 xor     eax, ebp
.text$mn:0000574D                 push    eax
.text$mn:0000574E                 lea     eax, [ebp+var_C]
.text$mn:00005751                 mov     large fs:0, eax
.text$mn:00005757                 mov     [ebp+var_10], ecx
.text$mn:0000575A                 mov     ecx, [ebp+var_10]
.text$mn:0000575D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(void)
.text$mn:00005762                 mov     [ebp+var_4], 0
.text$mn:00005769                 mov     eax, [ebp+var_10]
.text$mn:0000576C                 mov     ecx, [ebp+arg_0]
.text$mn:0000576F                 mov     [eax+8], ecx
.text$mn:00005772                 mov     edx, [ebp+arg_4]
.text$mn:00005775                 push    edx             ; struct std::_Container_base12 *
.text$mn:00005776                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005779                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000577E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005785                 mov     eax, [ebp+var_10]
.text$mn:00005788                 mov     ecx, [ebp+var_C]
.text$mn:0000578B                 mov     large fs:0, ecx
.text$mn:00005792                 pop     ecx
.text$mn:00005793                 mov     esp, ebp
.text$mn:00005795                 pop     ebp
.text$mn:00005796                 retn    8
.text$mn:00005796 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z endp
.text$mn:00005796
.text$mn:00005796 ; ---------------------------------------------------------------------------
.text$mn:00005799                 align 4
.text$mn:00005799 _text$mn        ends
.text$mn:00005799
.text$x:0000579C ; ===========================================================================
.text$x:0000579C
.text$x:0000579C ; Segment type: Pure code
.text$x:0000579C ; Segment permissions: Read/Execute
.text$x:0000579C _text$x         segment para public 'CODE' use32
.text$x:0000579C                 assume cs:_text$x
.text$x:0000579C                 ;org 579Ch
.text$x:0000579C ; COMDAT (pick associative to section at 5734)
.text$x:0000579C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000579C
.text$x:0000579C ; =============== S U B R O U T I N E =======================================
.text$x:0000579C
.text$x:0000579C
.text$x:0000579C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z$0 proc near
.text$x:0000579C                                         ; DATA XREF: .xdata$x:0000DF4Co
.text$x:0000579C                 mov     ecx, [ebp-10h]
.text$x:0000579F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(void)
.text$x:0000579F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z$0 endp
.text$x:0000579F
.text$x:000057A4
.text$x:000057A4 ; =============== S U B R O U T I N E =======================================
.text$x:000057A4
.text$x:000057A4
.text$x:000057A4 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z proc near
.text$x:000057A4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(MacroShortcut *,std::_Container_base12 const *)+5o
.text$x:000057A4
.text$x:000057A4 arg_4           = dword ptr  8
.text$x:000057A4
.text$x:000057A4                 mov     edx, [esp+arg_4]
.text$x:000057A8                 lea     eax, [edx+0Ch]
.text$x:000057AB                 mov     ecx, [edx-8]
.text$x:000057AE                 xor     ecx, eax
.text$x:000057B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000057B5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.text$x:000057BA                 jmp     ___CxxFrameHandler3
.text$x:000057BA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z endp
.text$x:000057BA
.text$x:000057BA ; ---------------------------------------------------------------------------
.text$x:000057BF                 align 10h
.text$x:000057BF _text$x         ends
.text$x:000057BF
.text$mn:000057C0 ; ===========================================================================
.text$mn:000057C0
.text$mn:000057C0 ; Segment type: Pure code
.text$mn:000057C0 ; Segment permissions: Read/Execute
.text$mn:000057C0 _text$mn        segment para public 'CODE' use32
.text$mn:000057C0                 assume cs:_text$mn
.text$mn:000057C0                 ;org 57C0h
.text$mn:000057C0 ; COMDAT (pick any)
.text$mn:000057C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057C0
.text$mn:000057C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000057C0
.text$mn:000057C0 ; Attributes: bp-based frame
.text$mn:000057C0
.text$mn:000057C0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(struct std::_Iterator_base12 *)
.text$mn:000057C0                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000057C0 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000057C0                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+D37p
.text$mn:000057C0                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)+2Dp ...
.text$mn:000057C0
.text$mn:000057C0 var_10          = dword ptr -10h
.text$mn:000057C0 var_C           = dword ptr -0Ch
.text$mn:000057C0 var_4           = dword ptr -4
.text$mn:000057C0 arg_0           = dword ptr  8
.text$mn:000057C0
.text$mn:000057C0                 push    ebp
.text$mn:000057C1                 mov     ebp, esp
.text$mn:000057C3                 push    0FFFFFFFFh
.text$mn:000057C5                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000057CA                 mov     eax, large fs:0
.text$mn:000057D0                 push    eax
.text$mn:000057D1                 push    ecx
.text$mn:000057D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000057D7                 xor     eax, ebp
.text$mn:000057D9                 push    eax
.text$mn:000057DA                 lea     eax, [ebp+var_C]
.text$mn:000057DD                 mov     large fs:0, eax
.text$mn:000057E3                 mov     [ebp+var_10], ecx
.text$mn:000057E6                 mov     eax, [ebp+arg_0]
.text$mn:000057E9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000057EA                 mov     ecx, [ebp+var_10]
.text$mn:000057ED                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12> const &)
.text$mn:000057F2                 mov     [ebp+var_4], 0
.text$mn:000057F9                 mov     ecx, [ebp+var_10]
.text$mn:000057FC                 mov     edx, [ebp+arg_0]
.text$mn:000057FF                 mov     eax, [edx+8]
.text$mn:00005802                 mov     [ecx+8], eax
.text$mn:00005805                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000580C                 mov     eax, [ebp+var_10]
.text$mn:0000580F                 mov     ecx, [ebp+var_C]
.text$mn:00005812                 mov     large fs:0, ecx
.text$mn:00005819                 pop     ecx
.text$mn:0000581A                 mov     esp, ebp
.text$mn:0000581C                 pop     ebp
.text$mn:0000581D                 retn    4
.text$mn:0000581D ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000581D
.text$mn:0000581D _text$mn        ends
.text$mn:0000581D
.text$x:00005820 ; ===========================================================================
.text$x:00005820
.text$x:00005820 ; Segment type: Pure code
.text$x:00005820 ; Segment permissions: Read/Execute
.text$x:00005820 _text$x         segment para public 'CODE' use32
.text$x:00005820                 assume cs:_text$x
.text$x:00005820                 ;org 5820h
.text$x:00005820 ; COMDAT (pick associative to section at 57C0)
.text$x:00005820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005820
.text$x:00005820 ; =============== S U B R O U T I N E =======================================
.text$x:00005820
.text$x:00005820
.text$x:00005820 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005820                                         ; DATA XREF: .xdata$x:0000E164o
.text$x:00005820                 mov     ecx, [ebp-10h]
.text$x:00005823                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(void)
.text$x:00005823 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005823
.text$x:00005828
.text$x:00005828 ; =============== S U B R O U T I N E =======================================
.text$x:00005828
.text$x:00005828
.text$x:00005828 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005828                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)+5o
.text$x:00005828
.text$x:00005828 arg_4           = dword ptr  8
.text$x:00005828
.text$x:00005828                 mov     edx, [esp+arg_4]
.text$x:0000582C                 lea     eax, [edx+0Ch]
.text$x:0000582F                 mov     ecx, [edx-8]
.text$x:00005832                 xor     ecx, eax
.text$x:00005834                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005839                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000583E                 jmp     ___CxxFrameHandler3
.text$x:0000583E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000583E
.text$x:0000583E ; ---------------------------------------------------------------------------
.text$x:00005843                 align 4
.text$x:00005843 _text$x         ends
.text$x:00005843
.text$mn:00005844 ; ===========================================================================
.text$mn:00005844
.text$mn:00005844 ; Segment type: Pure code
.text$mn:00005844 ; Segment permissions: Read/Execute
.text$mn:00005844 _text$mn        segment para public 'CODE' use32
.text$mn:00005844                 assume cs:_text$mn
.text$mn:00005844                 ;org 5844h
.text$mn:00005844 ; COMDAT (pick any)
.text$mn:00005844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005844
.text$mn:00005844 ; =============== S U B R O U T I N E =======================================
.text$mn:00005844
.text$mn:00005844 ; Attributes: bp-based frame
.text$mn:00005844
.text$mn:00005844 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(int, struct std::_Container_base12 *)
.text$mn:00005844                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.text$mn:00005844 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z proc near
.text$mn:00005844                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(UserCommand *,std::_Container_base12 const *)+31p
.text$mn:00005844
.text$mn:00005844 var_10          = dword ptr -10h
.text$mn:00005844 var_C           = dword ptr -0Ch
.text$mn:00005844 var_4           = dword ptr -4
.text$mn:00005844 arg_0           = dword ptr  8
.text$mn:00005844 arg_4           = dword ptr  0Ch
.text$mn:00005844
.text$mn:00005844                 push    ebp
.text$mn:00005845                 mov     ebp, esp
.text$mn:00005847                 push    0FFFFFFFFh
.text$mn:00005849                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.text$mn:0000584E                 mov     eax, large fs:0
.text$mn:00005854                 push    eax
.text$mn:00005855                 push    ecx
.text$mn:00005856                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000585B                 xor     eax, ebp
.text$mn:0000585D                 push    eax
.text$mn:0000585E                 lea     eax, [ebp+var_C]
.text$mn:00005861                 mov     large fs:0, eax
.text$mn:00005867                 mov     [ebp+var_10], ecx
.text$mn:0000586A                 mov     ecx, [ebp+var_10]
.text$mn:0000586D                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(void)
.text$mn:00005872                 mov     [ebp+var_4], 0
.text$mn:00005879                 mov     eax, [ebp+var_10]
.text$mn:0000587C                 mov     ecx, [ebp+arg_0]
.text$mn:0000587F                 mov     [eax+8], ecx
.text$mn:00005882                 mov     edx, [ebp+arg_4]
.text$mn:00005885                 push    edx             ; struct std::_Container_base12 *
.text$mn:00005886                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005889                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000588E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005895                 mov     eax, [ebp+var_10]
.text$mn:00005898                 mov     ecx, [ebp+var_C]
.text$mn:0000589B                 mov     large fs:0, ecx
.text$mn:000058A2                 pop     ecx
.text$mn:000058A3                 mov     esp, ebp
.text$mn:000058A5                 pop     ebp
.text$mn:000058A6                 retn    8
.text$mn:000058A6 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z endp
.text$mn:000058A6
.text$mn:000058A6 ; ---------------------------------------------------------------------------
.text$mn:000058A9                 align 4
.text$mn:000058A9 _text$mn        ends
.text$mn:000058A9
.text$x:000058AC ; ===========================================================================
.text$x:000058AC
.text$x:000058AC ; Segment type: Pure code
.text$x:000058AC ; Segment permissions: Read/Execute
.text$x:000058AC _text$x         segment para public 'CODE' use32
.text$x:000058AC                 assume cs:_text$x
.text$x:000058AC                 ;org 58ACh
.text$x:000058AC ; COMDAT (pick associative to section at 5844)
.text$x:000058AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000058AC
.text$x:000058AC ; =============== S U B R O U T I N E =======================================
.text$x:000058AC
.text$x:000058AC
.text$x:000058AC __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z$0 proc near
.text$x:000058AC                                         ; DATA XREF: .xdata$x:0000E10Co
.text$x:000058AC                 mov     ecx, [ebp-10h]
.text$x:000058AF                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(void)
.text$x:000058AF __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z$0 endp
.text$x:000058AF
.text$x:000058B4
.text$x:000058B4 ; =============== S U B R O U T I N E =======================================
.text$x:000058B4
.text$x:000058B4
.text$x:000058B4 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z proc near
.text$x:000058B4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(UserCommand *,std::_Container_base12 const *)+5o
.text$x:000058B4
.text$x:000058B4 arg_4           = dword ptr  8
.text$x:000058B4
.text$x:000058B4                 mov     edx, [esp+arg_4]
.text$x:000058B8                 lea     eax, [edx+0Ch]
.text$x:000058BB                 mov     ecx, [edx-8]
.text$x:000058BE                 xor     ecx, eax
.text$x:000058C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000058C5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.text$x:000058CA                 jmp     ___CxxFrameHandler3
.text$x:000058CA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z endp
.text$x:000058CA
.text$x:000058CA ; ---------------------------------------------------------------------------
.text$x:000058CF                 align 10h
.text$x:000058CF _text$x         ends
.text$x:000058CF
.text$mn:000058D0 ; ===========================================================================
.text$mn:000058D0
.text$mn:000058D0 ; Segment type: Pure code
.text$mn:000058D0 ; Segment permissions: Read/Execute
.text$mn:000058D0 _text$mn        segment para public 'CODE' use32
.text$mn:000058D0                 assume cs:_text$mn
.text$mn:000058D0                 ;org 58D0h
.text$mn:000058D0 ; COMDAT (pick any)
.text$mn:000058D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000058D0
.text$mn:000058D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000058D0
.text$mn:000058D0 ; Attributes: bp-based frame
.text$mn:000058D0
.text$mn:000058D0 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(struct std::_Iterator_base12 *)
.text$mn:000058D0                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000058D0 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000058D0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+(int)+36p
.text$mn:000058D0                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+(int)+52p
.text$mn:000058D0
.text$mn:000058D0 var_10          = dword ptr -10h
.text$mn:000058D0 var_C           = dword ptr -0Ch
.text$mn:000058D0 var_4           = dword ptr -4
.text$mn:000058D0 arg_0           = dword ptr  8
.text$mn:000058D0
.text$mn:000058D0                 push    ebp
.text$mn:000058D1                 mov     ebp, esp
.text$mn:000058D3                 push    0FFFFFFFFh
.text$mn:000058D5                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000058DA                 mov     eax, large fs:0
.text$mn:000058E0                 push    eax
.text$mn:000058E1                 push    ecx
.text$mn:000058E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000058E7                 xor     eax, ebp
.text$mn:000058E9                 push    eax
.text$mn:000058EA                 lea     eax, [ebp+var_C]
.text$mn:000058ED                 mov     large fs:0, eax
.text$mn:000058F3                 mov     [ebp+var_10], ecx
.text$mn:000058F6                 mov     eax, [ebp+arg_0]
.text$mn:000058F9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000058FA                 mov     ecx, [ebp+var_10]
.text$mn:000058FD                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)
.text$mn:00005902                 mov     [ebp+var_4], 0
.text$mn:00005909                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005910                 mov     eax, [ebp+var_10]
.text$mn:00005913                 mov     ecx, [ebp+var_C]
.text$mn:00005916                 mov     large fs:0, ecx
.text$mn:0000591D                 pop     ecx
.text$mn:0000591E                 mov     esp, ebp
.text$mn:00005920                 pop     ebp
.text$mn:00005921                 retn    4
.text$mn:00005921 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005921
.text$mn:00005921 _text$mn        ends
.text$mn:00005921
.text$x:00005924 ; ===========================================================================
.text$x:00005924
.text$x:00005924 ; Segment type: Pure code
.text$x:00005924 ; Segment permissions: Read/Execute
.text$x:00005924 _text$x         segment para public 'CODE' use32
.text$x:00005924                 assume cs:_text$x
.text$x:00005924                 ;org 5924h
.text$x:00005924 ; COMDAT (pick associative to section at 58D0)
.text$x:00005924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005924
.text$x:00005924 ; =============== S U B R O U T I N E =======================================
.text$x:00005924
.text$x:00005924
.text$x:00005924 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005924                                         ; DATA XREF: .xdata$x:0000E05Co
.text$x:00005924                 mov     ecx, [ebp-10h]
.text$x:00005927                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:00005927 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005927
.text$x:0000592C
.text$x:0000592C ; =============== S U B R O U T I N E =======================================
.text$x:0000592C
.text$x:0000592C
.text$x:0000592C __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000592C                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)+5o
.text$x:0000592C
.text$x:0000592C arg_4           = dword ptr  8
.text$x:0000592C
.text$x:0000592C                 mov     edx, [esp+arg_4]
.text$x:00005930                 lea     eax, [edx+0Ch]
.text$x:00005933                 mov     ecx, [edx-8]
.text$x:00005936                 xor     ecx, eax
.text$x:00005938                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000593D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005942                 jmp     ___CxxFrameHandler3
.text$x:00005942 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005942
.text$x:00005942 ; ---------------------------------------------------------------------------
.text$x:00005947                 align 4
.text$x:00005947 _text$x         ends
.text$x:00005947
.text$mn:00005948 ; ===========================================================================
.text$mn:00005948
.text$mn:00005948 ; Segment type: Pure code
.text$mn:00005948 ; Segment permissions: Read/Execute
.text$mn:00005948 _text$mn        segment para public 'CODE' use32
.text$mn:00005948                 assume cs:_text$mn
.text$mn:00005948                 ;org 5948h
.text$mn:00005948 ; COMDAT (pick any)
.text$mn:00005948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005948
.text$mn:00005948 ; =============== S U B R O U T I N E =======================================
.text$mn:00005948
.text$mn:00005948 ; Attributes: bp-based frame
.text$mn:00005948
.text$mn:00005948 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(int, struct std::_Container_base12 *)
.text$mn:00005948                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.text$mn:00005948 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z proc near
.text$mn:00005948                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+41p
.text$mn:00005948                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::begin(void)+3Dp
.text$mn:00005948
.text$mn:00005948 var_10          = dword ptr -10h
.text$mn:00005948 var_C           = dword ptr -0Ch
.text$mn:00005948 var_4           = dword ptr -4
.text$mn:00005948 arg_0           = dword ptr  8
.text$mn:00005948 arg_4           = dword ptr  0Ch
.text$mn:00005948
.text$mn:00005948                 push    ebp
.text$mn:00005949                 mov     ebp, esp
.text$mn:0000594B                 push    0FFFFFFFFh
.text$mn:0000594D                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.text$mn:00005952                 mov     eax, large fs:0
.text$mn:00005958                 push    eax
.text$mn:00005959                 push    ecx
.text$mn:0000595A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000595F                 xor     eax, ebp
.text$mn:00005961                 push    eax
.text$mn:00005962                 lea     eax, [ebp+var_C]
.text$mn:00005965                 mov     large fs:0, eax
.text$mn:0000596B                 mov     [ebp+var_10], ecx
.text$mn:0000596E                 mov     eax, [ebp+arg_4]
.text$mn:00005971                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005972                 mov     ecx, [ebp+arg_0]
.text$mn:00005975                 push    ecx             ; int
.text$mn:00005976                 mov     ecx, [ebp+var_10]
.text$mn:00005979                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(MacroShortcut *,std::_Container_base12 const *)
.text$mn:0000597E                 mov     [ebp+var_4], 0
.text$mn:00005985                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000598C                 mov     eax, [ebp+var_10]
.text$mn:0000598F                 mov     ecx, [ebp+var_C]
.text$mn:00005992                 mov     large fs:0, ecx
.text$mn:00005999                 pop     ecx
.text$mn:0000599A                 mov     esp, ebp
.text$mn:0000599C                 pop     ebp
.text$mn:0000599D                 retn    8
.text$mn:0000599D ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z endp
.text$mn:0000599D
.text$mn:0000599D _text$mn        ends
.text$mn:0000599D
.text$x:000059A0 ; ===========================================================================
.text$x:000059A0
.text$x:000059A0 ; Segment type: Pure code
.text$x:000059A0 ; Segment permissions: Read/Execute
.text$x:000059A0 _text$x         segment para public 'CODE' use32
.text$x:000059A0                 assume cs:_text$x
.text$x:000059A0                 ;org 59A0h
.text$x:000059A0 ; COMDAT (pick associative to section at 5948)
.text$x:000059A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000059A0
.text$x:000059A0 ; =============== S U B R O U T I N E =======================================
.text$x:000059A0
.text$x:000059A0
.text$x:000059A0 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z$0 proc near
.text$x:000059A0                                         ; DATA XREF: .xdata$x:0000DFD0o
.text$x:000059A0                 mov     ecx, [ebp-10h]
.text$x:000059A3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:000059A3 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z$0 endp
.text$x:000059A3
.text$x:000059A8
.text$x:000059A8 ; =============== S U B R O U T I N E =======================================
.text$x:000059A8
.text$x:000059A8
.text$x:000059A8 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z proc near
.text$x:000059A8                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(MacroShortcut *,std::_Container_base12 const *)+5o
.text$x:000059A8
.text$x:000059A8 arg_4           = dword ptr  8
.text$x:000059A8
.text$x:000059A8                 mov     edx, [esp+arg_4]
.text$x:000059AC                 lea     eax, [edx+0Ch]
.text$x:000059AF                 mov     ecx, [edx-8]
.text$x:000059B2                 xor     ecx, eax
.text$x:000059B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000059B9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.text$x:000059BE                 jmp     ___CxxFrameHandler3
.text$x:000059BE __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z endp
.text$x:000059BE
.text$x:000059BE ; ---------------------------------------------------------------------------
.text$x:000059C3                 align 4
.text$x:000059C3 _text$x         ends
.text$x:000059C3
.text$mn:000059C4 ; ===========================================================================
.text$mn:000059C4
.text$mn:000059C4 ; Segment type: Pure code
.text$mn:000059C4 ; Segment permissions: Read/Execute
.text$mn:000059C4 _text$mn        segment para public 'CODE' use32
.text$mn:000059C4                 assume cs:_text$mn
.text$mn:000059C4                 ;org 59C4h
.text$mn:000059C4 ; COMDAT (pick any)
.text$mn:000059C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000059C4
.text$mn:000059C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000059C4
.text$mn:000059C4 ; Attributes: bp-based frame
.text$mn:000059C4
.text$mn:000059C4 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(struct std::_Iterator_base12 *)
.text$mn:000059C4                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000059C4 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000059C4                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+(int)+36p
.text$mn:000059C4                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+(int)+52p
.text$mn:000059C4
.text$mn:000059C4 var_10          = dword ptr -10h
.text$mn:000059C4 var_C           = dword ptr -0Ch
.text$mn:000059C4 var_4           = dword ptr -4
.text$mn:000059C4 arg_0           = dword ptr  8
.text$mn:000059C4
.text$mn:000059C4                 push    ebp
.text$mn:000059C5                 mov     ebp, esp
.text$mn:000059C7                 push    0FFFFFFFFh
.text$mn:000059C9                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000059CE                 mov     eax, large fs:0
.text$mn:000059D4                 push    eax
.text$mn:000059D5                 push    ecx
.text$mn:000059D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000059DB                 xor     eax, ebp
.text$mn:000059DD                 push    eax
.text$mn:000059DE                 lea     eax, [ebp+var_C]
.text$mn:000059E1                 mov     large fs:0, eax
.text$mn:000059E7                 mov     [ebp+var_10], ecx
.text$mn:000059EA                 mov     eax, [ebp+arg_0]
.text$mn:000059ED                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000059EE                 mov     ecx, [ebp+var_10]
.text$mn:000059F1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)
.text$mn:000059F6                 mov     [ebp+var_4], 0
.text$mn:000059FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005A04                 mov     eax, [ebp+var_10]
.text$mn:00005A07                 mov     ecx, [ebp+var_C]
.text$mn:00005A0A                 mov     large fs:0, ecx
.text$mn:00005A11                 pop     ecx
.text$mn:00005A12                 mov     esp, ebp
.text$mn:00005A14                 pop     ebp
.text$mn:00005A15                 retn    4
.text$mn:00005A15 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005A15
.text$mn:00005A15 _text$mn        ends
.text$mn:00005A15
.text$x:00005A18 ; ===========================================================================
.text$x:00005A18
.text$x:00005A18 ; Segment type: Pure code
.text$x:00005A18 ; Segment permissions: Read/Execute
.text$x:00005A18 _text$x         segment para public 'CODE' use32
.text$x:00005A18                 assume cs:_text$x
.text$x:00005A18                 ;org 5A18h
.text$x:00005A18 ; COMDAT (pick associative to section at 59C4)
.text$x:00005A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005A18
.text$x:00005A18 ; =============== S U B R O U T I N E =======================================
.text$x:00005A18
.text$x:00005A18
.text$x:00005A18 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005A18                                         ; DATA XREF: .xdata$x:0000E21Co
.text$x:00005A18                 mov     ecx, [ebp-10h]
.text$x:00005A1B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:00005A1B __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005A1B
.text$x:00005A20
.text$x:00005A20 ; =============== S U B R O U T I N E =======================================
.text$x:00005A20
.text$x:00005A20
.text$x:00005A20 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005A20                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)+5o
.text$x:00005A20
.text$x:00005A20 arg_4           = dword ptr  8
.text$x:00005A20
.text$x:00005A20                 mov     edx, [esp+arg_4]
.text$x:00005A24                 lea     eax, [edx+0Ch]
.text$x:00005A27                 mov     ecx, [edx-8]
.text$x:00005A2A                 xor     ecx, eax
.text$x:00005A2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A31                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005A36                 jmp     ___CxxFrameHandler3
.text$x:00005A36 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005A36
.text$x:00005A36 ; ---------------------------------------------------------------------------
.text$x:00005A3B                 align 4
.text$x:00005A3B _text$x         ends
.text$x:00005A3B
.text$mn:00005A3C ; ===========================================================================
.text$mn:00005A3C
.text$mn:00005A3C ; Segment type: Pure code
.text$mn:00005A3C ; Segment permissions: Read/Execute
.text$mn:00005A3C _text$mn        segment para public 'CODE' use32
.text$mn:00005A3C                 assume cs:_text$mn
.text$mn:00005A3C                 ;org 5A3Ch
.text$mn:00005A3C ; COMDAT (pick any)
.text$mn:00005A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A3C
.text$mn:00005A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00005A3C
.text$mn:00005A3C ; Attributes: bp-based frame
.text$mn:00005A3C
.text$mn:00005A3C ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(int, struct std::_Container_base12 *)
.text$mn:00005A3C                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.text$mn:00005A3C ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z proc near
.text$mn:00005A3C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+41p
.text$mn:00005A3C                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::begin(void)+3Dp
.text$mn:00005A3C
.text$mn:00005A3C var_10          = dword ptr -10h
.text$mn:00005A3C var_C           = dword ptr -0Ch
.text$mn:00005A3C var_4           = dword ptr -4
.text$mn:00005A3C arg_0           = dword ptr  8
.text$mn:00005A3C arg_4           = dword ptr  0Ch
.text$mn:00005A3C
.text$mn:00005A3C                 push    ebp
.text$mn:00005A3D                 mov     ebp, esp
.text$mn:00005A3F                 push    0FFFFFFFFh
.text$mn:00005A41                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.text$mn:00005A46                 mov     eax, large fs:0
.text$mn:00005A4C                 push    eax
.text$mn:00005A4D                 push    ecx
.text$mn:00005A4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005A53                 xor     eax, ebp
.text$mn:00005A55                 push    eax
.text$mn:00005A56                 lea     eax, [ebp+var_C]
.text$mn:00005A59                 mov     large fs:0, eax
.text$mn:00005A5F                 mov     [ebp+var_10], ecx
.text$mn:00005A62                 mov     eax, [ebp+arg_4]
.text$mn:00005A65                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005A66                 mov     ecx, [ebp+arg_0]
.text$mn:00005A69                 push    ecx             ; int
.text$mn:00005A6A                 mov     ecx, [ebp+var_10]
.text$mn:00005A6D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(UserCommand *,std::_Container_base12 const *)
.text$mn:00005A72                 mov     [ebp+var_4], 0
.text$mn:00005A79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005A80                 mov     eax, [ebp+var_10]
.text$mn:00005A83                 mov     ecx, [ebp+var_C]
.text$mn:00005A86                 mov     large fs:0, ecx
.text$mn:00005A8D                 pop     ecx
.text$mn:00005A8E                 mov     esp, ebp
.text$mn:00005A90                 pop     ebp
.text$mn:00005A91                 retn    8
.text$mn:00005A91 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z endp
.text$mn:00005A91
.text$mn:00005A91 _text$mn        ends
.text$mn:00005A91
.text$x:00005A94 ; ===========================================================================
.text$x:00005A94
.text$x:00005A94 ; Segment type: Pure code
.text$x:00005A94 ; Segment permissions: Read/Execute
.text$x:00005A94 _text$x         segment para public 'CODE' use32
.text$x:00005A94                 assume cs:_text$x
.text$x:00005A94                 ;org 5A94h
.text$x:00005A94 ; COMDAT (pick associative to section at 5A3C)
.text$x:00005A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005A94
.text$x:00005A94 ; =============== S U B R O U T I N E =======================================
.text$x:00005A94
.text$x:00005A94
.text$x:00005A94 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z$0 proc near
.text$x:00005A94                                         ; DATA XREF: .xdata$x:0000E190o
.text$x:00005A94                 mov     ecx, [ebp-10h]
.text$x:00005A97                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:00005A97 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z$0 endp
.text$x:00005A97
.text$x:00005A9C
.text$x:00005A9C ; =============== S U B R O U T I N E =======================================
.text$x:00005A9C
.text$x:00005A9C
.text$x:00005A9C __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z proc near
.text$x:00005A9C                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(UserCommand *,std::_Container_base12 const *)+5o
.text$x:00005A9C
.text$x:00005A9C arg_4           = dword ptr  8
.text$x:00005A9C
.text$x:00005A9C                 mov     edx, [esp+arg_4]
.text$x:00005AA0                 lea     eax, [edx+0Ch]
.text$x:00005AA3                 mov     ecx, [edx-8]
.text$x:00005AA6                 xor     ecx, eax
.text$x:00005AA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005AAD                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.text$x:00005AB2                 jmp     ___CxxFrameHandler3
.text$x:00005AB2 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z endp
.text$x:00005AB2
.text$x:00005AB2 ; ---------------------------------------------------------------------------
.text$x:00005AB7                 align 4
.text$x:00005AB7 _text$x         ends
.text$x:00005AB7
.text$mn:00005AB8 ; ===========================================================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Segment type: Pure code
.text$mn:00005AB8 ; Segment permissions: Read/Execute
.text$mn:00005AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00005AB8                 assume cs:_text$mn
.text$mn:00005AB8                 ;org 5AB8h
.text$mn:00005AB8 ; COMDAT (pick any)
.text$mn:00005AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005AB8
.text$mn:00005AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Attributes: bp-based frame
.text$mn:00005AB8
.text$mn:00005AB8 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>::_Vector_val<struct std::_Simple_types<struct KeyCombo>>(void)
.text$mn:00005AB8                 public ??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.text$mn:00005AB8 ??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ proc near
.text$mn:00005AB8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(std::allocator<KeyCombo> const &)+29p
.text$mn:00005AB8
.text$mn:00005AB8 var_10          = dword ptr -10h
.text$mn:00005AB8 var_C           = dword ptr -0Ch
.text$mn:00005AB8 var_4           = dword ptr -4
.text$mn:00005AB8
.text$mn:00005AB8                 push    ebp
.text$mn:00005AB9                 mov     ebp, esp
.text$mn:00005ABB                 push    0FFFFFFFFh
.text$mn:00005ABD                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.text$mn:00005AC2                 mov     eax, large fs:0
.text$mn:00005AC8                 push    eax
.text$mn:00005AC9                 push    ecx
.text$mn:00005ACA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005ACF                 xor     eax, ebp
.text$mn:00005AD1                 push    eax
.text$mn:00005AD2                 lea     eax, [ebp+var_C]
.text$mn:00005AD5                 mov     large fs:0, eax
.text$mn:00005ADB                 mov     [ebp+var_10], ecx
.text$mn:00005ADE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005AE1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005AE6                 mov     [ebp+var_4], 0
.text$mn:00005AED                 mov     eax, [ebp+var_10]
.text$mn:00005AF0                 mov     dword ptr [eax+4], 0
.text$mn:00005AF7                 mov     ecx, [ebp+var_10]
.text$mn:00005AFA                 mov     dword ptr [ecx+8], 0
.text$mn:00005B01                 mov     edx, [ebp+var_10]
.text$mn:00005B04                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005B0B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005B12                 mov     eax, [ebp+var_10]
.text$mn:00005B15                 mov     ecx, [ebp+var_C]
.text$mn:00005B18                 mov     large fs:0, ecx
.text$mn:00005B1F                 pop     ecx
.text$mn:00005B20                 mov     esp, ebp
.text$mn:00005B22                 pop     ebp
.text$mn:00005B23                 retn
.text$mn:00005B23 ??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ endp
.text$mn:00005B23
.text$mn:00005B23 _text$mn        ends
.text$mn:00005B23
.text$x:00005B24 ; ===========================================================================
.text$x:00005B24
.text$x:00005B24 ; Segment type: Pure code
.text$x:00005B24 ; Segment permissions: Read/Execute
.text$x:00005B24 _text$x         segment para public 'CODE' use32
.text$x:00005B24                 assume cs:_text$x
.text$x:00005B24                 ;org 5B24h
.text$x:00005B24 ; COMDAT (pick associative to section at 5AB8)
.text$x:00005B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B24
.text$x:00005B24 ; =============== S U B R O U T I N E =======================================
.text$x:00005B24
.text$x:00005B24
.text$x:00005B24 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005B24                                         ; DATA XREF: .xdata$x:0000D2E0o
.text$x:00005B24                 mov     ecx, [ebp-10h]  ; this
.text$x:00005B27                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005B27 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005B27
.text$x:00005B2C
.text$x:00005B2C ; =============== S U B R O U T I N E =======================================
.text$x:00005B2C
.text$x:00005B2C
.text$x:00005B2C __ehhandler$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ proc near
.text$x:00005B2C                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<KeyCombo>>::_Vector_val<std::_Simple_types<KeyCombo>>(void)+5o
.text$x:00005B2C
.text$x:00005B2C arg_4           = dword ptr  8
.text$x:00005B2C
.text$x:00005B2C                 mov     edx, [esp+arg_4]
.text$x:00005B30                 lea     eax, [edx+0Ch]
.text$x:00005B33                 mov     ecx, [edx-8]
.text$x:00005B36                 xor     ecx, eax
.text$x:00005B38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B3D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.text$x:00005B42                 jmp     ___CxxFrameHandler3
.text$x:00005B42 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ endp
.text$x:00005B42
.text$x:00005B42 ; ---------------------------------------------------------------------------
.text$x:00005B47                 align 4
.text$x:00005B47 _text$x         ends
.text$x:00005B47
.text$mn:00005B48 ; ===========================================================================
.text$mn:00005B48
.text$mn:00005B48 ; Segment type: Pure code
.text$mn:00005B48 ; Segment permissions: Read/Execute
.text$mn:00005B48 _text$mn        segment para public 'CODE' use32
.text$mn:00005B48                 assume cs:_text$mn
.text$mn:00005B48                 ;org 5B48h
.text$mn:00005B48 ; COMDAT (pick any)
.text$mn:00005B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B48
.text$mn:00005B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B48
.text$mn:00005B48 ; Attributes: bp-based frame
.text$mn:00005B48
.text$mn:00005B48 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>::_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>(void)
.text$mn:00005B48                 public ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00005B48 ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:00005B48                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)+29p
.text$mn:00005B48
.text$mn:00005B48 var_10          = dword ptr -10h
.text$mn:00005B48 var_C           = dword ptr -0Ch
.text$mn:00005B48 var_4           = dword ptr -4
.text$mn:00005B48
.text$mn:00005B48                 push    ebp
.text$mn:00005B49                 mov     ebp, esp
.text$mn:00005B4B                 push    0FFFFFFFFh
.text$mn:00005B4D                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00005B52                 mov     eax, large fs:0
.text$mn:00005B58                 push    eax
.text$mn:00005B59                 push    ecx
.text$mn:00005B5A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005B5F                 xor     eax, ebp
.text$mn:00005B61                 push    eax
.text$mn:00005B62                 lea     eax, [ebp+var_C]
.text$mn:00005B65                 mov     large fs:0, eax
.text$mn:00005B6B                 mov     [ebp+var_10], ecx
.text$mn:00005B6E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005B71                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005B76                 mov     [ebp+var_4], 0
.text$mn:00005B7D                 mov     eax, [ebp+var_10]
.text$mn:00005B80                 mov     dword ptr [eax+4], 0
.text$mn:00005B87                 mov     ecx, [ebp+var_10]
.text$mn:00005B8A                 mov     dword ptr [ecx+8], 0
.text$mn:00005B91                 mov     edx, [ebp+var_10]
.text$mn:00005B94                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005B9B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005BA2                 mov     eax, [ebp+var_10]
.text$mn:00005BA5                 mov     ecx, [ebp+var_C]
.text$mn:00005BA8                 mov     large fs:0, ecx
.text$mn:00005BAF                 pop     ecx
.text$mn:00005BB0                 mov     esp, ebp
.text$mn:00005BB2                 pop     ebp
.text$mn:00005BB3                 retn
.text$mn:00005BB3 ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:00005BB3
.text$mn:00005BB3 _text$mn        ends
.text$mn:00005BB3
.text$x:00005BB4 ; ===========================================================================
.text$x:00005BB4
.text$x:00005BB4 ; Segment type: Pure code
.text$x:00005BB4 ; Segment permissions: Read/Execute
.text$x:00005BB4 _text$x         segment para public 'CODE' use32
.text$x:00005BB4                 assume cs:_text$x
.text$x:00005BB4                 ;org 5BB4h
.text$x:00005BB4 ; COMDAT (pick associative to section at 5B48)
.text$x:00005BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005BB4
.text$x:00005BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00005BB4
.text$x:00005BB4
.text$x:00005BB4 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005BB4                                         ; DATA XREF: .xdata$x:0000DD3Co
.text$x:00005BB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00005BB7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005BB7 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005BB7
.text$x:00005BBC
.text$x:00005BBC ; =============== S U B R O U T I N E =======================================
.text$x:00005BBC
.text$x:00005BBC
.text$x:00005BBC __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:00005BBC                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<MenuItemUnit>>::_Vector_val<std::_Simple_types<MenuItemUnit>>(void)+5o
.text$x:00005BBC
.text$x:00005BBC arg_4           = dword ptr  8
.text$x:00005BBC
.text$x:00005BBC                 mov     edx, [esp+arg_4]
.text$x:00005BC0                 lea     eax, [edx+0Ch]
.text$x:00005BC3                 mov     ecx, [edx-8]
.text$x:00005BC6                 xor     ecx, eax
.text$x:00005BC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005BCD                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:00005BD2                 jmp     ___CxxFrameHandler3
.text$x:00005BD2 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:00005BD2
.text$x:00005BD2 ; ---------------------------------------------------------------------------
.text$x:00005BD7                 align 4
.text$x:00005BD7 _text$x         ends
.text$x:00005BD7
.text$mn:00005BD8 ; ===========================================================================
.text$mn:00005BD8
.text$mn:00005BD8 ; Segment type: Pure code
.text$mn:00005BD8 ; Segment permissions: Read/Execute
.text$mn:00005BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00005BD8                 assume cs:_text$mn
.text$mn:00005BD8                 ;org 5BD8h
.text$mn:00005BD8 ; COMDAT (pick any)
.text$mn:00005BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BD8
.text$mn:00005BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BD8
.text$mn:00005BD8 ; Attributes: bp-based frame
.text$mn:00005BD8
.text$mn:00005BD8 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>(void)
.text$mn:00005BD8                 public ??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:00005BD8 ??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$mn:00005BD8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(std::allocator<recordedMacroStep> const &)+29p
.text$mn:00005BD8
.text$mn:00005BD8 var_10          = dword ptr -10h
.text$mn:00005BD8 var_C           = dword ptr -0Ch
.text$mn:00005BD8 var_4           = dword ptr -4
.text$mn:00005BD8
.text$mn:00005BD8                 push    ebp
.text$mn:00005BD9                 mov     ebp, esp
.text$mn:00005BDB                 push    0FFFFFFFFh
.text$mn:00005BDD                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:00005BE2                 mov     eax, large fs:0
.text$mn:00005BE8                 push    eax
.text$mn:00005BE9                 push    ecx
.text$mn:00005BEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005BEF                 xor     eax, ebp
.text$mn:00005BF1                 push    eax
.text$mn:00005BF2                 lea     eax, [ebp+var_C]
.text$mn:00005BF5                 mov     large fs:0, eax
.text$mn:00005BFB                 mov     [ebp+var_10], ecx
.text$mn:00005BFE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005C01                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005C06                 mov     [ebp+var_4], 0
.text$mn:00005C0D                 mov     eax, [ebp+var_10]
.text$mn:00005C10                 mov     dword ptr [eax+4], 0
.text$mn:00005C17                 mov     ecx, [ebp+var_10]
.text$mn:00005C1A                 mov     dword ptr [ecx+8], 0
.text$mn:00005C21                 mov     edx, [ebp+var_10]
.text$mn:00005C24                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005C2B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005C32                 mov     eax, [ebp+var_10]
.text$mn:00005C35                 mov     ecx, [ebp+var_C]
.text$mn:00005C38                 mov     large fs:0, ecx
.text$mn:00005C3F                 pop     ecx
.text$mn:00005C40                 mov     esp, ebp
.text$mn:00005C42                 pop     ebp
.text$mn:00005C43                 retn
.text$mn:00005C43 ??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$mn:00005C43
.text$mn:00005C43 _text$mn        ends
.text$mn:00005C43
.text$x:00005C44 ; ===========================================================================
.text$x:00005C44
.text$x:00005C44 ; Segment type: Pure code
.text$x:00005C44 ; Segment permissions: Read/Execute
.text$x:00005C44 _text$x         segment para public 'CODE' use32
.text$x:00005C44                 assume cs:_text$x
.text$x:00005C44                 ;org 5C44h
.text$x:00005C44 ; COMDAT (pick associative to section at 5BD8)
.text$x:00005C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005C44
.text$x:00005C44 ; =============== S U B R O U T I N E =======================================
.text$x:00005C44
.text$x:00005C44
.text$x:00005C44 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005C44                                         ; DATA XREF: .xdata$x:0000D6D0o
.text$x:00005C44                 mov     ecx, [ebp-10h]  ; this
.text$x:00005C47                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005C47 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005C47
.text$x:00005C4C
.text$x:00005C4C ; =============== S U B R O U T I N E =======================================
.text$x:00005C4C
.text$x:00005C4C
.text$x:00005C4C __ehhandler$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$x:00005C4C                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<recordedMacroStep>>::_Vector_val<std::_Simple_types<recordedMacroStep>>(void)+5o
.text$x:00005C4C
.text$x:00005C4C arg_4           = dword ptr  8
.text$x:00005C4C
.text$x:00005C4C                 mov     edx, [esp+arg_4]
.text$x:00005C50                 lea     eax, [edx+0Ch]
.text$x:00005C53                 mov     ecx, [edx-8]
.text$x:00005C56                 xor     ecx, eax
.text$x:00005C58                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005C5D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$x:00005C62                 jmp     ___CxxFrameHandler3
.text$x:00005C62 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$x:00005C62
.text$x:00005C62 ; ---------------------------------------------------------------------------
.text$x:00005C67                 align 4
.text$x:00005C67 _text$x         ends
.text$x:00005C67
.text$mn:00005C68 ; ===========================================================================
.text$mn:00005C68
.text$mn:00005C68 ; Segment type: Pure code
.text$mn:00005C68 ; Segment permissions: Read/Execute
.text$mn:00005C68 _text$mn        segment para public 'CODE' use32
.text$mn:00005C68                 assume cs:_text$mn
.text$mn:00005C68                 ;org 5C68h
.text$mn:00005C68 ; COMDAT (pick any)
.text$mn:00005C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C68
.text$mn:00005C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C68
.text$mn:00005C68 ; Attributes: bp-based frame
.text$mn:00005C68
.text$mn:00005C68 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00005C68                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00005C68 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00005C68                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00005C68
.text$mn:00005C68 var_4           = dword ptr -4
.text$mn:00005C68
.text$mn:00005C68                 push    ebp
.text$mn:00005C69                 mov     ebp, esp
.text$mn:00005C6B                 push    ecx
.text$mn:00005C6C                 mov     [ebp+var_4], ecx
.text$mn:00005C6F                 mov     ecx, [ebp+var_4]
.text$mn:00005C72                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00005C77                 mov     eax, [ebp+var_4]
.text$mn:00005C7A                 mov     esp, ebp
.text$mn:00005C7C                 pop     ebp
.text$mn:00005C7D                 retn
.text$mn:00005C7D ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00005C7D
.text$mn:00005C7D ; ---------------------------------------------------------------------------
.text$mn:00005C7E                 align 10h
.text$mn:00005C7E _text$mn        ends
.text$mn:00005C7E
.text$mn:00005C80 ; ===========================================================================
.text$mn:00005C80
.text$mn:00005C80 ; Segment type: Pure code
.text$mn:00005C80 ; Segment permissions: Read/Execute
.text$mn:00005C80 _text$mn        segment para public 'CODE' use32
.text$mn:00005C80                 assume cs:_text$mn
.text$mn:00005C80                 ;org 5C80h
.text$mn:00005C80 ; COMDAT (pick any)
.text$mn:00005C80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C80
.text$mn:00005C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C80
.text$mn:00005C80 ; Attributes: bp-based frame
.text$mn:00005C80
.text$mn:00005C80 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct KeyCombo>>::_Wrap_alloc<class std::allocator<struct KeyCombo>>(class std::allocator<struct KeyCombo> const &)
.text$mn:00005C80                 public ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z
.text$mn:00005C80 ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z proc near
.text$mn:00005C80                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00005C80
.text$mn:00005C80 var_4           = dword ptr -4
.text$mn:00005C80 arg_0           = dword ptr  8
.text$mn:00005C80
.text$mn:00005C80                 push    ebp
.text$mn:00005C81                 mov     ebp, esp
.text$mn:00005C83                 push    ecx
.text$mn:00005C84                 mov     [ebp+var_4], ecx
.text$mn:00005C87                 mov     eax, [ebp+arg_0]
.text$mn:00005C8A                 push    eax
.text$mn:00005C8B                 mov     ecx, [ebp+var_4]
.text$mn:00005C8E                 call    ??0?$allocator@UKeyCombo@@@std@@QAE@ABV01@@Z ; std::allocator<KeyCombo>::allocator<KeyCombo>(std::allocator<KeyCombo> const &)
.text$mn:00005C93                 mov     eax, [ebp+var_4]
.text$mn:00005C96                 mov     esp, ebp
.text$mn:00005C98                 pop     ebp
.text$mn:00005C99                 retn    4
.text$mn:00005C99 ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z endp
.text$mn:00005C99
.text$mn:00005C99 _text$mn        ends
.text$mn:00005C99
.text$mn:00005C9C ; ===========================================================================
.text$mn:00005C9C
.text$mn:00005C9C ; Segment type: Pure code
.text$mn:00005C9C ; Segment permissions: Read/Execute
.text$mn:00005C9C _text$mn        segment para public 'CODE' use32
.text$mn:00005C9C                 assume cs:_text$mn
.text$mn:00005C9C                 ;org 5C9Ch
.text$mn:00005C9C ; COMDAT (pick any)
.text$mn:00005C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C9C
.text$mn:00005C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C9C
.text$mn:00005C9C ; Attributes: bp-based frame
.text$mn:00005C9C
.text$mn:00005C9C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct KeyCombo>>::_Wrap_alloc<class std::allocator<struct KeyCombo>>(void)
.text$mn:00005C9C                 public ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ
.text$mn:00005C9C ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ proc near
.text$mn:00005C9C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)+Ap
.text$mn:00005C9C
.text$mn:00005C9C var_4           = dword ptr -4
.text$mn:00005C9C
.text$mn:00005C9C                 push    ebp
.text$mn:00005C9D                 mov     ebp, esp
.text$mn:00005C9F                 push    ecx
.text$mn:00005CA0                 mov     [ebp+var_4], ecx
.text$mn:00005CA3                 mov     ecx, [ebp+var_4]
.text$mn:00005CA6                 call    ??0?$allocator@UKeyCombo@@@std@@QAE@XZ ; std::allocator<KeyCombo>::allocator<KeyCombo>(void)
.text$mn:00005CAB                 mov     eax, [ebp+var_4]
.text$mn:00005CAE                 mov     esp, ebp
.text$mn:00005CB0                 pop     ebp
.text$mn:00005CB1                 retn
.text$mn:00005CB1 ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ endp
.text$mn:00005CB1
.text$mn:00005CB1 ; ---------------------------------------------------------------------------
.text$mn:00005CB2                 align 4
.text$mn:00005CB2 _text$mn        ends
.text$mn:00005CB2
.text$mn:00005CB4 ; ===========================================================================
.text$mn:00005CB4
.text$mn:00005CB4 ; Segment type: Pure code
.text$mn:00005CB4 ; Segment permissions: Read/Execute
.text$mn:00005CB4 _text$mn        segment para public 'CODE' use32
.text$mn:00005CB4                 assume cs:_text$mn
.text$mn:00005CB4                 ;org 5CB4h
.text$mn:00005CB4 ; COMDAT (pick any)
.text$mn:00005CB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CB4
.text$mn:00005CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CB4
.text$mn:00005CB4 ; Attributes: bp-based frame
.text$mn:00005CB4
.text$mn:00005CB4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>(void)
.text$mn:00005CB4                 public ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00005CB4 ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:00005CB4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)+Ap
.text$mn:00005CB4
.text$mn:00005CB4 var_4           = dword ptr -4
.text$mn:00005CB4
.text$mn:00005CB4                 push    ebp
.text$mn:00005CB5                 mov     ebp, esp
.text$mn:00005CB7                 push    ecx
.text$mn:00005CB8                 mov     [ebp+var_4], ecx
.text$mn:00005CBB                 mov     ecx, [ebp+var_4]
.text$mn:00005CBE                 call    ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ ; std::allocator<MenuItemUnit>::allocator<MenuItemUnit>(void)
.text$mn:00005CC3                 mov     eax, [ebp+var_4]
.text$mn:00005CC6                 mov     esp, ebp
.text$mn:00005CC8                 pop     ebp
.text$mn:00005CC9                 retn
.text$mn:00005CC9 ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:00005CC9
.text$mn:00005CC9 ; ---------------------------------------------------------------------------
.text$mn:00005CCA                 align 4
.text$mn:00005CCA _text$mn        ends
.text$mn:00005CCA
.text$mn:00005CCC ; ===========================================================================
.text$mn:00005CCC
.text$mn:00005CCC ; Segment type: Pure code
.text$mn:00005CCC ; Segment permissions: Read/Execute
.text$mn:00005CCC _text$mn        segment para public 'CODE' use32
.text$mn:00005CCC                 assume cs:_text$mn
.text$mn:00005CCC                 ;org 5CCCh
.text$mn:00005CCC ; COMDAT (pick any)
.text$mn:00005CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CCC
.text$mn:00005CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00005CCC
.text$mn:00005CCC ; Attributes: bp-based frame
.text$mn:00005CCC
.text$mn:00005CCC ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:00005CCC                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:00005CCC ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005CCC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Alloc_proxy(void)+Cp
.text$mn:00005CCC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00005CCC
.text$mn:00005CCC var_4           = dword ptr -4
.text$mn:00005CCC
.text$mn:00005CCC                 push    ebp
.text$mn:00005CCD                 mov     ebp, esp
.text$mn:00005CCF                 push    ecx
.text$mn:00005CD0                 mov     [ebp+var_4], ecx
.text$mn:00005CD3                 mov     ecx, [ebp+var_4]
.text$mn:00005CD6                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00005CDB                 mov     eax, [ebp+var_4]
.text$mn:00005CDE                 mov     esp, ebp
.text$mn:00005CE0                 pop     ebp
.text$mn:00005CE1                 retn
.text$mn:00005CE1 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005CE1
.text$mn:00005CE1 ; ---------------------------------------------------------------------------
.text$mn:00005CE2                 align 4
.text$mn:00005CE2 _text$mn        ends
.text$mn:00005CE2
.text$mn:00005CE4 ; ===========================================================================
.text$mn:00005CE4
.text$mn:00005CE4 ; Segment type: Pure code
.text$mn:00005CE4 ; Segment permissions: Read/Execute
.text$mn:00005CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00005CE4                 assume cs:_text$mn
.text$mn:00005CE4                 ;org 5CE4h
.text$mn:00005CE4 ; COMDAT (pick any)
.text$mn:00005CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CE4
.text$mn:00005CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CE4
.text$mn:00005CE4 ; Attributes: bp-based frame
.text$mn:00005CE4
.text$mn:00005CE4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>(class std::allocator<struct recordedMacroStep> const &)
.text$mn:00005CE4                 public ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z
.text$mn:00005CE4 ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z proc near
.text$mn:00005CE4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00005CE4
.text$mn:00005CE4 var_4           = dword ptr -4
.text$mn:00005CE4 arg_0           = dword ptr  8
.text$mn:00005CE4
.text$mn:00005CE4                 push    ebp
.text$mn:00005CE5                 mov     ebp, esp
.text$mn:00005CE7                 push    ecx
.text$mn:00005CE8                 mov     [ebp+var_4], ecx
.text$mn:00005CEB                 mov     eax, [ebp+arg_0]
.text$mn:00005CEE                 push    eax
.text$mn:00005CEF                 mov     ecx, [ebp+var_4]
.text$mn:00005CF2                 call    ??0?$allocator@UrecordedMacroStep@@@std@@QAE@ABV01@@Z ; std::allocator<recordedMacroStep>::allocator<recordedMacroStep>(std::allocator<recordedMacroStep> const &)
.text$mn:00005CF7                 mov     eax, [ebp+var_4]
.text$mn:00005CFA                 mov     esp, ebp
.text$mn:00005CFC                 pop     ebp
.text$mn:00005CFD                 retn    4
.text$mn:00005CFD ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z endp
.text$mn:00005CFD
.text$mn:00005CFD _text$mn        ends
.text$mn:00005CFD
.text$mn:00005D00 ; ===========================================================================
.text$mn:00005D00
.text$mn:00005D00 ; Segment type: Pure code
.text$mn:00005D00 ; Segment permissions: Read/Execute
.text$mn:00005D00 _text$mn        segment para public 'CODE' use32
.text$mn:00005D00                 assume cs:_text$mn
.text$mn:00005D00                 ;org 5D00h
.text$mn:00005D00 ; COMDAT (pick any)
.text$mn:00005D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D00
.text$mn:00005D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D00
.text$mn:00005D00 ; Attributes: bp-based frame
.text$mn:00005D00
.text$mn:00005D00 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>(void)
.text$mn:00005D00                 public ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:00005D00 ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$mn:00005D00                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)+Ap
.text$mn:00005D00
.text$mn:00005D00 var_4           = dword ptr -4
.text$mn:00005D00
.text$mn:00005D00                 push    ebp
.text$mn:00005D01                 mov     ebp, esp
.text$mn:00005D03                 push    ecx
.text$mn:00005D04                 mov     [ebp+var_4], ecx
.text$mn:00005D07                 mov     ecx, [ebp+var_4]
.text$mn:00005D0A                 call    ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ ; std::allocator<recordedMacroStep>::allocator<recordedMacroStep>(void)
.text$mn:00005D0F                 mov     eax, [ebp+var_4]
.text$mn:00005D12                 mov     esp, ebp
.text$mn:00005D14                 pop     ebp
.text$mn:00005D15                 retn
.text$mn:00005D15 ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$mn:00005D15
.text$mn:00005D15 ; ---------------------------------------------------------------------------
.text$mn:00005D16                 align 4
.text$mn:00005D16 _text$mn        ends
.text$mn:00005D16
.text$mn:00005D18 ; ===========================================================================
.text$mn:00005D18
.text$mn:00005D18 ; Segment type: Pure code
.text$mn:00005D18 ; Segment permissions: Read/Execute
.text$mn:00005D18 _text$mn        segment para public 'CODE' use32
.text$mn:00005D18                 assume cs:_text$mn
.text$mn:00005D18                 ;org 5D18h
.text$mn:00005D18 ; COMDAT (pick any)
.text$mn:00005D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D18
.text$mn:00005D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D18
.text$mn:00005D18 ; Attributes: bp-based frame
.text$mn:00005D18
.text$mn:00005D18 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class MacroShortcut>>::_Wrap_alloc<class std::allocator<class MacroShortcut>>(void)
.text$mn:00005D18                 public ??0?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAE@XZ
.text$mn:00005D18 ??0?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAE@XZ proc near
.text$mn:00005D18                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MacroShortcut,std::allocator<MacroShortcut>>>::_Getal(void)+Ap
.text$mn:00005D18
.text$mn:00005D18 var_4           = dword ptr -4
.text$mn:00005D18
.text$mn:00005D18                 push    ebp
.text$mn:00005D19                 mov     ebp, esp
.text$mn:00005D1B                 push    ecx
.text$mn:00005D1C                 mov     [ebp+var_4], ecx
.text$mn:00005D1F                 mov     ecx, [ebp+var_4]
.text$mn:00005D22                 call    ??0?$allocator@VMacroShortcut@@@std@@QAE@XZ ; std::allocator<MacroShortcut>::allocator<MacroShortcut>(void)
.text$mn:00005D27                 mov     eax, [ebp+var_4]
.text$mn:00005D2A                 mov     esp, ebp
.text$mn:00005D2C                 pop     ebp
.text$mn:00005D2D                 retn
.text$mn:00005D2D ??0?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAE@XZ endp
.text$mn:00005D2D
.text$mn:00005D2D ; ---------------------------------------------------------------------------
.text$mn:00005D2E                 align 10h
.text$mn:00005D2E _text$mn        ends
.text$mn:00005D2E
.text$mn:00005D30 ; ===========================================================================
.text$mn:00005D30
.text$mn:00005D30 ; Segment type: Pure code
.text$mn:00005D30 ; Segment permissions: Read/Execute
.text$mn:00005D30 _text$mn        segment para public 'CODE' use32
.text$mn:00005D30                 assume cs:_text$mn
.text$mn:00005D30                 ;org 5D30h
.text$mn:00005D30 ; COMDAT (pick any)
.text$mn:00005D30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D30
.text$mn:00005D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D30
.text$mn:00005D30 ; Attributes: bp-based frame
.text$mn:00005D30
.text$mn:00005D30 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class UserCommand>>::_Wrap_alloc<class std::allocator<class UserCommand>>(void)
.text$mn:00005D30                 public ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ
.text$mn:00005D30 ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ proc near
.text$mn:00005D30                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)+Ap
.text$mn:00005D30
.text$mn:00005D30 var_4           = dword ptr -4
.text$mn:00005D30
.text$mn:00005D30                 push    ebp
.text$mn:00005D31                 mov     ebp, esp
.text$mn:00005D33                 push    ecx
.text$mn:00005D34                 mov     [ebp+var_4], ecx
.text$mn:00005D37                 mov     ecx, [ebp+var_4]
.text$mn:00005D3A                 call    ??0?$allocator@VUserCommand@@@std@@QAE@XZ ; std::allocator<UserCommand>::allocator<UserCommand>(void)
.text$mn:00005D3F                 mov     eax, [ebp+var_4]
.text$mn:00005D42                 mov     esp, ebp
.text$mn:00005D44                 pop     ebp
.text$mn:00005D45                 retn
.text$mn:00005D45 ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ endp
.text$mn:00005D45
.text$mn:00005D45 ; ---------------------------------------------------------------------------
.text$mn:00005D46                 align 4
.text$mn:00005D46 _text$mn        ends
.text$mn:00005D46
.text$mn:00005D48 ; ===========================================================================
.text$mn:00005D48
.text$mn:00005D48 ; Segment type: Pure code
.text$mn:00005D48 ; Segment permissions: Read/Execute
.text$mn:00005D48 _text$mn        segment para public 'CODE' use32
.text$mn:00005D48                 assume cs:_text$mn
.text$mn:00005D48                 ;org 5D48h
.text$mn:00005D48 ; COMDAT (pick any)
.text$mn:00005D48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D48
.text$mn:00005D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D48
.text$mn:00005D48 ; Attributes: bp-based frame
.text$mn:00005D48
.text$mn:00005D48 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:00005D48                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005D48 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005D48                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00005D48
.text$mn:00005D48 var_4           = dword ptr -4
.text$mn:00005D48 arg_0           = dword ptr  8
.text$mn:00005D48
.text$mn:00005D48                 push    ebp
.text$mn:00005D49                 mov     ebp, esp
.text$mn:00005D4B                 push    ecx
.text$mn:00005D4C                 mov     [ebp+var_4], ecx
.text$mn:00005D4F                 mov     eax, [ebp+arg_0]
.text$mn:00005D52                 push    eax
.text$mn:00005D53                 mov     ecx, [ebp+var_4]
.text$mn:00005D56                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00005D5B                 mov     eax, [ebp+var_4]
.text$mn:00005D5E                 mov     esp, ebp
.text$mn:00005D60                 pop     ebp
.text$mn:00005D61                 retn    4
.text$mn:00005D61 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00005D61
.text$mn:00005D61 _text$mn        ends
.text$mn:00005D61
.text$mn:00005D64 ; ===========================================================================
.text$mn:00005D64
.text$mn:00005D64 ; Segment type: Pure code
.text$mn:00005D64 ; Segment permissions: Read/Execute
.text$mn:00005D64 _text$mn        segment para public 'CODE' use32
.text$mn:00005D64                 assume cs:_text$mn
.text$mn:00005D64                 ;org 5D64h
.text$mn:00005D64 ; COMDAT (pick any)
.text$mn:00005D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D64
.text$mn:00005D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D64
.text$mn:00005D64 ; Attributes: bp-based frame
.text$mn:00005D64
.text$mn:00005D64 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00005D64                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00005D64 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005D64                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00005D64
.text$mn:00005D64 var_4           = dword ptr -4
.text$mn:00005D64
.text$mn:00005D64                 push    ebp
.text$mn:00005D65                 mov     ebp, esp
.text$mn:00005D67                 push    ecx
.text$mn:00005D68                 mov     [ebp+var_4], ecx
.text$mn:00005D6B                 mov     ecx, [ebp+var_4]
.text$mn:00005D6E                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005D73                 mov     eax, [ebp+var_4]
.text$mn:00005D76                 mov     esp, ebp
.text$mn:00005D78                 pop     ebp
.text$mn:00005D79                 retn
.text$mn:00005D79 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00005D79
.text$mn:00005D79 ; ---------------------------------------------------------------------------
.text$mn:00005D7A                 align 4
.text$mn:00005D7A _text$mn        ends
.text$mn:00005D7A
.text$mn:00005D7C ; ===========================================================================
.text$mn:00005D7C
.text$mn:00005D7C ; Segment type: Pure code
.text$mn:00005D7C ; Segment permissions: Read/Execute
.text$mn:00005D7C _text$mn        segment para public 'CODE' use32
.text$mn:00005D7C                 assume cs:_text$mn
.text$mn:00005D7C                 ;org 5D7Ch
.text$mn:00005D7C ; COMDAT (pick any)
.text$mn:00005D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D7C
.text$mn:00005D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D7C
.text$mn:00005D7C ; Attributes: bp-based frame
.text$mn:00005D7C
.text$mn:00005D7C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00005D7C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00005D7C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00005D7C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00005D7C
.text$mn:00005D7C var_4           = dword ptr -4
.text$mn:00005D7C
.text$mn:00005D7C                 push    ebp
.text$mn:00005D7D                 mov     ebp, esp
.text$mn:00005D7F                 push    ecx
.text$mn:00005D80                 mov     [ebp+var_4], ecx
.text$mn:00005D83                 mov     eax, [ebp+var_4]
.text$mn:00005D86                 mov     esp, ebp
.text$mn:00005D88                 pop     ebp
.text$mn:00005D89                 retn
.text$mn:00005D89 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00005D89
.text$mn:00005D89 ; ---------------------------------------------------------------------------
.text$mn:00005D8A                 align 4
.text$mn:00005D8A _text$mn        ends
.text$mn:00005D8A
.text$mn:00005D8C ; ===========================================================================
.text$mn:00005D8C
.text$mn:00005D8C ; Segment type: Pure code
.text$mn:00005D8C ; Segment permissions: Read/Execute
.text$mn:00005D8C _text$mn        segment para public 'CODE' use32
.text$mn:00005D8C                 assume cs:_text$mn
.text$mn:00005D8C                 ;org 5D8Ch
.text$mn:00005D8C ; COMDAT (pick any)
.text$mn:00005D8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D8C
.text$mn:00005D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D8C
.text$mn:00005D8C ; Attributes: bp-based frame
.text$mn:00005D8C
.text$mn:00005D8C ; public: __thiscall std::allocator<struct KeyCombo>::allocator<struct KeyCombo>(class std::allocator<struct KeyCombo> const &)
.text$mn:00005D8C                 public ??0?$allocator@UKeyCombo@@@std@@QAE@ABV01@@Z
.text$mn:00005D8C ??0?$allocator@UKeyCombo@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005D8C                                         ; CODE XREF: std::operator==<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)+Bp
.text$mn:00005D8C                                         ; std::operator==<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)+18p ...
.text$mn:00005D8C
.text$mn:00005D8C var_4           = dword ptr -4
.text$mn:00005D8C
.text$mn:00005D8C                 push    ebp
.text$mn:00005D8D                 mov     ebp, esp
.text$mn:00005D8F                 push    ecx
.text$mn:00005D90                 mov     [ebp+var_4], ecx
.text$mn:00005D93                 mov     eax, [ebp+var_4]
.text$mn:00005D96                 mov     esp, ebp
.text$mn:00005D98                 pop     ebp
.text$mn:00005D99                 retn    4
.text$mn:00005D99 ??0?$allocator@UKeyCombo@@@std@@QAE@ABV01@@Z endp
.text$mn:00005D99
.text$mn:00005D99 _text$mn        ends
.text$mn:00005D99
.text$mn:00005D9C ; ===========================================================================
.text$mn:00005D9C
.text$mn:00005D9C ; Segment type: Pure code
.text$mn:00005D9C ; Segment permissions: Read/Execute
.text$mn:00005D9C _text$mn        segment para public 'CODE' use32
.text$mn:00005D9C                 assume cs:_text$mn
.text$mn:00005D9C                 ;org 5D9Ch
.text$mn:00005D9C ; COMDAT (pick any)
.text$mn:00005D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D9C
.text$mn:00005D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D9C
.text$mn:00005D9C ; Attributes: bp-based frame
.text$mn:00005D9C
.text$mn:00005D9C ; public: __thiscall std::allocator<struct KeyCombo>::allocator<struct KeyCombo>(void)
.text$mn:00005D9C                 public ??0?$allocator@UKeyCombo@@@std@@QAE@XZ
.text$mn:00005D9C ??0?$allocator@UKeyCombo@@@std@@QAE@XZ proc near
.text$mn:00005D9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::_Wrap_alloc<std::allocator<KeyCombo>>(void)+Ap
.text$mn:00005D9C
.text$mn:00005D9C var_4           = dword ptr -4
.text$mn:00005D9C
.text$mn:00005D9C                 push    ebp
.text$mn:00005D9D                 mov     ebp, esp
.text$mn:00005D9F                 push    ecx
.text$mn:00005DA0                 mov     [ebp+var_4], ecx
.text$mn:00005DA3                 mov     eax, [ebp+var_4]
.text$mn:00005DA6                 mov     esp, ebp
.text$mn:00005DA8                 pop     ebp
.text$mn:00005DA9                 retn
.text$mn:00005DA9 ??0?$allocator@UKeyCombo@@@std@@QAE@XZ endp
.text$mn:00005DA9
.text$mn:00005DA9 ; ---------------------------------------------------------------------------
.text$mn:00005DAA                 align 4
.text$mn:00005DAA _text$mn        ends
.text$mn:00005DAA
.text$mn:00005DAC ; ===========================================================================
.text$mn:00005DAC
.text$mn:00005DAC ; Segment type: Pure code
.text$mn:00005DAC ; Segment permissions: Read/Execute
.text$mn:00005DAC _text$mn        segment para public 'CODE' use32
.text$mn:00005DAC                 assume cs:_text$mn
.text$mn:00005DAC                 ;org 5DACh
.text$mn:00005DAC ; COMDAT (pick any)
.text$mn:00005DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DAC
.text$mn:00005DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DAC
.text$mn:00005DAC ; Attributes: bp-based frame
.text$mn:00005DAC
.text$mn:00005DAC ; public: __thiscall std::allocator<struct MenuItemUnit>::allocator<struct MenuItemUnit>(void)
.text$mn:00005DAC                 public ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ
.text$mn:00005DAC ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ proc near
.text$mn:00005DAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::_Wrap_alloc<std::allocator<MenuItemUnit>>(void)+Ap
.text$mn:00005DAC                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+2Bp
.text$mn:00005DAC
.text$mn:00005DAC var_4           = dword ptr -4
.text$mn:00005DAC
.text$mn:00005DAC                 push    ebp
.text$mn:00005DAD                 mov     ebp, esp
.text$mn:00005DAF                 push    ecx
.text$mn:00005DB0                 mov     [ebp+var_4], ecx
.text$mn:00005DB3                 mov     eax, [ebp+var_4]
.text$mn:00005DB6                 mov     esp, ebp
.text$mn:00005DB8                 pop     ebp
.text$mn:00005DB9                 retn
.text$mn:00005DB9 ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ endp
.text$mn:00005DB9
.text$mn:00005DB9 ; ---------------------------------------------------------------------------
.text$mn:00005DBA                 align 4
.text$mn:00005DBA _text$mn        ends
.text$mn:00005DBA
.text$mn:00005DBC ; ===========================================================================
.text$mn:00005DBC
.text$mn:00005DBC ; Segment type: Pure code
.text$mn:00005DBC ; Segment permissions: Read/Execute
.text$mn:00005DBC _text$mn        segment para public 'CODE' use32
.text$mn:00005DBC                 assume cs:_text$mn
.text$mn:00005DBC                 ;org 5DBCh
.text$mn:00005DBC ; COMDAT (pick any)
.text$mn:00005DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DBC
.text$mn:00005DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DBC
.text$mn:00005DBC ; Attributes: bp-based frame
.text$mn:00005DBC
.text$mn:00005DBC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00005DBC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00005DBC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00005DBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00005DBC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00005DBC
.text$mn:00005DBC var_4           = dword ptr -4
.text$mn:00005DBC
.text$mn:00005DBC                 push    ebp
.text$mn:00005DBD                 mov     ebp, esp
.text$mn:00005DBF                 push    ecx
.text$mn:00005DC0                 mov     [ebp+var_4], ecx
.text$mn:00005DC3                 mov     eax, [ebp+var_4]
.text$mn:00005DC6                 mov     esp, ebp
.text$mn:00005DC8                 pop     ebp
.text$mn:00005DC9                 retn
.text$mn:00005DC9 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00005DC9
.text$mn:00005DC9 ; ---------------------------------------------------------------------------
.text$mn:00005DCA                 align 4
.text$mn:00005DCA _text$mn        ends
.text$mn:00005DCA
.text$mn:00005DCC ; ===========================================================================
.text$mn:00005DCC
.text$mn:00005DCC ; Segment type: Pure code
.text$mn:00005DCC ; Segment permissions: Read/Execute
.text$mn:00005DCC _text$mn        segment para public 'CODE' use32
.text$mn:00005DCC                 assume cs:_text$mn
.text$mn:00005DCC                 ;org 5DCCh
.text$mn:00005DCC ; COMDAT (pick any)
.text$mn:00005DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DCC
.text$mn:00005DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DCC
.text$mn:00005DCC ; Attributes: bp-based frame
.text$mn:00005DCC
.text$mn:00005DCC ; public: __thiscall std::allocator<struct recordedMacroStep>::allocator<struct recordedMacroStep>(class std::allocator<struct recordedMacroStep> const &)
.text$mn:00005DCC                 public ??0?$allocator@UrecordedMacroStep@@@std@@QAE@ABV01@@Z
.text$mn:00005DCC ??0?$allocator@UrecordedMacroStep@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005DCC                                         ; CODE XREF: std::operator==<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)+Bp
.text$mn:00005DCC                                         ; std::operator==<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)+18p ...
.text$mn:00005DCC
.text$mn:00005DCC var_4           = dword ptr -4
.text$mn:00005DCC
.text$mn:00005DCC                 push    ebp
.text$mn:00005DCD                 mov     ebp, esp
.text$mn:00005DCF                 push    ecx
.text$mn:00005DD0                 mov     [ebp+var_4], ecx
.text$mn:00005DD3                 mov     eax, [ebp+var_4]
.text$mn:00005DD6                 mov     esp, ebp
.text$mn:00005DD8                 pop     ebp
.text$mn:00005DD9                 retn    4
.text$mn:00005DD9 ??0?$allocator@UrecordedMacroStep@@@std@@QAE@ABV01@@Z endp
.text$mn:00005DD9
.text$mn:00005DD9 _text$mn        ends
.text$mn:00005DD9
.text$mn:00005DDC ; ===========================================================================
.text$mn:00005DDC
.text$mn:00005DDC ; Segment type: Pure code
.text$mn:00005DDC ; Segment permissions: Read/Execute
.text$mn:00005DDC _text$mn        segment para public 'CODE' use32
.text$mn:00005DDC                 assume cs:_text$mn
.text$mn:00005DDC                 ;org 5DDCh
.text$mn:00005DDC ; COMDAT (pick any)
.text$mn:00005DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DDC
.text$mn:00005DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DDC
.text$mn:00005DDC ; Attributes: bp-based frame
.text$mn:00005DDC
.text$mn:00005DDC ; public: __thiscall std::allocator<struct recordedMacroStep>::allocator<struct recordedMacroStep>(void)
.text$mn:00005DDC                 public ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ
.text$mn:00005DDC ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ proc near
.text$mn:00005DDC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::_Wrap_alloc<std::allocator<recordedMacroStep>>(void)+Ap
.text$mn:00005DDC
.text$mn:00005DDC var_4           = dword ptr -4
.text$mn:00005DDC
.text$mn:00005DDC                 push    ebp
.text$mn:00005DDD                 mov     ebp, esp
.text$mn:00005DDF                 push    ecx
.text$mn:00005DE0                 mov     [ebp+var_4], ecx
.text$mn:00005DE3                 mov     eax, [ebp+var_4]
.text$mn:00005DE6                 mov     esp, ebp
.text$mn:00005DE8                 pop     ebp
.text$mn:00005DE9                 retn
.text$mn:00005DE9 ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ endp
.text$mn:00005DE9
.text$mn:00005DE9 ; ---------------------------------------------------------------------------
.text$mn:00005DEA                 align 4
.text$mn:00005DEA _text$mn        ends
.text$mn:00005DEA
.text$mn:00005DEC ; ===========================================================================
.text$mn:00005DEC
.text$mn:00005DEC ; Segment type: Pure code
.text$mn:00005DEC ; Segment permissions: Read/Execute
.text$mn:00005DEC _text$mn        segment para public 'CODE' use32
.text$mn:00005DEC                 assume cs:_text$mn
.text$mn:00005DEC                 ;org 5DECh
.text$mn:00005DEC ; COMDAT (pick any)
.text$mn:00005DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DEC
.text$mn:00005DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DEC
.text$mn:00005DEC ; Attributes: bp-based frame
.text$mn:00005DEC
.text$mn:00005DEC ; public: __thiscall std::allocator<class MacroShortcut>::allocator<class MacroShortcut>(void)
.text$mn:00005DEC                 public ??0?$allocator@VMacroShortcut@@@std@@QAE@XZ
.text$mn:00005DEC ??0?$allocator@VMacroShortcut@@@std@@QAE@XZ proc near
.text$mn:00005DEC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MacroShortcut>>::_Wrap_alloc<std::allocator<MacroShortcut>>(void)+Ap
.text$mn:00005DEC
.text$mn:00005DEC var_4           = dword ptr -4
.text$mn:00005DEC
.text$mn:00005DEC                 push    ebp
.text$mn:00005DED                 mov     ebp, esp
.text$mn:00005DEF                 push    ecx
.text$mn:00005DF0                 mov     [ebp+var_4], ecx
.text$mn:00005DF3                 mov     eax, [ebp+var_4]
.text$mn:00005DF6                 mov     esp, ebp
.text$mn:00005DF8                 pop     ebp
.text$mn:00005DF9                 retn
.text$mn:00005DF9 ??0?$allocator@VMacroShortcut@@@std@@QAE@XZ endp
.text$mn:00005DF9
.text$mn:00005DF9 ; ---------------------------------------------------------------------------
.text$mn:00005DFA                 align 4
.text$mn:00005DFA _text$mn        ends
.text$mn:00005DFA
.text$mn:00005DFC ; ===========================================================================
.text$mn:00005DFC
.text$mn:00005DFC ; Segment type: Pure code
.text$mn:00005DFC ; Segment permissions: Read/Execute
.text$mn:00005DFC _text$mn        segment para public 'CODE' use32
.text$mn:00005DFC                 assume cs:_text$mn
.text$mn:00005DFC                 ;org 5DFCh
.text$mn:00005DFC ; COMDAT (pick any)
.text$mn:00005DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DFC
.text$mn:00005DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DFC
.text$mn:00005DFC ; Attributes: bp-based frame
.text$mn:00005DFC
.text$mn:00005DFC ; public: __thiscall std::allocator<class UserCommand>::allocator<class UserCommand>(void)
.text$mn:00005DFC                 public ??0?$allocator@VUserCommand@@@std@@QAE@XZ
.text$mn:00005DFC ??0?$allocator@VUserCommand@@@std@@QAE@XZ proc near
.text$mn:00005DFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::_Wrap_alloc<std::allocator<UserCommand>>(void)+Ap
.text$mn:00005DFC
.text$mn:00005DFC var_4           = dword ptr -4
.text$mn:00005DFC
.text$mn:00005DFC                 push    ebp
.text$mn:00005DFD                 mov     ebp, esp
.text$mn:00005DFF                 push    ecx
.text$mn:00005E00                 mov     [ebp+var_4], ecx
.text$mn:00005E03                 mov     eax, [ebp+var_4]
.text$mn:00005E06                 mov     esp, ebp
.text$mn:00005E08                 pop     ebp
.text$mn:00005E09                 retn
.text$mn:00005E09 ??0?$allocator@VUserCommand@@@std@@QAE@XZ endp
.text$mn:00005E09
.text$mn:00005E09 ; ---------------------------------------------------------------------------
.text$mn:00005E0A                 align 4
.text$mn:00005E0A _text$mn        ends
.text$mn:00005E0A
.text$mn:00005E0C ; ===========================================================================
.text$mn:00005E0C
.text$mn:00005E0C ; Segment type: Pure code
.text$mn:00005E0C ; Segment permissions: Read/Execute
.text$mn:00005E0C _text$mn        segment para public 'CODE' use32
.text$mn:00005E0C                 assume cs:_text$mn
.text$mn:00005E0C                 ;org 5E0Ch
.text$mn:00005E0C ; COMDAT (pick any)
.text$mn:00005E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E0C
.text$mn:00005E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E0C
.text$mn:00005E0C ; Attributes: bp-based frame
.text$mn:00005E0C
.text$mn:00005E0C ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00005E0C                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00005E0C ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00005E0C                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Bp
.text$mn:00005E0C                                         ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+18p ...
.text$mn:00005E0C
.text$mn:00005E0C var_4           = dword ptr -4
.text$mn:00005E0C
.text$mn:00005E0C                 push    ebp
.text$mn:00005E0D                 mov     ebp, esp
.text$mn:00005E0F                 push    ecx
.text$mn:00005E10                 mov     [ebp+var_4], ecx
.text$mn:00005E13                 mov     eax, [ebp+var_4]
.text$mn:00005E16                 mov     esp, ebp
.text$mn:00005E18                 pop     ebp
.text$mn:00005E19                 retn    4
.text$mn:00005E19 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00005E19
.text$mn:00005E19 _text$mn        ends
.text$mn:00005E19
.text$mn:00005E1C ; ===========================================================================
.text$mn:00005E1C
.text$mn:00005E1C ; Segment type: Pure code
.text$mn:00005E1C ; Segment permissions: Read/Execute
.text$mn:00005E1C _text$mn        segment para public 'CODE' use32
.text$mn:00005E1C                 assume cs:_text$mn
.text$mn:00005E1C                 ;org 5E1Ch
.text$mn:00005E1C ; COMDAT (pick any)
.text$mn:00005E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E1C
.text$mn:00005E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E1C
.text$mn:00005E1C ; Attributes: bp-based frame
.text$mn:00005E1C
.text$mn:00005E1C ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005E1C                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00005E1C ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00005E1C
.text$mn:00005E1C var_4           = dword ptr -4
.text$mn:00005E1C
.text$mn:00005E1C                 push    ebp
.text$mn:00005E1D                 mov     ebp, esp
.text$mn:00005E1F                 push    ecx
.text$mn:00005E20                 mov     [ebp+var_4], ecx
.text$mn:00005E23                 mov     eax, [ebp+var_4]
.text$mn:00005E26                 mov     esp, ebp
.text$mn:00005E28                 pop     ebp
.text$mn:00005E29                 retn
.text$mn:00005E29 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00005E29
.text$mn:00005E29 ; ---------------------------------------------------------------------------
.text$mn:00005E2A                 align 4
.text$mn:00005E2A _text$mn        ends
.text$mn:00005E2A
.text$mn:00005E2C ; ===========================================================================
.text$mn:00005E2C
.text$mn:00005E2C ; Segment type: Pure code
.text$mn:00005E2C ; Segment permissions: Read/Execute
.text$mn:00005E2C _text$mn        segment para public 'CODE' use32
.text$mn:00005E2C                 assume cs:_text$mn
.text$mn:00005E2C                 ;org 5E2Ch
.text$mn:00005E2C ; COMDAT (pick any)
.text$mn:00005E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E2C
.text$mn:00005E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E2C
.text$mn:00005E2C ; Attributes: bp-based frame
.text$mn:00005E2C
.text$mn:00005E2C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00005E2C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00005E2C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00005E2C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00005E2C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00005E2C
.text$mn:00005E2C var_14          = dword ptr -14h
.text$mn:00005E2C var_D           = byte ptr -0Dh
.text$mn:00005E2C var_C           = dword ptr -0Ch
.text$mn:00005E2C var_4           = dword ptr -4
.text$mn:00005E2C Str             = dword ptr  8
.text$mn:00005E2C
.text$mn:00005E2C                 push    ebp
.text$mn:00005E2D                 mov     ebp, esp
.text$mn:00005E2F                 push    0FFFFFFFFh
.text$mn:00005E31                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00005E36                 mov     eax, large fs:0
.text$mn:00005E3C                 push    eax
.text$mn:00005E3D                 sub     esp, 8
.text$mn:00005E40                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E45                 xor     eax, ebp
.text$mn:00005E47                 push    eax
.text$mn:00005E48                 lea     eax, [ebp+var_C]
.text$mn:00005E4B                 mov     large fs:0, eax
.text$mn:00005E51                 mov     [ebp+var_14], ecx
.text$mn:00005E54                 lea     ecx, [ebp+var_D]
.text$mn:00005E57                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00005E5C                 push    eax
.text$mn:00005E5D                 mov     ecx, [ebp+var_14]
.text$mn:00005E60                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00005E65                 mov     [ebp+var_4], 0
.text$mn:00005E6C                 push    0               ; Size
.text$mn:00005E6E                 push    0               ; char
.text$mn:00005E70                 mov     ecx, [ebp+var_14]
.text$mn:00005E73                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005E78                 mov     eax, [ebp+Str]
.text$mn:00005E7B                 push    eax             ; Str
.text$mn:00005E7C                 mov     ecx, [ebp+var_14]
.text$mn:00005E7F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00005E84                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005E8B                 mov     eax, [ebp+var_14]
.text$mn:00005E8E                 mov     ecx, [ebp+var_C]
.text$mn:00005E91                 mov     large fs:0, ecx
.text$mn:00005E98                 pop     ecx
.text$mn:00005E99                 mov     esp, ebp
.text$mn:00005E9B                 pop     ebp
.text$mn:00005E9C                 retn    4
.text$mn:00005E9C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00005E9C
.text$mn:00005E9C ; ---------------------------------------------------------------------------
.text$mn:00005E9F                 align 10h
.text$mn:00005E9F _text$mn        ends
.text$mn:00005E9F
.text$x:00005EA0 ; ===========================================================================
.text$x:00005EA0
.text$x:00005EA0 ; Segment type: Pure code
.text$x:00005EA0 ; Segment permissions: Read/Execute
.text$x:00005EA0 _text$x         segment para public 'CODE' use32
.text$x:00005EA0                 assume cs:_text$x
.text$x:00005EA0                 ;org 5EA0h
.text$x:00005EA0 ; COMDAT (pick associative to section at 5E2C)
.text$x:00005EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005EA0
.text$x:00005EA0 ; =============== S U B R O U T I N E =======================================
.text$x:00005EA0
.text$x:00005EA0
.text$x:00005EA0 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00005EA0                                         ; DATA XREF: .xdata$x:0000CE2Co
.text$x:00005EA0                 mov     ecx, [ebp-14h]
.text$x:00005EA3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00005EA3 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00005EA3
.text$x:00005EA8
.text$x:00005EA8 ; =============== S U B R O U T I N E =======================================
.text$x:00005EA8
.text$x:00005EA8
.text$x:00005EA8 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00005EA8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00005EA8
.text$x:00005EA8 arg_4           = dword ptr  8
.text$x:00005EA8
.text$x:00005EA8                 mov     edx, [esp+arg_4]
.text$x:00005EAC                 lea     eax, [edx+0Ch]
.text$x:00005EAF                 mov     ecx, [edx-0Ch]
.text$x:00005EB2                 xor     ecx, eax
.text$x:00005EB4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005EB9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00005EBE                 jmp     ___CxxFrameHandler3
.text$x:00005EBE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00005EBE
.text$x:00005EBE ; ---------------------------------------------------------------------------
.text$x:00005EC3                 align 4
.text$x:00005EC3 _text$x         ends
.text$x:00005EC3
.text$mn:00005EC4 ; ===========================================================================
.text$mn:00005EC4
.text$mn:00005EC4 ; Segment type: Pure code
.text$mn:00005EC4 ; Segment permissions: Read/Execute
.text$mn:00005EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00005EC4                 assume cs:_text$mn
.text$mn:00005EC4                 ;org 5EC4h
.text$mn:00005EC4 ; COMDAT (pick any)
.text$mn:00005EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EC4
.text$mn:00005EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EC4
.text$mn:00005EC4 ; Attributes: bp-based frame
.text$mn:00005EC4
.text$mn:00005EC4 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00005EC4                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00005EC4 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:00005EC4                                         ; CODE XREF: MenuItemUnit::MenuItemUnit(MenuItemUnit const &)+3Dp
.text$mn:00005EC4                                         ; MenuItemUnit::MenuItemUnit(MenuItemUnit const &)+56p ...
.text$mn:00005EC4
.text$mn:00005EC4 var_14          = dword ptr -14h
.text$mn:00005EC4 var_E           = byte ptr -0Eh
.text$mn:00005EC4 var_D           = byte ptr -0Dh
.text$mn:00005EC4 var_C           = dword ptr -0Ch
.text$mn:00005EC4 var_4           = dword ptr -4
.text$mn:00005EC4 arg_0           = dword ptr  8
.text$mn:00005EC4
.text$mn:00005EC4                 push    ebp
.text$mn:00005EC5                 mov     ebp, esp
.text$mn:00005EC7                 push    0FFFFFFFFh
.text$mn:00005EC9                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00005ECE                 mov     eax, large fs:0
.text$mn:00005ED4                 push    eax
.text$mn:00005ED5                 sub     esp, 8
.text$mn:00005ED8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005EDD                 xor     eax, ebp
.text$mn:00005EDF                 push    eax
.text$mn:00005EE0                 lea     eax, [ebp+var_C]
.text$mn:00005EE3                 mov     large fs:0, eax
.text$mn:00005EE9                 mov     [ebp+var_14], ecx
.text$mn:00005EEC                 lea     eax, [ebp+var_D]
.text$mn:00005EEF                 push    eax
.text$mn:00005EF0                 lea     ecx, [ebp+var_E]
.text$mn:00005EF3                 push    ecx
.text$mn:00005EF4                 mov     ecx, [ebp+arg_0]
.text$mn:00005EF7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005EFC                 mov     ecx, eax
.text$mn:00005EFE                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:00005F03                 push    eax
.text$mn:00005F04                 mov     ecx, [ebp+var_14]
.text$mn:00005F07                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00005F0C                 mov     [ebp+var_4], 0
.text$mn:00005F13                 push    0
.text$mn:00005F15                 push    0
.text$mn:00005F17                 mov     ecx, [ebp+var_14]
.text$mn:00005F1A                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005F1F                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00005F25                 push    edx
.text$mn:00005F26                 push    0
.text$mn:00005F28                 mov     eax, [ebp+arg_0]
.text$mn:00005F2B                 push    eax
.text$mn:00005F2C                 mov     ecx, [ebp+var_14]
.text$mn:00005F2F                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00005F34                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005F3B                 mov     eax, [ebp+var_14]
.text$mn:00005F3E                 mov     ecx, [ebp+var_C]
.text$mn:00005F41                 mov     large fs:0, ecx
.text$mn:00005F48                 pop     ecx
.text$mn:00005F49                 mov     esp, ebp
.text$mn:00005F4B                 pop     ebp
.text$mn:00005F4C                 retn    4
.text$mn:00005F4C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:00005F4C
.text$mn:00005F4C ; ---------------------------------------------------------------------------
.text$mn:00005F4F                 align 10h
.text$mn:00005F4F _text$mn        ends
.text$mn:00005F4F
.text$x:00005F50 ; ===========================================================================
.text$x:00005F50
.text$x:00005F50 ; Segment type: Pure code
.text$x:00005F50 ; Segment permissions: Read/Execute
.text$x:00005F50 _text$x         segment para public 'CODE' use32
.text$x:00005F50                 assume cs:_text$x
.text$x:00005F50                 ;org 5F50h
.text$x:00005F50 ; COMDAT (pick associative to section at 5EC4)
.text$x:00005F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005F50
.text$x:00005F50 ; =============== S U B R O U T I N E =======================================
.text$x:00005F50
.text$x:00005F50
.text$x:00005F50 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005F50                                         ; DATA XREF: .xdata$x:0000D14Co
.text$x:00005F50                 mov     ecx, [ebp-14h]
.text$x:00005F53                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00005F53 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005F53
.text$x:00005F58
.text$x:00005F58 ; =============== S U B R O U T I N E =======================================
.text$x:00005F58
.text$x:00005F58
.text$x:00005F58 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:00005F58                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00005F58
.text$x:00005F58 arg_4           = dword ptr  8
.text$x:00005F58
.text$x:00005F58                 mov     edx, [esp+arg_4]
.text$x:00005F5C                 lea     eax, [edx+0Ch]
.text$x:00005F5F                 mov     ecx, [edx-0Ch]
.text$x:00005F62                 xor     ecx, eax
.text$x:00005F64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005F69                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:00005F6E                 jmp     ___CxxFrameHandler3
.text$x:00005F6E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:00005F6E
.text$x:00005F6E ; ---------------------------------------------------------------------------
.text$x:00005F73                 align 4
.text$x:00005F73 _text$x         ends
.text$x:00005F73
.text$mn:00005F74 ; ===========================================================================
.text$mn:00005F74
.text$mn:00005F74 ; Segment type: Pure code
.text$mn:00005F74 ; Segment permissions: Read/Execute
.text$mn:00005F74 _text$mn        segment para public 'CODE' use32
.text$mn:00005F74                 assume cs:_text$mn
.text$mn:00005F74                 ;org 5F74h
.text$mn:00005F74 ; COMDAT (pick any)
.text$mn:00005F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F74
.text$mn:00005F74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F74
.text$mn:00005F74 ; Attributes: bp-based frame
.text$mn:00005F74
.text$mn:00005F74 ; public: __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>(class std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>> const &)
.text$mn:00005F74                 public ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005F74 ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005F74                                         ; CODE XREF: ScintillaKeyMap::ScintillaKeyMap(ScintillaKeyMap const &)+79p
.text$mn:00005F74
.text$mn:00005F74 var_34          = dword ptr -34h
.text$mn:00005F74 var_30          = dword ptr -30h
.text$mn:00005F74 var_2C          = dword ptr -2Ch
.text$mn:00005F74 var_28          = dword ptr -28h
.text$mn:00005F74 var_24          = dword ptr -24h
.text$mn:00005F74 var_20          = dword ptr -20h
.text$mn:00005F74 var_1C          = dword ptr -1Ch
.text$mn:00005F74 var_18          = dword ptr -18h
.text$mn:00005F74 var_12          = byte ptr -12h
.text$mn:00005F74 var_11          = byte ptr -11h
.text$mn:00005F74 var_10          = dword ptr -10h
.text$mn:00005F74 var_C           = dword ptr -0Ch
.text$mn:00005F74 var_4           = dword ptr -4
.text$mn:00005F74 arg_0           = dword ptr  8
.text$mn:00005F74
.text$mn:00005F74 ; FUNCTION CHUNK AT .text$mn:0000605E SIZE 00000009 BYTES
.text$mn:00005F74 ; FUNCTION CHUNK AT .text$mn:0000606E SIZE 0000001E BYTES
.text$mn:00005F74
.text$mn:00005F74                 push    ebp
.text$mn:00005F75                 mov     ebp, esp
.text$mn:00005F77                 push    0FFFFFFFFh
.text$mn:00005F79                 push    offset __ehhandler$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005F7E                 mov     eax, large fs:0
.text$mn:00005F84                 push    eax
.text$mn:00005F85                 push    ecx
.text$mn:00005F86                 sub     esp, 24h
.text$mn:00005F89                 push    ebx
.text$mn:00005F8A                 push    esi
.text$mn:00005F8B                 push    edi
.text$mn:00005F8C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005F91                 xor     eax, ebp
.text$mn:00005F93                 push    eax
.text$mn:00005F94                 lea     eax, [ebp+var_C]
.text$mn:00005F97                 mov     large fs:0, eax
.text$mn:00005F9D                 mov     [ebp+var_10], esp
.text$mn:00005FA0                 mov     [ebp+var_18], ecx
.text$mn:00005FA3                 lea     eax, [ebp+var_11]
.text$mn:00005FA6                 push    eax
.text$mn:00005FA7                 lea     ecx, [ebp+var_12]
.text$mn:00005FAA                 push    ecx
.text$mn:00005FAB                 mov     ecx, [ebp+arg_0]
.text$mn:00005FAE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:00005FB3                 mov     ecx, eax
.text$mn:00005FB5                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<KeyCombo>>::select_on_container_copy_construction(void)
.text$mn:00005FBA                 push    eax
.text$mn:00005FBB                 mov     ecx, [ebp+var_18]
.text$mn:00005FBE                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(std::allocator<KeyCombo> const &)
.text$mn:00005FC3                 mov     [ebp+var_4], 0
.text$mn:00005FCA                 mov     ecx, [ebp+arg_0]
.text$mn:00005FCD                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00005FD2                 push    eax
.text$mn:00005FD3                 mov     ecx, [ebp+var_18]
.text$mn:00005FD6                 call    ?_Buy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAE_NI@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)
.text$mn:00005FDB                 movzx   edx, al
.text$mn:00005FDE                 test    edx, edx
.text$mn:00005FE0                 jz      loc_606E
.text$mn:00005FE6                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005FEA                 mov     eax, [ebp+var_18]
.text$mn:00005FED                 mov     ecx, [eax+4]
.text$mn:00005FF0                 push    ecx
.text$mn:00005FF1                 sub     esp, 0Ch
.text$mn:00005FF4                 mov     edx, esp
.text$mn:00005FF6                 mov     [ebp+var_28], esp
.text$mn:00005FF9                 push    edx
.text$mn:00005FFA                 mov     ecx, [ebp+arg_0]
.text$mn:00005FFD                 call    ?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::end(void)
.text$mn:00006002                 mov     [ebp+var_1C], eax
.text$mn:00006005                 mov     eax, [ebp+var_1C]
.text$mn:00006008                 mov     [ebp+var_2C], eax
.text$mn:0000600B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000600F                 sub     esp, 0Ch
.text$mn:00006012                 mov     ecx, esp
.text$mn:00006014                 mov     [ebp+var_30], esp
.text$mn:00006017                 push    ecx
.text$mn:00006018                 mov     ecx, [ebp+arg_0]
.text$mn:0000601B                 call    ?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::begin(void)
.text$mn:00006020                 mov     [ebp+var_20], eax
.text$mn:00006023                 mov     edx, [ebp+var_20]
.text$mn:00006026                 mov     [ebp+var_34], edx
.text$mn:00006029                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000602D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00006031                 mov     ecx, [ebp+var_18]
.text$mn:00006034                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)
.text$mn:00006039                 mov     [ebp+var_24], eax
.text$mn:0000603C                 mov     eax, [ebp+var_18]
.text$mn:0000603F                 mov     ecx, [ebp+var_24]
.text$mn:00006042                 mov     [eax+8], ecx
.text$mn:00006045                 jmp     short loc_605E
.text$mn:00006045 ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00006045
.text$mn:00006047
.text$mn:00006047 ; =============== S U B R O U T I N E =======================================
.text$mn:00006047
.text$mn:00006047 ; Attributes: noreturn
.text$mn:00006047
.text$mn:00006047 __catch$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:00006047                                         ; DATA XREF: .xdata$x:0000D398o
.text$mn:00006047                 mov     ecx, [ebp-18h]
.text$mn:0000604A                 call    ?_Tidy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Tidy(void)
.text$mn:0000604F                 push    0
.text$mn:00006051                 push    0
.text$mn:00006053                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006053 __catch$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:00006053
.text$mn:00006058 ; ---------------------------------------------------------------------------
.text$mn:00006058                 mov     eax, offset $LN11
.text$mn:0000605D                 retn
.text$mn:0000605E ; ---------------------------------------------------------------------------
.text$mn:0000605E ; START OF FUNCTION CHUNK FOR ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000605E
.text$mn:0000605E loc_605E:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+D1j
.text$mn:0000605E                 mov     [ebp+var_4], 0
.text$mn:00006065                 jmp     short loc_606E
.text$mn:00006065 ; END OF FUNCTION CHUNK FOR ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00006067
.text$mn:00006067 ; =============== S U B R O U T I N E =======================================
.text$mn:00006067
.text$mn:00006067
.text$mn:00006067 $LN11           proc near               ; DATA XREF: .text$mn:00006058o
.text$mn:00006067                 mov     dword ptr [ebp-4], 0
.text$mn:00006067 $LN11           endp ; sp-analysis failed
.text$mn:00006067
.text$mn:0000606E ; START OF FUNCTION CHUNK FOR ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000606E
.text$mn:0000606E loc_606E:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+6Cj
.text$mn:0000606E                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+F1j
.text$mn:0000606E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006075                 mov     eax, [ebp+var_18]
.text$mn:00006078                 mov     ecx, [ebp+var_C]
.text$mn:0000607B                 mov     large fs:0, ecx
.text$mn:00006082                 pop     ecx
.text$mn:00006083                 pop     edi
.text$mn:00006084                 pop     esi
.text$mn:00006085                 pop     ebx
.text$mn:00006086                 mov     esp, ebp
.text$mn:00006088                 pop     ebp
.text$mn:00006089                 retn    4
.text$mn:00006089 ; END OF FUNCTION CHUNK FOR ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00006089 _text$mn        ends
.text$mn:00006089
.text$x:0000608C ; ===========================================================================
.text$x:0000608C
.text$x:0000608C ; Segment type: Pure code
.text$x:0000608C ; Segment permissions: Read/Execute
.text$x:0000608C _text$x         segment para public 'CODE' use32
.text$x:0000608C                 assume cs:_text$x
.text$x:0000608C                 ;org 608Ch
.text$x:0000608C ; COMDAT (pick associative to section at 5F74)
.text$x:0000608C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000608C
.text$x:0000608C ; =============== S U B R O U T I N E =======================================
.text$x:0000608C
.text$x:0000608C
.text$x:0000608C __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:0000608C                                         ; DATA XREF: .xdata$x:0000D3D8o
.text$x:0000608C                 mov     ecx, [ebp-18h]
.text$x:0000608F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::~_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(void)
.text$x:0000608F __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:0000608F
.text$x:00006094
.text$x:00006094 ; =============== S U B R O U T I N E =======================================
.text$x:00006094
.text$x:00006094
.text$x:00006094 __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:00006094                                         ; DATA XREF: .xdata$x:0000D3E8o
.text$x:00006094                 mov     ecx, [ebp-28h]
.text$x:00006097                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:00006097 __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:00006097
.text$x:0000609C
.text$x:0000609C ; =============== S U B R O U T I N E =======================================
.text$x:0000609C
.text$x:0000609C
.text$x:0000609C __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:0000609C                                         ; DATA XREF: .xdata$x:0000D3F0o
.text$x:0000609C                 mov     ecx, [ebp-30h]
.text$x:0000609F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:0000609F __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:0000609F
.text$x:000060A4
.text$x:000060A4 ; =============== S U B R O U T I N E =======================================
.text$x:000060A4
.text$x:000060A4
.text$x:000060A4 __ehhandler$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000060A4                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+5o
.text$x:000060A4
.text$x:000060A4 arg_4           = dword ptr  8
.text$x:000060A4
.text$x:000060A4                 mov     edx, [esp+arg_4]
.text$x:000060A8                 lea     eax, [edx+0Ch]
.text$x:000060AB                 mov     ecx, [edx-38h]
.text$x:000060AE                 xor     ecx, eax
.text$x:000060B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000060B5                 mov     eax, offset __ehfuncinfo$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.text$x:000060BA                 jmp     ___CxxFrameHandler3
.text$x:000060BA __ehhandler$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000060BA
.text$x:000060BA ; ---------------------------------------------------------------------------
.text$x:000060BF                 align 10h
.text$x:000060BF _text$x         ends
.text$x:000060BF
.text$mn:000060C0 ; ===========================================================================
.text$mn:000060C0
.text$mn:000060C0 ; Segment type: Pure code
.text$mn:000060C0 ; Segment permissions: Read/Execute
.text$mn:000060C0 _text$mn        segment para public 'CODE' use32
.text$mn:000060C0                 assume cs:_text$mn
.text$mn:000060C0                 ;org 60C0h
.text$mn:000060C0 ; COMDAT (pick any)
.text$mn:000060C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060C0
.text$mn:000060C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060C0
.text$mn:000060C0 ; Attributes: bp-based frame
.text$mn:000060C0
.text$mn:000060C0 ; public: __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>(void)
.text$mn:000060C0                 public ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:000060C0 ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:000060C0                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+F9Ap
.text$mn:000060C0
.text$mn:000060C0 var_14          = dword ptr -14h
.text$mn:000060C0 var_D           = byte ptr -0Dh
.text$mn:000060C0 var_C           = dword ptr -0Ch
.text$mn:000060C0 var_4           = dword ptr -4
.text$mn:000060C0
.text$mn:000060C0                 push    ebp
.text$mn:000060C1                 mov     ebp, esp
.text$mn:000060C3                 push    0FFFFFFFFh
.text$mn:000060C5                 push    offset __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:000060CA                 mov     eax, large fs:0
.text$mn:000060D0                 push    eax
.text$mn:000060D1                 sub     esp, 8
.text$mn:000060D4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000060D9                 xor     eax, ebp
.text$mn:000060DB                 push    eax
.text$mn:000060DC                 lea     eax, [ebp+var_C]
.text$mn:000060DF                 mov     large fs:0, eax
.text$mn:000060E5                 mov     [ebp+var_14], ecx
.text$mn:000060E8                 lea     ecx, [ebp+var_D]
.text$mn:000060EB                 call    ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ ; std::allocator<MenuItemUnit>::allocator<MenuItemUnit>(void)
.text$mn:000060F0                 push    eax
.text$mn:000060F1                 mov     ecx, [ebp+var_14]
.text$mn:000060F4                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)
.text$mn:000060F9                 mov     [ebp+var_4], 0
.text$mn:00006100                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006107                 mov     eax, [ebp+var_14]
.text$mn:0000610A                 mov     ecx, [ebp+var_C]
.text$mn:0000610D                 mov     large fs:0, ecx
.text$mn:00006114                 pop     ecx
.text$mn:00006115                 mov     esp, ebp
.text$mn:00006117                 pop     ebp
.text$mn:00006118                 retn
.text$mn:00006118 ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:00006118
.text$mn:00006118 ; ---------------------------------------------------------------------------
.text$mn:00006119                 align 4
.text$mn:00006119 _text$mn        ends
.text$mn:00006119
.text$x:0000611C ; ===========================================================================
.text$x:0000611C
.text$x:0000611C ; Segment type: Pure code
.text$x:0000611C ; Segment permissions: Read/Execute
.text$x:0000611C _text$x         segment para public 'CODE' use32
.text$x:0000611C                 assume cs:_text$x
.text$x:0000611C                 ;org 611Ch
.text$x:0000611C ; COMDAT (pick associative to section at 60C0)
.text$x:0000611C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000611C
.text$x:0000611C ; =============== S U B R O U T I N E =======================================
.text$x:0000611C
.text$x:0000611C
.text$x:0000611C __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000611C                                         ; DATA XREF: .xdata$x:0000DDECo
.text$x:0000611C                 mov     ecx, [ebp-14h]
.text$x:0000611F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)
.text$x:0000611F __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000611F
.text$x:00006124
.text$x:00006124 ; =============== S U B R O U T I N E =======================================
.text$x:00006124
.text$x:00006124
.text$x:00006124 __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:00006124                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+5o
.text$x:00006124
.text$x:00006124 arg_4           = dword ptr  8
.text$x:00006124
.text$x:00006124                 mov     edx, [esp+arg_4]
.text$x:00006128                 lea     eax, [edx+0Ch]
.text$x:0000612B                 mov     ecx, [edx-0Ch]
.text$x:0000612E                 xor     ecx, eax
.text$x:00006130                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006135                 mov     eax, offset __ehfuncinfo$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:0000613A                 jmp     ___CxxFrameHandler3
.text$x:0000613A __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:0000613A
.text$x:0000613A ; ---------------------------------------------------------------------------
.text$x:0000613F                 align 10h
.text$x:0000613F _text$x         ends
.text$x:0000613F
.text$mn:00006140 ; ===========================================================================
.text$mn:00006140
.text$mn:00006140 ; Segment type: Pure code
.text$mn:00006140 ; Segment permissions: Read/Execute
.text$mn:00006140 _text$mn        segment para public 'CODE' use32
.text$mn:00006140                 assume cs:_text$mn
.text$mn:00006140                 ;org 6140h
.text$mn:00006140 ; COMDAT (pick any)
.text$mn:00006140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006140
.text$mn:00006140 ; =============== S U B R O U T I N E =======================================
.text$mn:00006140
.text$mn:00006140 ; Attributes: bp-based frame
.text$mn:00006140
.text$mn:00006140 ; public: __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>(class std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>> const &)
.text$mn:00006140                 public ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00006140 ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00006140                                         ; CODE XREF: MacroShortcut::MacroShortcut(MacroShortcut const &)+55p
.text$mn:00006140
.text$mn:00006140 var_34          = dword ptr -34h
.text$mn:00006140 var_30          = dword ptr -30h
.text$mn:00006140 var_2C          = dword ptr -2Ch
.text$mn:00006140 var_28          = dword ptr -28h
.text$mn:00006140 var_24          = dword ptr -24h
.text$mn:00006140 var_20          = dword ptr -20h
.text$mn:00006140 var_1C          = dword ptr -1Ch
.text$mn:00006140 var_18          = dword ptr -18h
.text$mn:00006140 var_12          = byte ptr -12h
.text$mn:00006140 var_11          = byte ptr -11h
.text$mn:00006140 var_10          = dword ptr -10h
.text$mn:00006140 var_C           = dword ptr -0Ch
.text$mn:00006140 var_4           = dword ptr -4
.text$mn:00006140 arg_0           = dword ptr  8
.text$mn:00006140
.text$mn:00006140 ; FUNCTION CHUNK AT .text$mn:0000622A SIZE 00000009 BYTES
.text$mn:00006140 ; FUNCTION CHUNK AT .text$mn:0000623A SIZE 0000001E BYTES
.text$mn:00006140
.text$mn:00006140                 push    ebp
.text$mn:00006141                 mov     ebp, esp
.text$mn:00006143                 push    0FFFFFFFFh
.text$mn:00006145                 push    offset __ehhandler$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000614A                 mov     eax, large fs:0
.text$mn:00006150                 push    eax
.text$mn:00006151                 push    ecx
.text$mn:00006152                 sub     esp, 24h
.text$mn:00006155                 push    ebx
.text$mn:00006156                 push    esi
.text$mn:00006157                 push    edi
.text$mn:00006158                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000615D                 xor     eax, ebp
.text$mn:0000615F                 push    eax
.text$mn:00006160                 lea     eax, [ebp+var_C]
.text$mn:00006163                 mov     large fs:0, eax
.text$mn:00006169                 mov     [ebp+var_10], esp
.text$mn:0000616C                 mov     [ebp+var_18], ecx
.text$mn:0000616F                 lea     eax, [ebp+var_11]
.text$mn:00006172                 push    eax
.text$mn:00006173                 lea     ecx, [ebp+var_12]
.text$mn:00006176                 push    ecx
.text$mn:00006177                 mov     ecx, [ebp+arg_0]
.text$mn:0000617A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000617F                 mov     ecx, eax
.text$mn:00006181                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::select_on_container_copy_construction(void)
.text$mn:00006186                 push    eax
.text$mn:00006187                 mov     ecx, [ebp+var_18]
.text$mn:0000618A                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(std::allocator<recordedMacroStep> const &)
.text$mn:0000618F                 mov     [ebp+var_4], 0
.text$mn:00006196                 mov     ecx, [ebp+arg_0]
.text$mn:00006199                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:0000619E                 push    eax
.text$mn:0000619F                 mov     ecx, [ebp+var_18]
.text$mn:000061A2                 call    ?_Buy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAE_NI@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)
.text$mn:000061A7                 movzx   edx, al
.text$mn:000061AA                 test    edx, edx
.text$mn:000061AC                 jz      loc_623A
.text$mn:000061B2                 mov     byte ptr [ebp+var_4], 1
.text$mn:000061B6                 mov     eax, [ebp+var_18]
.text$mn:000061B9                 mov     ecx, [eax+4]
.text$mn:000061BC                 push    ecx
.text$mn:000061BD                 sub     esp, 0Ch
.text$mn:000061C0                 mov     edx, esp
.text$mn:000061C2                 mov     [ebp+var_28], esp
.text$mn:000061C5                 push    edx
.text$mn:000061C6                 mov     ecx, [ebp+arg_0]
.text$mn:000061C9                 call    ?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::end(void)
.text$mn:000061CE                 mov     [ebp+var_1C], eax
.text$mn:000061D1                 mov     eax, [ebp+var_1C]
.text$mn:000061D4                 mov     [ebp+var_2C], eax
.text$mn:000061D7                 mov     byte ptr [ebp+var_4], 2
.text$mn:000061DB                 sub     esp, 0Ch
.text$mn:000061DE                 mov     ecx, esp
.text$mn:000061E0                 mov     [ebp+var_30], esp
.text$mn:000061E3                 push    ecx
.text$mn:000061E4                 mov     ecx, [ebp+arg_0]
.text$mn:000061E7                 call    ?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::begin(void)
.text$mn:000061EC                 mov     [ebp+var_20], eax
.text$mn:000061EF                 mov     edx, [ebp+var_20]
.text$mn:000061F2                 mov     [ebp+var_34], edx
.text$mn:000061F5                 mov     byte ptr [ebp+var_4], 3
.text$mn:000061F9                 mov     byte ptr [ebp+var_4], 1
.text$mn:000061FD                 mov     ecx, [ebp+var_18]
.text$mn:00006200                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)
.text$mn:00006205                 mov     [ebp+var_24], eax
.text$mn:00006208                 mov     eax, [ebp+var_18]
.text$mn:0000620B                 mov     ecx, [ebp+var_24]
.text$mn:0000620E                 mov     [eax+8], ecx
.text$mn:00006211                 jmp     short loc_622A
.text$mn:00006211 ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00006211
.text$mn:00006213
.text$mn:00006213 ; =============== S U B R O U T I N E =======================================
.text$mn:00006213
.text$mn:00006213 ; Attributes: noreturn
.text$mn:00006213
.text$mn:00006213 __catch$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:00006213                                         ; DATA XREF: .xdata$x:0000D788o
.text$mn:00006213                 mov     ecx, [ebp-18h]
.text$mn:00006216                 call    ?_Tidy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Tidy(void)
.text$mn:0000621B                 push    0
.text$mn:0000621D                 push    0
.text$mn:0000621F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000621F __catch$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:0000621F
.text$mn:00006224 ; ---------------------------------------------------------------------------
.text$mn:00006224                 mov     eax, offset $LN11_0
.text$mn:00006229                 retn
.text$mn:0000622A ; ---------------------------------------------------------------------------
.text$mn:0000622A ; START OF FUNCTION CHUNK FOR ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000622A
.text$mn:0000622A loc_622A:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+D1j
.text$mn:0000622A                 mov     [ebp+var_4], 0
.text$mn:00006231                 jmp     short loc_623A
.text$mn:00006231 ; END OF FUNCTION CHUNK FOR ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00006233
.text$mn:00006233 ; =============== S U B R O U T I N E =======================================
.text$mn:00006233
.text$mn:00006233
.text$mn:00006233 $LN11_0         proc near               ; DATA XREF: .text$mn:00006224o
.text$mn:00006233                 mov     dword ptr [ebp-4], 0
.text$mn:00006233 $LN11_0         endp ; sp-analysis failed
.text$mn:00006233
.text$mn:0000623A ; START OF FUNCTION CHUNK FOR ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000623A
.text$mn:0000623A loc_623A:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+6Cj
.text$mn:0000623A                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+F1j
.text$mn:0000623A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006241                 mov     eax, [ebp+var_18]
.text$mn:00006244                 mov     ecx, [ebp+var_C]
.text$mn:00006247                 mov     large fs:0, ecx
.text$mn:0000624E                 pop     ecx
.text$mn:0000624F                 pop     edi
.text$mn:00006250                 pop     esi
.text$mn:00006251                 pop     ebx
.text$mn:00006252                 mov     esp, ebp
.text$mn:00006254                 pop     ebp
.text$mn:00006255                 retn    4
.text$mn:00006255 ; END OF FUNCTION CHUNK FOR ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00006255 _text$mn        ends
.text$mn:00006255
.text$x:00006258 ; ===========================================================================
.text$x:00006258
.text$x:00006258 ; Segment type: Pure code
.text$x:00006258 ; Segment permissions: Read/Execute
.text$x:00006258 _text$x         segment para public 'CODE' use32
.text$x:00006258                 assume cs:_text$x
.text$x:00006258                 ;org 6258h
.text$x:00006258 ; COMDAT (pick associative to section at 6140)
.text$x:00006258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006258
.text$x:00006258 ; =============== S U B R O U T I N E =======================================
.text$x:00006258
.text$x:00006258
.text$x:00006258 __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:00006258                                         ; DATA XREF: .xdata$x:0000D7C8o
.text$x:00006258                 mov     ecx, [ebp-18h]
.text$x:0000625B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::~_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(void)
.text$x:0000625B __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:0000625B
.text$x:00006260
.text$x:00006260 ; =============== S U B R O U T I N E =======================================
.text$x:00006260
.text$x:00006260
.text$x:00006260 __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:00006260                                         ; DATA XREF: .xdata$x:0000D7D8o
.text$x:00006260                 mov     ecx, [ebp-28h]
.text$x:00006263                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:00006263 __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:00006263
.text$x:00006268
.text$x:00006268 ; =============== S U B R O U T I N E =======================================
.text$x:00006268
.text$x:00006268
.text$x:00006268 __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:00006268                                         ; DATA XREF: .xdata$x:0000D7E0o
.text$x:00006268                 mov     ecx, [ebp-30h]
.text$x:0000626B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:0000626B __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:0000626B
.text$x:00006270
.text$x:00006270 ; =============== S U B R O U T I N E =======================================
.text$x:00006270
.text$x:00006270
.text$x:00006270 __ehhandler$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00006270                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+5o
.text$x:00006270
.text$x:00006270 arg_4           = dword ptr  8
.text$x:00006270
.text$x:00006270                 mov     edx, [esp+arg_4]
.text$x:00006274                 lea     eax, [edx+0Ch]
.text$x:00006277                 mov     ecx, [edx-38h]
.text$x:0000627A                 xor     ecx, eax
.text$x:0000627C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006281                 mov     eax, offset __ehfuncinfo$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.text$x:00006286                 jmp     ___CxxFrameHandler3
.text$x:00006286 __ehhandler$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00006286
.text$x:00006286 ; ---------------------------------------------------------------------------
.text$x:0000628B                 align 4
.text$x:0000628B _text$x         ends
.text$x:0000628B
.text$mn:0000628C ; ===========================================================================
.text$mn:0000628C
.text$mn:0000628C ; Segment type: Pure code
.text$mn:0000628C ; Segment permissions: Read/Execute
.text$mn:0000628C _text$mn        segment para public 'CODE' use32
.text$mn:0000628C                 assume cs:_text$mn
.text$mn:0000628C                 ;org 628Ch
.text$mn:0000628C ; COMDAT (pick any)
.text$mn:0000628C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000628C
.text$mn:0000628C ; =============== S U B R O U T I N E =======================================
.text$mn:0000628C
.text$mn:0000628C ; Attributes: bp-based frame
.text$mn:0000628C
.text$mn:0000628C ; int __stdcall CommandShortcut::CommandShortcut(Shortcut *)
.text$mn:0000628C                 public ??0CommandShortcut@@QAE@ABV0@@Z
.text$mn:0000628C ??0CommandShortcut@@QAE@ABV0@@Z proc near
.text$mn:0000628C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+269p
.text$mn:0000628C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+291p ...
.text$mn:0000628C
.text$mn:0000628C var_10          = dword ptr -10h
.text$mn:0000628C var_C           = dword ptr -0Ch
.text$mn:0000628C var_4           = dword ptr -4
.text$mn:0000628C arg_0           = dword ptr  8
.text$mn:0000628C
.text$mn:0000628C                 push    ebp
.text$mn:0000628D                 mov     ebp, esp
.text$mn:0000628F                 push    0FFFFFFFFh
.text$mn:00006291                 push    offset __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z
.text$mn:00006296                 mov     eax, large fs:0
.text$mn:0000629C                 push    eax
.text$mn:0000629D                 push    ecx
.text$mn:0000629E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000062A3                 xor     eax, ebp
.text$mn:000062A5                 push    eax
.text$mn:000062A6                 lea     eax, [ebp+var_C]
.text$mn:000062A9                 mov     large fs:0, eax
.text$mn:000062AF                 mov     [ebp+var_10], ecx
.text$mn:000062B2                 mov     eax, [ebp+arg_0]
.text$mn:000062B5                 push    eax             ; Shortcut *
.text$mn:000062B6                 mov     ecx, [ebp+var_10]
.text$mn:000062B9                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:000062BE                 mov     [ebp+var_4], 0
.text$mn:000062C5                 mov     ecx, [ebp+var_10]
.text$mn:000062C8                 mov     dword ptr [ecx], offset ??_7CommandShortcut@@6B@ ; const CommandShortcut::`vftable'
.text$mn:000062CE                 mov     edx, [ebp+var_10]
.text$mn:000062D1                 mov     eax, [ebp+arg_0]
.text$mn:000062D4                 mov     ecx, [eax+128h]
.text$mn:000062DA                 mov     [edx+128h], ecx
.text$mn:000062E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000062E7                 mov     eax, [ebp+var_10]
.text$mn:000062EA                 mov     ecx, [ebp+var_C]
.text$mn:000062ED                 mov     large fs:0, ecx
.text$mn:000062F4                 pop     ecx
.text$mn:000062F5                 mov     esp, ebp
.text$mn:000062F7                 pop     ebp
.text$mn:000062F8                 retn    4
.text$mn:000062F8 ??0CommandShortcut@@QAE@ABV0@@Z endp
.text$mn:000062F8
.text$mn:000062F8 ; ---------------------------------------------------------------------------
.text$mn:000062FB                 align 4
.text$mn:000062FB _text$mn        ends
.text$mn:000062FB
.text$x:000062FC ; ===========================================================================
.text$x:000062FC
.text$x:000062FC ; Segment type: Pure code
.text$x:000062FC ; Segment permissions: Read/Execute
.text$x:000062FC _text$x         segment para public 'CODE' use32
.text$x:000062FC                 assume cs:_text$x
.text$x:000062FC                 ;org 62FCh
.text$x:000062FC ; COMDAT (pick associative to section at 628C)
.text$x:000062FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000062FC
.text$x:000062FC ; =============== S U B R O U T I N E =======================================
.text$x:000062FC
.text$x:000062FC
.text$x:000062FC __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0 proc near
.text$x:000062FC                                         ; DATA XREF: .xdata$x:0000D2B4o
.text$x:000062FC                 mov     ecx, [ebp-10h]  ; this
.text$x:000062FF                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:000062FF __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0 endp
.text$x:000062FF
.text$x:00006304
.text$x:00006304 ; =============== S U B R O U T I N E =======================================
.text$x:00006304
.text$x:00006304
.text$x:00006304 __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z proc near
.text$x:00006304                                         ; DATA XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+5o
.text$x:00006304
.text$x:00006304 arg_4           = dword ptr  8
.text$x:00006304
.text$x:00006304                 mov     edx, [esp+arg_4]
.text$x:00006308                 lea     eax, [edx+0Ch]
.text$x:0000630B                 mov     ecx, [edx-8]
.text$x:0000630E                 xor     ecx, eax
.text$x:00006310                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006315                 mov     eax, offset __ehfuncinfo$??0CommandShortcut@@QAE@ABV0@@Z
.text$x:0000631A                 jmp     ___CxxFrameHandler3
.text$x:0000631A __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z endp
.text$x:0000631A
.text$x:0000631A ; ---------------------------------------------------------------------------
.text$x:0000631F                 align 10h
.text$x:0000631F _text$x         ends
.text$x:0000631F
.text$mn:00006320 ; ===========================================================================
.text$mn:00006320
.text$mn:00006320 ; Segment type: Pure code
.text$mn:00006320 ; Segment permissions: Read/Execute
.text$mn:00006320 _text$mn        segment para public 'CODE' use32
.text$mn:00006320                 assume cs:_text$mn
.text$mn:00006320                 ;org 6320h
.text$mn:00006320 ; COMDAT (pick any)
.text$mn:00006320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006320
.text$mn:00006320 ; =============== S U B R O U T I N E =======================================
.text$mn:00006320
.text$mn:00006320 ; Attributes: bp-based frame
.text$mn:00006320
.text$mn:00006320 ; int __stdcall MacroShortcut::MacroShortcut(Shortcut *)
.text$mn:00006320                 public ??0MacroShortcut@@QAE@ABV0@@Z
.text$mn:00006320 ??0MacroShortcut@@QAE@ABV0@@Z proc near ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+3D6p
.text$mn:00006320                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+3FEp ...
.text$mn:00006320
.text$mn:00006320 var_10          = dword ptr -10h
.text$mn:00006320 var_C           = dword ptr -0Ch
.text$mn:00006320 var_4           = dword ptr -4
.text$mn:00006320 arg_0           = dword ptr  8
.text$mn:00006320
.text$mn:00006320                 push    ebp
.text$mn:00006321                 mov     ebp, esp
.text$mn:00006323                 push    0FFFFFFFFh
.text$mn:00006325                 push    offset __ehhandler$??0MacroShortcut@@QAE@ABV0@@Z
.text$mn:0000632A                 mov     eax, large fs:0
.text$mn:00006330                 push    eax
.text$mn:00006331                 push    ecx
.text$mn:00006332                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006337                 xor     eax, ebp
.text$mn:00006339                 push    eax
.text$mn:0000633A                 lea     eax, [ebp+var_C]
.text$mn:0000633D                 mov     large fs:0, eax
.text$mn:00006343                 mov     [ebp+var_10], ecx
.text$mn:00006346                 mov     eax, [ebp+arg_0]
.text$mn:00006349                 push    eax             ; Shortcut *
.text$mn:0000634A                 mov     ecx, [ebp+var_10]
.text$mn:0000634D                 call    ??0CommandShortcut@@QAE@ABV0@@Z ; CommandShortcut::CommandShortcut(CommandShortcut const &)
.text$mn:00006352                 mov     [ebp+var_4], 0
.text$mn:00006359                 mov     ecx, [ebp+var_10]
.text$mn:0000635C                 mov     dword ptr [ecx], offset ??_7MacroShortcut@@6B@ ; const MacroShortcut::`vftable'
.text$mn:00006362                 mov     edx, [ebp+arg_0]
.text$mn:00006365                 add     edx, 12Ch
.text$mn:0000636B                 push    edx
.text$mn:0000636C                 mov     ecx, [ebp+var_10]
.text$mn:0000636F                 add     ecx, 12Ch
.text$mn:00006375                 call    ??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)
.text$mn:0000637A                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000637E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006385                 mov     eax, [ebp+var_10]
.text$mn:00006388                 mov     ecx, [ebp+var_C]
.text$mn:0000638B                 mov     large fs:0, ecx
.text$mn:00006392                 pop     ecx
.text$mn:00006393                 mov     esp, ebp
.text$mn:00006395                 pop     ebp
.text$mn:00006396                 retn    4
.text$mn:00006396 ??0MacroShortcut@@QAE@ABV0@@Z endp
.text$mn:00006396
.text$mn:00006396 ; ---------------------------------------------------------------------------
.text$mn:00006399                 align 4
.text$mn:00006399 _text$mn        ends
.text$mn:00006399
.text$x:0000639C ; ===========================================================================
.text$x:0000639C
.text$x:0000639C ; Segment type: Pure code
.text$x:0000639C ; Segment permissions: Read/Execute
.text$x:0000639C _text$x         segment para public 'CODE' use32
.text$x:0000639C                 assume cs:_text$x
.text$x:0000639C                 ;org 639Ch
.text$x:0000639C ; COMDAT (pick associative to section at 6320)
.text$x:0000639C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000639C
.text$x:0000639C ; =============== S U B R O U T I N E =======================================
.text$x:0000639C
.text$x:0000639C
.text$x:0000639C __unwindfunclet$??0MacroShortcut@@QAE@ABV0@@Z$0 proc near
.text$x:0000639C                                         ; DATA XREF: .xdata$x:0000D900o
.text$x:0000639C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000639F                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:0000639F __unwindfunclet$??0MacroShortcut@@QAE@ABV0@@Z$0 endp
.text$x:0000639F
.text$x:000063A4
.text$x:000063A4 ; =============== S U B R O U T I N E =======================================
.text$x:000063A4
.text$x:000063A4
.text$x:000063A4 __unwindfunclet$??0MacroShortcut@@QAE@ABV0@@Z$1 proc near
.text$x:000063A4                                         ; DATA XREF: .xdata$x:0000D908o
.text$x:000063A4                 mov     ecx, [ebp-10h]
.text$x:000063A7                 add     ecx, 12Ch
.text$x:000063AD                 jmp     ??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::~vector<recordedMacroStep,std::allocator<recordedMacroStep>>(void)
.text$x:000063AD __unwindfunclet$??0MacroShortcut@@QAE@ABV0@@Z$1 endp
.text$x:000063AD
.text$x:000063B2
.text$x:000063B2 ; =============== S U B R O U T I N E =======================================
.text$x:000063B2
.text$x:000063B2
.text$x:000063B2 __ehhandler$??0MacroShortcut@@QAE@ABV0@@Z proc near
.text$x:000063B2                                         ; DATA XREF: MacroShortcut::MacroShortcut(MacroShortcut const &)+5o
.text$x:000063B2
.text$x:000063B2 arg_4           = dword ptr  8
.text$x:000063B2
.text$x:000063B2                 mov     edx, [esp+arg_4]
.text$x:000063B6                 lea     eax, [edx+0Ch]
.text$x:000063B9                 mov     ecx, [edx-8]
.text$x:000063BC                 xor     ecx, eax
.text$x:000063BE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000063C3                 mov     eax, offset __ehfuncinfo$??0MacroShortcut@@QAE@ABV0@@Z
.text$x:000063C8                 jmp     ___CxxFrameHandler3
.text$x:000063C8 __ehhandler$??0MacroShortcut@@QAE@ABV0@@Z endp
.text$x:000063C8
.text$x:000063C8 ; ---------------------------------------------------------------------------
.text$x:000063CD                 align 10h
.text$x:000063CD _text$x         ends
.text$x:000063CD
.text$mn:000063D0 ; ===========================================================================
.text$mn:000063D0
.text$mn:000063D0 ; Segment type: Pure code
.text$mn:000063D0 ; Segment permissions: Read/Execute
.text$mn:000063D0 _text$mn        segment para public 'CODE' use32
.text$mn:000063D0                 assume cs:_text$mn
.text$mn:000063D0                 ;org 63D0h
.text$mn:000063D0 ; COMDAT (pick any)
.text$mn:000063D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063D0
.text$mn:000063D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000063D0
.text$mn:000063D0 ; Attributes: bp-based frame
.text$mn:000063D0
.text$mn:000063D0 ; public: __thiscall MenuItemUnit::MenuItemUnit(struct MenuItemUnit const &)
.text$mn:000063D0                 public ??0MenuItemUnit@@QAE@ABU0@@Z
.text$mn:000063D0 ??0MenuItemUnit@@QAE@ABU0@@Z proc near  ; CODE XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+56p
.text$mn:000063D0
.text$mn:000063D0 var_10          = dword ptr -10h
.text$mn:000063D0 var_C           = dword ptr -0Ch
.text$mn:000063D0 var_4           = dword ptr -4
.text$mn:000063D0 arg_0           = dword ptr  8
.text$mn:000063D0
.text$mn:000063D0                 push    ebp
.text$mn:000063D1                 mov     ebp, esp
.text$mn:000063D3                 push    0FFFFFFFFh
.text$mn:000063D5                 push    offset __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z
.text$mn:000063DA                 mov     eax, large fs:0
.text$mn:000063E0                 push    eax
.text$mn:000063E1                 push    ecx
.text$mn:000063E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000063E7                 xor     eax, ebp
.text$mn:000063E9                 push    eax
.text$mn:000063EA                 lea     eax, [ebp+var_C]
.text$mn:000063ED                 mov     large fs:0, eax
.text$mn:000063F3                 mov     [ebp+var_10], ecx
.text$mn:000063F6                 mov     eax, [ebp+var_10]
.text$mn:000063F9                 mov     ecx, [ebp+arg_0]
.text$mn:000063FC                 mov     edx, [ecx]
.text$mn:000063FE                 mov     [eax], edx
.text$mn:00006400                 mov     eax, [ebp+arg_0]
.text$mn:00006403                 add     eax, 4
.text$mn:00006406                 push    eax
.text$mn:00006407                 mov     ecx, [ebp+var_10]
.text$mn:0000640A                 add     ecx, 4
.text$mn:0000640D                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00006412                 mov     [ebp+var_4], 0
.text$mn:00006419                 mov     ecx, [ebp+arg_0]
.text$mn:0000641C                 add     ecx, 20h ; ' '
.text$mn:0000641F                 push    ecx
.text$mn:00006420                 mov     ecx, [ebp+var_10]
.text$mn:00006423                 add     ecx, 20h ; ' '
.text$mn:00006426                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000642B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000642F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006436                 mov     eax, [ebp+var_10]
.text$mn:00006439                 mov     ecx, [ebp+var_C]
.text$mn:0000643C                 mov     large fs:0, ecx
.text$mn:00006443                 pop     ecx
.text$mn:00006444                 mov     esp, ebp
.text$mn:00006446                 pop     ebp
.text$mn:00006447                 retn    4
.text$mn:00006447 ??0MenuItemUnit@@QAE@ABU0@@Z endp
.text$mn:00006447
.text$mn:00006447 ; ---------------------------------------------------------------------------
.text$mn:0000644A                 align 4
.text$mn:0000644A _text$mn        ends
.text$mn:0000644A
.text$x:0000644C ; ===========================================================================
.text$x:0000644C
.text$x:0000644C ; Segment type: Pure code
.text$x:0000644C ; Segment permissions: Read/Execute
.text$x:0000644C _text$x         segment para public 'CODE' use32
.text$x:0000644C                 assume cs:_text$x
.text$x:0000644C                 ;org 644Ch
.text$x:0000644C ; COMDAT (pick associative to section at 63D0)
.text$x:0000644C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000644C
.text$x:0000644C ; =============== S U B R O U T I N E =======================================
.text$x:0000644C
.text$x:0000644C
.text$x:0000644C __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$0 proc near
.text$x:0000644C                                         ; DATA XREF: .xdata$x:0000DA38o
.text$x:0000644C                 mov     ecx, [ebp-10h]
.text$x:0000644F                 add     ecx, 4
.text$x:00006452                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006452 __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$0 endp
.text$x:00006452
.text$x:00006457
.text$x:00006457 ; =============== S U B R O U T I N E =======================================
.text$x:00006457
.text$x:00006457
.text$x:00006457 __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$1 proc near
.text$x:00006457                                         ; DATA XREF: .xdata$x:0000DA40o
.text$x:00006457                 mov     ecx, [ebp-10h]
.text$x:0000645A                 add     ecx, 20h ; ' '
.text$x:0000645D                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000645D __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$1 endp
.text$x:0000645D
.text$x:00006462
.text$x:00006462 ; =============== S U B R O U T I N E =======================================
.text$x:00006462
.text$x:00006462
.text$x:00006462 __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z proc near
.text$x:00006462                                         ; DATA XREF: MenuItemUnit::MenuItemUnit(MenuItemUnit const &)+5o
.text$x:00006462
.text$x:00006462 arg_4           = dword ptr  8
.text$x:00006462
.text$x:00006462                 mov     edx, [esp+arg_4]
.text$x:00006466                 lea     eax, [edx+0Ch]
.text$x:00006469                 mov     ecx, [edx-8]
.text$x:0000646C                 xor     ecx, eax
.text$x:0000646E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006473                 mov     eax, offset __ehfuncinfo$??0MenuItemUnit@@QAE@ABU0@@Z
.text$x:00006478                 jmp     ___CxxFrameHandler3
.text$x:00006478 __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z endp
.text$x:00006478
.text$x:00006478 ; ---------------------------------------------------------------------------
.text$x:0000647D                 align 10h
.text$x:0000647D _text$x         ends
.text$x:0000647D
.text$mn:00006480 ; ===========================================================================
.text$mn:00006480
.text$mn:00006480 ; Segment type: Pure code
.text$mn:00006480 ; Segment permissions: Read/Execute
.text$mn:00006480 _text$mn        segment para public 'CODE' use32
.text$mn:00006480                 assume cs:_text$mn
.text$mn:00006480                 ;org 6480h
.text$mn:00006480 ; COMDAT (pick any)
.text$mn:00006480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006480
.text$mn:00006480 ; =============== S U B R O U T I N E =======================================
.text$mn:00006480
.text$mn:00006480 ; Attributes: bp-based frame
.text$mn:00006480
.text$mn:00006480 ; int __stdcall PluginCmdShortcut::PluginCmdShortcut(Shortcut *)
.text$mn:00006480                 public ??0PluginCmdShortcut@@QAE@ABV0@@Z
.text$mn:00006480 ??0PluginCmdShortcut@@QAE@ABV0@@Z proc near
.text$mn:00006480                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+6D8p
.text$mn:00006480                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+700p
.text$mn:00006480
.text$mn:00006480 var_10          = dword ptr -10h
.text$mn:00006480 var_C           = dword ptr -0Ch
.text$mn:00006480 var_4           = dword ptr -4
.text$mn:00006480 arg_0           = dword ptr  8
.text$mn:00006480
.text$mn:00006480                 push    ebp
.text$mn:00006481                 mov     ebp, esp
.text$mn:00006483                 push    0FFFFFFFFh
.text$mn:00006485                 push    offset __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z
.text$mn:0000648A                 mov     eax, large fs:0
.text$mn:00006490                 push    eax
.text$mn:00006491                 push    ecx
.text$mn:00006492                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006497                 xor     eax, ebp
.text$mn:00006499                 push    eax
.text$mn:0000649A                 lea     eax, [ebp+var_C]
.text$mn:0000649D                 mov     large fs:0, eax
.text$mn:000064A3                 mov     [ebp+var_10], ecx
.text$mn:000064A6                 mov     eax, [ebp+arg_0]
.text$mn:000064A9                 push    eax             ; Shortcut *
.text$mn:000064AA                 mov     ecx, [ebp+var_10]
.text$mn:000064AD                 call    ??0CommandShortcut@@QAE@ABV0@@Z ; CommandShortcut::CommandShortcut(CommandShortcut const &)
.text$mn:000064B2                 mov     [ebp+var_4], 0
.text$mn:000064B9                 mov     ecx, [ebp+var_10]
.text$mn:000064BC                 mov     dword ptr [ecx], offset ??_7PluginCmdShortcut@@6B@ ; const PluginCmdShortcut::`vftable'
.text$mn:000064C2                 mov     edx, [ebp+var_10]
.text$mn:000064C5                 mov     eax, [ebp+arg_0]
.text$mn:000064C8                 mov     ecx, [eax+12Ch]
.text$mn:000064CE                 mov     [edx+12Ch], ecx
.text$mn:000064D4                 mov     edx, [ebp+arg_0]
.text$mn:000064D7                 add     edx, 130h
.text$mn:000064DD                 push    edx
.text$mn:000064DE                 mov     ecx, [ebp+var_10]
.text$mn:000064E1                 add     ecx, 130h
.text$mn:000064E7                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000064EC                 mov     byte ptr [ebp+var_4], 1
.text$mn:000064F0                 mov     eax, [ebp+var_10]
.text$mn:000064F3                 mov     ecx, [ebp+arg_0]
.text$mn:000064F6                 mov     edx, [ecx+14Ch]
.text$mn:000064FC                 mov     [eax+14Ch], edx
.text$mn:00006502                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006509                 mov     eax, [ebp+var_10]
.text$mn:0000650C                 mov     ecx, [ebp+var_C]
.text$mn:0000650F                 mov     large fs:0, ecx
.text$mn:00006516                 pop     ecx
.text$mn:00006517                 mov     esp, ebp
.text$mn:00006519                 pop     ebp
.text$mn:0000651A                 retn    4
.text$mn:0000651A ??0PluginCmdShortcut@@QAE@ABV0@@Z endp
.text$mn:0000651A
.text$mn:0000651A ; ---------------------------------------------------------------------------
.text$mn:0000651D                 align 10h
.text$mn:0000651D _text$mn        ends
.text$mn:0000651D
.text$x:00006520 ; ===========================================================================
.text$x:00006520
.text$x:00006520 ; Segment type: Pure code
.text$x:00006520 ; Segment permissions: Read/Execute
.text$x:00006520 _text$x         segment para public 'CODE' use32
.text$x:00006520                 assume cs:_text$x
.text$x:00006520                 ;org 6520h
.text$x:00006520 ; COMDAT (pick associative to section at 6480)
.text$x:00006520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006520
.text$x:00006520 ; =============== S U B R O U T I N E =======================================
.text$x:00006520
.text$x:00006520
.text$x:00006520 __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$0 proc near
.text$x:00006520                                         ; DATA XREF: .xdata$x:0000D9D0o
.text$x:00006520                 mov     ecx, [ebp-10h]  ; this
.text$x:00006523                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00006523 __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$0 endp
.text$x:00006523
.text$x:00006528
.text$x:00006528 ; =============== S U B R O U T I N E =======================================
.text$x:00006528
.text$x:00006528
.text$x:00006528 __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$1 proc near
.text$x:00006528                                         ; DATA XREF: .xdata$x:0000D9D8o
.text$x:00006528                 mov     ecx, [ebp-10h]
.text$x:0000652B                 add     ecx, 130h
.text$x:00006531                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006531 __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$1 endp
.text$x:00006531
.text$x:00006536
.text$x:00006536 ; =============== S U B R O U T I N E =======================================
.text$x:00006536
.text$x:00006536
.text$x:00006536 __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z proc near
.text$x:00006536                                         ; DATA XREF: PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)+5o
.text$x:00006536
.text$x:00006536 arg_4           = dword ptr  8
.text$x:00006536
.text$x:00006536                 mov     edx, [esp+arg_4]
.text$x:0000653A                 lea     eax, [edx+0Ch]
.text$x:0000653D                 mov     ecx, [edx-8]
.text$x:00006540                 xor     ecx, eax
.text$x:00006542                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006547                 mov     eax, offset __ehfuncinfo$??0PluginCmdShortcut@@QAE@ABV0@@Z
.text$x:0000654C                 jmp     ___CxxFrameHandler3
.text$x:0000654C __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z endp
.text$x:0000654C
.text$x:0000654C ; ---------------------------------------------------------------------------
.text$x:00006551                 align 4
.text$x:00006551 _text$x         ends
.text$x:00006551
.text$mn:00006554 ; ===========================================================================
.text$mn:00006554
.text$mn:00006554 ; Segment type: Pure code
.text$mn:00006554 ; Segment permissions: Read/Execute
.text$mn:00006554 _text$mn        segment para public 'CODE' use32
.text$mn:00006554                 assume cs:_text$mn
.text$mn:00006554                 ;org 6554h
.text$mn:00006554 ; COMDAT (pick any)
.text$mn:00006554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006554
.text$mn:00006554 ; =============== S U B R O U T I N E =======================================
.text$mn:00006554
.text$mn:00006554 ; Attributes: bp-based frame
.text$mn:00006554
.text$mn:00006554 ; int __stdcall ScintillaKeyMap::ScintillaKeyMap(Shortcut *)
.text$mn:00006554                 public ??0ScintillaKeyMap@@QAE@ABV0@@Z
.text$mn:00006554 ??0ScintillaKeyMap@@QAE@ABV0@@Z proc near
.text$mn:00006554                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+8DDp
.text$mn:00006554                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+905p
.text$mn:00006554
.text$mn:00006554 var_10          = dword ptr -10h
.text$mn:00006554 var_C           = dword ptr -0Ch
.text$mn:00006554 var_4           = dword ptr -4
.text$mn:00006554 arg_0           = dword ptr  8
.text$mn:00006554
.text$mn:00006554                 push    ebp
.text$mn:00006555                 mov     ebp, esp
.text$mn:00006557                 push    0FFFFFFFFh
.text$mn:00006559                 push    offset __ehhandler$??0ScintillaKeyMap@@QAE@ABV0@@Z
.text$mn:0000655E                 mov     eax, large fs:0
.text$mn:00006564                 push    eax
.text$mn:00006565                 push    ecx
.text$mn:00006566                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000656B                 xor     eax, ebp
.text$mn:0000656D                 push    eax
.text$mn:0000656E                 lea     eax, [ebp+var_C]
.text$mn:00006571                 mov     large fs:0, eax
.text$mn:00006577                 mov     [ebp+var_10], ecx
.text$mn:0000657A                 mov     eax, [ebp+arg_0]
.text$mn:0000657D                 push    eax             ; Shortcut *
.text$mn:0000657E                 mov     ecx, [ebp+var_10]
.text$mn:00006581                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:00006586                 mov     [ebp+var_4], 0
.text$mn:0000658D                 mov     ecx, [ebp+var_10]
.text$mn:00006590                 mov     dword ptr [ecx], offset ??_7ScintillaKeyMap@@6B@ ; const ScintillaKeyMap::`vftable'
.text$mn:00006596                 mov     edx, [ebp+var_10]
.text$mn:00006599                 mov     eax, [ebp+arg_0]
.text$mn:0000659C                 mov     ecx, [eax+128h]
.text$mn:000065A2                 mov     [edx+128h], ecx
.text$mn:000065A8                 mov     edx, [ebp+var_10]
.text$mn:000065AB                 mov     eax, [ebp+arg_0]
.text$mn:000065AE                 mov     ecx, [eax+12Ch]
.text$mn:000065B4                 mov     [edx+12Ch], ecx
.text$mn:000065BA                 mov     edx, [ebp+arg_0]
.text$mn:000065BD                 add     edx, 130h
.text$mn:000065C3                 push    edx
.text$mn:000065C4                 mov     ecx, [ebp+var_10]
.text$mn:000065C7                 add     ecx, 130h
.text$mn:000065CD                 call    ??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)
.text$mn:000065D2                 mov     byte ptr [ebp+var_4], 1
.text$mn:000065D6                 mov     eax, [ebp+var_10]
.text$mn:000065D9                 mov     ecx, [ebp+arg_0]
.text$mn:000065DC                 mov     edx, [ecx+140h]
.text$mn:000065E2                 mov     [eax+140h], edx
.text$mn:000065E8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000065EF                 mov     eax, [ebp+var_10]
.text$mn:000065F2                 mov     ecx, [ebp+var_C]
.text$mn:000065F5                 mov     large fs:0, ecx
.text$mn:000065FC                 pop     ecx
.text$mn:000065FD                 mov     esp, ebp
.text$mn:000065FF                 pop     ebp
.text$mn:00006600                 retn    4
.text$mn:00006600 ??0ScintillaKeyMap@@QAE@ABV0@@Z endp
.text$mn:00006600
.text$mn:00006600 ; ---------------------------------------------------------------------------
.text$mn:00006603                 align 4
.text$mn:00006603 _text$mn        ends
.text$mn:00006603
.text$x:00006604 ; ===========================================================================
.text$x:00006604
.text$x:00006604 ; Segment type: Pure code
.text$x:00006604 ; Segment permissions: Read/Execute
.text$x:00006604 _text$x         segment para public 'CODE' use32
.text$x:00006604                 assume cs:_text$x
.text$x:00006604                 ;org 6604h
.text$x:00006604 ; COMDAT (pick associative to section at 6554)
.text$x:00006604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006604
.text$x:00006604 ; =============== S U B R O U T I N E =======================================
.text$x:00006604
.text$x:00006604
.text$x:00006604 __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$0 proc near
.text$x:00006604                                         ; DATA XREF: .xdata$x:0000D510o
.text$x:00006604                 mov     ecx, [ebp-10h]  ; this
.text$x:00006607                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00006607 __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$0 endp
.text$x:00006607
.text$x:0000660C
.text$x:0000660C ; =============== S U B R O U T I N E =======================================
.text$x:0000660C
.text$x:0000660C
.text$x:0000660C __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$1 proc near
.text$x:0000660C                                         ; DATA XREF: .xdata$x:0000D518o
.text$x:0000660C                 mov     ecx, [ebp-10h]
.text$x:0000660F                 add     ecx, 130h
.text$x:00006615                 jmp     ??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::~vector<KeyCombo,std::allocator<KeyCombo>>(void)
.text$x:00006615 __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$1 endp
.text$x:00006615
.text$x:0000661A
.text$x:0000661A ; =============== S U B R O U T I N E =======================================
.text$x:0000661A
.text$x:0000661A
.text$x:0000661A __ehhandler$??0ScintillaKeyMap@@QAE@ABV0@@Z proc near
.text$x:0000661A                                         ; DATA XREF: ScintillaKeyMap::ScintillaKeyMap(ScintillaKeyMap const &)+5o
.text$x:0000661A
.text$x:0000661A arg_4           = dword ptr  8
.text$x:0000661A
.text$x:0000661A                 mov     edx, [esp+arg_4]
.text$x:0000661E                 lea     eax, [edx+0Ch]
.text$x:00006621                 mov     ecx, [edx-8]
.text$x:00006624                 xor     ecx, eax
.text$x:00006626                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000662B                 mov     eax, offset __ehfuncinfo$??0ScintillaKeyMap@@QAE@ABV0@@Z
.text$x:00006630                 jmp     ___CxxFrameHandler3
.text$x:00006630 __ehhandler$??0ScintillaKeyMap@@QAE@ABV0@@Z endp
.text$x:00006630
.text$x:00006630 ; ---------------------------------------------------------------------------
.text$x:00006635                 align 4
.text$x:00006635 _text$x         ends
.text$x:00006635
.text$mn:00006638 ; ===========================================================================
.text$mn:00006638
.text$mn:00006638 ; Segment type: Pure code
.text$mn:00006638 ; Segment permissions: Read/Execute
.text$mn:00006638 _text$mn        segment para public 'CODE' use32
.text$mn:00006638                 assume cs:_text$mn
.text$mn:00006638                 ;org 6638h
.text$mn:00006638 ; COMDAT (pick any)
.text$mn:00006638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006638
.text$mn:00006638 ; =============== S U B R O U T I N E =======================================
.text$mn:00006638
.text$mn:00006638 ; Attributes: bp-based frame
.text$mn:00006638
.text$mn:00006638 ; int __stdcall Shortcut::Shortcut(Shortcut *)
.text$mn:00006638                 public ??0Shortcut@@QAE@ABV0@@Z
.text$mn:00006638 ??0Shortcut@@QAE@ABV0@@Z proc near      ; CODE XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+2Dp
.text$mn:00006638                                         ; ScintillaKeyMap::ScintillaKeyMap(ScintillaKeyMap const &)+2Dp
.text$mn:00006638
.text$mn:00006638 var_10          = dword ptr -10h
.text$mn:00006638 var_C           = dword ptr -0Ch
.text$mn:00006638 var_4           = dword ptr -4
.text$mn:00006638 arg_0           = dword ptr  8
.text$mn:00006638
.text$mn:00006638                 push    ebp
.text$mn:00006639                 mov     ebp, esp
.text$mn:0000663B                 push    0FFFFFFFFh
.text$mn:0000663D                 push    offset __ehhandler$??0Shortcut@@QAE@ABV0@@Z
.text$mn:00006642                 mov     eax, large fs:0
.text$mn:00006648                 push    eax
.text$mn:00006649                 push    ecx
.text$mn:0000664A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000664F                 xor     eax, ebp
.text$mn:00006651                 push    eax
.text$mn:00006652                 lea     eax, [ebp+var_C]
.text$mn:00006655                 mov     large fs:0, eax
.text$mn:0000665B                 mov     [ebp+var_10], ecx
.text$mn:0000665E                 mov     ecx, [ebp+var_10]
.text$mn:00006661                 call    ??0StaticDialog@@QAE@XZ ; StaticDialog::StaticDialog(void)
.text$mn:00006666                 mov     [ebp+var_4], 0
.text$mn:0000666D                 mov     eax, [ebp+var_10]
.text$mn:00006670                 mov     dword ptr [eax], offset ??_7Shortcut@@6B@ ; const Shortcut::`vftable'
.text$mn:00006676                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006679                 call    ?getMenuName@Shortcut@@QBEPB_WXZ ; Shortcut::getMenuName(void)
.text$mn:0000667E                 push    eax             ; wchar_t *
.text$mn:0000667F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006682                 call    ?setName@Shortcut@@QAEXPB_W@Z ; Shortcut::setName(wchar_t const *)
.text$mn:00006687                 mov     ecx, [ebp+arg_0]
.text$mn:0000668A                 mov     edx, [ecx+20h]
.text$mn:0000668D                 mov     eax, [ebp+var_10]
.text$mn:00006690                 mov     [eax+20h], edx
.text$mn:00006693                 mov     ecx, [ebp+var_10]
.text$mn:00006696                 mov     edx, [ebp+arg_0]
.text$mn:00006699                 mov     al, [edx+24h]
.text$mn:0000669C                 mov     [ecx+24h], al
.text$mn:0000669F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000066A6                 mov     eax, [ebp+var_10]
.text$mn:000066A9                 mov     ecx, [ebp+var_C]
.text$mn:000066AC                 mov     large fs:0, ecx
.text$mn:000066B3                 pop     ecx
.text$mn:000066B4                 mov     esp, ebp
.text$mn:000066B6                 pop     ebp
.text$mn:000066B7                 retn    4
.text$mn:000066B7 ??0Shortcut@@QAE@ABV0@@Z endp
.text$mn:000066B7
.text$mn:000066B7 ; ---------------------------------------------------------------------------
.text$mn:000066BA                 align 4
.text$mn:000066BA _text$mn        ends
.text$mn:000066BA
.text$x:000066BC ; ===========================================================================
.text$x:000066BC
.text$x:000066BC ; Segment type: Pure code
.text$x:000066BC ; Segment permissions: Read/Execute
.text$x:000066BC _text$x         segment para public 'CODE' use32
.text$x:000066BC                 assume cs:_text$x
.text$x:000066BC                 ;org 66BCh
.text$x:000066BC ; COMDAT (pick associative to section at 6638)
.text$x:000066BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000066BC
.text$x:000066BC ; =============== S U B R O U T I N E =======================================
.text$x:000066BC
.text$x:000066BC
.text$x:000066BC __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0 proc near
.text$x:000066BC                                         ; DATA XREF: .xdata$x:0000D230o
.text$x:000066BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000066BF                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:000066BF __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0 endp
.text$x:000066BF
.text$x:000066C4
.text$x:000066C4 ; =============== S U B R O U T I N E =======================================
.text$x:000066C4
.text$x:000066C4
.text$x:000066C4 __ehhandler$??0Shortcut@@QAE@ABV0@@Z proc near
.text$x:000066C4                                         ; DATA XREF: Shortcut::Shortcut(Shortcut const &)+5o
.text$x:000066C4
.text$x:000066C4 arg_4           = dword ptr  8
.text$x:000066C4
.text$x:000066C4                 mov     edx, [esp+arg_4]
.text$x:000066C8                 lea     eax, [edx+0Ch]
.text$x:000066CB                 mov     ecx, [edx-8]
.text$x:000066CE                 xor     ecx, eax
.text$x:000066D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000066D5                 mov     eax, offset __ehfuncinfo$??0Shortcut@@QAE@ABV0@@Z
.text$x:000066DA                 jmp     ___CxxFrameHandler3
.text$x:000066DA __ehhandler$??0Shortcut@@QAE@ABV0@@Z endp
.text$x:000066DA
.text$x:000066DA ; ---------------------------------------------------------------------------
.text$x:000066DF                 align 10h
.text$x:000066DF _text$x         ends
.text$x:000066DF
.text$mn:000066E0 ; ===========================================================================
.text$mn:000066E0
.text$mn:000066E0 ; Segment type: Pure code
.text$mn:000066E0 ; Segment permissions: Read/Execute
.text$mn:000066E0 _text$mn        segment para public 'CODE' use32
.text$mn:000066E0                 assume cs:_text$mn
.text$mn:000066E0                 ;org 66E0h
.text$mn:000066E0 ; COMDAT (pick any)
.text$mn:000066E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066E0
.text$mn:000066E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000066E0
.text$mn:000066E0 ; Attributes: bp-based frame
.text$mn:000066E0
.text$mn:000066E0 ; public: __thiscall StaticDialog::StaticDialog(void)
.text$mn:000066E0                 public ??0StaticDialog@@QAE@XZ
.text$mn:000066E0 ??0StaticDialog@@QAE@XZ proc near       ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+29p
.text$mn:000066E0
.text$mn:000066E0 var_10          = dword ptr -10h
.text$mn:000066E0 var_C           = dword ptr -0Ch
.text$mn:000066E0 var_4           = dword ptr -4
.text$mn:000066E0
.text$mn:000066E0                 push    ebp
.text$mn:000066E1                 mov     ebp, esp
.text$mn:000066E3                 push    0FFFFFFFFh
.text$mn:000066E5                 push    offset __ehhandler$??0StaticDialog@@QAE@XZ
.text$mn:000066EA                 mov     eax, large fs:0
.text$mn:000066F0                 push    eax
.text$mn:000066F1                 push    ecx
.text$mn:000066F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066F7                 xor     eax, ebp
.text$mn:000066F9                 push    eax
.text$mn:000066FA                 lea     eax, [ebp+var_C]
.text$mn:000066FD                 mov     large fs:0, eax
.text$mn:00006703                 mov     [ebp+var_10], ecx
.text$mn:00006706                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006709                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:0000670E                 mov     [ebp+var_4], 0
.text$mn:00006715                 mov     eax, [ebp+var_10]
.text$mn:00006718                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:0000671E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006725                 mov     eax, [ebp+var_10]
.text$mn:00006728                 mov     ecx, [ebp+var_C]
.text$mn:0000672B                 mov     large fs:0, ecx
.text$mn:00006732                 pop     ecx
.text$mn:00006733                 mov     esp, ebp
.text$mn:00006735                 pop     ebp
.text$mn:00006736                 retn
.text$mn:00006736 ??0StaticDialog@@QAE@XZ endp
.text$mn:00006736
.text$mn:00006736 ; ---------------------------------------------------------------------------
.text$mn:00006737                 align 4
.text$mn:00006737 _text$mn        ends
.text$mn:00006737
.text$x:00006738 ; ===========================================================================
.text$x:00006738
.text$x:00006738 ; Segment type: Pure code
.text$x:00006738 ; Segment permissions: Read/Execute
.text$x:00006738 _text$x         segment para public 'CODE' use32
.text$x:00006738                 assume cs:_text$x
.text$x:00006738                 ;org 6738h
.text$x:00006738 ; COMDAT (pick associative to section at 66E0)
.text$x:00006738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006738
.text$x:00006738 ; =============== S U B R O U T I N E =======================================
.text$x:00006738
.text$x:00006738
.text$x:00006738 __unwindfunclet$??0StaticDialog@@QAE@XZ$0 proc near
.text$x:00006738                                         ; DATA XREF: .xdata$x:0000CC6Co
.text$x:00006738                 mov     ecx, [ebp-10h]  ; this
.text$x:0000673B                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:0000673B __unwindfunclet$??0StaticDialog@@QAE@XZ$0 endp
.text$x:0000673B
.text$x:00006740
.text$x:00006740 ; =============== S U B R O U T I N E =======================================
.text$x:00006740
.text$x:00006740
.text$x:00006740 __ehhandler$??0StaticDialog@@QAE@XZ proc near
.text$x:00006740                                         ; DATA XREF: StaticDialog::StaticDialog(void)+5o
.text$x:00006740
.text$x:00006740 arg_4           = dword ptr  8
.text$x:00006740
.text$x:00006740                 mov     edx, [esp+arg_4]
.text$x:00006744                 lea     eax, [edx+0Ch]
.text$x:00006747                 mov     ecx, [edx-8]
.text$x:0000674A                 xor     ecx, eax
.text$x:0000674C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006751                 mov     eax, offset __ehfuncinfo$??0StaticDialog@@QAE@XZ
.text$x:00006756                 jmp     ___CxxFrameHandler3
.text$x:00006756 __ehhandler$??0StaticDialog@@QAE@XZ endp
.text$x:00006756
.text$x:00006756 ; ---------------------------------------------------------------------------
.text$x:0000675B                 align 4
.text$x:0000675B _text$x         ends
.text$x:0000675B
.text$mn:0000675C ; ===========================================================================
.text$mn:0000675C
.text$mn:0000675C ; Segment type: Pure code
.text$mn:0000675C ; Segment permissions: Read/Execute
.text$mn:0000675C _text$mn        segment para public 'CODE' use32
.text$mn:0000675C                 assume cs:_text$mn
.text$mn:0000675C                 ;org 675Ch
.text$mn:0000675C ; COMDAT (pick any)
.text$mn:0000675C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000675C
.text$mn:0000675C ; =============== S U B R O U T I N E =======================================
.text$mn:0000675C
.text$mn:0000675C ; Attributes: bp-based frame
.text$mn:0000675C
.text$mn:0000675C ; int __stdcall UserCommand::UserCommand(Shortcut *)
.text$mn:0000675C                 public ??0UserCommand@@QAE@ABV0@@Z
.text$mn:0000675C ??0UserCommand@@QAE@ABV0@@Z proc near   ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+54Ep
.text$mn:0000675C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+576p ...
.text$mn:0000675C
.text$mn:0000675C var_10          = dword ptr -10h
.text$mn:0000675C var_C           = dword ptr -0Ch
.text$mn:0000675C var_4           = dword ptr -4
.text$mn:0000675C arg_0           = dword ptr  8
.text$mn:0000675C
.text$mn:0000675C                 push    ebp
.text$mn:0000675D                 mov     ebp, esp
.text$mn:0000675F                 push    0FFFFFFFFh
.text$mn:00006761                 push    offset __ehhandler$??0UserCommand@@QAE@ABV0@@Z
.text$mn:00006766                 mov     eax, large fs:0
.text$mn:0000676C                 push    eax
.text$mn:0000676D                 push    ecx
.text$mn:0000676E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006773                 xor     eax, ebp
.text$mn:00006775                 push    eax
.text$mn:00006776                 lea     eax, [ebp+var_C]
.text$mn:00006779                 mov     large fs:0, eax
.text$mn:0000677F                 mov     [ebp+var_10], ecx
.text$mn:00006782                 mov     eax, [ebp+arg_0]
.text$mn:00006785                 push    eax             ; Shortcut *
.text$mn:00006786                 mov     ecx, [ebp+var_10]
.text$mn:00006789                 call    ??0CommandShortcut@@QAE@ABV0@@Z ; CommandShortcut::CommandShortcut(CommandShortcut const &)
.text$mn:0000678E                 mov     [ebp+var_4], 0
.text$mn:00006795                 mov     ecx, [ebp+var_10]
.text$mn:00006798                 mov     dword ptr [ecx], offset ??_7UserCommand@@6B@ ; const UserCommand::`vftable'
.text$mn:0000679E                 mov     edx, [ebp+arg_0]
.text$mn:000067A1                 add     edx, 12Ch
.text$mn:000067A7                 push    edx
.text$mn:000067A8                 mov     ecx, [ebp+var_10]
.text$mn:000067AB                 add     ecx, 12Ch
.text$mn:000067B1                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000067B6                 mov     byte ptr [ebp+var_4], 1
.text$mn:000067BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000067C1                 mov     eax, [ebp+var_10]
.text$mn:000067C4                 mov     ecx, [ebp+var_C]
.text$mn:000067C7                 mov     large fs:0, ecx
.text$mn:000067CE                 pop     ecx
.text$mn:000067CF                 mov     esp, ebp
.text$mn:000067D1                 pop     ebp
.text$mn:000067D2                 retn    4
.text$mn:000067D2 ??0UserCommand@@QAE@ABV0@@Z endp
.text$mn:000067D2
.text$mn:000067D2 ; ---------------------------------------------------------------------------
.text$mn:000067D5                 align 4
.text$mn:000067D5 _text$mn        ends
.text$mn:000067D5
.text$x:000067D8 ; ===========================================================================
.text$x:000067D8
.text$x:000067D8 ; Segment type: Pure code
.text$x:000067D8 ; Segment permissions: Read/Execute
.text$x:000067D8 _text$x         segment para public 'CODE' use32
.text$x:000067D8                 assume cs:_text$x
.text$x:000067D8                 ;org 67D8h
.text$x:000067D8 ; COMDAT (pick associative to section at 675C)
.text$x:000067D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000067D8
.text$x:000067D8 ; =============== S U B R O U T I N E =======================================
.text$x:000067D8
.text$x:000067D8
.text$x:000067D8 __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$0 proc near
.text$x:000067D8                                         ; DATA XREF: .xdata$x:0000D968o
.text$x:000067D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000067DB                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:000067DB __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$0 endp
.text$x:000067DB
.text$x:000067E0
.text$x:000067E0 ; =============== S U B R O U T I N E =======================================
.text$x:000067E0
.text$x:000067E0
.text$x:000067E0 __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$1 proc near
.text$x:000067E0                                         ; DATA XREF: .xdata$x:0000D970o
.text$x:000067E0                 mov     ecx, [ebp-10h]
.text$x:000067E3                 add     ecx, 12Ch
.text$x:000067E9                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000067E9 __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$1 endp
.text$x:000067E9
.text$x:000067EE
.text$x:000067EE ; =============== S U B R O U T I N E =======================================
.text$x:000067EE
.text$x:000067EE
.text$x:000067EE __ehhandler$??0UserCommand@@QAE@ABV0@@Z proc near
.text$x:000067EE                                         ; DATA XREF: UserCommand::UserCommand(UserCommand const &)+5o
.text$x:000067EE
.text$x:000067EE arg_4           = dword ptr  8
.text$x:000067EE
.text$x:000067EE                 mov     edx, [esp+arg_4]
.text$x:000067F2                 lea     eax, [edx+0Ch]
.text$x:000067F5                 mov     ecx, [edx-8]
.text$x:000067F8                 xor     ecx, eax
.text$x:000067FA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067FF                 mov     eax, offset __ehfuncinfo$??0UserCommand@@QAE@ABV0@@Z
.text$x:00006804                 jmp     ___CxxFrameHandler3
.text$x:00006804 __ehhandler$??0UserCommand@@QAE@ABV0@@Z endp
.text$x:00006804
.text$x:00006804 ; ---------------------------------------------------------------------------
.text$x:00006809                 align 4
.text$x:00006809 _text$x         ends
.text$x:00006809
.text$mn:0000680C ; ===========================================================================
.text$mn:0000680C
.text$mn:0000680C ; Segment type: Pure code
.text$mn:0000680C ; Segment permissions: Read/Execute
.text$mn:0000680C _text$mn        segment para public 'CODE' use32
.text$mn:0000680C                 assume cs:_text$mn
.text$mn:0000680C                 ;org 680Ch
.text$mn:0000680C ; COMDAT (pick any)
.text$mn:0000680C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000680C
.text$mn:0000680C ; =============== S U B R O U T I N E =======================================
.text$mn:0000680C
.text$mn:0000680C ; Attributes: bp-based frame
.text$mn:0000680C
.text$mn:0000680C ; _DWORD __thiscall Window::Window(Window *__hidden this)
.text$mn:0000680C                 public ??0Window@@QAE@XZ
.text$mn:0000680C ??0Window@@QAE@XZ proc near             ; CODE XREF: StaticDialog::StaticDialog(void)+29p
.text$mn:0000680C
.text$mn:0000680C var_4           = dword ptr -4
.text$mn:0000680C
.text$mn:0000680C                 push    ebp
.text$mn:0000680D                 mov     ebp, esp
.text$mn:0000680F                 push    ecx
.text$mn:00006810                 mov     [ebp+var_4], ecx
.text$mn:00006813                 mov     eax, [ebp+var_4]
.text$mn:00006816                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:0000681C                 mov     ecx, [ebp+var_4]
.text$mn:0000681F                 mov     dword ptr [ecx+4], 0
.text$mn:00006826                 mov     edx, [ebp+var_4]
.text$mn:00006829                 mov     dword ptr [edx+8], 0
.text$mn:00006830                 mov     eax, [ebp+var_4]
.text$mn:00006833                 mov     dword ptr [eax+0Ch], 0
.text$mn:0000683A                 mov     eax, [ebp+var_4]
.text$mn:0000683D                 mov     esp, ebp
.text$mn:0000683F                 pop     ebp
.text$mn:00006840                 retn
.text$mn:00006840 ??0Window@@QAE@XZ endp
.text$mn:00006840
.text$mn:00006840 ; ---------------------------------------------------------------------------
.text$mn:00006841                 align 4
.text$mn:00006841 _text$mn        ends
.text$mn:00006841
.text$mn:00006844 ; ===========================================================================
.text$mn:00006844
.text$mn:00006844 ; Segment type: Pure code
.text$mn:00006844 ; Segment permissions: Read/Execute
.text$mn:00006844 _text$mn        segment para public 'CODE' use32
.text$mn:00006844                 assume cs:_text$mn
.text$mn:00006844                 ;org 6844h
.text$mn:00006844 ; COMDAT (pick any)
.text$mn:00006844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006844
.text$mn:00006844 ; =============== S U B R O U T I N E =======================================
.text$mn:00006844
.text$mn:00006844 ; Attributes: bp-based frame
.text$mn:00006844
.text$mn:00006844 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00006844                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00006844 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00006844                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00006844                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:00006844
.text$mn:00006844 var_4           = dword ptr -4
.text$mn:00006844
.text$mn:00006844                 push    ebp
.text$mn:00006845                 mov     ebp, esp
.text$mn:00006847                 push    ecx
.text$mn:00006848                 mov     [ebp+var_4], ecx
.text$mn:0000684B                 mov     eax, [ebp+var_4]
.text$mn:0000684E                 mov     dword ptr [eax], 0
.text$mn:00006854                 mov     eax, [ebp+var_4]
.text$mn:00006857                 mov     esp, ebp
.text$mn:00006859                 pop     ebp
.text$mn:0000685A                 retn
.text$mn:0000685A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000685A
.text$mn:0000685A ; ---------------------------------------------------------------------------
.text$mn:0000685B                 align 4
.text$mn:0000685B _text$mn        ends
.text$mn:0000685B
.text$mn:0000685C ; ===========================================================================
.text$mn:0000685C
.text$mn:0000685C ; Segment type: Pure code
.text$mn:0000685C ; Segment permissions: Read/Execute
.text$mn:0000685C _text$mn        segment para public 'CODE' use32
.text$mn:0000685C                 assume cs:_text$mn
.text$mn:0000685C                 ;org 685Ch
.text$mn:0000685C ; COMDAT (pick any)
.text$mn:0000685C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000685C
.text$mn:0000685C ; =============== S U B R O U T I N E =======================================
.text$mn:0000685C
.text$mn:0000685C ; Attributes: bp-based frame
.text$mn:0000685C
.text$mn:0000685C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000685C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000685C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000685C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000685C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:0000685C
.text$mn:0000685C var_4           = dword ptr -4
.text$mn:0000685C
.text$mn:0000685C                 push    ebp
.text$mn:0000685D                 mov     ebp, esp
.text$mn:0000685F                 push    ecx
.text$mn:00006860                 mov     [ebp+var_4], ecx
.text$mn:00006863                 mov     eax, [ebp+var_4]
.text$mn:00006866                 mov     dword ptr [eax], 0
.text$mn:0000686C                 mov     ecx, [ebp+var_4]
.text$mn:0000686F                 mov     dword ptr [ecx+4], 0
.text$mn:00006876                 mov     eax, [ebp+var_4]
.text$mn:00006879                 mov     esp, ebp
.text$mn:0000687B                 pop     ebp
.text$mn:0000687C                 retn
.text$mn:0000687C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000687C
.text$mn:0000687C ; ---------------------------------------------------------------------------
.text$mn:0000687D                 align 10h
.text$mn:0000687D _text$mn        ends
.text$mn:0000687D
.text$mn:00006880 ; ===========================================================================
.text$mn:00006880
.text$mn:00006880 ; Segment type: Pure code
.text$mn:00006880 ; Segment permissions: Read/Execute
.text$mn:00006880 _text$mn        segment para public 'CODE' use32
.text$mn:00006880                 assume cs:_text$mn
.text$mn:00006880                 ;org 6880h
.text$mn:00006880 ; COMDAT (pick any)
.text$mn:00006880                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006880
.text$mn:00006880 ; =============== S U B R O U T I N E =======================================
.text$mn:00006880
.text$mn:00006880 ; Attributes: bp-based frame
.text$mn:00006880
.text$mn:00006880 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00006880                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006880 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00006880                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00006880                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00006880
.text$mn:00006880 var_10          = dword ptr -10h
.text$mn:00006880 var_C           = dword ptr -0Ch
.text$mn:00006880 var_4           = dword ptr -4
.text$mn:00006880
.text$mn:00006880                 push    ebp
.text$mn:00006881                 mov     ebp, esp
.text$mn:00006883                 push    0FFFFFFFFh
.text$mn:00006885                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000688A                 mov     eax, large fs:0
.text$mn:00006890                 push    eax
.text$mn:00006891                 push    ecx
.text$mn:00006892                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006897                 xor     eax, ebp
.text$mn:00006899                 push    eax
.text$mn:0000689A                 lea     eax, [ebp+var_C]
.text$mn:0000689D                 mov     large fs:0, eax
.text$mn:000068A3                 mov     [ebp+var_10], ecx
.text$mn:000068A6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000068A9                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000068AE                 mov     [ebp+var_4], 0
.text$mn:000068B5                 mov     eax, [ebp+var_10]
.text$mn:000068B8                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000068BE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000068C5                 mov     eax, [ebp+var_10]
.text$mn:000068C8                 mov     ecx, [ebp+var_C]
.text$mn:000068CB                 mov     large fs:0, ecx
.text$mn:000068D2                 pop     ecx
.text$mn:000068D3                 mov     esp, ebp
.text$mn:000068D5                 pop     ebp
.text$mn:000068D6                 retn
.text$mn:000068D6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000068D6
.text$mn:000068D6 ; ---------------------------------------------------------------------------
.text$mn:000068D7                 align 4
.text$mn:000068D7 _text$mn        ends
.text$mn:000068D7
.text$x:000068D8 ; ===========================================================================
.text$x:000068D8
.text$x:000068D8 ; Segment type: Pure code
.text$x:000068D8 ; Segment permissions: Read/Execute
.text$x:000068D8 _text$x         segment para public 'CODE' use32
.text$x:000068D8                 assume cs:_text$x
.text$x:000068D8                 ;org 68D8h
.text$x:000068D8 ; COMDAT (pick associative to section at 6880)
.text$x:000068D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000068D8
.text$x:000068D8 ; =============== S U B R O U T I N E =======================================
.text$x:000068D8
.text$x:000068D8
.text$x:000068D8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000068D8                                         ; DATA XREF: .xdata$x:0000CF10o
.text$x:000068D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000068DB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000068DB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000068DB
.text$x:000068E0
.text$x:000068E0 ; =============== S U B R O U T I N E =======================================
.text$x:000068E0
.text$x:000068E0
.text$x:000068E0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000068E0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000068E0
.text$x:000068E0 arg_4           = dword ptr  8
.text$x:000068E0
.text$x:000068E0                 mov     edx, [esp+arg_4]
.text$x:000068E4                 lea     eax, [edx+0Ch]
.text$x:000068E7                 mov     ecx, [edx-8]
.text$x:000068EA                 xor     ecx, eax
.text$x:000068EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000068F1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000068F6                 jmp     ___CxxFrameHandler3
.text$x:000068F6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000068F6
.text$x:000068F6 ; ---------------------------------------------------------------------------
.text$x:000068FB                 align 4
.text$x:000068FB _text$x         ends
.text$x:000068FB
.text$mn:000068FC ; ===========================================================================
.text$mn:000068FC
.text$mn:000068FC ; Segment type: Pure code
.text$mn:000068FC ; Segment permissions: Read/Execute
.text$mn:000068FC _text$mn        segment para public 'CODE' use32
.text$mn:000068FC                 assume cs:_text$mn
.text$mn:000068FC                 ;org 68FCh
.text$mn:000068FC ; COMDAT (pick any)
.text$mn:000068FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068FC
.text$mn:000068FC ; =============== S U B R O U T I N E =======================================
.text$mn:000068FC
.text$mn:000068FC ; Attributes: bp-based frame
.text$mn:000068FC
.text$mn:000068FC ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:000068FC                 public ??0_Ignore@std@@QAE@XZ
.text$mn:000068FC ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:000068FC
.text$mn:000068FC var_4           = dword ptr -4
.text$mn:000068FC
.text$mn:000068FC                 push    ebp
.text$mn:000068FD                 mov     ebp, esp
.text$mn:000068FF                 push    ecx
.text$mn:00006900                 mov     [ebp+var_4], ecx
.text$mn:00006903                 mov     eax, [ebp+var_4]
.text$mn:00006906                 mov     esp, ebp
.text$mn:00006908                 pop     ebp
.text$mn:00006909                 retn
.text$mn:00006909 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00006909
.text$mn:00006909 ; ---------------------------------------------------------------------------
.text$mn:0000690A                 align 4
.text$mn:0000690A _text$mn        ends
.text$mn:0000690A
.text$mn:0000690C ; ===========================================================================
.text$mn:0000690C
.text$mn:0000690C ; Segment type: Pure code
.text$mn:0000690C ; Segment permissions: Read/Execute
.text$mn:0000690C _text$mn        segment para public 'CODE' use32
.text$mn:0000690C                 assume cs:_text$mn
.text$mn:0000690C                 ;org 690Ch
.text$mn:0000690C ; COMDAT (pick any)
.text$mn:0000690C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000690C
.text$mn:0000690C ; =============== S U B R O U T I N E =======================================
.text$mn:0000690C
.text$mn:0000690C ; Attributes: bp-based frame
.text$mn:0000690C
.text$mn:0000690C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000690C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000690C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:0000690C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000690C
.text$mn:0000690C var_10          = dword ptr -10h
.text$mn:0000690C var_C           = dword ptr -0Ch
.text$mn:0000690C var_4           = dword ptr -4
.text$mn:0000690C
.text$mn:0000690C                 push    ebp
.text$mn:0000690D                 mov     ebp, esp
.text$mn:0000690F                 push    0FFFFFFFFh
.text$mn:00006911                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00006916                 mov     eax, large fs:0
.text$mn:0000691C                 push    eax
.text$mn:0000691D                 push    ecx
.text$mn:0000691E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006923                 xor     eax, ebp
.text$mn:00006925                 push    eax
.text$mn:00006926                 lea     eax, [ebp+var_C]
.text$mn:00006929                 mov     large fs:0, eax
.text$mn:0000692F                 mov     [ebp+var_10], ecx
.text$mn:00006932                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006935                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000693A                 mov     [ebp+var_4], 0
.text$mn:00006941                 mov     eax, [ebp+var_10]
.text$mn:00006944                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000694A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006951                 mov     eax, [ebp+var_10]
.text$mn:00006954                 mov     ecx, [ebp+var_C]
.text$mn:00006957                 mov     large fs:0, ecx
.text$mn:0000695E                 pop     ecx
.text$mn:0000695F                 mov     esp, ebp
.text$mn:00006961                 pop     ebp
.text$mn:00006962                 retn
.text$mn:00006962 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00006962
.text$mn:00006962 ; ---------------------------------------------------------------------------
.text$mn:00006963                 align 4
.text$mn:00006963 _text$mn        ends
.text$mn:00006963
.text$x:00006964 ; ===========================================================================
.text$x:00006964
.text$x:00006964 ; Segment type: Pure code
.text$x:00006964 ; Segment permissions: Read/Execute
.text$x:00006964 _text$x         segment para public 'CODE' use32
.text$x:00006964                 assume cs:_text$x
.text$x:00006964                 ;org 6964h
.text$x:00006964 ; COMDAT (pick associative to section at 690C)
.text$x:00006964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006964
.text$x:00006964 ; =============== S U B R O U T I N E =======================================
.text$x:00006964
.text$x:00006964
.text$x:00006964 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00006964                                         ; DATA XREF: .xdata$x:0000CF94o
.text$x:00006964                 mov     ecx, [ebp-10h]  ; this
.text$x:00006967                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006967 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00006967
.text$x:0000696C
.text$x:0000696C ; =============== S U B R O U T I N E =======================================
.text$x:0000696C
.text$x:0000696C
.text$x:0000696C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000696C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000696C
.text$x:0000696C arg_4           = dword ptr  8
.text$x:0000696C
.text$x:0000696C                 mov     edx, [esp+arg_4]
.text$x:00006970                 lea     eax, [edx+0Ch]
.text$x:00006973                 mov     ecx, [edx-8]
.text$x:00006976                 xor     ecx, eax
.text$x:00006978                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000697D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00006982                 jmp     ___CxxFrameHandler3
.text$x:00006982 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00006982
.text$x:00006982 ; ---------------------------------------------------------------------------
.text$x:00006987                 align 4
.text$x:00006987 _text$x         ends
.text$x:00006987
.text$mn:00006988 ; ===========================================================================
.text$mn:00006988
.text$mn:00006988 ; Segment type: Pure code
.text$mn:00006988 ; Segment permissions: Read/Execute
.text$mn:00006988 _text$mn        segment para public 'CODE' use32
.text$mn:00006988                 assume cs:_text$mn
.text$mn:00006988                 ;org 6988h
.text$mn:00006988 ; COMDAT (pick any)
.text$mn:00006988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006988
.text$mn:00006988 ; =============== S U B R O U T I N E =======================================
.text$mn:00006988
.text$mn:00006988 ; Attributes: bp-based frame
.text$mn:00006988
.text$mn:00006988 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00006988                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00006988 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00006988                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00006988                                         ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12> const &)+2Dp ...
.text$mn:00006988
.text$mn:00006988 var_4           = dword ptr -4
.text$mn:00006988 arg_0           = dword ptr  8
.text$mn:00006988
.text$mn:00006988                 push    ebp
.text$mn:00006989                 mov     ebp, esp
.text$mn:0000698B                 push    ecx
.text$mn:0000698C                 mov     [ebp+var_4], ecx
.text$mn:0000698F                 mov     eax, [ebp+var_4]
.text$mn:00006992                 mov     dword ptr [eax], 0
.text$mn:00006998                 mov     ecx, [ebp+var_4]
.text$mn:0000699B                 mov     dword ptr [ecx+4], 0
.text$mn:000069A2                 mov     edx, [ebp+arg_0]
.text$mn:000069A5                 push    edx
.text$mn:000069A6                 mov     ecx, [ebp+var_4]
.text$mn:000069A9                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:000069AE                 mov     eax, [ebp+var_4]
.text$mn:000069B1                 mov     esp, ebp
.text$mn:000069B3                 pop     ebp
.text$mn:000069B4                 retn    4
.text$mn:000069B4 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:000069B4
.text$mn:000069B4 ; ---------------------------------------------------------------------------
.text$mn:000069B7                 align 4
.text$mn:000069B7 _text$mn        ends
.text$mn:000069B7
.text$mn:000069B8 ; ===========================================================================
.text$mn:000069B8
.text$mn:000069B8 ; Segment type: Pure code
.text$mn:000069B8 ; Segment permissions: Read/Execute
.text$mn:000069B8 _text$mn        segment para public 'CODE' use32
.text$mn:000069B8                 assume cs:_text$mn
.text$mn:000069B8                 ;org 69B8h
.text$mn:000069B8 ; COMDAT (pick any)
.text$mn:000069B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069B8
.text$mn:000069B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000069B8
.text$mn:000069B8 ; Attributes: bp-based frame
.text$mn:000069B8
.text$mn:000069B8 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:000069B8                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:000069B8 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:000069B8                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)+29p
.text$mn:000069B8                                         ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)+29p ...
.text$mn:000069B8
.text$mn:000069B8 var_4           = dword ptr -4
.text$mn:000069B8
.text$mn:000069B8                 push    ebp
.text$mn:000069B9                 mov     ebp, esp
.text$mn:000069BB                 push    ecx
.text$mn:000069BC                 mov     [ebp+var_4], ecx
.text$mn:000069BF                 mov     eax, [ebp+var_4]
.text$mn:000069C2                 mov     dword ptr [eax], 0
.text$mn:000069C8                 mov     ecx, [ebp+var_4]
.text$mn:000069CB                 mov     dword ptr [ecx+4], 0
.text$mn:000069D2                 mov     eax, [ebp+var_4]
.text$mn:000069D5                 mov     esp, ebp
.text$mn:000069D7                 pop     ebp
.text$mn:000069D8                 retn
.text$mn:000069D8 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:000069D8
.text$mn:000069D8 ; ---------------------------------------------------------------------------
.text$mn:000069D9                 align 4
.text$mn:000069D9 _text$mn        ends
.text$mn:000069D9
.text$mn:000069DC ; ===========================================================================
.text$mn:000069DC
.text$mn:000069DC ; Segment type: Pure code
.text$mn:000069DC ; Segment permissions: Read/Execute
.text$mn:000069DC _text$mn        segment para public 'CODE' use32
.text$mn:000069DC                 assume cs:_text$mn
.text$mn:000069DC                 ;org 69DCh
.text$mn:000069DC ; COMDAT (pick any)
.text$mn:000069DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069DC
.text$mn:000069DC ; =============== S U B R O U T I N E =======================================
.text$mn:000069DC
.text$mn:000069DC ; Attributes: bp-based frame
.text$mn:000069DC
.text$mn:000069DC ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000069DC                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:000069DC ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:000069DC                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000069DC
.text$mn:000069DC var_10          = dword ptr -10h
.text$mn:000069DC var_C           = dword ptr -0Ch
.text$mn:000069DC var_4           = dword ptr -4
.text$mn:000069DC
.text$mn:000069DC                 push    ebp
.text$mn:000069DD                 mov     ebp, esp
.text$mn:000069DF                 push    0FFFFFFFFh
.text$mn:000069E1                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:000069E6                 mov     eax, large fs:0
.text$mn:000069EC                 push    eax
.text$mn:000069ED                 push    ecx
.text$mn:000069EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069F3                 xor     eax, ebp
.text$mn:000069F5                 push    eax
.text$mn:000069F6                 lea     eax, [ebp+var_C]
.text$mn:000069F9                 mov     large fs:0, eax
.text$mn:000069FF                 mov     [ebp+var_10], ecx
.text$mn:00006A02                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006A05                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00006A0A                 mov     [ebp+var_4], 0
.text$mn:00006A11                 mov     eax, [ebp+var_10]
.text$mn:00006A14                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00006A1A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A21                 mov     eax, [ebp+var_10]
.text$mn:00006A24                 mov     ecx, [ebp+var_C]
.text$mn:00006A27                 mov     large fs:0, ecx
.text$mn:00006A2E                 pop     ecx
.text$mn:00006A2F                 mov     esp, ebp
.text$mn:00006A31                 pop     ebp
.text$mn:00006A32                 retn
.text$mn:00006A32 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00006A32
.text$mn:00006A32 ; ---------------------------------------------------------------------------
.text$mn:00006A33                 align 4
.text$mn:00006A33 _text$mn        ends
.text$mn:00006A33
.text$x:00006A34 ; ===========================================================================
.text$x:00006A34
.text$x:00006A34 ; Segment type: Pure code
.text$x:00006A34 ; Segment permissions: Read/Execute
.text$x:00006A34 _text$x         segment para public 'CODE' use32
.text$x:00006A34                 assume cs:_text$x
.text$x:00006A34                 ;org 6A34h
.text$x:00006A34 ; COMDAT (pick associative to section at 69DC)
.text$x:00006A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006A34
.text$x:00006A34 ; =============== S U B R O U T I N E =======================================
.text$x:00006A34
.text$x:00006A34
.text$x:00006A34 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00006A34                                         ; DATA XREF: .xdata$x:0000D018o
.text$x:00006A34                 mov     ecx, [ebp-10h]  ; this
.text$x:00006A37                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006A37 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00006A37
.text$x:00006A3C
.text$x:00006A3C ; =============== S U B R O U T I N E =======================================
.text$x:00006A3C
.text$x:00006A3C
.text$x:00006A3C __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00006A3C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00006A3C
.text$x:00006A3C arg_4           = dword ptr  8
.text$x:00006A3C
.text$x:00006A3C                 mov     edx, [esp+arg_4]
.text$x:00006A40                 lea     eax, [edx+0Ch]
.text$x:00006A43                 mov     ecx, [edx-8]
.text$x:00006A46                 xor     ecx, eax
.text$x:00006A48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A4D                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00006A52                 jmp     ___CxxFrameHandler3
.text$x:00006A52 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00006A52
.text$x:00006A52 ; ---------------------------------------------------------------------------
.text$x:00006A57                 align 4
.text$x:00006A57 _text$x         ends
.text$x:00006A57
.text$mn:00006A58 ; ===========================================================================
.text$mn:00006A58
.text$mn:00006A58 ; Segment type: Pure code
.text$mn:00006A58 ; Segment permissions: Read/Execute
.text$mn:00006A58 _text$mn        segment para public 'CODE' use32
.text$mn:00006A58                 assume cs:_text$mn
.text$mn:00006A58                 ;org 6A58h
.text$mn:00006A58 ; COMDAT (pick any)
.text$mn:00006A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A58
.text$mn:00006A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A58
.text$mn:00006A58 ; Attributes: bp-based frame
.text$mn:00006A58
.text$mn:00006A58 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00006A58                 public ??0error_category@std@@QAE@XZ
.text$mn:00006A58 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00006A58
.text$mn:00006A58 var_4           = dword ptr -4
.text$mn:00006A58
.text$mn:00006A58                 push    ebp
.text$mn:00006A59                 mov     ebp, esp
.text$mn:00006A5B                 push    ecx
.text$mn:00006A5C                 mov     [ebp+var_4], ecx
.text$mn:00006A5F                 mov     eax, [ebp+var_4]
.text$mn:00006A62                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00006A68                 mov     eax, [ebp+var_4]
.text$mn:00006A6B                 mov     esp, ebp
.text$mn:00006A6D                 pop     ebp
.text$mn:00006A6E                 retn
.text$mn:00006A6E ??0error_category@std@@QAE@XZ endp
.text$mn:00006A6E
.text$mn:00006A6E ; ---------------------------------------------------------------------------
.text$mn:00006A6F                 align 10h
.text$mn:00006A6F _text$mn        ends
.text$mn:00006A6F
.text$mn:00006A70 ; ===========================================================================
.text$mn:00006A70
.text$mn:00006A70 ; Segment type: Pure code
.text$mn:00006A70 ; Segment permissions: Read/Execute
.text$mn:00006A70 _text$mn        segment para public 'CODE' use32
.text$mn:00006A70                 assume cs:_text$mn
.text$mn:00006A70                 ;org 6A70h
.text$mn:00006A70 ; COMDAT (pick any)
.text$mn:00006A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A70
.text$mn:00006A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A70
.text$mn:00006A70 ; Attributes: bp-based frame
.text$mn:00006A70
.text$mn:00006A70 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00006A70                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00006A70 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00006A70                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00006A70                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00006A70
.text$mn:00006A70 var_4           = dword ptr -4
.text$mn:00006A70 arg_0           = dword ptr  8
.text$mn:00006A70 arg_4           = dword ptr  0Ch
.text$mn:00006A70
.text$mn:00006A70                 push    ebp
.text$mn:00006A71                 mov     ebp, esp
.text$mn:00006A73                 push    ecx
.text$mn:00006A74                 mov     [ebp+var_4], ecx
.text$mn:00006A77                 mov     eax, [ebp+var_4]
.text$mn:00006A7A                 mov     ecx, [ebp+arg_0]
.text$mn:00006A7D                 mov     [eax], ecx
.text$mn:00006A7F                 mov     edx, [ebp+var_4]
.text$mn:00006A82                 mov     eax, [ebp+arg_4]
.text$mn:00006A85                 mov     [edx+4], eax
.text$mn:00006A88                 mov     eax, [ebp+var_4]
.text$mn:00006A8B                 mov     esp, ebp
.text$mn:00006A8D                 pop     ebp
.text$mn:00006A8E                 retn    8
.text$mn:00006A8E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00006A8E
.text$mn:00006A8E ; ---------------------------------------------------------------------------
.text$mn:00006A91                 align 4
.text$mn:00006A91 _text$mn        ends
.text$mn:00006A91
.text$mn:00006A94 ; ===========================================================================
.text$mn:00006A94
.text$mn:00006A94 ; Segment type: Pure code
.text$mn:00006A94 ; Segment permissions: Read/Execute
.text$mn:00006A94 _text$mn        segment para public 'CODE' use32
.text$mn:00006A94                 assume cs:_text$mn
.text$mn:00006A94                 ;org 6A94h
.text$mn:00006A94 ; COMDAT (pick any)
.text$mn:00006A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A94
.text$mn:00006A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A94
.text$mn:00006A94 ; Attributes: bp-based frame
.text$mn:00006A94
.text$mn:00006A94 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00006A94                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00006A94 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00006A94                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00006A94
.text$mn:00006A94 var_4           = dword ptr -4
.text$mn:00006A94 arg_0           = dword ptr  8
.text$mn:00006A94
.text$mn:00006A94                 push    ebp
.text$mn:00006A95                 mov     ebp, esp
.text$mn:00006A97                 push    ecx
.text$mn:00006A98                 mov     [ebp+var_4], ecx
.text$mn:00006A9B                 mov     eax, [ebp+var_4]
.text$mn:00006A9E                 mov     ecx, [ebp+arg_0]
.text$mn:00006AA1                 mov     [eax], ecx
.text$mn:00006AA3                 mov     eax, [ebp+var_4]
.text$mn:00006AA6                 mov     esp, ebp
.text$mn:00006AA8                 pop     ebp
.text$mn:00006AA9                 retn    4
.text$mn:00006AA9 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00006AA9
.text$mn:00006AA9 _text$mn        ends
.text$mn:00006AA9
.text$mn:00006AAC ; ===========================================================================
.text$mn:00006AAC
.text$mn:00006AAC ; Segment type: Pure code
.text$mn:00006AAC ; Segment permissions: Read/Execute
.text$mn:00006AAC _text$mn        segment para public 'CODE' use32
.text$mn:00006AAC                 assume cs:_text$mn
.text$mn:00006AAC                 ;org 6AACh
.text$mn:00006AAC ; COMDAT (pick any)
.text$mn:00006AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AAC
.text$mn:00006AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00006AAC
.text$mn:00006AAC ; Attributes: bp-based frame
.text$mn:00006AAC
.text$mn:00006AAC ; public: __thiscall recordedMacroStep::recordedMacroStep(struct recordedMacroStep const &)
.text$mn:00006AAC                 public ??0recordedMacroStep@@QAE@ABU0@@Z
.text$mn:00006AAC ??0recordedMacroStep@@QAE@ABU0@@Z proc near
.text$mn:00006AAC                                         ; CODE XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep &>(recordedMacroStep *,recordedMacroStep &)+56p
.text$mn:00006AAC                                         ; std::allocator<recordedMacroStep>::construct(recordedMacroStep *,recordedMacroStep const &)+4Dp
.text$mn:00006AAC
.text$mn:00006AAC var_10          = dword ptr -10h
.text$mn:00006AAC var_C           = dword ptr -0Ch
.text$mn:00006AAC var_4           = dword ptr -4
.text$mn:00006AAC arg_0           = dword ptr  8
.text$mn:00006AAC
.text$mn:00006AAC                 push    ebp
.text$mn:00006AAD                 mov     ebp, esp
.text$mn:00006AAF                 push    0FFFFFFFFh
.text$mn:00006AB1                 push    offset __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z
.text$mn:00006AB6                 mov     eax, large fs:0
.text$mn:00006ABC                 push    eax
.text$mn:00006ABD                 push    ecx
.text$mn:00006ABE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006AC3                 xor     eax, ebp
.text$mn:00006AC5                 push    eax
.text$mn:00006AC6                 lea     eax, [ebp+var_C]
.text$mn:00006AC9                 mov     large fs:0, eax
.text$mn:00006ACF                 mov     [ebp+var_10], ecx
.text$mn:00006AD2                 mov     eax, [ebp+var_10]
.text$mn:00006AD5                 mov     ecx, [ebp+arg_0]
.text$mn:00006AD8                 mov     edx, [ecx]
.text$mn:00006ADA                 mov     [eax], edx
.text$mn:00006ADC                 mov     eax, [ebp+var_10]
.text$mn:00006ADF                 mov     ecx, [ebp+arg_0]
.text$mn:00006AE2                 mov     edx, [ecx+4]
.text$mn:00006AE5                 mov     [eax+4], edx
.text$mn:00006AE8                 mov     eax, [ebp+var_10]
.text$mn:00006AEB                 mov     ecx, [ebp+arg_0]
.text$mn:00006AEE                 mov     edx, [ecx+8]
.text$mn:00006AF1                 mov     [eax+8], edx
.text$mn:00006AF4                 mov     eax, [ebp+arg_0]
.text$mn:00006AF7                 add     eax, 0Ch
.text$mn:00006AFA                 push    eax
.text$mn:00006AFB                 mov     ecx, [ebp+var_10]
.text$mn:00006AFE                 add     ecx, 0Ch
.text$mn:00006B01                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00006B06                 mov     [ebp+var_4], 0
.text$mn:00006B0D                 mov     ecx, [ebp+var_10]
.text$mn:00006B10                 mov     edx, [ebp+arg_0]
.text$mn:00006B13                 mov     eax, [edx+28h]
.text$mn:00006B16                 mov     [ecx+28h], eax
.text$mn:00006B19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B20                 mov     eax, [ebp+var_10]
.text$mn:00006B23                 mov     ecx, [ebp+var_C]
.text$mn:00006B26                 mov     large fs:0, ecx
.text$mn:00006B2D                 pop     ecx
.text$mn:00006B2E                 mov     esp, ebp
.text$mn:00006B30                 pop     ebp
.text$mn:00006B31                 retn    4
.text$mn:00006B31 ??0recordedMacroStep@@QAE@ABU0@@Z endp
.text$mn:00006B31
.text$mn:00006B31 _text$mn        ends
.text$mn:00006B31
.text$x:00006B34 ; ===========================================================================
.text$x:00006B34
.text$x:00006B34 ; Segment type: Pure code
.text$x:00006B34 ; Segment permissions: Read/Execute
.text$x:00006B34 _text$x         segment para public 'CODE' use32
.text$x:00006B34                 assume cs:_text$x
.text$x:00006B34                 ;org 6B34h
.text$x:00006B34 ; COMDAT (pick associative to section at 6AAC)
.text$x:00006B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006B34
.text$x:00006B34 ; =============== S U B R O U T I N E =======================================
.text$x:00006B34
.text$x:00006B34
.text$x:00006B34 __unwindfunclet$??0recordedMacroStep@@QAE@ABU0@@Z$0 proc near
.text$x:00006B34                                         ; DATA XREF: .xdata$x:0000D678o
.text$x:00006B34                 mov     ecx, [ebp-10h]
.text$x:00006B37                 add     ecx, 0Ch
.text$x:00006B3A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006B3A __unwindfunclet$??0recordedMacroStep@@QAE@ABU0@@Z$0 endp
.text$x:00006B3A
.text$x:00006B3F
.text$x:00006B3F ; =============== S U B R O U T I N E =======================================
.text$x:00006B3F
.text$x:00006B3F
.text$x:00006B3F __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z proc near
.text$x:00006B3F                                         ; DATA XREF: recordedMacroStep::recordedMacroStep(recordedMacroStep const &)+5o
.text$x:00006B3F
.text$x:00006B3F arg_4           = dword ptr  8
.text$x:00006B3F
.text$x:00006B3F                 mov     edx, [esp+arg_4]
.text$x:00006B43                 lea     eax, [edx+0Ch]
.text$x:00006B46                 mov     ecx, [edx-8]
.text$x:00006B49                 xor     ecx, eax
.text$x:00006B4B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B50                 mov     eax, offset __ehfuncinfo$??0recordedMacroStep@@QAE@ABU0@@Z
.text$x:00006B55                 jmp     ___CxxFrameHandler3
.text$x:00006B55 __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z endp
.text$x:00006B55
.text$x:00006B55 ; ---------------------------------------------------------------------------
.text$x:00006B5A                 align 4
.text$x:00006B5A _text$x         ends
.text$x:00006B5A
.text$mn:00006B5C ; ===========================================================================
.text$mn:00006B5C
.text$mn:00006B5C ; Segment type: Pure code
.text$mn:00006B5C ; Segment permissions: Read/Execute
.text$mn:00006B5C _text$mn        segment para public 'CODE' use32
.text$mn:00006B5C                 assume cs:_text$mn
.text$mn:00006B5C                 ;org 6B5Ch
.text$mn:00006B5C ; COMDAT (pick any)
.text$mn:00006B5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B5C
.text$mn:00006B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B5C
.text$mn:00006B5C ; Attributes: bp-based frame
.text$mn:00006B5C
.text$mn:00006B5C ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct KeyCombo, int, struct KeyCombo const *, struct KeyCombo const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct KeyCombo, int, struct KeyCombo const *, struct KeyCombo const &, struct std::_Iterator_base12>(void)
.text$mn:00006B5C                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006B5C ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00006B5C                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006B5C                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006B5C
.text$mn:00006B5C var_10          = dword ptr -10h
.text$mn:00006B5C var_C           = dword ptr -0Ch
.text$mn:00006B5C var_4           = dword ptr -4
.text$mn:00006B5C
.text$mn:00006B5C                 push    ebp
.text$mn:00006B5D                 mov     ebp, esp
.text$mn:00006B5F                 push    0FFFFFFFFh
.text$mn:00006B61                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006B66                 mov     eax, large fs:0
.text$mn:00006B6C                 push    eax
.text$mn:00006B6D                 push    ecx
.text$mn:00006B6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B73                 xor     eax, ebp
.text$mn:00006B75                 push    eax
.text$mn:00006B76                 lea     eax, [ebp+var_C]
.text$mn:00006B79                 mov     large fs:0, eax
.text$mn:00006B7F                 mov     [ebp+var_10], ecx
.text$mn:00006B82                 mov     [ebp+var_4], 0
.text$mn:00006B89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B90                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006B93                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006B98                 mov     ecx, [ebp+var_C]
.text$mn:00006B9B                 mov     large fs:0, ecx
.text$mn:00006BA2                 pop     ecx
.text$mn:00006BA3                 mov     esp, ebp
.text$mn:00006BA5                 pop     ebp
.text$mn:00006BA6                 retn
.text$mn:00006BA6 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00006BA6
.text$mn:00006BA6 ; ---------------------------------------------------------------------------
.text$mn:00006BA7                 align 4
.text$mn:00006BA7 _text$mn        ends
.text$mn:00006BA7
.text$x:00006BA8 ; ===========================================================================
.text$x:00006BA8
.text$x:00006BA8 ; Segment type: Pure code
.text$x:00006BA8 ; Segment permissions: Read/Execute
.text$x:00006BA8 _text$x         segment para public 'CODE' use32
.text$x:00006BA8                 assume cs:_text$x
.text$x:00006BA8                 ;org 6BA8h
.text$x:00006BA8 ; COMDAT (pick associative to section at 6B5C)
.text$x:00006BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006BA8
.text$x:00006BA8 ; =============== S U B R O U T I N E =======================================
.text$x:00006BA8
.text$x:00006BA8
.text$x:00006BA8 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006BA8                                         ; DATA XREF: .xdata$x:0000D570o
.text$x:00006BA8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006BAB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006BAB __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006BAB
.text$x:00006BB0
.text$x:00006BB0 ; =============== S U B R O U T I N E =======================================
.text$x:00006BB0
.text$x:00006BB0
.text$x:00006BB0 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00006BB0                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)+5o
.text$x:00006BB0
.text$x:00006BB0 arg_4           = dword ptr  8
.text$x:00006BB0
.text$x:00006BB0                 mov     edx, [esp+arg_4]
.text$x:00006BB4                 lea     eax, [edx+0Ch]
.text$x:00006BB7                 mov     ecx, [edx-8]
.text$x:00006BBA                 xor     ecx, eax
.text$x:00006BBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BC1                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00006BC6                 jmp     ___CxxFrameHandler3
.text$x:00006BC6 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00006BC6
.text$x:00006BC6 ; ---------------------------------------------------------------------------
.text$x:00006BCB                 align 4
.text$x:00006BCB _text$x         ends
.text$x:00006BCB
.text$mn:00006BCC ; ===========================================================================
.text$mn:00006BCC
.text$mn:00006BCC ; Segment type: Pure code
.text$mn:00006BCC ; Segment permissions: Read/Execute
.text$mn:00006BCC _text$mn        segment para public 'CODE' use32
.text$mn:00006BCC                 assume cs:_text$mn
.text$mn:00006BCC                 ;org 6BCCh
.text$mn:00006BCC ; COMDAT (pick any)
.text$mn:00006BCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BCC
.text$mn:00006BCC ; =============== S U B R O U T I N E =======================================
.text$mn:00006BCC
.text$mn:00006BCC ; Attributes: bp-based frame
.text$mn:00006BCC
.text$mn:00006BCC ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct recordedMacroStep, int, struct recordedMacroStep const *, struct recordedMacroStep const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct recordedMacroStep, int, struct recordedMacroStep const *, struct recordedMacroStep const &, struct std::_Iterator_base12>(void)
.text$mn:00006BCC                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006BCC ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00006BCC                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006BCC                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006BCC
.text$mn:00006BCC var_10          = dword ptr -10h
.text$mn:00006BCC var_C           = dword ptr -0Ch
.text$mn:00006BCC var_4           = dword ptr -4
.text$mn:00006BCC
.text$mn:00006BCC                 push    ebp
.text$mn:00006BCD                 mov     ebp, esp
.text$mn:00006BCF                 push    0FFFFFFFFh
.text$mn:00006BD1                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006BD6                 mov     eax, large fs:0
.text$mn:00006BDC                 push    eax
.text$mn:00006BDD                 push    ecx
.text$mn:00006BDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006BE3                 xor     eax, ebp
.text$mn:00006BE5                 push    eax
.text$mn:00006BE6                 lea     eax, [ebp+var_C]
.text$mn:00006BE9                 mov     large fs:0, eax
.text$mn:00006BEF                 mov     [ebp+var_10], ecx
.text$mn:00006BF2                 mov     [ebp+var_4], 0
.text$mn:00006BF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C00                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006C03                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006C08                 mov     ecx, [ebp+var_C]
.text$mn:00006C0B                 mov     large fs:0, ecx
.text$mn:00006C12                 pop     ecx
.text$mn:00006C13                 mov     esp, ebp
.text$mn:00006C15                 pop     ebp
.text$mn:00006C16                 retn
.text$mn:00006C16 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00006C16
.text$mn:00006C16 ; ---------------------------------------------------------------------------
.text$mn:00006C17                 align 4
.text$mn:00006C17 _text$mn        ends
.text$mn:00006C17
.text$x:00006C18 ; ===========================================================================
.text$x:00006C18
.text$x:00006C18 ; Segment type: Pure code
.text$x:00006C18 ; Segment permissions: Read/Execute
.text$x:00006C18 _text$x         segment para public 'CODE' use32
.text$x:00006C18                 assume cs:_text$x
.text$x:00006C18                 ;org 6C18h
.text$x:00006C18 ; COMDAT (pick associative to section at 6BCC)
.text$x:00006C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006C18
.text$x:00006C18 ; =============== S U B R O U T I N E =======================================
.text$x:00006C18
.text$x:00006C18
.text$x:00006C18 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006C18                                         ; DATA XREF: .xdata$x:0000E2B8o
.text$x:00006C18                 mov     ecx, [ebp-10h]  ; this
.text$x:00006C1B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006C1B __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006C1B
.text$x:00006C20
.text$x:00006C20 ; =============== S U B R O U T I N E =======================================
.text$x:00006C20
.text$x:00006C20
.text$x:00006C20 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00006C20                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)+5o
.text$x:00006C20
.text$x:00006C20 arg_4           = dword ptr  8
.text$x:00006C20
.text$x:00006C20                 mov     edx, [esp+arg_4]
.text$x:00006C24                 lea     eax, [edx+0Ch]
.text$x:00006C27                 mov     ecx, [edx-8]
.text$x:00006C2A                 xor     ecx, eax
.text$x:00006C2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C31                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00006C36                 jmp     ___CxxFrameHandler3
.text$x:00006C36 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00006C36
.text$x:00006C36 ; ---------------------------------------------------------------------------
.text$x:00006C3B                 align 4
.text$x:00006C3B _text$x         ends
.text$x:00006C3B
.text$mn:00006C3C ; ===========================================================================
.text$mn:00006C3C
.text$mn:00006C3C ; Segment type: Pure code
.text$mn:00006C3C ; Segment permissions: Read/Execute
.text$mn:00006C3C _text$mn        segment para public 'CODE' use32
.text$mn:00006C3C                 assume cs:_text$mn
.text$mn:00006C3C                 ;org 6C3Ch
.text$mn:00006C3C ; COMDAT (pick any)
.text$mn:00006C3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C3C
.text$mn:00006C3C ; =============== S U B R O U T I N E =======================================
.text$mn:00006C3C
.text$mn:00006C3C ; Attributes: bp-based frame
.text$mn:00006C3C
.text$mn:00006C3C ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class MacroShortcut, int, class MacroShortcut const *, class MacroShortcut const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, class MacroShortcut, int, class MacroShortcut const *, class MacroShortcut const &, struct std::_Iterator_base12>(void)
.text$mn:00006C3C                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006C3C ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00006C3C                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006C3C                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006C3C
.text$mn:00006C3C var_10          = dword ptr -10h
.text$mn:00006C3C var_C           = dword ptr -0Ch
.text$mn:00006C3C var_4           = dword ptr -4
.text$mn:00006C3C
.text$mn:00006C3C                 push    ebp
.text$mn:00006C3D                 mov     ebp, esp
.text$mn:00006C3F                 push    0FFFFFFFFh
.text$mn:00006C41                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006C46                 mov     eax, large fs:0
.text$mn:00006C4C                 push    eax
.text$mn:00006C4D                 push    ecx
.text$mn:00006C4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006C53                 xor     eax, ebp
.text$mn:00006C55                 push    eax
.text$mn:00006C56                 lea     eax, [ebp+var_C]
.text$mn:00006C59                 mov     large fs:0, eax
.text$mn:00006C5F                 mov     [ebp+var_10], ecx
.text$mn:00006C62                 mov     [ebp+var_4], 0
.text$mn:00006C69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C70                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006C73                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006C78                 mov     ecx, [ebp+var_C]
.text$mn:00006C7B                 mov     large fs:0, ecx
.text$mn:00006C82                 pop     ecx
.text$mn:00006C83                 mov     esp, ebp
.text$mn:00006C85                 pop     ebp
.text$mn:00006C86                 retn
.text$mn:00006C86 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00006C86
.text$mn:00006C86 ; ---------------------------------------------------------------------------
.text$mn:00006C87                 align 4
.text$mn:00006C87 _text$mn        ends
.text$mn:00006C87
.text$x:00006C88 ; ===========================================================================
.text$x:00006C88
.text$x:00006C88 ; Segment type: Pure code
.text$x:00006C88 ; Segment permissions: Read/Execute
.text$x:00006C88 _text$x         segment para public 'CODE' use32
.text$x:00006C88                 assume cs:_text$x
.text$x:00006C88                 ;org 6C88h
.text$x:00006C88 ; COMDAT (pick associative to section at 6C3C)
.text$x:00006C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006C88
.text$x:00006C88 ; =============== S U B R O U T I N E =======================================
.text$x:00006C88
.text$x:00006C88
.text$x:00006C88 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006C88                                         ; DATA XREF: .xdata$x:0000DEF4o
.text$x:00006C88                 mov     ecx, [ebp-10h]  ; this
.text$x:00006C8B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006C8B __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006C8B
.text$x:00006C90
.text$x:00006C90 ; =============== S U B R O U T I N E =======================================
.text$x:00006C90
.text$x:00006C90
.text$x:00006C90 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00006C90                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(void)+5o
.text$x:00006C90
.text$x:00006C90 arg_4           = dword ptr  8
.text$x:00006C90
.text$x:00006C90                 mov     edx, [esp+arg_4]
.text$x:00006C94                 lea     eax, [edx+0Ch]
.text$x:00006C97                 mov     ecx, [edx-8]
.text$x:00006C9A                 xor     ecx, eax
.text$x:00006C9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CA1                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00006CA6                 jmp     ___CxxFrameHandler3
.text$x:00006CA6 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00006CA6
.text$x:00006CA6 ; ---------------------------------------------------------------------------
.text$x:00006CAB                 align 4
.text$x:00006CAB _text$x         ends
.text$x:00006CAB
.text$mn:00006CAC ; ===========================================================================
.text$mn:00006CAC
.text$mn:00006CAC ; Segment type: Pure code
.text$mn:00006CAC ; Segment permissions: Read/Execute
.text$mn:00006CAC _text$mn        segment para public 'CODE' use32
.text$mn:00006CAC                 assume cs:_text$mn
.text$mn:00006CAC                 ;org 6CACh
.text$mn:00006CAC ; COMDAT (pick any)
.text$mn:00006CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CAC
.text$mn:00006CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00006CAC
.text$mn:00006CAC ; Attributes: bp-based frame
.text$mn:00006CAC
.text$mn:00006CAC ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class UserCommand, int, class UserCommand const *, class UserCommand const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, class UserCommand, int, class UserCommand const *, class UserCommand const &, struct std::_Iterator_base12>(void)
.text$mn:00006CAC                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006CAC ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00006CAC                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006CAC                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006CAC
.text$mn:00006CAC var_10          = dword ptr -10h
.text$mn:00006CAC var_C           = dword ptr -0Ch
.text$mn:00006CAC var_4           = dword ptr -4
.text$mn:00006CAC
.text$mn:00006CAC                 push    ebp
.text$mn:00006CAD                 mov     ebp, esp
.text$mn:00006CAF                 push    0FFFFFFFFh
.text$mn:00006CB1                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006CB6                 mov     eax, large fs:0
.text$mn:00006CBC                 push    eax
.text$mn:00006CBD                 push    ecx
.text$mn:00006CBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CC3                 xor     eax, ebp
.text$mn:00006CC5                 push    eax
.text$mn:00006CC6                 lea     eax, [ebp+var_C]
.text$mn:00006CC9                 mov     large fs:0, eax
.text$mn:00006CCF                 mov     [ebp+var_10], ecx
.text$mn:00006CD2                 mov     [ebp+var_4], 0
.text$mn:00006CD9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006CE0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006CE3                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006CE8                 mov     ecx, [ebp+var_C]
.text$mn:00006CEB                 mov     large fs:0, ecx
.text$mn:00006CF2                 pop     ecx
.text$mn:00006CF3                 mov     esp, ebp
.text$mn:00006CF5                 pop     ebp
.text$mn:00006CF6                 retn
.text$mn:00006CF6 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00006CF6
.text$mn:00006CF6 ; ---------------------------------------------------------------------------
.text$mn:00006CF7                 align 4
.text$mn:00006CF7 _text$mn        ends
.text$mn:00006CF7
.text$x:00006CF8 ; ===========================================================================
.text$x:00006CF8
.text$x:00006CF8 ; Segment type: Pure code
.text$x:00006CF8 ; Segment permissions: Read/Execute
.text$x:00006CF8 _text$x         segment para public 'CODE' use32
.text$x:00006CF8                 assume cs:_text$x
.text$x:00006CF8                 ;org 6CF8h
.text$x:00006CF8 ; COMDAT (pick associative to section at 6CAC)
.text$x:00006CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006CF8
.text$x:00006CF8 ; =============== S U B R O U T I N E =======================================
.text$x:00006CF8
.text$x:00006CF8
.text$x:00006CF8 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006CF8                                         ; DATA XREF: .xdata$x:0000E0B4o
.text$x:00006CF8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006CFB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006CFB __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006CFB
.text$x:00006D00
.text$x:00006D00 ; =============== S U B R O U T I N E =======================================
.text$x:00006D00
.text$x:00006D00
.text$x:00006D00 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00006D00                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(void)+5o
.text$x:00006D00
.text$x:00006D00 arg_4           = dword ptr  8
.text$x:00006D00
.text$x:00006D00                 mov     edx, [esp+arg_4]
.text$x:00006D04                 lea     eax, [edx+0Ch]
.text$x:00006D07                 mov     ecx, [edx-8]
.text$x:00006D0A                 xor     ecx, eax
.text$x:00006D0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D11                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00006D16                 jmp     ___CxxFrameHandler3
.text$x:00006D16 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00006D16
.text$x:00006D16 ; ---------------------------------------------------------------------------
.text$x:00006D1B                 align 4
.text$x:00006D1B _text$x         ends
.text$x:00006D1B
.text$mn:00006D1C ; ===========================================================================
.text$mn:00006D1C
.text$mn:00006D1C ; Segment type: Pure code
.text$mn:00006D1C ; Segment permissions: Read/Execute
.text$mn:00006D1C _text$mn        segment para public 'CODE' use32
.text$mn:00006D1C                 assume cs:_text$mn
.text$mn:00006D1C                 ;org 6D1Ch
.text$mn:00006D1C ; COMDAT (pick any)
.text$mn:00006D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D1C
.text$mn:00006D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00006D1C
.text$mn:00006D1C ; Attributes: bp-based frame
.text$mn:00006D1C
.text$mn:00006D1C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00006D1C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00006D1C ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006D1C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00006D1C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00006D1C
.text$mn:00006D1C var_10          = dword ptr -10h
.text$mn:00006D1C var_C           = dword ptr -0Ch
.text$mn:00006D1C var_4           = dword ptr -4
.text$mn:00006D1C
.text$mn:00006D1C                 push    ebp
.text$mn:00006D1D                 mov     ebp, esp
.text$mn:00006D1F                 push    0FFFFFFFFh
.text$mn:00006D21                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00006D26                 mov     eax, large fs:0
.text$mn:00006D2C                 push    eax
.text$mn:00006D2D                 push    ecx
.text$mn:00006D2E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006D33                 xor     eax, ebp
.text$mn:00006D35                 push    eax
.text$mn:00006D36                 lea     eax, [ebp+var_C]
.text$mn:00006D39                 mov     large fs:0, eax
.text$mn:00006D3F                 mov     [ebp+var_10], ecx
.text$mn:00006D42                 mov     [ebp+var_4], 0
.text$mn:00006D49                 mov     ecx, [ebp+var_10]
.text$mn:00006D4C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00006D51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006D58                 mov     ecx, [ebp+var_10]
.text$mn:00006D5B                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00006D60                 mov     ecx, [ebp+var_C]
.text$mn:00006D63                 mov     large fs:0, ecx
.text$mn:00006D6A                 pop     ecx
.text$mn:00006D6B                 mov     esp, ebp
.text$mn:00006D6D                 pop     ebp
.text$mn:00006D6E                 retn
.text$mn:00006D6E ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006D6E
.text$mn:00006D6E ; ---------------------------------------------------------------------------
.text$mn:00006D6F                 align 10h
.text$mn:00006D6F _text$mn        ends
.text$mn:00006D6F
.text$x:00006D70 ; ===========================================================================
.text$x:00006D70
.text$x:00006D70 ; Segment type: Pure code
.text$x:00006D70 ; Segment permissions: Read/Execute
.text$x:00006D70 _text$x         segment para public 'CODE' use32
.text$x:00006D70                 assume cs:_text$x
.text$x:00006D70                 ;org 6D70h
.text$x:00006D70 ; COMDAT (pick associative to section at 6D1C)
.text$x:00006D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006D70
.text$x:00006D70 ; =============== S U B R O U T I N E =======================================
.text$x:00006D70
.text$x:00006D70
.text$x:00006D70 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006D70                                         ; DATA XREF: .xdata$x:0000CE00o
.text$x:00006D70                 mov     ecx, [ebp-10h]
.text$x:00006D73                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00006D73 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006D73
.text$x:00006D78
.text$x:00006D78 ; =============== S U B R O U T I N E =======================================
.text$x:00006D78
.text$x:00006D78
.text$x:00006D78 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006D78                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00006D78
.text$x:00006D78 arg_4           = dword ptr  8
.text$x:00006D78
.text$x:00006D78                 mov     edx, [esp+arg_4]
.text$x:00006D7C                 lea     eax, [edx+0Ch]
.text$x:00006D7F                 mov     ecx, [edx-8]
.text$x:00006D82                 xor     ecx, eax
.text$x:00006D84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D89                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00006D8E                 jmp     ___CxxFrameHandler3
.text$x:00006D8E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00006D8E
.text$x:00006D8E ; ---------------------------------------------------------------------------
.text$x:00006D93                 align 4
.text$x:00006D93 _text$x         ends
.text$x:00006D93
.text$mn:00006D94 ; ===========================================================================
.text$mn:00006D94
.text$mn:00006D94 ; Segment type: Pure code
.text$mn:00006D94 ; Segment permissions: Read/Execute
.text$mn:00006D94 _text$mn        segment para public 'CODE' use32
.text$mn:00006D94                 assume cs:_text$mn
.text$mn:00006D94                 ;org 6D94h
.text$mn:00006D94 ; COMDAT (pick any)
.text$mn:00006D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D94
.text$mn:00006D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D94
.text$mn:00006D94 ; Attributes: bp-based frame
.text$mn:00006D94
.text$mn:00006D94 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00006D94                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006D94 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006D94                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006D94                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+43p ...
.text$mn:00006D94
.text$mn:00006D94 var_10          = dword ptr -10h
.text$mn:00006D94 var_C           = dword ptr -0Ch
.text$mn:00006D94 var_4           = dword ptr -4
.text$mn:00006D94
.text$mn:00006D94                 push    ebp
.text$mn:00006D95                 mov     ebp, esp
.text$mn:00006D97                 push    0FFFFFFFFh
.text$mn:00006D99                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006D9E                 mov     eax, large fs:0
.text$mn:00006DA4                 push    eax
.text$mn:00006DA5                 push    ecx
.text$mn:00006DA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006DAB                 xor     eax, ebp
.text$mn:00006DAD                 push    eax
.text$mn:00006DAE                 lea     eax, [ebp+var_C]
.text$mn:00006DB1                 mov     large fs:0, eax
.text$mn:00006DB7                 mov     [ebp+var_10], ecx
.text$mn:00006DBA                 mov     [ebp+var_4], 0
.text$mn:00006DC1                 mov     ecx, [ebp+var_10]
.text$mn:00006DC4                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00006DC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006DD0                 mov     ecx, [ebp+var_10]
.text$mn:00006DD3                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00006DD8                 mov     ecx, [ebp+var_C]
.text$mn:00006DDB                 mov     large fs:0, ecx
.text$mn:00006DE2                 pop     ecx
.text$mn:00006DE3                 mov     esp, ebp
.text$mn:00006DE5                 pop     ebp
.text$mn:00006DE6                 retn
.text$mn:00006DE6 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006DE6
.text$mn:00006DE6 ; ---------------------------------------------------------------------------
.text$mn:00006DE7                 align 4
.text$mn:00006DE7 _text$mn        ends
.text$mn:00006DE7
.text$x:00006DE8 ; ===========================================================================
.text$x:00006DE8
.text$x:00006DE8 ; Segment type: Pure code
.text$x:00006DE8 ; Segment permissions: Read/Execute
.text$x:00006DE8 _text$x         segment para public 'CODE' use32
.text$x:00006DE8                 assume cs:_text$x
.text$x:00006DE8                 ;org 6DE8h
.text$x:00006DE8 ; COMDAT (pick associative to section at 6D94)
.text$x:00006DE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006DE8
.text$x:00006DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00006DE8
.text$x:00006DE8
.text$x:00006DE8 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006DE8                                         ; DATA XREF: .xdata$x:0000D120o
.text$x:00006DE8                 mov     ecx, [ebp-10h]
.text$x:00006DEB                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00006DEB __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006DEB
.text$x:00006DF0
.text$x:00006DF0 ; =============== S U B R O U T I N E =======================================
.text$x:00006DF0
.text$x:00006DF0
.text$x:00006DF0 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006DF0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00006DF0
.text$x:00006DF0 arg_4           = dword ptr  8
.text$x:00006DF0
.text$x:00006DF0                 mov     edx, [esp+arg_4]
.text$x:00006DF4                 lea     eax, [edx+0Ch]
.text$x:00006DF7                 mov     ecx, [edx-8]
.text$x:00006DFA                 xor     ecx, eax
.text$x:00006DFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E01                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00006E06                 jmp     ___CxxFrameHandler3
.text$x:00006E06 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00006E06
.text$x:00006E06 ; ---------------------------------------------------------------------------
.text$x:00006E0B                 align 4
.text$x:00006E0B _text$x         ends
.text$x:00006E0B
.text$mn:00006E0C ; ===========================================================================
.text$mn:00006E0C
.text$mn:00006E0C ; Segment type: Pure code
.text$mn:00006E0C ; Segment permissions: Read/Execute
.text$mn:00006E0C _text$mn        segment para public 'CODE' use32
.text$mn:00006E0C                 assume cs:_text$mn
.text$mn:00006E0C                 ;org 6E0Ch
.text$mn:00006E0C ; COMDAT (pick any)
.text$mn:00006E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E0C
.text$mn:00006E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E0C
.text$mn:00006E0C ; Attributes: bp-based frame
.text$mn:00006E0C
.text$mn:00006E0C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00006E0C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006E0C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00006E0C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00006E0C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00006E0C
.text$mn:00006E0C var_10          = dword ptr -10h
.text$mn:00006E0C var_C           = dword ptr -0Ch
.text$mn:00006E0C var_4           = dword ptr -4
.text$mn:00006E0C
.text$mn:00006E0C                 push    ebp
.text$mn:00006E0D                 mov     ebp, esp
.text$mn:00006E0F                 push    0FFFFFFFFh
.text$mn:00006E11                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006E16                 mov     eax, large fs:0
.text$mn:00006E1C                 push    eax
.text$mn:00006E1D                 push    ecx
.text$mn:00006E1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E23                 xor     eax, ebp
.text$mn:00006E25                 push    eax
.text$mn:00006E26                 lea     eax, [ebp+var_C]
.text$mn:00006E29                 mov     large fs:0, eax
.text$mn:00006E2F                 mov     [ebp+var_10], ecx
.text$mn:00006E32                 mov     [ebp+var_4], 0
.text$mn:00006E39                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006E40                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006E43                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006E48                 mov     ecx, [ebp+var_C]
.text$mn:00006E4B                 mov     large fs:0, ecx
.text$mn:00006E52                 pop     ecx
.text$mn:00006E53                 mov     esp, ebp
.text$mn:00006E55                 pop     ebp
.text$mn:00006E56                 retn
.text$mn:00006E56 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00006E56
.text$mn:00006E56 ; ---------------------------------------------------------------------------
.text$mn:00006E57                 align 4
.text$mn:00006E57 _text$mn        ends
.text$mn:00006E57
.text$x:00006E58 ; ===========================================================================
.text$x:00006E58
.text$x:00006E58 ; Segment type: Pure code
.text$x:00006E58 ; Segment permissions: Read/Execute
.text$x:00006E58 _text$x         segment para public 'CODE' use32
.text$x:00006E58                 assume cs:_text$x
.text$x:00006E58                 ;org 6E58h
.text$x:00006E58 ; COMDAT (pick associative to section at 6E0C)
.text$x:00006E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006E58
.text$x:00006E58 ; =============== S U B R O U T I N E =======================================
.text$x:00006E58
.text$x:00006E58
.text$x:00006E58 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00006E58                                         ; DATA XREF: .xdata$x:0000CDA8o
.text$x:00006E58                 mov     ecx, [ebp-10h]  ; this
.text$x:00006E5B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006E5B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00006E5B
.text$x:00006E60
.text$x:00006E60 ; =============== S U B R O U T I N E =======================================
.text$x:00006E60
.text$x:00006E60
.text$x:00006E60 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00006E60                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00006E60
.text$x:00006E60 arg_4           = dword ptr  8
.text$x:00006E60
.text$x:00006E60                 mov     edx, [esp+arg_4]
.text$x:00006E64                 lea     eax, [edx+0Ch]
.text$x:00006E67                 mov     ecx, [edx-8]
.text$x:00006E6A                 xor     ecx, eax
.text$x:00006E6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E71                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00006E76                 jmp     ___CxxFrameHandler3
.text$x:00006E76 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00006E76
.text$x:00006E76 ; ---------------------------------------------------------------------------
.text$x:00006E7B                 align 4
.text$x:00006E7B _text$x         ends
.text$x:00006E7B
.text$mn:00006E7C ; ===========================================================================
.text$mn:00006E7C
.text$mn:00006E7C ; Segment type: Pure code
.text$mn:00006E7C ; Segment permissions: Read/Execute
.text$mn:00006E7C _text$mn        segment para public 'CODE' use32
.text$mn:00006E7C                 assume cs:_text$mn
.text$mn:00006E7C                 ;org 6E7Ch
.text$mn:00006E7C ; COMDAT (pick any)
.text$mn:00006E7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E7C
.text$mn:00006E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E7C
.text$mn:00006E7C ; Attributes: bp-based frame
.text$mn:00006E7C
.text$mn:00006E7C ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00006E7C                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006E7C ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006E7C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00006E7C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00006E7C
.text$mn:00006E7C var_10          = dword ptr -10h
.text$mn:00006E7C var_C           = dword ptr -0Ch
.text$mn:00006E7C var_4           = dword ptr -4
.text$mn:00006E7C
.text$mn:00006E7C                 push    ebp
.text$mn:00006E7D                 mov     ebp, esp
.text$mn:00006E7F                 push    0FFFFFFFFh
.text$mn:00006E81                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006E86                 mov     eax, large fs:0
.text$mn:00006E8C                 push    eax
.text$mn:00006E8D                 push    ecx
.text$mn:00006E8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E93                 xor     eax, ebp
.text$mn:00006E95                 push    eax
.text$mn:00006E96                 lea     eax, [ebp+var_C]
.text$mn:00006E99                 mov     large fs:0, eax
.text$mn:00006E9F                 mov     [ebp+var_10], ecx
.text$mn:00006EA2                 mov     [ebp+var_4], 0
.text$mn:00006EA9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006EB0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006EB3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006EB8                 mov     ecx, [ebp+var_C]
.text$mn:00006EBB                 mov     large fs:0, ecx
.text$mn:00006EC2                 pop     ecx
.text$mn:00006EC3                 mov     esp, ebp
.text$mn:00006EC5                 pop     ebp
.text$mn:00006EC6                 retn
.text$mn:00006EC6 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00006EC6
.text$mn:00006EC6 ; ---------------------------------------------------------------------------
.text$mn:00006EC7                 align 4
.text$mn:00006EC7 _text$mn        ends
.text$mn:00006EC7
.text$x:00006EC8 ; ===========================================================================
.text$x:00006EC8
.text$x:00006EC8 ; Segment type: Pure code
.text$x:00006EC8 ; Segment permissions: Read/Execute
.text$x:00006EC8 _text$x         segment para public 'CODE' use32
.text$x:00006EC8                 assume cs:_text$x
.text$x:00006EC8                 ;org 6EC8h
.text$x:00006EC8 ; COMDAT (pick associative to section at 6E7C)
.text$x:00006EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006EC8
.text$x:00006EC8 ; =============== S U B R O U T I N E =======================================
.text$x:00006EC8
.text$x:00006EC8
.text$x:00006EC8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00006EC8                                         ; DATA XREF: .xdata$x:0000D0C8o
.text$x:00006EC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006ECB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006ECB __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00006ECB
.text$x:00006ED0
.text$x:00006ED0 ; =============== S U B R O U T I N E =======================================
.text$x:00006ED0
.text$x:00006ED0
.text$x:00006ED0 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00006ED0                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00006ED0
.text$x:00006ED0 arg_4           = dword ptr  8
.text$x:00006ED0
.text$x:00006ED0                 mov     edx, [esp+arg_4]
.text$x:00006ED4                 lea     eax, [edx+0Ch]
.text$x:00006ED7                 mov     ecx, [edx-8]
.text$x:00006EDA                 xor     ecx, eax
.text$x:00006EDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006EE1                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00006EE6                 jmp     ___CxxFrameHandler3
.text$x:00006EE6 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00006EE6
.text$x:00006EE6 ; ---------------------------------------------------------------------------
.text$x:00006EEB                 align 4
.text$x:00006EEB _text$x         ends
.text$x:00006EEB
.text$mn:00006EEC ; ===========================================================================
.text$mn:00006EEC
.text$mn:00006EEC ; Segment type: Pure code
.text$mn:00006EEC ; Segment permissions: Read/Execute
.text$mn:00006EEC _text$mn        segment para public 'CODE' use32
.text$mn:00006EEC                 assume cs:_text$mn
.text$mn:00006EEC                 ;org 6EECh
.text$mn:00006EEC ; COMDAT (pick any)
.text$mn:00006EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006EEC
.text$mn:00006EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00006EEC
.text$mn:00006EEC ; Attributes: bp-based frame
.text$mn:00006EEC
.text$mn:00006EEC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>(void)
.text$mn:00006EEC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006EEC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006EEC                                         ; CODE XREF: __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$2+3j
.text$mn:00006EEC                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::~vector<KeyCombo,std::allocator<KeyCombo>>(void)+3Fp ...
.text$mn:00006EEC
.text$mn:00006EEC var_10          = dword ptr -10h
.text$mn:00006EEC var_C           = dword ptr -0Ch
.text$mn:00006EEC var_4           = dword ptr -4
.text$mn:00006EEC
.text$mn:00006EEC                 push    ebp
.text$mn:00006EED                 mov     ebp, esp
.text$mn:00006EEF                 push    0FFFFFFFFh
.text$mn:00006EF1                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006EF6                 mov     eax, large fs:0
.text$mn:00006EFC                 push    eax
.text$mn:00006EFD                 push    ecx
.text$mn:00006EFE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F03                 xor     eax, ebp
.text$mn:00006F05                 push    eax
.text$mn:00006F06                 lea     eax, [ebp+var_C]
.text$mn:00006F09                 mov     large fs:0, eax
.text$mn:00006F0F                 mov     [ebp+var_10], ecx
.text$mn:00006F12                 mov     [ebp+var_4], 0
.text$mn:00006F19                 mov     ecx, [ebp+var_10]
.text$mn:00006F1C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Free_proxy(void)
.text$mn:00006F21                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006F28                 mov     ecx, [ebp+var_10]
.text$mn:00006F2B                 call    ??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<KeyCombo>>::~_Vector_val<std::_Simple_types<KeyCombo>>(void)
.text$mn:00006F30                 mov     ecx, [ebp+var_C]
.text$mn:00006F33                 mov     large fs:0, ecx
.text$mn:00006F3A                 pop     ecx
.text$mn:00006F3B                 mov     esp, ebp
.text$mn:00006F3D                 pop     ebp
.text$mn:00006F3E                 retn
.text$mn:00006F3E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006F3E
.text$mn:00006F3E ; ---------------------------------------------------------------------------
.text$mn:00006F3F                 align 10h
.text$mn:00006F3F _text$mn        ends
.text$mn:00006F3F
.text$x:00006F40 ; ===========================================================================
.text$x:00006F40
.text$x:00006F40 ; Segment type: Pure code
.text$x:00006F40 ; Segment permissions: Read/Execute
.text$x:00006F40 _text$x         segment para public 'CODE' use32
.text$x:00006F40                 assume cs:_text$x
.text$x:00006F40                 ;org 6F40h
.text$x:00006F40 ; COMDAT (pick associative to section at 6EEC)
.text$x:00006F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006F40
.text$x:00006F40 ; =============== S U B R O U T I N E =======================================
.text$x:00006F40
.text$x:00006F40
.text$x:00006F40 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006F40                                         ; DATA XREF: .xdata$x:0000D364o
.text$x:00006F40                 mov     ecx, [ebp-10h]
.text$x:00006F43                 jmp     ??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<KeyCombo>>::~_Vector_val<std::_Simple_types<KeyCombo>>(void)
.text$x:00006F43 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006F43
.text$x:00006F48
.text$x:00006F48 ; =============== S U B R O U T I N E =======================================
.text$x:00006F48
.text$x:00006F48
.text$x:00006F48 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006F48                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::~_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(void)+5o
.text$x:00006F48
.text$x:00006F48 arg_4           = dword ptr  8
.text$x:00006F48
.text$x:00006F48                 mov     edx, [esp+arg_4]
.text$x:00006F4C                 lea     eax, [edx+0Ch]
.text$x:00006F4F                 mov     ecx, [edx-8]
.text$x:00006F52                 xor     ecx, eax
.text$x:00006F54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F59                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.text$x:00006F5E                 jmp     ___CxxFrameHandler3
.text$x:00006F5E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00006F5E
.text$x:00006F5E ; ---------------------------------------------------------------------------
.text$x:00006F63                 align 4
.text$x:00006F63 _text$x         ends
.text$x:00006F63
.text$mn:00006F64 ; ===========================================================================
.text$mn:00006F64
.text$mn:00006F64 ; Segment type: Pure code
.text$mn:00006F64 ; Segment permissions: Read/Execute
.text$mn:00006F64 _text$mn        segment para public 'CODE' use32
.text$mn:00006F64                 assume cs:_text$mn
.text$mn:00006F64                 ;org 6F64h
.text$mn:00006F64 ; COMDAT (pick any)
.text$mn:00006F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F64
.text$mn:00006F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F64
.text$mn:00006F64 ; Attributes: bp-based frame
.text$mn:00006F64
.text$mn:00006F64 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>(void)
.text$mn:00006F64                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006F64 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006F64                                         ; CODE XREF: __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00006F64                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+3Fp ...
.text$mn:00006F64
.text$mn:00006F64 var_10          = dword ptr -10h
.text$mn:00006F64 var_C           = dword ptr -0Ch
.text$mn:00006F64 var_4           = dword ptr -4
.text$mn:00006F64
.text$mn:00006F64                 push    ebp
.text$mn:00006F65                 mov     ebp, esp
.text$mn:00006F67                 push    0FFFFFFFFh
.text$mn:00006F69                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006F6E                 mov     eax, large fs:0
.text$mn:00006F74                 push    eax
.text$mn:00006F75                 push    ecx
.text$mn:00006F76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F7B                 xor     eax, ebp
.text$mn:00006F7D                 push    eax
.text$mn:00006F7E                 lea     eax, [ebp+var_C]
.text$mn:00006F81                 mov     large fs:0, eax
.text$mn:00006F87                 mov     [ebp+var_10], ecx
.text$mn:00006F8A                 mov     [ebp+var_4], 0
.text$mn:00006F91                 mov     ecx, [ebp+var_10]
.text$mn:00006F94                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Free_proxy(void)
.text$mn:00006F99                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006FA0                 mov     ecx, [ebp+var_10]
.text$mn:00006FA3                 call    ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$mn:00006FA8                 mov     ecx, [ebp+var_C]
.text$mn:00006FAB                 mov     large fs:0, ecx
.text$mn:00006FB2                 pop     ecx
.text$mn:00006FB3                 mov     esp, ebp
.text$mn:00006FB5                 pop     ebp
.text$mn:00006FB6                 retn
.text$mn:00006FB6 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006FB6
.text$mn:00006FB6 ; ---------------------------------------------------------------------------
.text$mn:00006FB7                 align 4
.text$mn:00006FB7 _text$mn        ends
.text$mn:00006FB7
.text$x:00006FB8 ; ===========================================================================
.text$x:00006FB8
.text$x:00006FB8 ; Segment type: Pure code
.text$x:00006FB8 ; Segment permissions: Read/Execute
.text$x:00006FB8 _text$x         segment para public 'CODE' use32
.text$x:00006FB8                 assume cs:_text$x
.text$x:00006FB8                 ;org 6FB8h
.text$x:00006FB8 ; COMDAT (pick associative to section at 6F64)
.text$x:00006FB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006FB8
.text$x:00006FB8 ; =============== S U B R O U T I N E =======================================
.text$x:00006FB8
.text$x:00006FB8
.text$x:00006FB8 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006FB8                                         ; DATA XREF: .xdata$x:0000DDC0o
.text$x:00006FB8                 mov     ecx, [ebp-10h]
.text$x:00006FBB                 jmp     ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$x:00006FBB __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006FBB
.text$x:00006FC0
.text$x:00006FC0 ; =============== S U B R O U T I N E =======================================
.text$x:00006FC0
.text$x:00006FC0
.text$x:00006FC0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006FC0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)+5o
.text$x:00006FC0
.text$x:00006FC0 arg_4           = dword ptr  8
.text$x:00006FC0
.text$x:00006FC0                 mov     edx, [esp+arg_4]
.text$x:00006FC4                 lea     eax, [edx+0Ch]
.text$x:00006FC7                 mov     ecx, [edx-8]
.text$x:00006FCA                 xor     ecx, eax
.text$x:00006FCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FD1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.text$x:00006FD6                 jmp     ___CxxFrameHandler3
.text$x:00006FD6 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00006FD6
.text$x:00006FD6 ; ---------------------------------------------------------------------------
.text$x:00006FDB                 align 4
.text$x:00006FDB _text$x         ends
.text$x:00006FDB
.text$mn:00006FDC ; ===========================================================================
.text$mn:00006FDC
.text$mn:00006FDC ; Segment type: Pure code
.text$mn:00006FDC ; Segment permissions: Read/Execute
.text$mn:00006FDC _text$mn        segment para public 'CODE' use32
.text$mn:00006FDC                 assume cs:_text$mn
.text$mn:00006FDC                 ;org 6FDCh
.text$mn:00006FDC ; COMDAT (pick any)
.text$mn:00006FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FDC
.text$mn:00006FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FDC
.text$mn:00006FDC ; Attributes: bp-based frame
.text$mn:00006FDC
.text$mn:00006FDC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>(void)
.text$mn:00006FDC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006FDC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006FDC                                         ; CODE XREF: __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$2+3j
.text$mn:00006FDC                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::~vector<recordedMacroStep,std::allocator<recordedMacroStep>>(void)+3Fp ...
.text$mn:00006FDC
.text$mn:00006FDC var_10          = dword ptr -10h
.text$mn:00006FDC var_C           = dword ptr -0Ch
.text$mn:00006FDC var_4           = dword ptr -4
.text$mn:00006FDC
.text$mn:00006FDC                 push    ebp
.text$mn:00006FDD                 mov     ebp, esp
.text$mn:00006FDF                 push    0FFFFFFFFh
.text$mn:00006FE1                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006FE6                 mov     eax, large fs:0
.text$mn:00006FEC                 push    eax
.text$mn:00006FED                 push    ecx
.text$mn:00006FEE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006FF3                 xor     eax, ebp
.text$mn:00006FF5                 push    eax
.text$mn:00006FF6                 lea     eax, [ebp+var_C]
.text$mn:00006FF9                 mov     large fs:0, eax
.text$mn:00006FFF                 mov     [ebp+var_10], ecx
.text$mn:00007002                 mov     [ebp+var_4], 0
.text$mn:00007009                 mov     ecx, [ebp+var_10]
.text$mn:0000700C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Free_proxy(void)
.text$mn:00007011                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007018                 mov     ecx, [ebp+var_10]
.text$mn:0000701B                 call    ??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<recordedMacroStep>>::~_Vector_val<std::_Simple_types<recordedMacroStep>>(void)
.text$mn:00007020                 mov     ecx, [ebp+var_C]
.text$mn:00007023                 mov     large fs:0, ecx
.text$mn:0000702A                 pop     ecx
.text$mn:0000702B                 mov     esp, ebp
.text$mn:0000702D                 pop     ebp
.text$mn:0000702E                 retn
.text$mn:0000702E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000702E
.text$mn:0000702E ; ---------------------------------------------------------------------------
.text$mn:0000702F                 align 10h
.text$mn:0000702F _text$mn        ends
.text$mn:0000702F
.text$x:00007030 ; ===========================================================================
.text$x:00007030
.text$x:00007030 ; Segment type: Pure code
.text$x:00007030 ; Segment permissions: Read/Execute
.text$x:00007030 _text$x         segment para public 'CODE' use32
.text$x:00007030                 assume cs:_text$x
.text$x:00007030                 ;org 7030h
.text$x:00007030 ; COMDAT (pick associative to section at 6FDC)
.text$x:00007030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007030
.text$x:00007030 ; =============== S U B R O U T I N E =======================================
.text$x:00007030
.text$x:00007030
.text$x:00007030 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007030                                         ; DATA XREF: .xdata$x:0000D754o
.text$x:00007030                 mov     ecx, [ebp-10h]
.text$x:00007033                 jmp     ??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<recordedMacroStep>>::~_Vector_val<std::_Simple_types<recordedMacroStep>>(void)
.text$x:00007033 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007033
.text$x:00007038
.text$x:00007038 ; =============== S U B R O U T I N E =======================================
.text$x:00007038
.text$x:00007038
.text$x:00007038 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007038                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::~_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(void)+5o
.text$x:00007038
.text$x:00007038 arg_4           = dword ptr  8
.text$x:00007038
.text$x:00007038                 mov     edx, [esp+arg_4]
.text$x:0000703C                 lea     eax, [edx+0Ch]
.text$x:0000703F                 mov     ecx, [edx-8]
.text$x:00007042                 xor     ecx, eax
.text$x:00007044                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007049                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.text$x:0000704E                 jmp     ___CxxFrameHandler3
.text$x:0000704E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000704E
.text$x:0000704E ; ---------------------------------------------------------------------------
.text$x:00007053                 align 4
.text$x:00007053 _text$x         ends
.text$x:00007053
.text$mn:00007054 ; ===========================================================================
.text$mn:00007054
.text$mn:00007054 ; Segment type: Pure code
.text$mn:00007054 ; Segment permissions: Read/Execute
.text$mn:00007054 _text$mn        segment para public 'CODE' use32
.text$mn:00007054                 assume cs:_text$mn
.text$mn:00007054                 ;org 7054h
.text$mn:00007054 ; COMDAT (pick any)
.text$mn:00007054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007054
.text$mn:00007054 ; =============== S U B R O U T I N E =======================================
.text$mn:00007054
.text$mn:00007054 ; Attributes: bp-based frame
.text$mn:00007054
.text$mn:00007054 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>(void)
.text$mn:00007054                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.text$mn:00007054 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007054                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)+9Bp
.text$mn:00007054                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)+AAp ...
.text$mn:00007054
.text$mn:00007054 var_10          = dword ptr -10h
.text$mn:00007054 var_C           = dword ptr -0Ch
.text$mn:00007054 var_4           = dword ptr -4
.text$mn:00007054
.text$mn:00007054                 push    ebp
.text$mn:00007055                 mov     ebp, esp
.text$mn:00007057                 push    0FFFFFFFFh
.text$mn:00007059                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000705E                 mov     eax, large fs:0
.text$mn:00007064                 push    eax
.text$mn:00007065                 push    ecx
.text$mn:00007066                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000706B                 xor     eax, ebp
.text$mn:0000706D                 push    eax
.text$mn:0000706E                 lea     eax, [ebp+var_C]
.text$mn:00007071                 mov     large fs:0, eax
.text$mn:00007077                 mov     [ebp+var_10], ecx
.text$mn:0000707A                 mov     [ebp+var_4], 0
.text$mn:00007081                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007088                 mov     ecx, [ebp+var_10]
.text$mn:0000708B                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)
.text$mn:00007090                 mov     ecx, [ebp+var_C]
.text$mn:00007093                 mov     large fs:0, ecx
.text$mn:0000709A                 pop     ecx
.text$mn:0000709B                 mov     esp, ebp
.text$mn:0000709D                 pop     ebp
.text$mn:0000709E                 retn
.text$mn:0000709E ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000709E
.text$mn:0000709E ; ---------------------------------------------------------------------------
.text$mn:0000709F                 align 10h
.text$mn:0000709F _text$mn        ends
.text$mn:0000709F
.text$x:000070A0 ; ===========================================================================
.text$x:000070A0
.text$x:000070A0 ; Segment type: Pure code
.text$x:000070A0 ; Segment permissions: Read/Execute
.text$x:000070A0 _text$x         segment para public 'CODE' use32
.text$x:000070A0                 assume cs:_text$x
.text$x:000070A0                 ;org 70A0h
.text$x:000070A0 ; COMDAT (pick associative to section at 7054)
.text$x:000070A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000070A0
.text$x:000070A0 ; =============== S U B R O U T I N E =======================================
.text$x:000070A0
.text$x:000070A0
.text$x:000070A0 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000070A0                                         ; DATA XREF: .xdata$x:0000D5F4o
.text$x:000070A0                 mov     ecx, [ebp-10h]
.text$x:000070A3                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,KeyCombo,int,KeyCombo const *,KeyCombo const &,std::_Iterator_base12>(void)
.text$x:000070A3 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000070A3
.text$x:000070A8
.text$x:000070A8 ; =============== S U B R O U T I N E =======================================
.text$x:000070A8
.text$x:000070A8
.text$x:000070A8 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000070A8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)+5o
.text$x:000070A8
.text$x:000070A8 arg_4           = dword ptr  8
.text$x:000070A8
.text$x:000070A8                 mov     edx, [esp+arg_4]
.text$x:000070AC                 lea     eax, [edx+0Ch]
.text$x:000070AF                 mov     ecx, [edx-8]
.text$x:000070B2                 xor     ecx, eax
.text$x:000070B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000070B9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.text$x:000070BE                 jmp     ___CxxFrameHandler3
.text$x:000070BE __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000070BE
.text$x:000070BE ; ---------------------------------------------------------------------------
.text$x:000070C3                 align 4
.text$x:000070C3 _text$x         ends
.text$x:000070C3
.text$mn:000070C4 ; ===========================================================================
.text$mn:000070C4
.text$mn:000070C4 ; Segment type: Pure code
.text$mn:000070C4 ; Segment permissions: Read/Execute
.text$mn:000070C4 _text$mn        segment para public 'CODE' use32
.text$mn:000070C4                 assume cs:_text$mn
.text$mn:000070C4                 ;org 70C4h
.text$mn:000070C4 ; COMDAT (pick any)
.text$mn:000070C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070C4
.text$mn:000070C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000070C4
.text$mn:000070C4 ; Attributes: bp-based frame
.text$mn:000070C4
.text$mn:000070C4 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>(void)
.text$mn:000070C4                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.text$mn:000070C4 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000070C4                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)+9Bp
.text$mn:000070C4                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)+AAp ...
.text$mn:000070C4
.text$mn:000070C4 var_10          = dword ptr -10h
.text$mn:000070C4 var_C           = dword ptr -0Ch
.text$mn:000070C4 var_4           = dword ptr -4
.text$mn:000070C4
.text$mn:000070C4                 push    ebp
.text$mn:000070C5                 mov     ebp, esp
.text$mn:000070C7                 push    0FFFFFFFFh
.text$mn:000070C9                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.text$mn:000070CE                 mov     eax, large fs:0
.text$mn:000070D4                 push    eax
.text$mn:000070D5                 push    ecx
.text$mn:000070D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000070DB                 xor     eax, ebp
.text$mn:000070DD                 push    eax
.text$mn:000070DE                 lea     eax, [ebp+var_C]
.text$mn:000070E1                 mov     large fs:0, eax
.text$mn:000070E7                 mov     [ebp+var_10], ecx
.text$mn:000070EA                 mov     [ebp+var_4], 0
.text$mn:000070F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000070F8                 mov     ecx, [ebp+var_10]
.text$mn:000070FB                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)
.text$mn:00007100                 mov     ecx, [ebp+var_C]
.text$mn:00007103                 mov     large fs:0, ecx
.text$mn:0000710A                 pop     ecx
.text$mn:0000710B                 mov     esp, ebp
.text$mn:0000710D                 pop     ebp
.text$mn:0000710E                 retn
.text$mn:0000710E ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000710E
.text$mn:0000710E ; ---------------------------------------------------------------------------
.text$mn:0000710F                 align 10h
.text$mn:0000710F _text$mn        ends
.text$mn:0000710F
.text$x:00007110 ; ===========================================================================
.text$x:00007110
.text$x:00007110 ; Segment type: Pure code
.text$x:00007110 ; Segment permissions: Read/Execute
.text$x:00007110 _text$x         segment para public 'CODE' use32
.text$x:00007110                 assume cs:_text$x
.text$x:00007110                 ;org 7110h
.text$x:00007110 ; COMDAT (pick associative to section at 70C4)
.text$x:00007110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007110
.text$x:00007110 ; =============== S U B R O U T I N E =======================================
.text$x:00007110
.text$x:00007110
.text$x:00007110 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007110                                         ; DATA XREF: .xdata$x:0000E33Co
.text$x:00007110                 mov     ecx, [ebp-10h]
.text$x:00007113                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,recordedMacroStep,int,recordedMacroStep const *,recordedMacroStep const &,std::_Iterator_base12>(void)
.text$x:00007113 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007113
.text$x:00007118
.text$x:00007118 ; =============== S U B R O U T I N E =======================================
.text$x:00007118
.text$x:00007118
.text$x:00007118 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007118                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)+5o
.text$x:00007118
.text$x:00007118 arg_4           = dword ptr  8
.text$x:00007118
.text$x:00007118                 mov     edx, [esp+arg_4]
.text$x:0000711C                 lea     eax, [edx+0Ch]
.text$x:0000711F                 mov     ecx, [edx-8]
.text$x:00007122                 xor     ecx, eax
.text$x:00007124                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007129                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.text$x:0000712E                 jmp     ___CxxFrameHandler3
.text$x:0000712E __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000712E
.text$x:0000712E ; ---------------------------------------------------------------------------
.text$x:00007133                 align 4
.text$x:00007133 _text$x         ends
.text$x:00007133
.text$mn:00007134 ; ===========================================================================
.text$mn:00007134
.text$mn:00007134 ; Segment type: Pure code
.text$mn:00007134 ; Segment permissions: Read/Execute
.text$mn:00007134 _text$mn        segment para public 'CODE' use32
.text$mn:00007134                 assume cs:_text$mn
.text$mn:00007134                 ;org 7134h
.text$mn:00007134 ; COMDAT (pick any)
.text$mn:00007134                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007134
.text$mn:00007134 ; =============== S U B R O U T I N E =======================================
.text$mn:00007134
.text$mn:00007134 ; Attributes: bp-based frame
.text$mn:00007134
.text$mn:00007134 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>(void)
.text$mn:00007134                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.text$mn:00007134 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007134                                         ; CODE XREF: __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$17+6j
.text$mn:00007134                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:00007134
.text$mn:00007134 var_10          = dword ptr -10h
.text$mn:00007134 var_C           = dword ptr -0Ch
.text$mn:00007134 var_4           = dword ptr -4
.text$mn:00007134
.text$mn:00007134                 push    ebp
.text$mn:00007135                 mov     ebp, esp
.text$mn:00007137                 push    0FFFFFFFFh
.text$mn:00007139                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000713E                 mov     eax, large fs:0
.text$mn:00007144                 push    eax
.text$mn:00007145                 push    ecx
.text$mn:00007146                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000714B                 xor     eax, ebp
.text$mn:0000714D                 push    eax
.text$mn:0000714E                 lea     eax, [ebp+var_C]
.text$mn:00007151                 mov     large fs:0, eax
.text$mn:00007157                 mov     [ebp+var_10], ecx
.text$mn:0000715A                 mov     [ebp+var_4], 0
.text$mn:00007161                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007168                 mov     ecx, [ebp+var_10]
.text$mn:0000716B                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(void)
.text$mn:00007170                 mov     ecx, [ebp+var_C]
.text$mn:00007173                 mov     large fs:0, ecx
.text$mn:0000717A                 pop     ecx
.text$mn:0000717B                 mov     esp, ebp
.text$mn:0000717D                 pop     ebp
.text$mn:0000717E                 retn
.text$mn:0000717E ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000717E
.text$mn:0000717E ; ---------------------------------------------------------------------------
.text$mn:0000717F                 align 10h
.text$mn:0000717F _text$mn        ends
.text$mn:0000717F
.text$x:00007180 ; ===========================================================================
.text$x:00007180
.text$x:00007180 ; Segment type: Pure code
.text$x:00007180 ; Segment permissions: Read/Execute
.text$x:00007180 _text$x         segment para public 'CODE' use32
.text$x:00007180                 assume cs:_text$x
.text$x:00007180                 ;org 7180h
.text$x:00007180 ; COMDAT (pick associative to section at 7134)
.text$x:00007180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007180
.text$x:00007180 ; =============== S U B R O U T I N E =======================================
.text$x:00007180
.text$x:00007180
.text$x:00007180 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007180                                         ; DATA XREF: .xdata$x:0000DF78o
.text$x:00007180                 mov     ecx, [ebp-10h]
.text$x:00007183                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MacroShortcut,int,MacroShortcut const *,MacroShortcut const &,std::_Iterator_base12>(void)
.text$x:00007183 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007183
.text$x:00007188
.text$x:00007188 ; =============== S U B R O U T I N E =======================================
.text$x:00007188
.text$x:00007188
.text$x:00007188 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007188                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)+5o
.text$x:00007188
.text$x:00007188 arg_4           = dword ptr  8
.text$x:00007188
.text$x:00007188                 mov     edx, [esp+arg_4]
.text$x:0000718C                 lea     eax, [edx+0Ch]
.text$x:0000718F                 mov     ecx, [edx-8]
.text$x:00007192                 xor     ecx, eax
.text$x:00007194                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007199                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.text$x:0000719E                 jmp     ___CxxFrameHandler3
.text$x:0000719E __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000719E
.text$x:0000719E ; ---------------------------------------------------------------------------
.text$x:000071A3                 align 4
.text$x:000071A3 _text$x         ends
.text$x:000071A3
.text$mn:000071A4 ; ===========================================================================
.text$mn:000071A4
.text$mn:000071A4 ; Segment type: Pure code
.text$mn:000071A4 ; Segment permissions: Read/Execute
.text$mn:000071A4 _text$mn        segment para public 'CODE' use32
.text$mn:000071A4                 assume cs:_text$mn
.text$mn:000071A4                 ;org 71A4h
.text$mn:000071A4 ; COMDAT (pick any)
.text$mn:000071A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000071A4
.text$mn:000071A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000071A4
.text$mn:000071A4 ; Attributes: bp-based frame
.text$mn:000071A4
.text$mn:000071A4 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>(void)
.text$mn:000071A4                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.text$mn:000071A4 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000071A4                                         ; CODE XREF: __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$22+6j
.text$mn:000071A4                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:000071A4
.text$mn:000071A4 var_10          = dword ptr -10h
.text$mn:000071A4 var_C           = dword ptr -0Ch
.text$mn:000071A4 var_4           = dword ptr -4
.text$mn:000071A4
.text$mn:000071A4                 push    ebp
.text$mn:000071A5                 mov     ebp, esp
.text$mn:000071A7                 push    0FFFFFFFFh
.text$mn:000071A9                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.text$mn:000071AE                 mov     eax, large fs:0
.text$mn:000071B4                 push    eax
.text$mn:000071B5                 push    ecx
.text$mn:000071B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000071BB                 xor     eax, ebp
.text$mn:000071BD                 push    eax
.text$mn:000071BE                 lea     eax, [ebp+var_C]
.text$mn:000071C1                 mov     large fs:0, eax
.text$mn:000071C7                 mov     [ebp+var_10], ecx
.text$mn:000071CA                 mov     [ebp+var_4], 0
.text$mn:000071D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000071D8                 mov     ecx, [ebp+var_10]
.text$mn:000071DB                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(void)
.text$mn:000071E0                 mov     ecx, [ebp+var_C]
.text$mn:000071E3                 mov     large fs:0, ecx
.text$mn:000071EA                 pop     ecx
.text$mn:000071EB                 mov     esp, ebp
.text$mn:000071ED                 pop     ebp
.text$mn:000071EE                 retn
.text$mn:000071EE ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000071EE
.text$mn:000071EE ; ---------------------------------------------------------------------------
.text$mn:000071EF                 align 10h
.text$mn:000071EF _text$mn        ends
.text$mn:000071EF
.text$x:000071F0 ; ===========================================================================
.text$x:000071F0
.text$x:000071F0 ; Segment type: Pure code
.text$x:000071F0 ; Segment permissions: Read/Execute
.text$x:000071F0 _text$x         segment para public 'CODE' use32
.text$x:000071F0                 assume cs:_text$x
.text$x:000071F0                 ;org 71F0h
.text$x:000071F0 ; COMDAT (pick associative to section at 71A4)
.text$x:000071F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000071F0
.text$x:000071F0 ; =============== S U B R O U T I N E =======================================
.text$x:000071F0
.text$x:000071F0
.text$x:000071F0 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000071F0                                         ; DATA XREF: .xdata$x:0000E138o
.text$x:000071F0                 mov     ecx, [ebp-10h]
.text$x:000071F3                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,UserCommand,int,UserCommand const *,UserCommand const &,std::_Iterator_base12>(void)
.text$x:000071F3 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000071F3
.text$x:000071F8
.text$x:000071F8 ; =============== S U B R O U T I N E =======================================
.text$x:000071F8
.text$x:000071F8
.text$x:000071F8 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000071F8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)+5o
.text$x:000071F8
.text$x:000071F8 arg_4           = dword ptr  8
.text$x:000071F8
.text$x:000071F8                 mov     edx, [esp+arg_4]
.text$x:000071FC                 lea     eax, [edx+0Ch]
.text$x:000071FF                 mov     ecx, [edx-8]
.text$x:00007202                 xor     ecx, eax
.text$x:00007204                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007209                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.text$x:0000720E                 jmp     ___CxxFrameHandler3
.text$x:0000720E __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000720E
.text$x:0000720E ; ---------------------------------------------------------------------------
.text$x:00007213                 align 4
.text$x:00007213 _text$x         ends
.text$x:00007213
.text$mn:00007214 ; ===========================================================================
.text$mn:00007214
.text$mn:00007214 ; Segment type: Pure code
.text$mn:00007214 ; Segment permissions: Read/Execute
.text$mn:00007214 _text$mn        segment para public 'CODE' use32
.text$mn:00007214                 assume cs:_text$mn
.text$mn:00007214                 ;org 7214h
.text$mn:00007214 ; COMDAT (pick any)
.text$mn:00007214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007214
.text$mn:00007214 ; =============== S U B R O U T I N E =======================================
.text$mn:00007214
.text$mn:00007214 ; Attributes: bp-based frame
.text$mn:00007214
.text$mn:00007214 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>(void)
.text$mn:00007214                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.text$mn:00007214 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007214                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+B95p
.text$mn:00007214                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+BA4p ...
.text$mn:00007214
.text$mn:00007214 var_10          = dword ptr -10h
.text$mn:00007214 var_C           = dword ptr -0Ch
.text$mn:00007214 var_4           = dword ptr -4
.text$mn:00007214
.text$mn:00007214                 push    ebp
.text$mn:00007215                 mov     ebp, esp
.text$mn:00007217                 push    0FFFFFFFFh
.text$mn:00007219                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000721E                 mov     eax, large fs:0
.text$mn:00007224                 push    eax
.text$mn:00007225                 push    ecx
.text$mn:00007226                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000722B                 xor     eax, ebp
.text$mn:0000722D                 push    eax
.text$mn:0000722E                 lea     eax, [ebp+var_C]
.text$mn:00007231                 mov     large fs:0, eax
.text$mn:00007237                 mov     [ebp+var_10], ecx
.text$mn:0000723A                 mov     [ebp+var_4], 0
.text$mn:00007241                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007248                 mov     ecx, [ebp+var_10]
.text$mn:0000724B                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$mn:00007250                 mov     ecx, [ebp+var_C]
.text$mn:00007253                 mov     large fs:0, ecx
.text$mn:0000725A                 pop     ecx
.text$mn:0000725B                 mov     esp, ebp
.text$mn:0000725D                 pop     ebp
.text$mn:0000725E                 retn
.text$mn:0000725E ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000725E
.text$mn:0000725E ; ---------------------------------------------------------------------------
.text$mn:0000725F                 align 10h
.text$mn:0000725F _text$mn        ends
.text$mn:0000725F
.text$x:00007260 ; ===========================================================================
.text$x:00007260
.text$x:00007260 ; Segment type: Pure code
.text$x:00007260 ; Segment permissions: Read/Execute
.text$x:00007260 _text$x         segment para public 'CODE' use32
.text$x:00007260                 assume cs:_text$x
.text$x:00007260                 ;org 7260h
.text$x:00007260 ; COMDAT (pick associative to section at 7214)
.text$x:00007260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007260
.text$x:00007260 ; =============== S U B R O U T I N E =======================================
.text$x:00007260
.text$x:00007260
.text$x:00007260 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007260                                         ; DATA XREF: .xdata$x:0000E030o
.text$x:00007260                 mov     ecx, [ebp-10h]
.text$x:00007263                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:00007263 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007263
.text$x:00007268
.text$x:00007268 ; =============== S U B R O U T I N E =======================================
.text$x:00007268
.text$x:00007268
.text$x:00007268 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007268                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)+5o
.text$x:00007268
.text$x:00007268 arg_4           = dword ptr  8
.text$x:00007268
.text$x:00007268                 mov     edx, [esp+arg_4]
.text$x:0000726C                 lea     eax, [edx+0Ch]
.text$x:0000726F                 mov     ecx, [edx-8]
.text$x:00007272                 xor     ecx, eax
.text$x:00007274                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007279                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.text$x:0000727E                 jmp     ___CxxFrameHandler3
.text$x:0000727E __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000727E
.text$x:0000727E ; ---------------------------------------------------------------------------
.text$x:00007283                 align 4
.text$x:00007283 _text$x         ends
.text$x:00007283
.text$mn:00007284 ; ===========================================================================
.text$mn:00007284
.text$mn:00007284 ; Segment type: Pure code
.text$mn:00007284 ; Segment permissions: Read/Execute
.text$mn:00007284 _text$mn        segment para public 'CODE' use32
.text$mn:00007284                 assume cs:_text$mn
.text$mn:00007284                 ;org 7284h
.text$mn:00007284 ; COMDAT (pick any)
.text$mn:00007284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007284
.text$mn:00007284 ; =============== S U B R O U T I N E =======================================
.text$mn:00007284
.text$mn:00007284 ; Attributes: bp-based frame
.text$mn:00007284
.text$mn:00007284 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>(void)
.text$mn:00007284                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.text$mn:00007284 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00007284                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+D74p
.text$mn:00007284                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+D83p ...
.text$mn:00007284
.text$mn:00007284 var_10          = dword ptr -10h
.text$mn:00007284 var_C           = dword ptr -0Ch
.text$mn:00007284 var_4           = dword ptr -4
.text$mn:00007284
.text$mn:00007284                 push    ebp
.text$mn:00007285                 mov     ebp, esp
.text$mn:00007287                 push    0FFFFFFFFh
.text$mn:00007289                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000728E                 mov     eax, large fs:0
.text$mn:00007294                 push    eax
.text$mn:00007295                 push    ecx
.text$mn:00007296                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000729B                 xor     eax, ebp
.text$mn:0000729D                 push    eax
.text$mn:0000729E                 lea     eax, [ebp+var_C]
.text$mn:000072A1                 mov     large fs:0, eax
.text$mn:000072A7                 mov     [ebp+var_10], ecx
.text$mn:000072AA                 mov     [ebp+var_4], 0
.text$mn:000072B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000072B8                 mov     ecx, [ebp+var_10]
.text$mn:000072BB                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$mn:000072C0                 mov     ecx, [ebp+var_C]
.text$mn:000072C3                 mov     large fs:0, ecx
.text$mn:000072CA                 pop     ecx
.text$mn:000072CB                 mov     esp, ebp
.text$mn:000072CD                 pop     ebp
.text$mn:000072CE                 retn
.text$mn:000072CE ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000072CE
.text$mn:000072CE ; ---------------------------------------------------------------------------
.text$mn:000072CF                 align 10h
.text$mn:000072CF _text$mn        ends
.text$mn:000072CF
.text$x:000072D0 ; ===========================================================================
.text$x:000072D0
.text$x:000072D0 ; Segment type: Pure code
.text$x:000072D0 ; Segment permissions: Read/Execute
.text$x:000072D0 _text$x         segment para public 'CODE' use32
.text$x:000072D0                 assume cs:_text$x
.text$x:000072D0                 ;org 72D0h
.text$x:000072D0 ; COMDAT (pick associative to section at 7284)
.text$x:000072D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000072D0
.text$x:000072D0 ; =============== S U B R O U T I N E =======================================
.text$x:000072D0
.text$x:000072D0
.text$x:000072D0 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000072D0                                         ; DATA XREF: .xdata$x:0000E1F0o
.text$x:000072D0                 mov     ecx, [ebp-10h]
.text$x:000072D3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:000072D3 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000072D3
.text$x:000072D8
.text$x:000072D8 ; =============== S U B R O U T I N E =======================================
.text$x:000072D8
.text$x:000072D8
.text$x:000072D8 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000072D8                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)+5o
.text$x:000072D8
.text$x:000072D8 arg_4           = dword ptr  8
.text$x:000072D8
.text$x:000072D8                 mov     edx, [esp+arg_4]
.text$x:000072DC                 lea     eax, [edx+0Ch]
.text$x:000072DF                 mov     ecx, [edx-8]
.text$x:000072E2                 xor     ecx, eax
.text$x:000072E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072E9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.text$x:000072EE                 jmp     ___CxxFrameHandler3
.text$x:000072EE __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000072EE
.text$x:000072EE ; ---------------------------------------------------------------------------
.text$x:000072F3                 align 4
.text$x:000072F3 _text$x         ends
.text$x:000072F3
.text$mn:000072F4 ; ===========================================================================
.text$mn:000072F4
.text$mn:000072F4 ; Segment type: Pure code
.text$mn:000072F4 ; Segment permissions: Read/Execute
.text$mn:000072F4 _text$mn        segment para public 'CODE' use32
.text$mn:000072F4                 assume cs:_text$mn
.text$mn:000072F4                 ;org 72F4h
.text$mn:000072F4 ; COMDAT (pick any)
.text$mn:000072F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000072F4
.text$mn:000072F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000072F4
.text$mn:000072F4 ; Attributes: bp-based frame
.text$mn:000072F4
.text$mn:000072F4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>::~_Vector_val<struct std::_Simple_types<struct KeyCombo>>(void)
.text$mn:000072F4                 public ??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.text$mn:000072F4 ??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ proc near
.text$mn:000072F4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z$0+3j
.text$mn:000072F4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::~_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(void)+3Fp ...
.text$mn:000072F4
.text$mn:000072F4 var_10          = dword ptr -10h
.text$mn:000072F4 var_C           = dword ptr -0Ch
.text$mn:000072F4 var_4           = dword ptr -4
.text$mn:000072F4
.text$mn:000072F4                 push    ebp
.text$mn:000072F5                 mov     ebp, esp
.text$mn:000072F7                 push    0FFFFFFFFh
.text$mn:000072F9                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.text$mn:000072FE                 mov     eax, large fs:0
.text$mn:00007304                 push    eax
.text$mn:00007305                 push    ecx
.text$mn:00007306                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000730B                 xor     eax, ebp
.text$mn:0000730D                 push    eax
.text$mn:0000730E                 lea     eax, [ebp+var_C]
.text$mn:00007311                 mov     large fs:0, eax
.text$mn:00007317                 mov     [ebp+var_10], ecx
.text$mn:0000731A                 mov     [ebp+var_4], 0
.text$mn:00007321                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007328                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000732B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00007330                 mov     ecx, [ebp+var_C]
.text$mn:00007333                 mov     large fs:0, ecx
.text$mn:0000733A                 pop     ecx
.text$mn:0000733B                 mov     esp, ebp
.text$mn:0000733D                 pop     ebp
.text$mn:0000733E                 retn
.text$mn:0000733E ??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ endp
.text$mn:0000733E
.text$mn:0000733E ; ---------------------------------------------------------------------------
.text$mn:0000733F                 align 10h
.text$mn:0000733F _text$mn        ends
.text$mn:0000733F
.text$x:00007340 ; ===========================================================================
.text$x:00007340
.text$x:00007340 ; Segment type: Pure code
.text$x:00007340 ; Segment permissions: Read/Execute
.text$x:00007340 _text$x         segment para public 'CODE' use32
.text$x:00007340                 assume cs:_text$x
.text$x:00007340                 ;org 7340h
.text$x:00007340 ; COMDAT (pick associative to section at 72F4)
.text$x:00007340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007340
.text$x:00007340 ; =============== S U B R O U T I N E =======================================
.text$x:00007340
.text$x:00007340
.text$x:00007340 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007340                                         ; DATA XREF: .xdata$x:0000D30Co
.text$x:00007340                 mov     ecx, [ebp-10h]  ; this
.text$x:00007343                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00007343 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007343
.text$x:00007348
.text$x:00007348 ; =============== S U B R O U T I N E =======================================
.text$x:00007348
.text$x:00007348
.text$x:00007348 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ proc near
.text$x:00007348                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<KeyCombo>>::~_Vector_val<std::_Simple_types<KeyCombo>>(void)+5o
.text$x:00007348
.text$x:00007348 arg_4           = dword ptr  8
.text$x:00007348
.text$x:00007348                 mov     edx, [esp+arg_4]
.text$x:0000734C                 lea     eax, [edx+0Ch]
.text$x:0000734F                 mov     ecx, [edx-8]
.text$x:00007352                 xor     ecx, eax
.text$x:00007354                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007359                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.text$x:0000735E                 jmp     ___CxxFrameHandler3
.text$x:0000735E __ehhandler$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ endp
.text$x:0000735E
.text$x:0000735E ; ---------------------------------------------------------------------------
.text$x:00007363                 align 4
.text$x:00007363 _text$x         ends
.text$x:00007363
.text$mn:00007364 ; ===========================================================================
.text$mn:00007364
.text$mn:00007364 ; Segment type: Pure code
.text$mn:00007364 ; Segment permissions: Read/Execute
.text$mn:00007364 _text$mn        segment para public 'CODE' use32
.text$mn:00007364                 assume cs:_text$mn
.text$mn:00007364                 ;org 7364h
.text$mn:00007364 ; COMDAT (pick any)
.text$mn:00007364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007364
.text$mn:00007364 ; =============== S U B R O U T I N E =======================================
.text$mn:00007364
.text$mn:00007364 ; Attributes: bp-based frame
.text$mn:00007364
.text$mn:00007364 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>::~_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>(void)
.text$mn:00007364                 public ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00007364 ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:00007364                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0+3j
.text$mn:00007364                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)+3Fp ...
.text$mn:00007364
.text$mn:00007364 var_10          = dword ptr -10h
.text$mn:00007364 var_C           = dword ptr -0Ch
.text$mn:00007364 var_4           = dword ptr -4
.text$mn:00007364
.text$mn:00007364                 push    ebp
.text$mn:00007365                 mov     ebp, esp
.text$mn:00007367                 push    0FFFFFFFFh
.text$mn:00007369                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:0000736E                 mov     eax, large fs:0
.text$mn:00007374                 push    eax
.text$mn:00007375                 push    ecx
.text$mn:00007376                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000737B                 xor     eax, ebp
.text$mn:0000737D                 push    eax
.text$mn:0000737E                 lea     eax, [ebp+var_C]
.text$mn:00007381                 mov     large fs:0, eax
.text$mn:00007387                 mov     [ebp+var_10], ecx
.text$mn:0000738A                 mov     [ebp+var_4], 0
.text$mn:00007391                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007398                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000739B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000073A0                 mov     ecx, [ebp+var_C]
.text$mn:000073A3                 mov     large fs:0, ecx
.text$mn:000073AA                 pop     ecx
.text$mn:000073AB                 mov     esp, ebp
.text$mn:000073AD                 pop     ebp
.text$mn:000073AE                 retn
.text$mn:000073AE ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:000073AE
.text$mn:000073AE ; ---------------------------------------------------------------------------
.text$mn:000073AF                 align 10h
.text$mn:000073AF _text$mn        ends
.text$mn:000073AF
.text$x:000073B0 ; ===========================================================================
.text$x:000073B0
.text$x:000073B0 ; Segment type: Pure code
.text$x:000073B0 ; Segment permissions: Read/Execute
.text$x:000073B0 _text$x         segment para public 'CODE' use32
.text$x:000073B0                 assume cs:_text$x
.text$x:000073B0                 ;org 73B0h
.text$x:000073B0 ; COMDAT (pick associative to section at 7364)
.text$x:000073B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000073B0
.text$x:000073B0 ; =============== S U B R O U T I N E =======================================
.text$x:000073B0
.text$x:000073B0
.text$x:000073B0 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000073B0                                         ; DATA XREF: .xdata$x:0000DD68o
.text$x:000073B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000073B3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000073B3 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:000073B3
.text$x:000073B8
.text$x:000073B8 ; =============== S U B R O U T I N E =======================================
.text$x:000073B8
.text$x:000073B8
.text$x:000073B8 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:000073B8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)+5o
.text$x:000073B8
.text$x:000073B8 arg_4           = dword ptr  8
.text$x:000073B8
.text$x:000073B8                 mov     edx, [esp+arg_4]
.text$x:000073BC                 lea     eax, [edx+0Ch]
.text$x:000073BF                 mov     ecx, [edx-8]
.text$x:000073C2                 xor     ecx, eax
.text$x:000073C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073C9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:000073CE                 jmp     ___CxxFrameHandler3
.text$x:000073CE __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:000073CE
.text$x:000073CE ; ---------------------------------------------------------------------------
.text$x:000073D3                 align 4
.text$x:000073D3 _text$x         ends
.text$x:000073D3
.text$mn:000073D4 ; ===========================================================================
.text$mn:000073D4
.text$mn:000073D4 ; Segment type: Pure code
.text$mn:000073D4 ; Segment permissions: Read/Execute
.text$mn:000073D4 _text$mn        segment para public 'CODE' use32
.text$mn:000073D4                 assume cs:_text$mn
.text$mn:000073D4                 ;org 73D4h
.text$mn:000073D4 ; COMDAT (pick any)
.text$mn:000073D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000073D4
.text$mn:000073D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000073D4
.text$mn:000073D4 ; Attributes: bp-based frame
.text$mn:000073D4
.text$mn:000073D4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>::~_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>(void)
.text$mn:000073D4                 public ??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:000073D4 ??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$mn:000073D4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z$0+3j
.text$mn:000073D4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::~_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(void)+3Fp ...
.text$mn:000073D4
.text$mn:000073D4 var_10          = dword ptr -10h
.text$mn:000073D4 var_C           = dword ptr -0Ch
.text$mn:000073D4 var_4           = dword ptr -4
.text$mn:000073D4
.text$mn:000073D4                 push    ebp
.text$mn:000073D5                 mov     ebp, esp
.text$mn:000073D7                 push    0FFFFFFFFh
.text$mn:000073D9                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:000073DE                 mov     eax, large fs:0
.text$mn:000073E4                 push    eax
.text$mn:000073E5                 push    ecx
.text$mn:000073E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000073EB                 xor     eax, ebp
.text$mn:000073ED                 push    eax
.text$mn:000073EE                 lea     eax, [ebp+var_C]
.text$mn:000073F1                 mov     large fs:0, eax
.text$mn:000073F7                 mov     [ebp+var_10], ecx
.text$mn:000073FA                 mov     [ebp+var_4], 0
.text$mn:00007401                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007408                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000740B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00007410                 mov     ecx, [ebp+var_C]
.text$mn:00007413                 mov     large fs:0, ecx
.text$mn:0000741A                 pop     ecx
.text$mn:0000741B                 mov     esp, ebp
.text$mn:0000741D                 pop     ebp
.text$mn:0000741E                 retn
.text$mn:0000741E ??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$mn:0000741E
.text$mn:0000741E ; ---------------------------------------------------------------------------
.text$mn:0000741F                 align 10h
.text$mn:0000741F _text$mn        ends
.text$mn:0000741F
.text$x:00007420 ; ===========================================================================
.text$x:00007420
.text$x:00007420 ; Segment type: Pure code
.text$x:00007420 ; Segment permissions: Read/Execute
.text$x:00007420 _text$x         segment para public 'CODE' use32
.text$x:00007420                 assume cs:_text$x
.text$x:00007420                 ;org 7420h
.text$x:00007420 ; COMDAT (pick associative to section at 73D4)
.text$x:00007420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007420
.text$x:00007420 ; =============== S U B R O U T I N E =======================================
.text$x:00007420
.text$x:00007420
.text$x:00007420 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007420                                         ; DATA XREF: .xdata$x:0000D6FCo
.text$x:00007420                 mov     ecx, [ebp-10h]  ; this
.text$x:00007423                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00007423 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007423
.text$x:00007428
.text$x:00007428 ; =============== S U B R O U T I N E =======================================
.text$x:00007428
.text$x:00007428
.text$x:00007428 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$x:00007428                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<recordedMacroStep>>::~_Vector_val<std::_Simple_types<recordedMacroStep>>(void)+5o
.text$x:00007428
.text$x:00007428 arg_4           = dword ptr  8
.text$x:00007428
.text$x:00007428                 mov     edx, [esp+arg_4]
.text$x:0000742C                 lea     eax, [edx+0Ch]
.text$x:0000742F                 mov     ecx, [edx-8]
.text$x:00007432                 xor     ecx, eax
.text$x:00007434                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007439                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$x:0000743E                 jmp     ___CxxFrameHandler3
.text$x:0000743E __ehhandler$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$x:0000743E
.text$x:0000743E ; ---------------------------------------------------------------------------
.text$x:00007443                 align 4
.text$x:00007443 _text$x         ends
.text$x:00007443
.text$mn:00007444 ; ===========================================================================
.text$mn:00007444
.text$mn:00007444 ; Segment type: Pure code
.text$mn:00007444 ; Segment permissions: Read/Execute
.text$mn:00007444 _text$mn        segment para public 'CODE' use32
.text$mn:00007444                 assume cs:_text$mn
.text$mn:00007444                 ;org 7444h
.text$mn:00007444 ; COMDAT (pick any)
.text$mn:00007444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007444
.text$mn:00007444 ; =============== S U B R O U T I N E =======================================
.text$mn:00007444
.text$mn:00007444 ; Attributes: bp-based frame
.text$mn:00007444
.text$mn:00007444 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00007444                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00007444 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00007444                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00007444                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00007444
.text$mn:00007444 var_10          = dword ptr -10h
.text$mn:00007444 var_C           = dword ptr -0Ch
.text$mn:00007444 var_4           = dword ptr -4
.text$mn:00007444
.text$mn:00007444                 push    ebp
.text$mn:00007445                 mov     ebp, esp
.text$mn:00007447                 push    0FFFFFFFFh
.text$mn:00007449                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000744E                 mov     eax, large fs:0
.text$mn:00007454                 push    eax
.text$mn:00007455                 push    ecx
.text$mn:00007456                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000745B                 xor     eax, ebp
.text$mn:0000745D                 push    eax
.text$mn:0000745E                 lea     eax, [ebp+var_C]
.text$mn:00007461                 mov     large fs:0, eax
.text$mn:00007467                 mov     [ebp+var_10], ecx
.text$mn:0000746A                 mov     [ebp+var_4], 0
.text$mn:00007471                 push    0               ; Size
.text$mn:00007473                 push    1               ; char
.text$mn:00007475                 mov     ecx, [ebp+var_10]
.text$mn:00007478                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000747D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007484                 mov     ecx, [ebp+var_10]
.text$mn:00007487                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:0000748C                 mov     ecx, [ebp+var_C]
.text$mn:0000748F                 mov     large fs:0, ecx
.text$mn:00007496                 pop     ecx
.text$mn:00007497                 mov     esp, ebp
.text$mn:00007499                 pop     ebp
.text$mn:0000749A                 retn
.text$mn:0000749A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000749A
.text$mn:0000749A ; ---------------------------------------------------------------------------
.text$mn:0000749B                 align 4
.text$mn:0000749B _text$mn        ends
.text$mn:0000749B
.text$x:0000749C ; ===========================================================================
.text$x:0000749C
.text$x:0000749C ; Segment type: Pure code
.text$x:0000749C ; Segment permissions: Read/Execute
.text$x:0000749C _text$x         segment para public 'CODE' use32
.text$x:0000749C                 assume cs:_text$x
.text$x:0000749C                 ;org 749Ch
.text$x:0000749C ; COMDAT (pick associative to section at 7444)
.text$x:0000749C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000749C
.text$x:0000749C ; =============== S U B R O U T I N E =======================================
.text$x:0000749C
.text$x:0000749C
.text$x:0000749C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:0000749C                                         ; DATA XREF: .xdata$x:0000CE58o
.text$x:0000749C                 mov     ecx, [ebp-10h]
.text$x:0000749F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000749F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000749F
.text$x:000074A4
.text$x:000074A4 ; =============== S U B R O U T I N E =======================================
.text$x:000074A4
.text$x:000074A4
.text$x:000074A4 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000074A4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000074A4
.text$x:000074A4 arg_4           = dword ptr  8
.text$x:000074A4
.text$x:000074A4                 mov     edx, [esp+arg_4]
.text$x:000074A8                 lea     eax, [edx+0Ch]
.text$x:000074AB                 mov     ecx, [edx-8]
.text$x:000074AE                 xor     ecx, eax
.text$x:000074B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000074B5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000074BA                 jmp     ___CxxFrameHandler3
.text$x:000074BA __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000074BA
.text$x:000074BA ; ---------------------------------------------------------------------------
.text$x:000074BF                 align 10h
.text$x:000074BF _text$x         ends
.text$x:000074BF
.text$mn:000074C0 ; ===========================================================================
.text$mn:000074C0
.text$mn:000074C0 ; Segment type: Pure code
.text$mn:000074C0 ; Segment permissions: Read/Execute
.text$mn:000074C0 _text$mn        segment para public 'CODE' use32
.text$mn:000074C0                 assume cs:_text$mn
.text$mn:000074C0                 ;org 74C0h
.text$mn:000074C0 ; COMDAT (pick any)
.text$mn:000074C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074C0
.text$mn:000074C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000074C0
.text$mn:000074C0 ; Attributes: bp-based frame
.text$mn:000074C0
.text$mn:000074C0 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:000074C0                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:000074C0 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:000074C0                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+36Cp
.text$mn:000074C0                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+4E4p ...
.text$mn:000074C0
.text$mn:000074C0 var_10          = dword ptr -10h
.text$mn:000074C0 var_C           = dword ptr -0Ch
.text$mn:000074C0 var_4           = dword ptr -4
.text$mn:000074C0
.text$mn:000074C0                 push    ebp
.text$mn:000074C1                 mov     ebp, esp
.text$mn:000074C3                 push    0FFFFFFFFh
.text$mn:000074C5                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:000074CA                 mov     eax, large fs:0
.text$mn:000074D0                 push    eax
.text$mn:000074D1                 push    ecx
.text$mn:000074D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000074D7                 xor     eax, ebp
.text$mn:000074D9                 push    eax
.text$mn:000074DA                 lea     eax, [ebp+var_C]
.text$mn:000074DD                 mov     large fs:0, eax
.text$mn:000074E3                 mov     [ebp+var_10], ecx
.text$mn:000074E6                 mov     [ebp+var_4], 0
.text$mn:000074ED                 push    0
.text$mn:000074EF                 push    1
.text$mn:000074F1                 mov     ecx, [ebp+var_10]
.text$mn:000074F4                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000074F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007500                 mov     ecx, [ebp+var_10]
.text$mn:00007503                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00007508                 mov     ecx, [ebp+var_C]
.text$mn:0000750B                 mov     large fs:0, ecx
.text$mn:00007512                 pop     ecx
.text$mn:00007513                 mov     esp, ebp
.text$mn:00007515                 pop     ebp
.text$mn:00007516                 retn
.text$mn:00007516 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00007516
.text$mn:00007516 ; ---------------------------------------------------------------------------
.text$mn:00007517                 align 4
.text$mn:00007517 _text$mn        ends
.text$mn:00007517
.text$x:00007518 ; ===========================================================================
.text$x:00007518
.text$x:00007518 ; Segment type: Pure code
.text$x:00007518 ; Segment permissions: Read/Execute
.text$x:00007518 _text$x         segment para public 'CODE' use32
.text$x:00007518                 assume cs:_text$x
.text$x:00007518                 ;org 7518h
.text$x:00007518 ; COMDAT (pick associative to section at 74C0)
.text$x:00007518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007518
.text$x:00007518 ; =============== S U B R O U T I N E =======================================
.text$x:00007518
.text$x:00007518
.text$x:00007518 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00007518                                         ; DATA XREF: .xdata$x:0000D178o
.text$x:00007518                 mov     ecx, [ebp-10h]
.text$x:0000751B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000751B __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:0000751B
.text$x:00007520
.text$x:00007520 ; =============== S U B R O U T I N E =======================================
.text$x:00007520
.text$x:00007520
.text$x:00007520 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00007520                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00007520
.text$x:00007520 arg_4           = dword ptr  8
.text$x:00007520
.text$x:00007520                 mov     edx, [esp+arg_4]
.text$x:00007524                 lea     eax, [edx+0Ch]
.text$x:00007527                 mov     ecx, [edx-8]
.text$x:0000752A                 xor     ecx, eax
.text$x:0000752C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007531                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00007536                 jmp     ___CxxFrameHandler3
.text$x:00007536 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00007536
.text$x:00007536 ; ---------------------------------------------------------------------------
.text$x:0000753B                 align 4
.text$x:0000753B _text$x         ends
.text$x:0000753B
.text$mn:0000753C ; ===========================================================================
.text$mn:0000753C
.text$mn:0000753C ; Segment type: Pure code
.text$mn:0000753C ; Segment permissions: Read/Execute
.text$mn:0000753C _text$mn        segment para public 'CODE' use32
.text$mn:0000753C                 assume cs:_text$mn
.text$mn:0000753C                 ;org 753Ch
.text$mn:0000753C ; COMDAT (pick any)
.text$mn:0000753C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000753C
.text$mn:0000753C ; =============== S U B R O U T I N E =======================================
.text$mn:0000753C
.text$mn:0000753C ; Attributes: bp-based frame
.text$mn:0000753C
.text$mn:0000753C ; public: __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::~vector<struct KeyCombo, class std::allocator<struct KeyCombo>>(void)
.text$mn:0000753C                 public ??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ
.text$mn:0000753C ??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ proc near
.text$mn:0000753C                                         ; CODE XREF: __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$1+9j
.text$mn:0000753C                                         ; ScintillaKeyMap::~ScintillaKeyMap(void)+3Ap ...
.text$mn:0000753C
.text$mn:0000753C var_10          = dword ptr -10h
.text$mn:0000753C var_C           = dword ptr -0Ch
.text$mn:0000753C var_4           = dword ptr -4
.text$mn:0000753C
.text$mn:0000753C                 push    ebp
.text$mn:0000753D                 mov     ebp, esp
.text$mn:0000753F                 push    0FFFFFFFFh
.text$mn:00007541                 push    offset __ehhandler$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ
.text$mn:00007546                 mov     eax, large fs:0
.text$mn:0000754C                 push    eax
.text$mn:0000754D                 push    ecx
.text$mn:0000754E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007553                 xor     eax, ebp
.text$mn:00007555                 push    eax
.text$mn:00007556                 lea     eax, [ebp+var_C]
.text$mn:00007559                 mov     large fs:0, eax
.text$mn:0000755F                 mov     [ebp+var_10], ecx
.text$mn:00007562                 mov     [ebp+var_4], 0
.text$mn:00007569                 mov     ecx, [ebp+var_10]
.text$mn:0000756C                 call    ?_Tidy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Tidy(void)
.text$mn:00007571                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007578                 mov     ecx, [ebp+var_10]
.text$mn:0000757B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::~_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(void)
.text$mn:00007580                 mov     ecx, [ebp+var_C]
.text$mn:00007583                 mov     large fs:0, ecx
.text$mn:0000758A                 pop     ecx
.text$mn:0000758B                 mov     esp, ebp
.text$mn:0000758D                 pop     ebp
.text$mn:0000758E                 retn
.text$mn:0000758E ??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ endp
.text$mn:0000758E
.text$mn:0000758E ; ---------------------------------------------------------------------------
.text$mn:0000758F                 align 10h
.text$mn:0000758F _text$mn        ends
.text$mn:0000758F
.text$x:00007590 ; ===========================================================================
.text$x:00007590
.text$x:00007590 ; Segment type: Pure code
.text$x:00007590 ; Segment permissions: Read/Execute
.text$x:00007590 _text$x         segment para public 'CODE' use32
.text$x:00007590                 assume cs:_text$x
.text$x:00007590                 ;org 7590h
.text$x:00007590 ; COMDAT (pick associative to section at 753C)
.text$x:00007590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007590
.text$x:00007590 ; =============== S U B R O U T I N E =======================================
.text$x:00007590
.text$x:00007590
.text$x:00007590 __unwindfunclet$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007590                                         ; DATA XREF: .xdata$x:0000D400o
.text$x:00007590                 mov     ecx, [ebp-10h]
.text$x:00007593                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::~_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(void)
.text$x:00007593 __unwindfunclet$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007593
.text$x:00007598
.text$x:00007598 ; =============== S U B R O U T I N E =======================================
.text$x:00007598
.text$x:00007598
.text$x:00007598 __ehhandler$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ proc near
.text$x:00007598                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::~vector<KeyCombo,std::allocator<KeyCombo>>(void)+5o
.text$x:00007598
.text$x:00007598 arg_4           = dword ptr  8
.text$x:00007598
.text$x:00007598                 mov     edx, [esp+arg_4]
.text$x:0000759C                 lea     eax, [edx+0Ch]
.text$x:0000759F                 mov     ecx, [edx-8]
.text$x:000075A2                 xor     ecx, eax
.text$x:000075A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000075A9                 mov     eax, offset __ehfuncinfo$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ
.text$x:000075AE                 jmp     ___CxxFrameHandler3
.text$x:000075AE __ehhandler$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ endp
.text$x:000075AE
.text$x:000075AE ; ---------------------------------------------------------------------------
.text$x:000075B3                 align 4
.text$x:000075B3 _text$x         ends
.text$x:000075B3
.text$mn:000075B4 ; ===========================================================================
.text$mn:000075B4
.text$mn:000075B4 ; Segment type: Pure code
.text$mn:000075B4 ; Segment permissions: Read/Execute
.text$mn:000075B4 _text$mn        segment para public 'CODE' use32
.text$mn:000075B4                 assume cs:_text$mn
.text$mn:000075B4                 ;org 75B4h
.text$mn:000075B4 ; COMDAT (pick any)
.text$mn:000075B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075B4
.text$mn:000075B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000075B4
.text$mn:000075B4 ; Attributes: bp-based frame
.text$mn:000075B4
.text$mn:000075B4 ; public: __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::~vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>(void)
.text$mn:000075B4                 public ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:000075B4 ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:000075B4                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+106Ap
.text$mn:000075B4                                         ; __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$25+6j
.text$mn:000075B4
.text$mn:000075B4 var_10          = dword ptr -10h
.text$mn:000075B4 var_C           = dword ptr -0Ch
.text$mn:000075B4 var_4           = dword ptr -4
.text$mn:000075B4
.text$mn:000075B4                 push    ebp
.text$mn:000075B5                 mov     ebp, esp
.text$mn:000075B7                 push    0FFFFFFFFh
.text$mn:000075B9                 push    offset __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:000075BE                 mov     eax, large fs:0
.text$mn:000075C4                 push    eax
.text$mn:000075C5                 push    ecx
.text$mn:000075C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000075CB                 xor     eax, ebp
.text$mn:000075CD                 push    eax
.text$mn:000075CE                 lea     eax, [ebp+var_C]
.text$mn:000075D1                 mov     large fs:0, eax
.text$mn:000075D7                 mov     [ebp+var_10], ecx
.text$mn:000075DA                 mov     [ebp+var_4], 0
.text$mn:000075E1                 mov     ecx, [ebp+var_10]
.text$mn:000075E4                 call    ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Tidy(void)
.text$mn:000075E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000075F0                 mov     ecx, [ebp+var_10]
.text$mn:000075F3                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)
.text$mn:000075F8                 mov     ecx, [ebp+var_C]
.text$mn:000075FB                 mov     large fs:0, ecx
.text$mn:00007602                 pop     ecx
.text$mn:00007603                 mov     esp, ebp
.text$mn:00007605                 pop     ebp
.text$mn:00007606                 retn
.text$mn:00007606 ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:00007606
.text$mn:00007606 ; ---------------------------------------------------------------------------
.text$mn:00007607                 align 4
.text$mn:00007607 _text$mn        ends
.text$mn:00007607
.text$x:00007608 ; ===========================================================================
.text$x:00007608
.text$x:00007608 ; Segment type: Pure code
.text$x:00007608 ; Segment permissions: Read/Execute
.text$x:00007608 _text$x         segment para public 'CODE' use32
.text$x:00007608                 assume cs:_text$x
.text$x:00007608                 ;org 7608h
.text$x:00007608 ; COMDAT (pick associative to section at 75B4)
.text$x:00007608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007608
.text$x:00007608 ; =============== S U B R O U T I N E =======================================
.text$x:00007608
.text$x:00007608
.text$x:00007608 __unwindfunclet$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007608                                         ; DATA XREF: .xdata$x:0000DE18o
.text$x:00007608                 mov     ecx, [ebp-10h]
.text$x:0000760B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)
.text$x:0000760B __unwindfunclet$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000760B
.text$x:00007610
.text$x:00007610 ; =============== S U B R O U T I N E =======================================
.text$x:00007610
.text$x:00007610
.text$x:00007610 __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:00007610                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+5o
.text$x:00007610
.text$x:00007610 arg_4           = dword ptr  8
.text$x:00007610
.text$x:00007610                 mov     edx, [esp+arg_4]
.text$x:00007614                 lea     eax, [edx+0Ch]
.text$x:00007617                 mov     ecx, [edx-8]
.text$x:0000761A                 xor     ecx, eax
.text$x:0000761C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007621                 mov     eax, offset __ehfuncinfo$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:00007626                 jmp     ___CxxFrameHandler3
.text$x:00007626 __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:00007626
.text$x:00007626 ; ---------------------------------------------------------------------------
.text$x:0000762B                 align 4
.text$x:0000762B _text$x         ends
.text$x:0000762B
.text$mn:0000762C ; ===========================================================================
.text$mn:0000762C
.text$mn:0000762C ; Segment type: Pure code
.text$mn:0000762C ; Segment permissions: Read/Execute
.text$mn:0000762C _text$mn        segment para public 'CODE' use32
.text$mn:0000762C                 assume cs:_text$mn
.text$mn:0000762C                 ;org 762Ch
.text$mn:0000762C ; COMDAT (pick any)
.text$mn:0000762C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000762C
.text$mn:0000762C ; =============== S U B R O U T I N E =======================================
.text$mn:0000762C
.text$mn:0000762C ; Attributes: bp-based frame
.text$mn:0000762C
.text$mn:0000762C ; public: __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::~vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>(void)
.text$mn:0000762C                 public ??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:0000762C ??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$mn:0000762C                                         ; CODE XREF: __unwindfunclet$??0MacroShortcut@@QAE@ABV0@@Z$1+9j
.text$mn:0000762C                                         ; MacroShortcut::~MacroShortcut(void)+3Ap ...
.text$mn:0000762C
.text$mn:0000762C var_10          = dword ptr -10h
.text$mn:0000762C var_C           = dword ptr -0Ch
.text$mn:0000762C var_4           = dword ptr -4
.text$mn:0000762C
.text$mn:0000762C                 push    ebp
.text$mn:0000762D                 mov     ebp, esp
.text$mn:0000762F                 push    0FFFFFFFFh
.text$mn:00007631                 push    offset __ehhandler$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:00007636                 mov     eax, large fs:0
.text$mn:0000763C                 push    eax
.text$mn:0000763D                 push    ecx
.text$mn:0000763E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007643                 xor     eax, ebp
.text$mn:00007645                 push    eax
.text$mn:00007646                 lea     eax, [ebp+var_C]
.text$mn:00007649                 mov     large fs:0, eax
.text$mn:0000764F                 mov     [ebp+var_10], ecx
.text$mn:00007652                 mov     [ebp+var_4], 0
.text$mn:00007659                 mov     ecx, [ebp+var_10]
.text$mn:0000765C                 call    ?_Tidy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Tidy(void)
.text$mn:00007661                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007668                 mov     ecx, [ebp+var_10]
.text$mn:0000766B                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::~_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(void)
.text$mn:00007670                 mov     ecx, [ebp+var_C]
.text$mn:00007673                 mov     large fs:0, ecx
.text$mn:0000767A                 pop     ecx
.text$mn:0000767B                 mov     esp, ebp
.text$mn:0000767D                 pop     ebp
.text$mn:0000767E                 retn
.text$mn:0000767E ??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$mn:0000767E
.text$mn:0000767E ; ---------------------------------------------------------------------------
.text$mn:0000767F                 align 10h
.text$mn:0000767F _text$mn        ends
.text$mn:0000767F
.text$x:00007680 ; ===========================================================================
.text$x:00007680
.text$x:00007680 ; Segment type: Pure code
.text$x:00007680 ; Segment permissions: Read/Execute
.text$x:00007680 _text$x         segment para public 'CODE' use32
.text$x:00007680                 assume cs:_text$x
.text$x:00007680                 ;org 7680h
.text$x:00007680 ; COMDAT (pick associative to section at 762C)
.text$x:00007680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007680
.text$x:00007680 ; =============== S U B R O U T I N E =======================================
.text$x:00007680
.text$x:00007680
.text$x:00007680 __unwindfunclet$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007680                                         ; DATA XREF: .xdata$x:0000D7F0o
.text$x:00007680                 mov     ecx, [ebp-10h]
.text$x:00007683                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::~_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(void)
.text$x:00007683 __unwindfunclet$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007683
.text$x:00007688
.text$x:00007688 ; =============== S U B R O U T I N E =======================================
.text$x:00007688
.text$x:00007688
.text$x:00007688 __ehhandler$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$x:00007688                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::~vector<recordedMacroStep,std::allocator<recordedMacroStep>>(void)+5o
.text$x:00007688
.text$x:00007688 arg_4           = dword ptr  8
.text$x:00007688
.text$x:00007688                 mov     edx, [esp+arg_4]
.text$x:0000768C                 lea     eax, [edx+0Ch]
.text$x:0000768F                 mov     ecx, [edx-8]
.text$x:00007692                 xor     ecx, eax
.text$x:00007694                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007699                 mov     eax, offset __ehfuncinfo$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$x:0000769E                 jmp     ___CxxFrameHandler3
.text$x:0000769E __ehhandler$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$x:0000769E
.text$x:0000769E ; ---------------------------------------------------------------------------
.text$x:000076A3                 align 4
.text$x:000076A3 _text$x         ends
.text$x:000076A3
.text$mn:000076A4 ; ===========================================================================
.text$mn:000076A4
.text$mn:000076A4 ; Segment type: Pure code
.text$mn:000076A4 ; Segment permissions: Read/Execute
.text$mn:000076A4 _text$mn        segment para public 'CODE' use32
.text$mn:000076A4                 assume cs:_text$mn
.text$mn:000076A4                 ;org 76A4h
.text$mn:000076A4 ; COMDAT (pick any)
.text$mn:000076A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000076A4
.text$mn:000076A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000076A4
.text$mn:000076A4 ; Attributes: bp-based frame
.text$mn:000076A4
.text$mn:000076A4 ; _DWORD __thiscall CommandShortcut::~CommandShortcut(CommandShortcut *__hidden this)
.text$mn:000076A4                 public ??1CommandShortcut@@UAE@XZ
.text$mn:000076A4 ??1CommandShortcut@@UAE@XZ proc near    ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+38Dp
.text$mn:000076A4                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+39Fp ...
.text$mn:000076A4
.text$mn:000076A4 var_10          = dword ptr -10h
.text$mn:000076A4 var_C           = dword ptr -0Ch
.text$mn:000076A4 var_4           = dword ptr -4
.text$mn:000076A4
.text$mn:000076A4                 push    ebp
.text$mn:000076A5                 mov     ebp, esp
.text$mn:000076A7                 push    0FFFFFFFFh
.text$mn:000076A9                 push    offset __ehhandler$??1CommandShortcut@@UAE@XZ
.text$mn:000076AE                 mov     eax, large fs:0
.text$mn:000076B4                 push    eax
.text$mn:000076B5                 push    ecx
.text$mn:000076B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000076BB                 xor     eax, ebp
.text$mn:000076BD                 push    eax
.text$mn:000076BE                 lea     eax, [ebp+var_C]
.text$mn:000076C1                 mov     large fs:0, eax
.text$mn:000076C7                 mov     [ebp+var_10], ecx
.text$mn:000076CA                 mov     [ebp+var_4], 0
.text$mn:000076D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000076D8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000076DB                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:000076E0                 mov     ecx, [ebp+var_C]
.text$mn:000076E3                 mov     large fs:0, ecx
.text$mn:000076EA                 pop     ecx
.text$mn:000076EB                 mov     esp, ebp
.text$mn:000076ED                 pop     ebp
.text$mn:000076EE                 retn
.text$mn:000076EE ??1CommandShortcut@@UAE@XZ endp
.text$mn:000076EE
.text$mn:000076EE ; ---------------------------------------------------------------------------
.text$mn:000076EF                 align 10h
.text$mn:000076EF _text$mn        ends
.text$mn:000076EF
.text$x:000076F0 ; ===========================================================================
.text$x:000076F0
.text$x:000076F0 ; Segment type: Pure code
.text$x:000076F0 ; Segment permissions: Read/Execute
.text$x:000076F0 _text$x         segment para public 'CODE' use32
.text$x:000076F0                 assume cs:_text$x
.text$x:000076F0                 ;org 76F0h
.text$x:000076F0 ; COMDAT (pick associative to section at 76A4)
.text$x:000076F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000076F0
.text$x:000076F0 ; =============== S U B R O U T I N E =======================================
.text$x:000076F0
.text$x:000076F0
.text$x:000076F0 __unwindfunclet$??1CommandShortcut@@UAE@XZ$0 proc near
.text$x:000076F0                                         ; DATA XREF: .xdata$x:0000D288o
.text$x:000076F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000076F3                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:000076F3 __unwindfunclet$??1CommandShortcut@@UAE@XZ$0 endp
.text$x:000076F3
.text$x:000076F8
.text$x:000076F8 ; =============== S U B R O U T I N E =======================================
.text$x:000076F8
.text$x:000076F8
.text$x:000076F8 __ehhandler$??1CommandShortcut@@UAE@XZ proc near
.text$x:000076F8                                         ; DATA XREF: CommandShortcut::~CommandShortcut(void)+5o
.text$x:000076F8
.text$x:000076F8 arg_4           = dword ptr  8
.text$x:000076F8
.text$x:000076F8                 mov     edx, [esp+arg_4]
.text$x:000076FC                 lea     eax, [edx+0Ch]
.text$x:000076FF                 mov     ecx, [edx-8]
.text$x:00007702                 xor     ecx, eax
.text$x:00007704                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007709                 mov     eax, offset __ehfuncinfo$??1CommandShortcut@@UAE@XZ
.text$x:0000770E                 jmp     ___CxxFrameHandler3
.text$x:0000770E __ehhandler$??1CommandShortcut@@UAE@XZ endp
.text$x:0000770E
.text$x:0000770E ; ---------------------------------------------------------------------------
.text$x:00007713                 align 4
.text$x:00007713 _text$x         ends
.text$x:00007713
.text$mn:00007714 ; ===========================================================================
.text$mn:00007714
.text$mn:00007714 ; Segment type: Pure code
.text$mn:00007714 ; Segment permissions: Read/Execute
.text$mn:00007714 _text$mn        segment para public 'CODE' use32
.text$mn:00007714                 assume cs:_text$mn
.text$mn:00007714                 ;org 7714h
.text$mn:00007714 ; COMDAT (pick any)
.text$mn:00007714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007714
.text$mn:00007714 ; =============== S U B R O U T I N E =======================================
.text$mn:00007714
.text$mn:00007714 ; Attributes: bp-based frame
.text$mn:00007714
.text$mn:00007714 ; _DWORD __thiscall MacroShortcut::~MacroShortcut(MacroShortcut *__hidden this)
.text$mn:00007714                 public ??1MacroShortcut@@UAE@XZ
.text$mn:00007714 ??1MacroShortcut@@UAE@XZ proc near      ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+505p
.text$mn:00007714                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+517p ...
.text$mn:00007714
.text$mn:00007714 var_10          = dword ptr -10h
.text$mn:00007714 var_C           = dword ptr -0Ch
.text$mn:00007714 var_4           = dword ptr -4
.text$mn:00007714
.text$mn:00007714                 push    ebp
.text$mn:00007715                 mov     ebp, esp
.text$mn:00007717                 push    0FFFFFFFFh
.text$mn:00007719                 push    offset __ehhandler$??1MacroShortcut@@UAE@XZ
.text$mn:0000771E                 mov     eax, large fs:0
.text$mn:00007724                 push    eax
.text$mn:00007725                 push    ecx
.text$mn:00007726                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000772B                 xor     eax, ebp
.text$mn:0000772D                 push    eax
.text$mn:0000772E                 lea     eax, [ebp+var_C]
.text$mn:00007731                 mov     large fs:0, eax
.text$mn:00007737                 mov     [ebp+var_10], ecx
.text$mn:0000773A                 mov     [ebp+var_4], 1
.text$mn:00007741                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007745                 mov     ecx, [ebp+var_10]
.text$mn:00007748                 add     ecx, 12Ch
.text$mn:0000774E                 call    ??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::~vector<recordedMacroStep,std::allocator<recordedMacroStep>>(void)
.text$mn:00007753                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000775A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000775D                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:00007762                 mov     ecx, [ebp+var_C]
.text$mn:00007765                 mov     large fs:0, ecx
.text$mn:0000776C                 pop     ecx
.text$mn:0000776D                 mov     esp, ebp
.text$mn:0000776F                 pop     ebp
.text$mn:00007770                 retn
.text$mn:00007770 ??1MacroShortcut@@UAE@XZ endp
.text$mn:00007770
.text$mn:00007770 ; ---------------------------------------------------------------------------
.text$mn:00007771                 align 4
.text$mn:00007771 _text$mn        ends
.text$mn:00007771
.text$x:00007774 ; ===========================================================================
.text$x:00007774
.text$x:00007774 ; Segment type: Pure code
.text$x:00007774 ; Segment permissions: Read/Execute
.text$x:00007774 _text$x         segment para public 'CODE' use32
.text$x:00007774                 assume cs:_text$x
.text$x:00007774                 ;org 7774h
.text$x:00007774 ; COMDAT (pick associative to section at 7714)
.text$x:00007774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007774
.text$x:00007774 ; =============== S U B R O U T I N E =======================================
.text$x:00007774
.text$x:00007774
.text$x:00007774 __unwindfunclet$??1MacroShortcut@@UAE@XZ$0 proc near
.text$x:00007774                                         ; DATA XREF: .xdata$x:0000D8CCo
.text$x:00007774                 mov     ecx, [ebp-10h]  ; this
.text$x:00007777                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00007777 __unwindfunclet$??1MacroShortcut@@UAE@XZ$0 endp
.text$x:00007777
.text$x:0000777C
.text$x:0000777C ; =============== S U B R O U T I N E =======================================
.text$x:0000777C
.text$x:0000777C
.text$x:0000777C __unwindfunclet$??1MacroShortcut@@UAE@XZ$1 proc near
.text$x:0000777C                                         ; DATA XREF: .xdata$x:0000D8D4o
.text$x:0000777C                 mov     ecx, [ebp-10h]
.text$x:0000777F                 add     ecx, 12Ch
.text$x:00007785                 jmp     ??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::~vector<recordedMacroStep,std::allocator<recordedMacroStep>>(void)
.text$x:00007785 __unwindfunclet$??1MacroShortcut@@UAE@XZ$1 endp
.text$x:00007785
.text$x:0000778A
.text$x:0000778A ; =============== S U B R O U T I N E =======================================
.text$x:0000778A
.text$x:0000778A
.text$x:0000778A __ehhandler$??1MacroShortcut@@UAE@XZ proc near
.text$x:0000778A                                         ; DATA XREF: MacroShortcut::~MacroShortcut(void)+5o
.text$x:0000778A
.text$x:0000778A arg_4           = dword ptr  8
.text$x:0000778A
.text$x:0000778A                 mov     edx, [esp+arg_4]
.text$x:0000778E                 lea     eax, [edx+0Ch]
.text$x:00007791                 mov     ecx, [edx-8]
.text$x:00007794                 xor     ecx, eax
.text$x:00007796                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000779B                 mov     eax, offset __ehfuncinfo$??1MacroShortcut@@UAE@XZ
.text$x:000077A0                 jmp     ___CxxFrameHandler3
.text$x:000077A0 __ehhandler$??1MacroShortcut@@UAE@XZ endp
.text$x:000077A0
.text$x:000077A0 ; ---------------------------------------------------------------------------
.text$x:000077A5                 align 4
.text$x:000077A5 _text$x         ends
.text$x:000077A5
.text$mn:000077A8 ; ===========================================================================
.text$mn:000077A8
.text$mn:000077A8 ; Segment type: Pure code
.text$mn:000077A8 ; Segment permissions: Read/Execute
.text$mn:000077A8 _text$mn        segment para public 'CODE' use32
.text$mn:000077A8                 assume cs:_text$mn
.text$mn:000077A8                 ;org 77A8h
.text$mn:000077A8 ; COMDAT (pick any)
.text$mn:000077A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077A8
.text$mn:000077A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000077A8
.text$mn:000077A8 ; Attributes: bp-based frame
.text$mn:000077A8
.text$mn:000077A8 ; _DWORD __thiscall MenuItemUnit::~MenuItemUnit(MenuItemUnit *__hidden this)
.text$mn:000077A8                 public ??1MenuItemUnit@@QAE@XZ
.text$mn:000077A8 ??1MenuItemUnit@@QAE@XZ proc near       ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+FEFp
.text$mn:000077A8                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+103Dp ...
.text$mn:000077A8
.text$mn:000077A8 var_10          = dword ptr -10h
.text$mn:000077A8 var_C           = dword ptr -0Ch
.text$mn:000077A8 var_4           = dword ptr -4
.text$mn:000077A8
.text$mn:000077A8                 push    ebp
.text$mn:000077A9                 mov     ebp, esp
.text$mn:000077AB                 push    0FFFFFFFFh
.text$mn:000077AD                 push    offset __ehhandler$??1MenuItemUnit@@QAE@XZ
.text$mn:000077B2                 mov     eax, large fs:0
.text$mn:000077B8                 push    eax
.text$mn:000077B9                 push    ecx
.text$mn:000077BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000077BF                 xor     eax, ebp
.text$mn:000077C1                 push    eax
.text$mn:000077C2                 lea     eax, [ebp+var_C]
.text$mn:000077C5                 mov     large fs:0, eax
.text$mn:000077CB                 mov     [ebp+var_10], ecx
.text$mn:000077CE                 mov     [ebp+var_4], 1
.text$mn:000077D5                 mov     byte ptr [ebp+var_4], 0
.text$mn:000077D9                 mov     ecx, [ebp+var_10]
.text$mn:000077DC                 add     ecx, 20h ; ' '
.text$mn:000077DF                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000077E4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000077EB                 mov     ecx, [ebp+var_10]
.text$mn:000077EE                 add     ecx, 4
.text$mn:000077F1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000077F6                 mov     ecx, [ebp+var_C]
.text$mn:000077F9                 mov     large fs:0, ecx
.text$mn:00007800                 pop     ecx
.text$mn:00007801                 mov     esp, ebp
.text$mn:00007803                 pop     ebp
.text$mn:00007804                 retn
.text$mn:00007804 ??1MenuItemUnit@@QAE@XZ endp
.text$mn:00007804
.text$mn:00007804 ; ---------------------------------------------------------------------------
.text$mn:00007805                 align 4
.text$mn:00007805 _text$mn        ends
.text$mn:00007805
.text$x:00007808 ; ===========================================================================
.text$x:00007808
.text$x:00007808 ; Segment type: Pure code
.text$x:00007808 ; Segment permissions: Read/Execute
.text$x:00007808 _text$x         segment para public 'CODE' use32
.text$x:00007808                 assume cs:_text$x
.text$x:00007808                 ;org 7808h
.text$x:00007808 ; COMDAT (pick associative to section at 77A8)
.text$x:00007808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007808
.text$x:00007808 ; =============== S U B R O U T I N E =======================================
.text$x:00007808
.text$x:00007808
.text$x:00007808 __unwindfunclet$??1MenuItemUnit@@QAE@XZ$0 proc near
.text$x:00007808                                         ; DATA XREF: .xdata$x:0000DA04o
.text$x:00007808                 mov     ecx, [ebp-10h]
.text$x:0000780B                 add     ecx, 4
.text$x:0000780E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000780E __unwindfunclet$??1MenuItemUnit@@QAE@XZ$0 endp
.text$x:0000780E
.text$x:00007813
.text$x:00007813 ; =============== S U B R O U T I N E =======================================
.text$x:00007813
.text$x:00007813
.text$x:00007813 __unwindfunclet$??1MenuItemUnit@@QAE@XZ$1 proc near
.text$x:00007813                                         ; DATA XREF: .xdata$x:0000DA0Co
.text$x:00007813                 mov     ecx, [ebp-10h]
.text$x:00007816                 add     ecx, 20h ; ' '
.text$x:00007819                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00007819 __unwindfunclet$??1MenuItemUnit@@QAE@XZ$1 endp
.text$x:00007819
.text$x:0000781E
.text$x:0000781E ; =============== S U B R O U T I N E =======================================
.text$x:0000781E
.text$x:0000781E
.text$x:0000781E __ehhandler$??1MenuItemUnit@@QAE@XZ proc near
.text$x:0000781E                                         ; DATA XREF: MenuItemUnit::~MenuItemUnit(void)+5o
.text$x:0000781E
.text$x:0000781E arg_4           = dword ptr  8
.text$x:0000781E
.text$x:0000781E                 mov     edx, [esp+arg_4]
.text$x:00007822                 lea     eax, [edx+0Ch]
.text$x:00007825                 mov     ecx, [edx-8]
.text$x:00007828                 xor     ecx, eax
.text$x:0000782A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000782F                 mov     eax, offset __ehfuncinfo$??1MenuItemUnit@@QAE@XZ
.text$x:00007834                 jmp     ___CxxFrameHandler3
.text$x:00007834 __ehhandler$??1MenuItemUnit@@QAE@XZ endp
.text$x:00007834
.text$x:00007834 ; ---------------------------------------------------------------------------
.text$x:00007839                 align 4
.text$x:00007839 _text$x         ends
.text$x:00007839
.text$mn:0000783C ; ===========================================================================
.text$mn:0000783C
.text$mn:0000783C ; Segment type: Pure code
.text$mn:0000783C ; Segment permissions: Read/Execute
.text$mn:0000783C _text$mn        segment para public 'CODE' use32
.text$mn:0000783C                 assume cs:_text$mn
.text$mn:0000783C                 ;org 783Ch
.text$mn:0000783C ; COMDAT (pick any)
.text$mn:0000783C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000783C
.text$mn:0000783C ; =============== S U B R O U T I N E =======================================
.text$mn:0000783C
.text$mn:0000783C ; Attributes: bp-based frame
.text$mn:0000783C
.text$mn:0000783C ; _DWORD __thiscall PluginCmdShortcut::~PluginCmdShortcut(PluginCmdShortcut *__hidden this)
.text$mn:0000783C                 public ??1PluginCmdShortcut@@UAE@XZ
.text$mn:0000783C ??1PluginCmdShortcut@@UAE@XZ proc near  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+894p
.text$mn:0000783C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+8A6p ...
.text$mn:0000783C
.text$mn:0000783C var_10          = dword ptr -10h
.text$mn:0000783C var_C           = dword ptr -0Ch
.text$mn:0000783C var_4           = dword ptr -4
.text$mn:0000783C
.text$mn:0000783C                 push    ebp
.text$mn:0000783D                 mov     ebp, esp
.text$mn:0000783F                 push    0FFFFFFFFh
.text$mn:00007841                 push    offset __ehhandler$??1PluginCmdShortcut@@UAE@XZ
.text$mn:00007846                 mov     eax, large fs:0
.text$mn:0000784C                 push    eax
.text$mn:0000784D                 push    ecx
.text$mn:0000784E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007853                 xor     eax, ebp
.text$mn:00007855                 push    eax
.text$mn:00007856                 lea     eax, [ebp+var_C]
.text$mn:00007859                 mov     large fs:0, eax
.text$mn:0000785F                 mov     [ebp+var_10], ecx
.text$mn:00007862                 mov     [ebp+var_4], 1
.text$mn:00007869                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000786D                 mov     ecx, [ebp+var_10]
.text$mn:00007870                 add     ecx, 130h
.text$mn:00007876                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000787B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007882                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007885                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:0000788A                 mov     ecx, [ebp+var_C]
.text$mn:0000788D                 mov     large fs:0, ecx
.text$mn:00007894                 pop     ecx
.text$mn:00007895                 mov     esp, ebp
.text$mn:00007897                 pop     ebp
.text$mn:00007898                 retn
.text$mn:00007898 ??1PluginCmdShortcut@@UAE@XZ endp
.text$mn:00007898
.text$mn:00007898 ; ---------------------------------------------------------------------------
.text$mn:00007899                 align 4
.text$mn:00007899 _text$mn        ends
.text$mn:00007899
.text$x:0000789C ; ===========================================================================
.text$x:0000789C
.text$x:0000789C ; Segment type: Pure code
.text$x:0000789C ; Segment permissions: Read/Execute
.text$x:0000789C _text$x         segment para public 'CODE' use32
.text$x:0000789C                 assume cs:_text$x
.text$x:0000789C                 ;org 789Ch
.text$x:0000789C ; COMDAT (pick associative to section at 783C)
.text$x:0000789C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000789C
.text$x:0000789C ; =============== S U B R O U T I N E =======================================
.text$x:0000789C
.text$x:0000789C
.text$x:0000789C __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$0 proc near
.text$x:0000789C                                         ; DATA XREF: .xdata$x:0000D99Co
.text$x:0000789C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000789F                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:0000789F __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$0 endp
.text$x:0000789F
.text$x:000078A4
.text$x:000078A4 ; =============== S U B R O U T I N E =======================================
.text$x:000078A4
.text$x:000078A4
.text$x:000078A4 __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$1 proc near
.text$x:000078A4                                         ; DATA XREF: .xdata$x:0000D9A4o
.text$x:000078A4                 mov     ecx, [ebp-10h]
.text$x:000078A7                 add     ecx, 130h
.text$x:000078AD                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000078AD __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$1 endp
.text$x:000078AD
.text$x:000078B2
.text$x:000078B2 ; =============== S U B R O U T I N E =======================================
.text$x:000078B2
.text$x:000078B2
.text$x:000078B2 __ehhandler$??1PluginCmdShortcut@@UAE@XZ proc near
.text$x:000078B2                                         ; DATA XREF: PluginCmdShortcut::~PluginCmdShortcut(void)+5o
.text$x:000078B2
.text$x:000078B2 arg_4           = dword ptr  8
.text$x:000078B2
.text$x:000078B2                 mov     edx, [esp+arg_4]
.text$x:000078B6                 lea     eax, [edx+0Ch]
.text$x:000078B9                 mov     ecx, [edx-8]
.text$x:000078BC                 xor     ecx, eax
.text$x:000078BE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000078C3                 mov     eax, offset __ehfuncinfo$??1PluginCmdShortcut@@UAE@XZ
.text$x:000078C8                 jmp     ___CxxFrameHandler3
.text$x:000078C8 __ehhandler$??1PluginCmdShortcut@@UAE@XZ endp
.text$x:000078C8
.text$x:000078C8 ; ---------------------------------------------------------------------------
.text$x:000078CD                 align 10h
.text$x:000078CD _text$x         ends
.text$x:000078CD
.text$mn:000078D0 ; ===========================================================================
.text$mn:000078D0
.text$mn:000078D0 ; Segment type: Pure code
.text$mn:000078D0 ; Segment permissions: Read/Execute
.text$mn:000078D0 _text$mn        segment para public 'CODE' use32
.text$mn:000078D0                 assume cs:_text$mn
.text$mn:000078D0                 ;org 78D0h
.text$mn:000078D0 ; COMDAT (pick any)
.text$mn:000078D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078D0
.text$mn:000078D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000078D0
.text$mn:000078D0 ; Attributes: bp-based frame
.text$mn:000078D0
.text$mn:000078D0 ; _DWORD __thiscall ScintillaKeyMap::~ScintillaKeyMap(ScintillaKeyMap *__hidden this)
.text$mn:000078D0                 public ??1ScintillaKeyMap@@UAE@XZ
.text$mn:000078D0 ??1ScintillaKeyMap@@UAE@XZ proc near    ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+A01p
.text$mn:000078D0                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+A13p ...
.text$mn:000078D0
.text$mn:000078D0 var_10          = dword ptr -10h
.text$mn:000078D0 var_C           = dword ptr -0Ch
.text$mn:000078D0 var_4           = dword ptr -4
.text$mn:000078D0
.text$mn:000078D0                 push    ebp
.text$mn:000078D1                 mov     ebp, esp
.text$mn:000078D3                 push    0FFFFFFFFh
.text$mn:000078D5                 push    offset __ehhandler$??1ScintillaKeyMap@@UAE@XZ
.text$mn:000078DA                 mov     eax, large fs:0
.text$mn:000078E0                 push    eax
.text$mn:000078E1                 push    ecx
.text$mn:000078E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000078E7                 xor     eax, ebp
.text$mn:000078E9                 push    eax
.text$mn:000078EA                 lea     eax, [ebp+var_C]
.text$mn:000078ED                 mov     large fs:0, eax
.text$mn:000078F3                 mov     [ebp+var_10], ecx
.text$mn:000078F6                 mov     [ebp+var_4], 1
.text$mn:000078FD                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007901                 mov     ecx, [ebp+var_10]
.text$mn:00007904                 add     ecx, 130h
.text$mn:0000790A                 call    ??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::~vector<KeyCombo,std::allocator<KeyCombo>>(void)
.text$mn:0000790F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007916                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007919                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:0000791E                 mov     ecx, [ebp+var_C]
.text$mn:00007921                 mov     large fs:0, ecx
.text$mn:00007928                 pop     ecx
.text$mn:00007929                 mov     esp, ebp
.text$mn:0000792B                 pop     ebp
.text$mn:0000792C                 retn
.text$mn:0000792C ??1ScintillaKeyMap@@UAE@XZ endp
.text$mn:0000792C
.text$mn:0000792C ; ---------------------------------------------------------------------------
.text$mn:0000792D                 align 10h
.text$mn:0000792D _text$mn        ends
.text$mn:0000792D
.text$x:00007930 ; ===========================================================================
.text$x:00007930
.text$x:00007930 ; Segment type: Pure code
.text$x:00007930 ; Segment permissions: Read/Execute
.text$x:00007930 _text$x         segment para public 'CODE' use32
.text$x:00007930                 assume cs:_text$x
.text$x:00007930                 ;org 7930h
.text$x:00007930 ; COMDAT (pick associative to section at 78D0)
.text$x:00007930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007930
.text$x:00007930 ; =============== S U B R O U T I N E =======================================
.text$x:00007930
.text$x:00007930
.text$x:00007930 __unwindfunclet$??1ScintillaKeyMap@@UAE@XZ$0 proc near
.text$x:00007930                                         ; DATA XREF: .xdata$x:0000D4DCo
.text$x:00007930                 mov     ecx, [ebp-10h]  ; this
.text$x:00007933                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00007933 __unwindfunclet$??1ScintillaKeyMap@@UAE@XZ$0 endp
.text$x:00007933
.text$x:00007938
.text$x:00007938 ; =============== S U B R O U T I N E =======================================
.text$x:00007938
.text$x:00007938
.text$x:00007938 __unwindfunclet$??1ScintillaKeyMap@@UAE@XZ$1 proc near
.text$x:00007938                                         ; DATA XREF: .xdata$x:0000D4E4o
.text$x:00007938                 mov     ecx, [ebp-10h]
.text$x:0000793B                 add     ecx, 130h
.text$x:00007941                 jmp     ??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::~vector<KeyCombo,std::allocator<KeyCombo>>(void)
.text$x:00007941 __unwindfunclet$??1ScintillaKeyMap@@UAE@XZ$1 endp
.text$x:00007941
.text$x:00007946
.text$x:00007946 ; =============== S U B R O U T I N E =======================================
.text$x:00007946
.text$x:00007946
.text$x:00007946 __ehhandler$??1ScintillaKeyMap@@UAE@XZ proc near
.text$x:00007946                                         ; DATA XREF: ScintillaKeyMap::~ScintillaKeyMap(void)+5o
.text$x:00007946
.text$x:00007946 arg_4           = dword ptr  8
.text$x:00007946
.text$x:00007946                 mov     edx, [esp+arg_4]
.text$x:0000794A                 lea     eax, [edx+0Ch]
.text$x:0000794D                 mov     ecx, [edx-8]
.text$x:00007950                 xor     ecx, eax
.text$x:00007952                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007957                 mov     eax, offset __ehfuncinfo$??1ScintillaKeyMap@@UAE@XZ
.text$x:0000795C                 jmp     ___CxxFrameHandler3
.text$x:0000795C __ehhandler$??1ScintillaKeyMap@@UAE@XZ endp
.text$x:0000795C
.text$x:0000795C ; ---------------------------------------------------------------------------
.text$x:00007961                 align 4
.text$x:00007961 _text$x         ends
.text$x:00007961
.text$mn:00007964 ; ===========================================================================
.text$mn:00007964
.text$mn:00007964 ; Segment type: Pure code
.text$mn:00007964 ; Segment permissions: Read/Execute
.text$mn:00007964 _text$mn        segment para public 'CODE' use32
.text$mn:00007964                 assume cs:_text$mn
.text$mn:00007964                 ;org 7964h
.text$mn:00007964 ; COMDAT (pick any)
.text$mn:00007964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007964
.text$mn:00007964 ; =============== S U B R O U T I N E =======================================
.text$mn:00007964
.text$mn:00007964 ; Attributes: bp-based frame
.text$mn:00007964
.text$mn:00007964 ; _DWORD __thiscall Shortcut::~Shortcut(Shortcut *__hidden this)
.text$mn:00007964                 public ??1Shortcut@@UAE@XZ
.text$mn:00007964 ??1Shortcut@@UAE@XZ proc near           ; CODE XREF: __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0+3j
.text$mn:00007964                                         ; __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$0+3j ...
.text$mn:00007964
.text$mn:00007964 var_10          = dword ptr -10h
.text$mn:00007964 var_C           = dword ptr -0Ch
.text$mn:00007964 var_4           = dword ptr -4
.text$mn:00007964
.text$mn:00007964                 push    ebp
.text$mn:00007965                 mov     ebp, esp
.text$mn:00007967                 push    0FFFFFFFFh
.text$mn:00007969                 push    offset __ehhandler$??1Shortcut@@UAE@XZ
.text$mn:0000796E                 mov     eax, large fs:0
.text$mn:00007974                 push    eax
.text$mn:00007975                 push    ecx
.text$mn:00007976                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000797B                 xor     eax, ebp
.text$mn:0000797D                 push    eax
.text$mn:0000797E                 lea     eax, [ebp+var_C]
.text$mn:00007981                 mov     large fs:0, eax
.text$mn:00007987                 mov     [ebp+var_10], ecx
.text$mn:0000798A                 mov     [ebp+var_4], 0
.text$mn:00007991                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007998                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000799B                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:000079A0                 mov     ecx, [ebp+var_C]
.text$mn:000079A3                 mov     large fs:0, ecx
.text$mn:000079AA                 pop     ecx
.text$mn:000079AB                 mov     esp, ebp
.text$mn:000079AD                 pop     ebp
.text$mn:000079AE                 retn
.text$mn:000079AE ??1Shortcut@@UAE@XZ endp
.text$mn:000079AE
.text$mn:000079AE ; ---------------------------------------------------------------------------
.text$mn:000079AF                 align 10h
.text$mn:000079AF _text$mn        ends
.text$mn:000079AF
.text$x:000079B0 ; ===========================================================================
.text$x:000079B0
.text$x:000079B0 ; Segment type: Pure code
.text$x:000079B0 ; Segment permissions: Read/Execute
.text$x:000079B0 _text$x         segment para public 'CODE' use32
.text$x:000079B0                 assume cs:_text$x
.text$x:000079B0                 ;org 79B0h
.text$x:000079B0 ; COMDAT (pick associative to section at 7964)
.text$x:000079B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000079B0
.text$x:000079B0 ; =============== S U B R O U T I N E =======================================
.text$x:000079B0
.text$x:000079B0
.text$x:000079B0 __unwindfunclet$??1Shortcut@@UAE@XZ$0 proc near
.text$x:000079B0                                         ; DATA XREF: .xdata$x:0000D25Co
.text$x:000079B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000079B3                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:000079B3 __unwindfunclet$??1Shortcut@@UAE@XZ$0 endp
.text$x:000079B3
.text$x:000079B8
.text$x:000079B8 ; =============== S U B R O U T I N E =======================================
.text$x:000079B8
.text$x:000079B8
.text$x:000079B8 __ehhandler$??1Shortcut@@UAE@XZ proc near
.text$x:000079B8                                         ; DATA XREF: Shortcut::~Shortcut(void)+5o
.text$x:000079B8
.text$x:000079B8 arg_4           = dword ptr  8
.text$x:000079B8
.text$x:000079B8                 mov     edx, [esp+arg_4]
.text$x:000079BC                 lea     eax, [edx+0Ch]
.text$x:000079BF                 mov     ecx, [edx-8]
.text$x:000079C2                 xor     ecx, eax
.text$x:000079C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000079C9                 mov     eax, offset __ehfuncinfo$??1Shortcut@@UAE@XZ
.text$x:000079CE                 jmp     ___CxxFrameHandler3
.text$x:000079CE __ehhandler$??1Shortcut@@UAE@XZ endp
.text$x:000079CE
.text$x:000079CE ; ---------------------------------------------------------------------------
.text$x:000079D3                 align 4
.text$x:000079D3 _text$x         ends
.text$x:000079D3
.text$mn:000079D4 ; ===========================================================================
.text$mn:000079D4
.text$mn:000079D4 ; Segment type: Pure code
.text$mn:000079D4 ; Segment permissions: Read/Execute
.text$mn:000079D4 _text$mn        segment para public 'CODE' use32
.text$mn:000079D4                 assume cs:_text$mn
.text$mn:000079D4                 ;org 79D4h
.text$mn:000079D4 ; COMDAT (pick any)
.text$mn:000079D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079D4
.text$mn:000079D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000079D4
.text$mn:000079D4 ; Attributes: bp-based frame
.text$mn:000079D4
.text$mn:000079D4 ; _DWORD __thiscall StaticDialog::~StaticDialog(StaticDialog *__hidden this)
.text$mn:000079D4                 public ??1StaticDialog@@UAE@XZ
.text$mn:000079D4 ??1StaticDialog@@UAE@XZ proc near       ; CODE XREF: __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0+3j
.text$mn:000079D4                                         ; Shortcut::~Shortcut(void)+37p ...
.text$mn:000079D4
.text$mn:000079D4 var_10          = dword ptr -10h
.text$mn:000079D4 var_C           = dword ptr -0Ch
.text$mn:000079D4 var_4           = dword ptr -4
.text$mn:000079D4
.text$mn:000079D4                 push    ebp
.text$mn:000079D5                 mov     ebp, esp
.text$mn:000079D7                 push    0FFFFFFFFh
.text$mn:000079D9                 push    offset __ehhandler$??1StaticDialog@@UAE@XZ
.text$mn:000079DE                 mov     eax, large fs:0
.text$mn:000079E4                 push    eax
.text$mn:000079E5                 push    ecx
.text$mn:000079E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000079EB                 xor     eax, ebp
.text$mn:000079ED                 push    eax
.text$mn:000079EE                 lea     eax, [ebp+var_C]
.text$mn:000079F1                 mov     large fs:0, eax
.text$mn:000079F7                 mov     [ebp+var_10], ecx
.text$mn:000079FA                 mov     eax, [ebp+var_10]
.text$mn:000079FD                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:00007A03                 mov     [ebp+var_4], 0
.text$mn:00007A0A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A0D                 call    ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.text$mn:00007A12                 movzx   ecx, al
.text$mn:00007A15                 test    ecx, ecx
.text$mn:00007A17                 jz      short loc_7A32
.text$mn:00007A19                 push    0               ; dwNewLong
.text$mn:00007A1B                 push    0FFFFFFEBh      ; nIndex
.text$mn:00007A1D                 mov     edx, [ebp+var_10]
.text$mn:00007A20                 mov     eax, [edx+0Ch]
.text$mn:00007A23                 push    eax             ; hWnd
.text$mn:00007A24                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00007A2A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A2D                 call    ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.text$mn:00007A32
.text$mn:00007A32 loc_7A32:                               ; CODE XREF: StaticDialog::~StaticDialog(void)+43j
.text$mn:00007A32                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007A39                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007A3C                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00007A41                 mov     ecx, [ebp+var_C]
.text$mn:00007A44                 mov     large fs:0, ecx
.text$mn:00007A4B                 pop     ecx
.text$mn:00007A4C                 mov     esp, ebp
.text$mn:00007A4E                 pop     ebp
.text$mn:00007A4F                 retn
.text$mn:00007A4F ??1StaticDialog@@UAE@XZ endp
.text$mn:00007A4F
.text$mn:00007A4F _text$mn        ends
.text$mn:00007A4F
.text$x:00007A50 ; ===========================================================================
.text$x:00007A50
.text$x:00007A50 ; Segment type: Pure code
.text$x:00007A50 ; Segment permissions: Read/Execute
.text$x:00007A50 _text$x         segment para public 'CODE' use32
.text$x:00007A50                 assume cs:_text$x
.text$x:00007A50                 ;org 7A50h
.text$x:00007A50 ; COMDAT (pick associative to section at 79D4)
.text$x:00007A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007A50
.text$x:00007A50 ; =============== S U B R O U T I N E =======================================
.text$x:00007A50
.text$x:00007A50
.text$x:00007A50 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 proc near
.text$x:00007A50                                         ; DATA XREF: .xdata$x:0000CC98o
.text$x:00007A50                 mov     ecx, [ebp-10h]  ; this
.text$x:00007A53                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00007A53 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 endp
.text$x:00007A53
.text$x:00007A58
.text$x:00007A58 ; =============== S U B R O U T I N E =======================================
.text$x:00007A58
.text$x:00007A58
.text$x:00007A58 __ehhandler$??1StaticDialog@@UAE@XZ proc near
.text$x:00007A58                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+5o
.text$x:00007A58
.text$x:00007A58 arg_4           = dword ptr  8
.text$x:00007A58
.text$x:00007A58                 mov     edx, [esp+arg_4]
.text$x:00007A5C                 lea     eax, [edx+0Ch]
.text$x:00007A5F                 mov     ecx, [edx-8]
.text$x:00007A62                 xor     ecx, eax
.text$x:00007A64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007A69                 mov     eax, offset __ehfuncinfo$??1StaticDialog@@UAE@XZ
.text$x:00007A6E                 jmp     ___CxxFrameHandler3
.text$x:00007A6E __ehhandler$??1StaticDialog@@UAE@XZ endp
.text$x:00007A6E
.text$x:00007A6E ; ---------------------------------------------------------------------------
.text$x:00007A73                 align 4
.text$x:00007A73 _text$x         ends
.text$x:00007A73
.text$mn:00007A74 ; ===========================================================================
.text$mn:00007A74
.text$mn:00007A74 ; Segment type: Pure code
.text$mn:00007A74 ; Segment permissions: Read/Execute
.text$mn:00007A74 _text$mn        segment para public 'CODE' use32
.text$mn:00007A74                 assume cs:_text$mn
.text$mn:00007A74                 ;org 7A74h
.text$mn:00007A74 ; COMDAT (pick any)
.text$mn:00007A74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A74
.text$mn:00007A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A74
.text$mn:00007A74 ; Attributes: bp-based frame
.text$mn:00007A74
.text$mn:00007A74 ; _DWORD __thiscall UserCommand::~UserCommand(UserCommand *__hidden this)
.text$mn:00007A74                 public ??1UserCommand@@UAE@XZ
.text$mn:00007A74 ??1UserCommand@@UAE@XZ proc near        ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+68Fp
.text$mn:00007A74                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+6A1p ...
.text$mn:00007A74
.text$mn:00007A74 var_10          = dword ptr -10h
.text$mn:00007A74 var_C           = dword ptr -0Ch
.text$mn:00007A74 var_4           = dword ptr -4
.text$mn:00007A74
.text$mn:00007A74                 push    ebp
.text$mn:00007A75                 mov     ebp, esp
.text$mn:00007A77                 push    0FFFFFFFFh
.text$mn:00007A79                 push    offset __ehhandler$??1UserCommand@@UAE@XZ
.text$mn:00007A7E                 mov     eax, large fs:0
.text$mn:00007A84                 push    eax
.text$mn:00007A85                 push    ecx
.text$mn:00007A86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007A8B                 xor     eax, ebp
.text$mn:00007A8D                 push    eax
.text$mn:00007A8E                 lea     eax, [ebp+var_C]
.text$mn:00007A91                 mov     large fs:0, eax
.text$mn:00007A97                 mov     [ebp+var_10], ecx
.text$mn:00007A9A                 mov     [ebp+var_4], 1
.text$mn:00007AA1                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007AA5                 mov     ecx, [ebp+var_10]
.text$mn:00007AA8                 add     ecx, 12Ch
.text$mn:00007AAE                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00007AB3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007ABA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007ABD                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:00007AC2                 mov     ecx, [ebp+var_C]
.text$mn:00007AC5                 mov     large fs:0, ecx
.text$mn:00007ACC                 pop     ecx
.text$mn:00007ACD                 mov     esp, ebp
.text$mn:00007ACF                 pop     ebp
.text$mn:00007AD0                 retn
.text$mn:00007AD0 ??1UserCommand@@UAE@XZ endp
.text$mn:00007AD0
.text$mn:00007AD0 ; ---------------------------------------------------------------------------
.text$mn:00007AD1                 align 4
.text$mn:00007AD1 _text$mn        ends
.text$mn:00007AD1
.text$x:00007AD4 ; ===========================================================================
.text$x:00007AD4
.text$x:00007AD4 ; Segment type: Pure code
.text$x:00007AD4 ; Segment permissions: Read/Execute
.text$x:00007AD4 _text$x         segment para public 'CODE' use32
.text$x:00007AD4                 assume cs:_text$x
.text$x:00007AD4                 ;org 7AD4h
.text$x:00007AD4 ; COMDAT (pick associative to section at 7A74)
.text$x:00007AD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007AD4
.text$x:00007AD4 ; =============== S U B R O U T I N E =======================================
.text$x:00007AD4
.text$x:00007AD4
.text$x:00007AD4 __unwindfunclet$??1UserCommand@@UAE@XZ$0 proc near
.text$x:00007AD4                                         ; DATA XREF: .xdata$x:0000D934o
.text$x:00007AD4                 mov     ecx, [ebp-10h]  ; this
.text$x:00007AD7                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00007AD7 __unwindfunclet$??1UserCommand@@UAE@XZ$0 endp
.text$x:00007AD7
.text$x:00007ADC
.text$x:00007ADC ; =============== S U B R O U T I N E =======================================
.text$x:00007ADC
.text$x:00007ADC
.text$x:00007ADC __unwindfunclet$??1UserCommand@@UAE@XZ$1 proc near
.text$x:00007ADC                                         ; DATA XREF: .xdata$x:0000D93Co
.text$x:00007ADC                 mov     ecx, [ebp-10h]
.text$x:00007ADF                 add     ecx, 12Ch
.text$x:00007AE5                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00007AE5 __unwindfunclet$??1UserCommand@@UAE@XZ$1 endp
.text$x:00007AE5
.text$x:00007AEA
.text$x:00007AEA ; =============== S U B R O U T I N E =======================================
.text$x:00007AEA
.text$x:00007AEA
.text$x:00007AEA __ehhandler$??1UserCommand@@UAE@XZ proc near
.text$x:00007AEA                                         ; DATA XREF: UserCommand::~UserCommand(void)+5o
.text$x:00007AEA
.text$x:00007AEA arg_4           = dword ptr  8
.text$x:00007AEA
.text$x:00007AEA                 mov     edx, [esp+arg_4]
.text$x:00007AEE                 lea     eax, [edx+0Ch]
.text$x:00007AF1                 mov     ecx, [edx-8]
.text$x:00007AF4                 xor     ecx, eax
.text$x:00007AF6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007AFB                 mov     eax, offset __ehfuncinfo$??1UserCommand@@UAE@XZ
.text$x:00007B00                 jmp     ___CxxFrameHandler3
.text$x:00007B00 __ehhandler$??1UserCommand@@UAE@XZ endp
.text$x:00007B00
.text$x:00007B00 ; ---------------------------------------------------------------------------
.text$x:00007B05                 align 4
.text$x:00007B05 _text$x         ends
.text$x:00007B05
.text$mn:00007B08 ; ===========================================================================
.text$mn:00007B08
.text$mn:00007B08 ; Segment type: Pure code
.text$mn:00007B08 ; Segment permissions: Read/Execute
.text$mn:00007B08 _text$mn        segment para public 'CODE' use32
.text$mn:00007B08                 assume cs:_text$mn
.text$mn:00007B08                 ;org 7B08h
.text$mn:00007B08 ; COMDAT (pick any)
.text$mn:00007B08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B08
.text$mn:00007B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B08
.text$mn:00007B08 ; Attributes: bp-based frame
.text$mn:00007B08
.text$mn:00007B08 ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:00007B08                 public ??1Window@@UAE@XZ
.text$mn:00007B08 ??1Window@@UAE@XZ proc near             ; CODE XREF: __unwindfunclet$??0StaticDialog@@QAE@XZ$0+3j
.text$mn:00007B08                                         ; StaticDialog::~StaticDialog(void)+68p ...
.text$mn:00007B08
.text$mn:00007B08 var_4           = dword ptr -4
.text$mn:00007B08
.text$mn:00007B08                 push    ebp
.text$mn:00007B09                 mov     ebp, esp
.text$mn:00007B0B                 push    ecx
.text$mn:00007B0C                 mov     [ebp+var_4], ecx
.text$mn:00007B0F                 mov     eax, [ebp+var_4]
.text$mn:00007B12                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00007B18                 mov     esp, ebp
.text$mn:00007B1A                 pop     ebp
.text$mn:00007B1B                 retn
.text$mn:00007B1B ??1Window@@UAE@XZ endp
.text$mn:00007B1B
.text$mn:00007B1B _text$mn        ends
.text$mn:00007B1B
.text$mn:00007B1C ; ===========================================================================
.text$mn:00007B1C
.text$mn:00007B1C ; Segment type: Pure code
.text$mn:00007B1C ; Segment permissions: Read/Execute
.text$mn:00007B1C _text$mn        segment para public 'CODE' use32
.text$mn:00007B1C                 assume cs:_text$mn
.text$mn:00007B1C                 ;org 7B1Ch
.text$mn:00007B1C ; COMDAT (pick any)
.text$mn:00007B1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B1C
.text$mn:00007B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B1C
.text$mn:00007B1C ; Attributes: bp-based frame
.text$mn:00007B1C
.text$mn:00007B1C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00007B1C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00007B1C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00007B1C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00007B1C                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00007B1C
.text$mn:00007B1C var_4           = dword ptr -4
.text$mn:00007B1C
.text$mn:00007B1C                 push    ebp
.text$mn:00007B1D                 mov     ebp, esp
.text$mn:00007B1F                 push    ecx
.text$mn:00007B20                 mov     [ebp+var_4], ecx
.text$mn:00007B23                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007B26                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007B2B                 mov     esp, ebp
.text$mn:00007B2D                 pop     ebp
.text$mn:00007B2E                 retn
.text$mn:00007B2E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00007B2E
.text$mn:00007B2E ; ---------------------------------------------------------------------------
.text$mn:00007B2F                 align 10h
.text$mn:00007B2F _text$mn        ends
.text$mn:00007B2F
.text$mn:00007B30 ; ===========================================================================
.text$mn:00007B30
.text$mn:00007B30 ; Segment type: Pure code
.text$mn:00007B30 ; Segment permissions: Read/Execute
.text$mn:00007B30 _text$mn        segment para public 'CODE' use32
.text$mn:00007B30                 assume cs:_text$mn
.text$mn:00007B30                 ;org 7B30h
.text$mn:00007B30 ; COMDAT (pick any)
.text$mn:00007B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B30
.text$mn:00007B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B30
.text$mn:00007B30 ; Attributes: bp-based frame
.text$mn:00007B30
.text$mn:00007B30 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00007B30                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00007B30 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00007B30                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00007B30                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00007B30
.text$mn:00007B30 var_10          = dword ptr -10h
.text$mn:00007B30 var_C           = dword ptr -0Ch
.text$mn:00007B30 var_4           = dword ptr -4
.text$mn:00007B30
.text$mn:00007B30                 push    ebp
.text$mn:00007B31                 mov     ebp, esp
.text$mn:00007B33                 push    0FFFFFFFFh
.text$mn:00007B35                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00007B3A                 mov     eax, large fs:0
.text$mn:00007B40                 push    eax
.text$mn:00007B41                 push    ecx
.text$mn:00007B42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007B47                 xor     eax, ebp
.text$mn:00007B49                 push    eax
.text$mn:00007B4A                 lea     eax, [ebp+var_C]
.text$mn:00007B4D                 mov     large fs:0, eax
.text$mn:00007B53                 mov     [ebp+var_10], ecx
.text$mn:00007B56                 mov     [ebp+var_4], 0
.text$mn:00007B5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007B64                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007B67                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00007B6C                 mov     ecx, [ebp+var_C]
.text$mn:00007B6F                 mov     large fs:0, ecx
.text$mn:00007B76                 pop     ecx
.text$mn:00007B77                 mov     esp, ebp
.text$mn:00007B79                 pop     ebp
.text$mn:00007B7A                 retn
.text$mn:00007B7A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00007B7A
.text$mn:00007B7A ; ---------------------------------------------------------------------------
.text$mn:00007B7B                 align 4
.text$mn:00007B7B _text$mn        ends
.text$mn:00007B7B
.text$x:00007B7C ; ===========================================================================
.text$x:00007B7C
.text$x:00007B7C ; Segment type: Pure code
.text$x:00007B7C ; Segment permissions: Read/Execute
.text$x:00007B7C _text$x         segment para public 'CODE' use32
.text$x:00007B7C                 assume cs:_text$x
.text$x:00007B7C                 ;org 7B7Ch
.text$x:00007B7C ; COMDAT (pick associative to section at 7B30)
.text$x:00007B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007B7C
.text$x:00007B7C ; =============== S U B R O U T I N E =======================================
.text$x:00007B7C
.text$x:00007B7C
.text$x:00007B7C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00007B7C                                         ; DATA XREF: .xdata$x:0000CF68o
.text$x:00007B7C                 mov     ecx, [ebp-10h]  ; this
.text$x:00007B7F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00007B7F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00007B7F
.text$x:00007B84
.text$x:00007B84 ; =============== S U B R O U T I N E =======================================
.text$x:00007B84
.text$x:00007B84
.text$x:00007B84 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00007B84                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00007B84
.text$x:00007B84 arg_4           = dword ptr  8
.text$x:00007B84
.text$x:00007B84                 mov     edx, [esp+arg_4]
.text$x:00007B88                 lea     eax, [edx+0Ch]
.text$x:00007B8B                 mov     ecx, [edx-8]
.text$x:00007B8E                 xor     ecx, eax
.text$x:00007B90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007B95                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00007B9A                 jmp     ___CxxFrameHandler3
.text$x:00007B9A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00007B9A
.text$x:00007B9A ; ---------------------------------------------------------------------------
.text$x:00007B9F                 align 10h
.text$x:00007B9F _text$x         ends
.text$x:00007B9F
.text$mn:00007BA0 ; ===========================================================================
.text$mn:00007BA0
.text$mn:00007BA0 ; Segment type: Pure code
.text$mn:00007BA0 ; Segment permissions: Read/Execute
.text$mn:00007BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00007BA0                 assume cs:_text$mn
.text$mn:00007BA0                 ;org 7BA0h
.text$mn:00007BA0 ; COMDAT (pick any)
.text$mn:00007BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BA0
.text$mn:00007BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BA0
.text$mn:00007BA0 ; Attributes: bp-based frame
.text$mn:00007BA0
.text$mn:00007BA0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00007BA0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00007BA0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00007BA0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00007BA0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00007BA0
.text$mn:00007BA0 var_10          = dword ptr -10h
.text$mn:00007BA0 var_C           = dword ptr -0Ch
.text$mn:00007BA0 var_4           = dword ptr -4
.text$mn:00007BA0
.text$mn:00007BA0                 push    ebp
.text$mn:00007BA1                 mov     ebp, esp
.text$mn:00007BA3                 push    0FFFFFFFFh
.text$mn:00007BA5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00007BAA                 mov     eax, large fs:0
.text$mn:00007BB0                 push    eax
.text$mn:00007BB1                 push    ecx
.text$mn:00007BB2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007BB7                 xor     eax, ebp
.text$mn:00007BB9                 push    eax
.text$mn:00007BBA                 lea     eax, [ebp+var_C]
.text$mn:00007BBD                 mov     large fs:0, eax
.text$mn:00007BC3                 mov     [ebp+var_10], ecx
.text$mn:00007BC6                 mov     [ebp+var_4], 0
.text$mn:00007BCD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007BD4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007BD7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007BDC                 mov     ecx, [ebp+var_C]
.text$mn:00007BDF                 mov     large fs:0, ecx
.text$mn:00007BE6                 pop     ecx
.text$mn:00007BE7                 mov     esp, ebp
.text$mn:00007BE9                 pop     ebp
.text$mn:00007BEA                 retn
.text$mn:00007BEA ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00007BEA
.text$mn:00007BEA ; ---------------------------------------------------------------------------
.text$mn:00007BEB                 align 4
.text$mn:00007BEB _text$mn        ends
.text$mn:00007BEB
.text$x:00007BEC ; ===========================================================================
.text$x:00007BEC
.text$x:00007BEC ; Segment type: Pure code
.text$x:00007BEC ; Segment permissions: Read/Execute
.text$x:00007BEC _text$x         segment para public 'CODE' use32
.text$x:00007BEC                 assume cs:_text$x
.text$x:00007BEC                 ;org 7BECh
.text$x:00007BEC ; COMDAT (pick associative to section at 7BA0)
.text$x:00007BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007BEC
.text$x:00007BEC ; =============== S U B R O U T I N E =======================================
.text$x:00007BEC
.text$x:00007BEC
.text$x:00007BEC __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00007BEC                                         ; DATA XREF: .xdata$x:0000CFECo
.text$x:00007BEC                 mov     ecx, [ebp-10h]  ; this
.text$x:00007BEF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007BEF __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00007BEF
.text$x:00007BF4
.text$x:00007BF4 ; =============== S U B R O U T I N E =======================================
.text$x:00007BF4
.text$x:00007BF4
.text$x:00007BF4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00007BF4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00007BF4
.text$x:00007BF4 arg_4           = dword ptr  8
.text$x:00007BF4
.text$x:00007BF4                 mov     edx, [esp+arg_4]
.text$x:00007BF8                 lea     eax, [edx+0Ch]
.text$x:00007BFB                 mov     ecx, [edx-8]
.text$x:00007BFE                 xor     ecx, eax
.text$x:00007C00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007C05                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00007C0A                 jmp     ___CxxFrameHandler3
.text$x:00007C0A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00007C0A
.text$x:00007C0A ; ---------------------------------------------------------------------------
.text$x:00007C0F                 align 10h
.text$x:00007C0F _text$x         ends
.text$x:00007C0F
.text$mn:00007C10 ; ===========================================================================
.text$mn:00007C10
.text$mn:00007C10 ; Segment type: Pure code
.text$mn:00007C10 ; Segment permissions: Read/Execute
.text$mn:00007C10 _text$mn        segment para public 'CODE' use32
.text$mn:00007C10                 assume cs:_text$mn
.text$mn:00007C10                 ;org 7C10h
.text$mn:00007C10 ; COMDAT (pick any)
.text$mn:00007C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C10
.text$mn:00007C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C10
.text$mn:00007C10 ; Attributes: bp-based frame
.text$mn:00007C10
.text$mn:00007C10 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00007C10                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00007C10 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00007C10                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00007C10                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00007C10
.text$mn:00007C10 var_14          = byte ptr -14h
.text$mn:00007C10 var_10          = dword ptr -10h
.text$mn:00007C10 var_C           = dword ptr -0Ch
.text$mn:00007C10 var_4           = dword ptr -4
.text$mn:00007C10
.text$mn:00007C10                 push    ebp
.text$mn:00007C11                 mov     ebp, esp
.text$mn:00007C13                 push    0FFFFFFFFh
.text$mn:00007C15                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00007C1A                 mov     eax, large fs:0
.text$mn:00007C20                 push    eax
.text$mn:00007C21                 sub     esp, 8
.text$mn:00007C24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007C29                 xor     eax, ebp
.text$mn:00007C2B                 push    eax
.text$mn:00007C2C                 lea     eax, [ebp+var_C]
.text$mn:00007C2F                 mov     large fs:0, eax
.text$mn:00007C35                 mov     [ebp+var_10], ecx
.text$mn:00007C38                 push    3               ; int
.text$mn:00007C3A                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007C3D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007C42                 mov     [ebp+var_4], 0
.text$mn:00007C49                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007C4C                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007C51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007C58                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007C5B                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007C60                 mov     ecx, [ebp+var_C]
.text$mn:00007C63                 mov     large fs:0, ecx
.text$mn:00007C6A                 pop     ecx
.text$mn:00007C6B                 mov     esp, ebp
.text$mn:00007C6D                 pop     ebp
.text$mn:00007C6E                 retn
.text$mn:00007C6E ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00007C6E
.text$mn:00007C6E ; ---------------------------------------------------------------------------
.text$mn:00007C6F                 align 10h
.text$mn:00007C6F _text$mn        ends
.text$mn:00007C6F
.text$x:00007C70 ; ===========================================================================
.text$x:00007C70
.text$x:00007C70 ; Segment type: Pure code
.text$x:00007C70 ; Segment permissions: Read/Execute
.text$x:00007C70 _text$x         segment para public 'CODE' use32
.text$x:00007C70                 assume cs:_text$x
.text$x:00007C70                 ;org 7C70h
.text$x:00007C70 ; COMDAT (pick associative to section at 7C10)
.text$x:00007C70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007C70
.text$x:00007C70 ; =============== S U B R O U T I N E =======================================
.text$x:00007C70
.text$x:00007C70
.text$x:00007C70 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00007C70                                         ; DATA XREF: .xdata$x:0000CD1Co
.text$x:00007C70                 lea     ecx, [ebp-14h]  ; this
.text$x:00007C73                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007C73 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00007C73
.text$x:00007C78
.text$x:00007C78 ; =============== S U B R O U T I N E =======================================
.text$x:00007C78
.text$x:00007C78
.text$x:00007C78 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00007C78                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00007C78
.text$x:00007C78 arg_4           = dword ptr  8
.text$x:00007C78
.text$x:00007C78                 mov     edx, [esp+arg_4]
.text$x:00007C7C                 lea     eax, [edx+0Ch]
.text$x:00007C7F                 mov     ecx, [edx-0Ch]
.text$x:00007C82                 xor     ecx, eax
.text$x:00007C84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007C89                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00007C8E                 jmp     ___CxxFrameHandler3
.text$x:00007C8E __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00007C8E
.text$x:00007C8E ; ---------------------------------------------------------------------------
.text$x:00007C93                 align 4
.text$x:00007C93 _text$x         ends
.text$x:00007C93
.text$mn:00007C94 ; ===========================================================================
.text$mn:00007C94
.text$mn:00007C94 ; Segment type: Pure code
.text$mn:00007C94 ; Segment permissions: Read/Execute
.text$mn:00007C94 _text$mn        segment para public 'CODE' use32
.text$mn:00007C94                 assume cs:_text$mn
.text$mn:00007C94                 ;org 7C94h
.text$mn:00007C94 ; COMDAT (pick any)
.text$mn:00007C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C94
.text$mn:00007C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C94
.text$mn:00007C94 ; Attributes: bp-based frame
.text$mn:00007C94
.text$mn:00007C94 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00007C94                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00007C94 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00007C94                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00007C94                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00007C94
.text$mn:00007C94 var_10          = dword ptr -10h
.text$mn:00007C94 var_C           = dword ptr -0Ch
.text$mn:00007C94 var_4           = dword ptr -4
.text$mn:00007C94
.text$mn:00007C94                 push    ebp
.text$mn:00007C95                 mov     ebp, esp
.text$mn:00007C97                 push    0FFFFFFFFh
.text$mn:00007C99                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00007C9E                 mov     eax, large fs:0
.text$mn:00007CA4                 push    eax
.text$mn:00007CA5                 push    ecx
.text$mn:00007CA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007CAB                 xor     eax, ebp
.text$mn:00007CAD                 push    eax
.text$mn:00007CAE                 lea     eax, [ebp+var_C]
.text$mn:00007CB1                 mov     large fs:0, eax
.text$mn:00007CB7                 mov     [ebp+var_10], ecx
.text$mn:00007CBA                 mov     [ebp+var_4], 0
.text$mn:00007CC1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007CC8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007CCB                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007CD0                 mov     ecx, [ebp+var_C]
.text$mn:00007CD3                 mov     large fs:0, ecx
.text$mn:00007CDA                 pop     ecx
.text$mn:00007CDB                 mov     esp, ebp
.text$mn:00007CDD                 pop     ebp
.text$mn:00007CDE                 retn
.text$mn:00007CDE ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00007CDE
.text$mn:00007CDE ; ---------------------------------------------------------------------------
.text$mn:00007CDF                 align 10h
.text$mn:00007CDF _text$mn        ends
.text$mn:00007CDF
.text$x:00007CE0 ; ===========================================================================
.text$x:00007CE0
.text$x:00007CE0 ; Segment type: Pure code
.text$x:00007CE0 ; Segment permissions: Read/Execute
.text$x:00007CE0 _text$x         segment para public 'CODE' use32
.text$x:00007CE0                 assume cs:_text$x
.text$x:00007CE0                 ;org 7CE0h
.text$x:00007CE0 ; COMDAT (pick associative to section at 7C94)
.text$x:00007CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007CE0
.text$x:00007CE0 ; =============== S U B R O U T I N E =======================================
.text$x:00007CE0
.text$x:00007CE0
.text$x:00007CE0 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00007CE0                                         ; DATA XREF: .xdata$x:0000D070o
.text$x:00007CE0                 mov     ecx, [ebp-10h]  ; this
.text$x:00007CE3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007CE3 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00007CE3
.text$x:00007CE8
.text$x:00007CE8 ; =============== S U B R O U T I N E =======================================
.text$x:00007CE8
.text$x:00007CE8
.text$x:00007CE8 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00007CE8                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00007CE8
.text$x:00007CE8 arg_4           = dword ptr  8
.text$x:00007CE8
.text$x:00007CE8                 mov     edx, [esp+arg_4]
.text$x:00007CEC                 lea     eax, [edx+0Ch]
.text$x:00007CEF                 mov     ecx, [edx-8]
.text$x:00007CF2                 xor     ecx, eax
.text$x:00007CF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007CF9                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00007CFE                 jmp     ___CxxFrameHandler3
.text$x:00007CFE __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00007CFE
.text$x:00007CFE ; ---------------------------------------------------------------------------
.text$x:00007D03                 align 4
.text$x:00007D03 _text$x         ends
.text$x:00007D03
.text$mn:00007D04 ; ===========================================================================
.text$mn:00007D04
.text$mn:00007D04 ; Segment type: Pure code
.text$mn:00007D04 ; Segment permissions: Read/Execute
.text$mn:00007D04 _text$mn        segment para public 'CODE' use32
.text$mn:00007D04                 assume cs:_text$mn
.text$mn:00007D04                 ;org 7D04h
.text$mn:00007D04 ; COMDAT (pick any)
.text$mn:00007D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D04
.text$mn:00007D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D04
.text$mn:00007D04 ; Attributes: bp-based frame
.text$mn:00007D04
.text$mn:00007D04 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00007D04                 public ??1error_category@std@@UAE@XZ
.text$mn:00007D04 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00007D04                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00007D04
.text$mn:00007D04 var_4           = dword ptr -4
.text$mn:00007D04
.text$mn:00007D04                 push    ebp
.text$mn:00007D05                 mov     ebp, esp
.text$mn:00007D07                 push    ecx
.text$mn:00007D08                 mov     [ebp+var_4], ecx
.text$mn:00007D0B                 mov     eax, [ebp+var_4]
.text$mn:00007D0E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00007D14                 mov     esp, ebp
.text$mn:00007D16                 pop     ebp
.text$mn:00007D17                 retn
.text$mn:00007D17 ??1error_category@std@@UAE@XZ endp
.text$mn:00007D17
.text$mn:00007D17 _text$mn        ends
.text$mn:00007D17
.text$mn:00007D18 ; ===========================================================================
.text$mn:00007D18
.text$mn:00007D18 ; Segment type: Pure code
.text$mn:00007D18 ; Segment permissions: Read/Execute
.text$mn:00007D18 _text$mn        segment para public 'CODE' use32
.text$mn:00007D18                 assume cs:_text$mn
.text$mn:00007D18                 ;org 7D18h
.text$mn:00007D18 ; COMDAT (pick any)
.text$mn:00007D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D18
.text$mn:00007D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D18
.text$mn:00007D18 ; Attributes: bp-based frame
.text$mn:00007D18
.text$mn:00007D18 ; _DWORD __thiscall recordedMacroStep::~recordedMacroStep(recordedMacroStep *__hidden this)
.text$mn:00007D18                 public ??1recordedMacroStep@@QAE@XZ
.text$mn:00007D18 ??1recordedMacroStep@@QAE@XZ proc near  ; CODE XREF: recordedMacroStep::`scalar deleting destructor'(uint)+Ap
.text$mn:00007D18
.text$mn:00007D18 var_10          = dword ptr -10h
.text$mn:00007D18 var_C           = dword ptr -0Ch
.text$mn:00007D18 var_4           = dword ptr -4
.text$mn:00007D18
.text$mn:00007D18                 push    ebp
.text$mn:00007D19                 mov     ebp, esp
.text$mn:00007D1B                 push    0FFFFFFFFh
.text$mn:00007D1D                 push    offset __ehhandler$??1recordedMacroStep@@QAE@XZ
.text$mn:00007D22                 mov     eax, large fs:0
.text$mn:00007D28                 push    eax
.text$mn:00007D29                 push    ecx
.text$mn:00007D2A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007D2F                 xor     eax, ebp
.text$mn:00007D31                 push    eax
.text$mn:00007D32                 lea     eax, [ebp+var_C]
.text$mn:00007D35                 mov     large fs:0, eax
.text$mn:00007D3B                 mov     [ebp+var_10], ecx
.text$mn:00007D3E                 mov     [ebp+var_4], 0
.text$mn:00007D45                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007D4C                 mov     ecx, [ebp+var_10]
.text$mn:00007D4F                 add     ecx, 0Ch
.text$mn:00007D52                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00007D57                 mov     ecx, [ebp+var_C]
.text$mn:00007D5A                 mov     large fs:0, ecx
.text$mn:00007D61                 pop     ecx
.text$mn:00007D62                 mov     esp, ebp
.text$mn:00007D64                 pop     ebp
.text$mn:00007D65                 retn
.text$mn:00007D65 ??1recordedMacroStep@@QAE@XZ endp
.text$mn:00007D65
.text$mn:00007D65 ; ---------------------------------------------------------------------------
.text$mn:00007D66                 align 4
.text$mn:00007D66 _text$mn        ends
.text$mn:00007D66
.text$x:00007D68 ; ===========================================================================
.text$x:00007D68
.text$x:00007D68 ; Segment type: Pure code
.text$x:00007D68 ; Segment permissions: Read/Execute
.text$x:00007D68 _text$x         segment para public 'CODE' use32
.text$x:00007D68                 assume cs:_text$x
.text$x:00007D68                 ;org 7D68h
.text$x:00007D68 ; COMDAT (pick associative to section at 7D18)
.text$x:00007D68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007D68
.text$x:00007D68 ; =============== S U B R O U T I N E =======================================
.text$x:00007D68
.text$x:00007D68
.text$x:00007D68 __unwindfunclet$??1recordedMacroStep@@QAE@XZ$0 proc near
.text$x:00007D68                                         ; DATA XREF: .xdata$x:0000D64Co
.text$x:00007D68                 mov     ecx, [ebp-10h]
.text$x:00007D6B                 add     ecx, 0Ch
.text$x:00007D6E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00007D6E __unwindfunclet$??1recordedMacroStep@@QAE@XZ$0 endp
.text$x:00007D6E
.text$x:00007D73
.text$x:00007D73 ; =============== S U B R O U T I N E =======================================
.text$x:00007D73
.text$x:00007D73
.text$x:00007D73 __ehhandler$??1recordedMacroStep@@QAE@XZ proc near
.text$x:00007D73                                         ; DATA XREF: recordedMacroStep::~recordedMacroStep(void)+5o
.text$x:00007D73
.text$x:00007D73 arg_4           = dword ptr  8
.text$x:00007D73
.text$x:00007D73                 mov     edx, [esp+arg_4]
.text$x:00007D77                 lea     eax, [edx+0Ch]
.text$x:00007D7A                 mov     ecx, [edx-8]
.text$x:00007D7D                 xor     ecx, eax
.text$x:00007D7F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007D84                 mov     eax, offset __ehfuncinfo$??1recordedMacroStep@@QAE@XZ
.text$x:00007D89                 jmp     ___CxxFrameHandler3
.text$x:00007D89 __ehhandler$??1recordedMacroStep@@QAE@XZ endp
.text$x:00007D89
.text$x:00007D89 ; ---------------------------------------------------------------------------
.text$x:00007D8E                 align 10h
.text$x:00007D8E _text$x         ends
.text$x:00007D8E
.text$mn:00007D90 ; ===========================================================================
.text$mn:00007D90
.text$mn:00007D90 ; Segment type: Pure code
.text$mn:00007D90 ; Segment permissions: Read/Execute
.text$mn:00007D90 _text$mn        segment para public 'CODE' use32
.text$mn:00007D90                 assume cs:_text$mn
.text$mn:00007D90                 ;org 7D90h
.text$mn:00007D90 ; COMDAT (pick any)
.text$mn:00007D90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D90
.text$mn:00007D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D90
.text$mn:00007D90 ; Attributes: bp-based frame
.text$mn:00007D90
.text$mn:00007D90 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00007D90                 public ??2@YAPAXIPAX@Z
.text$mn:00007D90 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00007D90                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00007D90
.text$mn:00007D90 arg_4           = dword ptr  0Ch
.text$mn:00007D90
.text$mn:00007D90                 push    ebp
.text$mn:00007D91                 mov     ebp, esp
.text$mn:00007D93                 mov     eax, [ebp+arg_4]
.text$mn:00007D96                 pop     ebp
.text$mn:00007D97                 retn
.text$mn:00007D97 ??2@YAPAXIPAX@Z endp
.text$mn:00007D97
.text$mn:00007D97 _text$mn        ends
.text$mn:00007D97
.text$mn:00007D98 ; ===========================================================================
.text$mn:00007D98
.text$mn:00007D98 ; Segment type: Pure code
.text$mn:00007D98 ; Segment permissions: Read/Execute
.text$mn:00007D98 _text$mn        segment para public 'CODE' use32
.text$mn:00007D98                 assume cs:_text$mn
.text$mn:00007D98                 ;org 7D98h
.text$mn:00007D98 ; COMDAT (pick any)
.text$mn:00007D98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D98
.text$mn:00007D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D98
.text$mn:00007D98 ; Attributes: bp-based frame
.text$mn:00007D98
.text$mn:00007D98 ; void __cdecl operator delete(void *)
.text$mn:00007D98                 public ??3@YAXPAX0@Z
.text$mn:00007D98 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00007D98                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00007D98                 push    ebp
.text$mn:00007D99                 mov     ebp, esp
.text$mn:00007D9B                 pop     ebp
.text$mn:00007D9C                 retn
.text$mn:00007D9C ??3@YAXPAX0@Z   endp
.text$mn:00007D9C
.text$mn:00007D9C ; ---------------------------------------------------------------------------
.text$mn:00007D9D                 align 10h
.text$mn:00007D9D _text$mn        ends
.text$mn:00007D9D
.text$mn:00007DA0 ; ===========================================================================
.text$mn:00007DA0
.text$mn:00007DA0 ; Segment type: Pure code
.text$mn:00007DA0 ; Segment permissions: Read/Execute
.text$mn:00007DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00007DA0                 assume cs:_text$mn
.text$mn:00007DA0                 ;org 7DA0h
.text$mn:00007DA0 ; COMDAT (pick any)
.text$mn:00007DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DA0
.text$mn:00007DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DA0
.text$mn:00007DA0 ; Attributes: bp-based frame
.text$mn:00007DA0
.text$mn:00007DA0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00007DA0                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:00007DA0 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00007DA0                                         ; CODE XREF: PluginCmdShortcut::operator=(PluginCmdShortcut const &)+38p
.text$mn:00007DA0                                         ; UserCommand::operator=(UserCommand const &)+26p ...
.text$mn:00007DA0
.text$mn:00007DA0 var_8           = dword ptr -8
.text$mn:00007DA0 var_3           = byte ptr -3
.text$mn:00007DA0 var_2           = byte ptr -2
.text$mn:00007DA0 var_1           = byte ptr -1
.text$mn:00007DA0 arg_0           = dword ptr  8
.text$mn:00007DA0
.text$mn:00007DA0                 push    ebp
.text$mn:00007DA1                 mov     ebp, esp
.text$mn:00007DA3                 sub     esp, 8
.text$mn:00007DA6                 mov     [ebp+var_8], ecx
.text$mn:00007DA9                 mov     eax, [ebp+var_8]
.text$mn:00007DAC                 cmp     eax, [ebp+arg_0]
.text$mn:00007DAF                 jz      short loc_7E0B
.text$mn:00007DB1                 lea     ecx, [ebp+var_1]
.text$mn:00007DB4                 push    ecx
.text$mn:00007DB5                 mov     ecx, [ebp+arg_0]
.text$mn:00007DB8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007DBD                 push    eax
.text$mn:00007DBE                 lea     edx, [ebp+var_2]
.text$mn:00007DC1                 push    edx
.text$mn:00007DC2                 mov     ecx, [ebp+var_8]
.text$mn:00007DC5                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007DCA                 push    eax
.text$mn:00007DCB                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00007DD0                 add     esp, 8
.text$mn:00007DD3                 movzx   eax, al
.text$mn:00007DD6                 test    eax, eax
.text$mn:00007DD8                 jz      short loc_7DFF
.text$mn:00007DDA                 xor     ecx, ecx
.text$mn:00007DDC                 jz      short loc_7DFF
.text$mn:00007DDE                 push    0
.text$mn:00007DE0                 push    1
.text$mn:00007DE2                 mov     ecx, [ebp+var_8]
.text$mn:00007DE5                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007DEA                 lea     edx, [ebp+var_3]
.text$mn:00007DED                 push    edx
.text$mn:00007DEE                 mov     ecx, [ebp+arg_0]
.text$mn:00007DF1                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007DF6                 push    eax
.text$mn:00007DF7                 mov     ecx, [ebp+var_8]
.text$mn:00007DFA                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00007DFF
.text$mn:00007DFF loc_7DFF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+38j
.text$mn:00007DFF                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Cj
.text$mn:00007DFF                 mov     eax, [ebp+arg_0]
.text$mn:00007E02                 push    eax
.text$mn:00007E03                 mov     ecx, [ebp+var_8]
.text$mn:00007E06                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00007E0B
.text$mn:00007E0B loc_7E0B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Fj
.text$mn:00007E0B                 mov     eax, [ebp+var_8]
.text$mn:00007E0E                 mov     esp, ebp
.text$mn:00007E10                 pop     ebp
.text$mn:00007E11                 retn    4
.text$mn:00007E11 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00007E11
.text$mn:00007E11 _text$mn        ends
.text$mn:00007E11
.text$mn:00007E14 ; ===========================================================================
.text$mn:00007E14
.text$mn:00007E14 ; Segment type: Pure code
.text$mn:00007E14 ; Segment permissions: Read/Execute
.text$mn:00007E14 _text$mn        segment para public 'CODE' use32
.text$mn:00007E14                 assume cs:_text$mn
.text$mn:00007E14                 ;org 7E14h
.text$mn:00007E14 ; COMDAT (pick any)
.text$mn:00007E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E14
.text$mn:00007E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E14
.text$mn:00007E14 ; Attributes: bp-based frame
.text$mn:00007E14
.text$mn:00007E14 ; public: class std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>> & __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::operator=(class std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>> const &)
.text$mn:00007E14                 public ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00007E14 ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00007E14                                         ; CODE XREF: ScintillaKeyMap::operator=(ScintillaKeyMap const &)+4Ap
.text$mn:00007E14
.text$mn:00007E14 var_20          = dword ptr -20h
.text$mn:00007E14 var_1C          = dword ptr -1Ch
.text$mn:00007E14 var_18          = dword ptr -18h
.text$mn:00007E14 var_14          = byte ptr -14h
.text$mn:00007E14 var_13          = byte ptr -13h
.text$mn:00007E14 var_12          = byte ptr -12h
.text$mn:00007E14 var_11          = byte ptr -11h
.text$mn:00007E14 var_10          = dword ptr -10h
.text$mn:00007E14 var_C           = dword ptr -0Ch
.text$mn:00007E14 var_4           = dword ptr -4
.text$mn:00007E14 arg_0           = dword ptr  8
.text$mn:00007E14
.text$mn:00007E14 ; FUNCTION CHUNK AT .text$mn:0000802F SIZE 00000009 BYTES
.text$mn:00007E14 ; FUNCTION CHUNK AT .text$mn:0000803F SIZE 00000017 BYTES
.text$mn:00007E14
.text$mn:00007E14                 push    ebp
.text$mn:00007E15                 mov     ebp, esp
.text$mn:00007E17                 push    0FFFFFFFFh
.text$mn:00007E19                 push    offset __ehhandler$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00007E1E                 mov     eax, large fs:0
.text$mn:00007E24                 push    eax
.text$mn:00007E25                 push    ecx
.text$mn:00007E26                 sub     esp, 10h
.text$mn:00007E29                 push    ebx
.text$mn:00007E2A                 push    esi
.text$mn:00007E2B                 push    edi
.text$mn:00007E2C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007E31                 xor     eax, ebp
.text$mn:00007E33                 push    eax
.text$mn:00007E34                 lea     eax, [ebp+var_C]
.text$mn:00007E37                 mov     large fs:0, eax
.text$mn:00007E3D                 mov     [ebp+var_10], esp
.text$mn:00007E40                 mov     [ebp+var_18], ecx
.text$mn:00007E43                 mov     eax, [ebp+var_18]
.text$mn:00007E46                 cmp     eax, [ebp+arg_0]
.text$mn:00007E49                 jz      loc_803F
.text$mn:00007E4F                 lea     ecx, [ebp+var_11]
.text$mn:00007E52                 push    ecx
.text$mn:00007E53                 mov     ecx, [ebp+arg_0]
.text$mn:00007E56                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:00007E5B                 push    eax
.text$mn:00007E5C                 lea     edx, [ebp+var_12]
.text$mn:00007E5F                 push    edx
.text$mn:00007E60                 mov     ecx, [ebp+var_18]
.text$mn:00007E63                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:00007E68                 push    eax
.text$mn:00007E69                 call    ??$?9V?$allocator@UKeyCombo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@0@Z ; std::operator!=<std::allocator<KeyCombo>,std::allocator<KeyCombo>>(std::_Wrap_alloc<std::allocator<KeyCombo>> const &,std::_Wrap_alloc<std::allocator<KeyCombo>> const &)
.text$mn:00007E6E                 add     esp, 8
.text$mn:00007E71                 movzx   eax, al
.text$mn:00007E74                 test    eax, eax
.text$mn:00007E76                 jz      short loc_7E99
.text$mn:00007E78                 xor     ecx, ecx
.text$mn:00007E7A                 jz      short loc_7E99
.text$mn:00007E7C                 mov     ecx, [ebp+var_18]
.text$mn:00007E7F                 call    ?_Tidy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Tidy(void)
.text$mn:00007E84                 lea     edx, [ebp+var_13]
.text$mn:00007E87                 push    edx
.text$mn:00007E88                 mov     ecx, [ebp+arg_0]
.text$mn:00007E8B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:00007E90                 push    eax
.text$mn:00007E91                 mov     ecx, [ebp+var_18]
.text$mn:00007E94                 call    ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<KeyCombo>> const &)
.text$mn:00007E99
.text$mn:00007E99 loc_7E99:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+62j
.text$mn:00007E99                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+66j
.text$mn:00007E99                 mov     ecx, [ebp+var_18] ; this
.text$mn:00007E9C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007EA1                 mov     ecx, [ebp+arg_0]
.text$mn:00007EA4                 call    ?empty@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE_NXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::empty(void)
.text$mn:00007EA9                 movzx   eax, al
.text$mn:00007EAC                 test    eax, eax
.text$mn:00007EAE                 jz      short loc_7EBD
.text$mn:00007EB0                 mov     ecx, [ebp+var_18]
.text$mn:00007EB3                 call    ?clear@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEXXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::clear(void)
.text$mn:00007EB8                 jmp     loc_803F
.text$mn:00007EBD ; ---------------------------------------------------------------------------
.text$mn:00007EBD
.text$mn:00007EBD loc_7EBD:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+9Aj
.text$mn:00007EBD                 mov     ecx, [ebp+arg_0]
.text$mn:00007EC0                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00007EC5                 mov     esi, eax
.text$mn:00007EC7                 mov     ecx, [ebp+var_18]
.text$mn:00007ECA                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00007ECF                 cmp     esi, eax
.text$mn:00007ED1                 ja      short loc_7F22
.text$mn:00007ED3                 mov     ecx, [ebp+var_18]
.text$mn:00007ED6                 mov     edx, [ecx+4]
.text$mn:00007ED9                 push    edx
.text$mn:00007EDA                 mov     eax, [ebp+arg_0]
.text$mn:00007EDD                 mov     ecx, [eax+8]
.text$mn:00007EE0                 push    ecx
.text$mn:00007EE1                 mov     edx, [ebp+arg_0]
.text$mn:00007EE4                 mov     eax, [edx+4]
.text$mn:00007EE7                 push    eax
.text$mn:00007EE8                 call    ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00@Z ; std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)
.text$mn:00007EED                 add     esp, 0Ch
.text$mn:00007EF0                 mov     [ebp+var_20], eax
.text$mn:00007EF3                 mov     ecx, [ebp+var_18]
.text$mn:00007EF6                 mov     edx, [ecx+8]
.text$mn:00007EF9                 push    edx
.text$mn:00007EFA                 mov     eax, [ebp+var_20]
.text$mn:00007EFD                 push    eax
.text$mn:00007EFE                 mov     ecx, [ebp+var_18]
.text$mn:00007F01                 call    ?_Destroy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXPAUKeyCombo@@0@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Destroy(KeyCombo *,KeyCombo *)
.text$mn:00007F06                 mov     ecx, [ebp+arg_0]
.text$mn:00007F09                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00007F0E                 mov     ecx, [ebp+var_18]
.text$mn:00007F11                 mov     edx, [ecx+4]
.text$mn:00007F14                 lea     eax, [edx+eax*4]
.text$mn:00007F17                 mov     ecx, [ebp+var_18]
.text$mn:00007F1A                 mov     [ecx+8], eax
.text$mn:00007F1D                 jmp     loc_803F
.text$mn:00007F22 ; ---------------------------------------------------------------------------
.text$mn:00007F22
.text$mn:00007F22 loc_7F22:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+BDj
.text$mn:00007F22                 mov     ecx, [ebp+arg_0]
.text$mn:00007F25                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00007F2A                 mov     esi, eax
.text$mn:00007F2C                 mov     ecx, [ebp+var_18]
.text$mn:00007F2F                 call    ?capacity@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::capacity(void)
.text$mn:00007F34                 cmp     esi, eax
.text$mn:00007F36                 ja      short loc_7F8B
.text$mn:00007F38                 mov     ecx, [ebp+var_18]
.text$mn:00007F3B                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00007F40                 mov     edx, [ebp+arg_0]
.text$mn:00007F43                 mov     ecx, [edx+4]
.text$mn:00007F46                 lea     edx, [ecx+eax*4]
.text$mn:00007F49                 mov     [ebp+var_1C], edx
.text$mn:00007F4C                 mov     eax, [ebp+var_18]
.text$mn:00007F4F                 mov     ecx, [eax+4]
.text$mn:00007F52                 push    ecx
.text$mn:00007F53                 mov     edx, [ebp+var_1C]
.text$mn:00007F56                 push    edx
.text$mn:00007F57                 mov     eax, [ebp+arg_0]
.text$mn:00007F5A                 mov     ecx, [eax+4]
.text$mn:00007F5D                 push    ecx
.text$mn:00007F5E                 call    ??$_Copy_impl@PAUKeyCombo@@PAU1@@std@@YAPAUKeyCombo@@PAU1@00@Z ; std::_Copy_impl<KeyCombo *,KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)
.text$mn:00007F63                 add     esp, 0Ch
.text$mn:00007F66                 mov     edx, [ebp+var_18]
.text$mn:00007F69                 mov     eax, [edx+8]
.text$mn:00007F6C                 push    eax
.text$mn:00007F6D                 mov     ecx, [ebp+arg_0]
.text$mn:00007F70                 mov     edx, [ecx+8]
.text$mn:00007F73                 push    edx
.text$mn:00007F74                 mov     eax, [ebp+var_1C]
.text$mn:00007F77                 push    eax
.text$mn:00007F78                 mov     ecx, [ebp+var_18]
.text$mn:00007F7B                 call    ??$_Ucopy@PAUKeyCombo@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@PAU2@00@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)
.text$mn:00007F80                 mov     ecx, [ebp+var_18]
.text$mn:00007F83                 mov     [ecx+8], eax
.text$mn:00007F86                 jmp     loc_803F
.text$mn:00007F8B ; ---------------------------------------------------------------------------
.text$mn:00007F8B
.text$mn:00007F8B loc_7F8B:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+122j
.text$mn:00007F8B                 mov     edx, [ebp+var_18]
.text$mn:00007F8E                 cmp     dword ptr [edx+4], 0
.text$mn:00007F92                 jz      short loc_7FD4
.text$mn:00007F94                 mov     eax, [ebp+var_18]
.text$mn:00007F97                 mov     ecx, [eax+8]
.text$mn:00007F9A                 push    ecx
.text$mn:00007F9B                 mov     edx, [ebp+var_18]
.text$mn:00007F9E                 mov     eax, [edx+4]
.text$mn:00007FA1                 push    eax
.text$mn:00007FA2                 mov     ecx, [ebp+var_18]
.text$mn:00007FA5                 call    ?_Destroy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXPAUKeyCombo@@0@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Destroy(KeyCombo *,KeyCombo *)
.text$mn:00007FAA                 mov     ecx, [ebp+var_18]
.text$mn:00007FAD                 mov     edx, [ebp+var_18]
.text$mn:00007FB0                 mov     eax, [ecx+0Ch]
.text$mn:00007FB3                 sub     eax, [edx+4]
.text$mn:00007FB6                 sar     eax, 2
.text$mn:00007FB9                 push    eax             ; int
.text$mn:00007FBA                 mov     ecx, [ebp+var_18]
.text$mn:00007FBD                 mov     edx, [ecx+4]
.text$mn:00007FC0                 push    edx             ; void *
.text$mn:00007FC1                 lea     eax, [ebp+var_14]
.text$mn:00007FC4                 push    eax
.text$mn:00007FC5                 mov     ecx, [ebp+var_18]
.text$mn:00007FC8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:00007FCD                 mov     ecx, eax
.text$mn:00007FCF                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@I@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::deallocate(KeyCombo *,uint)
.text$mn:00007FD4
.text$mn:00007FD4 loc_7FD4:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+17Ej
.text$mn:00007FD4                 mov     ecx, [ebp+arg_0]
.text$mn:00007FD7                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00007FDC                 push    eax
.text$mn:00007FDD                 mov     ecx, [ebp+var_18]
.text$mn:00007FE0                 call    ?_Buy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAE_NI@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)
.text$mn:00007FE5                 movzx   ecx, al
.text$mn:00007FE8                 test    ecx, ecx
.text$mn:00007FEA                 jz      short loc_803F
.text$mn:00007FEC                 mov     [ebp+var_4], 0
.text$mn:00007FF3                 mov     edx, [ebp+var_18]
.text$mn:00007FF6                 mov     eax, [edx+4]
.text$mn:00007FF9                 push    eax
.text$mn:00007FFA                 mov     ecx, [ebp+arg_0]
.text$mn:00007FFD                 mov     edx, [ecx+8]
.text$mn:00008000                 push    edx
.text$mn:00008001                 mov     eax, [ebp+arg_0]
.text$mn:00008004                 mov     ecx, [eax+4]
.text$mn:00008007                 push    ecx
.text$mn:00008008                 mov     ecx, [ebp+var_18]
.text$mn:0000800B                 call    ??$_Ucopy@PAUKeyCombo@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@PAU2@00@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)
.text$mn:00008010                 mov     edx, [ebp+var_18]
.text$mn:00008013                 mov     [edx+8], eax
.text$mn:00008016                 jmp     short loc_802F
.text$mn:00008016 ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00008016
.text$mn:00008018
.text$mn:00008018 ; =============== S U B R O U T I N E =======================================
.text$mn:00008018
.text$mn:00008018 ; Attributes: noreturn
.text$mn:00008018
.text$mn:00008018 __catch$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z$0 proc near
.text$mn:00008018                                         ; DATA XREF: .xdata$x:0000D434o
.text$mn:00008018                 mov     ecx, [ebp-18h]
.text$mn:0000801B                 call    ?_Tidy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Tidy(void)
.text$mn:00008020                 push    0
.text$mn:00008022                 push    0
.text$mn:00008024                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008024 __catch$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z$0 endp
.text$mn:00008024
.text$mn:00008029 ; ---------------------------------------------------------------------------
.text$mn:00008029                 mov     eax, offset $LN17_1
.text$mn:0000802E                 retn
.text$mn:0000802F ; ---------------------------------------------------------------------------
.text$mn:0000802F ; START OF FUNCTION CHUNK FOR ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000802F
.text$mn:0000802F loc_802F:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+202j
.text$mn:0000802F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008036                 jmp     short loc_803F
.text$mn:00008036 ; END OF FUNCTION CHUNK FOR ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00008038
.text$mn:00008038 ; =============== S U B R O U T I N E =======================================
.text$mn:00008038
.text$mn:00008038
.text$mn:00008038 $LN17_1         proc near               ; DATA XREF: .text$mn:00008029o
.text$mn:00008038                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00008038 $LN17_1         endp ; sp-analysis failed
.text$mn:00008038
.text$mn:0000803F ; START OF FUNCTION CHUNK FOR ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000803F
.text$mn:0000803F loc_803F:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+35j
.text$mn:0000803F                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+A4j ...
.text$mn:0000803F                 mov     eax, [ebp+var_18]
.text$mn:00008042                 mov     ecx, [ebp+var_C]
.text$mn:00008045                 mov     large fs:0, ecx
.text$mn:0000804C                 pop     ecx
.text$mn:0000804D                 pop     edi
.text$mn:0000804E                 pop     esi
.text$mn:0000804F                 pop     ebx
.text$mn:00008050                 mov     esp, ebp
.text$mn:00008052                 pop     ebp
.text$mn:00008053                 retn    4
.text$mn:00008053 ; END OF FUNCTION CHUNK FOR ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00008053 ; ---------------------------------------------------------------------------
.text$mn:00008056                 align 4
.text$mn:00008056 _text$mn        ends
.text$mn:00008056
.text$x:00008058 ; ===========================================================================
.text$x:00008058
.text$x:00008058 ; Segment type: Pure code
.text$x:00008058 ; Segment permissions: Read/Execute
.text$x:00008058 _text$x         segment para public 'CODE' use32
.text$x:00008058                 assume cs:_text$x
.text$x:00008058                 ;org 8058h
.text$x:00008058 ; COMDAT (pick associative to section at 7E14)
.text$x:00008058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008058
.text$x:00008058 ; =============== S U B R O U T I N E =======================================
.text$x:00008058
.text$x:00008058
.text$x:00008058 __ehhandler$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$x:00008058                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+5o
.text$x:00008058
.text$x:00008058 arg_4           = dword ptr  8
.text$x:00008058
.text$x:00008058                 mov     edx, [esp+arg_4]
.text$x:0000805C                 lea     eax, [edx+0Ch]
.text$x:0000805F                 mov     ecx, [edx-24h]
.text$x:00008062                 xor     ecx, eax
.text$x:00008064                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008069                 mov     eax, offset __ehfuncinfo$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$x:0000806E                 jmp     ___CxxFrameHandler3
.text$x:0000806E __ehhandler$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$x:0000806E
.text$x:0000806E ; ---------------------------------------------------------------------------
.text$x:00008073                 align 4
.text$x:00008073 _text$x         ends
.text$x:00008073
.text$mn:00008074 ; ===========================================================================
.text$mn:00008074
.text$mn:00008074 ; Segment type: Pure code
.text$mn:00008074 ; Segment permissions: Read/Execute
.text$mn:00008074 _text$mn        segment para public 'CODE' use32
.text$mn:00008074                 assume cs:_text$mn
.text$mn:00008074                 ;org 8074h
.text$mn:00008074 ; COMDAT (pick any)
.text$mn:00008074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008074
.text$mn:00008074 ; =============== S U B R O U T I N E =======================================
.text$mn:00008074
.text$mn:00008074 ; Attributes: bp-based frame
.text$mn:00008074
.text$mn:00008074 ; public: class std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>> & __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::operator=(class std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>> const &)
.text$mn:00008074                 public ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00008074 ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00008074                                         ; CODE XREF: MacroShortcut::operator=(MacroShortcut const &)+26p
.text$mn:00008074
.text$mn:00008074 var_20          = dword ptr -20h
.text$mn:00008074 var_1C          = dword ptr -1Ch
.text$mn:00008074 var_18          = dword ptr -18h
.text$mn:00008074 var_14          = byte ptr -14h
.text$mn:00008074 var_13          = byte ptr -13h
.text$mn:00008074 var_12          = byte ptr -12h
.text$mn:00008074 var_11          = byte ptr -11h
.text$mn:00008074 var_10          = dword ptr -10h
.text$mn:00008074 var_C           = dword ptr -0Ch
.text$mn:00008074 var_4           = dword ptr -4
.text$mn:00008074 arg_0           = dword ptr  8
.text$mn:00008074
.text$mn:00008074 ; FUNCTION CHUNK AT .text$mn:00008294 SIZE 00000009 BYTES
.text$mn:00008074 ; FUNCTION CHUNK AT .text$mn:000082A4 SIZE 00000017 BYTES
.text$mn:00008074
.text$mn:00008074                 push    ebp
.text$mn:00008075                 mov     ebp, esp
.text$mn:00008077                 push    0FFFFFFFFh
.text$mn:00008079                 push    offset __ehhandler$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000807E                 mov     eax, large fs:0
.text$mn:00008084                 push    eax
.text$mn:00008085                 push    ecx
.text$mn:00008086                 sub     esp, 10h
.text$mn:00008089                 push    ebx
.text$mn:0000808A                 push    esi
.text$mn:0000808B                 push    edi
.text$mn:0000808C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008091                 xor     eax, ebp
.text$mn:00008093                 push    eax
.text$mn:00008094                 lea     eax, [ebp+var_C]
.text$mn:00008097                 mov     large fs:0, eax
.text$mn:0000809D                 mov     [ebp+var_10], esp
.text$mn:000080A0                 mov     [ebp+var_18], ecx
.text$mn:000080A3                 mov     eax, [ebp+var_18]
.text$mn:000080A6                 cmp     eax, [ebp+arg_0]
.text$mn:000080A9                 jz      loc_82A4
.text$mn:000080AF                 lea     ecx, [ebp+var_11]
.text$mn:000080B2                 push    ecx
.text$mn:000080B3                 mov     ecx, [ebp+arg_0]
.text$mn:000080B6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:000080BB                 push    eax
.text$mn:000080BC                 lea     edx, [ebp+var_12]
.text$mn:000080BF                 push    edx
.text$mn:000080C0                 mov     ecx, [ebp+var_18]
.text$mn:000080C3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:000080C8                 push    eax
.text$mn:000080C9                 call    ??$?9V?$allocator@UrecordedMacroStep@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0@Z ; std::operator!=<std::allocator<recordedMacroStep>,std::allocator<recordedMacroStep>>(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &,std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)
.text$mn:000080CE                 add     esp, 8
.text$mn:000080D1                 movzx   eax, al
.text$mn:000080D4                 test    eax, eax
.text$mn:000080D6                 jz      short loc_80F9
.text$mn:000080D8                 xor     ecx, ecx
.text$mn:000080DA                 jz      short loc_80F9
.text$mn:000080DC                 mov     ecx, [ebp+var_18]
.text$mn:000080DF                 call    ?_Tidy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Tidy(void)
.text$mn:000080E4                 lea     edx, [ebp+var_13]
.text$mn:000080E7                 push    edx
.text$mn:000080E8                 mov     ecx, [ebp+arg_0]
.text$mn:000080EB                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:000080F0                 push    eax
.text$mn:000080F1                 mov     ecx, [ebp+var_18]
.text$mn:000080F4                 call    ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<recordedMacroStep>> const &)
.text$mn:000080F9
.text$mn:000080F9 loc_80F9:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+62j
.text$mn:000080F9                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+66j
.text$mn:000080F9                 mov     ecx, [ebp+var_18] ; this
.text$mn:000080FC                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00008101                 mov     ecx, [ebp+arg_0]
.text$mn:00008104                 call    ?empty@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE_NXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::empty(void)
.text$mn:00008109                 movzx   eax, al
.text$mn:0000810C                 test    eax, eax
.text$mn:0000810E                 jz      short loc_811D
.text$mn:00008110                 mov     ecx, [ebp+var_18]
.text$mn:00008113                 call    ?clear@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::clear(void)
.text$mn:00008118                 jmp     loc_82A4
.text$mn:0000811D ; ---------------------------------------------------------------------------
.text$mn:0000811D
.text$mn:0000811D loc_811D:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+9Aj
.text$mn:0000811D                 mov     ecx, [ebp+arg_0]
.text$mn:00008120                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:00008125                 mov     esi, eax
.text$mn:00008127                 mov     ecx, [ebp+var_18]
.text$mn:0000812A                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:0000812F                 cmp     esi, eax
.text$mn:00008131                 ja      short loc_8182
.text$mn:00008133                 mov     ecx, [ebp+var_18]
.text$mn:00008136                 mov     edx, [ecx+4]
.text$mn:00008139                 push    edx
.text$mn:0000813A                 mov     eax, [ebp+arg_0]
.text$mn:0000813D                 mov     ecx, [eax+8]
.text$mn:00008140                 push    ecx
.text$mn:00008141                 mov     edx, [ebp+arg_0]
.text$mn:00008144                 mov     eax, [edx+4]
.text$mn:00008147                 push    eax
.text$mn:00008148                 call    ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00@Z ; std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)
.text$mn:0000814D                 add     esp, 0Ch
.text$mn:00008150                 mov     [ebp+var_20], eax
.text$mn:00008153                 mov     ecx, [ebp+var_18]
.text$mn:00008156                 mov     edx, [ecx+8]
.text$mn:00008159                 push    edx
.text$mn:0000815A                 mov     eax, [ebp+var_20]
.text$mn:0000815D                 push    eax
.text$mn:0000815E                 mov     ecx, [ebp+var_18]
.text$mn:00008161                 call    ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)
.text$mn:00008166                 mov     ecx, [ebp+arg_0]
.text$mn:00008169                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:0000816E                 imul    ecx, eax, 2Ch
.text$mn:00008171                 mov     edx, [ebp+var_18]
.text$mn:00008174                 add     ecx, [edx+4]
.text$mn:00008177                 mov     eax, [ebp+var_18]
.text$mn:0000817A                 mov     [eax+8], ecx
.text$mn:0000817D                 jmp     loc_82A4
.text$mn:00008182 ; ---------------------------------------------------------------------------
.text$mn:00008182
.text$mn:00008182 loc_8182:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+BDj
.text$mn:00008182                 mov     ecx, [ebp+arg_0]
.text$mn:00008185                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:0000818A                 mov     esi, eax
.text$mn:0000818C                 mov     ecx, [ebp+var_18]
.text$mn:0000818F                 call    ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::capacity(void)
.text$mn:00008194                 cmp     esi, eax
.text$mn:00008196                 ja      short loc_81EB
.text$mn:00008198                 mov     ecx, [ebp+var_18]
.text$mn:0000819B                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:000081A0                 imul    ecx, eax, 2Ch
.text$mn:000081A3                 mov     edx, [ebp+arg_0]
.text$mn:000081A6                 add     ecx, [edx+4]
.text$mn:000081A9                 mov     [ebp+var_1C], ecx
.text$mn:000081AC                 mov     eax, [ebp+var_18]
.text$mn:000081AF                 mov     ecx, [eax+4]
.text$mn:000081B2                 push    ecx
.text$mn:000081B3                 mov     edx, [ebp+var_1C]
.text$mn:000081B6                 push    edx
.text$mn:000081B7                 mov     eax, [ebp+arg_0]
.text$mn:000081BA                 mov     ecx, [eax+4]
.text$mn:000081BD                 push    ecx
.text$mn:000081BE                 call    ??$_Copy_impl@PAUrecordedMacroStep@@PAU1@@std@@YAPAUrecordedMacroStep@@PAU1@00@Z ; std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)
.text$mn:000081C3                 add     esp, 0Ch
.text$mn:000081C6                 mov     edx, [ebp+var_18]
.text$mn:000081C9                 mov     eax, [edx+8]
.text$mn:000081CC                 push    eax
.text$mn:000081CD                 mov     ecx, [ebp+arg_0]
.text$mn:000081D0                 mov     edx, [ecx+8]
.text$mn:000081D3                 push    edx
.text$mn:000081D4                 mov     eax, [ebp+var_1C]
.text$mn:000081D7                 push    eax
.text$mn:000081D8                 mov     ecx, [ebp+var_18]
.text$mn:000081DB                 call    ??$_Ucopy@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)
.text$mn:000081E0                 mov     ecx, [ebp+var_18]
.text$mn:000081E3                 mov     [ecx+8], eax
.text$mn:000081E6                 jmp     loc_82A4
.text$mn:000081EB ; ---------------------------------------------------------------------------
.text$mn:000081EB
.text$mn:000081EB loc_81EB:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+122j
.text$mn:000081EB                 mov     edx, [ebp+var_18]
.text$mn:000081EE                 cmp     dword ptr [edx+4], 0
.text$mn:000081F2                 jz      short loc_8239
.text$mn:000081F4                 mov     eax, [ebp+var_18]
.text$mn:000081F7                 mov     ecx, [eax+8]
.text$mn:000081FA                 push    ecx
.text$mn:000081FB                 mov     edx, [ebp+var_18]
.text$mn:000081FE                 mov     eax, [edx+4]
.text$mn:00008201                 push    eax
.text$mn:00008202                 mov     ecx, [ebp+var_18]
.text$mn:00008205                 call    ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)
.text$mn:0000820A                 mov     ecx, [ebp+var_18]
.text$mn:0000820D                 mov     edx, [ebp+var_18]
.text$mn:00008210                 mov     eax, [ecx+0Ch]
.text$mn:00008213                 sub     eax, [edx+4]
.text$mn:00008216                 cdq
.text$mn:00008217                 mov     ecx, 2Ch ; ','
.text$mn:0000821C                 idiv    ecx
.text$mn:0000821E                 push    eax             ; int
.text$mn:0000821F                 mov     edx, [ebp+var_18]
.text$mn:00008222                 mov     eax, [edx+4]
.text$mn:00008225                 push    eax             ; void *
.text$mn:00008226                 lea     ecx, [ebp+var_14]
.text$mn:00008229                 push    ecx
.text$mn:0000822A                 mov     ecx, [ebp+var_18]
.text$mn:0000822D                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:00008232                 mov     ecx, eax
.text$mn:00008234                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(recordedMacroStep *,uint)
.text$mn:00008239
.text$mn:00008239 loc_8239:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+17Ej
.text$mn:00008239                 mov     ecx, [ebp+arg_0]
.text$mn:0000823C                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:00008241                 push    eax
.text$mn:00008242                 mov     ecx, [ebp+var_18]
.text$mn:00008245                 call    ?_Buy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAE_NI@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)
.text$mn:0000824A                 movzx   edx, al
.text$mn:0000824D                 test    edx, edx
.text$mn:0000824F                 jz      short loc_82A4
.text$mn:00008251                 mov     [ebp+var_4], 0
.text$mn:00008258                 mov     eax, [ebp+var_18]
.text$mn:0000825B                 mov     ecx, [eax+4]
.text$mn:0000825E                 push    ecx
.text$mn:0000825F                 mov     edx, [ebp+arg_0]
.text$mn:00008262                 mov     eax, [edx+8]
.text$mn:00008265                 push    eax
.text$mn:00008266                 mov     ecx, [ebp+arg_0]
.text$mn:00008269                 mov     edx, [ecx+4]
.text$mn:0000826C                 push    edx
.text$mn:0000826D                 mov     ecx, [ebp+var_18]
.text$mn:00008270                 call    ??$_Ucopy@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)
.text$mn:00008275                 mov     ecx, [ebp+var_18]
.text$mn:00008278                 mov     [ecx+8], eax
.text$mn:0000827B                 jmp     short loc_8294
.text$mn:0000827B ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:0000827B
.text$mn:0000827D
.text$mn:0000827D ; =============== S U B R O U T I N E =======================================
.text$mn:0000827D
.text$mn:0000827D ; Attributes: noreturn
.text$mn:0000827D
.text$mn:0000827D __catch$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z$0 proc near
.text$mn:0000827D                                         ; DATA XREF: .xdata$x:0000D824o
.text$mn:0000827D                 mov     ecx, [ebp-18h]
.text$mn:00008280                 call    ?_Tidy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Tidy(void)
.text$mn:00008285                 push    0
.text$mn:00008287                 push    0
.text$mn:00008289                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008289 __catch$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z$0 endp
.text$mn:00008289
.text$mn:0000828E ; ---------------------------------------------------------------------------
.text$mn:0000828E                 mov     eax, offset $LN17_2
.text$mn:00008293                 retn
.text$mn:00008294 ; ---------------------------------------------------------------------------
.text$mn:00008294 ; START OF FUNCTION CHUNK FOR ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00008294
.text$mn:00008294 loc_8294:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+207j
.text$mn:00008294                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000829B                 jmp     short loc_82A4
.text$mn:0000829B ; END OF FUNCTION CHUNK FOR ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000829D
.text$mn:0000829D ; =============== S U B R O U T I N E =======================================
.text$mn:0000829D
.text$mn:0000829D
.text$mn:0000829D $LN17_2         proc near               ; DATA XREF: .text$mn:0000828Eo
.text$mn:0000829D                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000829D $LN17_2         endp ; sp-analysis failed
.text$mn:0000829D
.text$mn:000082A4 ; START OF FUNCTION CHUNK FOR ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:000082A4
.text$mn:000082A4 loc_82A4:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+35j
.text$mn:000082A4                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+A4j ...
.text$mn:000082A4                 mov     eax, [ebp+var_18]
.text$mn:000082A7                 mov     ecx, [ebp+var_C]
.text$mn:000082AA                 mov     large fs:0, ecx
.text$mn:000082B1                 pop     ecx
.text$mn:000082B2                 pop     edi
.text$mn:000082B3                 pop     esi
.text$mn:000082B4                 pop     ebx
.text$mn:000082B5                 mov     esp, ebp
.text$mn:000082B7                 pop     ebp
.text$mn:000082B8                 retn    4
.text$mn:000082B8 ; END OF FUNCTION CHUNK FOR ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:000082B8 ; ---------------------------------------------------------------------------
.text$mn:000082BB                 align 4
.text$mn:000082BB _text$mn        ends
.text$mn:000082BB
.text$x:000082BC ; ===========================================================================
.text$x:000082BC
.text$x:000082BC ; Segment type: Pure code
.text$x:000082BC ; Segment permissions: Read/Execute
.text$x:000082BC _text$x         segment para public 'CODE' use32
.text$x:000082BC                 assume cs:_text$x
.text$x:000082BC                 ;org 82BCh
.text$x:000082BC ; COMDAT (pick associative to section at 8074)
.text$x:000082BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000082BC
.text$x:000082BC ; =============== S U B R O U T I N E =======================================
.text$x:000082BC
.text$x:000082BC
.text$x:000082BC __ehhandler$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$x:000082BC                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+5o
.text$x:000082BC
.text$x:000082BC arg_4           = dword ptr  8
.text$x:000082BC
.text$x:000082BC                 mov     edx, [esp+arg_4]
.text$x:000082C0                 lea     eax, [edx+0Ch]
.text$x:000082C3                 mov     ecx, [edx-24h]
.text$x:000082C6                 xor     ecx, eax
.text$x:000082C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000082CD                 mov     eax, offset __ehfuncinfo$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.text$x:000082D2                 jmp     ___CxxFrameHandler3
.text$x:000082D2 __ehhandler$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$x:000082D2
.text$x:000082D2 ; ---------------------------------------------------------------------------
.text$x:000082D7                 align 4
.text$x:000082D7 _text$x         ends
.text$x:000082D7
.text$mn:000082D8 ; ===========================================================================
.text$mn:000082D8
.text$mn:000082D8 ; Segment type: Pure code
.text$mn:000082D8 ; Segment permissions: Read/Execute
.text$mn:000082D8 _text$mn        segment para public 'CODE' use32
.text$mn:000082D8                 assume cs:_text$mn
.text$mn:000082D8                 ;org 82D8h
.text$mn:000082D8 ; COMDAT (pick any)
.text$mn:000082D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082D8
.text$mn:000082D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082D8
.text$mn:000082D8 ; Attributes: bp-based frame
.text$mn:000082D8
.text$mn:000082D8 ; int __stdcall CommandShortcut::operator=(Shortcut *)
.text$mn:000082D8                 public ??4CommandShortcut@@QAEAAV0@ABV0@@Z
.text$mn:000082D8 ??4CommandShortcut@@QAEAAV0@ABV0@@Z proc near
.text$mn:000082D8                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+31Bp
.text$mn:000082D8                                         ; MacroShortcut::operator=(MacroShortcut const &)+Ep ...
.text$mn:000082D8
.text$mn:000082D8 var_4           = dword ptr -4
.text$mn:000082D8 arg_0           = dword ptr  8
.text$mn:000082D8
.text$mn:000082D8                 push    ebp
.text$mn:000082D9                 mov     ebp, esp
.text$mn:000082DB                 push    ecx
.text$mn:000082DC                 mov     [ebp+var_4], ecx
.text$mn:000082DF                 mov     eax, [ebp+arg_0]
.text$mn:000082E2                 push    eax             ; Shortcut *
.text$mn:000082E3                 mov     ecx, [ebp+var_4]
.text$mn:000082E6                 call    ??4Shortcut@@QAEAAV0@ABV0@@Z ; Shortcut::operator=(Shortcut const &)
.text$mn:000082EB                 mov     ecx, [ebp+var_4]
.text$mn:000082EE                 mov     edx, [ebp+arg_0]
.text$mn:000082F1                 mov     eax, [edx+128h]
.text$mn:000082F7                 mov     [ecx+128h], eax
.text$mn:000082FD                 mov     eax, [ebp+var_4]
.text$mn:00008300                 mov     esp, ebp
.text$mn:00008302                 pop     ebp
.text$mn:00008303                 retn    4
.text$mn:00008303 ??4CommandShortcut@@QAEAAV0@ABV0@@Z endp
.text$mn:00008303
.text$mn:00008303 ; ---------------------------------------------------------------------------
.text$mn:00008306                 align 4
.text$mn:00008306 _text$mn        ends
.text$mn:00008306
.text$mn:00008308 ; ===========================================================================
.text$mn:00008308
.text$mn:00008308 ; Segment type: Pure code
.text$mn:00008308 ; Segment permissions: Read/Execute
.text$mn:00008308 _text$mn        segment para public 'CODE' use32
.text$mn:00008308                 assume cs:_text$mn
.text$mn:00008308                 ;org 8308h
.text$mn:00008308 ; COMDAT (pick any)
.text$mn:00008308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008308
.text$mn:00008308 ; =============== S U B R O U T I N E =======================================
.text$mn:00008308
.text$mn:00008308 ; Attributes: bp-based frame
.text$mn:00008308
.text$mn:00008308 ; int __stdcall MacroShortcut::operator=(Shortcut *)
.text$mn:00008308                 public ??4MacroShortcut@@QAEAAV0@ABV0@@Z
.text$mn:00008308 ??4MacroShortcut@@QAEAAV0@ABV0@@Z proc near
.text$mn:00008308                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+473p
.text$mn:00008308                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+C7Dp ...
.text$mn:00008308
.text$mn:00008308 var_4           = dword ptr -4
.text$mn:00008308 arg_0           = dword ptr  8
.text$mn:00008308
.text$mn:00008308                 push    ebp
.text$mn:00008309                 mov     ebp, esp
.text$mn:0000830B                 push    ecx
.text$mn:0000830C                 mov     [ebp+var_4], ecx
.text$mn:0000830F                 mov     eax, [ebp+arg_0]
.text$mn:00008312                 push    eax             ; Shortcut *
.text$mn:00008313                 mov     ecx, [ebp+var_4]
.text$mn:00008316                 call    ??4CommandShortcut@@QAEAAV0@ABV0@@Z ; CommandShortcut::operator=(CommandShortcut const &)
.text$mn:0000831B                 mov     ecx, [ebp+arg_0]
.text$mn:0000831E                 add     ecx, 12Ch
.text$mn:00008324                 push    ecx
.text$mn:00008325                 mov     ecx, [ebp+var_4]
.text$mn:00008328                 add     ecx, 12Ch
.text$mn:0000832E                 call    ??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)
.text$mn:00008333                 mov     eax, [ebp+var_4]
.text$mn:00008336                 mov     esp, ebp
.text$mn:00008338                 pop     ebp
.text$mn:00008339                 retn    4
.text$mn:00008339 ??4MacroShortcut@@QAEAAV0@ABV0@@Z endp
.text$mn:00008339
.text$mn:00008339 _text$mn        ends
.text$mn:00008339
.text$mn:0000833C ; ===========================================================================
.text$mn:0000833C
.text$mn:0000833C ; Segment type: Pure code
.text$mn:0000833C ; Segment permissions: Read/Execute
.text$mn:0000833C _text$mn        segment para public 'CODE' use32
.text$mn:0000833C                 assume cs:_text$mn
.text$mn:0000833C                 ;org 833Ch
.text$mn:0000833C ; COMDAT (pick any)
.text$mn:0000833C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000833C
.text$mn:0000833C ; =============== S U B R O U T I N E =======================================
.text$mn:0000833C
.text$mn:0000833C ; Attributes: bp-based frame
.text$mn:0000833C
.text$mn:0000833C ; int __stdcall PluginCmdShortcut::operator=(Shortcut *)
.text$mn:0000833C                 public ??4PluginCmdShortcut@@QAEAAV0@ABV0@@Z
.text$mn:0000833C ??4PluginCmdShortcut@@QAEAAV0@ABV0@@Z proc near
.text$mn:0000833C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+72Fp
.text$mn:0000833C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+79Cp
.text$mn:0000833C
.text$mn:0000833C var_4           = dword ptr -4
.text$mn:0000833C arg_0           = dword ptr  8
.text$mn:0000833C
.text$mn:0000833C                 push    ebp
.text$mn:0000833D                 mov     ebp, esp
.text$mn:0000833F                 push    ecx
.text$mn:00008340                 mov     [ebp+var_4], ecx
.text$mn:00008343                 mov     eax, [ebp+arg_0]
.text$mn:00008346                 push    eax             ; Shortcut *
.text$mn:00008347                 mov     ecx, [ebp+var_4]
.text$mn:0000834A                 call    ??4CommandShortcut@@QAEAAV0@ABV0@@Z ; CommandShortcut::operator=(CommandShortcut const &)
.text$mn:0000834F                 mov     ecx, [ebp+var_4]
.text$mn:00008352                 mov     edx, [ebp+arg_0]
.text$mn:00008355                 mov     eax, [edx+12Ch]
.text$mn:0000835B                 mov     [ecx+12Ch], eax
.text$mn:00008361                 mov     ecx, [ebp+arg_0]
.text$mn:00008364                 add     ecx, 130h
.text$mn:0000836A                 push    ecx
.text$mn:0000836B                 mov     ecx, [ebp+var_4]
.text$mn:0000836E                 add     ecx, 130h
.text$mn:00008374                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00008379                 mov     edx, [ebp+var_4]
.text$mn:0000837C                 mov     eax, [ebp+arg_0]
.text$mn:0000837F                 mov     ecx, [eax+14Ch]
.text$mn:00008385                 mov     [edx+14Ch], ecx
.text$mn:0000838B                 mov     eax, [ebp+var_4]
.text$mn:0000838E                 mov     esp, ebp
.text$mn:00008390                 pop     ebp
.text$mn:00008391                 retn    4
.text$mn:00008391 ??4PluginCmdShortcut@@QAEAAV0@ABV0@@Z endp
.text$mn:00008391
.text$mn:00008391 _text$mn        ends
.text$mn:00008391
.text$mn:00008394 ; ===========================================================================
.text$mn:00008394
.text$mn:00008394 ; Segment type: Pure code
.text$mn:00008394 ; Segment permissions: Read/Execute
.text$mn:00008394 _text$mn        segment para public 'CODE' use32
.text$mn:00008394                 assume cs:_text$mn
.text$mn:00008394                 ;org 8394h
.text$mn:00008394 ; COMDAT (pick any)
.text$mn:00008394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008394
.text$mn:00008394 ; =============== S U B R O U T I N E =======================================
.text$mn:00008394
.text$mn:00008394 ; Attributes: bp-based frame
.text$mn:00008394
.text$mn:00008394 ; int __stdcall ScintillaKeyMap::operator=(Shortcut *)
.text$mn:00008394                 public ??4ScintillaKeyMap@@QAEAAV0@ABV0@@Z
.text$mn:00008394 ??4ScintillaKeyMap@@QAEAAV0@ABV0@@Z proc near
.text$mn:00008394                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+98Fp
.text$mn:00008394
.text$mn:00008394 var_4           = dword ptr -4
.text$mn:00008394 arg_0           = dword ptr  8
.text$mn:00008394
.text$mn:00008394                 push    ebp
.text$mn:00008395                 mov     ebp, esp
.text$mn:00008397                 push    ecx
.text$mn:00008398                 mov     [ebp+var_4], ecx
.text$mn:0000839B                 mov     eax, [ebp+arg_0]
.text$mn:0000839E                 push    eax             ; Shortcut *
.text$mn:0000839F                 mov     ecx, [ebp+var_4]
.text$mn:000083A2                 call    ??4Shortcut@@QAEAAV0@ABV0@@Z ; Shortcut::operator=(Shortcut const &)
.text$mn:000083A7                 mov     ecx, [ebp+var_4]
.text$mn:000083AA                 mov     edx, [ebp+arg_0]
.text$mn:000083AD                 mov     eax, [edx+128h]
.text$mn:000083B3                 mov     [ecx+128h], eax
.text$mn:000083B9                 mov     ecx, [ebp+var_4]
.text$mn:000083BC                 mov     edx, [ebp+arg_0]
.text$mn:000083BF                 mov     eax, [edx+12Ch]
.text$mn:000083C5                 mov     [ecx+12Ch], eax
.text$mn:000083CB                 mov     ecx, [ebp+arg_0]
.text$mn:000083CE                 add     ecx, 130h
.text$mn:000083D4                 push    ecx
.text$mn:000083D5                 mov     ecx, [ebp+var_4]
.text$mn:000083D8                 add     ecx, 130h
.text$mn:000083DE                 call    ??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)
.text$mn:000083E3                 mov     edx, [ebp+var_4]
.text$mn:000083E6                 mov     eax, [ebp+arg_0]
.text$mn:000083E9                 mov     ecx, [eax+140h]
.text$mn:000083EF                 mov     [edx+140h], ecx
.text$mn:000083F5                 mov     eax, [ebp+var_4]
.text$mn:000083F8                 mov     esp, ebp
.text$mn:000083FA                 pop     ebp
.text$mn:000083FB                 retn    4
.text$mn:000083FB ??4ScintillaKeyMap@@QAEAAV0@ABV0@@Z endp
.text$mn:000083FB
.text$mn:000083FB ; ---------------------------------------------------------------------------
.text$mn:000083FE                 align 10h
.text$mn:000083FE _text$mn        ends
.text$mn:000083FE
.text$mn:00008400 ; ===========================================================================
.text$mn:00008400
.text$mn:00008400 ; Segment type: Pure code
.text$mn:00008400 ; Segment permissions: Read/Execute
.text$mn:00008400 _text$mn        segment para public 'CODE' use32
.text$mn:00008400                 assume cs:_text$mn
.text$mn:00008400                 ;org 8400h
.text$mn:00008400 ; COMDAT (pick any)
.text$mn:00008400                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008400
.text$mn:00008400 ; =============== S U B R O U T I N E =======================================
.text$mn:00008400
.text$mn:00008400 ; Attributes: bp-based frame
.text$mn:00008400
.text$mn:00008400 ; int __stdcall Shortcut::operator=(Shortcut *)
.text$mn:00008400                 public ??4Shortcut@@QAEAAV0@ABV0@@Z
.text$mn:00008400 ??4Shortcut@@QAEAAV0@ABV0@@Z proc near  ; CODE XREF: CommandShortcut::operator=(CommandShortcut const &)+Ep
.text$mn:00008400                                         ; ScintillaKeyMap::operator=(ScintillaKeyMap const &)+Ep
.text$mn:00008400
.text$mn:00008400 var_4           = dword ptr -4
.text$mn:00008400 arg_0           = dword ptr  8
.text$mn:00008400
.text$mn:00008400                 push    ebp
.text$mn:00008401                 mov     ebp, esp
.text$mn:00008403                 push    ecx
.text$mn:00008404                 mov     [ebp+var_4], ecx
.text$mn:00008407                 mov     eax, 2
.text$mn:0000840C                 imul    ecx, eax, 0
.text$mn:0000840F                 mov     edx, [ebp+var_4]
.text$mn:00008412                 movzx   eax, word ptr [edx+ecx+26h]
.text$mn:00008417                 test    eax, eax
.text$mn:00008419                 jz      short loc_842F
.text$mn:0000841B                 mov     ecx, 2
.text$mn:00008420                 imul    edx, ecx, 0
.text$mn:00008423                 mov     eax, [ebp+arg_0]
.text$mn:00008426                 movzx   ecx, word ptr [eax+edx+26h]
.text$mn:0000842B                 test    ecx, ecx
.text$mn:0000842D                 jz      short loc_8440
.text$mn:0000842F
.text$mn:0000842F loc_842F:                               ; CODE XREF: Shortcut::operator=(Shortcut const &)+19j
.text$mn:0000842F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008432                 call    ?getMenuName@Shortcut@@QBEPB_WXZ ; Shortcut::getMenuName(void)
.text$mn:00008437                 push    eax             ; wchar_t *
.text$mn:00008438                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000843B                 call    ?setName@Shortcut@@QAEXPB_W@Z ; Shortcut::setName(wchar_t const *)
.text$mn:00008440
.text$mn:00008440 loc_8440:                               ; CODE XREF: Shortcut::operator=(Shortcut const &)+2Dj
.text$mn:00008440                 mov     edx, [ebp+arg_0]
.text$mn:00008443                 mov     eax, [edx+20h]
.text$mn:00008446                 mov     ecx, [ebp+var_4]
.text$mn:00008449                 mov     [ecx+20h], eax
.text$mn:0000844C                 mov     edx, [ebp+var_4]
.text$mn:0000844F                 mov     eax, [ebp+arg_0]
.text$mn:00008452                 mov     cl, [eax+24h]
.text$mn:00008455                 mov     [edx+24h], cl
.text$mn:00008458                 mov     eax, [ebp+var_4]
.text$mn:0000845B                 mov     esp, ebp
.text$mn:0000845D                 pop     ebp
.text$mn:0000845E                 retn    4
.text$mn:0000845E ??4Shortcut@@QAEAAV0@ABV0@@Z endp
.text$mn:0000845E
.text$mn:0000845E ; ---------------------------------------------------------------------------
.text$mn:00008461                 align 4
.text$mn:00008461 _text$mn        ends
.text$mn:00008461
.text$mn:00008464 ; ===========================================================================
.text$mn:00008464
.text$mn:00008464 ; Segment type: Pure code
.text$mn:00008464 ; Segment permissions: Read/Execute
.text$mn:00008464 _text$mn        segment para public 'CODE' use32
.text$mn:00008464                 assume cs:_text$mn
.text$mn:00008464                 ;org 8464h
.text$mn:00008464 ; COMDAT (pick any)
.text$mn:00008464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008464
.text$mn:00008464 ; =============== S U B R O U T I N E =======================================
.text$mn:00008464
.text$mn:00008464 ; Attributes: bp-based frame
.text$mn:00008464
.text$mn:00008464 ; int __stdcall UserCommand::operator=(Shortcut *)
.text$mn:00008464                 public ??4UserCommand@@QAEAAV0@ABV0@@Z
.text$mn:00008464 ??4UserCommand@@QAEAAV0@ABV0@@Z proc near
.text$mn:00008464                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+5A5p
.text$mn:00008464                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+5FDp ...
.text$mn:00008464
.text$mn:00008464 var_4           = dword ptr -4
.text$mn:00008464 arg_0           = dword ptr  8
.text$mn:00008464
.text$mn:00008464                 push    ebp
.text$mn:00008465                 mov     ebp, esp
.text$mn:00008467                 push    ecx
.text$mn:00008468                 mov     [ebp+var_4], ecx
.text$mn:0000846B                 mov     eax, [ebp+arg_0]
.text$mn:0000846E                 push    eax             ; Shortcut *
.text$mn:0000846F                 mov     ecx, [ebp+var_4]
.text$mn:00008472                 call    ??4CommandShortcut@@QAEAAV0@ABV0@@Z ; CommandShortcut::operator=(CommandShortcut const &)
.text$mn:00008477                 mov     ecx, [ebp+arg_0]
.text$mn:0000847A                 add     ecx, 12Ch
.text$mn:00008480                 push    ecx
.text$mn:00008481                 mov     ecx, [ebp+var_4]
.text$mn:00008484                 add     ecx, 12Ch
.text$mn:0000848A                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000848F                 mov     eax, [ebp+var_4]
.text$mn:00008492                 mov     esp, ebp
.text$mn:00008494                 pop     ebp
.text$mn:00008495                 retn    4
.text$mn:00008495 ??4UserCommand@@QAEAAV0@ABV0@@Z endp
.text$mn:00008495
.text$mn:00008495 _text$mn        ends
.text$mn:00008495
.text$mn:00008498 ; ===========================================================================
.text$mn:00008498
.text$mn:00008498 ; Segment type: Pure code
.text$mn:00008498 ; Segment permissions: Read/Execute
.text$mn:00008498 _text$mn        segment para public 'CODE' use32
.text$mn:00008498                 assume cs:_text$mn
.text$mn:00008498                 ;org 8498h
.text$mn:00008498 ; COMDAT (pick any)
.text$mn:00008498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008498
.text$mn:00008498 ; =============== S U B R O U T I N E =======================================
.text$mn:00008498
.text$mn:00008498 ; Attributes: bp-based frame
.text$mn:00008498
.text$mn:00008498 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00008498                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00008498 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00008498                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00008498
.text$mn:00008498 var_14          = byte ptr -14h
.text$mn:00008498 var_10          = dword ptr -10h
.text$mn:00008498 var_C           = dword ptr -0Ch
.text$mn:00008498 var_4           = dword ptr -4
.text$mn:00008498 arg_0           = dword ptr  8
.text$mn:00008498
.text$mn:00008498                 push    ebp
.text$mn:00008499                 mov     ebp, esp
.text$mn:0000849B                 push    0FFFFFFFFh
.text$mn:0000849D                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:000084A2                 mov     eax, large fs:0
.text$mn:000084A8                 push    eax
.text$mn:000084A9                 sub     esp, 8
.text$mn:000084AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000084B1                 xor     eax, ebp
.text$mn:000084B3                 push    eax
.text$mn:000084B4                 lea     eax, [ebp+var_C]
.text$mn:000084B7                 mov     large fs:0, eax
.text$mn:000084BD                 mov     [ebp+var_10], ecx
.text$mn:000084C0                 mov     eax, [ebp+var_10]
.text$mn:000084C3                 mov     ecx, [ebp+arg_0]
.text$mn:000084C6                 mov     edx, [eax]
.text$mn:000084C8                 cmp     edx, [ecx]
.text$mn:000084CA                 jnz     short loc_84CE
.text$mn:000084CC                 jmp     short loc_8510
.text$mn:000084CE ; ---------------------------------------------------------------------------
.text$mn:000084CE
.text$mn:000084CE loc_84CE:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:000084CE                 mov     eax, [ebp+arg_0]
.text$mn:000084D1                 cmp     dword ptr [eax], 0
.text$mn:000084D4                 jz      short loc_84E8
.text$mn:000084D6                 mov     ecx, [ebp+arg_0]
.text$mn:000084D9                 mov     edx, [ecx]
.text$mn:000084DB                 mov     eax, [edx]
.text$mn:000084DD                 push    eax             ; struct std::_Container_base12 *
.text$mn:000084DE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000084E1                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000084E6                 jmp     short loc_8510
.text$mn:000084E8 ; ---------------------------------------------------------------------------
.text$mn:000084E8
.text$mn:000084E8 loc_84E8:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:000084E8                 push    3               ; int
.text$mn:000084EA                 lea     ecx, [ebp+var_14] ; this
.text$mn:000084ED                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000084F2                 mov     [ebp+var_4], 0
.text$mn:000084F9                 mov     ecx, [ebp+var_10] ; this
.text$mn:000084FC                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00008501                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008508                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000850B                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008510
.text$mn:00008510 loc_8510:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00008510                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00008510                 mov     eax, [ebp+var_10]
.text$mn:00008513                 mov     ecx, [ebp+var_C]
.text$mn:00008516                 mov     large fs:0, ecx
.text$mn:0000851D                 pop     ecx
.text$mn:0000851E                 mov     esp, ebp
.text$mn:00008520                 pop     ebp
.text$mn:00008521                 retn    4
.text$mn:00008521 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00008521
.text$mn:00008521 _text$mn        ends
.text$mn:00008521
.text$x:00008524 ; ===========================================================================
.text$x:00008524
.text$x:00008524 ; Segment type: Pure code
.text$x:00008524 ; Segment permissions: Read/Execute
.text$x:00008524 _text$x         segment para public 'CODE' use32
.text$x:00008524                 assume cs:_text$x
.text$x:00008524                 ;org 8524h
.text$x:00008524 ; COMDAT (pick associative to section at 8498)
.text$x:00008524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008524
.text$x:00008524 ; =============== S U B R O U T I N E =======================================
.text$x:00008524
.text$x:00008524
.text$x:00008524 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00008524                                         ; DATA XREF: .xdata$x:0000CCF0o
.text$x:00008524                 lea     ecx, [ebp-14h]  ; this
.text$x:00008527                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008527 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00008527
.text$x:0000852C
.text$x:0000852C ; =============== S U B R O U T I N E =======================================
.text$x:0000852C
.text$x:0000852C
.text$x:0000852C __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:0000852C                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:0000852C
.text$x:0000852C arg_4           = dword ptr  8
.text$x:0000852C
.text$x:0000852C                 mov     edx, [esp+arg_4]
.text$x:00008530                 lea     eax, [edx+0Ch]
.text$x:00008533                 mov     ecx, [edx-0Ch]
.text$x:00008536                 xor     ecx, eax
.text$x:00008538                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000853D                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00008542                 jmp     ___CxxFrameHandler3
.text$x:00008542 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00008542
.text$x:00008542 ; ---------------------------------------------------------------------------
.text$x:00008547                 align 4
.text$x:00008547 _text$x         ends
.text$x:00008547
.text$mn:00008548 ; ===========================================================================
.text$mn:00008548
.text$mn:00008548 ; Segment type: Pure code
.text$mn:00008548 ; Segment permissions: Read/Execute
.text$mn:00008548 _text$mn        segment para public 'CODE' use32
.text$mn:00008548                 assume cs:_text$mn
.text$mn:00008548                 ;org 8548h
.text$mn:00008548 ; COMDAT (pick any)
.text$mn:00008548                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008548
.text$mn:00008548 ; =============== S U B R O U T I N E =======================================
.text$mn:00008548
.text$mn:00008548 ; Attributes: bp-based frame
.text$mn:00008548
.text$mn:00008548 ; public: struct recordedMacroStep & __thiscall recordedMacroStep::operator=(struct recordedMacroStep const &)
.text$mn:00008548                 public ??4recordedMacroStep@@QAEAAU0@ABU0@@Z
.text$mn:00008548 ??4recordedMacroStep@@QAEAAU0@ABU0@@Z proc near
.text$mn:00008548                                         ; CODE XREF: std::_Copy_impl<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+26p
.text$mn:00008548
.text$mn:00008548 var_4           = dword ptr -4
.text$mn:00008548 arg_0           = dword ptr  8
.text$mn:00008548
.text$mn:00008548                 push    ebp
.text$mn:00008549                 mov     ebp, esp
.text$mn:0000854B                 push    ecx
.text$mn:0000854C                 mov     [ebp+var_4], ecx
.text$mn:0000854F                 mov     eax, [ebp+var_4]
.text$mn:00008552                 mov     ecx, [ebp+arg_0]
.text$mn:00008555                 mov     edx, [ecx]
.text$mn:00008557                 mov     [eax], edx
.text$mn:00008559                 mov     eax, [ebp+var_4]
.text$mn:0000855C                 mov     ecx, [ebp+arg_0]
.text$mn:0000855F                 mov     edx, [ecx+4]
.text$mn:00008562                 mov     [eax+4], edx
.text$mn:00008565                 mov     eax, [ebp+var_4]
.text$mn:00008568                 mov     ecx, [ebp+arg_0]
.text$mn:0000856B                 mov     edx, [ecx+8]
.text$mn:0000856E                 mov     [eax+8], edx
.text$mn:00008571                 mov     eax, [ebp+arg_0]
.text$mn:00008574                 add     eax, 0Ch
.text$mn:00008577                 push    eax
.text$mn:00008578                 mov     ecx, [ebp+var_4]
.text$mn:0000857B                 add     ecx, 0Ch
.text$mn:0000857E                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00008583                 mov     ecx, [ebp+var_4]
.text$mn:00008586                 mov     edx, [ebp+arg_0]
.text$mn:00008589                 mov     eax, [edx+28h]
.text$mn:0000858C                 mov     [ecx+28h], eax
.text$mn:0000858F                 mov     eax, [ebp+var_4]
.text$mn:00008592                 mov     esp, ebp
.text$mn:00008594                 pop     ebp
.text$mn:00008595                 retn    4
.text$mn:00008595 ??4recordedMacroStep@@QAEAAU0@ABU0@@Z endp
.text$mn:00008595
.text$mn:00008595 _text$mn        ends
.text$mn:00008595
.text$mn:00008598 ; ===========================================================================
.text$mn:00008598
.text$mn:00008598 ; Segment type: Pure code
.text$mn:00008598 ; Segment permissions: Read/Execute
.text$mn:00008598 _text$mn        segment para public 'CODE' use32
.text$mn:00008598                 assume cs:_text$mn
.text$mn:00008598                 ;org 8598h
.text$mn:00008598 ; COMDAT (pick any)
.text$mn:00008598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008598
.text$mn:00008598 ; =============== S U B R O U T I N E =======================================
.text$mn:00008598
.text$mn:00008598 ; Attributes: bp-based frame
.text$mn:00008598
.text$mn:00008598 ; bool const __cdecl operator==(class ScintillaKeyMap const &, class ScintillaKeyMap const &)
.text$mn:00008598                 public ??8@YA?B_NABVScintillaKeyMap@@0@Z
.text$mn:00008598 ??8@YA?B_NABVScintillaKeyMap@@0@Z proc near
.text$mn:00008598                                         ; CODE XREF: operator!=(ScintillaKeyMap const &,ScintillaKeyMap const &)+Cp
.text$mn:00008598
.text$mn:00008598 var_10          = dword ptr -10h
.text$mn:00008598 var_C           = dword ptr -0Ch
.text$mn:00008598 var_8           = dword ptr -8
.text$mn:00008598 var_1           = byte ptr -1
.text$mn:00008598 arg_0           = dword ptr  8
.text$mn:00008598 arg_4           = dword ptr  0Ch
.text$mn:00008598
.text$mn:00008598                 push    ebp
.text$mn:00008599                 mov     ebp, esp
.text$mn:0000859B                 sub     esp, 10h
.text$mn:0000859E                 push    esi
.text$mn:0000859F                 mov     eax, [ebp+arg_0]
.text$mn:000085A2                 mov     ecx, [ebp+arg_4]
.text$mn:000085A5                 mov     edx, [eax+140h]
.text$mn:000085AB                 cmp     edx, [ecx+140h]
.text$mn:000085B1                 jnz     short loc_85BC
.text$mn:000085B3                 mov     [ebp+var_C], 1
.text$mn:000085BA                 jmp     short loc_85C3
.text$mn:000085BC ; ---------------------------------------------------------------------------
.text$mn:000085BC
.text$mn:000085BC loc_85BC:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+19j
.text$mn:000085BC                 mov     [ebp+var_C], 0
.text$mn:000085C3
.text$mn:000085C3 loc_85C3:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+22j
.text$mn:000085C3                 mov     al, byte ptr [ebp+var_C]
.text$mn:000085C6                 mov     [ebp+var_1], al
.text$mn:000085C9                 movzx   ecx, [ebp+var_1]
.text$mn:000085CD                 test    ecx, ecx
.text$mn:000085CF                 jnz     short loc_85D8
.text$mn:000085D1                 xor     al, al
.text$mn:000085D3                 jmp     loc_86E6
.text$mn:000085D8 ; ---------------------------------------------------------------------------
.text$mn:000085D8
.text$mn:000085D8 loc_85D8:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+37j
.text$mn:000085D8                 mov     [ebp+var_8], 0
.text$mn:000085DF
.text$mn:000085DF loc_85DF:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+146j
.text$mn:000085DF                 movzx   edx, [ebp+var_1]
.text$mn:000085E3                 test    edx, edx
.text$mn:000085E5                 jz      loc_86E3
.text$mn:000085EB                 mov     eax, [ebp+arg_0]
.text$mn:000085EE                 mov     ecx, [ebp+var_8]
.text$mn:000085F1                 cmp     ecx, [eax+140h]
.text$mn:000085F7                 jnb     loc_86E3
.text$mn:000085FD                 mov     edx, [ebp+var_8]
.text$mn:00008600                 push    edx
.text$mn:00008601                 mov     ecx, [ebp+arg_0]
.text$mn:00008604                 add     ecx, 130h
.text$mn:0000860A                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:0000860F                 movzx   esi, byte ptr [eax]
.text$mn:00008612                 mov     eax, [ebp+var_8]
.text$mn:00008615                 push    eax
.text$mn:00008616                 mov     ecx, [ebp+arg_4]
.text$mn:00008619                 add     ecx, 130h
.text$mn:0000861F                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:00008624                 movzx   ecx, byte ptr [eax]
.text$mn:00008627                 cmp     esi, ecx
.text$mn:00008629                 jnz     loc_86C8
.text$mn:0000862F                 mov     edx, [ebp+var_8]
.text$mn:00008632                 push    edx
.text$mn:00008633                 mov     ecx, [ebp+arg_0]
.text$mn:00008636                 add     ecx, 130h
.text$mn:0000863C                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:00008641                 movzx   esi, byte ptr [eax+1]
.text$mn:00008645                 mov     eax, [ebp+var_8]
.text$mn:00008648                 push    eax
.text$mn:00008649                 mov     ecx, [ebp+arg_4]
.text$mn:0000864C                 add     ecx, 130h
.text$mn:00008652                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:00008657                 movzx   ecx, byte ptr [eax+1]
.text$mn:0000865B                 cmp     esi, ecx
.text$mn:0000865D                 jnz     short loc_86C8
.text$mn:0000865F                 mov     edx, [ebp+var_8]
.text$mn:00008662                 push    edx
.text$mn:00008663                 mov     ecx, [ebp+arg_0]
.text$mn:00008666                 add     ecx, 130h
.text$mn:0000866C                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:00008671                 movzx   esi, byte ptr [eax+2]
.text$mn:00008675                 mov     eax, [ebp+var_8]
.text$mn:00008678                 push    eax
.text$mn:00008679                 mov     ecx, [ebp+arg_4]
.text$mn:0000867C                 add     ecx, 130h
.text$mn:00008682                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:00008687                 movzx   ecx, byte ptr [eax+2]
.text$mn:0000868B                 cmp     esi, ecx
.text$mn:0000868D                 jnz     short loc_86C8
.text$mn:0000868F                 mov     edx, [ebp+var_8]
.text$mn:00008692                 push    edx
.text$mn:00008693                 mov     ecx, [ebp+arg_0]
.text$mn:00008696                 add     ecx, 130h
.text$mn:0000869C                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:000086A1                 movzx   esi, byte ptr [eax+3]
.text$mn:000086A5                 mov     eax, [ebp+var_8]
.text$mn:000086A8                 push    eax
.text$mn:000086A9                 mov     ecx, [ebp+arg_4]
.text$mn:000086AC                 add     ecx, 130h
.text$mn:000086B2                 call    ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)
.text$mn:000086B7                 movzx   ecx, byte ptr [eax+3]
.text$mn:000086BB                 cmp     esi, ecx
.text$mn:000086BD                 jnz     short loc_86C8
.text$mn:000086BF                 mov     [ebp+var_10], 1
.text$mn:000086C6                 jmp     short loc_86CF
.text$mn:000086C8 ; ---------------------------------------------------------------------------
.text$mn:000086C8
.text$mn:000086C8 loc_86C8:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+91j
.text$mn:000086C8                                         ; operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+C5j ...
.text$mn:000086C8                 mov     [ebp+var_10], 0
.text$mn:000086CF
.text$mn:000086CF loc_86CF:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+12Ej
.text$mn:000086CF                 mov     dl, byte ptr [ebp+var_10]
.text$mn:000086D2                 mov     [ebp+var_1], dl
.text$mn:000086D5                 mov     eax, [ebp+var_8]
.text$mn:000086D8                 add     eax, 1
.text$mn:000086DB                 mov     [ebp+var_8], eax
.text$mn:000086DE                 jmp     loc_85DF
.text$mn:000086E3 ; ---------------------------------------------------------------------------
.text$mn:000086E3
.text$mn:000086E3 loc_86E3:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+4Dj
.text$mn:000086E3                                         ; operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+5Fj
.text$mn:000086E3                 mov     al, [ebp+var_1]
.text$mn:000086E6
.text$mn:000086E6 loc_86E6:                               ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+3Bj
.text$mn:000086E6                 pop     esi
.text$mn:000086E7                 mov     esp, ebp
.text$mn:000086E9                 pop     ebp
.text$mn:000086EA                 retn
.text$mn:000086EA ??8@YA?B_NABVScintillaKeyMap@@0@Z endp
.text$mn:000086EA
.text$mn:000086EA ; ---------------------------------------------------------------------------
.text$mn:000086EB                 align 4
.text$mn:000086EB _text$mn        ends
.text$mn:000086EB
.text$mn:000086EC ; ===========================================================================
.text$mn:000086EC
.text$mn:000086EC ; Segment type: Pure code
.text$mn:000086EC ; Segment permissions: Read/Execute
.text$mn:000086EC _text$mn        segment para public 'CODE' use32
.text$mn:000086EC                 assume cs:_text$mn
.text$mn:000086EC                 ;org 86ECh
.text$mn:000086EC ; COMDAT (pick any)
.text$mn:000086EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086EC
.text$mn:000086EC ; =============== S U B R O U T I N E =======================================
.text$mn:000086EC
.text$mn:000086EC ; Attributes: bp-based frame
.text$mn:000086EC
.text$mn:000086EC ; int __cdecl operator==(Shortcut *, Shortcut *)
.text$mn:000086EC                 public ??8@YA?B_NABVShortcut@@0@Z
.text$mn:000086EC ??8@YA?B_NABVShortcut@@0@Z proc near    ; CODE XREF: operator!=(Shortcut const &,Shortcut const &)+Cp
.text$mn:000086EC
.text$mn:000086EC var_1           = byte ptr -1
.text$mn:000086EC arg_0           = dword ptr  8
.text$mn:000086EC arg_4           = dword ptr  0Ch
.text$mn:000086EC
.text$mn:000086EC                 push    ebp
.text$mn:000086ED                 mov     ebp, esp
.text$mn:000086EF                 push    ecx
.text$mn:000086F0                 mov     ecx, [ebp+arg_4] ; this
.text$mn:000086F3                 call    ?getMenuName@Shortcut@@QBEPB_WXZ ; Shortcut::getMenuName(void)
.text$mn:000086F8                 push    eax             ; lpString2
.text$mn:000086F9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000086FC                 call    ?getMenuName@Shortcut@@QBEPB_WXZ ; Shortcut::getMenuName(void)
.text$mn:00008701                 push    eax             ; lpString1
.text$mn:00008702                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00008708                 test    eax, eax
.text$mn:0000870A                 jnz     short loc_875A
.text$mn:0000870C                 mov     eax, [ebp+arg_0]
.text$mn:0000870F                 movzx   ecx, byte ptr [eax+20h]
.text$mn:00008713                 mov     edx, [ebp+arg_4]
.text$mn:00008716                 movzx   eax, byte ptr [edx+20h]
.text$mn:0000871A                 cmp     ecx, eax
.text$mn:0000871C                 jnz     short loc_875A
.text$mn:0000871E                 mov     ecx, [ebp+arg_0]
.text$mn:00008721                 movzx   edx, byte ptr [ecx+21h]
.text$mn:00008725                 mov     eax, [ebp+arg_4]
.text$mn:00008728                 movzx   ecx, byte ptr [eax+21h]
.text$mn:0000872C                 cmp     edx, ecx
.text$mn:0000872E                 jnz     short loc_875A
.text$mn:00008730                 mov     edx, [ebp+arg_0]
.text$mn:00008733                 movzx   eax, byte ptr [edx+22h]
.text$mn:00008737                 mov     ecx, [ebp+arg_4]
.text$mn:0000873A                 movzx   edx, byte ptr [ecx+22h]
.text$mn:0000873E                 cmp     eax, edx
.text$mn:00008740                 jnz     short loc_875A
.text$mn:00008742                 mov     eax, [ebp+arg_0]
.text$mn:00008745                 movzx   ecx, byte ptr [eax+23h]
.text$mn:00008749                 mov     edx, [ebp+arg_4]
.text$mn:0000874C                 movzx   eax, byte ptr [edx+23h]
.text$mn:00008750                 cmp     ecx, eax
.text$mn:00008752                 jnz     short loc_875A
.text$mn:00008754                 mov     [ebp+var_1], 1
.text$mn:00008758                 jmp     short loc_875E
.text$mn:0000875A ; ---------------------------------------------------------------------------
.text$mn:0000875A
.text$mn:0000875A loc_875A:                               ; CODE XREF: operator==(Shortcut const &,Shortcut const &)+1Ej
.text$mn:0000875A                                         ; operator==(Shortcut const &,Shortcut const &)+30j ...
.text$mn:0000875A                 mov     [ebp+var_1], 0
.text$mn:0000875E
.text$mn:0000875E loc_875E:                               ; CODE XREF: operator==(Shortcut const &,Shortcut const &)+6Cj
.text$mn:0000875E                 mov     al, [ebp+var_1]
.text$mn:00008761                 mov     esp, ebp
.text$mn:00008763                 pop     ebp
.text$mn:00008764                 retn
.text$mn:00008764 ??8@YA?B_NABVShortcut@@0@Z endp
.text$mn:00008764
.text$mn:00008764 ; ---------------------------------------------------------------------------
.text$mn:00008765                 align 4
.text$mn:00008765 _text$mn        ends
.text$mn:00008765
.text$mn:00008768 ; ===========================================================================
.text$mn:00008768
.text$mn:00008768 ; Segment type: Pure code
.text$mn:00008768 ; Segment permissions: Read/Execute
.text$mn:00008768 _text$mn        segment para public 'CODE' use32
.text$mn:00008768                 assume cs:_text$mn
.text$mn:00008768                 ;org 8768h
.text$mn:00008768 ; COMDAT (pick any)
.text$mn:00008768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008768
.text$mn:00008768 ; =============== S U B R O U T I N E =======================================
.text$mn:00008768
.text$mn:00008768 ; Attributes: bp-based frame
.text$mn:00008768
.text$mn:00008768 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00008768                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00008768 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00008768                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00008768                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00008768
.text$mn:00008768 var_8           = dword ptr -8
.text$mn:00008768 var_4           = dword ptr -4
.text$mn:00008768 arg_0           = dword ptr  8
.text$mn:00008768
.text$mn:00008768                 push    ebp
.text$mn:00008769                 mov     ebp, esp
.text$mn:0000876B                 sub     esp, 8
.text$mn:0000876E                 mov     [ebp+var_8], ecx
.text$mn:00008771                 mov     eax, [ebp+var_8]
.text$mn:00008774                 cmp     eax, [ebp+arg_0]
.text$mn:00008777                 jnz     short loc_8782
.text$mn:00008779                 mov     [ebp+var_4], 1
.text$mn:00008780                 jmp     short loc_8789
.text$mn:00008782 ; ---------------------------------------------------------------------------
.text$mn:00008782
.text$mn:00008782 loc_8782:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00008782                 mov     [ebp+var_4], 0
.text$mn:00008789
.text$mn:00008789 loc_8789:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00008789                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000878C                 mov     esp, ebp
.text$mn:0000878E                 pop     ebp
.text$mn:0000878F                 retn    4
.text$mn:0000878F ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000878F
.text$mn:0000878F ; ---------------------------------------------------------------------------
.text$mn:00008792                 align 4
.text$mn:00008792 _text$mn        ends
.text$mn:00008792
.text$mn:00008794 ; ===========================================================================
.text$mn:00008794
.text$mn:00008794 ; Segment type: Pure code
.text$mn:00008794 ; Segment permissions: Read/Execute
.text$mn:00008794 _text$mn        segment para public 'CODE' use32
.text$mn:00008794                 assume cs:_text$mn
.text$mn:00008794                 ;org 8794h
.text$mn:00008794 ; COMDAT (pick any)
.text$mn:00008794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008794
.text$mn:00008794 ; =============== S U B R O U T I N E =======================================
.text$mn:00008794
.text$mn:00008794 ; Attributes: bp-based frame
.text$mn:00008794
.text$mn:00008794 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00008794                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00008794 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00008794                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00008794
.text$mn:00008794 var_8           = dword ptr -8
.text$mn:00008794 var_4           = dword ptr -4
.text$mn:00008794 arg_0           = dword ptr  8
.text$mn:00008794
.text$mn:00008794                 push    ebp
.text$mn:00008795                 mov     ebp, esp
.text$mn:00008797                 sub     esp, 8
.text$mn:0000879A                 push    esi
.text$mn:0000879B                 mov     [ebp+var_4], ecx
.text$mn:0000879E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000087A1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000087A6                 push    eax
.text$mn:000087A7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000087AA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000087AF                 mov     ecx, eax
.text$mn:000087B1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000087B6                 movzx   eax, al
.text$mn:000087B9                 test    eax, eax
.text$mn:000087BB                 jz      short loc_87DC
.text$mn:000087BD                 mov     ecx, [ebp+var_4] ; this
.text$mn:000087C0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000087C5                 mov     esi, eax
.text$mn:000087C7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000087CA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000087CF                 cmp     esi, eax
.text$mn:000087D1                 jnz     short loc_87DC
.text$mn:000087D3                 mov     [ebp+var_8], 1
.text$mn:000087DA                 jmp     short loc_87E3
.text$mn:000087DC ; ---------------------------------------------------------------------------
.text$mn:000087DC
.text$mn:000087DC loc_87DC:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000087DC                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000087DC                 mov     [ebp+var_8], 0
.text$mn:000087E3
.text$mn:000087E3 loc_87E3:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000087E3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000087E6                 pop     esi
.text$mn:000087E7                 mov     esp, ebp
.text$mn:000087E9                 pop     ebp
.text$mn:000087EA                 retn    4
.text$mn:000087EA ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000087EA
.text$mn:000087EA ; ---------------------------------------------------------------------------
.text$mn:000087ED                 align 10h
.text$mn:000087ED _text$mn        ends
.text$mn:000087ED
.text$mn:000087F0 ; ===========================================================================
.text$mn:000087F0
.text$mn:000087F0 ; Segment type: Pure code
.text$mn:000087F0 ; Segment permissions: Read/Execute
.text$mn:000087F0 _text$mn        segment para public 'CODE' use32
.text$mn:000087F0                 assume cs:_text$mn
.text$mn:000087F0                 ;org 87F0h
.text$mn:000087F0 ; COMDAT (pick any)
.text$mn:000087F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000087F0
.text$mn:000087F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000087F0
.text$mn:000087F0 ; Attributes: bp-based frame
.text$mn:000087F0
.text$mn:000087F0 ; bool const __cdecl operator!=(class ScintillaKeyMap const &, class ScintillaKeyMap const &)
.text$mn:000087F0                 public ??9@YA?B_NABVScintillaKeyMap@@0@Z
.text$mn:000087F0 ??9@YA?B_NABVScintillaKeyMap@@0@Z proc near
.text$mn:000087F0                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+949p
.text$mn:000087F0
.text$mn:000087F0 var_1           = byte ptr -1
.text$mn:000087F0 arg_0           = dword ptr  8
.text$mn:000087F0 arg_4           = dword ptr  0Ch
.text$mn:000087F0
.text$mn:000087F0                 push    ebp
.text$mn:000087F1                 mov     ebp, esp
.text$mn:000087F3                 push    ecx
.text$mn:000087F4                 mov     eax, [ebp+arg_4]
.text$mn:000087F7                 push    eax
.text$mn:000087F8                 mov     ecx, [ebp+arg_0]
.text$mn:000087FB                 push    ecx
.text$mn:000087FC                 call    ??8@YA?B_NABVScintillaKeyMap@@0@Z ; operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)
.text$mn:00008801                 add     esp, 8
.text$mn:00008804                 movzx   edx, al
.text$mn:00008807                 test    edx, edx
.text$mn:00008809                 jnz     short loc_8811
.text$mn:0000880B                 mov     [ebp+var_1], 1
.text$mn:0000880F                 jmp     short loc_8815
.text$mn:00008811 ; ---------------------------------------------------------------------------
.text$mn:00008811
.text$mn:00008811 loc_8811:                               ; CODE XREF: operator!=(ScintillaKeyMap const &,ScintillaKeyMap const &)+19j
.text$mn:00008811                 mov     [ebp+var_1], 0
.text$mn:00008815
.text$mn:00008815 loc_8815:                               ; CODE XREF: operator!=(ScintillaKeyMap const &,ScintillaKeyMap const &)+1Fj
.text$mn:00008815                 mov     al, [ebp+var_1]
.text$mn:00008818                 mov     esp, ebp
.text$mn:0000881A                 pop     ebp
.text$mn:0000881B                 retn
.text$mn:0000881B ??9@YA?B_NABVScintillaKeyMap@@0@Z endp
.text$mn:0000881B
.text$mn:0000881B _text$mn        ends
.text$mn:0000881B
.text$mn:0000881C ; ===========================================================================
.text$mn:0000881C
.text$mn:0000881C ; Segment type: Pure code
.text$mn:0000881C ; Segment permissions: Read/Execute
.text$mn:0000881C _text$mn        segment para public 'CODE' use32
.text$mn:0000881C                 assume cs:_text$mn
.text$mn:0000881C                 ;org 881Ch
.text$mn:0000881C ; COMDAT (pick any)
.text$mn:0000881C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000881C
.text$mn:0000881C ; =============== S U B R O U T I N E =======================================
.text$mn:0000881C
.text$mn:0000881C ; Attributes: bp-based frame
.text$mn:0000881C
.text$mn:0000881C ; int __cdecl operator!=(Shortcut *, Shortcut *)
.text$mn:0000881C                 public ??9@YA?B_NABVShortcut@@0@Z
.text$mn:0000881C ??9@YA?B_NABVShortcut@@0@Z proc near    ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+2D5p
.text$mn:0000881C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+442p ...
.text$mn:0000881C
.text$mn:0000881C var_1           = byte ptr -1
.text$mn:0000881C arg_0           = dword ptr  8
.text$mn:0000881C arg_4           = dword ptr  0Ch
.text$mn:0000881C
.text$mn:0000881C                 push    ebp
.text$mn:0000881D                 mov     ebp, esp
.text$mn:0000881F                 push    ecx
.text$mn:00008820                 mov     eax, [ebp+arg_4]
.text$mn:00008823                 push    eax             ; Shortcut *
.text$mn:00008824                 mov     ecx, [ebp+arg_0]
.text$mn:00008827                 push    ecx             ; Shortcut *
.text$mn:00008828                 call    ??8@YA?B_NABVShortcut@@0@Z ; operator==(Shortcut const &,Shortcut const &)
.text$mn:0000882D                 add     esp, 8
.text$mn:00008830                 movzx   edx, al
.text$mn:00008833                 test    edx, edx
.text$mn:00008835                 jnz     short loc_883D
.text$mn:00008837                 mov     [ebp+var_1], 1
.text$mn:0000883B                 jmp     short loc_8841
.text$mn:0000883D ; ---------------------------------------------------------------------------
.text$mn:0000883D
.text$mn:0000883D loc_883D:                               ; CODE XREF: operator!=(Shortcut const &,Shortcut const &)+19j
.text$mn:0000883D                 mov     [ebp+var_1], 0
.text$mn:00008841
.text$mn:00008841 loc_8841:                               ; CODE XREF: operator!=(Shortcut const &,Shortcut const &)+1Fj
.text$mn:00008841                 mov     al, [ebp+var_1]
.text$mn:00008844                 mov     esp, ebp
.text$mn:00008846                 pop     ebp
.text$mn:00008847                 retn
.text$mn:00008847 ??9@YA?B_NABVShortcut@@0@Z endp
.text$mn:00008847
.text$mn:00008847 _text$mn        ends
.text$mn:00008847
.text$mn:00008848 ; ===========================================================================
.text$mn:00008848
.text$mn:00008848 ; Segment type: Pure code
.text$mn:00008848 ; Segment permissions: Read/Execute
.text$mn:00008848 _text$mn        segment para public 'CODE' use32
.text$mn:00008848                 assume cs:_text$mn
.text$mn:00008848                 ;org 8848h
.text$mn:00008848 ; COMDAT (pick any)
.text$mn:00008848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008848
.text$mn:00008848 ; =============== S U B R O U T I N E =======================================
.text$mn:00008848
.text$mn:00008848 ; Attributes: bp-based frame
.text$mn:00008848
.text$mn:00008848 ; public: wchar_t const & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator[](unsigned int)const
.text$mn:00008848                 public ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
.text$mn:00008848 ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z proc near
.text$mn:00008848                                         ; CODE XREF: PluginCmdShortcut::isValid(void)+25p
.text$mn:00008848
.text$mn:00008848 var_4           = dword ptr -4
.text$mn:00008848 arg_0           = dword ptr  8
.text$mn:00008848
.text$mn:00008848                 push    ebp
.text$mn:00008849                 mov     ebp, esp
.text$mn:0000884B                 push    ecx
.text$mn:0000884C                 mov     [ebp+var_4], ecx
.text$mn:0000884F                 mov     eax, [ebp+var_4]
.text$mn:00008852                 mov     ecx, [eax+14h]
.text$mn:00008855                 cmp     ecx, [ebp+arg_0]
.text$mn:00008858                 jnb     short loc_8871
.text$mn:0000885A                 push    6A2h            ; unsigned int
.text$mn:0000885F                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008864                 push    offset ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "string subscript out of range"
.text$mn:00008869                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000886E                 add     esp, 0Ch
.text$mn:00008871
.text$mn:00008871 loc_8871:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+10j
.text$mn:00008871                 mov     ecx, [ebp+var_4]
.text$mn:00008874                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008879                 mov     edx, [ebp+arg_0]
.text$mn:0000887C                 lea     eax, [eax+edx*2]
.text$mn:0000887F                 mov     esp, ebp
.text$mn:00008881                 pop     ebp
.text$mn:00008882                 retn    4
.text$mn:00008882 ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z endp
.text$mn:00008882
.text$mn:00008882 ; ---------------------------------------------------------------------------
.text$mn:00008885                 align 4
.text$mn:00008885 _text$mn        ends
.text$mn:00008885
.text$mn:00008888 ; ===========================================================================
.text$mn:00008888
.text$mn:00008888 ; Segment type: Pure code
.text$mn:00008888 ; Segment permissions: Read/Execute
.text$mn:00008888 _text$mn        segment para public 'CODE' use32
.text$mn:00008888                 assume cs:_text$mn
.text$mn:00008888                 ;org 8888h
.text$mn:00008888 ; COMDAT (pick any)
.text$mn:00008888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008888
.text$mn:00008888 ; =============== S U B R O U T I N E =======================================
.text$mn:00008888
.text$mn:00008888 ; Attributes: bp-based frame
.text$mn:00008888
.text$mn:00008888 ; public: struct KeyCombo const & __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::operator[](unsigned int)const
.text$mn:00008888                 public ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z
.text$mn:00008888 ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z proc near
.text$mn:00008888                                         ; CODE XREF: operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+72p
.text$mn:00008888                                         ; operator==(ScintillaKeyMap const &,ScintillaKeyMap const &)+87p ...
.text$mn:00008888
.text$mn:00008888 var_4           = dword ptr -4
.text$mn:00008888 arg_0           = dword ptr  8
.text$mn:00008888
.text$mn:00008888                 push    ebp
.text$mn:00008889                 mov     ebp, esp
.text$mn:0000888B                 push    ecx
.text$mn:0000888C                 mov     [ebp+var_4], ecx
.text$mn:0000888F                 mov     ecx, [ebp+var_4]
.text$mn:00008892                 call    ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::size(void)
.text$mn:00008897                 cmp     eax, [ebp+arg_0]
.text$mn:0000889A                 ja      short loc_8904
.text$mn:0000889C                 push    4A1h            ; unsigned int
.text$mn:000088A1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000088A6                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:000088AB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000088B0                 add     esp, 0Ch
.text$mn:000088B3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000088B8                 test    eax, eax
.text$mn:000088BA                 jz      short loc_88C0
.text$mn:000088BC                 xor     ecx, ecx
.text$mn:000088BE                 jnz     short loc_88E6
.text$mn:000088C0
.text$mn:000088C0 loc_88C0:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+32j
.text$mn:000088C0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000088C5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000088CA                 push    0
.text$mn:000088CC                 push    4A2h
.text$mn:000088D1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000088D6                 push    2
.text$mn:000088D8                 call    __CrtDbgReportW
.text$mn:000088DD                 add     esp, 18h
.text$mn:000088E0                 cmp     eax, 1
.text$mn:000088E3                 jnz     short loc_88E6
.text$mn:000088E5                 int     3               ; Trap to Debugger
.text$mn:000088E6
.text$mn:000088E6 loc_88E6:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+36j
.text$mn:000088E6                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+5Bj
.text$mn:000088E6                 push    0
.text$mn:000088E8                 push    4A2h
.text$mn:000088ED                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000088F2                 push    offset ??_C@_1KC@KHKGAADA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAK?$AAe?$AAy?$AAC?$AAo?$AAm?$AAb?$AAo?$AA?0?$AAc?$AAl?$AAa?$AAs@ ; "std::vector<struct KeyCombo,class std::"...
.text$mn:000088F7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000088FC                 call    __invalid_parameter
.text$mn:00008901                 add     esp, 14h
.text$mn:00008904
.text$mn:00008904 loc_8904:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+12j
.text$mn:00008904                 mov     eax, [ebp+var_4]
.text$mn:00008907                 mov     ecx, [eax+4]
.text$mn:0000890A                 mov     edx, [ebp+arg_0]
.text$mn:0000890D                 lea     eax, [ecx+edx*4]
.text$mn:00008910                 mov     esp, ebp
.text$mn:00008912                 pop     ebp
.text$mn:00008913                 retn    4
.text$mn:00008913 ??A?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEABUKeyCombo@@I@Z endp
.text$mn:00008913
.text$mn:00008913 ; ---------------------------------------------------------------------------
.text$mn:00008916                 align 4
.text$mn:00008916 _text$mn        ends
.text$mn:00008916
.text$mn:00008918 ; ===========================================================================
.text$mn:00008918
.text$mn:00008918 ; Segment type: Pure code
.text$mn:00008918 ; Segment permissions: Read/Execute
.text$mn:00008918 _text$mn        segment para public 'CODE' use32
.text$mn:00008918                 assume cs:_text$mn
.text$mn:00008918                 ;org 8918h
.text$mn:00008918 ; COMDAT (pick any)
.text$mn:00008918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008918
.text$mn:00008918 ; =============== S U B R O U T I N E =======================================
.text$mn:00008918
.text$mn:00008918 ; Attributes: bp-based frame
.text$mn:00008918
.text$mn:00008918 ; public: class CommandShortcut & __thiscall std::vector<class CommandShortcut, class std::allocator<class CommandShortcut>>::operator[](unsigned int)
.text$mn:00008918                 public ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z
.text$mn:00008918 ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z proc near
.text$mn:00008918                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+25Dp
.text$mn:00008918                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+285p ...
.text$mn:00008918
.text$mn:00008918 var_4           = dword ptr -4
.text$mn:00008918 arg_0           = dword ptr  8
.text$mn:00008918
.text$mn:00008918                 push    ebp
.text$mn:00008919                 mov     ebp, esp
.text$mn:0000891B                 push    ecx
.text$mn:0000891C                 mov     [ebp+var_4], ecx
.text$mn:0000891F                 mov     ecx, [ebp+var_4]
.text$mn:00008922                 call    ?size@?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QBEIXZ ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::size(void)
.text$mn:00008927                 cmp     eax, [ebp+arg_0]
.text$mn:0000892A                 ja      short loc_8994
.text$mn:0000892C                 push    4B1h            ; unsigned int
.text$mn:00008931                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008936                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000893B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008940                 add     esp, 0Ch
.text$mn:00008943                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008948                 test    eax, eax
.text$mn:0000894A                 jz      short loc_8950
.text$mn:0000894C                 xor     ecx, ecx
.text$mn:0000894E                 jnz     short loc_8976
.text$mn:00008950
.text$mn:00008950 loc_8950:                               ; CODE XREF: std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+32j
.text$mn:00008950                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008955                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000895A                 push    0
.text$mn:0000895C                 push    4B2h
.text$mn:00008961                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008966                 push    2
.text$mn:00008968                 call    __CrtDbgReportW
.text$mn:0000896D                 add     esp, 18h
.text$mn:00008970                 cmp     eax, 1
.text$mn:00008973                 jnz     short loc_8976
.text$mn:00008975                 int     3               ; Trap to Debugger
.text$mn:00008976
.text$mn:00008976 loc_8976:                               ; CODE XREF: std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+36j
.text$mn:00008976                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+5Bj
.text$mn:00008976                 push    0
.text$mn:00008978                 push    4B2h
.text$mn:0000897D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008982                 push    offset ??_C@_1LK@BFNMKIGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu@ ; "std::vector<class CommandShortcut,class"...
.text$mn:00008987                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000898C                 call    __invalid_parameter
.text$mn:00008991                 add     esp, 14h
.text$mn:00008994
.text$mn:00008994 loc_8994:                               ; CODE XREF: std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+12j
.text$mn:00008994                 imul    eax, [ebp+arg_0], 12Ch
.text$mn:0000899B                 mov     ecx, [ebp+var_4]
.text$mn:0000899E                 add     eax, [ecx+4]
.text$mn:000089A1                 mov     esp, ebp
.text$mn:000089A3                 pop     ebp
.text$mn:000089A4                 retn    4
.text$mn:000089A4 ??A?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QAEAAVCommandShortcut@@I@Z endp
.text$mn:000089A4
.text$mn:000089A4 ; ---------------------------------------------------------------------------
.text$mn:000089A7                 align 4
.text$mn:000089A7 _text$mn        ends
.text$mn:000089A7
.text$mn:000089A8 ; ===========================================================================
.text$mn:000089A8
.text$mn:000089A8 ; Segment type: Pure code
.text$mn:000089A8 ; Segment permissions: Read/Execute
.text$mn:000089A8 _text$mn        segment para public 'CODE' use32
.text$mn:000089A8                 assume cs:_text$mn
.text$mn:000089A8                 ;org 89A8h
.text$mn:000089A8 ; COMDAT (pick any)
.text$mn:000089A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089A8
.text$mn:000089A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000089A8
.text$mn:000089A8 ; Attributes: bp-based frame
.text$mn:000089A8
.text$mn:000089A8 ; public: class MacroShortcut & __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::operator[](unsigned int)
.text$mn:000089A8                 public ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z
.text$mn:000089A8 ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z proc near
.text$mn:000089A8                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+3CAp
.text$mn:000089A8                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+3F2p ...
.text$mn:000089A8
.text$mn:000089A8 var_4           = dword ptr -4
.text$mn:000089A8 arg_0           = dword ptr  8
.text$mn:000089A8
.text$mn:000089A8                 push    ebp
.text$mn:000089A9                 mov     ebp, esp
.text$mn:000089AB                 push    ecx
.text$mn:000089AC                 mov     [ebp+var_4], ecx
.text$mn:000089AF                 mov     ecx, [ebp+var_4]
.text$mn:000089B2                 call    ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::size(void)
.text$mn:000089B7                 cmp     eax, [ebp+arg_0]
.text$mn:000089BA                 ja      short loc_8A24
.text$mn:000089BC                 push    4B1h            ; unsigned int
.text$mn:000089C1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000089C6                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:000089CB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000089D0                 add     esp, 0Ch
.text$mn:000089D3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000089D8                 test    eax, eax
.text$mn:000089DA                 jz      short loc_89E0
.text$mn:000089DC                 xor     ecx, ecx
.text$mn:000089DE                 jnz     short loc_8A06
.text$mn:000089E0
.text$mn:000089E0 loc_89E0:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+32j
.text$mn:000089E0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000089E5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000089EA                 push    0
.text$mn:000089EC                 push    4B2h
.text$mn:000089F1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000089F6                 push    2
.text$mn:000089F8                 call    __CrtDbgReportW
.text$mn:000089FD                 add     esp, 18h
.text$mn:00008A00                 cmp     eax, 1
.text$mn:00008A03                 jnz     short loc_8A06
.text$mn:00008A05                 int     3               ; Trap to Debugger
.text$mn:00008A06
.text$mn:00008A06 loc_8A06:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+36j
.text$mn:00008A06                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+5Bj
.text$mn:00008A06                 push    0
.text$mn:00008A08                 push    4B2h
.text$mn:00008A0D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008A12                 push    offset ??_C@_1LC@OPANGMDH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAM?$AAa?$AAc?$AAr?$AAo?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu?$AAt?$AA?0@ ; "std::vector<class MacroShortcut,class s"...
.text$mn:00008A17                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008A1C                 call    __invalid_parameter
.text$mn:00008A21                 add     esp, 14h
.text$mn:00008A24
.text$mn:00008A24 loc_8A24:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+12j
.text$mn:00008A24                 imul    eax, [ebp+arg_0], 13Ch
.text$mn:00008A2B                 mov     ecx, [ebp+var_4]
.text$mn:00008A2E                 add     eax, [ecx+4]
.text$mn:00008A31                 mov     esp, ebp
.text$mn:00008A33                 pop     ebp
.text$mn:00008A34                 retn    4
.text$mn:00008A34 ??A?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAEAAVMacroShortcut@@I@Z endp
.text$mn:00008A34
.text$mn:00008A34 ; ---------------------------------------------------------------------------
.text$mn:00008A37                 align 4
.text$mn:00008A37 _text$mn        ends
.text$mn:00008A37
.text$mn:00008A38 ; ===========================================================================
.text$mn:00008A38
.text$mn:00008A38 ; Segment type: Pure code
.text$mn:00008A38 ; Segment permissions: Read/Execute
.text$mn:00008A38 _text$mn        segment para public 'CODE' use32
.text$mn:00008A38                 assume cs:_text$mn
.text$mn:00008A38                 ;org 8A38h
.text$mn:00008A38 ; COMDAT (pick any)
.text$mn:00008A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A38
.text$mn:00008A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A38
.text$mn:00008A38 ; Attributes: bp-based frame
.text$mn:00008A38
.text$mn:00008A38 ; public: class PluginCmdShortcut & __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::operator[](unsigned int)
.text$mn:00008A38                 public ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z
.text$mn:00008A38 ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z proc near
.text$mn:00008A38                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+6CCp
.text$mn:00008A38                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+6F4p ...
.text$mn:00008A38
.text$mn:00008A38 var_4           = dword ptr -4
.text$mn:00008A38 arg_0           = dword ptr  8
.text$mn:00008A38
.text$mn:00008A38                 push    ebp
.text$mn:00008A39                 mov     ebp, esp
.text$mn:00008A3B                 push    ecx
.text$mn:00008A3C                 mov     [ebp+var_4], ecx
.text$mn:00008A3F                 mov     ecx, [ebp+var_4]
.text$mn:00008A42                 call    ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::size(void)
.text$mn:00008A47                 cmp     eax, [ebp+arg_0]
.text$mn:00008A4A                 ja      short loc_8AB4
.text$mn:00008A4C                 push    4B1h            ; unsigned int
.text$mn:00008A51                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008A56                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00008A5B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008A60                 add     esp, 0Ch
.text$mn:00008A63                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008A68                 test    eax, eax
.text$mn:00008A6A                 jz      short loc_8A70
.text$mn:00008A6C                 xor     ecx, ecx
.text$mn:00008A6E                 jnz     short loc_8A96
.text$mn:00008A70
.text$mn:00008A70 loc_8A70:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+32j
.text$mn:00008A70                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008A75                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008A7A                 push    0
.text$mn:00008A7C                 push    4B2h
.text$mn:00008A81                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008A86                 push    2
.text$mn:00008A88                 call    __CrtDbgReportW
.text$mn:00008A8D                 add     esp, 18h
.text$mn:00008A90                 cmp     eax, 1
.text$mn:00008A93                 jnz     short loc_8A96
.text$mn:00008A95                 int     3               ; Trap to Debugger
.text$mn:00008A96
.text$mn:00008A96 loc_8A96:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+36j
.text$mn:00008A96                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+5Bj
.text$mn:00008A96                 push    0
.text$mn:00008A98                 push    4B2h
.text$mn:00008A9D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008AA2                 push    offset ??_C@_1MC@MGKONNEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAm?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt@ ; "std::vector<class PluginCmdShortcut,cla"...
.text$mn:00008AA7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008AAC                 call    __invalid_parameter
.text$mn:00008AB1                 add     esp, 14h
.text$mn:00008AB4
.text$mn:00008AB4 loc_8AB4:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+12j
.text$mn:00008AB4                 imul    eax, [ebp+arg_0], 150h
.text$mn:00008ABB                 mov     ecx, [ebp+var_4]
.text$mn:00008ABE                 add     eax, [ecx+4]
.text$mn:00008AC1                 mov     esp, ebp
.text$mn:00008AC3                 pop     ebp
.text$mn:00008AC4                 retn    4
.text$mn:00008AC4 ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEAAVPluginCmdShortcut@@I@Z endp
.text$mn:00008AC4
.text$mn:00008AC4 ; ---------------------------------------------------------------------------
.text$mn:00008AC7                 align 4
.text$mn:00008AC7 _text$mn        ends
.text$mn:00008AC7
.text$mn:00008AC8 ; ===========================================================================
.text$mn:00008AC8
.text$mn:00008AC8 ; Segment type: Pure code
.text$mn:00008AC8 ; Segment permissions: Read/Execute
.text$mn:00008AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00008AC8                 assume cs:_text$mn
.text$mn:00008AC8                 ;org 8AC8h
.text$mn:00008AC8 ; COMDAT (pick any)
.text$mn:00008AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008AC8
.text$mn:00008AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AC8
.text$mn:00008AC8 ; Attributes: bp-based frame
.text$mn:00008AC8
.text$mn:00008AC8 ; public: class ScintillaKeyMap & __thiscall std::vector<class ScintillaKeyMap, class std::allocator<class ScintillaKeyMap>>::operator[](unsigned int)
.text$mn:00008AC8                 public ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z
.text$mn:00008AC8 ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z proc near
.text$mn:00008AC8                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+8D1p
.text$mn:00008AC8                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+8F9p ...
.text$mn:00008AC8
.text$mn:00008AC8 var_4           = dword ptr -4
.text$mn:00008AC8 arg_0           = dword ptr  8
.text$mn:00008AC8
.text$mn:00008AC8                 push    ebp
.text$mn:00008AC9                 mov     ebp, esp
.text$mn:00008ACB                 push    ecx
.text$mn:00008ACC                 mov     [ebp+var_4], ecx
.text$mn:00008ACF                 mov     ecx, [ebp+var_4]
.text$mn:00008AD2                 call    ?size@?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QBEIXZ ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::size(void)
.text$mn:00008AD7                 cmp     eax, [ebp+arg_0]
.text$mn:00008ADA                 ja      short loc_8B44
.text$mn:00008ADC                 push    4B1h            ; unsigned int
.text$mn:00008AE1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008AE6                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00008AEB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008AF0                 add     esp, 0Ch
.text$mn:00008AF3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008AF8                 test    eax, eax
.text$mn:00008AFA                 jz      short loc_8B00
.text$mn:00008AFC                 xor     ecx, ecx
.text$mn:00008AFE                 jnz     short loc_8B26
.text$mn:00008B00
.text$mn:00008B00 loc_8B00:                               ; CODE XREF: std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)+32j
.text$mn:00008B00                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008B05                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008B0A                 push    0
.text$mn:00008B0C                 push    4B2h
.text$mn:00008B11                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008B16                 push    2
.text$mn:00008B18                 call    __CrtDbgReportW
.text$mn:00008B1D                 add     esp, 18h
.text$mn:00008B20                 cmp     eax, 1
.text$mn:00008B23                 jnz     short loc_8B26
.text$mn:00008B25                 int     3               ; Trap to Debugger
.text$mn:00008B26
.text$mn:00008B26 loc_8B26:                               ; CODE XREF: std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)+36j
.text$mn:00008B26                                         ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)+5Bj
.text$mn:00008B26                 push    0
.text$mn:00008B28                 push    4B2h
.text$mn:00008B2D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008B32                 push    offset ??_C@_1LK@EFECNNFA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAS?$AAc?$AAi?$AAn?$AAt?$AAi?$AAl?$AAl?$AAa?$AAK?$AAe?$AAy?$AAM?$AAa@ ; "std::vector<class ScintillaKeyMap,class"...
.text$mn:00008B37                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008B3C                 call    __invalid_parameter
.text$mn:00008B41                 add     esp, 14h
.text$mn:00008B44
.text$mn:00008B44 loc_8B44:                               ; CODE XREF: std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)+12j
.text$mn:00008B44                 imul    eax, [ebp+arg_0], 144h
.text$mn:00008B4B                 mov     ecx, [ebp+var_4]
.text$mn:00008B4E                 add     eax, [ecx+4]
.text$mn:00008B51                 mov     esp, ebp
.text$mn:00008B53                 pop     ebp
.text$mn:00008B54                 retn    4
.text$mn:00008B54 ??A?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QAEAAVScintillaKeyMap@@I@Z endp
.text$mn:00008B54
.text$mn:00008B54 ; ---------------------------------------------------------------------------
.text$mn:00008B57                 align 4
.text$mn:00008B57 _text$mn        ends
.text$mn:00008B57
.text$mn:00008B58 ; ===========================================================================
.text$mn:00008B58
.text$mn:00008B58 ; Segment type: Pure code
.text$mn:00008B58 ; Segment permissions: Read/Execute
.text$mn:00008B58 _text$mn        segment para public 'CODE' use32
.text$mn:00008B58                 assume cs:_text$mn
.text$mn:00008B58                 ;org 8B58h
.text$mn:00008B58 ; COMDAT (pick any)
.text$mn:00008B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B58
.text$mn:00008B58 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B58
.text$mn:00008B58 ; Attributes: bp-based frame
.text$mn:00008B58
.text$mn:00008B58 ; public: class UserCommand & __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::operator[](unsigned int)
.text$mn:00008B58                 public ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z
.text$mn:00008B58 ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z proc near
.text$mn:00008B58                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+542p
.text$mn:00008B58                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+56Ap ...
.text$mn:00008B58
.text$mn:00008B58 var_4           = dword ptr -4
.text$mn:00008B58 arg_0           = dword ptr  8
.text$mn:00008B58
.text$mn:00008B58                 push    ebp
.text$mn:00008B59                 mov     ebp, esp
.text$mn:00008B5B                 push    ecx
.text$mn:00008B5C                 mov     [ebp+var_4], ecx
.text$mn:00008B5F                 mov     ecx, [ebp+var_4]
.text$mn:00008B62                 call    ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::size(void)
.text$mn:00008B67                 cmp     eax, [ebp+arg_0]
.text$mn:00008B6A                 ja      short loc_8BD4
.text$mn:00008B6C                 push    4B1h            ; unsigned int
.text$mn:00008B71                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008B76                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00008B7B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008B80                 add     esp, 0Ch
.text$mn:00008B83                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008B88                 test    eax, eax
.text$mn:00008B8A                 jz      short loc_8B90
.text$mn:00008B8C                 xor     ecx, ecx
.text$mn:00008B8E                 jnz     short loc_8BB6
.text$mn:00008B90
.text$mn:00008B90 loc_8B90:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)+32j
.text$mn:00008B90                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008B95                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008B9A                 push    0
.text$mn:00008B9C                 push    4B2h
.text$mn:00008BA1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008BA6                 push    2
.text$mn:00008BA8                 call    __CrtDbgReportW
.text$mn:00008BAD                 add     esp, 18h
.text$mn:00008BB0                 cmp     eax, 1
.text$mn:00008BB3                 jnz     short loc_8BB6
.text$mn:00008BB5                 int     3               ; Trap to Debugger
.text$mn:00008BB6
.text$mn:00008BB6 loc_8BB6:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)+36j
.text$mn:00008BB6                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)+5Bj
.text$mn:00008BB6                 push    0
.text$mn:00008BB8                 push    4B2h
.text$mn:00008BBD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008BC2                 push    offset ??_C@_1KK@IAHNKIAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAU?$AAs?$AAe?$AAr?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?0?$AAc?$AAl@ ; "std::vector<class UserCommand,class std"...
.text$mn:00008BC7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008BCC                 call    __invalid_parameter
.text$mn:00008BD1                 add     esp, 14h
.text$mn:00008BD4
.text$mn:00008BD4 loc_8BD4:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)+12j
.text$mn:00008BD4                 imul    eax, [ebp+arg_0], 148h
.text$mn:00008BDB                 mov     ecx, [ebp+var_4]
.text$mn:00008BDE                 add     eax, [ecx+4]
.text$mn:00008BE1                 mov     esp, ebp
.text$mn:00008BE3                 pop     ebp
.text$mn:00008BE4                 retn    4
.text$mn:00008BE4 ??A?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEAAVUserCommand@@I@Z endp
.text$mn:00008BE4
.text$mn:00008BE4 ; ---------------------------------------------------------------------------
.text$mn:00008BE7                 align 4
.text$mn:00008BE7 _text$mn        ends
.text$mn:00008BE7
.text$mn:00008BE8 ; ===========================================================================
.text$mn:00008BE8
.text$mn:00008BE8 ; Segment type: Pure code
.text$mn:00008BE8 ; Segment permissions: Read/Execute
.text$mn:00008BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00008BE8                 assume cs:_text$mn
.text$mn:00008BE8                 ;org 8BE8h
.text$mn:00008BE8 ; COMDAT (pick any)
.text$mn:00008BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008BE8
.text$mn:00008BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008BE8
.text$mn:00008BE8 ; Attributes: bp-based frame
.text$mn:00008BE8
.text$mn:00008BE8 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>::operator+(int)const
.text$mn:00008BE8                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00008BE8 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00008BE8                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+B2Bp
.text$mn:00008BE8
.text$mn:00008BE8 var_20          = byte ptr -20h
.text$mn:00008BE8 var_14          = dword ptr -14h
.text$mn:00008BE8 var_10          = dword ptr -10h
.text$mn:00008BE8 var_C           = dword ptr -0Ch
.text$mn:00008BE8 var_4           = dword ptr -4
.text$mn:00008BE8 arg_0           = dword ptr  8
.text$mn:00008BE8 arg_4           = dword ptr  0Ch
.text$mn:00008BE8
.text$mn:00008BE8                 push    ebp
.text$mn:00008BE9                 mov     ebp, esp
.text$mn:00008BEB                 push    0FFFFFFFFh
.text$mn:00008BED                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00008BF2                 mov     eax, large fs:0
.text$mn:00008BF8                 push    eax
.text$mn:00008BF9                 sub     esp, 14h
.text$mn:00008BFC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008C01                 xor     eax, ebp
.text$mn:00008C03                 push    eax
.text$mn:00008C04                 lea     eax, [ebp+var_C]
.text$mn:00008C07                 mov     large fs:0, eax
.text$mn:00008C0D                 mov     [ebp+var_14], ecx
.text$mn:00008C10                 mov     [ebp+var_10], 0
.text$mn:00008C17                 mov     eax, [ebp+var_14]
.text$mn:00008C1A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008C1B                 lea     ecx, [ebp+var_20]
.text$mn:00008C1E                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)
.text$mn:00008C23                 mov     [ebp+var_4], 1
.text$mn:00008C2A                 mov     ecx, [ebp+arg_4]
.text$mn:00008C2D                 push    ecx
.text$mn:00008C2E                 lea     ecx, [ebp+var_20]
.text$mn:00008C31                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)
.text$mn:00008C36                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008C37                 mov     ecx, [ebp+arg_0]
.text$mn:00008C3A                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)
.text$mn:00008C3F                 mov     edx, [ebp+var_10]
.text$mn:00008C42                 or      edx, 1
.text$mn:00008C45                 mov     [ebp+var_10], edx
.text$mn:00008C48                 mov     byte ptr [ebp+var_4], 0
.text$mn:00008C4C                 lea     ecx, [ebp+var_20]
.text$mn:00008C4F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$mn:00008C54                 mov     eax, [ebp+arg_0]
.text$mn:00008C57                 mov     ecx, [ebp+var_C]
.text$mn:00008C5A                 mov     large fs:0, ecx
.text$mn:00008C61                 pop     ecx
.text$mn:00008C62                 mov     esp, ebp
.text$mn:00008C64                 pop     ebp
.text$mn:00008C65                 retn    8
.text$mn:00008C65 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00008C65
.text$mn:00008C65 _text$mn        ends
.text$mn:00008C65
.text$x:00008C68 ; ===========================================================================
.text$x:00008C68
.text$x:00008C68 ; Segment type: Pure code
.text$x:00008C68 ; Segment permissions: Read/Execute
.text$x:00008C68 _text$x         segment para public 'CODE' use32
.text$x:00008C68                 assume cs:_text$x
.text$x:00008C68                 ;org 8C68h
.text$x:00008C68 ; COMDAT (pick associative to section at 8BE8)
.text$x:00008C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008C68
.text$x:00008C68 ; =============== S U B R O U T I N E =======================================
.text$x:00008C68
.text$x:00008C68
.text$x:00008C68 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00008C68                                         ; DATA XREF: .xdata$x:0000E004o
.text$x:00008C68                 lea     ecx, [ebp-20h]
.text$x:00008C6B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:00008C6B __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00008C6B
.text$x:00008C70
.text$x:00008C70 ; =============== S U B R O U T I N E =======================================
.text$x:00008C70
.text$x:00008C70
.text$x:00008C70 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00008C70                                         ; DATA XREF: .xdata$x:0000DFFCo
.text$x:00008C70                 mov     eax, [ebp-10h]
.text$x:00008C73                 and     eax, 1
.text$x:00008C76                 jz      $LN5_1
.text$x:00008C7C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008C80                 mov     ecx, [ebp+8]
.text$x:00008C83                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:00008C88 ; ---------------------------------------------------------------------------
.text$x:00008C88
.text$x:00008C88 $LN5_1:                                 ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00008C88                 retn
.text$x:00008C88 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00008C88
.text$x:00008C89
.text$x:00008C89 ; =============== S U B R O U T I N E =======================================
.text$x:00008C89
.text$x:00008C89
.text$x:00008C89 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00008C89                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+(int)+5o
.text$x:00008C89
.text$x:00008C89 arg_4           = dword ptr  8
.text$x:00008C89
.text$x:00008C89                 mov     edx, [esp+arg_4]
.text$x:00008C8D                 lea     eax, [edx+0Ch]
.text$x:00008C90                 mov     ecx, [edx-18h]
.text$x:00008C93                 xor     ecx, eax
.text$x:00008C95                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008C9A                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00008C9F                 jmp     ___CxxFrameHandler3
.text$x:00008C9F __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00008C9F
.text$x:00008C9F _text$x         ends
.text$x:00008C9F
.text$mn:00008CA4 ; ===========================================================================
.text$mn:00008CA4
.text$mn:00008CA4 ; Segment type: Pure code
.text$mn:00008CA4 ; Segment permissions: Read/Execute
.text$mn:00008CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00008CA4                 assume cs:_text$mn
.text$mn:00008CA4                 ;org 8CA4h
.text$mn:00008CA4 ; COMDAT (pick any)
.text$mn:00008CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008CA4
.text$mn:00008CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008CA4
.text$mn:00008CA4 ; Attributes: bp-based frame
.text$mn:00008CA4
.text$mn:00008CA4 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>::operator+(int)const
.text$mn:00008CA4                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00008CA4 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00008CA4                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+D0Ap
.text$mn:00008CA4
.text$mn:00008CA4 var_20          = byte ptr -20h
.text$mn:00008CA4 var_14          = dword ptr -14h
.text$mn:00008CA4 var_10          = dword ptr -10h
.text$mn:00008CA4 var_C           = dword ptr -0Ch
.text$mn:00008CA4 var_4           = dword ptr -4
.text$mn:00008CA4 arg_0           = dword ptr  8
.text$mn:00008CA4 arg_4           = dword ptr  0Ch
.text$mn:00008CA4
.text$mn:00008CA4                 push    ebp
.text$mn:00008CA5                 mov     ebp, esp
.text$mn:00008CA7                 push    0FFFFFFFFh
.text$mn:00008CA9                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00008CAE                 mov     eax, large fs:0
.text$mn:00008CB4                 push    eax
.text$mn:00008CB5                 sub     esp, 14h
.text$mn:00008CB8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008CBD                 xor     eax, ebp
.text$mn:00008CBF                 push    eax
.text$mn:00008CC0                 lea     eax, [ebp+var_C]
.text$mn:00008CC3                 mov     large fs:0, eax
.text$mn:00008CC9                 mov     [ebp+var_14], ecx
.text$mn:00008CCC                 mov     [ebp+var_10], 0
.text$mn:00008CD3                 mov     eax, [ebp+var_14]
.text$mn:00008CD6                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008CD7                 lea     ecx, [ebp+var_20]
.text$mn:00008CDA                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)
.text$mn:00008CDF                 mov     [ebp+var_4], 1
.text$mn:00008CE6                 mov     ecx, [ebp+arg_4]
.text$mn:00008CE9                 push    ecx
.text$mn:00008CEA                 lea     ecx, [ebp+var_20]
.text$mn:00008CED                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)
.text$mn:00008CF2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008CF3                 mov     ecx, [ebp+arg_0]
.text$mn:00008CF6                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)
.text$mn:00008CFB                 mov     edx, [ebp+var_10]
.text$mn:00008CFE                 or      edx, 1
.text$mn:00008D01                 mov     [ebp+var_10], edx
.text$mn:00008D04                 mov     byte ptr [ebp+var_4], 0
.text$mn:00008D08                 lea     ecx, [ebp+var_20]
.text$mn:00008D0B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$mn:00008D10                 mov     eax, [ebp+arg_0]
.text$mn:00008D13                 mov     ecx, [ebp+var_C]
.text$mn:00008D16                 mov     large fs:0, ecx
.text$mn:00008D1D                 pop     ecx
.text$mn:00008D1E                 mov     esp, ebp
.text$mn:00008D20                 pop     ebp
.text$mn:00008D21                 retn    8
.text$mn:00008D21 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00008D21
.text$mn:00008D21 _text$mn        ends
.text$mn:00008D21
.text$x:00008D24 ; ===========================================================================
.text$x:00008D24
.text$x:00008D24 ; Segment type: Pure code
.text$x:00008D24 ; Segment permissions: Read/Execute
.text$x:00008D24 _text$x         segment para public 'CODE' use32
.text$x:00008D24                 assume cs:_text$x
.text$x:00008D24                 ;org 8D24h
.text$x:00008D24 ; COMDAT (pick associative to section at 8CA4)
.text$x:00008D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008D24
.text$x:00008D24 ; =============== S U B R O U T I N E =======================================
.text$x:00008D24
.text$x:00008D24
.text$x:00008D24 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00008D24                                         ; DATA XREF: .xdata$x:0000E1C4o
.text$x:00008D24                 lea     ecx, [ebp-20h]
.text$x:00008D27                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:00008D27 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00008D27
.text$x:00008D2C
.text$x:00008D2C ; =============== S U B R O U T I N E =======================================
.text$x:00008D2C
.text$x:00008D2C
.text$x:00008D2C __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00008D2C                                         ; DATA XREF: .xdata$x:0000E1BCo
.text$x:00008D2C                 mov     eax, [ebp-10h]
.text$x:00008D2F                 and     eax, 1
.text$x:00008D32                 jz      $LN5_2
.text$x:00008D38                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008D3C                 mov     ecx, [ebp+8]
.text$x:00008D3F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:00008D44 ; ---------------------------------------------------------------------------
.text$x:00008D44
.text$x:00008D44 $LN5_2:                                 ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00008D44                 retn
.text$x:00008D44 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00008D44
.text$x:00008D45
.text$x:00008D45 ; =============== S U B R O U T I N E =======================================
.text$x:00008D45
.text$x:00008D45
.text$x:00008D45 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00008D45                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+(int)+5o
.text$x:00008D45
.text$x:00008D45 arg_4           = dword ptr  8
.text$x:00008D45
.text$x:00008D45                 mov     edx, [esp+arg_4]
.text$x:00008D49                 lea     eax, [edx+0Ch]
.text$x:00008D4C                 mov     ecx, [edx-18h]
.text$x:00008D4F                 xor     ecx, eax
.text$x:00008D51                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008D56                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00008D5B                 jmp     ___CxxFrameHandler3
.text$x:00008D5B __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00008D5B
.text$x:00008D5B _text$x         ends
.text$x:00008D5B
.text$mn:00008D60 ; ===========================================================================
.text$mn:00008D60
.text$mn:00008D60 ; Segment type: Pure code
.text$mn:00008D60 ; Segment permissions: Read/Execute
.text$mn:00008D60 _text$mn        segment para public 'CODE' use32
.text$mn:00008D60                 assume cs:_text$mn
.text$mn:00008D60                 ;org 8D60h
.text$mn:00008D60 ; COMDAT (pick any)
.text$mn:00008D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D60
.text$mn:00008D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D60
.text$mn:00008D60 ; Attributes: bp-based frame
.text$mn:00008D60
.text$mn:00008D60 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>::operator+=(int)
.text$mn:00008D60                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00008D60 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00008D60                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+Ep
.text$mn:00008D60
.text$mn:00008D60 var_4           = dword ptr -4
.text$mn:00008D60 arg_0           = dword ptr  8
.text$mn:00008D60
.text$mn:00008D60                 push    ebp
.text$mn:00008D61                 mov     ebp, esp
.text$mn:00008D63                 push    ecx
.text$mn:00008D64                 push    esi
.text$mn:00008D65                 mov     [ebp+var_4], ecx
.text$mn:00008D68                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008D6B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008D70                 test    eax, eax
.text$mn:00008D72                 jz      short loc_8DA8
.text$mn:00008D74                 imul    esi, [ebp+arg_0], 13Ch
.text$mn:00008D7B                 mov     eax, [ebp+var_4]
.text$mn:00008D7E                 add     esi, [eax+8]
.text$mn:00008D81                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008D84                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008D89                 cmp     esi, [eax+4]
.text$mn:00008D8C                 jb      short loc_8DA8
.text$mn:00008D8E                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008D91                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008D96                 imul    ecx, [ebp+arg_0], 13Ch
.text$mn:00008D9D                 mov     edx, [ebp+var_4]
.text$mn:00008DA0                 add     ecx, [edx+8]
.text$mn:00008DA3                 cmp     [eax+8], ecx
.text$mn:00008DA6                 jnb     short loc_8E10
.text$mn:00008DA8
.text$mn:00008DA8 loc_8DA8:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+12j
.text$mn:00008DA8                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+2Cj
.text$mn:00008DA8                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:00008DAD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008DB2                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00008DB7                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008DBC                 add     esp, 0Ch
.text$mn:00008DBF                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008DC4                 test    eax, eax
.text$mn:00008DC6                 jz      short loc_8DCC
.text$mn:00008DC8                 xor     ecx, ecx
.text$mn:00008DCA                 jnz     short loc_8DF2
.text$mn:00008DCC
.text$mn:00008DCC loc_8DCC:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+66j
.text$mn:00008DCC                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008DD1                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008DD6                 push    0
.text$mn:00008DD8                 push    0A0h ; 'á'
.text$mn:00008DDD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008DE2                 push    2
.text$mn:00008DE4                 call    __CrtDbgReportW
.text$mn:00008DE9                 add     esp, 18h
.text$mn:00008DEC                 cmp     eax, 1
.text$mn:00008DEF                 jnz     short loc_8DF2
.text$mn:00008DF1                 int     3               ; Trap to Debugger
.text$mn:00008DF2
.text$mn:00008DF2 loc_8DF2:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+6Aj
.text$mn:00008DF2                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+8Fj
.text$mn:00008DF2                 push    0
.text$mn:00008DF4                 push    0A0h ; 'á'
.text$mn:00008DF9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008DFE                 push    offset ??_C@_1OG@IKOELCPO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00008E03                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008E08                 call    __invalid_parameter
.text$mn:00008E0D                 add     esp, 14h
.text$mn:00008E10
.text$mn:00008E10 loc_8E10:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+46j
.text$mn:00008E10                 imul    eax, [ebp+arg_0], 13Ch
.text$mn:00008E17                 mov     ecx, [ebp+var_4]
.text$mn:00008E1A                 add     eax, [ecx+8]
.text$mn:00008E1D                 mov     edx, [ebp+var_4]
.text$mn:00008E20                 mov     [edx+8], eax
.text$mn:00008E23                 mov     eax, [ebp+var_4]
.text$mn:00008E26                 pop     esi
.text$mn:00008E27                 mov     esp, ebp
.text$mn:00008E29                 pop     ebp
.text$mn:00008E2A                 retn    4
.text$mn:00008E2A ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00008E2A
.text$mn:00008E2A ; ---------------------------------------------------------------------------
.text$mn:00008E2D                 align 10h
.text$mn:00008E2D _text$mn        ends
.text$mn:00008E2D
.text$mn:00008E30 ; ===========================================================================
.text$mn:00008E30
.text$mn:00008E30 ; Segment type: Pure code
.text$mn:00008E30 ; Segment permissions: Read/Execute
.text$mn:00008E30 _text$mn        segment para public 'CODE' use32
.text$mn:00008E30                 assume cs:_text$mn
.text$mn:00008E30                 ;org 8E30h
.text$mn:00008E30 ; COMDAT (pick any)
.text$mn:00008E30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E30
.text$mn:00008E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E30
.text$mn:00008E30 ; Attributes: bp-based frame
.text$mn:00008E30
.text$mn:00008E30 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>::operator+=(int)
.text$mn:00008E30                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00008E30 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00008E30                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+Ep
.text$mn:00008E30
.text$mn:00008E30 var_4           = dword ptr -4
.text$mn:00008E30 arg_0           = dword ptr  8
.text$mn:00008E30
.text$mn:00008E30                 push    ebp
.text$mn:00008E31                 mov     ebp, esp
.text$mn:00008E33                 push    ecx
.text$mn:00008E34                 push    esi
.text$mn:00008E35                 mov     [ebp+var_4], ecx
.text$mn:00008E38                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008E3B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008E40                 test    eax, eax
.text$mn:00008E42                 jz      short loc_8E78
.text$mn:00008E44                 imul    esi, [ebp+arg_0], 148h
.text$mn:00008E4B                 mov     eax, [ebp+var_4]
.text$mn:00008E4E                 add     esi, [eax+8]
.text$mn:00008E51                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008E54                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008E59                 cmp     esi, [eax+4]
.text$mn:00008E5C                 jb      short loc_8E78
.text$mn:00008E5E                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008E61                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008E66                 imul    ecx, [ebp+arg_0], 148h
.text$mn:00008E6D                 mov     edx, [ebp+var_4]
.text$mn:00008E70                 add     ecx, [edx+8]
.text$mn:00008E73                 cmp     [eax+8], ecx
.text$mn:00008E76                 jnb     short loc_8EE0
.text$mn:00008E78
.text$mn:00008E78 loc_8E78:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+12j
.text$mn:00008E78                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+2Cj
.text$mn:00008E78                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:00008E7D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008E82                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00008E87                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008E8C                 add     esp, 0Ch
.text$mn:00008E8F                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00008E94                 test    eax, eax
.text$mn:00008E96                 jz      short loc_8E9C
.text$mn:00008E98                 xor     ecx, ecx
.text$mn:00008E9A                 jnz     short loc_8EC2
.text$mn:00008E9C
.text$mn:00008E9C loc_8E9C:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+66j
.text$mn:00008E9C                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00008EA1                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00008EA6                 push    0
.text$mn:00008EA8                 push    0A0h ; 'á'
.text$mn:00008EAD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008EB2                 push    2
.text$mn:00008EB4                 call    __CrtDbgReportW
.text$mn:00008EB9                 add     esp, 18h
.text$mn:00008EBC                 cmp     eax, 1
.text$mn:00008EBF                 jnz     short loc_8EC2
.text$mn:00008EC1                 int     3               ; Trap to Debugger
.text$mn:00008EC2
.text$mn:00008EC2 loc_8EC2:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+6Aj
.text$mn:00008EC2                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+8Fj
.text$mn:00008EC2                 push    0
.text$mn:00008EC4                 push    0A0h ; 'á'
.text$mn:00008EC9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008ECE                 push    offset ??_C@_1OC@IGLELAPI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00008ED3                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00008ED8                 call    __invalid_parameter
.text$mn:00008EDD                 add     esp, 14h
.text$mn:00008EE0
.text$mn:00008EE0 loc_8EE0:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+46j
.text$mn:00008EE0                 imul    eax, [ebp+arg_0], 148h
.text$mn:00008EE7                 mov     ecx, [ebp+var_4]
.text$mn:00008EEA                 add     eax, [ecx+8]
.text$mn:00008EED                 mov     edx, [ebp+var_4]
.text$mn:00008EF0                 mov     [edx+8], eax
.text$mn:00008EF3                 mov     eax, [ebp+var_4]
.text$mn:00008EF6                 pop     esi
.text$mn:00008EF7                 mov     esp, ebp
.text$mn:00008EF9                 pop     ebp
.text$mn:00008EFA                 retn    4
.text$mn:00008EFA ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00008EFA
.text$mn:00008EFA ; ---------------------------------------------------------------------------
.text$mn:00008EFD                 align 10h
.text$mn:00008EFD _text$mn        ends
.text$mn:00008EFD
.text$mn:00008F00 ; ===========================================================================
.text$mn:00008F00
.text$mn:00008F00 ; Segment type: Pure code
.text$mn:00008F00 ; Segment permissions: Read/Execute
.text$mn:00008F00 _text$mn        segment para public 'CODE' use32
.text$mn:00008F00                 assume cs:_text$mn
.text$mn:00008F00                 ;org 8F00h
.text$mn:00008F00 ; COMDAT (pick any)
.text$mn:00008F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F00
.text$mn:00008F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F00
.text$mn:00008F00 ; Attributes: bp-based frame
.text$mn:00008F00
.text$mn:00008F00 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>::operator+=(int)
.text$mn:00008F00                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00008F00 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00008F00                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+(int)+49p
.text$mn:00008F00
.text$mn:00008F00 var_4           = dword ptr -4
.text$mn:00008F00 arg_0           = dword ptr  8
.text$mn:00008F00
.text$mn:00008F00                 push    ebp
.text$mn:00008F01                 mov     ebp, esp
.text$mn:00008F03                 push    ecx
.text$mn:00008F04                 mov     [ebp+var_4], ecx
.text$mn:00008F07                 mov     eax, [ebp+arg_0]
.text$mn:00008F0A                 push    eax
.text$mn:00008F0B                 mov     ecx, [ebp+var_4]
.text$mn:00008F0E                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)
.text$mn:00008F13                 mov     eax, [ebp+var_4]
.text$mn:00008F16                 mov     esp, ebp
.text$mn:00008F18                 pop     ebp
.text$mn:00008F19                 retn    4
.text$mn:00008F19 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00008F19
.text$mn:00008F19 _text$mn        ends
.text$mn:00008F19
.text$mn:00008F1C ; ===========================================================================
.text$mn:00008F1C
.text$mn:00008F1C ; Segment type: Pure code
.text$mn:00008F1C ; Segment permissions: Read/Execute
.text$mn:00008F1C _text$mn        segment para public 'CODE' use32
.text$mn:00008F1C                 assume cs:_text$mn
.text$mn:00008F1C                 ;org 8F1Ch
.text$mn:00008F1C ; COMDAT (pick any)
.text$mn:00008F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F1C
.text$mn:00008F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00008F1C
.text$mn:00008F1C ; Attributes: bp-based frame
.text$mn:00008F1C
.text$mn:00008F1C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>::operator+=(int)
.text$mn:00008F1C                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00008F1C ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00008F1C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+(int)+49p
.text$mn:00008F1C
.text$mn:00008F1C var_4           = dword ptr -4
.text$mn:00008F1C arg_0           = dword ptr  8
.text$mn:00008F1C
.text$mn:00008F1C                 push    ebp
.text$mn:00008F1D                 mov     ebp, esp
.text$mn:00008F1F                 push    ecx
.text$mn:00008F20                 mov     [ebp+var_4], ecx
.text$mn:00008F23                 mov     eax, [ebp+arg_0]
.text$mn:00008F26                 push    eax
.text$mn:00008F27                 mov     ecx, [ebp+var_4]
.text$mn:00008F2A                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)
.text$mn:00008F2F                 mov     eax, [ebp+var_4]
.text$mn:00008F32                 mov     esp, ebp
.text$mn:00008F34                 pop     ebp
.text$mn:00008F35                 retn    4
.text$mn:00008F35 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00008F35
.text$mn:00008F35 _text$mn        ends
.text$mn:00008F35
.text$mn:00008F38 ; ===========================================================================
.text$mn:00008F38
.text$mn:00008F38 ; Segment type: Pure code
.text$mn:00008F38 ; Segment permissions: Read/Execute
.text$mn:00008F38 _text$mn        segment para public 'CODE' use32
.text$mn:00008F38                 assume cs:_text$mn
.text$mn:00008F38                 ;org 8F38h
.text$mn:00008F38 ; COMDAT (pick any)
.text$mn:00008F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F38
.text$mn:00008F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F38
.text$mn:00008F38 ; Attributes: bp-based frame
.text$mn:00008F38
.text$mn:00008F38 ; public: virtual void * __thiscall CommandShortcut::`scalar deleting destructor'(unsigned int)
.text$mn:00008F38                 public ??_GCommandShortcut@@UAEPAXI@Z
.text$mn:00008F38 ??_GCommandShortcut@@UAEPAXI@Z proc near
.text$mn:00008F38
.text$mn:00008F38 var_4           = dword ptr -4
.text$mn:00008F38 arg_0           = dword ptr  8
.text$mn:00008F38
.text$mn:00008F38                 push    ebp
.text$mn:00008F39                 mov     ebp, esp
.text$mn:00008F3B                 push    ecx
.text$mn:00008F3C                 mov     [ebp+var_4], ecx
.text$mn:00008F3F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008F42                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:00008F47                 mov     eax, [ebp+arg_0]
.text$mn:00008F4A                 and     eax, 1
.text$mn:00008F4D                 jz      short loc_8F5B
.text$mn:00008F4F                 mov     ecx, [ebp+var_4]
.text$mn:00008F52                 push    ecx             ; void *
.text$mn:00008F53                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008F58                 add     esp, 4
.text$mn:00008F5B
.text$mn:00008F5B loc_8F5B:                               ; CODE XREF: CommandShortcut::`scalar deleting destructor'(uint)+15j
.text$mn:00008F5B                 mov     eax, [ebp+var_4]
.text$mn:00008F5E                 mov     esp, ebp
.text$mn:00008F60                 pop     ebp
.text$mn:00008F61                 retn    4
.text$mn:00008F61 ??_GCommandShortcut@@UAEPAXI@Z endp
.text$mn:00008F61
.text$mn:00008F61 _text$mn        ends
.text$mn:00008F61
.text$mn:00008F64 ; ===========================================================================
.text$mn:00008F64
.text$mn:00008F64 ; Segment type: Pure code
.text$mn:00008F64 ; Segment permissions: Read/Execute
.text$mn:00008F64 _text$mn        segment para public 'CODE' use32
.text$mn:00008F64                 assume cs:_text$mn
.text$mn:00008F64                 ;org 8F64h
.text$mn:00008F64 ; COMDAT (pick any)
.text$mn:00008F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F64
.text$mn:00008F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F64
.text$mn:00008F64 ; Attributes: bp-based frame
.text$mn:00008F64
.text$mn:00008F64 ; public: virtual void * __thiscall MacroShortcut::`scalar deleting destructor'(unsigned int)
.text$mn:00008F64                 public ??_GMacroShortcut@@UAEPAXI@Z
.text$mn:00008F64 ??_GMacroShortcut@@UAEPAXI@Z proc near
.text$mn:00008F64
.text$mn:00008F64 var_4           = dword ptr -4
.text$mn:00008F64 arg_0           = dword ptr  8
.text$mn:00008F64
.text$mn:00008F64                 push    ebp
.text$mn:00008F65                 mov     ebp, esp
.text$mn:00008F67                 push    ecx
.text$mn:00008F68                 mov     [ebp+var_4], ecx
.text$mn:00008F6B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008F6E                 call    ??1MacroShortcut@@UAE@XZ ; MacroShortcut::~MacroShortcut(void)
.text$mn:00008F73                 mov     eax, [ebp+arg_0]
.text$mn:00008F76                 and     eax, 1
.text$mn:00008F79                 jz      short loc_8F87
.text$mn:00008F7B                 mov     ecx, [ebp+var_4]
.text$mn:00008F7E                 push    ecx             ; void *
.text$mn:00008F7F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008F84                 add     esp, 4
.text$mn:00008F87
.text$mn:00008F87 loc_8F87:                               ; CODE XREF: MacroShortcut::`scalar deleting destructor'(uint)+15j
.text$mn:00008F87                 mov     eax, [ebp+var_4]
.text$mn:00008F8A                 mov     esp, ebp
.text$mn:00008F8C                 pop     ebp
.text$mn:00008F8D                 retn    4
.text$mn:00008F8D ??_GMacroShortcut@@UAEPAXI@Z endp
.text$mn:00008F8D
.text$mn:00008F8D _text$mn        ends
.text$mn:00008F8D
.text$mn:00008F90 ; ===========================================================================
.text$mn:00008F90
.text$mn:00008F90 ; Segment type: Pure code
.text$mn:00008F90 ; Segment permissions: Read/Execute
.text$mn:00008F90 _text$mn        segment para public 'CODE' use32
.text$mn:00008F90                 assume cs:_text$mn
.text$mn:00008F90                 ;org 8F90h
.text$mn:00008F90 ; COMDAT (pick any)
.text$mn:00008F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F90
.text$mn:00008F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F90
.text$mn:00008F90 ; Attributes: bp-based frame
.text$mn:00008F90
.text$mn:00008F90 ; public: void * __thiscall MenuItemUnit::`scalar deleting destructor'(unsigned int)
.text$mn:00008F90                 public ??_GMenuItemUnit@@QAEPAXI@Z
.text$mn:00008F90 ??_GMenuItemUnit@@QAEPAXI@Z proc near   ; CODE XREF: std::allocator<MenuItemUnit>::destroy<MenuItemUnit>(MenuItemUnit *)+Cp
.text$mn:00008F90
.text$mn:00008F90 var_4           = dword ptr -4
.text$mn:00008F90 arg_0           = dword ptr  8
.text$mn:00008F90
.text$mn:00008F90                 push    ebp
.text$mn:00008F91                 mov     ebp, esp
.text$mn:00008F93                 push    ecx
.text$mn:00008F94                 mov     [ebp+var_4], ecx
.text$mn:00008F97                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008F9A                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00008F9F                 mov     eax, [ebp+arg_0]
.text$mn:00008FA2                 and     eax, 1
.text$mn:00008FA5                 jz      short loc_8FB3
.text$mn:00008FA7                 mov     ecx, [ebp+var_4]
.text$mn:00008FAA                 push    ecx             ; void *
.text$mn:00008FAB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008FB0                 add     esp, 4
.text$mn:00008FB3
.text$mn:00008FB3 loc_8FB3:                               ; CODE XREF: MenuItemUnit::`scalar deleting destructor'(uint)+15j
.text$mn:00008FB3                 mov     eax, [ebp+var_4]
.text$mn:00008FB6                 mov     esp, ebp
.text$mn:00008FB8                 pop     ebp
.text$mn:00008FB9                 retn    4
.text$mn:00008FB9 ??_GMenuItemUnit@@QAEPAXI@Z endp
.text$mn:00008FB9
.text$mn:00008FB9 _text$mn        ends
.text$mn:00008FB9
.text$mn:00008FBC ; ===========================================================================
.text$mn:00008FBC
.text$mn:00008FBC ; Segment type: Pure code
.text$mn:00008FBC ; Segment permissions: Read/Execute
.text$mn:00008FBC _text$mn        segment para public 'CODE' use32
.text$mn:00008FBC                 assume cs:_text$mn
.text$mn:00008FBC                 ;org 8FBCh
.text$mn:00008FBC ; COMDAT (pick any)
.text$mn:00008FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FBC
.text$mn:00008FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00008FBC
.text$mn:00008FBC ; Attributes: bp-based frame
.text$mn:00008FBC
.text$mn:00008FBC ; public: virtual void * __thiscall PluginCmdShortcut::`scalar deleting destructor'(unsigned int)
.text$mn:00008FBC                 public ??_GPluginCmdShortcut@@UAEPAXI@Z
.text$mn:00008FBC ??_GPluginCmdShortcut@@UAEPAXI@Z proc near
.text$mn:00008FBC
.text$mn:00008FBC var_4           = dword ptr -4
.text$mn:00008FBC arg_0           = dword ptr  8
.text$mn:00008FBC
.text$mn:00008FBC                 push    ebp
.text$mn:00008FBD                 mov     ebp, esp
.text$mn:00008FBF                 push    ecx
.text$mn:00008FC0                 mov     [ebp+var_4], ecx
.text$mn:00008FC3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008FC6                 call    ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$mn:00008FCB                 mov     eax, [ebp+arg_0]
.text$mn:00008FCE                 and     eax, 1
.text$mn:00008FD1                 jz      short loc_8FDF
.text$mn:00008FD3                 mov     ecx, [ebp+var_4]
.text$mn:00008FD6                 push    ecx             ; void *
.text$mn:00008FD7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008FDC                 add     esp, 4
.text$mn:00008FDF
.text$mn:00008FDF loc_8FDF:                               ; CODE XREF: PluginCmdShortcut::`scalar deleting destructor'(uint)+15j
.text$mn:00008FDF                 mov     eax, [ebp+var_4]
.text$mn:00008FE2                 mov     esp, ebp
.text$mn:00008FE4                 pop     ebp
.text$mn:00008FE5                 retn    4
.text$mn:00008FE5 ??_GPluginCmdShortcut@@UAEPAXI@Z endp
.text$mn:00008FE5
.text$mn:00008FE5 _text$mn        ends
.text$mn:00008FE5
.text$mn:00008FE8 ; ===========================================================================
.text$mn:00008FE8
.text$mn:00008FE8 ; Segment type: Pure code
.text$mn:00008FE8 ; Segment permissions: Read/Execute
.text$mn:00008FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00008FE8                 assume cs:_text$mn
.text$mn:00008FE8                 ;org 8FE8h
.text$mn:00008FE8 ; COMDAT (pick any)
.text$mn:00008FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FE8
.text$mn:00008FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008FE8
.text$mn:00008FE8 ; Attributes: bp-based frame
.text$mn:00008FE8
.text$mn:00008FE8 ; public: virtual void * __thiscall ScintillaKeyMap::`scalar deleting destructor'(unsigned int)
.text$mn:00008FE8                 public ??_GScintillaKeyMap@@UAEPAXI@Z
.text$mn:00008FE8 ??_GScintillaKeyMap@@UAEPAXI@Z proc near
.text$mn:00008FE8
.text$mn:00008FE8 var_4           = dword ptr -4
.text$mn:00008FE8 arg_0           = dword ptr  8
.text$mn:00008FE8
.text$mn:00008FE8                 push    ebp
.text$mn:00008FE9                 mov     ebp, esp
.text$mn:00008FEB                 push    ecx
.text$mn:00008FEC                 mov     [ebp+var_4], ecx
.text$mn:00008FEF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00008FF2                 call    ??1ScintillaKeyMap@@UAE@XZ ; ScintillaKeyMap::~ScintillaKeyMap(void)
.text$mn:00008FF7                 mov     eax, [ebp+arg_0]
.text$mn:00008FFA                 and     eax, 1
.text$mn:00008FFD                 jz      short loc_900B
.text$mn:00008FFF                 mov     ecx, [ebp+var_4]
.text$mn:00009002                 push    ecx             ; void *
.text$mn:00009003                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00009008                 add     esp, 4
.text$mn:0000900B
.text$mn:0000900B loc_900B:                               ; CODE XREF: ScintillaKeyMap::`scalar deleting destructor'(uint)+15j
.text$mn:0000900B                 mov     eax, [ebp+var_4]
.text$mn:0000900E                 mov     esp, ebp
.text$mn:00009010                 pop     ebp
.text$mn:00009011                 retn    4
.text$mn:00009011 ??_GScintillaKeyMap@@UAEPAXI@Z endp
.text$mn:00009011
.text$mn:00009011 _text$mn        ends
.text$mn:00009011
.text$mn:00009014 ; ===========================================================================
.text$mn:00009014
.text$mn:00009014 ; Segment type: Pure code
.text$mn:00009014 ; Segment permissions: Read/Execute
.text$mn:00009014 _text$mn        segment para public 'CODE' use32
.text$mn:00009014                 assume cs:_text$mn
.text$mn:00009014                 ;org 9014h
.text$mn:00009014 ; COMDAT (pick any)
.text$mn:00009014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009014
.text$mn:00009014 ; =============== S U B R O U T I N E =======================================
.text$mn:00009014
.text$mn:00009014 ; Attributes: bp-based frame
.text$mn:00009014
.text$mn:00009014 ; public: virtual void * __thiscall Shortcut::`scalar deleting destructor'(unsigned int)
.text$mn:00009014                 public ??_GShortcut@@UAEPAXI@Z
.text$mn:00009014 ??_GShortcut@@UAEPAXI@Z proc near
.text$mn:00009014
.text$mn:00009014 var_4           = dword ptr -4
.text$mn:00009014 arg_0           = dword ptr  8
.text$mn:00009014
.text$mn:00009014                 push    ebp
.text$mn:00009015                 mov     ebp, esp
.text$mn:00009017                 push    ecx
.text$mn:00009018                 mov     [ebp+var_4], ecx
.text$mn:0000901B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000901E                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:00009023                 mov     eax, [ebp+arg_0]
.text$mn:00009026                 and     eax, 1
.text$mn:00009029                 jz      short loc_9037
.text$mn:0000902B                 mov     ecx, [ebp+var_4]
.text$mn:0000902E                 push    ecx             ; void *
.text$mn:0000902F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00009034                 add     esp, 4
.text$mn:00009037
.text$mn:00009037 loc_9037:                               ; CODE XREF: Shortcut::`scalar deleting destructor'(uint)+15j
.text$mn:00009037                 mov     eax, [ebp+var_4]
.text$mn:0000903A                 mov     esp, ebp
.text$mn:0000903C                 pop     ebp
.text$mn:0000903D                 retn    4
.text$mn:0000903D ??_GShortcut@@UAEPAXI@Z endp
.text$mn:0000903D
.text$mn:0000903D _text$mn        ends
.text$mn:0000903D
.text$mn:00009040 ; ===========================================================================
.text$mn:00009040
.text$mn:00009040 ; Segment type: Pure code
.text$mn:00009040 ; Segment permissions: Read/Execute
.text$mn:00009040 _text$mn        segment para public 'CODE' use32
.text$mn:00009040                 assume cs:_text$mn
.text$mn:00009040                 ;org 9040h
.text$mn:00009040 ; COMDAT (pick any)
.text$mn:00009040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009040
.text$mn:00009040 ; =============== S U B R O U T I N E =======================================
.text$mn:00009040
.text$mn:00009040 ; Attributes: bp-based frame
.text$mn:00009040
.text$mn:00009040 ; public: virtual void * __thiscall StaticDialog::`scalar deleting destructor'(unsigned int)
.text$mn:00009040                 public ??_GStaticDialog@@UAEPAXI@Z
.text$mn:00009040 ??_GStaticDialog@@UAEPAXI@Z proc near
.text$mn:00009040
.text$mn:00009040 var_4           = dword ptr -4
.text$mn:00009040 arg_0           = dword ptr  8
.text$mn:00009040
.text$mn:00009040                 push    ebp
.text$mn:00009041                 mov     ebp, esp
.text$mn:00009043                 push    ecx
.text$mn:00009044                 mov     [ebp+var_4], ecx
.text$mn:00009047                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000904A                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:0000904F                 mov     eax, [ebp+arg_0]
.text$mn:00009052                 and     eax, 1
.text$mn:00009055                 jz      short loc_9063
.text$mn:00009057                 mov     ecx, [ebp+var_4]
.text$mn:0000905A                 push    ecx             ; void *
.text$mn:0000905B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00009060                 add     esp, 4
.text$mn:00009063
.text$mn:00009063 loc_9063:                               ; CODE XREF: StaticDialog::`scalar deleting destructor'(uint)+15j
.text$mn:00009063                 mov     eax, [ebp+var_4]
.text$mn:00009066                 mov     esp, ebp
.text$mn:00009068                 pop     ebp
.text$mn:00009069                 retn    4
.text$mn:00009069 ??_GStaticDialog@@UAEPAXI@Z endp
.text$mn:00009069
.text$mn:00009069 _text$mn        ends
.text$mn:00009069
.text$mn:0000906C ; ===========================================================================
.text$mn:0000906C
.text$mn:0000906C ; Segment type: Pure code
.text$mn:0000906C ; Segment permissions: Read/Execute
.text$mn:0000906C _text$mn        segment para public 'CODE' use32
.text$mn:0000906C                 assume cs:_text$mn
.text$mn:0000906C                 ;org 906Ch
.text$mn:0000906C ; COMDAT (pick any)
.text$mn:0000906C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000906C
.text$mn:0000906C ; =============== S U B R O U T I N E =======================================
.text$mn:0000906C
.text$mn:0000906C ; Attributes: bp-based frame
.text$mn:0000906C
.text$mn:0000906C ; public: virtual void * __thiscall UserCommand::`scalar deleting destructor'(unsigned int)
.text$mn:0000906C                 public ??_GUserCommand@@UAEPAXI@Z
.text$mn:0000906C ??_GUserCommand@@UAEPAXI@Z proc near
.text$mn:0000906C
.text$mn:0000906C var_4           = dword ptr -4
.text$mn:0000906C arg_0           = dword ptr  8
.text$mn:0000906C
.text$mn:0000906C                 push    ebp
.text$mn:0000906D                 mov     ebp, esp
.text$mn:0000906F                 push    ecx
.text$mn:00009070                 mov     [ebp+var_4], ecx
.text$mn:00009073                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009076                 call    ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$mn:0000907B                 mov     eax, [ebp+arg_0]
.text$mn:0000907E                 and     eax, 1
.text$mn:00009081                 jz      short loc_908F
.text$mn:00009083                 mov     ecx, [ebp+var_4]
.text$mn:00009086                 push    ecx             ; void *
.text$mn:00009087                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000908C                 add     esp, 4
.text$mn:0000908F
.text$mn:0000908F loc_908F:                               ; CODE XREF: UserCommand::`scalar deleting destructor'(uint)+15j
.text$mn:0000908F                 mov     eax, [ebp+var_4]
.text$mn:00009092                 mov     esp, ebp
.text$mn:00009094                 pop     ebp
.text$mn:00009095                 retn    4
.text$mn:00009095 ??_GUserCommand@@UAEPAXI@Z endp
.text$mn:00009095
.text$mn:00009095 _text$mn        ends
.text$mn:00009095
.text$mn:00009098 ; ===========================================================================
.text$mn:00009098
.text$mn:00009098 ; Segment type: Pure code
.text$mn:00009098 ; Segment permissions: Read/Execute
.text$mn:00009098 _text$mn        segment para public 'CODE' use32
.text$mn:00009098                 assume cs:_text$mn
.text$mn:00009098                 ;org 9098h
.text$mn:00009098 ; COMDAT (pick any)
.text$mn:00009098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009098
.text$mn:00009098 ; =============== S U B R O U T I N E =======================================
.text$mn:00009098
.text$mn:00009098 ; Attributes: bp-based frame
.text$mn:00009098
.text$mn:00009098 ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:00009098                 public ??_GWindow@@UAEPAXI@Z
.text$mn:00009098 ??_GWindow@@UAEPAXI@Z proc near
.text$mn:00009098
.text$mn:00009098 var_4           = dword ptr -4
.text$mn:00009098 arg_0           = dword ptr  8
.text$mn:00009098
.text$mn:00009098                 push    ebp
.text$mn:00009099                 mov     ebp, esp
.text$mn:0000909B                 push    ecx
.text$mn:0000909C                 mov     [ebp+var_4], ecx
.text$mn:0000909F                 mov     ecx, [ebp+var_4] ; this
.text$mn:000090A2                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:000090A7                 mov     eax, [ebp+arg_0]
.text$mn:000090AA                 and     eax, 1
.text$mn:000090AD                 jz      short loc_90BB
.text$mn:000090AF                 mov     ecx, [ebp+var_4]
.text$mn:000090B2                 push    ecx             ; void *
.text$mn:000090B3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000090B8                 add     esp, 4
.text$mn:000090BB
.text$mn:000090BB loc_90BB:                               ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:000090BB                 mov     eax, [ebp+var_4]
.text$mn:000090BE                 mov     esp, ebp
.text$mn:000090C0                 pop     ebp
.text$mn:000090C1                 retn    4
.text$mn:000090C1 ??_GWindow@@UAEPAXI@Z endp
.text$mn:000090C1
.text$mn:000090C1 _text$mn        ends
.text$mn:000090C1
.text$mn:000090C4 ; ===========================================================================
.text$mn:000090C4
.text$mn:000090C4 ; Segment type: Pure code
.text$mn:000090C4 ; Segment permissions: Read/Execute
.text$mn:000090C4 _text$mn        segment para public 'CODE' use32
.text$mn:000090C4                 assume cs:_text$mn
.text$mn:000090C4                 ;org 90C4h
.text$mn:000090C4 ; COMDAT (pick any)
.text$mn:000090C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090C4
.text$mn:000090C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000090C4
.text$mn:000090C4 ; Attributes: bp-based frame
.text$mn:000090C4
.text$mn:000090C4 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000090C4                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000090C4 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000090C4
.text$mn:000090C4 var_4           = dword ptr -4
.text$mn:000090C4 arg_0           = dword ptr  8
.text$mn:000090C4
.text$mn:000090C4                 push    ebp
.text$mn:000090C5                 mov     ebp, esp
.text$mn:000090C7                 push    ecx
.text$mn:000090C8                 mov     [ebp+var_4], ecx
.text$mn:000090CB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000090CE                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000090D3                 mov     eax, [ebp+arg_0]
.text$mn:000090D6                 and     eax, 1
.text$mn:000090D9                 jz      short loc_90E7
.text$mn:000090DB                 mov     ecx, [ebp+var_4]
.text$mn:000090DE                 push    ecx             ; void *
.text$mn:000090DF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000090E4                 add     esp, 4
.text$mn:000090E7
.text$mn:000090E7 loc_90E7:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000090E7                 mov     eax, [ebp+var_4]
.text$mn:000090EA                 mov     esp, ebp
.text$mn:000090EC                 pop     ebp
.text$mn:000090ED                 retn    4
.text$mn:000090ED ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000090ED
.text$mn:000090ED _text$mn        ends
.text$mn:000090ED
.text$mn:000090F0 ; ===========================================================================
.text$mn:000090F0
.text$mn:000090F0 ; Segment type: Pure code
.text$mn:000090F0 ; Segment permissions: Read/Execute
.text$mn:000090F0 _text$mn        segment para public 'CODE' use32
.text$mn:000090F0                 assume cs:_text$mn
.text$mn:000090F0                 ;org 90F0h
.text$mn:000090F0 ; COMDAT (pick any)
.text$mn:000090F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000090F0
.text$mn:000090F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000090F0
.text$mn:000090F0 ; Attributes: bp-based frame
.text$mn:000090F0
.text$mn:000090F0 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000090F0                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:000090F0 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:000090F0
.text$mn:000090F0 var_4           = dword ptr -4
.text$mn:000090F0 arg_0           = dword ptr  8
.text$mn:000090F0
.text$mn:000090F0                 push    ebp
.text$mn:000090F1                 mov     ebp, esp
.text$mn:000090F3                 push    ecx
.text$mn:000090F4                 mov     [ebp+var_4], ecx
.text$mn:000090F7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000090FA                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:000090FF                 mov     eax, [ebp+arg_0]
.text$mn:00009102                 and     eax, 1
.text$mn:00009105                 jz      short loc_9113
.text$mn:00009107                 mov     ecx, [ebp+var_4]
.text$mn:0000910A                 push    ecx             ; void *
.text$mn:0000910B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00009110                 add     esp, 4
.text$mn:00009113
.text$mn:00009113 loc_9113:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00009113                 mov     eax, [ebp+var_4]
.text$mn:00009116                 mov     esp, ebp
.text$mn:00009118                 pop     ebp
.text$mn:00009119                 retn    4
.text$mn:00009119 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00009119
.text$mn:00009119 _text$mn        ends
.text$mn:00009119
.text$mn:0000911C ; ===========================================================================
.text$mn:0000911C
.text$mn:0000911C ; Segment type: Pure code
.text$mn:0000911C ; Segment permissions: Read/Execute
.text$mn:0000911C _text$mn        segment para public 'CODE' use32
.text$mn:0000911C                 assume cs:_text$mn
.text$mn:0000911C                 ;org 911Ch
.text$mn:0000911C ; COMDAT (pick any)
.text$mn:0000911C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000911C
.text$mn:0000911C ; =============== S U B R O U T I N E =======================================
.text$mn:0000911C
.text$mn:0000911C ; Attributes: bp-based frame
.text$mn:0000911C
.text$mn:0000911C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000911C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000911C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000911C
.text$mn:0000911C var_4           = dword ptr -4
.text$mn:0000911C arg_0           = dword ptr  8
.text$mn:0000911C
.text$mn:0000911C                 push    ebp
.text$mn:0000911D                 mov     ebp, esp
.text$mn:0000911F                 push    ecx
.text$mn:00009120                 mov     [ebp+var_4], ecx
.text$mn:00009123                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009126                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000912B                 mov     eax, [ebp+arg_0]
.text$mn:0000912E                 and     eax, 1
.text$mn:00009131                 jz      short loc_913F
.text$mn:00009133                 mov     ecx, [ebp+var_4]
.text$mn:00009136                 push    ecx             ; void *
.text$mn:00009137                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000913C                 add     esp, 4
.text$mn:0000913F
.text$mn:0000913F loc_913F:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000913F                 mov     eax, [ebp+var_4]
.text$mn:00009142                 mov     esp, ebp
.text$mn:00009144                 pop     ebp
.text$mn:00009145                 retn    4
.text$mn:00009145 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00009145
.text$mn:00009145 _text$mn        ends
.text$mn:00009145
.text$mn:00009148 ; ===========================================================================
.text$mn:00009148
.text$mn:00009148 ; Segment type: Pure code
.text$mn:00009148 ; Segment permissions: Read/Execute
.text$mn:00009148 _text$mn        segment para public 'CODE' use32
.text$mn:00009148                 assume cs:_text$mn
.text$mn:00009148                 ;org 9148h
.text$mn:00009148 ; COMDAT (pick any)
.text$mn:00009148                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009148
.text$mn:00009148 ; =============== S U B R O U T I N E =======================================
.text$mn:00009148
.text$mn:00009148 ; Attributes: bp-based frame
.text$mn:00009148
.text$mn:00009148 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00009148                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00009148 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00009148
.text$mn:00009148 var_4           = dword ptr -4
.text$mn:00009148 arg_0           = dword ptr  8
.text$mn:00009148
.text$mn:00009148                 push    ebp
.text$mn:00009149                 mov     ebp, esp
.text$mn:0000914B                 push    ecx
.text$mn:0000914C                 mov     [ebp+var_4], ecx
.text$mn:0000914F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009152                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00009157                 mov     eax, [ebp+arg_0]
.text$mn:0000915A                 and     eax, 1
.text$mn:0000915D                 jz      short loc_916B
.text$mn:0000915F                 mov     ecx, [ebp+var_4]
.text$mn:00009162                 push    ecx             ; void *
.text$mn:00009163                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00009168                 add     esp, 4
.text$mn:0000916B
.text$mn:0000916B loc_916B:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000916B                 mov     eax, [ebp+var_4]
.text$mn:0000916E                 mov     esp, ebp
.text$mn:00009170                 pop     ebp
.text$mn:00009171                 retn    4
.text$mn:00009171 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00009171
.text$mn:00009171 _text$mn        ends
.text$mn:00009171
.text$mn:00009174 ; ===========================================================================
.text$mn:00009174
.text$mn:00009174 ; Segment type: Pure code
.text$mn:00009174 ; Segment permissions: Read/Execute
.text$mn:00009174 _text$mn        segment para public 'CODE' use32
.text$mn:00009174                 assume cs:_text$mn
.text$mn:00009174                 ;org 9174h
.text$mn:00009174 ; COMDAT (pick any)
.text$mn:00009174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009174
.text$mn:00009174 ; =============== S U B R O U T I N E =======================================
.text$mn:00009174
.text$mn:00009174 ; Attributes: bp-based frame
.text$mn:00009174
.text$mn:00009174 ; public: void * __thiscall recordedMacroStep::`scalar deleting destructor'(unsigned int)
.text$mn:00009174                 public ??_GrecordedMacroStep@@QAEPAXI@Z
.text$mn:00009174 ??_GrecordedMacroStep@@QAEPAXI@Z proc near
.text$mn:00009174                                         ; CODE XREF: std::allocator<recordedMacroStep>::destroy<recordedMacroStep>(recordedMacroStep *)+Cp
.text$mn:00009174
.text$mn:00009174 var_4           = dword ptr -4
.text$mn:00009174 arg_0           = dword ptr  8
.text$mn:00009174
.text$mn:00009174                 push    ebp
.text$mn:00009175                 mov     ebp, esp
.text$mn:00009177                 push    ecx
.text$mn:00009178                 mov     [ebp+var_4], ecx
.text$mn:0000917B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000917E                 call    ??1recordedMacroStep@@QAE@XZ ; recordedMacroStep::~recordedMacroStep(void)
.text$mn:00009183                 mov     eax, [ebp+arg_0]
.text$mn:00009186                 and     eax, 1
.text$mn:00009189                 jz      short loc_9197
.text$mn:0000918B                 mov     ecx, [ebp+var_4]
.text$mn:0000918E                 push    ecx             ; void *
.text$mn:0000918F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00009194                 add     esp, 4
.text$mn:00009197
.text$mn:00009197 loc_9197:                               ; CODE XREF: recordedMacroStep::`scalar deleting destructor'(uint)+15j
.text$mn:00009197                 mov     eax, [ebp+var_4]
.text$mn:0000919A                 mov     esp, ebp
.text$mn:0000919C                 pop     ebp
.text$mn:0000919D                 retn    4
.text$mn:0000919D ??_GrecordedMacroStep@@QAEPAXI@Z endp
.text$mn:0000919D
.text$mn:0000919D _text$mn        ends
.text$mn:0000919D
.text$di:000091A0 ; ===========================================================================
.text$di:000091A0
.text$di:000091A0 ; Segment type: Pure code
.text$di:000091A0 ; Segment permissions: Read/Execute
.text$di:000091A0 _text$di        segment para public 'CODE' use32
.text$di:000091A0                 assume cs:_text$di
.text$di:000091A0                 ;org 91A0h
.text$di:000091A0 ; COMDAT (pick any)
.text$di:000091A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000091A0
.text$di:000091A0 ; =============== S U B R O U T I N E =======================================
.text$di:000091A0
.text$di:000091A0 ; Attributes: bp-based frame
.text$di:000091A0
.text$di:000091A0 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000091A0 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000091A0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000091A0                 push    ebp
.text$di:000091A1                 mov     ebp, esp
.text$di:000091A3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000091A8                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000091AD                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000091B2                 call    _atexit
.text$di:000091B7                 add     esp, 4
.text$di:000091BA                 pop     ebp
.text$di:000091BB                 retn
.text$di:000091BB ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000091BB
.text$di:000091BB _text$di        ends
.text$di:000091BB
.text$di:000091BC ; ===========================================================================
.text$di:000091BC
.text$di:000091BC ; Segment type: Pure code
.text$di:000091BC ; Segment permissions: Read/Execute
.text$di:000091BC _text$di        segment para public 'CODE' use32
.text$di:000091BC                 assume cs:_text$di
.text$di:000091BC                 ;org 91BCh
.text$di:000091BC ; COMDAT (pick any)
.text$di:000091BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000091BC
.text$di:000091BC ; =============== S U B R O U T I N E =======================================
.text$di:000091BC
.text$di:000091BC ; Attributes: bp-based frame
.text$di:000091BC
.text$di:000091BC ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000091BC ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000091BC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000091BC                 push    ebp
.text$di:000091BD                 mov     ebp, esp
.text$di:000091BF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000091C4                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000091C9                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000091CE                 call    _atexit
.text$di:000091D3                 add     esp, 4
.text$di:000091D6                 pop     ebp
.text$di:000091D7                 retn
.text$di:000091D7 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000091D7
.text$di:000091D7 _text$di        ends
.text$di:000091D7
.text$di:000091D8 ; ===========================================================================
.text$di:000091D8
.text$di:000091D8 ; Segment type: Pure code
.text$di:000091D8 ; Segment permissions: Read/Execute
.text$di:000091D8 _text$di        segment para public 'CODE' use32
.text$di:000091D8                 assume cs:_text$di
.text$di:000091D8                 ;org 91D8h
.text$di:000091D8 ; COMDAT (pick any)
.text$di:000091D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000091D8
.text$di:000091D8 ; =============== S U B R O U T I N E =======================================
.text$di:000091D8
.text$di:000091D8 ; Attributes: bp-based frame
.text$di:000091D8
.text$di:000091D8 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000091D8 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000091D8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000091D8                 push    ebp
.text$di:000091D9                 mov     ebp, esp
.text$di:000091DB                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000091E0                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000091E5                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000091EA                 call    _atexit
.text$di:000091EF                 add     esp, 4
.text$di:000091F2                 pop     ebp
.text$di:000091F3                 retn
.text$di:000091F3 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000091F3
.text$di:000091F3 _text$di        ends
.text$di:000091F3
.text$di:000091F4 ; ===========================================================================
.text$di:000091F4
.text$di:000091F4 ; Segment type: Pure code
.text$di:000091F4 ; Segment permissions: Read/Execute
.text$di:000091F4 _text$di        segment para public 'CODE' use32
.text$di:000091F4                 assume cs:_text$di
.text$di:000091F4                 ;org 91F4h
.text$di:000091F4 ; COMDAT (pick any)
.text$di:000091F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000091F4
.text$di:000091F4 ; =============== S U B R O U T I N E =======================================
.text$di:000091F4
.text$di:000091F4 ; Attributes: bp-based frame
.text$di:000091F4
.text$di:000091F4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:000091F4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000091F4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:000091F4                 push    ebp
.text$di:000091F5                 mov     ebp, esp
.text$di:000091F7                 push    0               ; unsigned int
.text$di:000091F9                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000091FE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00009203                 pop     ebp
.text$di:00009204                 retn
.text$di:00009204 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00009204
.text$di:00009204 ; ---------------------------------------------------------------------------
.text$di:00009205                 align 4
.text$di:00009205 _text$di        ends
.text$di:00009205
.text$di:00009208 ; ===========================================================================
.text$di:00009208
.text$di:00009208 ; Segment type: Pure code
.text$di:00009208 ; Segment permissions: Read/Execute
.text$di:00009208 _text$di        segment para public 'CODE' use32
.text$di:00009208                 assume cs:_text$di
.text$di:00009208                 ;org 9208h
.text$di:00009208 ; COMDAT (pick any)
.text$di:00009208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00009208
.text$di:00009208 ; =============== S U B R O U T I N E =======================================
.text$di:00009208
.text$di:00009208 ; Attributes: bp-based frame
.text$di:00009208
.text$di:00009208 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00009208 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00009208                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00009208                 push    ebp
.text$di:00009209                 mov     ebp, esp
.text$di:0000920B                 push    0               ; unsigned int
.text$di:0000920D                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00009212                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00009217                 pop     ebp
.text$di:00009218                 retn
.text$di:00009218 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00009218
.text$di:00009218 ; ---------------------------------------------------------------------------
.text$di:00009219                 align 4
.text$di:00009219 _text$di        ends
.text$di:00009219
.text$di:0000921C ; ===========================================================================
.text$di:0000921C
.text$di:0000921C ; Segment type: Pure code
.text$di:0000921C ; Segment permissions: Read/Execute
.text$di:0000921C _text$di        segment para public 'CODE' use32
.text$di:0000921C                 assume cs:_text$di
.text$di:0000921C                 ;org 921Ch
.text$di:0000921C ; COMDAT (pick any)
.text$di:0000921C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000921C
.text$di:0000921C ; =============== S U B R O U T I N E =======================================
.text$di:0000921C
.text$di:0000921C ; Attributes: bp-based frame
.text$di:0000921C
.text$di:0000921C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:0000921C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000921C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:0000921C                 push    ebp
.text$di:0000921D                 mov     ebp, esp
.text$di:0000921F                 push    0               ; unsigned int
.text$di:00009221                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00009226                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000922B                 pop     ebp
.text$di:0000922C                 retn
.text$di:0000922C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000922C
.text$di:0000922C ; ---------------------------------------------------------------------------
.text$di:0000922D                 align 10h
.text$di:0000922D _text$di        ends
.text$di:0000922D
.text$di:00009230 ; ===========================================================================
.text$di:00009230
.text$di:00009230 ; Segment type: Pure code
.text$di:00009230 ; Segment permissions: Read/Execute
.text$di:00009230 _text$di        segment para public 'CODE' use32
.text$di:00009230                 assume cs:_text$di
.text$di:00009230                 ;org 9230h
.text$di:00009230 ; COMDAT (pick any)
.text$di:00009230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00009230
.text$di:00009230 ; =============== S U B R O U T I N E =======================================
.text$di:00009230
.text$di:00009230 ; Attributes: bp-based frame
.text$di:00009230
.text$di:00009230 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00009230 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00009230                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00009230                 push    ebp
.text$di:00009231                 mov     ebp, esp
.text$di:00009233                 push    0               ; unsigned int
.text$di:00009235                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000923A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000923F                 pop     ebp
.text$di:00009240                 retn
.text$di:00009240 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00009240
.text$di:00009240 ; ---------------------------------------------------------------------------
.text$di:00009241                 align 4
.text$di:00009241 _text$di        ends
.text$di:00009241
.text$di:00009244 ; ===========================================================================
.text$di:00009244
.text$di:00009244 ; Segment type: Pure code
.text$di:00009244 ; Segment permissions: Read/Execute
.text$di:00009244 _text$di        segment para public 'CODE' use32
.text$di:00009244                 assume cs:_text$di
.text$di:00009244                 ;org 9244h
.text$di:00009244 ; COMDAT (pick any)
.text$di:00009244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00009244
.text$di:00009244 ; =============== S U B R O U T I N E =======================================
.text$di:00009244
.text$di:00009244 ; Attributes: bp-based frame
.text$di:00009244
.text$di:00009244 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00009244 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00009244
.text$di:00009244 var_1           = byte ptr -1
.text$di:00009244
.text$di:00009244                 push    ebp
.text$di:00009245                 mov     ebp, esp
.text$di:00009247                 push    ecx
.text$di:00009248                 xor     eax, eax
.text$di:0000924A                 mov     [ebp+var_1], al
.text$di:0000924D                 mov     esp, ebp
.text$di:0000924F                 pop     ebp
.text$di:00009250                 retn
.text$di:00009250 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00009250
.text$di:00009250 ; ---------------------------------------------------------------------------
.text$di:00009251                 align 4
.text$di:00009251 _text$di        ends
.text$di:00009251
.text$di:00009254 ; ===========================================================================
.text$di:00009254
.text$di:00009254 ; Segment type: Pure code
.text$di:00009254 ; Segment permissions: Read/Execute
.text$di:00009254 _text$di        segment para public 'CODE' use32
.text$di:00009254                 assume cs:_text$di
.text$di:00009254                 ;org 9254h
.text$di:00009254 ; COMDAT (pick any)
.text$di:00009254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00009254
.text$di:00009254 ; =============== S U B R O U T I N E =======================================
.text$di:00009254
.text$di:00009254 ; Attributes: bp-based frame
.text$di:00009254
.text$di:00009254 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00009254 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00009254
.text$di:00009254 var_1           = byte ptr -1
.text$di:00009254
.text$di:00009254                 push    ebp
.text$di:00009255                 mov     ebp, esp
.text$di:00009257                 push    ecx
.text$di:00009258                 xor     eax, eax
.text$di:0000925A                 mov     [ebp+var_1], al
.text$di:0000925D                 mov     esp, ebp
.text$di:0000925F                 pop     ebp
.text$di:00009260                 retn
.text$di:00009260 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00009260
.text$di:00009260 ; ---------------------------------------------------------------------------
.text$di:00009261                 align 4
.text$di:00009261 _text$di        ends
.text$di:00009261
.text$di:00009264 ; ===========================================================================
.text$di:00009264
.text$di:00009264 ; Segment type: Pure code
.text$di:00009264 ; Segment permissions: Read/Execute
.text$di:00009264 _text$di        segment para public 'CODE' use32
.text$di:00009264                 assume cs:_text$di
.text$di:00009264                 ;org 9264h
.text$di:00009264 ; COMDAT (pick any)
.text$di:00009264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00009264
.text$di:00009264 ; =============== S U B R O U T I N E =======================================
.text$di:00009264
.text$di:00009264 ; Attributes: bp-based frame
.text$di:00009264
.text$di:00009264 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00009264 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00009264                 push    ebp
.text$di:00009265                 mov     ebp, esp
.text$di:00009267                 mov     ecx, offset _ignore ; this
.text$di:0000926C                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00009271                 pop     ebp
.text$di:00009272                 retn
.text$di:00009272 ??__Eignore@std@@YAXXZ endp
.text$di:00009272
.text$di:00009272 ; ---------------------------------------------------------------------------
.text$di:00009273                 align 4
.text$di:00009273 _text$di        ends
.text$di:00009273
.text$di:00009274 ; ===========================================================================
.text$di:00009274
.text$di:00009274 ; Segment type: Pure code
.text$di:00009274 ; Segment permissions: Read/Execute
.text$di:00009274 _text$di        segment para public 'CODE' use32
.text$di:00009274                 assume cs:_text$di
.text$di:00009274                 ;org 9274h
.text$di:00009274 ; COMDAT (pick any)
.text$di:00009274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00009274
.text$di:00009274 ; =============== S U B R O U T I N E =======================================
.text$di:00009274
.text$di:00009274 ; Attributes: bp-based frame
.text$di:00009274
.text$di:00009274 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00009274 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00009274                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00009274
.text$di:00009274 var_1           = byte ptr -1
.text$di:00009274
.text$di:00009274                 push    ebp
.text$di:00009275                 mov     ebp, esp
.text$di:00009277                 push    ecx
.text$di:00009278                 xor     eax, eax
.text$di:0000927A                 mov     [ebp+var_1], al
.text$di:0000927D                 mov     esp, ebp
.text$di:0000927F                 pop     ebp
.text$di:00009280                 retn
.text$di:00009280 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00009280
.text$di:00009280 ; ---------------------------------------------------------------------------
.text$di:00009281                 align 4
.text$di:00009281 _text$di        ends
.text$di:00009281
.text$yd:00009284 ; ===========================================================================
.text$yd:00009284
.text$yd:00009284 ; Segment type: Pure code
.text$yd:00009284 ; Segment permissions: Read/Execute
.text$yd:00009284 _text$yd        segment para public 'CODE' use32
.text$yd:00009284                 assume cs:_text$yd
.text$yd:00009284                 ;org 9284h
.text$yd:00009284 ; COMDAT (pick any)
.text$yd:00009284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00009284
.text$yd:00009284 ; =============== S U B R O U T I N E =======================================
.text$yd:00009284
.text$yd:00009284 ; Attributes: bp-based frame
.text$yd:00009284
.text$yd:00009284 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00009284 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00009284                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00009284                 push    ebp
.text$yd:00009285                 mov     ebp, esp
.text$yd:00009287                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:0000928C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00009291                 pop     ebp
.text$yd:00009292                 retn
.text$yd:00009292 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00009292
.text$yd:00009292 ; ---------------------------------------------------------------------------
.text$yd:00009293                 align 4
.text$yd:00009293 _text$yd        ends
.text$yd:00009293
.text$yd:00009294 ; ===========================================================================
.text$yd:00009294
.text$yd:00009294 ; Segment type: Pure code
.text$yd:00009294 ; Segment permissions: Read/Execute
.text$yd:00009294 _text$yd        segment para public 'CODE' use32
.text$yd:00009294                 assume cs:_text$yd
.text$yd:00009294                 ;org 9294h
.text$yd:00009294 ; COMDAT (pick any)
.text$yd:00009294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00009294
.text$yd:00009294 ; =============== S U B R O U T I N E =======================================
.text$yd:00009294
.text$yd:00009294 ; Attributes: bp-based frame
.text$yd:00009294
.text$yd:00009294 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00009294 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00009294                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00009294                 push    ebp
.text$yd:00009295                 mov     ebp, esp
.text$yd:00009297                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:0000929C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000092A1                 pop     ebp
.text$yd:000092A2                 retn
.text$yd:000092A2 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000092A2
.text$yd:000092A2 ; ---------------------------------------------------------------------------
.text$yd:000092A3                 align 4
.text$yd:000092A3 _text$yd        ends
.text$yd:000092A3
.text$yd:000092A4 ; ===========================================================================
.text$yd:000092A4
.text$yd:000092A4 ; Segment type: Pure code
.text$yd:000092A4 ; Segment permissions: Read/Execute
.text$yd:000092A4 _text$yd        segment para public 'CODE' use32
.text$yd:000092A4                 assume cs:_text$yd
.text$yd:000092A4                 ;org 92A4h
.text$yd:000092A4 ; COMDAT (pick any)
.text$yd:000092A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000092A4
.text$yd:000092A4 ; =============== S U B R O U T I N E =======================================
.text$yd:000092A4
.text$yd:000092A4 ; Attributes: bp-based frame
.text$yd:000092A4
.text$yd:000092A4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000092A4 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000092A4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000092A4                 push    ebp
.text$yd:000092A5                 mov     ebp, esp
.text$yd:000092A7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000092AC                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000092B1                 pop     ebp
.text$yd:000092B2                 retn
.text$yd:000092B2 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000092B2
.text$yd:000092B2 ; ---------------------------------------------------------------------------
.text$yd:000092B3                 align 4
.text$yd:000092B3 _text$yd        ends
.text$yd:000092B3
.text$mn:000092B4 ; ===========================================================================
.text$mn:000092B4
.text$mn:000092B4 ; Segment type: Pure code
.text$mn:000092B4 ; Segment permissions: Read/Execute
.text$mn:000092B4 _text$mn        segment para public 'CODE' use32
.text$mn:000092B4                 assume cs:_text$mn
.text$mn:000092B4                 ;org 92B4h
.text$mn:000092B4 ; COMDAT (pick any)
.text$mn:000092B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000092B4
.text$mn:000092B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000092B4
.text$mn:000092B4 ; Attributes: bp-based frame
.text$mn:000092B4
.text$mn:000092B4 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:000092B4                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:000092B4 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:000092B4                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(KeyCombo *,std::_Container_base12 const *)+45p
.text$mn:000092B4                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(recordedMacroStep *,std::_Container_base12 const *)+45p ...
.text$mn:000092B4
.text$mn:000092B4 var_1C          = byte ptr -1Ch
.text$mn:000092B4 var_18          = byte ptr -18h
.text$mn:000092B4 var_14          = dword ptr -14h
.text$mn:000092B4 var_10          = dword ptr -10h
.text$mn:000092B4 var_C           = dword ptr -0Ch
.text$mn:000092B4 var_4           = dword ptr -4
.text$mn:000092B4 arg_0           = dword ptr  8
.text$mn:000092B4
.text$mn:000092B4                 push    ebp
.text$mn:000092B5                 mov     ebp, esp
.text$mn:000092B7                 push    0FFFFFFFFh
.text$mn:000092B9                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:000092BE                 mov     eax, large fs:0
.text$mn:000092C4                 push    eax
.text$mn:000092C5                 sub     esp, 10h
.text$mn:000092C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000092CD                 xor     eax, ebp
.text$mn:000092CF                 push    eax
.text$mn:000092D0                 lea     eax, [ebp+var_C]
.text$mn:000092D3                 mov     large fs:0, eax
.text$mn:000092D9                 mov     [ebp+var_10], ecx
.text$mn:000092DC                 cmp     [ebp+arg_0], 0
.text$mn:000092E0                 jnz     short loc_930C
.text$mn:000092E2                 push    3               ; int
.text$mn:000092E4                 lea     ecx, [ebp+var_18] ; this
.text$mn:000092E7                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000092EC                 mov     [ebp+var_4], 0
.text$mn:000092F3                 mov     ecx, [ebp+var_10] ; this
.text$mn:000092F6                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000092FB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009302                 lea     ecx, [ebp+var_18] ; this
.text$mn:00009305                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000930A                 jmp     short loc_9363
.text$mn:0000930C ; ---------------------------------------------------------------------------
.text$mn:0000930C
.text$mn:0000930C loc_930C:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:0000930C                 mov     eax, [ebp+arg_0]
.text$mn:0000930F                 mov     ecx, [eax]
.text$mn:00009311                 mov     [ebp+var_14], ecx
.text$mn:00009314                 mov     edx, [ebp+var_10]
.text$mn:00009317                 mov     eax, [edx]
.text$mn:00009319                 cmp     eax, [ebp+var_14]
.text$mn:0000931C                 jz      short loc_9363
.text$mn:0000931E                 push    3               ; int
.text$mn:00009320                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00009323                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00009328                 mov     [ebp+var_4], 1
.text$mn:0000932F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00009332                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00009337                 mov     ecx, [ebp+var_10]
.text$mn:0000933A                 mov     edx, [ebp+var_14]
.text$mn:0000933D                 mov     eax, [edx+4]
.text$mn:00009340                 mov     [ecx+4], eax
.text$mn:00009343                 mov     ecx, [ebp+var_14]
.text$mn:00009346                 mov     edx, [ebp+var_10]
.text$mn:00009349                 mov     [ecx+4], edx
.text$mn:0000934C                 mov     eax, [ebp+var_10]
.text$mn:0000934F                 mov     ecx, [ebp+var_14]
.text$mn:00009352                 mov     [eax], ecx
.text$mn:00009354                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000935B                 lea     ecx, [ebp+var_1C] ; this
.text$mn:0000935E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00009363
.text$mn:00009363 loc_9363:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00009363                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00009363                 mov     ecx, [ebp+var_C]
.text$mn:00009366                 mov     large fs:0, ecx
.text$mn:0000936D                 pop     ecx
.text$mn:0000936E                 mov     esp, ebp
.text$mn:00009370                 pop     ebp
.text$mn:00009371                 retn    4
.text$mn:00009371 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00009371
.text$mn:00009371 _text$mn        ends
.text$mn:00009371
.text$x:00009374 ; ===========================================================================
.text$x:00009374
.text$x:00009374 ; Segment type: Pure code
.text$x:00009374 ; Segment permissions: Read/Execute
.text$x:00009374 _text$x         segment para public 'CODE' use32
.text$x:00009374                 assume cs:_text$x
.text$x:00009374                 ;org 9374h
.text$x:00009374 ; COMDAT (pick associative to section at 92B4)
.text$x:00009374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009374
.text$x:00009374 ; =============== S U B R O U T I N E =======================================
.text$x:00009374
.text$x:00009374
.text$x:00009374 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00009374                                         ; DATA XREF: .xdata$x:0000CD48o
.text$x:00009374                 lea     ecx, [ebp-18h]  ; this
.text$x:00009377                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00009377 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00009377
.text$x:0000937C
.text$x:0000937C ; =============== S U B R O U T I N E =======================================
.text$x:0000937C
.text$x:0000937C
.text$x:0000937C __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:0000937C                                         ; DATA XREF: .xdata$x:0000CD50o
.text$x:0000937C                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000937F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000937F __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:0000937F
.text$x:00009384
.text$x:00009384 ; =============== S U B R O U T I N E =======================================
.text$x:00009384
.text$x:00009384
.text$x:00009384 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00009384                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00009384
.text$x:00009384 arg_4           = dword ptr  8
.text$x:00009384
.text$x:00009384                 mov     edx, [esp+arg_4]
.text$x:00009388                 lea     eax, [edx+0Ch]
.text$x:0000938B                 mov     ecx, [edx-14h]
.text$x:0000938E                 xor     ecx, eax
.text$x:00009390                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009395                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:0000939A                 jmp     ___CxxFrameHandler3
.text$x:0000939A __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:0000939A
.text$x:0000939A ; ---------------------------------------------------------------------------
.text$x:0000939F                 align 10h
.text$x:0000939F _text$x         ends
.text$x:0000939F
.text$mn:000093A0 ; ===========================================================================
.text$mn:000093A0
.text$mn:000093A0 ; Segment type: Pure code
.text$mn:000093A0 ; Segment permissions: Read/Execute
.text$mn:000093A0 _text$mn        segment para public 'CODE' use32
.text$mn:000093A0                 assume cs:_text$mn
.text$mn:000093A0                 ;org 93A0h
.text$mn:000093A0 ; COMDAT (pick any)
.text$mn:000093A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093A0
.text$mn:000093A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000093A0
.text$mn:000093A0 ; Attributes: bp-based frame
.text$mn:000093A0
.text$mn:000093A0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000093A0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000093A0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000093A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000093A0
.text$mn:000093A0 var_10          = byte ptr -10h
.text$mn:000093A0 var_8           = dword ptr -8
.text$mn:000093A0 var_1           = byte ptr -1
.text$mn:000093A0
.text$mn:000093A0                 push    ebp
.text$mn:000093A1                 mov     ebp, esp
.text$mn:000093A3                 sub     esp, 10h
.text$mn:000093A6                 mov     [ebp+var_8], ecx
.text$mn:000093A9                 lea     ecx, [ebp+var_1]
.text$mn:000093AC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000093B1                 push    1
.text$mn:000093B3                 lea     ecx, [ebp+var_1]
.text$mn:000093B6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000093BB                 mov     ecx, [ebp+var_8]
.text$mn:000093BE                 mov     [ecx], eax
.text$mn:000093C0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000093C3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000093C8                 push    eax             ; int
.text$mn:000093C9                 mov     edx, [ebp+var_8]
.text$mn:000093CC                 mov     eax, [edx]
.text$mn:000093CE                 push    eax             ; void *
.text$mn:000093CF                 lea     ecx, [ebp+var_1]
.text$mn:000093D2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000093D7                 mov     ecx, [ebp+var_8]
.text$mn:000093DA                 mov     edx, [ecx]
.text$mn:000093DC                 mov     eax, [ebp+var_8]
.text$mn:000093DF                 mov     [edx], eax
.text$mn:000093E1                 mov     esp, ebp
.text$mn:000093E3                 pop     ebp
.text$mn:000093E4                 retn
.text$mn:000093E4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000093E4
.text$mn:000093E4 ; ---------------------------------------------------------------------------
.text$mn:000093E5                 align 4
.text$mn:000093E5 _text$mn        ends
.text$mn:000093E5
.text$mn:000093E8 ; ===========================================================================
.text$mn:000093E8
.text$mn:000093E8 ; Segment type: Pure code
.text$mn:000093E8 ; Segment permissions: Read/Execute
.text$mn:000093E8 _text$mn        segment para public 'CODE' use32
.text$mn:000093E8                 assume cs:_text$mn
.text$mn:000093E8                 ;org 93E8h
.text$mn:000093E8 ; COMDAT (pick any)
.text$mn:000093E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093E8
.text$mn:000093E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000093E8
.text$mn:000093E8 ; Attributes: bp-based frame
.text$mn:000093E8
.text$mn:000093E8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000093E8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000093E8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000093E8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:000093E8
.text$mn:000093E8 var_10          = byte ptr -10h
.text$mn:000093E8 var_8           = dword ptr -8
.text$mn:000093E8 var_1           = byte ptr -1
.text$mn:000093E8
.text$mn:000093E8                 push    ebp
.text$mn:000093E9                 mov     ebp, esp
.text$mn:000093EB                 sub     esp, 10h
.text$mn:000093EE                 mov     [ebp+var_8], ecx
.text$mn:000093F1                 lea     ecx, [ebp+var_1]
.text$mn:000093F4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000093F9                 push    1
.text$mn:000093FB                 lea     ecx, [ebp+var_1]
.text$mn:000093FE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00009403                 mov     ecx, [ebp+var_8]
.text$mn:00009406                 mov     [ecx], eax
.text$mn:00009408                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000940B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00009410                 push    eax             ; int
.text$mn:00009411                 mov     edx, [ebp+var_8]
.text$mn:00009414                 mov     eax, [edx]
.text$mn:00009416                 push    eax             ; void *
.text$mn:00009417                 lea     ecx, [ebp+var_1]
.text$mn:0000941A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000941F                 mov     ecx, [ebp+var_8]
.text$mn:00009422                 mov     edx, [ecx]
.text$mn:00009424                 mov     eax, [ebp+var_8]
.text$mn:00009427                 mov     [edx], eax
.text$mn:00009429                 mov     esp, ebp
.text$mn:0000942B                 pop     ebp
.text$mn:0000942C                 retn
.text$mn:0000942C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000942C
.text$mn:0000942C ; ---------------------------------------------------------------------------
.text$mn:0000942D                 align 10h
.text$mn:0000942D _text$mn        ends
.text$mn:0000942D
.text$mn:00009430 ; ===========================================================================
.text$mn:00009430
.text$mn:00009430 ; Segment type: Pure code
.text$mn:00009430 ; Segment permissions: Read/Execute
.text$mn:00009430 _text$mn        segment para public 'CODE' use32
.text$mn:00009430                 assume cs:_text$mn
.text$mn:00009430                 ;org 9430h
.text$mn:00009430 ; COMDAT (pick any)
.text$mn:00009430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009430
.text$mn:00009430 ; =============== S U B R O U T I N E =======================================
.text$mn:00009430
.text$mn:00009430 ; Attributes: bp-based frame
.text$mn:00009430
.text$mn:00009430 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>::_Alloc_proxy(void)
.text$mn:00009430                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ
.text$mn:00009430 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009430                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(std::allocator<KeyCombo> const &)+38p
.text$mn:00009430
.text$mn:00009430 var_10          = byte ptr -10h
.text$mn:00009430 var_8           = dword ptr -8
.text$mn:00009430 var_1           = byte ptr -1
.text$mn:00009430
.text$mn:00009430                 push    ebp
.text$mn:00009431                 mov     ebp, esp
.text$mn:00009433                 sub     esp, 10h
.text$mn:00009436                 mov     [ebp+var_8], ecx
.text$mn:00009439                 lea     ecx, [ebp+var_1]
.text$mn:0000943C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009441                 push    1
.text$mn:00009443                 lea     ecx, [ebp+var_1]
.text$mn:00009446                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000944B                 mov     ecx, [ebp+var_8]
.text$mn:0000944E                 mov     [ecx], eax
.text$mn:00009450                 lea     ecx, [ebp+var_10] ; this
.text$mn:00009453                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00009458                 push    eax             ; int
.text$mn:00009459                 mov     edx, [ebp+var_8]
.text$mn:0000945C                 mov     eax, [edx]
.text$mn:0000945E                 push    eax             ; void *
.text$mn:0000945F                 lea     ecx, [ebp+var_1]
.text$mn:00009462                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00009467                 mov     ecx, [ebp+var_8]
.text$mn:0000946A                 mov     edx, [ecx]
.text$mn:0000946C                 mov     eax, [ebp+var_8]
.text$mn:0000946F                 mov     [edx], eax
.text$mn:00009471                 mov     esp, ebp
.text$mn:00009473                 pop     ebp
.text$mn:00009474                 retn
.text$mn:00009474 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009474
.text$mn:00009474 ; ---------------------------------------------------------------------------
.text$mn:00009475                 align 4
.text$mn:00009475 _text$mn        ends
.text$mn:00009475
.text$mn:00009478 ; ===========================================================================
.text$mn:00009478
.text$mn:00009478 ; Segment type: Pure code
.text$mn:00009478 ; Segment permissions: Read/Execute
.text$mn:00009478 _text$mn        segment para public 'CODE' use32
.text$mn:00009478                 assume cs:_text$mn
.text$mn:00009478                 ;org 9478h
.text$mn:00009478 ; COMDAT (pick any)
.text$mn:00009478                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009478
.text$mn:00009478 ; =============== S U B R O U T I N E =======================================
.text$mn:00009478
.text$mn:00009478 ; Attributes: bp-based frame
.text$mn:00009478
.text$mn:00009478 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Alloc_proxy(void)
.text$mn:00009478                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ
.text$mn:00009478 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009478                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)+38p
.text$mn:00009478
.text$mn:00009478 var_10          = byte ptr -10h
.text$mn:00009478 var_8           = dword ptr -8
.text$mn:00009478 var_1           = byte ptr -1
.text$mn:00009478
.text$mn:00009478                 push    ebp
.text$mn:00009479                 mov     ebp, esp
.text$mn:0000947B                 sub     esp, 10h
.text$mn:0000947E                 mov     [ebp+var_8], ecx
.text$mn:00009481                 lea     ecx, [ebp+var_1]
.text$mn:00009484                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009489                 push    1
.text$mn:0000948B                 lea     ecx, [ebp+var_1]
.text$mn:0000948E                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00009493                 mov     ecx, [ebp+var_8]
.text$mn:00009496                 mov     [ecx], eax
.text$mn:00009498                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000949B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000094A0                 push    eax             ; int
.text$mn:000094A1                 mov     edx, [ebp+var_8]
.text$mn:000094A4                 mov     eax, [edx]
.text$mn:000094A6                 push    eax             ; void *
.text$mn:000094A7                 lea     ecx, [ebp+var_1]
.text$mn:000094AA                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000094AF                 mov     ecx, [ebp+var_8]
.text$mn:000094B2                 mov     edx, [ecx]
.text$mn:000094B4                 mov     eax, [ebp+var_8]
.text$mn:000094B7                 mov     [edx], eax
.text$mn:000094B9                 mov     esp, ebp
.text$mn:000094BB                 pop     ebp
.text$mn:000094BC                 retn
.text$mn:000094BC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000094BC
.text$mn:000094BC ; ---------------------------------------------------------------------------
.text$mn:000094BD                 align 10h
.text$mn:000094BD _text$mn        ends
.text$mn:000094BD
.text$mn:000094C0 ; ===========================================================================
.text$mn:000094C0
.text$mn:000094C0 ; Segment type: Pure code
.text$mn:000094C0 ; Segment permissions: Read/Execute
.text$mn:000094C0 _text$mn        segment para public 'CODE' use32
.text$mn:000094C0                 assume cs:_text$mn
.text$mn:000094C0                 ;org 94C0h
.text$mn:000094C0 ; COMDAT (pick any)
.text$mn:000094C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000094C0
.text$mn:000094C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000094C0
.text$mn:000094C0 ; Attributes: bp-based frame
.text$mn:000094C0
.text$mn:000094C0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>::_Alloc_proxy(void)
.text$mn:000094C0                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ
.text$mn:000094C0 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000094C0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(std::allocator<recordedMacroStep> const &)+38p
.text$mn:000094C0
.text$mn:000094C0 var_10          = byte ptr -10h
.text$mn:000094C0 var_8           = dword ptr -8
.text$mn:000094C0 var_1           = byte ptr -1
.text$mn:000094C0
.text$mn:000094C0                 push    ebp
.text$mn:000094C1                 mov     ebp, esp
.text$mn:000094C3                 sub     esp, 10h
.text$mn:000094C6                 mov     [ebp+var_8], ecx
.text$mn:000094C9                 lea     ecx, [ebp+var_1]
.text$mn:000094CC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000094D1                 push    1
.text$mn:000094D3                 lea     ecx, [ebp+var_1]
.text$mn:000094D6                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:000094DB                 mov     ecx, [ebp+var_8]
.text$mn:000094DE                 mov     [ecx], eax
.text$mn:000094E0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000094E3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000094E8                 push    eax             ; int
.text$mn:000094E9                 mov     edx, [ebp+var_8]
.text$mn:000094EC                 mov     eax, [edx]
.text$mn:000094EE                 push    eax             ; void *
.text$mn:000094EF                 lea     ecx, [ebp+var_1]
.text$mn:000094F2                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000094F7                 mov     ecx, [ebp+var_8]
.text$mn:000094FA                 mov     edx, [ecx]
.text$mn:000094FC                 mov     eax, [ebp+var_8]
.text$mn:000094FF                 mov     [edx], eax
.text$mn:00009501                 mov     esp, ebp
.text$mn:00009503                 pop     ebp
.text$mn:00009504                 retn
.text$mn:00009504 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009504
.text$mn:00009504 ; ---------------------------------------------------------------------------
.text$mn:00009505                 align 4
.text$mn:00009505 _text$mn        ends
.text$mn:00009505
.text$mn:00009508 ; ===========================================================================
.text$mn:00009508
.text$mn:00009508 ; Segment type: Pure code
.text$mn:00009508 ; Segment permissions: Read/Execute
.text$mn:00009508 _text$mn        segment para public 'CODE' use32
.text$mn:00009508                 assume cs:_text$mn
.text$mn:00009508                 ;org 9508h
.text$mn:00009508 ; COMDAT (pick any)
.text$mn:00009508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009508
.text$mn:00009508 ; =============== S U B R O U T I N E =======================================
.text$mn:00009508
.text$mn:00009508 ; Attributes: bp-based frame
.text$mn:00009508
.text$mn:00009508 ; protected: bool __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::_Buy(unsigned int)
.text$mn:00009508                 public ?_Buy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAE_NI@Z
.text$mn:00009508 ?_Buy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAE_NI@Z proc near
.text$mn:00009508                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+62p
.text$mn:00009508                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+1CCp
.text$mn:00009508
.text$mn:00009508 var_8           = dword ptr -8
.text$mn:00009508 var_1           = byte ptr -1
.text$mn:00009508 arg_0           = dword ptr  8
.text$mn:00009508
.text$mn:00009508                 push    ebp
.text$mn:00009509                 mov     ebp, esp
.text$mn:0000950B                 sub     esp, 8
.text$mn:0000950E                 mov     [ebp+var_8], ecx
.text$mn:00009511                 mov     eax, [ebp+var_8]
.text$mn:00009514                 mov     dword ptr [eax+4], 0
.text$mn:0000951B                 mov     ecx, [ebp+var_8]
.text$mn:0000951E                 mov     dword ptr [ecx+8], 0
.text$mn:00009525                 mov     edx, [ebp+var_8]
.text$mn:00009528                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000952F                 cmp     [ebp+arg_0], 0
.text$mn:00009533                 jnz     short loc_953B
.text$mn:00009535                 xor     al, al
.text$mn:00009537                 jmp     short loc_958F
.text$mn:00009539 ; ---------------------------------------------------------------------------
.text$mn:00009539                 jmp     short loc_958D
.text$mn:0000953B ; ---------------------------------------------------------------------------
.text$mn:0000953B
.text$mn:0000953B loc_953B:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+2Bj
.text$mn:0000953B                 mov     ecx, [ebp+var_8]
.text$mn:0000953E                 call    ?max_size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::max_size(void)
.text$mn:00009543                 cmp     eax, [ebp+arg_0]
.text$mn:00009546                 jnb     short loc_9552
.text$mn:00009548                 mov     ecx, [ebp+var_8]
.text$mn:0000954B                 call    ?_Xlen@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IBEXXZ ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Xlen(void)
.text$mn:00009550                 jmp     short loc_958D
.text$mn:00009552 ; ---------------------------------------------------------------------------
.text$mn:00009552
.text$mn:00009552 loc_9552:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+3Ej
.text$mn:00009552                 mov     eax, [ebp+arg_0]
.text$mn:00009555                 push    eax
.text$mn:00009556                 lea     ecx, [ebp+var_1]
.text$mn:00009559                 push    ecx
.text$mn:0000955A                 mov     ecx, [ebp+var_8]
.text$mn:0000955D                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:00009562                 mov     ecx, eax
.text$mn:00009564                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEPAUKeyCombo@@I@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::allocate(uint)
.text$mn:00009569                 mov     edx, [ebp+var_8]
.text$mn:0000956C                 mov     [edx+4], eax
.text$mn:0000956F                 mov     eax, [ebp+var_8]
.text$mn:00009572                 mov     ecx, [ebp+var_8]
.text$mn:00009575                 mov     edx, [ecx+4]
.text$mn:00009578                 mov     [eax+8], edx
.text$mn:0000957B                 mov     eax, [ebp+var_8]
.text$mn:0000957E                 mov     ecx, [eax+4]
.text$mn:00009581                 mov     edx, [ebp+arg_0]
.text$mn:00009584                 lea     eax, [ecx+edx*4]
.text$mn:00009587                 mov     ecx, [ebp+var_8]
.text$mn:0000958A                 mov     [ecx+0Ch], eax
.text$mn:0000958D
.text$mn:0000958D loc_958D:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+31j
.text$mn:0000958D                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+48j
.text$mn:0000958D                 mov     al, 1
.text$mn:0000958F
.text$mn:0000958F loc_958F:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+2Fj
.text$mn:0000958F                 mov     esp, ebp
.text$mn:00009591                 pop     ebp
.text$mn:00009592                 retn    4
.text$mn:00009592 ?_Buy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAE_NI@Z endp
.text$mn:00009592
.text$mn:00009592 ; ---------------------------------------------------------------------------
.text$mn:00009595                 align 4
.text$mn:00009595 _text$mn        ends
.text$mn:00009595
.text$mn:00009598 ; ===========================================================================
.text$mn:00009598
.text$mn:00009598 ; Segment type: Pure code
.text$mn:00009598 ; Segment permissions: Read/Execute
.text$mn:00009598 _text$mn        segment para public 'CODE' use32
.text$mn:00009598                 assume cs:_text$mn
.text$mn:00009598                 ;org 9598h
.text$mn:00009598 ; COMDAT (pick any)
.text$mn:00009598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009598
.text$mn:00009598 ; =============== S U B R O U T I N E =======================================
.text$mn:00009598
.text$mn:00009598 ; Attributes: bp-based frame
.text$mn:00009598
.text$mn:00009598 ; protected: bool __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Buy(unsigned int)
.text$mn:00009598                 public ?_Buy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAE_NI@Z
.text$mn:00009598 ?_Buy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAE_NI@Z proc near
.text$mn:00009598                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+62p
.text$mn:00009598                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+1D1p
.text$mn:00009598
.text$mn:00009598 var_8           = dword ptr -8
.text$mn:00009598 var_1           = byte ptr -1
.text$mn:00009598 arg_0           = dword ptr  8
.text$mn:00009598
.text$mn:00009598                 push    ebp
.text$mn:00009599                 mov     ebp, esp
.text$mn:0000959B                 sub     esp, 8
.text$mn:0000959E                 mov     [ebp+var_8], ecx
.text$mn:000095A1                 mov     eax, [ebp+var_8]
.text$mn:000095A4                 mov     dword ptr [eax+4], 0
.text$mn:000095AB                 mov     ecx, [ebp+var_8]
.text$mn:000095AE                 mov     dword ptr [ecx+8], 0
.text$mn:000095B5                 mov     edx, [ebp+var_8]
.text$mn:000095B8                 mov     dword ptr [edx+0Ch], 0
.text$mn:000095BF                 cmp     [ebp+arg_0], 0
.text$mn:000095C3                 jnz     short loc_95CB
.text$mn:000095C5                 xor     al, al
.text$mn:000095C7                 jmp     short loc_961D
.text$mn:000095C9 ; ---------------------------------------------------------------------------
.text$mn:000095C9                 jmp     short loc_961B
.text$mn:000095CB ; ---------------------------------------------------------------------------
.text$mn:000095CB
.text$mn:000095CB loc_95CB:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+2Bj
.text$mn:000095CB                 mov     ecx, [ebp+var_8]
.text$mn:000095CE                 call    ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::max_size(void)
.text$mn:000095D3                 cmp     eax, [ebp+arg_0]
.text$mn:000095D6                 jnb     short loc_95E2
.text$mn:000095D8                 mov     ecx, [ebp+var_8]
.text$mn:000095DB                 call    ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Xlen(void)
.text$mn:000095E0                 jmp     short loc_961B
.text$mn:000095E2 ; ---------------------------------------------------------------------------
.text$mn:000095E2
.text$mn:000095E2 loc_95E2:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+3Ej
.text$mn:000095E2                 mov     eax, [ebp+arg_0]
.text$mn:000095E5                 push    eax
.text$mn:000095E6                 lea     ecx, [ebp+var_1]
.text$mn:000095E9                 push    ecx
.text$mn:000095EA                 mov     ecx, [ebp+var_8]
.text$mn:000095ED                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:000095F2                 mov     ecx, eax
.text$mn:000095F4                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::allocate(uint)
.text$mn:000095F9                 mov     edx, [ebp+var_8]
.text$mn:000095FC                 mov     [edx+4], eax
.text$mn:000095FF                 mov     eax, [ebp+var_8]
.text$mn:00009602                 mov     ecx, [ebp+var_8]
.text$mn:00009605                 mov     edx, [ecx+4]
.text$mn:00009608                 mov     [eax+8], edx
.text$mn:0000960B                 imul    eax, [ebp+arg_0], 2Ch
.text$mn:0000960F                 mov     ecx, [ebp+var_8]
.text$mn:00009612                 add     eax, [ecx+4]
.text$mn:00009615                 mov     edx, [ebp+var_8]
.text$mn:00009618                 mov     [edx+0Ch], eax
.text$mn:0000961B
.text$mn:0000961B loc_961B:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+31j
.text$mn:0000961B                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+48j
.text$mn:0000961B                 mov     al, 1
.text$mn:0000961D
.text$mn:0000961D loc_961D:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+2Fj
.text$mn:0000961D                 mov     esp, ebp
.text$mn:0000961F                 pop     ebp
.text$mn:00009620                 retn    4
.text$mn:00009620 ?_Buy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAE_NI@Z endp
.text$mn:00009620
.text$mn:00009620 ; ---------------------------------------------------------------------------
.text$mn:00009623                 align 4
.text$mn:00009623 _text$mn        ends
.text$mn:00009623
.text$mn:00009624 ; ===========================================================================
.text$mn:00009624
.text$mn:00009624 ; Segment type: Pure code
.text$mn:00009624 ; Segment permissions: Read/Execute
.text$mn:00009624 _text$mn        segment para public 'CODE' use32
.text$mn:00009624                 assume cs:_text$mn
.text$mn:00009624                 ;org 9624h
.text$mn:00009624 ; COMDAT (pick any)
.text$mn:00009624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009624
.text$mn:00009624 ; =============== S U B R O U T I N E =======================================
.text$mn:00009624
.text$mn:00009624 ; Attributes: bp-based frame
.text$mn:00009624
.text$mn:00009624 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00009624                 public ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
.text$mn:00009624 ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z proc near
.text$mn:00009624                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Ap
.text$mn:00009624
.text$mn:00009624 var_4           = dword ptr -4
.text$mn:00009624
.text$mn:00009624                 push    ebp
.text$mn:00009625                 mov     ebp, esp
.text$mn:00009627                 push    ecx
.text$mn:00009628                 mov     [ebp+var_4], ecx
.text$mn:0000962B                 mov     esp, ebp
.text$mn:0000962D                 pop     ebp
.text$mn:0000962E                 retn    4
.text$mn:0000962E ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z endp
.text$mn:0000962E
.text$mn:0000962E ; ---------------------------------------------------------------------------
.text$mn:00009631                 align 4
.text$mn:00009631 _text$mn        ends
.text$mn:00009631
.text$mn:00009634 ; ===========================================================================
.text$mn:00009634
.text$mn:00009634 ; Segment type: Pure code
.text$mn:00009634 ; Segment permissions: Read/Execute
.text$mn:00009634 _text$mn        segment para public 'CODE' use32
.text$mn:00009634                 assume cs:_text$mn
.text$mn:00009634                 ;org 9634h
.text$mn:00009634 ; COMDAT (pick any)
.text$mn:00009634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009634
.text$mn:00009634 ; =============== S U B R O U T I N E =======================================
.text$mn:00009634
.text$mn:00009634 ; Attributes: bp-based frame
.text$mn:00009634
.text$mn:00009634 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> const &)
.text$mn:00009634                 public ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@Z
.text$mn:00009634 ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@Z proc near
.text$mn:00009634                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+80p
.text$mn:00009634
.text$mn:00009634 var_4           = dword ptr -4
.text$mn:00009634
.text$mn:00009634                 push    ebp
.text$mn:00009635                 mov     ebp, esp
.text$mn:00009637                 push    ecx
.text$mn:00009638                 mov     [ebp+var_4], ecx
.text$mn:0000963B                 mov     esp, ebp
.text$mn:0000963D                 pop     ebp
.text$mn:0000963E                 retn    4
.text$mn:0000963E ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@Z endp
.text$mn:0000963E
.text$mn:0000963E ; ---------------------------------------------------------------------------
.text$mn:00009641                 align 4
.text$mn:00009641 _text$mn        ends
.text$mn:00009641
.text$mn:00009644 ; ===========================================================================
.text$mn:00009644
.text$mn:00009644 ; Segment type: Pure code
.text$mn:00009644 ; Segment permissions: Read/Execute
.text$mn:00009644 _text$mn        segment para public 'CODE' use32
.text$mn:00009644                 assume cs:_text$mn
.text$mn:00009644                 ;org 9644h
.text$mn:00009644 ; COMDAT (pick any)
.text$mn:00009644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009644
.text$mn:00009644 ; =============== S U B R O U T I N E =======================================
.text$mn:00009644
.text$mn:00009644 ; Attributes: bp-based frame
.text$mn:00009644
.text$mn:00009644 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> const &)
.text$mn:00009644                 public ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@Z
.text$mn:00009644 ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@Z proc near
.text$mn:00009644                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+80p
.text$mn:00009644
.text$mn:00009644 var_4           = dword ptr -4
.text$mn:00009644
.text$mn:00009644                 push    ebp
.text$mn:00009645                 mov     ebp, esp
.text$mn:00009647                 push    ecx
.text$mn:00009648                 mov     [ebp+var_4], ecx
.text$mn:0000964B                 mov     esp, ebp
.text$mn:0000964D                 pop     ebp
.text$mn:0000964E                 retn    4
.text$mn:0000964E ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@Z endp
.text$mn:0000964E
.text$mn:0000964E ; ---------------------------------------------------------------------------
.text$mn:00009651                 align 4
.text$mn:00009651 _text$mn        ends
.text$mn:00009651
.text$mn:00009654 ; ===========================================================================
.text$mn:00009654
.text$mn:00009654 ; Segment type: Pure code
.text$mn:00009654 ; Segment permissions: Read/Execute
.text$mn:00009654 _text$mn        segment para public 'CODE' use32
.text$mn:00009654                 assume cs:_text$mn
.text$mn:00009654                 ;org 9654h
.text$mn:00009654 ; COMDAT (pick any)
.text$mn:00009654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009654
.text$mn:00009654 ; =============== S U B R O U T I N E =======================================
.text$mn:00009654
.text$mn:00009654 ; Attributes: bp-based frame
.text$mn:00009654
.text$mn:00009654 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00009654                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00009654 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00009654                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+80p
.text$mn:00009654                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+80p ...
.text$mn:00009654
.text$mn:00009654 var_4           = dword ptr -4
.text$mn:00009654
.text$mn:00009654                 push    ebp
.text$mn:00009655                 mov     ebp, esp
.text$mn:00009657                 push    ecx
.text$mn:00009658                 mov     [ebp+var_4], ecx
.text$mn:0000965B                 mov     eax, [ebp+var_4]
.text$mn:0000965E                 mov     dword ptr [eax], 0
.text$mn:00009664                 mov     esp, ebp
.text$mn:00009666                 pop     ebp
.text$mn:00009667                 retn
.text$mn:00009667 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00009667
.text$mn:00009667 _text$mn        ends
.text$mn:00009667
.text$mn:00009668 ; ===========================================================================
.text$mn:00009668
.text$mn:00009668 ; Segment type: Pure code
.text$mn:00009668 ; Segment permissions: Read/Execute
.text$mn:00009668 _text$mn        segment para public 'CODE' use32
.text$mn:00009668                 assume cs:_text$mn
.text$mn:00009668                 ;org 9668h
.text$mn:00009668 ; COMDAT (pick any)
.text$mn:00009668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009668
.text$mn:00009668 ; =============== S U B R O U T I N E =======================================
.text$mn:00009668
.text$mn:00009668 ; Attributes: bp-based frame
.text$mn:00009668
.text$mn:00009668 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00009668                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00009668 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00009668                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00009668
.text$mn:00009668 var_20          = dword ptr -20h
.text$mn:00009668 var_1C          = dword ptr -1Ch
.text$mn:00009668 var_18          = dword ptr -18h
.text$mn:00009668 var_11          = byte ptr -11h
.text$mn:00009668 var_10          = dword ptr -10h
.text$mn:00009668 var_C           = byte ptr -0Ch
.text$mn:00009668 var_4           = dword ptr -4
.text$mn:00009668 arg_0           = dword ptr  8
.text$mn:00009668
.text$mn:00009668 ; FUNCTION CHUNK AT .text$mn:0000978A SIZE 00000009 BYTES
.text$mn:00009668
.text$mn:00009668                 push    ebp
.text$mn:00009669                 mov     ebp, esp
.text$mn:0000966B                 push    0FFFFFFFFh
.text$mn:0000966D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00009672                 mov     eax, large fs:0
.text$mn:00009678                 push    eax
.text$mn:00009679                 push    ecx
.text$mn:0000967A                 sub     esp, 10h
.text$mn:0000967D                 push    ebx
.text$mn:0000967E                 push    esi
.text$mn:0000967F                 push    edi
.text$mn:00009680                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009685                 xor     eax, ebp
.text$mn:00009687                 push    eax
.text$mn:00009688                 lea     eax, [ebp+var_C]
.text$mn:0000968B                 mov     large fs:0, eax
.text$mn:00009691                 mov     [ebp+var_10], esp
.text$mn:00009694                 mov     [ebp+var_18], ecx
.text$mn:00009697                 mov     eax, [ebp+arg_0]
.text$mn:0000969A                 or      eax, 0Fh
.text$mn:0000969D                 mov     [ebp+var_1C], eax
.text$mn:000096A0                 mov     ecx, [ebp+var_18]
.text$mn:000096A3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000096A8                 cmp     eax, [ebp+var_1C]
.text$mn:000096AB                 jnb     short loc_96B5
.text$mn:000096AD                 mov     ecx, [ebp+arg_0]
.text$mn:000096B0                 mov     [ebp+var_1C], ecx
.text$mn:000096B3                 jmp     short loc_9707
.text$mn:000096B5 ; ---------------------------------------------------------------------------
.text$mn:000096B5
.text$mn:000096B5 loc_96B5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000096B5                 mov     edx, [ebp+var_18]
.text$mn:000096B8                 mov     ecx, [edx+18h]
.text$mn:000096BB                 shr     ecx, 1
.text$mn:000096BD                 mov     eax, [ebp+var_1C]
.text$mn:000096C0                 xor     edx, edx
.text$mn:000096C2                 mov     esi, 3
.text$mn:000096C7                 div     esi
.text$mn:000096C9                 cmp     ecx, eax
.text$mn:000096CB                 ja      short loc_96CF
.text$mn:000096CD                 jmp     short loc_9707
.text$mn:000096CF ; ---------------------------------------------------------------------------
.text$mn:000096CF
.text$mn:000096CF loc_96CF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000096CF                 mov     ecx, [ebp+var_18]
.text$mn:000096D2                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000096D7                 mov     edx, [ebp+var_18]
.text$mn:000096DA                 mov     ecx, [edx+18h]
.text$mn:000096DD                 shr     ecx, 1
.text$mn:000096DF                 sub     eax, ecx
.text$mn:000096E1                 mov     edx, [ebp+var_18]
.text$mn:000096E4                 cmp     [edx+18h], eax
.text$mn:000096E7                 ja      short loc_96FC
.text$mn:000096E9                 mov     eax, [ebp+var_18]
.text$mn:000096EC                 mov     ecx, [eax+18h]
.text$mn:000096EF                 shr     ecx, 1
.text$mn:000096F1                 mov     edx, [ebp+var_18]
.text$mn:000096F4                 add     ecx, [edx+18h]
.text$mn:000096F7                 mov     [ebp+var_1C], ecx
.text$mn:000096FA                 jmp     short loc_9707
.text$mn:000096FC ; ---------------------------------------------------------------------------
.text$mn:000096FC
.text$mn:000096FC loc_96FC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000096FC                 mov     ecx, [ebp+var_18]
.text$mn:000096FF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00009704                 mov     [ebp+var_1C], eax
.text$mn:00009707
.text$mn:00009707 loc_9707:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00009707                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00009707                 mov     [ebp+var_4], 0
.text$mn:0000970E                 mov     eax, [ebp+var_1C]
.text$mn:00009711                 add     eax, 1
.text$mn:00009714                 push    eax
.text$mn:00009715                 lea     ecx, [ebp+var_11]
.text$mn:00009718                 push    ecx
.text$mn:00009719                 mov     ecx, [ebp+var_18]
.text$mn:0000971C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00009721                 mov     ecx, eax
.text$mn:00009723                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00009728                 mov     [ebp+var_20], eax
.text$mn:0000972B                 jmp     short loc_978A
.text$mn:0000972B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000972B
.text$mn:0000972D
.text$mn:0000972D ; =============== S U B R O U T I N E =======================================
.text$mn:0000972D
.text$mn:0000972D
.text$mn:0000972D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000972D                                         ; DATA XREF: .xdata$x:0000CE8Co
.text$mn:0000972D
.text$mn:0000972D ; FUNCTION CHUNK AT .text$mn:00009774 SIZE 00000009 BYTES
.text$mn:0000972D ; FUNCTION CHUNK AT .text$mn:00009784 SIZE 00000006 BYTES
.text$mn:0000972D
.text$mn:0000972D                 mov     [ebp-10h], esp
.text$mn:00009730                 mov     edx, [ebp+8]
.text$mn:00009733                 mov     [ebp-1Ch], edx
.text$mn:00009736                 mov     byte ptr [ebp-4], 2
.text$mn:0000973A                 mov     eax, [ebp-1Ch]
.text$mn:0000973D                 add     eax, 1
.text$mn:00009740                 push    eax
.text$mn:00009741                 lea     ecx, [ebp-12h]
.text$mn:00009744                 push    ecx
.text$mn:00009745                 mov     ecx, [ebp-18h]
.text$mn:00009748                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000974D                 mov     ecx, eax
.text$mn:0000974F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00009754                 mov     [ebp-20h], eax
.text$mn:00009757                 jmp     short loc_9774
.text$mn:00009757 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00009757
.text$mn:00009759
.text$mn:00009759 ; =============== S U B R O U T I N E =======================================
.text$mn:00009759
.text$mn:00009759 ; Attributes: noreturn
.text$mn:00009759
.text$mn:00009759 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00009759                                         ; DATA XREF: .xdata$x:0000CE9Co
.text$mn:00009759                 push    0               ; Size
.text$mn:0000975B                 push    1               ; char
.text$mn:0000975D                 mov     ecx, [ebp-18h]
.text$mn:00009760                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00009765                 push    0
.text$mn:00009767                 push    0
.text$mn:00009769                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009769 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00009769
.text$mn:0000976E ; ---------------------------------------------------------------------------
.text$mn:0000976E                 mov     eax, offset $LN17
.text$mn:00009773                 retn
.text$mn:00009774 ; ---------------------------------------------------------------------------
.text$mn:00009774 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00009774
.text$mn:00009774 loc_9774:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00009774                 mov     dword ptr [ebp-4], 1
.text$mn:0000977B                 jmp     short loc_9784
.text$mn:0000977B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000977D
.text$mn:0000977D ; =============== S U B R O U T I N E =======================================
.text$mn:0000977D
.text$mn:0000977D
.text$mn:0000977D $LN17           proc near               ; DATA XREF: .text$mn:0000976Eo
.text$mn:0000977D                 mov     dword ptr [ebp-4], 1
.text$mn:0000977D $LN17           endp ; sp-analysis failed
.text$mn:0000977D
.text$mn:00009784 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00009784
.text$mn:00009784 loc_9784:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00009784                 mov     eax, offset $LN19
.text$mn:00009789                 retn
.text$mn:00009789 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000978A ; ---------------------------------------------------------------------------
.text$mn:0000978A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000978A
.text$mn:0000978A loc_978A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000978A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009791                 jmp     short loc_979A
.text$mn:00009791 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00009793
.text$mn:00009793 ; =============== S U B R O U T I N E =======================================
.text$mn:00009793
.text$mn:00009793
.text$mn:00009793 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_9784o
.text$mn:00009793                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000979A
.text$mn:0000979A loc_979A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000979A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000979E                 jbe     short loc_97B9
.text$mn:000097A0                 mov     edx, [ebp+0Ch]
.text$mn:000097A3                 push    edx             ; Size
.text$mn:000097A4                 mov     ecx, [ebp-18h]
.text$mn:000097A7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000097AC                 push    eax             ; Src
.text$mn:000097AD                 mov     eax, [ebp-20h]
.text$mn:000097B0                 push    eax             ; Dst
.text$mn:000097B1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000097B6                 add     esp, 0Ch
.text$mn:000097B9
.text$mn:000097B9 loc_97B9:                               ; CODE XREF: $LN19+Bj
.text$mn:000097B9                 push    0               ; Size
.text$mn:000097BB                 push    1               ; char
.text$mn:000097BD                 mov     ecx, [ebp-18h]
.text$mn:000097C0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000097C5                 lea     ecx, [ebp-20h]
.text$mn:000097C8                 push    ecx             ; int
.text$mn:000097C9                 mov     edx, [ebp-18h]
.text$mn:000097CC                 add     edx, 4
.text$mn:000097CF                 push    edx             ; void *
.text$mn:000097D0                 lea     eax, [ebp-13h]
.text$mn:000097D3                 push    eax
.text$mn:000097D4                 mov     ecx, [ebp-18h]
.text$mn:000097D7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000097DC                 mov     ecx, eax
.text$mn:000097DE                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000097E3                 mov     ecx, [ebp-18h]
.text$mn:000097E6                 mov     edx, [ebp-1Ch]
.text$mn:000097E9                 mov     [ecx+18h], edx
.text$mn:000097EC                 mov     eax, [ebp+0Ch]
.text$mn:000097EF                 push    eax
.text$mn:000097F0                 mov     ecx, [ebp-18h]
.text$mn:000097F3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000097F8                 mov     ecx, [ebp-0Ch]
.text$mn:000097FB                 mov     large fs:0, ecx
.text$mn:00009802                 pop     ecx
.text$mn:00009803                 pop     edi
.text$mn:00009804                 pop     esi
.text$mn:00009805                 pop     ebx
.text$mn:00009806                 mov     esp, ebp
.text$mn:00009808                 pop     ebp
.text$mn:00009809                 retn    8
.text$mn:00009809 $LN19           endp ; sp-analysis failed
.text$mn:00009809
.text$mn:00009809 _text$mn        ends
.text$mn:00009809
.text$x:0000980C ; ===========================================================================
.text$x:0000980C
.text$x:0000980C ; Segment type: Pure code
.text$x:0000980C ; Segment permissions: Read/Execute
.text$x:0000980C _text$x         segment para public 'CODE' use32
.text$x:0000980C                 assume cs:_text$x
.text$x:0000980C                 ;org 980Ch
.text$x:0000980C ; COMDAT (pick associative to section at 9668)
.text$x:0000980C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000980C
.text$x:0000980C ; =============== S U B R O U T I N E =======================================
.text$x:0000980C
.text$x:0000980C
.text$x:0000980C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000980C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000980C
.text$x:0000980C arg_4           = dword ptr  8
.text$x:0000980C
.text$x:0000980C                 mov     edx, [esp+arg_4]
.text$x:00009810                 lea     eax, [edx+0Ch]
.text$x:00009813                 mov     ecx, [edx-24h]
.text$x:00009816                 xor     ecx, eax
.text$x:00009818                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000981D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00009822                 jmp     ___CxxFrameHandler3
.text$x:00009822 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00009822
.text$x:00009822 ; ---------------------------------------------------------------------------
.text$x:00009827                 align 4
.text$x:00009827 _text$x         ends
.text$x:00009827
.text$mn:00009828 ; ===========================================================================
.text$mn:00009828
.text$mn:00009828 ; Segment type: Pure code
.text$mn:00009828 ; Segment permissions: Read/Execute
.text$mn:00009828 _text$mn        segment para public 'CODE' use32
.text$mn:00009828                 assume cs:_text$mn
.text$mn:00009828                 ;org 9828h
.text$mn:00009828 ; COMDAT (pick any)
.text$mn:00009828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009828
.text$mn:00009828 ; =============== S U B R O U T I N E =======================================
.text$mn:00009828
.text$mn:00009828 ; Attributes: bp-based frame
.text$mn:00009828
.text$mn:00009828 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00009828                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009828 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00009828                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00009828
.text$mn:00009828 var_20          = dword ptr -20h
.text$mn:00009828 var_1C          = dword ptr -1Ch
.text$mn:00009828 var_18          = dword ptr -18h
.text$mn:00009828 var_11          = byte ptr -11h
.text$mn:00009828 var_10          = dword ptr -10h
.text$mn:00009828 var_C           = byte ptr -0Ch
.text$mn:00009828 var_4           = dword ptr -4
.text$mn:00009828 arg_0           = dword ptr  8
.text$mn:00009828
.text$mn:00009828 ; FUNCTION CHUNK AT .text$mn:0000994A SIZE 00000009 BYTES
.text$mn:00009828
.text$mn:00009828                 push    ebp
.text$mn:00009829                 mov     ebp, esp
.text$mn:0000982B                 push    0FFFFFFFFh
.text$mn:0000982D                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009832                 mov     eax, large fs:0
.text$mn:00009838                 push    eax
.text$mn:00009839                 push    ecx
.text$mn:0000983A                 sub     esp, 10h
.text$mn:0000983D                 push    ebx
.text$mn:0000983E                 push    esi
.text$mn:0000983F                 push    edi
.text$mn:00009840                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009845                 xor     eax, ebp
.text$mn:00009847                 push    eax
.text$mn:00009848                 lea     eax, [ebp+var_C]
.text$mn:0000984B                 mov     large fs:0, eax
.text$mn:00009851                 mov     [ebp+var_10], esp
.text$mn:00009854                 mov     [ebp+var_18], ecx
.text$mn:00009857                 mov     eax, [ebp+arg_0]
.text$mn:0000985A                 or      eax, 7
.text$mn:0000985D                 mov     [ebp+var_1C], eax
.text$mn:00009860                 mov     ecx, [ebp+var_18]
.text$mn:00009863                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009868                 cmp     eax, [ebp+var_1C]
.text$mn:0000986B                 jnb     short loc_9875
.text$mn:0000986D                 mov     ecx, [ebp+arg_0]
.text$mn:00009870                 mov     [ebp+var_1C], ecx
.text$mn:00009873                 jmp     short loc_98C7
.text$mn:00009875 ; ---------------------------------------------------------------------------
.text$mn:00009875
.text$mn:00009875 loc_9875:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00009875                 mov     edx, [ebp+var_18]
.text$mn:00009878                 mov     ecx, [edx+18h]
.text$mn:0000987B                 shr     ecx, 1
.text$mn:0000987D                 mov     eax, [ebp+var_1C]
.text$mn:00009880                 xor     edx, edx
.text$mn:00009882                 mov     esi, 3
.text$mn:00009887                 div     esi
.text$mn:00009889                 cmp     ecx, eax
.text$mn:0000988B                 ja      short loc_988F
.text$mn:0000988D                 jmp     short loc_98C7
.text$mn:0000988F ; ---------------------------------------------------------------------------
.text$mn:0000988F
.text$mn:0000988F loc_988F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:0000988F                 mov     ecx, [ebp+var_18]
.text$mn:00009892                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009897                 mov     edx, [ebp+var_18]
.text$mn:0000989A                 mov     ecx, [edx+18h]
.text$mn:0000989D                 shr     ecx, 1
.text$mn:0000989F                 sub     eax, ecx
.text$mn:000098A1                 mov     edx, [ebp+var_18]
.text$mn:000098A4                 cmp     [edx+18h], eax
.text$mn:000098A7                 ja      short loc_98BC
.text$mn:000098A9                 mov     eax, [ebp+var_18]
.text$mn:000098AC                 mov     ecx, [eax+18h]
.text$mn:000098AF                 shr     ecx, 1
.text$mn:000098B1                 mov     edx, [ebp+var_18]
.text$mn:000098B4                 add     ecx, [edx+18h]
.text$mn:000098B7                 mov     [ebp+var_1C], ecx
.text$mn:000098BA                 jmp     short loc_98C7
.text$mn:000098BC ; ---------------------------------------------------------------------------
.text$mn:000098BC
.text$mn:000098BC loc_98BC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:000098BC                 mov     ecx, [ebp+var_18]
.text$mn:000098BF                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000098C4                 mov     [ebp+var_1C], eax
.text$mn:000098C7
.text$mn:000098C7 loc_98C7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:000098C7                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:000098C7                 mov     [ebp+var_4], 0
.text$mn:000098CE                 mov     eax, [ebp+var_1C]
.text$mn:000098D1                 add     eax, 1
.text$mn:000098D4                 push    eax
.text$mn:000098D5                 lea     ecx, [ebp+var_11]
.text$mn:000098D8                 push    ecx
.text$mn:000098D9                 mov     ecx, [ebp+var_18]
.text$mn:000098DC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000098E1                 mov     ecx, eax
.text$mn:000098E3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000098E8                 mov     [ebp+var_20], eax
.text$mn:000098EB                 jmp     short loc_994A
.text$mn:000098EB ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:000098EB
.text$mn:000098ED
.text$mn:000098ED ; =============== S U B R O U T I N E =======================================
.text$mn:000098ED
.text$mn:000098ED
.text$mn:000098ED __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:000098ED                                         ; DATA XREF: .xdata$x:0000D1ACo
.text$mn:000098ED
.text$mn:000098ED ; FUNCTION CHUNK AT .text$mn:00009934 SIZE 00000009 BYTES
.text$mn:000098ED ; FUNCTION CHUNK AT .text$mn:00009944 SIZE 00000006 BYTES
.text$mn:000098ED
.text$mn:000098ED                 mov     [ebp-10h], esp
.text$mn:000098F0                 mov     edx, [ebp+8]
.text$mn:000098F3                 mov     [ebp-1Ch], edx
.text$mn:000098F6                 mov     byte ptr [ebp-4], 2
.text$mn:000098FA                 mov     eax, [ebp-1Ch]
.text$mn:000098FD                 add     eax, 1
.text$mn:00009900                 push    eax
.text$mn:00009901                 lea     ecx, [ebp-12h]
.text$mn:00009904                 push    ecx
.text$mn:00009905                 mov     ecx, [ebp-18h]
.text$mn:00009908                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000990D                 mov     ecx, eax
.text$mn:0000990F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00009914                 mov     [ebp-20h], eax
.text$mn:00009917                 jmp     short loc_9934
.text$mn:00009917 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00009917
.text$mn:00009919
.text$mn:00009919 ; =============== S U B R O U T I N E =======================================
.text$mn:00009919
.text$mn:00009919 ; Attributes: noreturn
.text$mn:00009919
.text$mn:00009919 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00009919                                         ; DATA XREF: .xdata$x:0000D1BCo
.text$mn:00009919                 push    0
.text$mn:0000991B                 push    1
.text$mn:0000991D                 mov     ecx, [ebp-18h]
.text$mn:00009920                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00009925                 push    0
.text$mn:00009927                 push    0
.text$mn:00009929                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009929 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00009929
.text$mn:0000992E ; ---------------------------------------------------------------------------
.text$mn:0000992E                 mov     eax, offset $LN17_0
.text$mn:00009933                 retn
.text$mn:00009934 ; ---------------------------------------------------------------------------
.text$mn:00009934 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00009934
.text$mn:00009934 loc_9934:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00009934                 mov     dword ptr [ebp-4], 1
.text$mn:0000993B                 jmp     short loc_9944
.text$mn:0000993B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000993D
.text$mn:0000993D ; =============== S U B R O U T I N E =======================================
.text$mn:0000993D
.text$mn:0000993D
.text$mn:0000993D $LN17_0         proc near               ; DATA XREF: .text$mn:0000992Eo
.text$mn:0000993D                 mov     dword ptr [ebp-4], 1
.text$mn:0000993D $LN17_0         endp ; sp-analysis failed
.text$mn:0000993D
.text$mn:00009944 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00009944
.text$mn:00009944 loc_9944:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00009944                 mov     eax, offset $LN19_0
.text$mn:00009949                 retn
.text$mn:00009949 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000994A ; ---------------------------------------------------------------------------
.text$mn:0000994A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000994A
.text$mn:0000994A loc_994A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:0000994A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009951                 jmp     short loc_995A
.text$mn:00009951 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00009953
.text$mn:00009953 ; =============== S U B R O U T I N E =======================================
.text$mn:00009953
.text$mn:00009953
.text$mn:00009953 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_9944o
.text$mn:00009953                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000995A
.text$mn:0000995A loc_995A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:0000995A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000995E                 jbe     short loc_9979
.text$mn:00009960                 mov     edx, [ebp+0Ch]
.text$mn:00009963                 push    edx             ; int
.text$mn:00009964                 mov     ecx, [ebp-18h]
.text$mn:00009967                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000996C                 push    eax             ; Src
.text$mn:0000996D                 mov     eax, [ebp-20h]
.text$mn:00009970                 push    eax             ; Dst
.text$mn:00009971                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009976                 add     esp, 0Ch
.text$mn:00009979
.text$mn:00009979 loc_9979:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00009979                 push    0
.text$mn:0000997B                 push    1
.text$mn:0000997D                 mov     ecx, [ebp-18h]
.text$mn:00009980                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00009985                 lea     ecx, [ebp-20h]
.text$mn:00009988                 push    ecx             ; int
.text$mn:00009989                 mov     edx, [ebp-18h]
.text$mn:0000998C                 add     edx, 4
.text$mn:0000998F                 push    edx             ; void *
.text$mn:00009990                 lea     eax, [ebp-13h]
.text$mn:00009993                 push    eax
.text$mn:00009994                 mov     ecx, [ebp-18h]
.text$mn:00009997                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000999C                 mov     ecx, eax
.text$mn:0000999E                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000099A3                 mov     ecx, [ebp-18h]
.text$mn:000099A6                 mov     edx, [ebp-1Ch]
.text$mn:000099A9                 mov     [ecx+18h], edx
.text$mn:000099AC                 mov     eax, [ebp+0Ch]
.text$mn:000099AF                 push    eax
.text$mn:000099B0                 mov     ecx, [ebp-18h]
.text$mn:000099B3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000099B8                 mov     ecx, [ebp-0Ch]
.text$mn:000099BB                 mov     large fs:0, ecx
.text$mn:000099C2                 pop     ecx
.text$mn:000099C3                 pop     edi
.text$mn:000099C4                 pop     esi
.text$mn:000099C5                 pop     ebx
.text$mn:000099C6                 mov     esp, ebp
.text$mn:000099C8                 pop     ebp
.text$mn:000099C9                 retn    8
.text$mn:000099C9 $LN19_0         endp ; sp-analysis failed
.text$mn:000099C9
.text$mn:000099C9 _text$mn        ends
.text$mn:000099C9
.text$x:000099CC ; ===========================================================================
.text$x:000099CC
.text$x:000099CC ; Segment type: Pure code
.text$x:000099CC ; Segment permissions: Read/Execute
.text$x:000099CC _text$x         segment para public 'CODE' use32
.text$x:000099CC                 assume cs:_text$x
.text$x:000099CC                 ;org 99CCh
.text$x:000099CC ; COMDAT (pick associative to section at 9828)
.text$x:000099CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000099CC
.text$x:000099CC ; =============== S U B R O U T I N E =======================================
.text$x:000099CC
.text$x:000099CC
.text$x:000099CC __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:000099CC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:000099CC
.text$x:000099CC arg_4           = dword ptr  8
.text$x:000099CC
.text$x:000099CC                 mov     edx, [esp+arg_4]
.text$x:000099D0                 lea     eax, [edx+0Ch]
.text$x:000099D3                 mov     ecx, [edx-24h]
.text$x:000099D6                 xor     ecx, eax
.text$x:000099D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000099DD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:000099E2                 jmp     ___CxxFrameHandler3
.text$x:000099E2 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:000099E2
.text$x:000099E2 ; ---------------------------------------------------------------------------
.text$x:000099E7                 align 4
.text$x:000099E7 _text$x         ends
.text$x:000099E7
.text$mn:000099E8 ; ===========================================================================
.text$mn:000099E8
.text$mn:000099E8 ; Segment type: Pure code
.text$mn:000099E8 ; Segment permissions: Read/Execute
.text$mn:000099E8 _text$mn        segment para public 'CODE' use32
.text$mn:000099E8                 assume cs:_text$mn
.text$mn:000099E8                 ;org 99E8h
.text$mn:000099E8 ; COMDAT (pick any)
.text$mn:000099E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000099E8
.text$mn:000099E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000099E8
.text$mn:000099E8 ; Attributes: bp-based frame
.text$mn:000099E8
.text$mn:000099E8 ; protected: void __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::_Destroy(struct KeyCombo *, struct KeyCombo *)
.text$mn:000099E8                 public ?_Destroy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXPAUKeyCombo@@0@Z
.text$mn:000099E8 ?_Destroy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXPAUKeyCombo@@0@Z proc near
.text$mn:000099E8                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+EDp
.text$mn:000099E8                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+191p ...
.text$mn:000099E8
.text$mn:000099E8 var_8           = dword ptr -8
.text$mn:000099E8 var_1           = byte ptr -1
.text$mn:000099E8 arg_0           = dword ptr  8
.text$mn:000099E8 arg_4           = dword ptr  0Ch
.text$mn:000099E8
.text$mn:000099E8                 push    ebp
.text$mn:000099E9                 mov     ebp, esp
.text$mn:000099EB                 sub     esp, 8
.text$mn:000099EE                 mov     [ebp+var_8], ecx
.text$mn:000099F1                 lea     eax, [ebp+var_1]
.text$mn:000099F4                 push    eax
.text$mn:000099F5                 mov     ecx, [ebp+var_8]
.text$mn:000099F8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:000099FD                 lea     ecx, [ebp+var_1]
.text$mn:00009A00                 push    ecx
.text$mn:00009A01                 mov     edx, [ebp+arg_4]
.text$mn:00009A04                 push    edx
.text$mn:00009A05                 mov     eax, [ebp+arg_0]
.text$mn:00009A08                 push    eax
.text$mn:00009A09                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@@std@@YAXPAUKeyCombo@@0AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<KeyCombo>>>(KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &)
.text$mn:00009A0E                 add     esp, 0Ch
.text$mn:00009A11                 mov     esp, ebp
.text$mn:00009A13                 pop     ebp
.text$mn:00009A14                 retn    8
.text$mn:00009A14 ?_Destroy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXPAUKeyCombo@@0@Z endp
.text$mn:00009A14
.text$mn:00009A14 ; ---------------------------------------------------------------------------
.text$mn:00009A17                 align 4
.text$mn:00009A17 _text$mn        ends
.text$mn:00009A17
.text$mn:00009A18 ; ===========================================================================
.text$mn:00009A18
.text$mn:00009A18 ; Segment type: Pure code
.text$mn:00009A18 ; Segment permissions: Read/Execute
.text$mn:00009A18 _text$mn        segment para public 'CODE' use32
.text$mn:00009A18                 assume cs:_text$mn
.text$mn:00009A18                 ;org 9A18h
.text$mn:00009A18 ; COMDAT (pick any)
.text$mn:00009A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A18
.text$mn:00009A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A18
.text$mn:00009A18 ; Attributes: bp-based frame
.text$mn:00009A18
.text$mn:00009A18 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Destroy(struct MenuItemUnit *, struct MenuItemUnit *)
.text$mn:00009A18                 public ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z
.text$mn:00009A18 ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z proc near
.text$mn:00009A18                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+CBp
.text$mn:00009A18                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Tidy(void)+2Bp
.text$mn:00009A18
.text$mn:00009A18 var_8           = dword ptr -8
.text$mn:00009A18 var_1           = byte ptr -1
.text$mn:00009A18 arg_0           = dword ptr  8
.text$mn:00009A18 arg_4           = dword ptr  0Ch
.text$mn:00009A18
.text$mn:00009A18                 push    ebp
.text$mn:00009A19                 mov     ebp, esp
.text$mn:00009A1B                 sub     esp, 8
.text$mn:00009A1E                 mov     [ebp+var_8], ecx
.text$mn:00009A21                 lea     eax, [ebp+var_1]
.text$mn:00009A24                 push    eax
.text$mn:00009A25                 mov     ecx, [ebp+var_8]
.text$mn:00009A28                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:00009A2D                 lea     ecx, [ebp+var_1]
.text$mn:00009A30                 push    ecx
.text$mn:00009A31                 mov     edx, [ebp+arg_4]
.text$mn:00009A34                 push    edx
.text$mn:00009A35                 mov     eax, [ebp+arg_0]
.text$mn:00009A38                 push    eax
.text$mn:00009A39                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)
.text$mn:00009A3E                 add     esp, 0Ch
.text$mn:00009A41                 mov     esp, ebp
.text$mn:00009A43                 pop     ebp
.text$mn:00009A44                 retn    8
.text$mn:00009A44 ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z endp
.text$mn:00009A44
.text$mn:00009A44 ; ---------------------------------------------------------------------------
.text$mn:00009A47                 align 4
.text$mn:00009A47 _text$mn        ends
.text$mn:00009A47
.text$mn:00009A48 ; ===========================================================================
.text$mn:00009A48
.text$mn:00009A48 ; Segment type: Pure code
.text$mn:00009A48 ; Segment permissions: Read/Execute
.text$mn:00009A48 _text$mn        segment para public 'CODE' use32
.text$mn:00009A48                 assume cs:_text$mn
.text$mn:00009A48                 ;org 9A48h
.text$mn:00009A48 ; COMDAT (pick any)
.text$mn:00009A48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A48
.text$mn:00009A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A48
.text$mn:00009A48 ; Attributes: bp-based frame
.text$mn:00009A48
.text$mn:00009A48 ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Destroy(struct recordedMacroStep *, struct recordedMacroStep *)
.text$mn:00009A48                 public ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z
.text$mn:00009A48 ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z proc near
.text$mn:00009A48                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+EDp
.text$mn:00009A48                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+191p ...
.text$mn:00009A48
.text$mn:00009A48 var_8           = dword ptr -8
.text$mn:00009A48 var_1           = byte ptr -1
.text$mn:00009A48 arg_0           = dword ptr  8
.text$mn:00009A48 arg_4           = dword ptr  0Ch
.text$mn:00009A48
.text$mn:00009A48                 push    ebp
.text$mn:00009A49                 mov     ebp, esp
.text$mn:00009A4B                 sub     esp, 8
.text$mn:00009A4E                 mov     [ebp+var_8], ecx
.text$mn:00009A51                 lea     eax, [ebp+var_1]
.text$mn:00009A54                 push    eax
.text$mn:00009A55                 mov     ecx, [ebp+var_8]
.text$mn:00009A58                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:00009A5D                 lea     ecx, [ebp+var_1]
.text$mn:00009A60                 push    ecx
.text$mn:00009A61                 mov     edx, [ebp+arg_4]
.text$mn:00009A64                 push    edx
.text$mn:00009A65                 mov     eax, [ebp+arg_0]
.text$mn:00009A68                 push    eax
.text$mn:00009A69                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:00009A6E                 add     esp, 0Ch
.text$mn:00009A71                 mov     esp, ebp
.text$mn:00009A73                 pop     ebp
.text$mn:00009A74                 retn    8
.text$mn:00009A74 ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z endp
.text$mn:00009A74
.text$mn:00009A74 ; ---------------------------------------------------------------------------
.text$mn:00009A77                 align 4
.text$mn:00009A77 _text$mn        ends
.text$mn:00009A77
.text$mn:00009A78 ; ===========================================================================
.text$mn:00009A78
.text$mn:00009A78 ; Segment type: Pure code
.text$mn:00009A78 ; Segment permissions: Read/Execute
.text$mn:00009A78 _text$mn        segment para public 'CODE' use32
.text$mn:00009A78                 assume cs:_text$mn
.text$mn:00009A78                 ;org 9A78h
.text$mn:00009A78 ; COMDAT (pick any)
.text$mn:00009A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A78
.text$mn:00009A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A78
.text$mn:00009A78 ; Attributes: bp-based frame
.text$mn:00009A78
.text$mn:00009A78 ; protected: void __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::_Destroy(class MacroShortcut *, class MacroShortcut *)
.text$mn:00009A78                 public ?_Destroy@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IAEXPAVMacroShortcut@@0@Z
.text$mn:00009A78 ?_Destroy@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IAEXPAVMacroShortcut@@0@Z proc near
.text$mn:00009A78                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+A4p
.text$mn:00009A78
.text$mn:00009A78 var_8           = dword ptr -8
.text$mn:00009A78 var_1           = byte ptr -1
.text$mn:00009A78 arg_0           = dword ptr  8
.text$mn:00009A78 arg_4           = dword ptr  0Ch
.text$mn:00009A78
.text$mn:00009A78                 push    ebp
.text$mn:00009A79                 mov     ebp, esp
.text$mn:00009A7B                 sub     esp, 8
.text$mn:00009A7E                 mov     [ebp+var_8], ecx
.text$mn:00009A81                 lea     eax, [ebp+var_1]
.text$mn:00009A84                 push    eax
.text$mn:00009A85                 mov     ecx, [ebp+var_8]
.text$mn:00009A88                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MacroShortcut,std::allocator<MacroShortcut>>>::_Getal(void)
.text$mn:00009A8D                 lea     ecx, [ebp+var_1]
.text$mn:00009A90                 push    ecx
.text$mn:00009A91                 mov     edx, [ebp+arg_4]
.text$mn:00009A94                 push    edx
.text$mn:00009A95                 mov     eax, [ebp+arg_0]
.text$mn:00009A98                 push    eax
.text$mn:00009A99                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@YAXPAVMacroShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MacroShortcut>>>(MacroShortcut *,MacroShortcut *,std::_Wrap_alloc<std::allocator<MacroShortcut>> &)
.text$mn:00009A9E                 add     esp, 0Ch
.text$mn:00009AA1                 mov     esp, ebp
.text$mn:00009AA3                 pop     ebp
.text$mn:00009AA4                 retn    8
.text$mn:00009AA4 ?_Destroy@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IAEXPAVMacroShortcut@@0@Z endp
.text$mn:00009AA4
.text$mn:00009AA4 ; ---------------------------------------------------------------------------
.text$mn:00009AA7                 align 4
.text$mn:00009AA7 _text$mn        ends
.text$mn:00009AA7
.text$mn:00009AA8 ; ===========================================================================
.text$mn:00009AA8
.text$mn:00009AA8 ; Segment type: Pure code
.text$mn:00009AA8 ; Segment permissions: Read/Execute
.text$mn:00009AA8 _text$mn        segment para public 'CODE' use32
.text$mn:00009AA8                 assume cs:_text$mn
.text$mn:00009AA8                 ;org 9AA8h
.text$mn:00009AA8 ; COMDAT (pick any)
.text$mn:00009AA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009AA8
.text$mn:00009AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AA8
.text$mn:00009AA8 ; Attributes: bp-based frame
.text$mn:00009AA8
.text$mn:00009AA8 ; protected: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Destroy(class UserCommand *, class UserCommand *)
.text$mn:00009AA8                 public ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z
.text$mn:00009AA8 ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z proc near
.text$mn:00009AA8                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+A4p
.text$mn:00009AA8
.text$mn:00009AA8 var_8           = dword ptr -8
.text$mn:00009AA8 var_1           = byte ptr -1
.text$mn:00009AA8 arg_0           = dword ptr  8
.text$mn:00009AA8 arg_4           = dword ptr  0Ch
.text$mn:00009AA8
.text$mn:00009AA8                 push    ebp
.text$mn:00009AA9                 mov     ebp, esp
.text$mn:00009AAB                 sub     esp, 8
.text$mn:00009AAE                 mov     [ebp+var_8], ecx
.text$mn:00009AB1                 lea     eax, [ebp+var_1]
.text$mn:00009AB4                 push    eax
.text$mn:00009AB5                 mov     ecx, [ebp+var_8]
.text$mn:00009AB8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:00009ABD                 lea     ecx, [ebp+var_1]
.text$mn:00009AC0                 push    ecx
.text$mn:00009AC1                 mov     edx, [ebp+arg_4]
.text$mn:00009AC4                 push    edx
.text$mn:00009AC5                 mov     eax, [ebp+arg_0]
.text$mn:00009AC8                 push    eax
.text$mn:00009AC9                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)
.text$mn:00009ACE                 add     esp, 0Ch
.text$mn:00009AD1                 mov     esp, ebp
.text$mn:00009AD3                 pop     ebp
.text$mn:00009AD4                 retn    8
.text$mn:00009AD4 ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z endp
.text$mn:00009AD4
.text$mn:00009AD4 ; ---------------------------------------------------------------------------
.text$mn:00009AD7                 align 4
.text$mn:00009AD7 _text$mn        ends
.text$mn:00009AD7
.text$mn:00009AD8 ; ===========================================================================
.text$mn:00009AD8
.text$mn:00009AD8 ; Segment type: Pure code
.text$mn:00009AD8 ; Segment permissions: Read/Execute
.text$mn:00009AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00009AD8                 assume cs:_text$mn
.text$mn:00009AD8                 ;org 9AD8h
.text$mn:00009AD8 ; COMDAT (pick any)
.text$mn:00009AD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009AD8
.text$mn:00009AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AD8
.text$mn:00009AD8 ; Attributes: bp-based frame
.text$mn:00009AD8
.text$mn:00009AD8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00009AD8                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00009AD8 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00009AD8                                         ; CODE XREF: $LN19+60p
.text$mn:00009AD8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00009AD8
.text$mn:00009AD8 var_8           = dword ptr -8
.text$mn:00009AD8 var_1           = byte ptr -1
.text$mn:00009AD8 arg_0           = dword ptr  8
.text$mn:00009AD8
.text$mn:00009AD8                 push    ebp
.text$mn:00009AD9                 mov     ebp, esp
.text$mn:00009ADB                 sub     esp, 8
.text$mn:00009ADE                 mov     [ebp+var_8], ecx
.text$mn:00009AE1                 mov     [ebp+var_1], 0
.text$mn:00009AE5                 mov     eax, [ebp+var_8]
.text$mn:00009AE8                 mov     ecx, [ebp+arg_0]
.text$mn:00009AEB                 mov     [eax+14h], ecx
.text$mn:00009AEE                 lea     edx, [ebp+var_1]
.text$mn:00009AF1                 push    edx
.text$mn:00009AF2                 mov     ecx, [ebp+var_8]
.text$mn:00009AF5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00009AFA                 add     eax, [ebp+arg_0]
.text$mn:00009AFD                 push    eax
.text$mn:00009AFE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00009B03                 add     esp, 8
.text$mn:00009B06                 mov     esp, ebp
.text$mn:00009B08                 pop     ebp
.text$mn:00009B09                 retn    4
.text$mn:00009B09 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00009B09
.text$mn:00009B09 _text$mn        ends
.text$mn:00009B09
.text$mn:00009B0C ; ===========================================================================
.text$mn:00009B0C
.text$mn:00009B0C ; Segment type: Pure code
.text$mn:00009B0C ; Segment permissions: Read/Execute
.text$mn:00009B0C _text$mn        segment para public 'CODE' use32
.text$mn:00009B0C                 assume cs:_text$mn
.text$mn:00009B0C                 ;org 9B0Ch
.text$mn:00009B0C ; COMDAT (pick any)
.text$mn:00009B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B0C
.text$mn:00009B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00009B0C
.text$mn:00009B0C ; Attributes: bp-based frame
.text$mn:00009B0C
.text$mn:00009B0C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00009B0C                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00009B0C ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00009B0C                                         ; CODE XREF: $LN19_0+60p
.text$mn:00009B0C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00009B0C
.text$mn:00009B0C var_8           = dword ptr -8
.text$mn:00009B0C var_2           = word ptr -2
.text$mn:00009B0C arg_0           = dword ptr  8
.text$mn:00009B0C
.text$mn:00009B0C                 push    ebp
.text$mn:00009B0D                 mov     ebp, esp
.text$mn:00009B0F                 sub     esp, 8
.text$mn:00009B12                 mov     [ebp+var_8], ecx
.text$mn:00009B15                 xor     eax, eax
.text$mn:00009B17                 mov     [ebp+var_2], ax
.text$mn:00009B1B                 mov     ecx, [ebp+var_8]
.text$mn:00009B1E                 mov     edx, [ebp+arg_0]
.text$mn:00009B21                 mov     [ecx+14h], edx
.text$mn:00009B24                 lea     eax, [ebp+var_2]
.text$mn:00009B27                 push    eax
.text$mn:00009B28                 mov     ecx, [ebp+var_8]
.text$mn:00009B2B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009B30                 mov     ecx, [ebp+arg_0]
.text$mn:00009B33                 lea     edx, [eax+ecx*2]
.text$mn:00009B36                 push    edx
.text$mn:00009B37                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00009B3C                 add     esp, 8
.text$mn:00009B3F                 mov     esp, ebp
.text$mn:00009B41                 pop     ebp
.text$mn:00009B42                 retn    4
.text$mn:00009B42 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00009B42
.text$mn:00009B42 ; ---------------------------------------------------------------------------
.text$mn:00009B45                 align 4
.text$mn:00009B45 _text$mn        ends
.text$mn:00009B45
.text$mn:00009B48 ; ===========================================================================
.text$mn:00009B48
.text$mn:00009B48 ; Segment type: Pure code
.text$mn:00009B48 ; Segment permissions: Read/Execute
.text$mn:00009B48 _text$mn        segment para public 'CODE' use32
.text$mn:00009B48                 assume cs:_text$mn
.text$mn:00009B48                 ;org 9B48h
.text$mn:00009B48 ; COMDAT (pick any)
.text$mn:00009B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B48
.text$mn:00009B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B48
.text$mn:00009B48 ; Attributes: bp-based frame
.text$mn:00009B48
.text$mn:00009B48 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00009B48                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00009B48 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009B48                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00009B48
.text$mn:00009B48 var_8           = dword ptr -8
.text$mn:00009B48 var_1           = byte ptr -1
.text$mn:00009B48
.text$mn:00009B48                 push    ebp
.text$mn:00009B49                 mov     ebp, esp
.text$mn:00009B4B                 sub     esp, 8
.text$mn:00009B4E                 mov     [ebp+var_8], ecx
.text$mn:00009B51                 lea     ecx, [ebp+var_1]
.text$mn:00009B54                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00009B59                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009B5C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009B61                 mov     eax, [ebp+var_8]
.text$mn:00009B64                 mov     ecx, [eax]
.text$mn:00009B66                 push    ecx
.text$mn:00009B67                 lea     ecx, [ebp+var_1]
.text$mn:00009B6A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00009B6F                 push    1               ; int
.text$mn:00009B71                 mov     edx, [ebp+var_8]
.text$mn:00009B74                 mov     eax, [edx]
.text$mn:00009B76                 push    eax             ; void *
.text$mn:00009B77                 lea     ecx, [ebp+var_1]
.text$mn:00009B7A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009B7F                 mov     ecx, [ebp+var_8]
.text$mn:00009B82                 mov     dword ptr [ecx], 0
.text$mn:00009B88                 mov     esp, ebp
.text$mn:00009B8A                 pop     ebp
.text$mn:00009B8B                 retn
.text$mn:00009B8B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009B8B
.text$mn:00009B8B _text$mn        ends
.text$mn:00009B8B
.text$mn:00009B8C ; ===========================================================================
.text$mn:00009B8C
.text$mn:00009B8C ; Segment type: Pure code
.text$mn:00009B8C ; Segment permissions: Read/Execute
.text$mn:00009B8C _text$mn        segment para public 'CODE' use32
.text$mn:00009B8C                 assume cs:_text$mn
.text$mn:00009B8C                 ;org 9B8Ch
.text$mn:00009B8C ; COMDAT (pick any)
.text$mn:00009B8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B8C
.text$mn:00009B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00009B8C
.text$mn:00009B8C ; Attributes: bp-based frame
.text$mn:00009B8C
.text$mn:00009B8C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00009B8C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00009B8C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009B8C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00009B8C
.text$mn:00009B8C var_8           = dword ptr -8
.text$mn:00009B8C var_1           = byte ptr -1
.text$mn:00009B8C
.text$mn:00009B8C                 push    ebp
.text$mn:00009B8D                 mov     ebp, esp
.text$mn:00009B8F                 sub     esp, 8
.text$mn:00009B92                 mov     [ebp+var_8], ecx
.text$mn:00009B95                 lea     ecx, [ebp+var_1]
.text$mn:00009B98                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00009B9D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009BA0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009BA5                 mov     eax, [ebp+var_8]
.text$mn:00009BA8                 mov     ecx, [eax]
.text$mn:00009BAA                 push    ecx
.text$mn:00009BAB                 lea     ecx, [ebp+var_1]
.text$mn:00009BAE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00009BB3                 push    1               ; int
.text$mn:00009BB5                 mov     edx, [ebp+var_8]
.text$mn:00009BB8                 mov     eax, [edx]
.text$mn:00009BBA                 push    eax             ; void *
.text$mn:00009BBB                 lea     ecx, [ebp+var_1]
.text$mn:00009BBE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009BC3                 mov     ecx, [ebp+var_8]
.text$mn:00009BC6                 mov     dword ptr [ecx], 0
.text$mn:00009BCC                 mov     esp, ebp
.text$mn:00009BCE                 pop     ebp
.text$mn:00009BCF                 retn
.text$mn:00009BCF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009BCF
.text$mn:00009BCF _text$mn        ends
.text$mn:00009BCF
.text$mn:00009BD0 ; ===========================================================================
.text$mn:00009BD0
.text$mn:00009BD0 ; Segment type: Pure code
.text$mn:00009BD0 ; Segment permissions: Read/Execute
.text$mn:00009BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00009BD0                 assume cs:_text$mn
.text$mn:00009BD0                 ;org 9BD0h
.text$mn:00009BD0 ; COMDAT (pick any)
.text$mn:00009BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009BD0
.text$mn:00009BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009BD0
.text$mn:00009BD0 ; Attributes: bp-based frame
.text$mn:00009BD0
.text$mn:00009BD0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>::_Free_proxy(void)
.text$mn:00009BD0                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ
.text$mn:00009BD0 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009BD0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::~_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>(void)+30p
.text$mn:00009BD0
.text$mn:00009BD0 var_8           = dword ptr -8
.text$mn:00009BD0 var_1           = byte ptr -1
.text$mn:00009BD0
.text$mn:00009BD0                 push    ebp
.text$mn:00009BD1                 mov     ebp, esp
.text$mn:00009BD3                 sub     esp, 8
.text$mn:00009BD6                 mov     [ebp+var_8], ecx
.text$mn:00009BD9                 lea     ecx, [ebp+var_1]
.text$mn:00009BDC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009BE1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009BE4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009BE9                 mov     eax, [ebp+var_8]
.text$mn:00009BEC                 mov     ecx, [eax]
.text$mn:00009BEE                 push    ecx
.text$mn:00009BEF                 lea     ecx, [ebp+var_1]
.text$mn:00009BF2                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00009BF7                 push    1               ; int
.text$mn:00009BF9                 mov     edx, [ebp+var_8]
.text$mn:00009BFC                 mov     eax, [edx]
.text$mn:00009BFE                 push    eax             ; void *
.text$mn:00009BFF                 lea     ecx, [ebp+var_1]
.text$mn:00009C02                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009C07                 mov     ecx, [ebp+var_8]
.text$mn:00009C0A                 mov     dword ptr [ecx], 0
.text$mn:00009C10                 mov     esp, ebp
.text$mn:00009C12                 pop     ebp
.text$mn:00009C13                 retn
.text$mn:00009C13 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009C13
.text$mn:00009C13 _text$mn        ends
.text$mn:00009C13
.text$mn:00009C14 ; ===========================================================================
.text$mn:00009C14
.text$mn:00009C14 ; Segment type: Pure code
.text$mn:00009C14 ; Segment permissions: Read/Execute
.text$mn:00009C14 _text$mn        segment para public 'CODE' use32
.text$mn:00009C14                 assume cs:_text$mn
.text$mn:00009C14                 ;org 9C14h
.text$mn:00009C14 ; COMDAT (pick any)
.text$mn:00009C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009C14
.text$mn:00009C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C14
.text$mn:00009C14 ; Attributes: bp-based frame
.text$mn:00009C14
.text$mn:00009C14 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Free_proxy(void)
.text$mn:00009C14                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ
.text$mn:00009C14 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009C14                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)+30p
.text$mn:00009C14
.text$mn:00009C14 var_8           = dword ptr -8
.text$mn:00009C14 var_1           = byte ptr -1
.text$mn:00009C14
.text$mn:00009C14                 push    ebp
.text$mn:00009C15                 mov     ebp, esp
.text$mn:00009C17                 sub     esp, 8
.text$mn:00009C1A                 mov     [ebp+var_8], ecx
.text$mn:00009C1D                 lea     ecx, [ebp+var_1]
.text$mn:00009C20                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009C25                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009C28                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009C2D                 mov     eax, [ebp+var_8]
.text$mn:00009C30                 mov     ecx, [eax]
.text$mn:00009C32                 push    ecx
.text$mn:00009C33                 lea     ecx, [ebp+var_1]
.text$mn:00009C36                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00009C3B                 push    1               ; int
.text$mn:00009C3D                 mov     edx, [ebp+var_8]
.text$mn:00009C40                 mov     eax, [edx]
.text$mn:00009C42                 push    eax             ; void *
.text$mn:00009C43                 lea     ecx, [ebp+var_1]
.text$mn:00009C46                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009C4B                 mov     ecx, [ebp+var_8]
.text$mn:00009C4E                 mov     dword ptr [ecx], 0
.text$mn:00009C54                 mov     esp, ebp
.text$mn:00009C56                 pop     ebp
.text$mn:00009C57                 retn
.text$mn:00009C57 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009C57
.text$mn:00009C57 _text$mn        ends
.text$mn:00009C57
.text$mn:00009C58 ; ===========================================================================
.text$mn:00009C58
.text$mn:00009C58 ; Segment type: Pure code
.text$mn:00009C58 ; Segment permissions: Read/Execute
.text$mn:00009C58 _text$mn        segment para public 'CODE' use32
.text$mn:00009C58                 assume cs:_text$mn
.text$mn:00009C58                 ;org 9C58h
.text$mn:00009C58 ; COMDAT (pick any)
.text$mn:00009C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009C58
.text$mn:00009C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C58
.text$mn:00009C58 ; Attributes: bp-based frame
.text$mn:00009C58
.text$mn:00009C58 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>::_Free_proxy(void)
.text$mn:00009C58                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ
.text$mn:00009C58 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00009C58                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::~_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>(void)+30p
.text$mn:00009C58
.text$mn:00009C58 var_8           = dword ptr -8
.text$mn:00009C58 var_1           = byte ptr -1
.text$mn:00009C58
.text$mn:00009C58                 push    ebp
.text$mn:00009C59                 mov     ebp, esp
.text$mn:00009C5B                 sub     esp, 8
.text$mn:00009C5E                 mov     [ebp+var_8], ecx
.text$mn:00009C61                 lea     ecx, [ebp+var_1]
.text$mn:00009C64                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00009C69                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009C6C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009C71                 mov     eax, [ebp+var_8]
.text$mn:00009C74                 mov     ecx, [eax]
.text$mn:00009C76                 push    ecx
.text$mn:00009C77                 lea     ecx, [ebp+var_1]
.text$mn:00009C7A                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00009C7F                 push    1               ; int
.text$mn:00009C81                 mov     edx, [ebp+var_8]
.text$mn:00009C84                 mov     eax, [edx]
.text$mn:00009C86                 push    eax             ; void *
.text$mn:00009C87                 lea     ecx, [ebp+var_1]
.text$mn:00009C8A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009C8F                 mov     ecx, [ebp+var_8]
.text$mn:00009C92                 mov     dword ptr [ecx], 0
.text$mn:00009C98                 mov     esp, ebp
.text$mn:00009C9A                 pop     ebp
.text$mn:00009C9B                 retn
.text$mn:00009C9B ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00009C9B
.text$mn:00009C9B _text$mn        ends
.text$mn:00009C9B
.text$mn:00009C9C ; ===========================================================================
.text$mn:00009C9C
.text$mn:00009C9C ; Segment type: Pure code
.text$mn:00009C9C ; Segment permissions: Read/Execute
.text$mn:00009C9C _text$mn        segment para public 'CODE' use32
.text$mn:00009C9C                 assume cs:_text$mn
.text$mn:00009C9C                 ;org 9C9Ch
.text$mn:00009C9C ; COMDAT (pick any)
.text$mn:00009C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009C9C
.text$mn:00009C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00009C9C
.text$mn:00009C9C ; Attributes: bp-based frame
.text$mn:00009C9C
.text$mn:00009C9C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00009C9C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00009C9C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00009C9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00009C9C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00009C9C
.text$mn:00009C9C var_4           = dword ptr -4
.text$mn:00009C9C arg_0           = dword ptr  8
.text$mn:00009C9C
.text$mn:00009C9C                 push    ebp
.text$mn:00009C9D                 mov     ebp, esp
.text$mn:00009C9F                 push    ecx
.text$mn:00009CA0                 mov     [ebp+var_4], ecx
.text$mn:00009CA3                 mov     ecx, [ebp+arg_0]
.text$mn:00009CA6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00009CAB                 mov     eax, [ebp+arg_0]
.text$mn:00009CAE                 mov     esp, ebp
.text$mn:00009CB0                 pop     ebp
.text$mn:00009CB1                 retn    4
.text$mn:00009CB1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00009CB1
.text$mn:00009CB1 _text$mn        ends
.text$mn:00009CB1
.text$mn:00009CB4 ; ===========================================================================
.text$mn:00009CB4
.text$mn:00009CB4 ; Segment type: Pure code
.text$mn:00009CB4 ; Segment permissions: Read/Execute
.text$mn:00009CB4 _text$mn        segment para public 'CODE' use32
.text$mn:00009CB4                 assume cs:_text$mn
.text$mn:00009CB4                 ;org 9CB4h
.text$mn:00009CB4 ; COMDAT (pick any)
.text$mn:00009CB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009CB4
.text$mn:00009CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CB4
.text$mn:00009CB4 ; Attributes: bp-based frame
.text$mn:00009CB4
.text$mn:00009CB4 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00009CB4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00009CB4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00009CB4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:00009CB4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+18p ...
.text$mn:00009CB4
.text$mn:00009CB4 var_4           = dword ptr -4
.text$mn:00009CB4 arg_0           = dword ptr  8
.text$mn:00009CB4
.text$mn:00009CB4                 push    ebp
.text$mn:00009CB5                 mov     ebp, esp
.text$mn:00009CB7                 push    ecx
.text$mn:00009CB8                 mov     [ebp+var_4], ecx
.text$mn:00009CBB                 mov     ecx, [ebp+arg_0]
.text$mn:00009CBE                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00009CC3                 mov     eax, [ebp+arg_0]
.text$mn:00009CC6                 mov     esp, ebp
.text$mn:00009CC8                 pop     ebp
.text$mn:00009CC9                 retn    4
.text$mn:00009CC9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00009CC9
.text$mn:00009CC9 _text$mn        ends
.text$mn:00009CC9
.text$mn:00009CCC ; ===========================================================================
.text$mn:00009CCC
.text$mn:00009CCC ; Segment type: Pure code
.text$mn:00009CCC ; Segment permissions: Read/Execute
.text$mn:00009CCC _text$mn        segment para public 'CODE' use32
.text$mn:00009CCC                 assume cs:_text$mn
.text$mn:00009CCC                 ;org 9CCCh
.text$mn:00009CCC ; COMDAT (pick any)
.text$mn:00009CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009CCC
.text$mn:00009CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00009CCC
.text$mn:00009CCC ; Attributes: bp-based frame
.text$mn:00009CCC
.text$mn:00009CCC ; public: struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct KeyCombo, class std::allocator<struct KeyCombo>>>::_Getal(void)const
.text$mn:00009CCC                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ
.text$mn:00009CCC ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ proc near
.text$mn:00009CCC                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<KeyCombo *>(KeyCombo *,KeyCombo *,KeyCombo *)+10p
.text$mn:00009CCC                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>,KeyCombo *)+36p ...
.text$mn:00009CCC
.text$mn:00009CCC var_4           = dword ptr -4
.text$mn:00009CCC arg_0           = dword ptr  8
.text$mn:00009CCC
.text$mn:00009CCC                 push    ebp
.text$mn:00009CCD                 mov     ebp, esp
.text$mn:00009CCF                 push    ecx
.text$mn:00009CD0                 mov     [ebp+var_4], ecx
.text$mn:00009CD3                 mov     ecx, [ebp+arg_0]
.text$mn:00009CD6                 call    ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<KeyCombo>>::_Wrap_alloc<std::allocator<KeyCombo>>(void)
.text$mn:00009CDB                 mov     eax, [ebp+arg_0]
.text$mn:00009CDE                 mov     esp, ebp
.text$mn:00009CE0                 pop     ebp
.text$mn:00009CE1                 retn    4
.text$mn:00009CE1 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ endp
.text$mn:00009CE1
.text$mn:00009CE1 _text$mn        ends
.text$mn:00009CE1
.text$mn:00009CE4 ; ===========================================================================
.text$mn:00009CE4
.text$mn:00009CE4 ; Segment type: Pure code
.text$mn:00009CE4 ; Segment permissions: Read/Execute
.text$mn:00009CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00009CE4                 assume cs:_text$mn
.text$mn:00009CE4                 ;org 9CE4h
.text$mn:00009CE4 ; COMDAT (pick any)
.text$mn:00009CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009CE4
.text$mn:00009CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CE4
.text$mn:00009CE4 ; Attributes: bp-based frame
.text$mn:00009CE4
.text$mn:00009CE4 ; public: struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Getal(void)const
.text$mn:00009CE4                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ
.text$mn:00009CE4 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ proc near
.text$mn:00009CE4                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Umove<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *)+10p
.text$mn:00009CE4                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)+10p ...
.text$mn:00009CE4
.text$mn:00009CE4 var_4           = dword ptr -4
.text$mn:00009CE4 arg_0           = dword ptr  8
.text$mn:00009CE4
.text$mn:00009CE4                 push    ebp
.text$mn:00009CE5                 mov     ebp, esp
.text$mn:00009CE7                 push    ecx
.text$mn:00009CE8                 mov     [ebp+var_4], ecx
.text$mn:00009CEB                 mov     ecx, [ebp+arg_0]
.text$mn:00009CEE                 call    ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::_Wrap_alloc<std::allocator<MenuItemUnit>>(void)
.text$mn:00009CF3                 mov     eax, [ebp+arg_0]
.text$mn:00009CF6                 mov     esp, ebp
.text$mn:00009CF8                 pop     ebp
.text$mn:00009CF9                 retn    4
.text$mn:00009CF9 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ endp
.text$mn:00009CF9
.text$mn:00009CF9 _text$mn        ends
.text$mn:00009CF9
.text$mn:00009CFC ; ===========================================================================
.text$mn:00009CFC
.text$mn:00009CFC ; Segment type: Pure code
.text$mn:00009CFC ; Segment permissions: Read/Execute
.text$mn:00009CFC _text$mn        segment para public 'CODE' use32
.text$mn:00009CFC                 assume cs:_text$mn
.text$mn:00009CFC                 ;org 9CFCh
.text$mn:00009CFC ; COMDAT (pick any)
.text$mn:00009CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009CFC
.text$mn:00009CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00009CFC
.text$mn:00009CFC ; Attributes: bp-based frame
.text$mn:00009CFC
.text$mn:00009CFC ; public: struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>::_Getal(void)const
.text$mn:00009CFC                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ
.text$mn:00009CFC ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ proc near
.text$mn:00009CFC                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)+10p
.text$mn:00009CFC                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>,recordedMacroStep *)+36p ...
.text$mn:00009CFC
.text$mn:00009CFC var_4           = dword ptr -4
.text$mn:00009CFC arg_0           = dword ptr  8
.text$mn:00009CFC
.text$mn:00009CFC                 push    ebp
.text$mn:00009CFD                 mov     ebp, esp
.text$mn:00009CFF                 push    ecx
.text$mn:00009D00                 mov     [ebp+var_4], ecx
.text$mn:00009D03                 mov     ecx, [ebp+arg_0]
.text$mn:00009D06                 call    ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::_Wrap_alloc<std::allocator<recordedMacroStep>>(void)
.text$mn:00009D0B                 mov     eax, [ebp+arg_0]
.text$mn:00009D0E                 mov     esp, ebp
.text$mn:00009D10                 pop     ebp
.text$mn:00009D11                 retn    4
.text$mn:00009D11 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ endp
.text$mn:00009D11
.text$mn:00009D11 _text$mn        ends
.text$mn:00009D11
.text$mn:00009D14 ; ===========================================================================
.text$mn:00009D14
.text$mn:00009D14 ; Segment type: Pure code
.text$mn:00009D14 ; Segment permissions: Read/Execute
.text$mn:00009D14 _text$mn        segment para public 'CODE' use32
.text$mn:00009D14                 assume cs:_text$mn
.text$mn:00009D14                 ;org 9D14h
.text$mn:00009D14 ; COMDAT (pick any)
.text$mn:00009D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D14
.text$mn:00009D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D14
.text$mn:00009D14 ; Attributes: bp-based frame
.text$mn:00009D14
.text$mn:00009D14 ; public: struct std::_Wrap_alloc<class std::allocator<class MacroShortcut>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class MacroShortcut, class std::allocator<class MacroShortcut>>>::_Getal(void)const
.text$mn:00009D14                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@2@XZ
.text$mn:00009D14 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@2@XZ proc near
.text$mn:00009D14                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Destroy(MacroShortcut *,MacroShortcut *)+10p
.text$mn:00009D14
.text$mn:00009D14 var_4           = dword ptr -4
.text$mn:00009D14 arg_0           = dword ptr  8
.text$mn:00009D14
.text$mn:00009D14                 push    ebp
.text$mn:00009D15                 mov     ebp, esp
.text$mn:00009D17                 push    ecx
.text$mn:00009D18                 mov     [ebp+var_4], ecx
.text$mn:00009D1B                 mov     ecx, [ebp+arg_0]
.text$mn:00009D1E                 call    ??0?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<MacroShortcut>>::_Wrap_alloc<std::allocator<MacroShortcut>>(void)
.text$mn:00009D23                 mov     eax, [ebp+arg_0]
.text$mn:00009D26                 mov     esp, ebp
.text$mn:00009D28                 pop     ebp
.text$mn:00009D29                 retn    4
.text$mn:00009D29 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VMacroShortcut@@@std@@@2@XZ endp
.text$mn:00009D29
.text$mn:00009D29 _text$mn        ends
.text$mn:00009D29
.text$mn:00009D2C ; ===========================================================================
.text$mn:00009D2C
.text$mn:00009D2C ; Segment type: Pure code
.text$mn:00009D2C ; Segment permissions: Read/Execute
.text$mn:00009D2C _text$mn        segment para public 'CODE' use32
.text$mn:00009D2C                 assume cs:_text$mn
.text$mn:00009D2C                 ;org 9D2Ch
.text$mn:00009D2C ; COMDAT (pick any)
.text$mn:00009D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D2C
.text$mn:00009D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00009D2C
.text$mn:00009D2C ; Attributes: bp-based frame
.text$mn:00009D2C
.text$mn:00009D2C ; public: struct std::_Wrap_alloc<class std::allocator<class UserCommand>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class UserCommand, class std::allocator<class UserCommand>>>::_Getal(void)const
.text$mn:00009D2C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ
.text$mn:00009D2C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ proc near
.text$mn:00009D2C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Destroy(UserCommand *,UserCommand *)+10p
.text$mn:00009D2C
.text$mn:00009D2C var_4           = dword ptr -4
.text$mn:00009D2C arg_0           = dword ptr  8
.text$mn:00009D2C
.text$mn:00009D2C                 push    ebp
.text$mn:00009D2D                 mov     ebp, esp
.text$mn:00009D2F                 push    ecx
.text$mn:00009D30                 mov     [ebp+var_4], ecx
.text$mn:00009D33                 mov     ecx, [ebp+arg_0]
.text$mn:00009D36                 call    ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<UserCommand>>::_Wrap_alloc<std::allocator<UserCommand>>(void)
.text$mn:00009D3B                 mov     eax, [ebp+arg_0]
.text$mn:00009D3E                 mov     esp, ebp
.text$mn:00009D40                 pop     ebp
.text$mn:00009D41                 retn    4
.text$mn:00009D41 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ endp
.text$mn:00009D41
.text$mn:00009D41 _text$mn        ends
.text$mn:00009D41
.text$mn:00009D44 ; ===========================================================================
.text$mn:00009D44
.text$mn:00009D44 ; Segment type: Pure code
.text$mn:00009D44 ; Segment permissions: Read/Execute
.text$mn:00009D44 _text$mn        segment para public 'CODE' use32
.text$mn:00009D44                 assume cs:_text$mn
.text$mn:00009D44                 ;org 9D44h
.text$mn:00009D44 ; COMDAT (pick any)
.text$mn:00009D44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D44
.text$mn:00009D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D44
.text$mn:00009D44 ; Attributes: bp-based frame
.text$mn:00009D44
.text$mn:00009D44 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00009D44                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00009D44 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00009D44                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+Bp
.text$mn:00009D44                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+24p ...
.text$mn:00009D44
.text$mn:00009D44 var_8           = dword ptr -8
.text$mn:00009D44 var_4           = dword ptr -4
.text$mn:00009D44
.text$mn:00009D44                 push    ebp
.text$mn:00009D45                 mov     ebp, esp
.text$mn:00009D47                 sub     esp, 8
.text$mn:00009D4A                 mov     [ebp+var_4], ecx
.text$mn:00009D4D                 mov     eax, [ebp+var_4]
.text$mn:00009D50                 cmp     dword ptr [eax], 0
.text$mn:00009D53                 jnz     short loc_9D5E
.text$mn:00009D55                 mov     [ebp+var_8], 0
.text$mn:00009D5C                 jmp     short loc_9D68
.text$mn:00009D5E ; ---------------------------------------------------------------------------
.text$mn:00009D5E
.text$mn:00009D5E loc_9D5E:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:00009D5E                 mov     ecx, [ebp+var_4]
.text$mn:00009D61                 mov     edx, [ecx]
.text$mn:00009D63                 mov     eax, [edx]
.text$mn:00009D65                 mov     [ebp+var_8], eax
.text$mn:00009D68
.text$mn:00009D68 loc_9D68:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00009D68                 mov     eax, [ebp+var_8]
.text$mn:00009D6B                 mov     esp, ebp
.text$mn:00009D6D                 pop     ebp
.text$mn:00009D6E                 retn
.text$mn:00009D6E ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:00009D6E
.text$mn:00009D6E ; ---------------------------------------------------------------------------
.text$mn:00009D6F                 align 10h
.text$mn:00009D6F _text$mn        ends
.text$mn:00009D6F
.text$mn:00009D70 ; ===========================================================================
.text$mn:00009D70
.text$mn:00009D70 ; Segment type: Pure code
.text$mn:00009D70 ; Segment permissions: Read/Execute
.text$mn:00009D70 _text$mn        segment para public 'CODE' use32
.text$mn:00009D70                 assume cs:_text$mn
.text$mn:00009D70                 ;org 9D70h
.text$mn:00009D70 ; COMDAT (pick any)
.text$mn:00009D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D70
.text$mn:00009D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D70
.text$mn:00009D70 ; Attributes: bp-based frame
.text$mn:00009D70
.text$mn:00009D70 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00009D70                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00009D70 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00009D70                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+3Cp
.text$mn:00009D70                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+3Cp ...
.text$mn:00009D70
.text$mn:00009D70 var_8           = dword ptr -8
.text$mn:00009D70 var_4           = dword ptr -4
.text$mn:00009D70
.text$mn:00009D70                 push    ebp
.text$mn:00009D71                 mov     ebp, esp
.text$mn:00009D73                 sub     esp, 8
.text$mn:00009D76                 mov     [ebp+var_4], ecx
.text$mn:00009D79                 mov     eax, [ebp+var_4]
.text$mn:00009D7C                 cmp     dword ptr [eax], 0
.text$mn:00009D7F                 jnz     short loc_9D8A
.text$mn:00009D81                 mov     [ebp+var_8], 0
.text$mn:00009D88                 jmp     short loc_9D95
.text$mn:00009D8A ; ---------------------------------------------------------------------------
.text$mn:00009D8A
.text$mn:00009D8A loc_9D8A:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00009D8A                 mov     ecx, [ebp+var_4]
.text$mn:00009D8D                 mov     edx, [ecx]
.text$mn:00009D8F                 add     edx, 4
.text$mn:00009D92                 mov     [ebp+var_8], edx
.text$mn:00009D95
.text$mn:00009D95 loc_9D95:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00009D95                 mov     eax, [ebp+var_8]
.text$mn:00009D98                 mov     esp, ebp
.text$mn:00009D9A                 pop     ebp
.text$mn:00009D9B                 retn
.text$mn:00009D9B ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00009D9B
.text$mn:00009D9B _text$mn        ends
.text$mn:00009D9B
.text$mn:00009D9C ; ===========================================================================
.text$mn:00009D9C
.text$mn:00009D9C ; Segment type: Pure code
.text$mn:00009D9C ; Segment permissions: Read/Execute
.text$mn:00009D9C _text$mn        segment para public 'CODE' use32
.text$mn:00009D9C                 assume cs:_text$mn
.text$mn:00009D9C                 ;org 9D9Ch
.text$mn:00009D9C ; COMDAT (pick any)
.text$mn:00009D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D9C
.text$mn:00009D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00009D9C
.text$mn:00009D9C ; Attributes: bp-based frame
.text$mn:00009D9C
.text$mn:00009D9C ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00009D9C                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00009D9C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00009D9C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+71p
.text$mn:00009D9C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+8Ap ...
.text$mn:00009D9C
.text$mn:00009D9C var_4           = dword ptr -4
.text$mn:00009D9C
.text$mn:00009D9C                 push    ebp
.text$mn:00009D9D                 mov     ebp, esp
.text$mn:00009D9F                 push    ecx
.text$mn:00009DA0                 mov     [ebp+var_4], ecx
.text$mn:00009DA3                 mov     eax, [ebp+var_4]
.text$mn:00009DA6                 add     eax, 4
.text$mn:00009DA9                 mov     esp, ebp
.text$mn:00009DAB                 pop     ebp
.text$mn:00009DAC                 retn
.text$mn:00009DAC ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00009DAC
.text$mn:00009DAC ; ---------------------------------------------------------------------------
.text$mn:00009DAD                 align 10h
.text$mn:00009DAD _text$mn        ends
.text$mn:00009DAD
.text$mn:00009DB0 ; ===========================================================================
.text$mn:00009DB0
.text$mn:00009DB0 ; Segment type: Pure code
.text$mn:00009DB0 ; Segment permissions: Read/Execute
.text$mn:00009DB0 _text$mn        segment para public 'CODE' use32
.text$mn:00009DB0                 assume cs:_text$mn
.text$mn:00009DB0                 ;org 9DB0h
.text$mn:00009DB0 ; COMDAT (pick any)
.text$mn:00009DB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DB0
.text$mn:00009DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DB0
.text$mn:00009DB0 ; Attributes: bp-based frame
.text$mn:00009DB0
.text$mn:00009DB0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00009DB0                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00009DB0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00009DB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00009DB0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00009DB0
.text$mn:00009DB0 var_C           = dword ptr -0Ch
.text$mn:00009DB0 Size            = dword ptr -8
.text$mn:00009DB0 var_4           = dword ptr -4
.text$mn:00009DB0 arg_0           = dword ptr  8
.text$mn:00009DB0 arg_4           = byte ptr  0Ch
.text$mn:00009DB0
.text$mn:00009DB0                 push    ebp
.text$mn:00009DB1                 mov     ebp, esp
.text$mn:00009DB3                 sub     esp, 0Ch
.text$mn:00009DB6                 mov     [ebp+var_4], ecx
.text$mn:00009DB9                 mov     ecx, [ebp+var_4]
.text$mn:00009DBC                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00009DC1                 cmp     eax, [ebp+arg_0]
.text$mn:00009DC4                 jnb     short loc_9DCE
.text$mn:00009DC6                 mov     ecx, [ebp+var_4]
.text$mn:00009DC9                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00009DCE
.text$mn:00009DCE loc_9DCE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00009DCE                 mov     eax, [ebp+var_4]
.text$mn:00009DD1                 mov     ecx, [eax+18h]
.text$mn:00009DD4                 cmp     ecx, [ebp+arg_0]
.text$mn:00009DD7                 jnb     short loc_9DEE
.text$mn:00009DD9                 mov     edx, [ebp+var_4]
.text$mn:00009DDC                 mov     eax, [edx+14h]
.text$mn:00009DDF                 push    eax
.text$mn:00009DE0                 mov     ecx, [ebp+arg_0]
.text$mn:00009DE3                 push    ecx
.text$mn:00009DE4                 mov     ecx, [ebp+var_4]
.text$mn:00009DE7                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00009DEC                 jmp     short loc_9E38
.text$mn:00009DEE ; ---------------------------------------------------------------------------
.text$mn:00009DEE
.text$mn:00009DEE loc_9DEE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00009DEE                 movzx   edx, [ebp+arg_4]
.text$mn:00009DF2                 test    edx, edx
.text$mn:00009DF4                 jz      short loc_9E28
.text$mn:00009DF6                 cmp     [ebp+arg_0], 10h
.text$mn:00009DFA                 jnb     short loc_9E28
.text$mn:00009DFC                 mov     eax, [ebp+var_4]
.text$mn:00009DFF                 mov     ecx, [ebp+arg_0]
.text$mn:00009E02                 cmp     ecx, [eax+14h]
.text$mn:00009E05                 jnb     short loc_9E0F
.text$mn:00009E07                 mov     edx, [ebp+arg_0]
.text$mn:00009E0A                 mov     [ebp+Size], edx
.text$mn:00009E0D                 jmp     short loc_9E18
.text$mn:00009E0F ; ---------------------------------------------------------------------------
.text$mn:00009E0F
.text$mn:00009E0F loc_9E0F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00009E0F                 mov     eax, [ebp+var_4]
.text$mn:00009E12                 mov     ecx, [eax+14h]
.text$mn:00009E15                 mov     [ebp+Size], ecx
.text$mn:00009E18
.text$mn:00009E18 loc_9E18:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00009E18                 mov     edx, [ebp+Size]
.text$mn:00009E1B                 push    edx             ; Size
.text$mn:00009E1C                 push    1               ; char
.text$mn:00009E1E                 mov     ecx, [ebp+var_4]
.text$mn:00009E21                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00009E26                 jmp     short loc_9E38
.text$mn:00009E28 ; ---------------------------------------------------------------------------
.text$mn:00009E28
.text$mn:00009E28 loc_9E28:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00009E28                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00009E28                 cmp     [ebp+arg_0], 0
.text$mn:00009E2C                 jnz     short loc_9E38
.text$mn:00009E2E                 push    0
.text$mn:00009E30                 mov     ecx, [ebp+var_4]
.text$mn:00009E33                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00009E38
.text$mn:00009E38 loc_9E38:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00009E38                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00009E38                 cmp     [ebp+arg_0], 0
.text$mn:00009E3C                 jbe     short loc_9E47
.text$mn:00009E3E                 mov     [ebp+var_C], 1
.text$mn:00009E45                 jmp     short loc_9E4E
.text$mn:00009E47 ; ---------------------------------------------------------------------------
.text$mn:00009E47
.text$mn:00009E47 loc_9E47:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00009E47                 mov     [ebp+var_C], 0
.text$mn:00009E4E
.text$mn:00009E4E loc_9E4E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00009E4E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00009E51                 mov     esp, ebp
.text$mn:00009E53                 pop     ebp
.text$mn:00009E54                 retn    8
.text$mn:00009E54 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00009E54
.text$mn:00009E54 ; ---------------------------------------------------------------------------
.text$mn:00009E57                 align 4
.text$mn:00009E57 _text$mn        ends
.text$mn:00009E57
.text$mn:00009E58 ; ===========================================================================
.text$mn:00009E58
.text$mn:00009E58 ; Segment type: Pure code
.text$mn:00009E58 ; Segment permissions: Read/Execute
.text$mn:00009E58 _text$mn        segment para public 'CODE' use32
.text$mn:00009E58                 assume cs:_text$mn
.text$mn:00009E58                 ;org 9E58h
.text$mn:00009E58 ; COMDAT (pick any)
.text$mn:00009E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009E58
.text$mn:00009E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E58
.text$mn:00009E58 ; Attributes: bp-based frame
.text$mn:00009E58
.text$mn:00009E58 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00009E58                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00009E58 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00009E58                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00009E58
.text$mn:00009E58 var_C           = dword ptr -0Ch
.text$mn:00009E58 var_8           = dword ptr -8
.text$mn:00009E58 var_4           = dword ptr -4
.text$mn:00009E58 arg_0           = dword ptr  8
.text$mn:00009E58 arg_4           = byte ptr  0Ch
.text$mn:00009E58
.text$mn:00009E58                 push    ebp
.text$mn:00009E59                 mov     ebp, esp
.text$mn:00009E5B                 sub     esp, 0Ch
.text$mn:00009E5E                 mov     [ebp+var_4], ecx
.text$mn:00009E61                 mov     ecx, [ebp+var_4]
.text$mn:00009E64                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00009E69                 cmp     eax, [ebp+arg_0]
.text$mn:00009E6C                 jnb     short loc_9E76
.text$mn:00009E6E                 mov     ecx, [ebp+var_4]
.text$mn:00009E71                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00009E76
.text$mn:00009E76 loc_9E76:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00009E76                 mov     eax, [ebp+var_4]
.text$mn:00009E79                 mov     ecx, [eax+18h]
.text$mn:00009E7C                 cmp     ecx, [ebp+arg_0]
.text$mn:00009E7F                 jnb     short loc_9E96
.text$mn:00009E81                 mov     edx, [ebp+var_4]
.text$mn:00009E84                 mov     eax, [edx+14h]
.text$mn:00009E87                 push    eax
.text$mn:00009E88                 mov     ecx, [ebp+arg_0]
.text$mn:00009E8B                 push    ecx
.text$mn:00009E8C                 mov     ecx, [ebp+var_4]
.text$mn:00009E8F                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00009E94                 jmp     short loc_9EE0
.text$mn:00009E96 ; ---------------------------------------------------------------------------
.text$mn:00009E96
.text$mn:00009E96 loc_9E96:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00009E96                 movzx   edx, [ebp+arg_4]
.text$mn:00009E9A                 test    edx, edx
.text$mn:00009E9C                 jz      short loc_9ED0
.text$mn:00009E9E                 cmp     [ebp+arg_0], 8
.text$mn:00009EA2                 jnb     short loc_9ED0
.text$mn:00009EA4                 mov     eax, [ebp+var_4]
.text$mn:00009EA7                 mov     ecx, [ebp+arg_0]
.text$mn:00009EAA                 cmp     ecx, [eax+14h]
.text$mn:00009EAD                 jnb     short loc_9EB7
.text$mn:00009EAF                 mov     edx, [ebp+arg_0]
.text$mn:00009EB2                 mov     [ebp+var_8], edx
.text$mn:00009EB5                 jmp     short loc_9EC0
.text$mn:00009EB7 ; ---------------------------------------------------------------------------
.text$mn:00009EB7
.text$mn:00009EB7 loc_9EB7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00009EB7                 mov     eax, [ebp+var_4]
.text$mn:00009EBA                 mov     ecx, [eax+14h]
.text$mn:00009EBD                 mov     [ebp+var_8], ecx
.text$mn:00009EC0
.text$mn:00009EC0 loc_9EC0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00009EC0                 mov     edx, [ebp+var_8]
.text$mn:00009EC3                 push    edx
.text$mn:00009EC4                 push    1
.text$mn:00009EC6                 mov     ecx, [ebp+var_4]
.text$mn:00009EC9                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00009ECE                 jmp     short loc_9EE0
.text$mn:00009ED0 ; ---------------------------------------------------------------------------
.text$mn:00009ED0
.text$mn:00009ED0 loc_9ED0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00009ED0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00009ED0                 cmp     [ebp+arg_0], 0
.text$mn:00009ED4                 jnz     short loc_9EE0
.text$mn:00009ED6                 push    0
.text$mn:00009ED8                 mov     ecx, [ebp+var_4]
.text$mn:00009EDB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009EE0
.text$mn:00009EE0 loc_9EE0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00009EE0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00009EE0                 cmp     [ebp+arg_0], 0
.text$mn:00009EE4                 jbe     short loc_9EEF
.text$mn:00009EE6                 mov     [ebp+var_C], 1
.text$mn:00009EED                 jmp     short loc_9EF6
.text$mn:00009EEF ; ---------------------------------------------------------------------------
.text$mn:00009EEF
.text$mn:00009EEF loc_9EEF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00009EEF                 mov     [ebp+var_C], 0
.text$mn:00009EF6
.text$mn:00009EF6 loc_9EF6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00009EF6                 mov     al, byte ptr [ebp+var_C]
.text$mn:00009EF9                 mov     esp, ebp
.text$mn:00009EFB                 pop     ebp
.text$mn:00009EFC                 retn    8
.text$mn:00009EFC ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00009EFC
.text$mn:00009EFC ; ---------------------------------------------------------------------------
.text$mn:00009EFF                 align 10h
.text$mn:00009EFF _text$mn        ends
.text$mn:00009EFF
.text$mn:00009F00 ; ===========================================================================
.text$mn:00009F00
.text$mn:00009F00 ; Segment type: Pure code
.text$mn:00009F00 ; Segment permissions: Read/Execute
.text$mn:00009F00 _text$mn        segment para public 'CODE' use32
.text$mn:00009F00                 assume cs:_text$mn
.text$mn:00009F00                 ;org 9F00h
.text$mn:00009F00 ; COMDAT (pick any)
.text$mn:00009F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009F00
.text$mn:00009F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F00
.text$mn:00009F00 ; Attributes: bp-based frame
.text$mn:00009F00
.text$mn:00009F00 ; protected: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Grow_to(unsigned int)const
.text$mn:00009F00                 public ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z
.text$mn:00009F00 ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z proc near
.text$mn:00009F00                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+45p
.text$mn:00009F00
.text$mn:00009F00 var_C           = dword ptr -0Ch
.text$mn:00009F00 var_8           = dword ptr -8
.text$mn:00009F00 var_4           = dword ptr -4
.text$mn:00009F00 arg_0           = dword ptr  8
.text$mn:00009F00
.text$mn:00009F00                 push    ebp
.text$mn:00009F01                 mov     ebp, esp
.text$mn:00009F03                 sub     esp, 0Ch
.text$mn:00009F06                 mov     [ebp+var_8], ecx
.text$mn:00009F09                 mov     ecx, [ebp+var_8]
.text$mn:00009F0C                 call    ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::capacity(void)
.text$mn:00009F11                 mov     [ebp+var_4], eax
.text$mn:00009F14                 mov     ecx, [ebp+var_8]
.text$mn:00009F17                 call    ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::max_size(void)
.text$mn:00009F1C                 mov     ecx, [ebp+var_4]
.text$mn:00009F1F                 shr     ecx, 1
.text$mn:00009F21                 sub     eax, ecx
.text$mn:00009F23                 cmp     eax, [ebp+var_4]
.text$mn:00009F26                 jnb     short loc_9F31
.text$mn:00009F28                 mov     [ebp+var_C], 0
.text$mn:00009F2F                 jmp     short loc_9F3C
.text$mn:00009F31 ; ---------------------------------------------------------------------------
.text$mn:00009F31
.text$mn:00009F31 loc_9F31:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+26j
.text$mn:00009F31                 mov     edx, [ebp+var_4]
.text$mn:00009F34                 shr     edx, 1
.text$mn:00009F36                 add     edx, [ebp+var_4]
.text$mn:00009F39                 mov     [ebp+var_C], edx
.text$mn:00009F3C
.text$mn:00009F3C loc_9F3C:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+2Fj
.text$mn:00009F3C                 mov     eax, [ebp+var_C]
.text$mn:00009F3F                 mov     [ebp+var_4], eax
.text$mn:00009F42                 mov     ecx, [ebp+var_4]
.text$mn:00009F45                 cmp     ecx, [ebp+arg_0]
.text$mn:00009F48                 jnb     short loc_9F50
.text$mn:00009F4A                 mov     edx, [ebp+arg_0]
.text$mn:00009F4D                 mov     [ebp+var_4], edx
.text$mn:00009F50
.text$mn:00009F50 loc_9F50:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+48j
.text$mn:00009F50                 mov     eax, [ebp+var_4]
.text$mn:00009F53                 mov     esp, ebp
.text$mn:00009F55                 pop     ebp
.text$mn:00009F56                 retn    4
.text$mn:00009F56 ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z endp
.text$mn:00009F56
.text$mn:00009F56 ; ---------------------------------------------------------------------------
.text$mn:00009F59                 align 4
.text$mn:00009F59 _text$mn        ends
.text$mn:00009F59
.text$mn:00009F5C ; ===========================================================================
.text$mn:00009F5C
.text$mn:00009F5C ; Segment type: Pure code
.text$mn:00009F5C ; Segment permissions: Read/Execute
.text$mn:00009F5C _text$mn        segment para public 'CODE' use32
.text$mn:00009F5C                 assume cs:_text$mn
.text$mn:00009F5C                 ;org 9F5Ch
.text$mn:00009F5C ; COMDAT (pick any)
.text$mn:00009F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009F5C
.text$mn:00009F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00009F5C
.text$mn:00009F5C ; Attributes: bp-based frame
.text$mn:00009F5C
.text$mn:00009F5C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00009F5C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00009F5C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00009F5C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00009F5C
.text$mn:00009F5C var_4           = dword ptr -4
.text$mn:00009F5C arg_0           = dword ptr  8
.text$mn:00009F5C
.text$mn:00009F5C                 push    ebp
.text$mn:00009F5D                 mov     ebp, esp
.text$mn:00009F5F                 push    ecx
.text$mn:00009F60                 mov     [ebp+var_4], ecx
.text$mn:00009F63                 cmp     [ebp+arg_0], 0
.text$mn:00009F67                 jz      short loc_9F89
.text$mn:00009F69                 mov     ecx, [ebp+var_4]
.text$mn:00009F6C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00009F71                 cmp     [ebp+arg_0], eax
.text$mn:00009F74                 jb      short loc_9F89
.text$mn:00009F76                 mov     ecx, [ebp+var_4]
.text$mn:00009F79                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00009F7E                 mov     ecx, [ebp+var_4]
.text$mn:00009F81                 add     eax, [ecx+14h]
.text$mn:00009F84                 cmp     eax, [ebp+arg_0]
.text$mn:00009F87                 ja      short loc_9F8F
.text$mn:00009F89
.text$mn:00009F89 loc_9F89:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00009F89                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00009F89                 xor     al, al
.text$mn:00009F8B                 jmp     short loc_9F91
.text$mn:00009F8D ; ---------------------------------------------------------------------------
.text$mn:00009F8D                 jmp     short loc_9F91
.text$mn:00009F8F ; ---------------------------------------------------------------------------
.text$mn:00009F8F
.text$mn:00009F8F loc_9F8F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00009F8F                 mov     al, 1
.text$mn:00009F91
.text$mn:00009F91 loc_9F91:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00009F91                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00009F91                 mov     esp, ebp
.text$mn:00009F93                 pop     ebp
.text$mn:00009F94                 retn    4
.text$mn:00009F94 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00009F94
.text$mn:00009F94 ; ---------------------------------------------------------------------------
.text$mn:00009F97                 align 4
.text$mn:00009F97 _text$mn        ends
.text$mn:00009F97
.text$mn:00009F98 ; ===========================================================================
.text$mn:00009F98
.text$mn:00009F98 ; Segment type: Pure code
.text$mn:00009F98 ; Segment permissions: Read/Execute
.text$mn:00009F98 _text$mn        segment para public 'CODE' use32
.text$mn:00009F98                 assume cs:_text$mn
.text$mn:00009F98                 ;org 9F98h
.text$mn:00009F98 ; COMDAT (pick any)
.text$mn:00009F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009F98
.text$mn:00009F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F98
.text$mn:00009F98 ; Attributes: bp-based frame
.text$mn:00009F98
.text$mn:00009F98 ; protected: bool __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Inside(struct MenuItemUnit const *)const
.text$mn:00009F98                 public ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z
.text$mn:00009F98 ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z proc near
.text$mn:00009F98                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+19p
.text$mn:00009F98
.text$mn:00009F98 var_8           = dword ptr -8
.text$mn:00009F98 var_4           = dword ptr -4
.text$mn:00009F98 arg_0           = dword ptr  8
.text$mn:00009F98
.text$mn:00009F98                 push    ebp
.text$mn:00009F99                 mov     ebp, esp
.text$mn:00009F9B                 sub     esp, 8
.text$mn:00009F9E                 mov     [ebp+var_4], ecx
.text$mn:00009FA1                 mov     eax, [ebp+var_4]
.text$mn:00009FA4                 mov     ecx, [ebp+arg_0]
.text$mn:00009FA7                 cmp     ecx, [eax+8]
.text$mn:00009FAA                 jnb     short loc_9FC0
.text$mn:00009FAC                 mov     edx, [ebp+var_4]
.text$mn:00009FAF                 mov     eax, [edx+4]
.text$mn:00009FB2                 cmp     eax, [ebp+arg_0]
.text$mn:00009FB5                 ja      short loc_9FC0
.text$mn:00009FB7                 mov     [ebp+var_8], 1
.text$mn:00009FBE                 jmp     short loc_9FC7
.text$mn:00009FC0 ; ---------------------------------------------------------------------------
.text$mn:00009FC0
.text$mn:00009FC0 loc_9FC0:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)+12j
.text$mn:00009FC0                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)+1Dj
.text$mn:00009FC0                 mov     [ebp+var_8], 0
.text$mn:00009FC7
.text$mn:00009FC7 loc_9FC7:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)+26j
.text$mn:00009FC7                 mov     al, byte ptr [ebp+var_8]
.text$mn:00009FCA                 mov     esp, ebp
.text$mn:00009FCC                 pop     ebp
.text$mn:00009FCD                 retn    4
.text$mn:00009FCD ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z endp
.text$mn:00009FCD
.text$mn:00009FCD _text$mn        ends
.text$mn:00009FCD
.text$mn:00009FD0 ; ===========================================================================
.text$mn:00009FD0
.text$mn:00009FD0 ; Segment type: Pure code
.text$mn:00009FD0 ; Segment permissions: Read/Execute
.text$mn:00009FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00009FD0                 assume cs:_text$mn
.text$mn:00009FD0                 ;org 9FD0h
.text$mn:00009FD0 ; COMDAT (pick any)
.text$mn:00009FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009FD0
.text$mn:00009FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009FD0
.text$mn:00009FD0 ; Attributes: bp-based frame
.text$mn:00009FD0
.text$mn:00009FD0 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>> __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>)const
.text$mn:00009FD0                 public ?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.text$mn:00009FD0 ?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z proc near
.text$mn:00009FD0                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+F7p
.text$mn:00009FD0
.text$mn:00009FD0 var_14          = dword ptr -14h
.text$mn:00009FD0 var_10          = dword ptr -10h
.text$mn:00009FD0 var_C           = dword ptr -0Ch
.text$mn:00009FD0 var_4           = dword ptr -4
.text$mn:00009FD0 arg_0           = dword ptr  8
.text$mn:00009FD0 arg_4           = byte ptr  0Ch
.text$mn:00009FD0 arg_C           = dword ptr  14h
.text$mn:00009FD0
.text$mn:00009FD0                 push    ebp
.text$mn:00009FD1                 mov     ebp, esp
.text$mn:00009FD3                 push    0FFFFFFFFh
.text$mn:00009FD5                 push    offset __ehhandler$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.text$mn:00009FDA                 mov     eax, large fs:0
.text$mn:00009FE0                 push    eax
.text$mn:00009FE1                 sub     esp, 8
.text$mn:00009FE4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009FE9                 xor     eax, ebp
.text$mn:00009FEB                 push    eax
.text$mn:00009FEC                 lea     eax, [ebp+var_C]
.text$mn:00009FEF                 mov     large fs:0, eax
.text$mn:00009FF5                 mov     [ebp+var_14], ecx
.text$mn:00009FF8                 mov     [ebp+var_10], 0
.text$mn:00009FFF                 mov     [ebp+var_4], 1
.text$mn:0000A006                 mov     eax, [ebp+var_14]
.text$mn:0000A009                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000A00A                 mov     ecx, [ebp+arg_C]
.text$mn:0000A00D                 push    ecx             ; int
.text$mn:0000A00E                 mov     ecx, [ebp+arg_0]
.text$mn:0000A011                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(MacroShortcut *,std::_Container_base12 const *)
.text$mn:0000A016                 mov     edx, [ebp+var_10]
.text$mn:0000A019                 or      edx, 1
.text$mn:0000A01C                 mov     [ebp+var_10], edx
.text$mn:0000A01F                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000A023                 lea     ecx, [ebp+arg_4]
.text$mn:0000A026                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$mn:0000A02B                 mov     eax, [ebp+arg_0]
.text$mn:0000A02E                 mov     ecx, [ebp+var_C]
.text$mn:0000A031                 mov     large fs:0, ecx
.text$mn:0000A038                 pop     ecx
.text$mn:0000A039                 mov     esp, ebp
.text$mn:0000A03B                 pop     ebp
.text$mn:0000A03C                 retn    10h
.text$mn:0000A03C ?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z endp
.text$mn:0000A03C
.text$mn:0000A03C ; ---------------------------------------------------------------------------
.text$mn:0000A03F                 align 10h
.text$mn:0000A03F _text$mn        ends
.text$mn:0000A03F
.text$x:0000A040 ; ===========================================================================
.text$x:0000A040
.text$x:0000A040 ; Segment type: Pure code
.text$x:0000A040 ; Segment permissions: Read/Execute
.text$x:0000A040 _text$x         segment para public 'CODE' use32
.text$x:0000A040                 assume cs:_text$x
.text$x:0000A040                 ;org 0A040h
.text$x:0000A040 ; COMDAT (pick associative to section at 9FD0)
.text$x:0000A040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A040
.text$x:0000A040 ; =============== S U B R O U T I N E =======================================
.text$x:0000A040
.text$x:0000A040
.text$x:0000A040 __unwindfunclet$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$0 proc near
.text$x:0000A040                                         ; DATA XREF: .xdata$x:0000DBE0o
.text$x:0000A040                 lea     ecx, [ebp+0Ch]
.text$x:0000A043                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:0000A043 __unwindfunclet$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$0 endp
.text$x:0000A043
.text$x:0000A048
.text$x:0000A048 ; =============== S U B R O U T I N E =======================================
.text$x:0000A048
.text$x:0000A048
.text$x:0000A048 __unwindfunclet$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$1 proc near
.text$x:0000A048                                         ; DATA XREF: .xdata$x:0000DBD8o
.text$x:0000A048                 mov     eax, [ebp-10h]
.text$x:0000A04B                 and     eax, 1
.text$x:0000A04E                 jz      $LN5
.text$x:0000A054                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000A058                 mov     ecx, [ebp+8]
.text$x:0000A05B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:0000A060 ; ---------------------------------------------------------------------------
.text$x:0000A060
.text$x:0000A060 $LN5:                                   ; CODE XREF: __unwindfunclet$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$1+6j
.text$x:0000A060                 retn
.text$x:0000A060 __unwindfunclet$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$1 endp
.text$x:0000A060
.text$x:0000A061
.text$x:0000A061 ; =============== S U B R O U T I N E =======================================
.text$x:0000A061
.text$x:0000A061
.text$x:0000A061 __ehhandler$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z proc near
.text$x:0000A061                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+5o
.text$x:0000A061
.text$x:0000A061 arg_4           = dword ptr  8
.text$x:0000A061
.text$x:0000A061                 mov     edx, [esp+arg_4]
.text$x:0000A065                 lea     eax, [edx+0Ch]
.text$x:0000A068                 mov     ecx, [edx-0Ch]
.text$x:0000A06B                 xor     ecx, eax
.text$x:0000A06D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A072                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.text$x:0000A077                 jmp     ___CxxFrameHandler3
.text$x:0000A077 __ehhandler$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z endp
.text$x:0000A077
.text$x:0000A077 _text$x         ends
.text$x:0000A077
.text$mn:0000A07C ; ===========================================================================
.text$mn:0000A07C
.text$mn:0000A07C ; Segment type: Pure code
.text$mn:0000A07C ; Segment permissions: Read/Execute
.text$mn:0000A07C _text$mn        segment para public 'CODE' use32
.text$mn:0000A07C                 assume cs:_text$mn
.text$mn:0000A07C                 ;org 0A07Ch
.text$mn:0000A07C ; COMDAT (pick any)
.text$mn:0000A07C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A07C
.text$mn:0000A07C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A07C
.text$mn:0000A07C ; Attributes: bp-based frame
.text$mn:0000A07C
.text$mn:0000A07C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>> __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>)const
.text$mn:0000A07C                 public ?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.text$mn:0000A07C ?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z proc near
.text$mn:0000A07C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+F7p
.text$mn:0000A07C
.text$mn:0000A07C var_14          = dword ptr -14h
.text$mn:0000A07C var_10          = dword ptr -10h
.text$mn:0000A07C var_C           = dword ptr -0Ch
.text$mn:0000A07C var_4           = dword ptr -4
.text$mn:0000A07C arg_0           = dword ptr  8
.text$mn:0000A07C arg_4           = byte ptr  0Ch
.text$mn:0000A07C arg_C           = dword ptr  14h
.text$mn:0000A07C
.text$mn:0000A07C                 push    ebp
.text$mn:0000A07D                 mov     ebp, esp
.text$mn:0000A07F                 push    0FFFFFFFFh
.text$mn:0000A081                 push    offset __ehhandler$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.text$mn:0000A086                 mov     eax, large fs:0
.text$mn:0000A08C                 push    eax
.text$mn:0000A08D                 sub     esp, 8
.text$mn:0000A090                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A095                 xor     eax, ebp
.text$mn:0000A097                 push    eax
.text$mn:0000A098                 lea     eax, [ebp+var_C]
.text$mn:0000A09B                 mov     large fs:0, eax
.text$mn:0000A0A1                 mov     [ebp+var_14], ecx
.text$mn:0000A0A4                 mov     [ebp+var_10], 0
.text$mn:0000A0AB                 mov     [ebp+var_4], 1
.text$mn:0000A0B2                 mov     eax, [ebp+var_14]
.text$mn:0000A0B5                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000A0B6                 mov     ecx, [ebp+arg_C]
.text$mn:0000A0B9                 push    ecx             ; int
.text$mn:0000A0BA                 mov     ecx, [ebp+arg_0]
.text$mn:0000A0BD                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(UserCommand *,std::_Container_base12 const *)
.text$mn:0000A0C2                 mov     edx, [ebp+var_10]
.text$mn:0000A0C5                 or      edx, 1
.text$mn:0000A0C8                 mov     [ebp+var_10], edx
.text$mn:0000A0CB                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000A0CF                 lea     ecx, [ebp+arg_4]
.text$mn:0000A0D2                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$mn:0000A0D7                 mov     eax, [ebp+arg_0]
.text$mn:0000A0DA                 mov     ecx, [ebp+var_C]
.text$mn:0000A0DD                 mov     large fs:0, ecx
.text$mn:0000A0E4                 pop     ecx
.text$mn:0000A0E5                 mov     esp, ebp
.text$mn:0000A0E7                 pop     ebp
.text$mn:0000A0E8                 retn    10h
.text$mn:0000A0E8 ?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z endp
.text$mn:0000A0E8
.text$mn:0000A0E8 ; ---------------------------------------------------------------------------
.text$mn:0000A0EB                 align 4
.text$mn:0000A0EB _text$mn        ends
.text$mn:0000A0EB
.text$x:0000A0EC ; ===========================================================================
.text$x:0000A0EC
.text$x:0000A0EC ; Segment type: Pure code
.text$x:0000A0EC ; Segment permissions: Read/Execute
.text$x:0000A0EC _text$x         segment para public 'CODE' use32
.text$x:0000A0EC                 assume cs:_text$x
.text$x:0000A0EC                 ;org 0A0ECh
.text$x:0000A0EC ; COMDAT (pick associative to section at A07C)
.text$x:0000A0EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A0EC
.text$x:0000A0EC ; =============== S U B R O U T I N E =======================================
.text$x:0000A0EC
.text$x:0000A0EC
.text$x:0000A0EC __unwindfunclet$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$0 proc near
.text$x:0000A0EC                                         ; DATA XREF: .xdata$x:0000DCA8o
.text$x:0000A0EC                 lea     ecx, [ebp+0Ch]
.text$x:0000A0EF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:0000A0EF __unwindfunclet$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$0 endp
.text$x:0000A0EF
.text$x:0000A0F4
.text$x:0000A0F4 ; =============== S U B R O U T I N E =======================================
.text$x:0000A0F4
.text$x:0000A0F4
.text$x:0000A0F4 __unwindfunclet$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$1 proc near
.text$x:0000A0F4                                         ; DATA XREF: .xdata$x:0000DCA0o
.text$x:0000A0F4                 mov     eax, [ebp-10h]
.text$x:0000A0F7                 and     eax, 1
.text$x:0000A0FA                 jz      $LN5_0
.text$x:0000A100                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000A104                 mov     ecx, [ebp+8]
.text$x:0000A107                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:0000A10C ; ---------------------------------------------------------------------------
.text$x:0000A10C
.text$x:0000A10C $LN5_0:                                 ; CODE XREF: __unwindfunclet$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$1+6j
.text$x:0000A10C                 retn
.text$x:0000A10C __unwindfunclet$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$1 endp
.text$x:0000A10C
.text$x:0000A10D
.text$x:0000A10D ; =============== S U B R O U T I N E =======================================
.text$x:0000A10D
.text$x:0000A10D
.text$x:0000A10D __ehhandler$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z proc near
.text$x:0000A10D                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+5o
.text$x:0000A10D
.text$x:0000A10D arg_4           = dword ptr  8
.text$x:0000A10D
.text$x:0000A10D                 mov     edx, [esp+arg_4]
.text$x:0000A111                 lea     eax, [edx+0Ch]
.text$x:0000A114                 mov     ecx, [edx-0Ch]
.text$x:0000A117                 xor     ecx, eax
.text$x:0000A119                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A11E                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.text$x:0000A123                 jmp     ___CxxFrameHandler3
.text$x:0000A123 __ehhandler$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z endp
.text$x:0000A123
.text$x:0000A123 _text$x         ends
.text$x:0000A123
.text$mn:0000A128 ; ===========================================================================
.text$mn:0000A128
.text$mn:0000A128 ; Segment type: Pure code
.text$mn:0000A128 ; Segment permissions: Read/Execute
.text$mn:0000A128 _text$mn        segment para public 'CODE' use32
.text$mn:0000A128                 assume cs:_text$mn
.text$mn:0000A128                 ;org 0A128h
.text$mn:0000A128 ; COMDAT (pick any)
.text$mn:0000A128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A128
.text$mn:0000A128 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A128
.text$mn:0000A128 ; Attributes: bp-based frame
.text$mn:0000A128
.text$mn:0000A128 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A128                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000A128 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000A128                                         ; CODE XREF: $LN19+14p
.text$mn:0000A128                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:0000A128
.text$mn:0000A128 var_8           = dword ptr -8
.text$mn:0000A128 var_4           = dword ptr -4
.text$mn:0000A128
.text$mn:0000A128                 push    ebp
.text$mn:0000A129                 mov     ebp, esp
.text$mn:0000A12B                 sub     esp, 8
.text$mn:0000A12E                 mov     [ebp+var_4], ecx
.text$mn:0000A131                 mov     eax, [ebp+var_4]
.text$mn:0000A134                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000A138                 jb      short loc_A14E
.text$mn:0000A13A                 mov     ecx, [ebp+var_4]
.text$mn:0000A13D                 mov     edx, [ecx+4]
.text$mn:0000A140                 push    edx
.text$mn:0000A141                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000A146                 add     esp, 4
.text$mn:0000A149                 mov     [ebp+var_8], eax
.text$mn:0000A14C                 jmp     short loc_A157
.text$mn:0000A14E ; ---------------------------------------------------------------------------
.text$mn:0000A14E
.text$mn:0000A14E loc_A14E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000A14E                 mov     eax, [ebp+var_4]
.text$mn:0000A151                 add     eax, 4
.text$mn:0000A154                 mov     [ebp+var_8], eax
.text$mn:0000A157
.text$mn:0000A157 loc_A157:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000A157                 mov     eax, [ebp+var_8]
.text$mn:0000A15A                 mov     esp, ebp
.text$mn:0000A15C                 pop     ebp
.text$mn:0000A15D                 retn
.text$mn:0000A15D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000A15D
.text$mn:0000A15D ; ---------------------------------------------------------------------------
.text$mn:0000A15E                 align 10h
.text$mn:0000A15E _text$mn        ends
.text$mn:0000A15E
.text$mn:0000A160 ; ===========================================================================
.text$mn:0000A160
.text$mn:0000A160 ; Segment type: Pure code
.text$mn:0000A160 ; Segment permissions: Read/Execute
.text$mn:0000A160 _text$mn        segment para public 'CODE' use32
.text$mn:0000A160                 assume cs:_text$mn
.text$mn:0000A160                 ;org 0A160h
.text$mn:0000A160 ; COMDAT (pick any)
.text$mn:0000A160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A160
.text$mn:0000A160 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A160
.text$mn:0000A160 ; Attributes: bp-based frame
.text$mn:0000A160
.text$mn:0000A160 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:0000A160                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:0000A160 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:0000A160                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:0000A160
.text$mn:0000A160 var_8           = dword ptr -8
.text$mn:0000A160 var_4           = dword ptr -4
.text$mn:0000A160
.text$mn:0000A160                 push    ebp
.text$mn:0000A161                 mov     ebp, esp
.text$mn:0000A163                 sub     esp, 8
.text$mn:0000A166                 mov     [ebp+var_4], ecx
.text$mn:0000A169                 mov     eax, [ebp+var_4]
.text$mn:0000A16C                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000A170                 jb      short loc_A186
.text$mn:0000A172                 mov     ecx, [ebp+var_4]
.text$mn:0000A175                 mov     edx, [ecx+4]
.text$mn:0000A178                 push    edx
.text$mn:0000A179                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000A17E                 add     esp, 4
.text$mn:0000A181                 mov     [ebp+var_8], eax
.text$mn:0000A184                 jmp     short loc_A18F
.text$mn:0000A186 ; ---------------------------------------------------------------------------
.text$mn:0000A186
.text$mn:0000A186 loc_A186:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000A186                 mov     eax, [ebp+var_4]
.text$mn:0000A189                 add     eax, 4
.text$mn:0000A18C                 mov     [ebp+var_8], eax
.text$mn:0000A18F
.text$mn:0000A18F loc_A18F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000A18F                 mov     eax, [ebp+var_8]
.text$mn:0000A192                 mov     esp, ebp
.text$mn:0000A194                 pop     ebp
.text$mn:0000A195                 retn
.text$mn:0000A195 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000A195
.text$mn:0000A195 ; ---------------------------------------------------------------------------
.text$mn:0000A196                 align 4
.text$mn:0000A196 _text$mn        ends
.text$mn:0000A196
.text$mn:0000A198 ; ===========================================================================
.text$mn:0000A198
.text$mn:0000A198 ; Segment type: Pure code
.text$mn:0000A198 ; Segment permissions: Read/Execute
.text$mn:0000A198 _text$mn        segment para public 'CODE' use32
.text$mn:0000A198                 assume cs:_text$mn
.text$mn:0000A198                 ;org 0A198h
.text$mn:0000A198 ; COMDAT (pick any)
.text$mn:0000A198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A198
.text$mn:0000A198 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A198
.text$mn:0000A198 ; Attributes: bp-based frame
.text$mn:0000A198
.text$mn:0000A198 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A198                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:0000A198 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:0000A198                                         ; CODE XREF: $LN19_0+14p
.text$mn:0000A198                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:0000A198
.text$mn:0000A198 var_8           = dword ptr -8
.text$mn:0000A198 var_4           = dword ptr -4
.text$mn:0000A198
.text$mn:0000A198                 push    ebp
.text$mn:0000A199                 mov     ebp, esp
.text$mn:0000A19B                 sub     esp, 8
.text$mn:0000A19E                 mov     [ebp+var_4], ecx
.text$mn:0000A1A1                 mov     eax, [ebp+var_4]
.text$mn:0000A1A4                 cmp     dword ptr [eax+18h], 8
.text$mn:0000A1A8                 jb      short loc_A1BE
.text$mn:0000A1AA                 mov     ecx, [ebp+var_4]
.text$mn:0000A1AD                 mov     edx, [ecx+4]
.text$mn:0000A1B0                 push    edx
.text$mn:0000A1B1                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000A1B6                 add     esp, 4
.text$mn:0000A1B9                 mov     [ebp+var_8], eax
.text$mn:0000A1BC                 jmp     short loc_A1C7
.text$mn:0000A1BE ; ---------------------------------------------------------------------------
.text$mn:0000A1BE
.text$mn:0000A1BE loc_A1BE:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000A1BE                 mov     eax, [ebp+var_4]
.text$mn:0000A1C1                 add     eax, 4
.text$mn:0000A1C4                 mov     [ebp+var_8], eax
.text$mn:0000A1C7
.text$mn:0000A1C7 loc_A1C7:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000A1C7                 mov     eax, [ebp+var_8]
.text$mn:0000A1CA                 mov     esp, ebp
.text$mn:0000A1CC                 pop     ebp
.text$mn:0000A1CD                 retn
.text$mn:0000A1CD ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:0000A1CD
.text$mn:0000A1CD ; ---------------------------------------------------------------------------
.text$mn:0000A1CE                 align 10h
.text$mn:0000A1CE _text$mn        ends
.text$mn:0000A1CE
.text$mn:0000A1D0 ; ===========================================================================
.text$mn:0000A1D0
.text$mn:0000A1D0 ; Segment type: Pure code
.text$mn:0000A1D0 ; Segment permissions: Read/Execute
.text$mn:0000A1D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A1D0                 assume cs:_text$mn
.text$mn:0000A1D0                 ;org 0A1D0h
.text$mn:0000A1D0 ; COMDAT (pick any)
.text$mn:0000A1D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A1D0
.text$mn:0000A1D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A1D0
.text$mn:0000A1D0 ; Attributes: bp-based frame
.text$mn:0000A1D0
.text$mn:0000A1D0 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:0000A1D0                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:0000A1D0 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:0000A1D0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+2Cp
.text$mn:0000A1D0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:0000A1D0
.text$mn:0000A1D0 var_8           = dword ptr -8
.text$mn:0000A1D0 var_4           = dword ptr -4
.text$mn:0000A1D0
.text$mn:0000A1D0                 push    ebp
.text$mn:0000A1D1                 mov     ebp, esp
.text$mn:0000A1D3                 sub     esp, 8
.text$mn:0000A1D6                 mov     [ebp+var_4], ecx
.text$mn:0000A1D9                 mov     eax, [ebp+var_4]
.text$mn:0000A1DC                 cmp     dword ptr [eax+18h], 8
.text$mn:0000A1E0                 jb      short loc_A1F6
.text$mn:0000A1E2                 mov     ecx, [ebp+var_4]
.text$mn:0000A1E5                 mov     edx, [ecx+4]
.text$mn:0000A1E8                 push    edx
.text$mn:0000A1E9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000A1EE                 add     esp, 4
.text$mn:0000A1F1                 mov     [ebp+var_8], eax
.text$mn:0000A1F4                 jmp     short loc_A1FF
.text$mn:0000A1F6 ; ---------------------------------------------------------------------------
.text$mn:0000A1F6
.text$mn:0000A1F6 loc_A1F6:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000A1F6                 mov     eax, [ebp+var_4]
.text$mn:0000A1F9                 add     eax, 4
.text$mn:0000A1FC                 mov     [ebp+var_8], eax
.text$mn:0000A1FF
.text$mn:0000A1FF loc_A1FF:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000A1FF                 mov     eax, [ebp+var_8]
.text$mn:0000A202                 mov     esp, ebp
.text$mn:0000A204                 pop     ebp
.text$mn:0000A205                 retn
.text$mn:0000A205 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:0000A205
.text$mn:0000A205 ; ---------------------------------------------------------------------------
.text$mn:0000A206                 align 4
.text$mn:0000A206 _text$mn        ends
.text$mn:0000A206
.text$mn:0000A208 ; ===========================================================================
.text$mn:0000A208
.text$mn:0000A208 ; Segment type: Pure code
.text$mn:0000A208 ; Segment permissions: Read/Execute
.text$mn:0000A208 _text$mn        segment para public 'CODE' use32
.text$mn:0000A208                 assume cs:_text$mn
.text$mn:0000A208                 ;org 0A208h
.text$mn:0000A208 ; COMDAT (pick any)
.text$mn:0000A208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A208
.text$mn:0000A208 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A208
.text$mn:0000A208 ; Attributes: bp-based frame
.text$mn:0000A208
.text$mn:0000A208 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000A208                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000A208 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000A208                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000A208                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+88p ...
.text$mn:0000A208
.text$mn:0000A208 var_18          = byte ptr -18h
.text$mn:0000A208 var_14          = dword ptr -14h
.text$mn:0000A208 var_10          = dword ptr -10h
.text$mn:0000A208 var_C           = dword ptr -0Ch
.text$mn:0000A208 var_4           = dword ptr -4
.text$mn:0000A208
.text$mn:0000A208                 push    ebp
.text$mn:0000A209                 mov     ebp, esp
.text$mn:0000A20B                 push    0FFFFFFFFh
.text$mn:0000A20D                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000A212                 mov     eax, large fs:0
.text$mn:0000A218                 push    eax
.text$mn:0000A219                 sub     esp, 0Ch
.text$mn:0000A21C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A221                 xor     eax, ebp
.text$mn:0000A223                 push    eax
.text$mn:0000A224                 lea     eax, [ebp+var_C]
.text$mn:0000A227                 mov     large fs:0, eax
.text$mn:0000A22D                 mov     [ebp+var_14], ecx
.text$mn:0000A230                 mov     eax, [ebp+var_14]
.text$mn:0000A233                 cmp     dword ptr [eax], 0
.text$mn:0000A236                 jz      short loc_A293
.text$mn:0000A238                 push    3               ; int
.text$mn:0000A23A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A23D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000A242                 mov     [ebp+var_4], 0
.text$mn:0000A249                 mov     ecx, [ebp+var_14]
.text$mn:0000A24C                 mov     edx, [ecx]
.text$mn:0000A24E                 add     edx, 4
.text$mn:0000A251                 mov     [ebp+var_10], edx
.text$mn:0000A254                 jmp     short loc_A263
.text$mn:0000A256 ; ---------------------------------------------------------------------------
.text$mn:0000A256
.text$mn:0000A256 loc_A256:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000A256                 mov     eax, [ebp+var_10]
.text$mn:0000A259                 mov     ecx, [eax]
.text$mn:0000A25B                 mov     edx, [ebp+var_10]
.text$mn:0000A25E                 mov     eax, [ecx+4]
.text$mn:0000A261                 mov     [edx], eax
.text$mn:0000A263
.text$mn:0000A263 loc_A263:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000A263                 mov     ecx, [ebp+var_10]
.text$mn:0000A266                 cmp     dword ptr [ecx], 0
.text$mn:0000A269                 jz      short loc_A278
.text$mn:0000A26B                 mov     edx, [ebp+var_10]
.text$mn:0000A26E                 mov     eax, [edx]
.text$mn:0000A270                 mov     dword ptr [eax], 0
.text$mn:0000A276                 jmp     short loc_A256
.text$mn:0000A278 ; ---------------------------------------------------------------------------
.text$mn:0000A278
.text$mn:0000A278 loc_A278:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000A278                 mov     ecx, [ebp+var_14]
.text$mn:0000A27B                 mov     edx, [ecx]
.text$mn:0000A27D                 mov     dword ptr [edx+4], 0
.text$mn:0000A284                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A28B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A28E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000A293
.text$mn:0000A293 loc_A293:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:0000A293                 mov     ecx, [ebp+var_C]
.text$mn:0000A296                 mov     large fs:0, ecx
.text$mn:0000A29D                 pop     ecx
.text$mn:0000A29E                 mov     esp, ebp
.text$mn:0000A2A0                 pop     ebp
.text$mn:0000A2A1                 retn
.text$mn:0000A2A1 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:0000A2A1
.text$mn:0000A2A1 ; ---------------------------------------------------------------------------
.text$mn:0000A2A2                 align 4
.text$mn:0000A2A2 _text$mn        ends
.text$mn:0000A2A2
.text$x:0000A2A4 ; ===========================================================================
.text$x:0000A2A4
.text$x:0000A2A4 ; Segment type: Pure code
.text$x:0000A2A4 ; Segment permissions: Read/Execute
.text$x:0000A2A4 _text$x         segment para public 'CODE' use32
.text$x:0000A2A4                 assume cs:_text$x
.text$x:0000A2A4                 ;org 0A2A4h
.text$x:0000A2A4 ; COMDAT (pick associative to section at A208)
.text$x:0000A2A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A2A4
.text$x:0000A2A4 ; =============== S U B R O U T I N E =======================================
.text$x:0000A2A4
.text$x:0000A2A4
.text$x:0000A2A4 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:0000A2A4                                         ; DATA XREF: .xdata$x:0000CCC4o
.text$x:0000A2A4                 lea     ecx, [ebp-18h]  ; this
.text$x:0000A2A7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000A2A7 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000A2A7
.text$x:0000A2AC
.text$x:0000A2AC ; =============== S U B R O U T I N E =======================================
.text$x:0000A2AC
.text$x:0000A2AC
.text$x:0000A2AC __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:0000A2AC                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:0000A2AC
.text$x:0000A2AC arg_4           = dword ptr  8
.text$x:0000A2AC
.text$x:0000A2AC                 mov     edx, [esp+arg_4]
.text$x:0000A2B0                 lea     eax, [edx+0Ch]
.text$x:0000A2B3                 mov     ecx, [edx-10h]
.text$x:0000A2B6                 xor     ecx, eax
.text$x:0000A2B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A2BD                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000A2C2                 jmp     ___CxxFrameHandler3
.text$x:0000A2C2 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000A2C2
.text$x:0000A2C2 ; ---------------------------------------------------------------------------
.text$x:0000A2C7                 align 4
.text$x:0000A2C7 _text$x         ends
.text$x:0000A2C7
.text$mn:0000A2C8 ; ===========================================================================
.text$mn:0000A2C8
.text$mn:0000A2C8 ; Segment type: Pure code
.text$mn:0000A2C8 ; Segment permissions: Read/Execute
.text$mn:0000A2C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A2C8                 assume cs:_text$mn
.text$mn:0000A2C8                 ;org 0A2C8h
.text$mn:0000A2C8 ; COMDAT (pick any)
.text$mn:0000A2C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A2C8
.text$mn:0000A2C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A2C8
.text$mn:0000A2C8 ; Attributes: bp-based frame
.text$mn:0000A2C8
.text$mn:0000A2C8 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:0000A2C8                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:0000A2C8 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000A2C8                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:0000A2C8                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:0000A2C8
.text$mn:0000A2C8 var_8           = dword ptr -8
.text$mn:0000A2C8 var_4           = dword ptr -4
.text$mn:0000A2C8
.text$mn:0000A2C8                 push    ebp
.text$mn:0000A2C9                 mov     ebp, esp
.text$mn:0000A2CB                 sub     esp, 8
.text$mn:0000A2CE                 mov     [ebp+var_8], ecx
.text$mn:0000A2D1                 mov     eax, [ebp+var_8]
.text$mn:0000A2D4                 cmp     dword ptr [eax], 0
.text$mn:0000A2D7                 jz      short loc_A336
.text$mn:0000A2D9                 mov     ecx, [ebp+var_8]
.text$mn:0000A2DC                 mov     edx, [ecx]
.text$mn:0000A2DE                 add     edx, 4
.text$mn:0000A2E1                 mov     [ebp+var_4], edx
.text$mn:0000A2E4
.text$mn:0000A2E4 loc_A2E4:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:0000A2E4                 mov     eax, [ebp+var_4]
.text$mn:0000A2E7                 cmp     dword ptr [eax], 0
.text$mn:0000A2EA                 jz      short loc_A303
.text$mn:0000A2EC                 mov     ecx, [ebp+var_4]
.text$mn:0000A2EF                 mov     edx, [ecx]
.text$mn:0000A2F1                 cmp     edx, [ebp+var_8]
.text$mn:0000A2F4                 jz      short loc_A303
.text$mn:0000A2F6                 mov     eax, [ebp+var_4]
.text$mn:0000A2F9                 mov     ecx, [eax]
.text$mn:0000A2FB                 add     ecx, 4
.text$mn:0000A2FE                 mov     [ebp+var_4], ecx
.text$mn:0000A301                 jmp     short loc_A2E4
.text$mn:0000A303 ; ---------------------------------------------------------------------------
.text$mn:0000A303
.text$mn:0000A303 loc_A303:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:0000A303                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:0000A303                 mov     edx, [ebp+var_4]
.text$mn:0000A306                 cmp     dword ptr [edx], 0
.text$mn:0000A309                 jnz     short loc_A322
.text$mn:0000A30B                 push    0C9h ; '+'      ; unsigned int
.text$mn:0000A310                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A315                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:0000A31A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A31F                 add     esp, 0Ch
.text$mn:0000A322
.text$mn:0000A322 loc_A322:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:0000A322                 mov     eax, [ebp+var_4]
.text$mn:0000A325                 mov     ecx, [ebp+var_8]
.text$mn:0000A328                 mov     edx, [ecx+4]
.text$mn:0000A32B                 mov     [eax], edx
.text$mn:0000A32D                 mov     eax, [ebp+var_8]
.text$mn:0000A330                 mov     dword ptr [eax], 0
.text$mn:0000A336
.text$mn:0000A336 loc_A336:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:0000A336                 mov     esp, ebp
.text$mn:0000A338                 pop     ebp
.text$mn:0000A339                 retn
.text$mn:0000A339 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000A339
.text$mn:0000A339 ; ---------------------------------------------------------------------------
.text$mn:0000A33A                 align 4
.text$mn:0000A33A _text$mn        ends
.text$mn:0000A33A
.text$mn:0000A33C ; ===========================================================================
.text$mn:0000A33C
.text$mn:0000A33C ; Segment type: Pure code
.text$mn:0000A33C ; Segment permissions: Read/Execute
.text$mn:0000A33C _text$mn        segment para public 'CODE' use32
.text$mn:0000A33C                 assume cs:_text$mn
.text$mn:0000A33C                 ;org 0A33Ch
.text$mn:0000A33C ; COMDAT (pick any)
.text$mn:0000A33C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A33C
.text$mn:0000A33C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A33C
.text$mn:0000A33C ; Attributes: bp-based frame
.text$mn:0000A33C
.text$mn:0000A33C ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Orphan_range(struct MenuItemUnit *, struct MenuItemUnit *)const
.text$mn:0000A33C                 public ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.text$mn:0000A33C ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z proc near
.text$mn:0000A33C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+6Fp
.text$mn:0000A33C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+DCp
.text$mn:0000A33C
.text$mn:0000A33C var_18          = byte ptr -18h
.text$mn:0000A33C var_14          = dword ptr -14h
.text$mn:0000A33C var_10          = dword ptr -10h
.text$mn:0000A33C var_C           = dword ptr -0Ch
.text$mn:0000A33C var_4           = dword ptr -4
.text$mn:0000A33C arg_0           = dword ptr  8
.text$mn:0000A33C arg_4           = dword ptr  0Ch
.text$mn:0000A33C
.text$mn:0000A33C                 push    ebp
.text$mn:0000A33D                 mov     ebp, esp
.text$mn:0000A33F                 push    0FFFFFFFFh
.text$mn:0000A341                 push    offset __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.text$mn:0000A346                 mov     eax, large fs:0
.text$mn:0000A34C                 push    eax
.text$mn:0000A34D                 sub     esp, 0Ch
.text$mn:0000A350                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A355                 xor     eax, ebp
.text$mn:0000A357                 push    eax
.text$mn:0000A358                 lea     eax, [ebp+var_C]
.text$mn:0000A35B                 mov     large fs:0, eax
.text$mn:0000A361                 mov     [ebp+var_14], ecx
.text$mn:0000A364                 push    3               ; int
.text$mn:0000A366                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A369                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000A36E                 mov     [ebp+var_4], 0
.text$mn:0000A375                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000A378                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000A37D                 mov     [ebp+var_10], eax
.text$mn:0000A380                 cmp     [ebp+var_10], 0
.text$mn:0000A384                 jz      short loc_A3D4
.text$mn:0000A386
.text$mn:0000A386 loc_A386:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *):loc_A3D2j
.text$mn:0000A386                 mov     eax, [ebp+var_10]
.text$mn:0000A389                 cmp     dword ptr [eax], 0
.text$mn:0000A38C                 jz      short loc_A3D4
.text$mn:0000A38E                 mov     ecx, [ebp+var_10]
.text$mn:0000A391                 mov     edx, [ecx]
.text$mn:0000A393                 mov     eax, [edx+8]
.text$mn:0000A396                 cmp     eax, [ebp+arg_0]
.text$mn:0000A399                 jb      short loc_A3A8
.text$mn:0000A39B                 mov     ecx, [ebp+var_10]
.text$mn:0000A39E                 mov     edx, [ecx]
.text$mn:0000A3A0                 mov     eax, [ebp+arg_4]
.text$mn:0000A3A3                 cmp     eax, [edx+8]
.text$mn:0000A3A6                 jnb     short loc_A3B7
.text$mn:0000A3A8
.text$mn:0000A3A8 loc_A3A8:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+5Dj
.text$mn:0000A3A8                 mov     ecx, [ebp+var_10]
.text$mn:0000A3AB                 mov     ecx, [ecx]      ; this
.text$mn:0000A3AD                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A3B2                 mov     [ebp+var_10], eax
.text$mn:0000A3B5                 jmp     short loc_A3D2
.text$mn:0000A3B7 ; ---------------------------------------------------------------------------
.text$mn:0000A3B7
.text$mn:0000A3B7 loc_A3B7:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+6Aj
.text$mn:0000A3B7                 mov     edx, [ebp+var_10]
.text$mn:0000A3BA                 mov     ecx, [edx]      ; this
.text$mn:0000A3BC                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000A3C1                 mov     eax, [ebp+var_10]
.text$mn:0000A3C4                 mov     ecx, [eax]      ; this
.text$mn:0000A3C6                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A3CB                 mov     ecx, [ebp+var_10]
.text$mn:0000A3CE                 mov     edx, [eax]
.text$mn:0000A3D0                 mov     [ecx], edx
.text$mn:0000A3D2
.text$mn:0000A3D2 loc_A3D2:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+79j
.text$mn:0000A3D2                 jmp     short loc_A386
.text$mn:0000A3D4 ; ---------------------------------------------------------------------------
.text$mn:0000A3D4
.text$mn:0000A3D4 loc_A3D4:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+48j
.text$mn:0000A3D4                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+50j
.text$mn:0000A3D4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A3DB                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A3DE                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000A3E3                 mov     ecx, [ebp+var_C]
.text$mn:0000A3E6                 mov     large fs:0, ecx
.text$mn:0000A3ED                 pop     ecx
.text$mn:0000A3EE                 mov     esp, ebp
.text$mn:0000A3F0                 pop     ebp
.text$mn:0000A3F1                 retn    8
.text$mn:0000A3F1 ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z endp
.text$mn:0000A3F1
.text$mn:0000A3F1 _text$mn        ends
.text$mn:0000A3F1
.text$x:0000A3F4 ; ===========================================================================
.text$x:0000A3F4
.text$x:0000A3F4 ; Segment type: Pure code
.text$x:0000A3F4 ; Segment permissions: Read/Execute
.text$x:0000A3F4 _text$x         segment para public 'CODE' use32
.text$x:0000A3F4                 assume cs:_text$x
.text$x:0000A3F4                 ;org 0A3F4h
.text$x:0000A3F4 ; COMDAT (pick associative to section at A33C)
.text$x:0000A3F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A3F4
.text$x:0000A3F4 ; =============== S U B R O U T I N E =======================================
.text$x:0000A3F4
.text$x:0000A3F4
.text$x:0000A3F4 __unwindfunclet$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z$0 proc near
.text$x:0000A3F4                                         ; DATA XREF: .xdata$x:0000DE9Co
.text$x:0000A3F4                 lea     ecx, [ebp-18h]  ; this
.text$x:0000A3F7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000A3F7 __unwindfunclet$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z$0 endp
.text$x:0000A3F7
.text$x:0000A3FC
.text$x:0000A3FC ; =============== S U B R O U T I N E =======================================
.text$x:0000A3FC
.text$x:0000A3FC
.text$x:0000A3FC __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z proc near
.text$x:0000A3FC                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+5o
.text$x:0000A3FC
.text$x:0000A3FC arg_4           = dword ptr  8
.text$x:0000A3FC
.text$x:0000A3FC                 mov     edx, [esp+arg_4]
.text$x:0000A400                 lea     eax, [edx+0Ch]
.text$x:0000A403                 mov     ecx, [edx-10h]
.text$x:0000A406                 xor     ecx, eax
.text$x:0000A408                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A40D                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.text$x:0000A412                 jmp     ___CxxFrameHandler3
.text$x:0000A412 __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z endp
.text$x:0000A412
.text$x:0000A412 ; ---------------------------------------------------------------------------
.text$x:0000A417                 align 4
.text$x:0000A417 _text$x         ends
.text$x:0000A417
.text$mn:0000A418 ; ===========================================================================
.text$mn:0000A418
.text$mn:0000A418 ; Segment type: Pure code
.text$mn:0000A418 ; Segment permissions: Read/Execute
.text$mn:0000A418 _text$mn        segment para public 'CODE' use32
.text$mn:0000A418                 assume cs:_text$mn
.text$mn:0000A418                 ;org 0A418h
.text$mn:0000A418 ; COMDAT (pick any)
.text$mn:0000A418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A418
.text$mn:0000A418 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A418
.text$mn:0000A418 ; Attributes: bp-based frame
.text$mn:0000A418
.text$mn:0000A418 ; protected: void __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::_Orphan_range(class MacroShortcut *, class MacroShortcut *)const
.text$mn:0000A418                 public ?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z
.text$mn:0000A418 ?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z proc near
.text$mn:0000A418                                         ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+B7p
.text$mn:0000A418
.text$mn:0000A418 var_18          = byte ptr -18h
.text$mn:0000A418 var_14          = dword ptr -14h
.text$mn:0000A418 var_10          = dword ptr -10h
.text$mn:0000A418 var_C           = dword ptr -0Ch
.text$mn:0000A418 var_4           = dword ptr -4
.text$mn:0000A418 arg_0           = dword ptr  8
.text$mn:0000A418 arg_4           = dword ptr  0Ch
.text$mn:0000A418
.text$mn:0000A418                 push    ebp
.text$mn:0000A419                 mov     ebp, esp
.text$mn:0000A41B                 push    0FFFFFFFFh
.text$mn:0000A41D                 push    offset __ehhandler$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z
.text$mn:0000A422                 mov     eax, large fs:0
.text$mn:0000A428                 push    eax
.text$mn:0000A429                 sub     esp, 0Ch
.text$mn:0000A42C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A431                 xor     eax, ebp
.text$mn:0000A433                 push    eax
.text$mn:0000A434                 lea     eax, [ebp+var_C]
.text$mn:0000A437                 mov     large fs:0, eax
.text$mn:0000A43D                 mov     [ebp+var_14], ecx
.text$mn:0000A440                 push    3               ; int
.text$mn:0000A442                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A445                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000A44A                 mov     [ebp+var_4], 0
.text$mn:0000A451                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000A454                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000A459                 mov     [ebp+var_10], eax
.text$mn:0000A45C                 cmp     [ebp+var_10], 0
.text$mn:0000A460                 jz      short loc_A4B0
.text$mn:0000A462
.text$mn:0000A462 loc_A462:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *):loc_A4AEj
.text$mn:0000A462                 mov     eax, [ebp+var_10]
.text$mn:0000A465                 cmp     dword ptr [eax], 0
.text$mn:0000A468                 jz      short loc_A4B0
.text$mn:0000A46A                 mov     ecx, [ebp+var_10]
.text$mn:0000A46D                 mov     edx, [ecx]
.text$mn:0000A46F                 mov     eax, [edx+8]
.text$mn:0000A472                 cmp     eax, [ebp+arg_0]
.text$mn:0000A475                 jb      short loc_A484
.text$mn:0000A477                 mov     ecx, [ebp+var_10]
.text$mn:0000A47A                 mov     edx, [ecx]
.text$mn:0000A47C                 mov     eax, [ebp+arg_4]
.text$mn:0000A47F                 cmp     eax, [edx+8]
.text$mn:0000A482                 jnb     short loc_A493
.text$mn:0000A484
.text$mn:0000A484 loc_A484:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+5Dj
.text$mn:0000A484                 mov     ecx, [ebp+var_10]
.text$mn:0000A487                 mov     ecx, [ecx]      ; this
.text$mn:0000A489                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A48E                 mov     [ebp+var_10], eax
.text$mn:0000A491                 jmp     short loc_A4AE
.text$mn:0000A493 ; ---------------------------------------------------------------------------
.text$mn:0000A493
.text$mn:0000A493 loc_A493:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+6Aj
.text$mn:0000A493                 mov     edx, [ebp+var_10]
.text$mn:0000A496                 mov     ecx, [edx]      ; this
.text$mn:0000A498                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000A49D                 mov     eax, [ebp+var_10]
.text$mn:0000A4A0                 mov     ecx, [eax]      ; this
.text$mn:0000A4A2                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A4A7                 mov     ecx, [ebp+var_10]
.text$mn:0000A4AA                 mov     edx, [eax]
.text$mn:0000A4AC                 mov     [ecx], edx
.text$mn:0000A4AE
.text$mn:0000A4AE loc_A4AE:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+79j
.text$mn:0000A4AE                 jmp     short loc_A462
.text$mn:0000A4B0 ; ---------------------------------------------------------------------------
.text$mn:0000A4B0
.text$mn:0000A4B0 loc_A4B0:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+48j
.text$mn:0000A4B0                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+50j
.text$mn:0000A4B0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A4B7                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A4BA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000A4BF                 mov     ecx, [ebp+var_C]
.text$mn:0000A4C2                 mov     large fs:0, ecx
.text$mn:0000A4C9                 pop     ecx
.text$mn:0000A4CA                 mov     esp, ebp
.text$mn:0000A4CC                 pop     ebp
.text$mn:0000A4CD                 retn    8
.text$mn:0000A4CD ?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z endp
.text$mn:0000A4CD
.text$mn:0000A4CD _text$mn        ends
.text$mn:0000A4CD
.text$x:0000A4D0 ; ===========================================================================
.text$x:0000A4D0
.text$x:0000A4D0 ; Segment type: Pure code
.text$x:0000A4D0 ; Segment permissions: Read/Execute
.text$x:0000A4D0 _text$x         segment para public 'CODE' use32
.text$x:0000A4D0                 assume cs:_text$x
.text$x:0000A4D0                 ;org 0A4D0h
.text$x:0000A4D0 ; COMDAT (pick associative to section at A418)
.text$x:0000A4D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A4D0
.text$x:0000A4D0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A4D0
.text$x:0000A4D0
.text$x:0000A4D0 __unwindfunclet$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z$0 proc near
.text$x:0000A4D0                                         ; DATA XREF: .xdata$x:0000DC48o
.text$x:0000A4D0                 lea     ecx, [ebp-18h]  ; this
.text$x:0000A4D3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000A4D3 __unwindfunclet$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z$0 endp
.text$x:0000A4D3
.text$x:0000A4D8
.text$x:0000A4D8 ; =============== S U B R O U T I N E =======================================
.text$x:0000A4D8
.text$x:0000A4D8
.text$x:0000A4D8 __ehhandler$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z proc near
.text$x:0000A4D8                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)+5o
.text$x:0000A4D8
.text$x:0000A4D8 arg_4           = dword ptr  8
.text$x:0000A4D8
.text$x:0000A4D8                 mov     edx, [esp+arg_4]
.text$x:0000A4DC                 lea     eax, [edx+0Ch]
.text$x:0000A4DF                 mov     ecx, [edx-10h]
.text$x:0000A4E2                 xor     ecx, eax
.text$x:0000A4E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A4E9                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z
.text$x:0000A4EE                 jmp     ___CxxFrameHandler3
.text$x:0000A4EE __ehhandler$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z endp
.text$x:0000A4EE
.text$x:0000A4EE ; ---------------------------------------------------------------------------
.text$x:0000A4F3                 align 4
.text$x:0000A4F3 _text$x         ends
.text$x:0000A4F3
.text$mn:0000A4F4 ; ===========================================================================
.text$mn:0000A4F4
.text$mn:0000A4F4 ; Segment type: Pure code
.text$mn:0000A4F4 ; Segment permissions: Read/Execute
.text$mn:0000A4F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A4F4                 assume cs:_text$mn
.text$mn:0000A4F4                 ;org 0A4F4h
.text$mn:0000A4F4 ; COMDAT (pick any)
.text$mn:0000A4F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A4F4
.text$mn:0000A4F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A4F4
.text$mn:0000A4F4 ; Attributes: bp-based frame
.text$mn:0000A4F4
.text$mn:0000A4F4 ; protected: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Orphan_range(class UserCommand *, class UserCommand *)const
.text$mn:0000A4F4                 public ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.text$mn:0000A4F4 ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z proc near
.text$mn:0000A4F4                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+B7p
.text$mn:0000A4F4
.text$mn:0000A4F4 var_18          = byte ptr -18h
.text$mn:0000A4F4 var_14          = dword ptr -14h
.text$mn:0000A4F4 var_10          = dword ptr -10h
.text$mn:0000A4F4 var_C           = dword ptr -0Ch
.text$mn:0000A4F4 var_4           = dword ptr -4
.text$mn:0000A4F4 arg_0           = dword ptr  8
.text$mn:0000A4F4 arg_4           = dword ptr  0Ch
.text$mn:0000A4F4
.text$mn:0000A4F4                 push    ebp
.text$mn:0000A4F5                 mov     ebp, esp
.text$mn:0000A4F7                 push    0FFFFFFFFh
.text$mn:0000A4F9                 push    offset __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.text$mn:0000A4FE                 mov     eax, large fs:0
.text$mn:0000A504                 push    eax
.text$mn:0000A505                 sub     esp, 0Ch
.text$mn:0000A508                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A50D                 xor     eax, ebp
.text$mn:0000A50F                 push    eax
.text$mn:0000A510                 lea     eax, [ebp+var_C]
.text$mn:0000A513                 mov     large fs:0, eax
.text$mn:0000A519                 mov     [ebp+var_14], ecx
.text$mn:0000A51C                 push    3               ; int
.text$mn:0000A51E                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A521                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000A526                 mov     [ebp+var_4], 0
.text$mn:0000A52D                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000A530                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000A535                 mov     [ebp+var_10], eax
.text$mn:0000A538                 cmp     [ebp+var_10], 0
.text$mn:0000A53C                 jz      short loc_A58C
.text$mn:0000A53E
.text$mn:0000A53E loc_A53E:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *):loc_A58Aj
.text$mn:0000A53E                 mov     eax, [ebp+var_10]
.text$mn:0000A541                 cmp     dword ptr [eax], 0
.text$mn:0000A544                 jz      short loc_A58C
.text$mn:0000A546                 mov     ecx, [ebp+var_10]
.text$mn:0000A549                 mov     edx, [ecx]
.text$mn:0000A54B                 mov     eax, [edx+8]
.text$mn:0000A54E                 cmp     eax, [ebp+arg_0]
.text$mn:0000A551                 jb      short loc_A560
.text$mn:0000A553                 mov     ecx, [ebp+var_10]
.text$mn:0000A556                 mov     edx, [ecx]
.text$mn:0000A558                 mov     eax, [ebp+arg_4]
.text$mn:0000A55B                 cmp     eax, [edx+8]
.text$mn:0000A55E                 jnb     short loc_A56F
.text$mn:0000A560
.text$mn:0000A560 loc_A560:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+5Dj
.text$mn:0000A560                 mov     ecx, [ebp+var_10]
.text$mn:0000A563                 mov     ecx, [ecx]      ; this
.text$mn:0000A565                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A56A                 mov     [ebp+var_10], eax
.text$mn:0000A56D                 jmp     short loc_A58A
.text$mn:0000A56F ; ---------------------------------------------------------------------------
.text$mn:0000A56F
.text$mn:0000A56F loc_A56F:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+6Aj
.text$mn:0000A56F                 mov     edx, [ebp+var_10]
.text$mn:0000A572                 mov     ecx, [edx]      ; this
.text$mn:0000A574                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000A579                 mov     eax, [ebp+var_10]
.text$mn:0000A57C                 mov     ecx, [eax]      ; this
.text$mn:0000A57E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000A583                 mov     ecx, [ebp+var_10]
.text$mn:0000A586                 mov     edx, [eax]
.text$mn:0000A588                 mov     [ecx], edx
.text$mn:0000A58A
.text$mn:0000A58A loc_A58A:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+79j
.text$mn:0000A58A                 jmp     short loc_A53E
.text$mn:0000A58C ; ---------------------------------------------------------------------------
.text$mn:0000A58C
.text$mn:0000A58C loc_A58C:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+48j
.text$mn:0000A58C                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+50j
.text$mn:0000A58C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A593                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000A596                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000A59B                 mov     ecx, [ebp+var_C]
.text$mn:0000A59E                 mov     large fs:0, ecx
.text$mn:0000A5A5                 pop     ecx
.text$mn:0000A5A6                 mov     esp, ebp
.text$mn:0000A5A8                 pop     ebp
.text$mn:0000A5A9                 retn    8
.text$mn:0000A5A9 ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z endp
.text$mn:0000A5A9
.text$mn:0000A5A9 _text$mn        ends
.text$mn:0000A5A9
.text$x:0000A5AC ; ===========================================================================
.text$x:0000A5AC
.text$x:0000A5AC ; Segment type: Pure code
.text$x:0000A5AC ; Segment permissions: Read/Execute
.text$x:0000A5AC _text$x         segment para public 'CODE' use32
.text$x:0000A5AC                 assume cs:_text$x
.text$x:0000A5AC                 ;org 0A5ACh
.text$x:0000A5AC ; COMDAT (pick associative to section at A4F4)
.text$x:0000A5AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A5AC
.text$x:0000A5AC ; =============== S U B R O U T I N E =======================================
.text$x:0000A5AC
.text$x:0000A5AC
.text$x:0000A5AC __unwindfunclet$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z$0 proc near
.text$x:0000A5AC                                         ; DATA XREF: .xdata$x:0000DD10o
.text$x:0000A5AC                 lea     ecx, [ebp-18h]  ; this
.text$x:0000A5AF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000A5AF __unwindfunclet$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z$0 endp
.text$x:0000A5AF
.text$x:0000A5B4
.text$x:0000A5B4 ; =============== S U B R O U T I N E =======================================
.text$x:0000A5B4
.text$x:0000A5B4
.text$x:0000A5B4 __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z proc near
.text$x:0000A5B4                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+5o
.text$x:0000A5B4
.text$x:0000A5B4 arg_4           = dword ptr  8
.text$x:0000A5B4
.text$x:0000A5B4                 mov     edx, [esp+arg_4]
.text$x:0000A5B8                 lea     eax, [edx+0Ch]
.text$x:0000A5BB                 mov     ecx, [edx-10h]
.text$x:0000A5BE                 xor     ecx, eax
.text$x:0000A5C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A5C5                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.text$x:0000A5CA                 jmp     ___CxxFrameHandler3
.text$x:0000A5CA __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z endp
.text$x:0000A5CA
.text$x:0000A5CA ; ---------------------------------------------------------------------------
.text$x:0000A5CF                 align 10h
.text$x:0000A5CF _text$x         ends
.text$x:0000A5CF
.text$mn:0000A5D0 ; ===========================================================================
.text$mn:0000A5D0
.text$mn:0000A5D0 ; Segment type: Pure code
.text$mn:0000A5D0 ; Segment permissions: Read/Execute
.text$mn:0000A5D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5D0                 assume cs:_text$mn
.text$mn:0000A5D0                 ;org 0A5D0h
.text$mn:0000A5D0 ; COMDAT (pick any)
.text$mn:0000A5D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A5D0
.text$mn:0000A5D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5D0
.text$mn:0000A5D0 ; Attributes: bp-based frame
.text$mn:0000A5D0
.text$mn:0000A5D0 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Reallocate(unsigned int)
.text$mn:0000A5D0                 public ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:0000A5D0 ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z proc near
.text$mn:0000A5D0                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+4Ep
.text$mn:0000A5D0
.text$mn:0000A5D0 var_20          = dword ptr -20h
.text$mn:0000A5D0 var_1C          = dword ptr -1Ch
.text$mn:0000A5D0 var_18          = dword ptr -18h
.text$mn:0000A5D0 var_13          = byte ptr -13h
.text$mn:0000A5D0 var_11          = byte ptr -11h
.text$mn:0000A5D0 var_10          = dword ptr -10h
.text$mn:0000A5D0 var_C           = dword ptr -0Ch
.text$mn:0000A5D0 var_4           = dword ptr -4
.text$mn:0000A5D0 arg_0           = dword ptr  8
.text$mn:0000A5D0
.text$mn:0000A5D0 ; FUNCTION CHUNK AT .text$mn:0000A666 SIZE 00000009 BYTES
.text$mn:0000A5D0 ; FUNCTION CHUNK AT .text$mn:0000A676 SIZE 00000098 BYTES
.text$mn:0000A5D0
.text$mn:0000A5D0                 push    ebp
.text$mn:0000A5D1                 mov     ebp, esp
.text$mn:0000A5D3                 push    0FFFFFFFFh
.text$mn:0000A5D5                 push    offset __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:0000A5DA                 mov     eax, large fs:0
.text$mn:0000A5E0                 push    eax
.text$mn:0000A5E1                 push    ecx
.text$mn:0000A5E2                 sub     esp, 10h
.text$mn:0000A5E5                 push    ebx
.text$mn:0000A5E6                 push    esi
.text$mn:0000A5E7                 push    edi
.text$mn:0000A5E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A5ED                 xor     eax, ebp
.text$mn:0000A5EF                 push    eax
.text$mn:0000A5F0                 lea     eax, [ebp+var_C]
.text$mn:0000A5F3                 mov     large fs:0, eax
.text$mn:0000A5F9                 mov     [ebp+var_10], esp
.text$mn:0000A5FC                 mov     [ebp+var_18], ecx
.text$mn:0000A5FF                 mov     eax, [ebp+arg_0]
.text$mn:0000A602                 push    eax
.text$mn:0000A603                 lea     ecx, [ebp+var_11]
.text$mn:0000A606                 push    ecx
.text$mn:0000A607                 mov     ecx, [ebp+var_18]
.text$mn:0000A60A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000A60F                 mov     ecx, eax
.text$mn:0000A611                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::allocate(uint)
.text$mn:0000A616                 mov     [ebp+var_1C], eax
.text$mn:0000A619                 mov     [ebp+var_4], 0
.text$mn:0000A620                 mov     edx, [ebp+var_1C]
.text$mn:0000A623                 push    edx
.text$mn:0000A624                 mov     eax, [ebp+var_18]
.text$mn:0000A627                 mov     ecx, [eax+8]
.text$mn:0000A62A                 push    ecx
.text$mn:0000A62B                 mov     edx, [ebp+var_18]
.text$mn:0000A62E                 mov     eax, [edx+4]
.text$mn:0000A631                 push    eax
.text$mn:0000A632                 mov     ecx, [ebp+var_18]
.text$mn:0000A635                 call    ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Umove<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *)
.text$mn:0000A63A                 jmp     short loc_A666
.text$mn:0000A63A ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z endp
.text$mn:0000A63A
.text$mn:0000A63C
.text$mn:0000A63C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A63C
.text$mn:0000A63C ; Attributes: noreturn
.text$mn:0000A63C
.text$mn:0000A63C __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:0000A63C                                         ; DATA XREF: .xdata$x:0000DE4Co
.text$mn:0000A63C                 mov     ecx, [ebp+8]
.text$mn:0000A63F                 push    ecx             ; int
.text$mn:0000A640                 mov     edx, [ebp-1Ch]
.text$mn:0000A643                 push    edx             ; void *
.text$mn:0000A644                 lea     eax, [ebp-12h]
.text$mn:0000A647                 push    eax
.text$mn:0000A648                 mov     ecx, [ebp-18h]
.text$mn:0000A64B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000A650                 mov     ecx, eax
.text$mn:0000A652                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)
.text$mn:0000A657                 push    0
.text$mn:0000A659                 push    0
.text$mn:0000A65B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000A65B __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:0000A65B
.text$mn:0000A660 ; ---------------------------------------------------------------------------
.text$mn:0000A660                 mov     eax, offset $LN8_2
.text$mn:0000A665                 retn
.text$mn:0000A666 ; ---------------------------------------------------------------------------
.text$mn:0000A666 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:0000A666
.text$mn:0000A666 loc_A666:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+6Aj
.text$mn:0000A666                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A66D                 jmp     short loc_A676
.text$mn:0000A66D ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:0000A66F
.text$mn:0000A66F ; =============== S U B R O U T I N E =======================================
.text$mn:0000A66F
.text$mn:0000A66F
.text$mn:0000A66F $LN8_2          proc near               ; DATA XREF: .text$mn:0000A660o
.text$mn:0000A66F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000A66F $LN8_2          endp ; sp-analysis failed
.text$mn:0000A66F
.text$mn:0000A676 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:0000A676
.text$mn:0000A676 loc_A676:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+9Dj
.text$mn:0000A676                 mov     ecx, [ebp+var_18]
.text$mn:0000A679                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:0000A67E                 mov     [ebp+var_20], eax
.text$mn:0000A681                 mov     ecx, [ebp+var_18]
.text$mn:0000A684                 cmp     dword ptr [ecx+4], 0
.text$mn:0000A688                 jz      short loc_A6CF
.text$mn:0000A68A                 mov     edx, [ebp+var_18]
.text$mn:0000A68D                 mov     eax, [edx+8]
.text$mn:0000A690                 push    eax
.text$mn:0000A691                 mov     ecx, [ebp+var_18]
.text$mn:0000A694                 mov     edx, [ecx+4]
.text$mn:0000A697                 push    edx
.text$mn:0000A698                 mov     ecx, [ebp+var_18]
.text$mn:0000A69B                 call    ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)
.text$mn:0000A6A0                 mov     eax, [ebp+var_18]
.text$mn:0000A6A3                 mov     ecx, [ebp+var_18]
.text$mn:0000A6A6                 mov     eax, [eax+0Ch]
.text$mn:0000A6A9                 sub     eax, [ecx+4]
.text$mn:0000A6AC                 cdq
.text$mn:0000A6AD                 mov     ecx, 3Ch ; '<'
.text$mn:0000A6B2                 idiv    ecx
.text$mn:0000A6B4                 push    eax             ; int
.text$mn:0000A6B5                 mov     edx, [ebp+var_18]
.text$mn:0000A6B8                 mov     eax, [edx+4]
.text$mn:0000A6BB                 push    eax             ; void *
.text$mn:0000A6BC                 lea     ecx, [ebp+var_13]
.text$mn:0000A6BF                 push    ecx
.text$mn:0000A6C0                 mov     ecx, [ebp+var_18]
.text$mn:0000A6C3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000A6C8                 mov     ecx, eax
.text$mn:0000A6CA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)
.text$mn:0000A6CF
.text$mn:0000A6CF loc_A6CF:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+B8j
.text$mn:0000A6CF                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000A6D2                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A6D7                 imul    edx, [ebp+arg_0], 3Ch
.text$mn:0000A6DB                 add     edx, [ebp+var_1C]
.text$mn:0000A6DE                 mov     eax, [ebp+var_18]
.text$mn:0000A6E1                 mov     [eax+0Ch], edx
.text$mn:0000A6E4                 imul    ecx, [ebp+var_20], 3Ch
.text$mn:0000A6E8                 add     ecx, [ebp+var_1C]
.text$mn:0000A6EB                 mov     edx, [ebp+var_18]
.text$mn:0000A6EE                 mov     [edx+8], ecx
.text$mn:0000A6F1                 mov     eax, [ebp+var_18]
.text$mn:0000A6F4                 mov     ecx, [ebp+var_1C]
.text$mn:0000A6F7                 mov     [eax+4], ecx
.text$mn:0000A6FA                 mov     ecx, [ebp+var_C]
.text$mn:0000A6FD                 mov     large fs:0, ecx
.text$mn:0000A704                 pop     ecx
.text$mn:0000A705                 pop     edi
.text$mn:0000A706                 pop     esi
.text$mn:0000A707                 pop     ebx
.text$mn:0000A708                 mov     esp, ebp
.text$mn:0000A70A                 pop     ebp
.text$mn:0000A70B                 retn    4
.text$mn:0000A70B ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:0000A70B ; ---------------------------------------------------------------------------
.text$mn:0000A70E                 align 10h
.text$mn:0000A70E _text$mn        ends
.text$mn:0000A70E
.text$x:0000A710 ; ===========================================================================
.text$x:0000A710
.text$x:0000A710 ; Segment type: Pure code
.text$x:0000A710 ; Segment permissions: Read/Execute
.text$x:0000A710 _text$x         segment para public 'CODE' use32
.text$x:0000A710                 assume cs:_text$x
.text$x:0000A710                 ;org 0A710h
.text$x:0000A710 ; COMDAT (pick associative to section at A5D0)
.text$x:0000A710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A710
.text$x:0000A710 ; =============== S U B R O U T I N E =======================================
.text$x:0000A710
.text$x:0000A710
.text$x:0000A710 __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z proc near
.text$x:0000A710                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+5o
.text$x:0000A710
.text$x:0000A710 arg_4           = dword ptr  8
.text$x:0000A710
.text$x:0000A710                 mov     edx, [esp+arg_4]
.text$x:0000A714                 lea     eax, [edx+0Ch]
.text$x:0000A717                 mov     ecx, [edx-24h]
.text$x:0000A71A                 xor     ecx, eax
.text$x:0000A71C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A721                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$x:0000A726                 jmp     ___CxxFrameHandler3
.text$x:0000A726 __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z endp
.text$x:0000A726
.text$x:0000A726 ; ---------------------------------------------------------------------------
.text$x:0000A72B                 align 4
.text$x:0000A72B _text$x         ends
.text$x:0000A72B
.text$mn:0000A72C ; ===========================================================================
.text$mn:0000A72C
.text$mn:0000A72C ; Segment type: Pure code
.text$mn:0000A72C ; Segment permissions: Read/Execute
.text$mn:0000A72C _text$mn        segment para public 'CODE' use32
.text$mn:0000A72C                 assume cs:_text$mn
.text$mn:0000A72C                 ;org 0A72Ch
.text$mn:0000A72C ; COMDAT (pick any)
.text$mn:0000A72C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A72C
.text$mn:0000A72C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A72C
.text$mn:0000A72C ; Attributes: bp-based frame
.text$mn:0000A72C
.text$mn:0000A72C ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Reserve(unsigned int)
.text$mn:0000A72C                 public ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:0000A72C ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z proc near
.text$mn:0000A72C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+59p
.text$mn:0000A72C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+C6p
.text$mn:0000A72C
.text$mn:0000A72C var_4           = dword ptr -4
.text$mn:0000A72C arg_0           = dword ptr  8
.text$mn:0000A72C
.text$mn:0000A72C                 push    ebp
.text$mn:0000A72D                 mov     ebp, esp
.text$mn:0000A72F                 push    ecx
.text$mn:0000A730                 push    esi
.text$mn:0000A731                 mov     [ebp+var_4], ecx
.text$mn:0000A734                 mov     ecx, [ebp+var_4]
.text$mn:0000A737                 call    ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Unused_capacity(void)
.text$mn:0000A73C                 cmp     eax, [ebp+arg_0]
.text$mn:0000A73F                 jnb     short loc_A77F
.text$mn:0000A741                 mov     ecx, [ebp+var_4]
.text$mn:0000A744                 call    ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::max_size(void)
.text$mn:0000A749                 mov     esi, eax
.text$mn:0000A74B                 mov     ecx, [ebp+var_4]
.text$mn:0000A74E                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:0000A753                 sub     esi, eax
.text$mn:0000A755                 cmp     esi, [ebp+arg_0]
.text$mn:0000A758                 jnb     short loc_A762
.text$mn:0000A75A                 mov     ecx, [ebp+var_4]
.text$mn:0000A75D                 call    ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Xlen(void)
.text$mn:0000A762
.text$mn:0000A762 loc_A762:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+2Cj
.text$mn:0000A762                 mov     ecx, [ebp+var_4]
.text$mn:0000A765                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:0000A76A                 add     eax, [ebp+arg_0]
.text$mn:0000A76D                 push    eax
.text$mn:0000A76E                 mov     ecx, [ebp+var_4]
.text$mn:0000A771                 call    ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)
.text$mn:0000A776                 push    eax
.text$mn:0000A777                 mov     ecx, [ebp+var_4]
.text$mn:0000A77A                 call    ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)
.text$mn:0000A77F
.text$mn:0000A77F loc_A77F:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+13j
.text$mn:0000A77F                 pop     esi
.text$mn:0000A780                 mov     esp, ebp
.text$mn:0000A782                 pop     ebp
.text$mn:0000A783                 retn    4
.text$mn:0000A783 ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z endp
.text$mn:0000A783
.text$mn:0000A783 ; ---------------------------------------------------------------------------
.text$mn:0000A786                 align 4
.text$mn:0000A786 _text$mn        ends
.text$mn:0000A786
.text$mn:0000A788 ; ===========================================================================
.text$mn:0000A788
.text$mn:0000A788 ; Segment type: Pure code
.text$mn:0000A788 ; Segment permissions: Read/Execute
.text$mn:0000A788 _text$mn        segment para public 'CODE' use32
.text$mn:0000A788                 assume cs:_text$mn
.text$mn:0000A788                 ;org 0A788h
.text$mn:0000A788 ; COMDAT (pick any)
.text$mn:0000A788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A788
.text$mn:0000A788 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A788
.text$mn:0000A788 ; Attributes: bp-based frame
.text$mn:0000A788
.text$mn:0000A788 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000A788                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000A788 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000A788                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000A788                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000A788
.text$mn:0000A788 var_C           = dword ptr -0Ch
.text$mn:0000A788 var_8           = dword ptr -8
.text$mn:0000A788 var_2           = byte ptr -2
.text$mn:0000A788 var_1           = byte ptr -1
.text$mn:0000A788 arg_0           = byte ptr  8
.text$mn:0000A788 Size            = dword ptr  0Ch
.text$mn:0000A788
.text$mn:0000A788                 push    ebp
.text$mn:0000A789                 mov     ebp, esp
.text$mn:0000A78B                 sub     esp, 0Ch
.text$mn:0000A78E                 mov     [ebp+var_8], ecx
.text$mn:0000A791                 movzx   eax, [ebp+arg_0]
.text$mn:0000A795                 test    eax, eax
.text$mn:0000A797                 jnz     short loc_A79B
.text$mn:0000A799                 jmp     short loc_A80E
.text$mn:0000A79B ; ---------------------------------------------------------------------------
.text$mn:0000A79B
.text$mn:0000A79B loc_A79B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000A79B                 mov     ecx, [ebp+var_8]
.text$mn:0000A79E                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000A7A2                 jb      short loc_A80E
.text$mn:0000A7A4                 mov     edx, [ebp+var_8]
.text$mn:0000A7A7                 mov     eax, [edx+4]
.text$mn:0000A7AA                 mov     [ebp+var_C], eax
.text$mn:0000A7AD                 mov     ecx, [ebp+var_8]
.text$mn:0000A7B0                 add     ecx, 4
.text$mn:0000A7B3                 push    ecx
.text$mn:0000A7B4                 lea     edx, [ebp+var_1]
.text$mn:0000A7B7                 push    edx
.text$mn:0000A7B8                 mov     ecx, [ebp+var_8]
.text$mn:0000A7BB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000A7C0                 mov     ecx, eax
.text$mn:0000A7C2                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000A7C7                 cmp     [ebp+Size], 0
.text$mn:0000A7CB                 jbe     short loc_A7ED
.text$mn:0000A7CD                 mov     eax, [ebp+Size]
.text$mn:0000A7D0                 push    eax             ; Size
.text$mn:0000A7D1                 mov     ecx, [ebp+var_C]
.text$mn:0000A7D4                 push    ecx
.text$mn:0000A7D5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000A7DA                 add     esp, 4
.text$mn:0000A7DD                 push    eax             ; Src
.text$mn:0000A7DE                 mov     edx, [ebp+var_8]
.text$mn:0000A7E1                 add     edx, 4
.text$mn:0000A7E4                 push    edx             ; Dst
.text$mn:0000A7E5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000A7EA                 add     esp, 0Ch
.text$mn:0000A7ED
.text$mn:0000A7ED loc_A7ED:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000A7ED                 mov     eax, [ebp+var_8]
.text$mn:0000A7F0                 mov     ecx, [eax+18h]
.text$mn:0000A7F3                 add     ecx, 1
.text$mn:0000A7F6                 push    ecx             ; int
.text$mn:0000A7F7                 mov     edx, [ebp+var_C]
.text$mn:0000A7FA                 push    edx             ; void *
.text$mn:0000A7FB                 lea     eax, [ebp+var_2]
.text$mn:0000A7FE                 push    eax
.text$mn:0000A7FF                 mov     ecx, [ebp+var_8]
.text$mn:0000A802                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000A807                 mov     ecx, eax
.text$mn:0000A809                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000A80E
.text$mn:0000A80E loc_A80E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000A80E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000A80E                 mov     ecx, [ebp+var_8]
.text$mn:0000A811                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:0000A818                 mov     edx, [ebp+Size]
.text$mn:0000A81B                 push    edx
.text$mn:0000A81C                 mov     ecx, [ebp+var_8]
.text$mn:0000A81F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A824                 mov     esp, ebp
.text$mn:0000A826                 pop     ebp
.text$mn:0000A827                 retn    8
.text$mn:0000A827 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000A827
.text$mn:0000A827 ; ---------------------------------------------------------------------------
.text$mn:0000A82A                 align 4
.text$mn:0000A82A _text$mn        ends
.text$mn:0000A82A
.text$mn:0000A82C ; ===========================================================================
.text$mn:0000A82C
.text$mn:0000A82C ; Segment type: Pure code
.text$mn:0000A82C ; Segment permissions: Read/Execute
.text$mn:0000A82C _text$mn        segment para public 'CODE' use32
.text$mn:0000A82C                 assume cs:_text$mn
.text$mn:0000A82C                 ;org 0A82Ch
.text$mn:0000A82C ; COMDAT (pick any)
.text$mn:0000A82C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A82C
.text$mn:0000A82C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A82C
.text$mn:0000A82C ; Attributes: bp-based frame
.text$mn:0000A82C
.text$mn:0000A82C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:0000A82C                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:0000A82C ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:0000A82C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p
.text$mn:0000A82C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p ...
.text$mn:0000A82C
.text$mn:0000A82C var_C           = dword ptr -0Ch
.text$mn:0000A82C var_8           = dword ptr -8
.text$mn:0000A82C var_2           = byte ptr -2
.text$mn:0000A82C var_1           = byte ptr -1
.text$mn:0000A82C arg_0           = byte ptr  8
.text$mn:0000A82C arg_4           = dword ptr  0Ch
.text$mn:0000A82C
.text$mn:0000A82C                 push    ebp
.text$mn:0000A82D                 mov     ebp, esp
.text$mn:0000A82F                 sub     esp, 0Ch
.text$mn:0000A832                 mov     [ebp+var_8], ecx
.text$mn:0000A835                 movzx   eax, [ebp+arg_0]
.text$mn:0000A839                 test    eax, eax
.text$mn:0000A83B                 jnz     short loc_A83F
.text$mn:0000A83D                 jmp     short loc_A8B2
.text$mn:0000A83F ; ---------------------------------------------------------------------------
.text$mn:0000A83F
.text$mn:0000A83F loc_A83F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000A83F                 mov     ecx, [ebp+var_8]
.text$mn:0000A842                 cmp     dword ptr [ecx+18h], 8
.text$mn:0000A846                 jb      short loc_A8B2
.text$mn:0000A848                 mov     edx, [ebp+var_8]
.text$mn:0000A84B                 mov     eax, [edx+4]
.text$mn:0000A84E                 mov     [ebp+var_C], eax
.text$mn:0000A851                 mov     ecx, [ebp+var_8]
.text$mn:0000A854                 add     ecx, 4
.text$mn:0000A857                 push    ecx
.text$mn:0000A858                 lea     edx, [ebp+var_1]
.text$mn:0000A85B                 push    edx
.text$mn:0000A85C                 mov     ecx, [ebp+var_8]
.text$mn:0000A85F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A864                 mov     ecx, eax
.text$mn:0000A866                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000A86B                 cmp     [ebp+arg_4], 0
.text$mn:0000A86F                 jbe     short loc_A891
.text$mn:0000A871                 mov     eax, [ebp+arg_4]
.text$mn:0000A874                 push    eax             ; int
.text$mn:0000A875                 mov     ecx, [ebp+var_C]
.text$mn:0000A878                 push    ecx
.text$mn:0000A879                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000A87E                 add     esp, 4
.text$mn:0000A881                 push    eax             ; Src
.text$mn:0000A882                 mov     edx, [ebp+var_8]
.text$mn:0000A885                 add     edx, 4
.text$mn:0000A888                 push    edx             ; Dst
.text$mn:0000A889                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A88E                 add     esp, 0Ch
.text$mn:0000A891
.text$mn:0000A891 loc_A891:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000A891                 mov     eax, [ebp+var_8]
.text$mn:0000A894                 mov     ecx, [eax+18h]
.text$mn:0000A897                 add     ecx, 1
.text$mn:0000A89A                 push    ecx             ; int
.text$mn:0000A89B                 mov     edx, [ebp+var_C]
.text$mn:0000A89E                 push    edx             ; void *
.text$mn:0000A89F                 lea     eax, [ebp+var_2]
.text$mn:0000A8A2                 push    eax
.text$mn:0000A8A3                 mov     ecx, [ebp+var_8]
.text$mn:0000A8A6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000A8AB                 mov     ecx, eax
.text$mn:0000A8AD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000A8B2
.text$mn:0000A8B2 loc_A8B2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:0000A8B2                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:0000A8B2                 mov     ecx, [ebp+var_8]
.text$mn:0000A8B5                 mov     dword ptr [ecx+18h], 7
.text$mn:0000A8BC                 mov     edx, [ebp+arg_4]
.text$mn:0000A8BF                 push    edx
.text$mn:0000A8C0                 mov     ecx, [ebp+var_8]
.text$mn:0000A8C3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A8C8                 mov     esp, ebp
.text$mn:0000A8CA                 pop     ebp
.text$mn:0000A8CB                 retn    8
.text$mn:0000A8CB ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:0000A8CB
.text$mn:0000A8CB ; ---------------------------------------------------------------------------
.text$mn:0000A8CE                 align 10h
.text$mn:0000A8CE _text$mn        ends
.text$mn:0000A8CE
.text$mn:0000A8D0 ; ===========================================================================
.text$mn:0000A8D0
.text$mn:0000A8D0 ; Segment type: Pure code
.text$mn:0000A8D0 ; Segment permissions: Read/Execute
.text$mn:0000A8D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A8D0                 assume cs:_text$mn
.text$mn:0000A8D0                 ;org 0A8D0h
.text$mn:0000A8D0 ; COMDAT (pick any)
.text$mn:0000A8D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A8D0
.text$mn:0000A8D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8D0
.text$mn:0000A8D0 ; Attributes: bp-based frame
.text$mn:0000A8D0
.text$mn:0000A8D0 ; protected: void __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::_Tidy(void)
.text$mn:0000A8D0                 public ?_Tidy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXXZ
.text$mn:0000A8D0 ?_Tidy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXXZ proc near
.text$mn:0000A8D0                                         ; CODE XREF: __catch$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:0000A8D0                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::~vector<KeyCombo,std::allocator<KeyCombo>>(void)+30p ...
.text$mn:0000A8D0
.text$mn:0000A8D0 var_8           = dword ptr -8
.text$mn:0000A8D0 var_1           = byte ptr -1
.text$mn:0000A8D0
.text$mn:0000A8D0                 push    ebp
.text$mn:0000A8D1                 mov     ebp, esp
.text$mn:0000A8D3                 sub     esp, 8
.text$mn:0000A8D6                 mov     [ebp+var_8], ecx
.text$mn:0000A8D9                 mov     eax, [ebp+var_8]
.text$mn:0000A8DC                 cmp     dword ptr [eax+4], 0
.text$mn:0000A8E0                 jz      short loc_A948
.text$mn:0000A8E2                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A8E5                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A8EA                 mov     ecx, [ebp+var_8]
.text$mn:0000A8ED                 mov     edx, [ecx+8]
.text$mn:0000A8F0                 push    edx
.text$mn:0000A8F1                 mov     eax, [ebp+var_8]
.text$mn:0000A8F4                 mov     ecx, [eax+4]
.text$mn:0000A8F7                 push    ecx
.text$mn:0000A8F8                 mov     ecx, [ebp+var_8]
.text$mn:0000A8FB                 call    ?_Destroy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXPAUKeyCombo@@0@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Destroy(KeyCombo *,KeyCombo *)
.text$mn:0000A900                 mov     edx, [ebp+var_8]
.text$mn:0000A903                 mov     eax, [ebp+var_8]
.text$mn:0000A906                 mov     ecx, [edx+0Ch]
.text$mn:0000A909                 sub     ecx, [eax+4]
.text$mn:0000A90C                 sar     ecx, 2
.text$mn:0000A90F                 push    ecx             ; int
.text$mn:0000A910                 mov     edx, [ebp+var_8]
.text$mn:0000A913                 mov     eax, [edx+4]
.text$mn:0000A916                 push    eax             ; void *
.text$mn:0000A917                 lea     ecx, [ebp+var_1]
.text$mn:0000A91A                 push    ecx
.text$mn:0000A91B                 mov     ecx, [ebp+var_8]
.text$mn:0000A91E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:0000A923                 mov     ecx, eax
.text$mn:0000A925                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@I@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::deallocate(KeyCombo *,uint)
.text$mn:0000A92A                 mov     edx, [ebp+var_8]
.text$mn:0000A92D                 mov     dword ptr [edx+4], 0
.text$mn:0000A934                 mov     eax, [ebp+var_8]
.text$mn:0000A937                 mov     dword ptr [eax+8], 0
.text$mn:0000A93E                 mov     ecx, [ebp+var_8]
.text$mn:0000A941                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000A948
.text$mn:0000A948 loc_A948:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Tidy(void)+10j
.text$mn:0000A948                 mov     esp, ebp
.text$mn:0000A94A                 pop     ebp
.text$mn:0000A94B                 retn
.text$mn:0000A94B ?_Tidy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXXZ endp
.text$mn:0000A94B
.text$mn:0000A94B _text$mn        ends
.text$mn:0000A94B
.text$mn:0000A94C ; ===========================================================================
.text$mn:0000A94C
.text$mn:0000A94C ; Segment type: Pure code
.text$mn:0000A94C ; Segment permissions: Read/Execute
.text$mn:0000A94C _text$mn        segment para public 'CODE' use32
.text$mn:0000A94C                 assume cs:_text$mn
.text$mn:0000A94C                 ;org 0A94Ch
.text$mn:0000A94C ; COMDAT (pick any)
.text$mn:0000A94C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A94C
.text$mn:0000A94C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A94C
.text$mn:0000A94C ; Attributes: bp-based frame
.text$mn:0000A94C
.text$mn:0000A94C ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Tidy(void)
.text$mn:0000A94C                 public ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ
.text$mn:0000A94C ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ proc near
.text$mn:0000A94C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+30p
.text$mn:0000A94C
.text$mn:0000A94C var_8           = dword ptr -8
.text$mn:0000A94C var_1           = byte ptr -1
.text$mn:0000A94C
.text$mn:0000A94C                 push    ebp
.text$mn:0000A94D                 mov     ebp, esp
.text$mn:0000A94F                 sub     esp, 8
.text$mn:0000A952                 mov     [ebp+var_8], ecx
.text$mn:0000A955                 mov     eax, [ebp+var_8]
.text$mn:0000A958                 cmp     dword ptr [eax+4], 0
.text$mn:0000A95C                 jz      short loc_A9CB
.text$mn:0000A95E                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A961                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A966                 mov     ecx, [ebp+var_8]
.text$mn:0000A969                 mov     edx, [ecx+8]
.text$mn:0000A96C                 push    edx
.text$mn:0000A96D                 mov     eax, [ebp+var_8]
.text$mn:0000A970                 mov     ecx, [eax+4]
.text$mn:0000A973                 push    ecx
.text$mn:0000A974                 mov     ecx, [ebp+var_8]
.text$mn:0000A977                 call    ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)
.text$mn:0000A97C                 mov     edx, [ebp+var_8]
.text$mn:0000A97F                 mov     eax, [ebp+var_8]
.text$mn:0000A982                 mov     ecx, [edx+0Ch]
.text$mn:0000A985                 sub     ecx, [eax+4]
.text$mn:0000A988                 mov     eax, ecx
.text$mn:0000A98A                 cdq
.text$mn:0000A98B                 mov     ecx, 3Ch ; '<'
.text$mn:0000A990                 idiv    ecx
.text$mn:0000A992                 push    eax             ; int
.text$mn:0000A993                 mov     edx, [ebp+var_8]
.text$mn:0000A996                 mov     eax, [edx+4]
.text$mn:0000A999                 push    eax             ; void *
.text$mn:0000A99A                 lea     ecx, [ebp+var_1]
.text$mn:0000A99D                 push    ecx
.text$mn:0000A99E                 mov     ecx, [ebp+var_8]
.text$mn:0000A9A1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000A9A6                 mov     ecx, eax
.text$mn:0000A9A8                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)
.text$mn:0000A9AD                 mov     edx, [ebp+var_8]
.text$mn:0000A9B0                 mov     dword ptr [edx+4], 0
.text$mn:0000A9B7                 mov     eax, [ebp+var_8]
.text$mn:0000A9BA                 mov     dword ptr [eax+8], 0
.text$mn:0000A9C1                 mov     ecx, [ebp+var_8]
.text$mn:0000A9C4                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000A9CB
.text$mn:0000A9CB loc_A9CB:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Tidy(void)+10j
.text$mn:0000A9CB                 mov     esp, ebp
.text$mn:0000A9CD                 pop     ebp
.text$mn:0000A9CE                 retn
.text$mn:0000A9CE ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ endp
.text$mn:0000A9CE
.text$mn:0000A9CE ; ---------------------------------------------------------------------------
.text$mn:0000A9CF                 align 10h
.text$mn:0000A9CF _text$mn        ends
.text$mn:0000A9CF
.text$mn:0000A9D0 ; ===========================================================================
.text$mn:0000A9D0
.text$mn:0000A9D0 ; Segment type: Pure code
.text$mn:0000A9D0 ; Segment permissions: Read/Execute
.text$mn:0000A9D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9D0                 assume cs:_text$mn
.text$mn:0000A9D0                 ;org 0A9D0h
.text$mn:0000A9D0 ; COMDAT (pick any)
.text$mn:0000A9D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000A9D0
.text$mn:0000A9D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9D0
.text$mn:0000A9D0 ; Attributes: bp-based frame
.text$mn:0000A9D0
.text$mn:0000A9D0 ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Tidy(void)
.text$mn:0000A9D0                 public ?_Tidy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXXZ
.text$mn:0000A9D0 ?_Tidy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXXZ proc near
.text$mn:0000A9D0                                         ; CODE XREF: __catch$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:0000A9D0                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::~vector<recordedMacroStep,std::allocator<recordedMacroStep>>(void)+30p ...
.text$mn:0000A9D0
.text$mn:0000A9D0 var_8           = dword ptr -8
.text$mn:0000A9D0 var_1           = byte ptr -1
.text$mn:0000A9D0
.text$mn:0000A9D0                 push    ebp
.text$mn:0000A9D1                 mov     ebp, esp
.text$mn:0000A9D3                 sub     esp, 8
.text$mn:0000A9D6                 mov     [ebp+var_8], ecx
.text$mn:0000A9D9                 mov     eax, [ebp+var_8]
.text$mn:0000A9DC                 cmp     dword ptr [eax+4], 0
.text$mn:0000A9E0                 jz      short loc_AA4F
.text$mn:0000A9E2                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A9E5                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000A9EA                 mov     ecx, [ebp+var_8]
.text$mn:0000A9ED                 mov     edx, [ecx+8]
.text$mn:0000A9F0                 push    edx
.text$mn:0000A9F1                 mov     eax, [ebp+var_8]
.text$mn:0000A9F4                 mov     ecx, [eax+4]
.text$mn:0000A9F7                 push    ecx
.text$mn:0000A9F8                 mov     ecx, [ebp+var_8]
.text$mn:0000A9FB                 call    ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)
.text$mn:0000AA00                 mov     edx, [ebp+var_8]
.text$mn:0000AA03                 mov     eax, [ebp+var_8]
.text$mn:0000AA06                 mov     ecx, [edx+0Ch]
.text$mn:0000AA09                 sub     ecx, [eax+4]
.text$mn:0000AA0C                 mov     eax, ecx
.text$mn:0000AA0E                 cdq
.text$mn:0000AA0F                 mov     ecx, 2Ch ; ','
.text$mn:0000AA14                 idiv    ecx
.text$mn:0000AA16                 push    eax             ; int
.text$mn:0000AA17                 mov     edx, [ebp+var_8]
.text$mn:0000AA1A                 mov     eax, [edx+4]
.text$mn:0000AA1D                 push    eax             ; void *
.text$mn:0000AA1E                 lea     ecx, [ebp+var_1]
.text$mn:0000AA21                 push    ecx
.text$mn:0000AA22                 mov     ecx, [ebp+var_8]
.text$mn:0000AA25                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000AA2A                 mov     ecx, eax
.text$mn:0000AA2C                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(recordedMacroStep *,uint)
.text$mn:0000AA31                 mov     edx, [ebp+var_8]
.text$mn:0000AA34                 mov     dword ptr [edx+4], 0
.text$mn:0000AA3B                 mov     eax, [ebp+var_8]
.text$mn:0000AA3E                 mov     dword ptr [eax+8], 0
.text$mn:0000AA45                 mov     ecx, [ebp+var_8]
.text$mn:0000AA48                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000AA4F
.text$mn:0000AA4F loc_AA4F:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Tidy(void)+10j
.text$mn:0000AA4F                 mov     esp, ebp
.text$mn:0000AA51                 pop     ebp
.text$mn:0000AA52                 retn
.text$mn:0000AA52 ?_Tidy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXXZ endp
.text$mn:0000AA52
.text$mn:0000AA52 ; ---------------------------------------------------------------------------
.text$mn:0000AA53                 align 4
.text$mn:0000AA53 _text$mn        ends
.text$mn:0000AA53
.text$mn:0000AA54 ; ===========================================================================
.text$mn:0000AA54
.text$mn:0000AA54 ; Segment type: Pure code
.text$mn:0000AA54 ; Segment permissions: Read/Execute
.text$mn:0000AA54 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA54                 assume cs:_text$mn
.text$mn:0000AA54                 ;org 0AA54h
.text$mn:0000AA54 ; COMDAT (pick any)
.text$mn:0000AA54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA54
.text$mn:0000AA54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA54
.text$mn:0000AA54 ; Attributes: bp-based frame
.text$mn:0000AA54
.text$mn:0000AA54 ; public: struct KeyCombo const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>>::_Unchecked(void)const
.text$mn:0000AA54                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QBEPBUKeyCombo@@XZ
.text$mn:0000AA54 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QBEPBUKeyCombo@@XZ proc near
.text$mn:0000AA54                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<KeyCombo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>)+2Dp
.text$mn:0000AA54
.text$mn:0000AA54 var_4           = dword ptr -4
.text$mn:0000AA54
.text$mn:0000AA54                 push    ebp
.text$mn:0000AA55                 mov     ebp, esp
.text$mn:0000AA57                 push    ecx
.text$mn:0000AA58                 mov     [ebp+var_4], ecx
.text$mn:0000AA5B                 mov     eax, [ebp+var_4]
.text$mn:0000AA5E                 mov     eax, [eax+8]
.text$mn:0000AA61                 mov     esp, ebp
.text$mn:0000AA63                 pop     ebp
.text$mn:0000AA64                 retn
.text$mn:0000AA64 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QBEPBUKeyCombo@@XZ endp
.text$mn:0000AA64
.text$mn:0000AA64 ; ---------------------------------------------------------------------------
.text$mn:0000AA65                 align 4
.text$mn:0000AA65 _text$mn        ends
.text$mn:0000AA65
.text$mn:0000AA68 ; ===========================================================================
.text$mn:0000AA68
.text$mn:0000AA68 ; Segment type: Pure code
.text$mn:0000AA68 ; Segment permissions: Read/Execute
.text$mn:0000AA68 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA68                 assume cs:_text$mn
.text$mn:0000AA68                 ;org 0AA68h
.text$mn:0000AA68 ; COMDAT (pick any)
.text$mn:0000AA68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA68
.text$mn:0000AA68 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA68
.text$mn:0000AA68 ; Attributes: bp-based frame
.text$mn:0000AA68
.text$mn:0000AA68 ; public: struct recordedMacroStep const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>>::_Unchecked(void)const
.text$mn:0000AA68                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QBEPBUrecordedMacroStep@@XZ
.text$mn:0000AA68 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QBEPBUrecordedMacroStep@@XZ proc near
.text$mn:0000AA68                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>)+2Dp
.text$mn:0000AA68
.text$mn:0000AA68 var_4           = dword ptr -4
.text$mn:0000AA68
.text$mn:0000AA68                 push    ebp
.text$mn:0000AA69                 mov     ebp, esp
.text$mn:0000AA6B                 push    ecx
.text$mn:0000AA6C                 mov     [ebp+var_4], ecx
.text$mn:0000AA6F                 mov     eax, [ebp+var_4]
.text$mn:0000AA72                 mov     eax, [eax+8]
.text$mn:0000AA75                 mov     esp, ebp
.text$mn:0000AA77                 pop     ebp
.text$mn:0000AA78                 retn
.text$mn:0000AA78 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QBEPBUrecordedMacroStep@@XZ endp
.text$mn:0000AA78
.text$mn:0000AA78 ; ---------------------------------------------------------------------------
.text$mn:0000AA79                 align 4
.text$mn:0000AA79 _text$mn        ends
.text$mn:0000AA79
.text$mn:0000AA7C ; ===========================================================================
.text$mn:0000AA7C
.text$mn:0000AA7C ; Segment type: Pure code
.text$mn:0000AA7C ; Segment permissions: Read/Execute
.text$mn:0000AA7C _text$mn        segment para public 'CODE' use32
.text$mn:0000AA7C                 assume cs:_text$mn
.text$mn:0000AA7C                 ;org 0AA7Ch
.text$mn:0000AA7C ; COMDAT (pick any)
.text$mn:0000AA7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA7C
.text$mn:0000AA7C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA7C
.text$mn:0000AA7C ; Attributes: bp-based frame
.text$mn:0000AA7C
.text$mn:0000AA7C ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Unused_capacity(void)const
.text$mn:0000AA7C                 public ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000AA7C ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000AA7C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+Bp
.text$mn:0000AA7C
.text$mn:0000AA7C var_4           = dword ptr -4
.text$mn:0000AA7C
.text$mn:0000AA7C                 push    ebp
.text$mn:0000AA7D                 mov     ebp, esp
.text$mn:0000AA7F                 push    ecx
.text$mn:0000AA80                 mov     [ebp+var_4], ecx
.text$mn:0000AA83                 mov     eax, [ebp+var_4]
.text$mn:0000AA86                 mov     ecx, [ebp+var_4]
.text$mn:0000AA89                 mov     eax, [eax+0Ch]
.text$mn:0000AA8C                 sub     eax, [ecx+8]
.text$mn:0000AA8F                 cdq
.text$mn:0000AA90                 mov     ecx, 3Ch ; '<'
.text$mn:0000AA95                 idiv    ecx
.text$mn:0000AA97                 mov     esp, ebp
.text$mn:0000AA99                 pop     ebp
.text$mn:0000AA9A                 retn
.text$mn:0000AA9A ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000AA9A
.text$mn:0000AA9A ; ---------------------------------------------------------------------------
.text$mn:0000AA9B                 align 4
.text$mn:0000AA9B _text$mn        ends
.text$mn:0000AA9B
.text$mn:0000AA9C ; ===========================================================================
.text$mn:0000AA9C
.text$mn:0000AA9C ; Segment type: Pure code
.text$mn:0000AA9C ; Segment permissions: Read/Execute
.text$mn:0000AA9C _text$mn        segment para public 'CODE' use32
.text$mn:0000AA9C                 assume cs:_text$mn
.text$mn:0000AA9C                 ;org 0AA9Ch
.text$mn:0000AA9C ; COMDAT (pick any)
.text$mn:0000AA9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AA9C
.text$mn:0000AA9C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA9C
.text$mn:0000AA9C ; Attributes: bp-based frame
.text$mn:0000AA9C
.text$mn:0000AA9C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000AA9C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000AA9C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000AA9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000AA9C
.text$mn:0000AA9C var_4           = dword ptr -4
.text$mn:0000AA9C
.text$mn:0000AA9C                 push    ebp
.text$mn:0000AA9D                 mov     ebp, esp
.text$mn:0000AA9F                 push    ecx
.text$mn:0000AAA0                 mov     [ebp+var_4], ecx
.text$mn:0000AAA3                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000AAA8                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000AAAD                 mov     esp, ebp
.text$mn:0000AAAF                 pop     ebp
.text$mn:0000AAB0                 retn
.text$mn:0000AAB0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000AAB0
.text$mn:0000AAB0 ; ---------------------------------------------------------------------------
.text$mn:0000AAB1                 align 4
.text$mn:0000AAB1 _text$mn        ends
.text$mn:0000AAB1
.text$mn:0000AAB4 ; ===========================================================================
.text$mn:0000AAB4
.text$mn:0000AAB4 ; Segment type: Pure code
.text$mn:0000AAB4 ; Segment permissions: Read/Execute
.text$mn:0000AAB4 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAB4                 assume cs:_text$mn
.text$mn:0000AAB4                 ;org 0AAB4h
.text$mn:0000AAB4 ; COMDAT (pick any)
.text$mn:0000AAB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AAB4
.text$mn:0000AAB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAB4
.text$mn:0000AAB4 ; Attributes: bp-based frame
.text$mn:0000AAB4
.text$mn:0000AAB4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000AAB4                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000AAB4 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000AAB4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:0000AAB4
.text$mn:0000AAB4 var_4           = dword ptr -4
.text$mn:0000AAB4
.text$mn:0000AAB4                 push    ebp
.text$mn:0000AAB5                 mov     ebp, esp
.text$mn:0000AAB7                 push    ecx
.text$mn:0000AAB8                 mov     [ebp+var_4], ecx
.text$mn:0000AABB                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000AAC0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000AAC5                 mov     esp, ebp
.text$mn:0000AAC7                 pop     ebp
.text$mn:0000AAC8                 retn
.text$mn:0000AAC8 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000AAC8
.text$mn:0000AAC8 ; ---------------------------------------------------------------------------
.text$mn:0000AAC9                 align 4
.text$mn:0000AAC9 _text$mn        ends
.text$mn:0000AAC9
.text$mn:0000AACC ; ===========================================================================
.text$mn:0000AACC
.text$mn:0000AACC ; Segment type: Pure code
.text$mn:0000AACC ; Segment permissions: Read/Execute
.text$mn:0000AACC _text$mn        segment para public 'CODE' use32
.text$mn:0000AACC                 assume cs:_text$mn
.text$mn:0000AACC                 ;org 0AACCh
.text$mn:0000AACC ; COMDAT (pick any)
.text$mn:0000AACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AACC
.text$mn:0000AACC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AACC
.text$mn:0000AACC ; Attributes: bp-based frame
.text$mn:0000AACC
.text$mn:0000AACC ; protected: void __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::_Xlen(void)const
.text$mn:0000AACC                 public ?_Xlen@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IBEXXZ
.text$mn:0000AACC ?_Xlen@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IBEXXZ proc near
.text$mn:0000AACC                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+43p
.text$mn:0000AACC
.text$mn:0000AACC var_4           = dword ptr -4
.text$mn:0000AACC
.text$mn:0000AACC                 push    ebp
.text$mn:0000AACD                 mov     ebp, esp
.text$mn:0000AACF                 push    ecx
.text$mn:0000AAD0                 mov     [ebp+var_4], ecx
.text$mn:0000AAD3                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000AAD8                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000AADD                 mov     esp, ebp
.text$mn:0000AADF                 pop     ebp
.text$mn:0000AAE0                 retn
.text$mn:0000AAE0 ?_Xlen@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IBEXXZ endp
.text$mn:0000AAE0
.text$mn:0000AAE0 ; ---------------------------------------------------------------------------
.text$mn:0000AAE1                 align 4
.text$mn:0000AAE1 _text$mn        ends
.text$mn:0000AAE1
.text$mn:0000AAE4 ; ===========================================================================
.text$mn:0000AAE4
.text$mn:0000AAE4 ; Segment type: Pure code
.text$mn:0000AAE4 ; Segment permissions: Read/Execute
.text$mn:0000AAE4 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAE4                 assume cs:_text$mn
.text$mn:0000AAE4                 ;org 0AAE4h
.text$mn:0000AAE4 ; COMDAT (pick any)
.text$mn:0000AAE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AAE4
.text$mn:0000AAE4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAE4
.text$mn:0000AAE4 ; Attributes: bp-based frame
.text$mn:0000AAE4
.text$mn:0000AAE4 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Xlen(void)const
.text$mn:0000AAE4                 public ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ
.text$mn:0000AAE4 ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ proc near
.text$mn:0000AAE4                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+31p
.text$mn:0000AAE4
.text$mn:0000AAE4 var_4           = dword ptr -4
.text$mn:0000AAE4
.text$mn:0000AAE4                 push    ebp
.text$mn:0000AAE5                 mov     ebp, esp
.text$mn:0000AAE7                 push    ecx
.text$mn:0000AAE8                 mov     [ebp+var_4], ecx
.text$mn:0000AAEB                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000AAF0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000AAF5                 mov     esp, ebp
.text$mn:0000AAF7                 pop     ebp
.text$mn:0000AAF8                 retn
.text$mn:0000AAF8 ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ endp
.text$mn:0000AAF8
.text$mn:0000AAF8 ; ---------------------------------------------------------------------------
.text$mn:0000AAF9                 align 4
.text$mn:0000AAF9 _text$mn        ends
.text$mn:0000AAF9
.text$mn:0000AAFC ; ===========================================================================
.text$mn:0000AAFC
.text$mn:0000AAFC ; Segment type: Pure code
.text$mn:0000AAFC ; Segment permissions: Read/Execute
.text$mn:0000AAFC _text$mn        segment para public 'CODE' use32
.text$mn:0000AAFC                 assume cs:_text$mn
.text$mn:0000AAFC                 ;org 0AAFCh
.text$mn:0000AAFC ; COMDAT (pick any)
.text$mn:0000AAFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AAFC
.text$mn:0000AAFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAFC
.text$mn:0000AAFC ; Attributes: bp-based frame
.text$mn:0000AAFC
.text$mn:0000AAFC ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Xlen(void)const
.text$mn:0000AAFC                 public ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ
.text$mn:0000AAFC ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ proc near
.text$mn:0000AAFC                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+43p
.text$mn:0000AAFC
.text$mn:0000AAFC var_4           = dword ptr -4
.text$mn:0000AAFC
.text$mn:0000AAFC                 push    ebp
.text$mn:0000AAFD                 mov     ebp, esp
.text$mn:0000AAFF                 push    ecx
.text$mn:0000AB00                 mov     [ebp+var_4], ecx
.text$mn:0000AB03                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000AB08                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000AB0D                 mov     esp, ebp
.text$mn:0000AB0F                 pop     ebp
.text$mn:0000AB10                 retn
.text$mn:0000AB10 ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ endp
.text$mn:0000AB10
.text$mn:0000AB10 ; ---------------------------------------------------------------------------
.text$mn:0000AB11                 align 4
.text$mn:0000AB11 _text$mn        ends
.text$mn:0000AB11
.text$mn:0000AB14 ; ===========================================================================
.text$mn:0000AB14
.text$mn:0000AB14 ; Segment type: Pure code
.text$mn:0000AB14 ; Segment permissions: Read/Execute
.text$mn:0000AB14 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB14                 assume cs:_text$mn
.text$mn:0000AB14                 ;org 0AB14h
.text$mn:0000AB14 ; COMDAT (pick any)
.text$mn:0000AB14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AB14
.text$mn:0000AB14 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB14
.text$mn:0000AB14 ; Attributes: bp-based frame
.text$mn:0000AB14
.text$mn:0000AB14 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:0000AB14                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000AB14 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000AB14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:0000AB14                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:0000AB14
.text$mn:0000AB14 var_4           = dword ptr -4
.text$mn:0000AB14
.text$mn:0000AB14                 push    ebp
.text$mn:0000AB15                 mov     ebp, esp
.text$mn:0000AB17                 push    ecx
.text$mn:0000AB18                 mov     [ebp+var_4], ecx
.text$mn:0000AB1B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000AB20                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000AB25                 mov     esp, ebp
.text$mn:0000AB27                 pop     ebp
.text$mn:0000AB28                 retn
.text$mn:0000AB28 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000AB28
.text$mn:0000AB28 ; ---------------------------------------------------------------------------
.text$mn:0000AB29                 align 4
.text$mn:0000AB29 _text$mn        ends
.text$mn:0000AB29
.text$mn:0000AB2C ; ===========================================================================
.text$mn:0000AB2C
.text$mn:0000AB2C ; Segment type: Pure code
.text$mn:0000AB2C ; Segment permissions: Read/Execute
.text$mn:0000AB2C _text$mn        segment para public 'CODE' use32
.text$mn:0000AB2C                 assume cs:_text$mn
.text$mn:0000AB2C                 ;org 0AB2Ch
.text$mn:0000AB2C ; COMDAT (pick any)
.text$mn:0000AB2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AB2C
.text$mn:0000AB2C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB2C
.text$mn:0000AB2C ; Attributes: bp-based frame
.text$mn:0000AB2C
.text$mn:0000AB2C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:0000AB2C                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000AB2C ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000AB2C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:0000AB2C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+15p ...
.text$mn:0000AB2C
.text$mn:0000AB2C var_4           = dword ptr -4
.text$mn:0000AB2C
.text$mn:0000AB2C                 push    ebp
.text$mn:0000AB2D                 mov     ebp, esp
.text$mn:0000AB2F                 push    ecx
.text$mn:0000AB30                 mov     [ebp+var_4], ecx
.text$mn:0000AB33                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000AB38                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000AB3D                 mov     esp, ebp
.text$mn:0000AB3F                 pop     ebp
.text$mn:0000AB40                 retn
.text$mn:0000AB40 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000AB40
.text$mn:0000AB40 ; ---------------------------------------------------------------------------
.text$mn:0000AB41                 align 4
.text$mn:0000AB41 _text$mn        ends
.text$mn:0000AB41
.text$mn:0000AB44 ; ===========================================================================
.text$mn:0000AB44
.text$mn:0000AB44 ; Segment type: Pure code
.text$mn:0000AB44 ; Segment permissions: Read/Execute
.text$mn:0000AB44 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB44                 assume cs:_text$mn
.text$mn:0000AB44                 ;org 0AB44h
.text$mn:0000AB44 ; COMDAT (pick any)
.text$mn:0000AB44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AB44
.text$mn:0000AB44 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB44
.text$mn:0000AB44 ; Attributes: bp-based frame
.text$mn:0000AB44
.text$mn:0000AB44 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000AB44                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000AB44 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000AB44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000AB44                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000AB44
.text$mn:0000AB44 var_4           = dword ptr -4
.text$mn:0000AB44 arg_0           = dword ptr  8
.text$mn:0000AB44
.text$mn:0000AB44                 push    ebp
.text$mn:0000AB45                 mov     ebp, esp
.text$mn:0000AB47                 push    ecx
.text$mn:0000AB48                 mov     [ebp+var_4], ecx
.text$mn:0000AB4B                 mov     eax, [ebp+arg_0]
.text$mn:0000AB4E                 push    eax
.text$mn:0000AB4F                 mov     ecx, [ebp+var_4]
.text$mn:0000AB52                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000AB57                 mov     esp, ebp
.text$mn:0000AB59                 pop     ebp
.text$mn:0000AB5A                 retn    4
.text$mn:0000AB5A ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000AB5A
.text$mn:0000AB5A ; ---------------------------------------------------------------------------
.text$mn:0000AB5D                 align 10h
.text$mn:0000AB5D _text$mn        ends
.text$mn:0000AB5D
.text$mn:0000AB60 ; ===========================================================================
.text$mn:0000AB60
.text$mn:0000AB60 ; Segment type: Pure code
.text$mn:0000AB60 ; Segment permissions: Read/Execute
.text$mn:0000AB60 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB60                 assume cs:_text$mn
.text$mn:0000AB60                 ;org 0AB60h
.text$mn:0000AB60 ; COMDAT (pick any)
.text$mn:0000AB60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AB60
.text$mn:0000AB60 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB60
.text$mn:0000AB60 ; Attributes: bp-based frame
.text$mn:0000AB60
.text$mn:0000AB60 ; public: struct KeyCombo * __thiscall std::_Wrap_alloc<class std::allocator<struct KeyCombo>>::allocate(unsigned int)
.text$mn:0000AB60                 public ?allocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEPAUKeyCombo@@I@Z
.text$mn:0000AB60 ?allocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEPAUKeyCombo@@I@Z proc near
.text$mn:0000AB60                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+5Cp
.text$mn:0000AB60
.text$mn:0000AB60 var_4           = dword ptr -4
.text$mn:0000AB60 arg_0           = dword ptr  8
.text$mn:0000AB60
.text$mn:0000AB60                 push    ebp
.text$mn:0000AB61                 mov     ebp, esp
.text$mn:0000AB63                 push    ecx
.text$mn:0000AB64                 mov     [ebp+var_4], ecx
.text$mn:0000AB67                 mov     eax, [ebp+arg_0]
.text$mn:0000AB6A                 push    eax
.text$mn:0000AB6B                 mov     ecx, [ebp+var_4]
.text$mn:0000AB6E                 call    ?allocate@?$allocator@UKeyCombo@@@std@@QAEPAUKeyCombo@@I@Z ; std::allocator<KeyCombo>::allocate(uint)
.text$mn:0000AB73                 mov     esp, ebp
.text$mn:0000AB75                 pop     ebp
.text$mn:0000AB76                 retn    4
.text$mn:0000AB76 ?allocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEPAUKeyCombo@@I@Z endp
.text$mn:0000AB76
.text$mn:0000AB76 ; ---------------------------------------------------------------------------
.text$mn:0000AB79                 align 4
.text$mn:0000AB79 _text$mn        ends
.text$mn:0000AB79
.text$mn:0000AB7C ; ===========================================================================
.text$mn:0000AB7C
.text$mn:0000AB7C ; Segment type: Pure code
.text$mn:0000AB7C ; Segment permissions: Read/Execute
.text$mn:0000AB7C _text$mn        segment para public 'CODE' use32
.text$mn:0000AB7C                 assume cs:_text$mn
.text$mn:0000AB7C                 ;org 0AB7Ch
.text$mn:0000AB7C ; COMDAT (pick any)
.text$mn:0000AB7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AB7C
.text$mn:0000AB7C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB7C
.text$mn:0000AB7C ; Attributes: bp-based frame
.text$mn:0000AB7C
.text$mn:0000AB7C ; public: struct MenuItemUnit * __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::allocate(unsigned int)
.text$mn:0000AB7C                 public ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z
.text$mn:0000AB7C ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z proc near
.text$mn:0000AB7C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+41p
.text$mn:0000AB7C
.text$mn:0000AB7C var_4           = dword ptr -4
.text$mn:0000AB7C arg_0           = dword ptr  8
.text$mn:0000AB7C
.text$mn:0000AB7C                 push    ebp
.text$mn:0000AB7D                 mov     ebp, esp
.text$mn:0000AB7F                 push    ecx
.text$mn:0000AB80                 mov     [ebp+var_4], ecx
.text$mn:0000AB83                 mov     eax, [ebp+arg_0]
.text$mn:0000AB86                 push    eax
.text$mn:0000AB87                 mov     ecx, [ebp+var_4]
.text$mn:0000AB8A                 call    ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z ; std::allocator<MenuItemUnit>::allocate(uint)
.text$mn:0000AB8F                 mov     esp, ebp
.text$mn:0000AB91                 pop     ebp
.text$mn:0000AB92                 retn    4
.text$mn:0000AB92 ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z endp
.text$mn:0000AB92
.text$mn:0000AB92 ; ---------------------------------------------------------------------------
.text$mn:0000AB95                 align 4
.text$mn:0000AB95 _text$mn        ends
.text$mn:0000AB95
.text$mn:0000AB98 ; ===========================================================================
.text$mn:0000AB98
.text$mn:0000AB98 ; Segment type: Pure code
.text$mn:0000AB98 ; Segment permissions: Read/Execute
.text$mn:0000AB98 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB98                 assume cs:_text$mn
.text$mn:0000AB98                 ;org 0AB98h
.text$mn:0000AB98 ; COMDAT (pick any)
.text$mn:0000AB98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AB98
.text$mn:0000AB98 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB98
.text$mn:0000AB98 ; Attributes: bp-based frame
.text$mn:0000AB98
.text$mn:0000AB98 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:0000AB98                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000AB98 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000AB98                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Alloc_proxy(void)+16p
.text$mn:0000AB98                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000AB98
.text$mn:0000AB98 var_4           = dword ptr -4
.text$mn:0000AB98 arg_0           = dword ptr  8
.text$mn:0000AB98
.text$mn:0000AB98                 push    ebp
.text$mn:0000AB99                 mov     ebp, esp
.text$mn:0000AB9B                 push    ecx
.text$mn:0000AB9C                 mov     [ebp+var_4], ecx
.text$mn:0000AB9F                 mov     eax, [ebp+arg_0]
.text$mn:0000ABA2                 push    eax
.text$mn:0000ABA3                 mov     ecx, [ebp+var_4]
.text$mn:0000ABA6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000ABAB                 mov     esp, ebp
.text$mn:0000ABAD                 pop     ebp
.text$mn:0000ABAE                 retn    4
.text$mn:0000ABAE ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000ABAE
.text$mn:0000ABAE ; ---------------------------------------------------------------------------
.text$mn:0000ABB1                 align 4
.text$mn:0000ABB1 _text$mn        ends
.text$mn:0000ABB1
.text$mn:0000ABB4 ; ===========================================================================
.text$mn:0000ABB4
.text$mn:0000ABB4 ; Segment type: Pure code
.text$mn:0000ABB4 ; Segment permissions: Read/Execute
.text$mn:0000ABB4 _text$mn        segment para public 'CODE' use32
.text$mn:0000ABB4                 assume cs:_text$mn
.text$mn:0000ABB4                 ;org 0ABB4h
.text$mn:0000ABB4 ; COMDAT (pick any)
.text$mn:0000ABB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ABB4
.text$mn:0000ABB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ABB4
.text$mn:0000ABB4 ; Attributes: bp-based frame
.text$mn:0000ABB4
.text$mn:0000ABB4 ; public: struct recordedMacroStep * __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::allocate(unsigned int)
.text$mn:0000ABB4                 public ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z
.text$mn:0000ABB4 ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z proc near
.text$mn:0000ABB4                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+5Cp
.text$mn:0000ABB4
.text$mn:0000ABB4 var_4           = dword ptr -4
.text$mn:0000ABB4 arg_0           = dword ptr  8
.text$mn:0000ABB4
.text$mn:0000ABB4                 push    ebp
.text$mn:0000ABB5                 mov     ebp, esp
.text$mn:0000ABB7                 push    ecx
.text$mn:0000ABB8                 mov     [ebp+var_4], ecx
.text$mn:0000ABBB                 mov     eax, [ebp+arg_0]
.text$mn:0000ABBE                 push    eax
.text$mn:0000ABBF                 mov     ecx, [ebp+var_4]
.text$mn:0000ABC2                 call    ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z ; std::allocator<recordedMacroStep>::allocate(uint)
.text$mn:0000ABC7                 mov     esp, ebp
.text$mn:0000ABC9                 pop     ebp
.text$mn:0000ABCA                 retn    4
.text$mn:0000ABCA ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z endp
.text$mn:0000ABCA
.text$mn:0000ABCA ; ---------------------------------------------------------------------------
.text$mn:0000ABCD                 align 10h
.text$mn:0000ABCD _text$mn        ends
.text$mn:0000ABCD
.text$mn:0000ABD0 ; ===========================================================================
.text$mn:0000ABD0
.text$mn:0000ABD0 ; Segment type: Pure code
.text$mn:0000ABD0 ; Segment permissions: Read/Execute
.text$mn:0000ABD0 _text$mn        segment para public 'CODE' use32
.text$mn:0000ABD0                 assume cs:_text$mn
.text$mn:0000ABD0                 ;org 0ABD0h
.text$mn:0000ABD0 ; COMDAT (pick any)
.text$mn:0000ABD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ABD0
.text$mn:0000ABD0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ABD0
.text$mn:0000ABD0 ; Attributes: bp-based frame
.text$mn:0000ABD0
.text$mn:0000ABD0 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:0000ABD0                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:0000ABD0 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:0000ABD0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:0000ABD0                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:0000ABD0
.text$mn:0000ABD0 var_4           = dword ptr -4
.text$mn:0000ABD0 arg_0           = dword ptr  8
.text$mn:0000ABD0
.text$mn:0000ABD0                 push    ebp
.text$mn:0000ABD1                 mov     ebp, esp
.text$mn:0000ABD3                 push    ecx
.text$mn:0000ABD4                 mov     [ebp+var_4], ecx
.text$mn:0000ABD7                 mov     eax, [ebp+arg_0]
.text$mn:0000ABDA                 push    eax
.text$mn:0000ABDB                 mov     ecx, [ebp+var_4]
.text$mn:0000ABDE                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000ABE3                 mov     esp, ebp
.text$mn:0000ABE5                 pop     ebp
.text$mn:0000ABE6                 retn    4
.text$mn:0000ABE6 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000ABE6
.text$mn:0000ABE6 ; ---------------------------------------------------------------------------
.text$mn:0000ABE9                 align 4
.text$mn:0000ABE9 _text$mn        ends
.text$mn:0000ABE9
.text$mn:0000ABEC ; ===========================================================================
.text$mn:0000ABEC
.text$mn:0000ABEC ; Segment type: Pure code
.text$mn:0000ABEC ; Segment permissions: Read/Execute
.text$mn:0000ABEC _text$mn        segment para public 'CODE' use32
.text$mn:0000ABEC                 assume cs:_text$mn
.text$mn:0000ABEC                 ;org 0ABECh
.text$mn:0000ABEC ; COMDAT (pick any)
.text$mn:0000ABEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000ABEC
.text$mn:0000ABEC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ABEC
.text$mn:0000ABEC ; Attributes: bp-based frame
.text$mn:0000ABEC
.text$mn:0000ABEC ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000ABEC                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000ABEC ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000ABEC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000ABEC
.text$mn:0000ABEC var_4           = dword ptr -4
.text$mn:0000ABEC arg_0           = dword ptr  8
.text$mn:0000ABEC
.text$mn:0000ABEC                 push    ebp
.text$mn:0000ABED                 mov     ebp, esp
.text$mn:0000ABEF                 push    ecx
.text$mn:0000ABF0                 mov     [ebp+var_4], ecx
.text$mn:0000ABF3                 push    0
.text$mn:0000ABF5                 mov     eax, [ebp+arg_0]
.text$mn:0000ABF8                 push    eax
.text$mn:0000ABF9                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000ABFE                 add     esp, 8
.text$mn:0000AC01                 mov     esp, ebp
.text$mn:0000AC03                 pop     ebp
.text$mn:0000AC04                 retn    4
.text$mn:0000AC04 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000AC04
.text$mn:0000AC04 ; ---------------------------------------------------------------------------
.text$mn:0000AC07                 align 4
.text$mn:0000AC07 _text$mn        ends
.text$mn:0000AC07
.text$mn:0000AC08 ; ===========================================================================
.text$mn:0000AC08
.text$mn:0000AC08 ; Segment type: Pure code
.text$mn:0000AC08 ; Segment permissions: Read/Execute
.text$mn:0000AC08 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC08                 assume cs:_text$mn
.text$mn:0000AC08                 ;org 0AC08h
.text$mn:0000AC08 ; COMDAT (pick any)
.text$mn:0000AC08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC08
.text$mn:0000AC08 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC08
.text$mn:0000AC08 ; Attributes: bp-based frame
.text$mn:0000AC08
.text$mn:0000AC08 ; public: struct KeyCombo * __thiscall std::allocator<struct KeyCombo>::allocate(unsigned int)
.text$mn:0000AC08                 public ?allocate@?$allocator@UKeyCombo@@@std@@QAEPAUKeyCombo@@I@Z
.text$mn:0000AC08 ?allocate@?$allocator@UKeyCombo@@@std@@QAEPAUKeyCombo@@I@Z proc near
.text$mn:0000AC08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::allocate(uint)+Ep
.text$mn:0000AC08
.text$mn:0000AC08 var_4           = dword ptr -4
.text$mn:0000AC08 arg_0           = dword ptr  8
.text$mn:0000AC08
.text$mn:0000AC08                 push    ebp
.text$mn:0000AC09                 mov     ebp, esp
.text$mn:0000AC0B                 push    ecx
.text$mn:0000AC0C                 mov     [ebp+var_4], ecx
.text$mn:0000AC0F                 push    0
.text$mn:0000AC11                 mov     eax, [ebp+arg_0]
.text$mn:0000AC14                 push    eax
.text$mn:0000AC15                 call    ??$_Allocate@UKeyCombo@@@std@@YAPAUKeyCombo@@IPAU1@@Z ; std::_Allocate<KeyCombo>(uint,KeyCombo *)
.text$mn:0000AC1A                 add     esp, 8
.text$mn:0000AC1D                 mov     esp, ebp
.text$mn:0000AC1F                 pop     ebp
.text$mn:0000AC20                 retn    4
.text$mn:0000AC20 ?allocate@?$allocator@UKeyCombo@@@std@@QAEPAUKeyCombo@@I@Z endp
.text$mn:0000AC20
.text$mn:0000AC20 ; ---------------------------------------------------------------------------
.text$mn:0000AC23                 align 4
.text$mn:0000AC23 _text$mn        ends
.text$mn:0000AC23
.text$mn:0000AC24 ; ===========================================================================
.text$mn:0000AC24
.text$mn:0000AC24 ; Segment type: Pure code
.text$mn:0000AC24 ; Segment permissions: Read/Execute
.text$mn:0000AC24 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC24                 assume cs:_text$mn
.text$mn:0000AC24                 ;org 0AC24h
.text$mn:0000AC24 ; COMDAT (pick any)
.text$mn:0000AC24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC24
.text$mn:0000AC24 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC24
.text$mn:0000AC24 ; Attributes: bp-based frame
.text$mn:0000AC24
.text$mn:0000AC24 ; public: struct MenuItemUnit * __thiscall std::allocator<struct MenuItemUnit>::allocate(unsigned int)
.text$mn:0000AC24                 public ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z
.text$mn:0000AC24 ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z proc near
.text$mn:0000AC24                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::allocate(uint)+Ep
.text$mn:0000AC24
.text$mn:0000AC24 var_4           = dword ptr -4
.text$mn:0000AC24 arg_0           = dword ptr  8
.text$mn:0000AC24
.text$mn:0000AC24                 push    ebp
.text$mn:0000AC25                 mov     ebp, esp
.text$mn:0000AC27                 push    ecx
.text$mn:0000AC28                 mov     [ebp+var_4], ecx
.text$mn:0000AC2B                 push    0
.text$mn:0000AC2D                 mov     eax, [ebp+arg_0]
.text$mn:0000AC30                 push    eax
.text$mn:0000AC31                 call    ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z ; std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)
.text$mn:0000AC36                 add     esp, 8
.text$mn:0000AC39                 mov     esp, ebp
.text$mn:0000AC3B                 pop     ebp
.text$mn:0000AC3C                 retn    4
.text$mn:0000AC3C ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z endp
.text$mn:0000AC3C
.text$mn:0000AC3C ; ---------------------------------------------------------------------------
.text$mn:0000AC3F                 align 10h
.text$mn:0000AC3F _text$mn        ends
.text$mn:0000AC3F
.text$mn:0000AC40 ; ===========================================================================
.text$mn:0000AC40
.text$mn:0000AC40 ; Segment type: Pure code
.text$mn:0000AC40 ; Segment permissions: Read/Execute
.text$mn:0000AC40 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC40                 assume cs:_text$mn
.text$mn:0000AC40                 ;org 0AC40h
.text$mn:0000AC40 ; COMDAT (pick any)
.text$mn:0000AC40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC40
.text$mn:0000AC40 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC40
.text$mn:0000AC40 ; Attributes: bp-based frame
.text$mn:0000AC40
.text$mn:0000AC40 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000AC40                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000AC40 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000AC40                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000AC40                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000AC40
.text$mn:0000AC40 var_4           = dword ptr -4
.text$mn:0000AC40 arg_0           = dword ptr  8
.text$mn:0000AC40
.text$mn:0000AC40                 push    ebp
.text$mn:0000AC41                 mov     ebp, esp
.text$mn:0000AC43                 push    ecx
.text$mn:0000AC44                 mov     [ebp+var_4], ecx
.text$mn:0000AC47                 push    0
.text$mn:0000AC49                 mov     eax, [ebp+arg_0]
.text$mn:0000AC4C                 push    eax
.text$mn:0000AC4D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000AC52                 add     esp, 8
.text$mn:0000AC55                 mov     esp, ebp
.text$mn:0000AC57                 pop     ebp
.text$mn:0000AC58                 retn    4
.text$mn:0000AC58 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000AC58
.text$mn:0000AC58 ; ---------------------------------------------------------------------------
.text$mn:0000AC5B                 align 4
.text$mn:0000AC5B _text$mn        ends
.text$mn:0000AC5B
.text$mn:0000AC5C ; ===========================================================================
.text$mn:0000AC5C
.text$mn:0000AC5C ; Segment type: Pure code
.text$mn:0000AC5C ; Segment permissions: Read/Execute
.text$mn:0000AC5C _text$mn        segment para public 'CODE' use32
.text$mn:0000AC5C                 assume cs:_text$mn
.text$mn:0000AC5C                 ;org 0AC5Ch
.text$mn:0000AC5C ; COMDAT (pick any)
.text$mn:0000AC5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC5C
.text$mn:0000AC5C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC5C
.text$mn:0000AC5C ; Attributes: bp-based frame
.text$mn:0000AC5C
.text$mn:0000AC5C ; public: struct recordedMacroStep * __thiscall std::allocator<struct recordedMacroStep>::allocate(unsigned int)
.text$mn:0000AC5C                 public ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z
.text$mn:0000AC5C ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z proc near
.text$mn:0000AC5C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::allocate(uint)+Ep
.text$mn:0000AC5C
.text$mn:0000AC5C var_4           = dword ptr -4
.text$mn:0000AC5C arg_0           = dword ptr  8
.text$mn:0000AC5C
.text$mn:0000AC5C                 push    ebp
.text$mn:0000AC5D                 mov     ebp, esp
.text$mn:0000AC5F                 push    ecx
.text$mn:0000AC60                 mov     [ebp+var_4], ecx
.text$mn:0000AC63                 push    0
.text$mn:0000AC65                 mov     eax, [ebp+arg_0]
.text$mn:0000AC68                 push    eax
.text$mn:0000AC69                 call    ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z ; std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)
.text$mn:0000AC6E                 add     esp, 8
.text$mn:0000AC71                 mov     esp, ebp
.text$mn:0000AC73                 pop     ebp
.text$mn:0000AC74                 retn    4
.text$mn:0000AC74 ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z endp
.text$mn:0000AC74
.text$mn:0000AC74 ; ---------------------------------------------------------------------------
.text$mn:0000AC77                 align 4
.text$mn:0000AC77 _text$mn        ends
.text$mn:0000AC77
.text$mn:0000AC78 ; ===========================================================================
.text$mn:0000AC78
.text$mn:0000AC78 ; Segment type: Pure code
.text$mn:0000AC78 ; Segment permissions: Read/Execute
.text$mn:0000AC78 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC78                 assume cs:_text$mn
.text$mn:0000AC78                 ;org 0AC78h
.text$mn:0000AC78 ; COMDAT (pick any)
.text$mn:0000AC78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC78
.text$mn:0000AC78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC78
.text$mn:0000AC78 ; Attributes: bp-based frame
.text$mn:0000AC78
.text$mn:0000AC78 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:0000AC78                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:0000AC78 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:0000AC78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:0000AC78
.text$mn:0000AC78 var_4           = dword ptr -4
.text$mn:0000AC78 arg_0           = dword ptr  8
.text$mn:0000AC78
.text$mn:0000AC78                 push    ebp
.text$mn:0000AC79                 mov     ebp, esp
.text$mn:0000AC7B                 push    ecx
.text$mn:0000AC7C                 mov     [ebp+var_4], ecx
.text$mn:0000AC7F                 push    0
.text$mn:0000AC81                 mov     eax, [ebp+arg_0]
.text$mn:0000AC84                 push    eax
.text$mn:0000AC85                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000AC8A                 add     esp, 8
.text$mn:0000AC8D                 mov     esp, ebp
.text$mn:0000AC8F                 pop     ebp
.text$mn:0000AC90                 retn    4
.text$mn:0000AC90 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:0000AC90
.text$mn:0000AC90 ; ---------------------------------------------------------------------------
.text$mn:0000AC93                 align 4
.text$mn:0000AC93 _text$mn        ends
.text$mn:0000AC93
.text$mn:0000AC94 ; ===========================================================================
.text$mn:0000AC94
.text$mn:0000AC94 ; Segment type: Pure code
.text$mn:0000AC94 ; Segment permissions: Read/Execute
.text$mn:0000AC94 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC94                 assume cs:_text$mn
.text$mn:0000AC94                 ;org 0AC94h
.text$mn:0000AC94 ; COMDAT (pick any)
.text$mn:0000AC94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AC94
.text$mn:0000AC94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC94
.text$mn:0000AC94 ; Attributes: bp-based frame
.text$mn:0000AC94
.text$mn:0000AC94 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000AC94                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000AC94 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000AC94                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000AC94
.text$mn:0000AC94 Size            = dword ptr -8
.text$mn:0000AC94 var_4           = dword ptr -4
.text$mn:0000AC94 arg_0           = dword ptr  8
.text$mn:0000AC94 arg_4           = dword ptr  0Ch
.text$mn:0000AC94 arg_8           = dword ptr  10h
.text$mn:0000AC94
.text$mn:0000AC94                 push    ebp
.text$mn:0000AC95                 mov     ebp, esp
.text$mn:0000AC97                 sub     esp, 8
.text$mn:0000AC9A                 mov     [ebp+var_4], ecx
.text$mn:0000AC9D                 mov     ecx, [ebp+arg_0]
.text$mn:0000ACA0                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000ACA5                 cmp     eax, [ebp+arg_4]
.text$mn:0000ACA8                 jnb     short loc_ACB2
.text$mn:0000ACAA                 mov     ecx, [ebp+var_4]
.text$mn:0000ACAD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000ACB2
.text$mn:0000ACB2 loc_ACB2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000ACB2                 mov     ecx, [ebp+arg_0]
.text$mn:0000ACB5                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000ACBA                 sub     eax, [ebp+arg_4]
.text$mn:0000ACBD                 mov     [ebp+Size], eax
.text$mn:0000ACC0                 mov     eax, [ebp+arg_8]
.text$mn:0000ACC3                 cmp     eax, [ebp+Size]
.text$mn:0000ACC6                 jnb     short loc_ACCE
.text$mn:0000ACC8                 mov     ecx, [ebp+arg_8]
.text$mn:0000ACCB                 mov     [ebp+Size], ecx
.text$mn:0000ACCE
.text$mn:0000ACCE loc_ACCE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000ACCE                 mov     edx, [ebp+var_4]
.text$mn:0000ACD1                 cmp     edx, [ebp+arg_0]
.text$mn:0000ACD4                 jnz     short loc_ACF5
.text$mn:0000ACD6                 mov     eax, [ebp+arg_4]
.text$mn:0000ACD9                 add     eax, [ebp+Size]
.text$mn:0000ACDC                 push    eax
.text$mn:0000ACDD                 mov     ecx, [ebp+var_4]
.text$mn:0000ACE0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:0000ACE5                 mov     ecx, [ebp+arg_4]
.text$mn:0000ACE8                 push    ecx
.text$mn:0000ACE9                 push    0
.text$mn:0000ACEB                 mov     ecx, [ebp+var_4]
.text$mn:0000ACEE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000ACF3                 jmp     short loc_AD37
.text$mn:0000ACF5 ; ---------------------------------------------------------------------------
.text$mn:0000ACF5
.text$mn:0000ACF5 loc_ACF5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:0000ACF5                 push    0
.text$mn:0000ACF7                 mov     edx, [ebp+Size]
.text$mn:0000ACFA                 push    edx
.text$mn:0000ACFB                 mov     ecx, [ebp+var_4]
.text$mn:0000ACFE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000AD03                 movzx   eax, al
.text$mn:0000AD06                 test    eax, eax
.text$mn:0000AD08                 jz      short loc_AD37
.text$mn:0000AD0A                 mov     ecx, [ebp+Size]
.text$mn:0000AD0D                 push    ecx             ; Size
.text$mn:0000AD0E                 mov     ecx, [ebp+arg_0]
.text$mn:0000AD11                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AD16                 add     eax, [ebp+arg_4]
.text$mn:0000AD19                 push    eax             ; Src
.text$mn:0000AD1A                 mov     ecx, [ebp+var_4]
.text$mn:0000AD1D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000AD22                 push    eax             ; Dst
.text$mn:0000AD23                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000AD28                 add     esp, 0Ch
.text$mn:0000AD2B                 mov     edx, [ebp+Size]
.text$mn:0000AD2E                 push    edx
.text$mn:0000AD2F                 mov     ecx, [ebp+var_4]
.text$mn:0000AD32                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000AD37
.text$mn:0000AD37 loc_AD37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000AD37                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000AD37                 mov     eax, [ebp+var_4]
.text$mn:0000AD3A                 mov     esp, ebp
.text$mn:0000AD3C                 pop     ebp
.text$mn:0000AD3D                 retn    0Ch
.text$mn:0000AD3D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000AD3D
.text$mn:0000AD3D _text$mn        ends
.text$mn:0000AD3D
.text$mn:0000AD40 ; ===========================================================================
.text$mn:0000AD40
.text$mn:0000AD40 ; Segment type: Pure code
.text$mn:0000AD40 ; Segment permissions: Read/Execute
.text$mn:0000AD40 _text$mn        segment para public 'CODE' use32
.text$mn:0000AD40                 assume cs:_text$mn
.text$mn:0000AD40                 ;org 0AD40h
.text$mn:0000AD40 ; COMDAT (pick any)
.text$mn:0000AD40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AD40
.text$mn:0000AD40 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD40
.text$mn:0000AD40 ; Attributes: bp-based frame
.text$mn:0000AD40
.text$mn:0000AD40 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:0000AD40                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000AD40 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000AD40                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:0000AD40
.text$mn:0000AD40 var_4           = dword ptr -4
.text$mn:0000AD40 Str             = dword ptr  8
.text$mn:0000AD40
.text$mn:0000AD40                 push    ebp
.text$mn:0000AD41                 mov     ebp, esp
.text$mn:0000AD43                 push    ecx
.text$mn:0000AD44                 mov     [ebp+var_4], ecx
.text$mn:0000AD47                 push    490h            ; unsigned int
.text$mn:0000AD4C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AD51                 mov     eax, [ebp+Str]
.text$mn:0000AD54                 push    eax             ; int
.text$mn:0000AD55                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000AD5A                 add     esp, 0Ch
.text$mn:0000AD5D                 mov     ecx, [ebp+Str]
.text$mn:0000AD60                 push    ecx             ; Str
.text$mn:0000AD61                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000AD66                 add     esp, 4
.text$mn:0000AD69                 push    eax             ; Size
.text$mn:0000AD6A                 mov     edx, [ebp+Str]
.text$mn:0000AD6D                 push    edx             ; Src
.text$mn:0000AD6E                 mov     ecx, [ebp+var_4]
.text$mn:0000AD71                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000AD76                 mov     esp, ebp
.text$mn:0000AD78                 pop     ebp
.text$mn:0000AD79                 retn    4
.text$mn:0000AD79 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000AD79
.text$mn:0000AD79 _text$mn        ends
.text$mn:0000AD79
.text$mn:0000AD7C ; ===========================================================================
.text$mn:0000AD7C
.text$mn:0000AD7C ; Segment type: Pure code
.text$mn:0000AD7C ; Segment permissions: Read/Execute
.text$mn:0000AD7C _text$mn        segment para public 'CODE' use32
.text$mn:0000AD7C                 assume cs:_text$mn
.text$mn:0000AD7C                 ;org 0AD7Ch
.text$mn:0000AD7C ; COMDAT (pick any)
.text$mn:0000AD7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AD7C
.text$mn:0000AD7C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD7C
.text$mn:0000AD7C ; Attributes: bp-based frame
.text$mn:0000AD7C
.text$mn:0000AD7C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000AD7C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000AD7C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000AD7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000AD7C
.text$mn:0000AD7C var_4           = dword ptr -4
.text$mn:0000AD7C Src             = dword ptr  8
.text$mn:0000AD7C Size            = dword ptr  0Ch
.text$mn:0000AD7C
.text$mn:0000AD7C                 push    ebp
.text$mn:0000AD7D                 mov     ebp, esp
.text$mn:0000AD7F                 push    ecx
.text$mn:0000AD80                 mov     [ebp+var_4], ecx
.text$mn:0000AD83                 cmp     [ebp+Size], 0
.text$mn:0000AD87                 jz      short loc_AD9F
.text$mn:0000AD89                 push    47Fh            ; unsigned int
.text$mn:0000AD8E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AD93                 mov     eax, [ebp+Src]
.text$mn:0000AD96                 push    eax             ; int
.text$mn:0000AD97                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000AD9C                 add     esp, 0Ch
.text$mn:0000AD9F
.text$mn:0000AD9F loc_AD9F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000AD9F                 mov     ecx, [ebp+Src]
.text$mn:0000ADA2                 push    ecx
.text$mn:0000ADA3                 mov     ecx, [ebp+var_4]
.text$mn:0000ADA6                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000ADAB                 movzx   edx, al
.text$mn:0000ADAE                 test    edx, edx
.text$mn:0000ADB0                 jz      short loc_ADD2
.text$mn:0000ADB2                 mov     eax, [ebp+Size]
.text$mn:0000ADB5                 push    eax
.text$mn:0000ADB6                 mov     ecx, [ebp+var_4]
.text$mn:0000ADB9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000ADBE                 mov     ecx, [ebp+Src]
.text$mn:0000ADC1                 sub     ecx, eax
.text$mn:0000ADC3                 push    ecx
.text$mn:0000ADC4                 mov     edx, [ebp+var_4]
.text$mn:0000ADC7                 push    edx
.text$mn:0000ADC8                 mov     ecx, [ebp+var_4]
.text$mn:0000ADCB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000ADD0                 jmp     short loc_AE0F
.text$mn:0000ADD2 ; ---------------------------------------------------------------------------
.text$mn:0000ADD2
.text$mn:0000ADD2 loc_ADD2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000ADD2                 push    0
.text$mn:0000ADD4                 mov     eax, [ebp+Size]
.text$mn:0000ADD7                 push    eax
.text$mn:0000ADD8                 mov     ecx, [ebp+var_4]
.text$mn:0000ADDB                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000ADE0                 movzx   ecx, al
.text$mn:0000ADE3                 test    ecx, ecx
.text$mn:0000ADE5                 jz      short loc_AE0C
.text$mn:0000ADE7                 mov     edx, [ebp+Size]
.text$mn:0000ADEA                 push    edx             ; Size
.text$mn:0000ADEB                 mov     eax, [ebp+Src]
.text$mn:0000ADEE                 push    eax             ; Src
.text$mn:0000ADEF                 mov     ecx, [ebp+var_4]
.text$mn:0000ADF2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000ADF7                 push    eax             ; Dst
.text$mn:0000ADF8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000ADFD                 add     esp, 0Ch
.text$mn:0000AE00                 mov     ecx, [ebp+Size]
.text$mn:0000AE03                 push    ecx
.text$mn:0000AE04                 mov     ecx, [ebp+var_4]
.text$mn:0000AE07                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000AE0C
.text$mn:0000AE0C loc_AE0C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000AE0C                 mov     eax, [ebp+var_4]
.text$mn:0000AE0F
.text$mn:0000AE0F loc_AE0F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000AE0F                 mov     esp, ebp
.text$mn:0000AE11                 pop     ebp
.text$mn:0000AE12                 retn    8
.text$mn:0000AE12 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000AE12
.text$mn:0000AE12 ; ---------------------------------------------------------------------------
.text$mn:0000AE15                 align 4
.text$mn:0000AE15 _text$mn        ends
.text$mn:0000AE15
.text$mn:0000AE18 ; ===========================================================================
.text$mn:0000AE18
.text$mn:0000AE18 ; Segment type: Pure code
.text$mn:0000AE18 ; Segment permissions: Read/Execute
.text$mn:0000AE18 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE18                 assume cs:_text$mn
.text$mn:0000AE18                 ;org 0AE18h
.text$mn:0000AE18 ; COMDAT (pick any)
.text$mn:0000AE18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AE18
.text$mn:0000AE18 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE18
.text$mn:0000AE18 ; Attributes: bp-based frame
.text$mn:0000AE18
.text$mn:0000AE18 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000AE18                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:0000AE18 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:0000AE18                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+66p
.text$mn:0000AE18
.text$mn:0000AE18 var_4           = dword ptr -4
.text$mn:0000AE18 arg_0           = dword ptr  8
.text$mn:0000AE18
.text$mn:0000AE18                 push    ebp
.text$mn:0000AE19                 mov     ebp, esp
.text$mn:0000AE1B                 push    ecx
.text$mn:0000AE1C                 mov     [ebp+var_4], ecx
.text$mn:0000AE1F                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000AE24                 push    eax
.text$mn:0000AE25                 push    0
.text$mn:0000AE27                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE2A                 push    ecx
.text$mn:0000AE2B                 mov     ecx, [ebp+var_4]
.text$mn:0000AE2E                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000AE33                 mov     esp, ebp
.text$mn:0000AE35                 pop     ebp
.text$mn:0000AE36                 retn    4
.text$mn:0000AE36 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:0000AE36
.text$mn:0000AE36 ; ---------------------------------------------------------------------------
.text$mn:0000AE39                 align 4
.text$mn:0000AE39 _text$mn        ends
.text$mn:0000AE39
.text$mn:0000AE3C ; ===========================================================================
.text$mn:0000AE3C
.text$mn:0000AE3C ; Segment type: Pure code
.text$mn:0000AE3C ; Segment permissions: Read/Execute
.text$mn:0000AE3C _text$mn        segment para public 'CODE' use32
.text$mn:0000AE3C                 assume cs:_text$mn
.text$mn:0000AE3C                 ;org 0AE3Ch
.text$mn:0000AE3C ; COMDAT (pick any)
.text$mn:0000AE3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AE3C
.text$mn:0000AE3C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE3C
.text$mn:0000AE3C ; Attributes: bp-based frame
.text$mn:0000AE3C
.text$mn:0000AE3C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000AE3C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000AE3C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000AE3C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:0000AE3C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p
.text$mn:0000AE3C
.text$mn:0000AE3C var_8           = dword ptr -8
.text$mn:0000AE3C var_4           = dword ptr -4
.text$mn:0000AE3C arg_0           = dword ptr  8
.text$mn:0000AE3C arg_4           = dword ptr  0Ch
.text$mn:0000AE3C arg_8           = dword ptr  10h
.text$mn:0000AE3C
.text$mn:0000AE3C                 push    ebp
.text$mn:0000AE3D                 mov     ebp, esp
.text$mn:0000AE3F                 sub     esp, 8
.text$mn:0000AE42                 mov     [ebp+var_4], ecx
.text$mn:0000AE45                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE48                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000AE4D                 cmp     eax, [ebp+arg_4]
.text$mn:0000AE50                 jnb     short loc_AE5A
.text$mn:0000AE52                 mov     ecx, [ebp+var_4]
.text$mn:0000AE55                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000AE5A
.text$mn:0000AE5A loc_AE5A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000AE5A                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE5D                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000AE62                 sub     eax, [ebp+arg_4]
.text$mn:0000AE65                 mov     [ebp+var_8], eax
.text$mn:0000AE68                 mov     eax, [ebp+arg_8]
.text$mn:0000AE6B                 cmp     eax, [ebp+var_8]
.text$mn:0000AE6E                 jnb     short loc_AE76
.text$mn:0000AE70                 mov     ecx, [ebp+arg_8]
.text$mn:0000AE73                 mov     [ebp+var_8], ecx
.text$mn:0000AE76
.text$mn:0000AE76 loc_AE76:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000AE76                 mov     edx, [ebp+var_4]
.text$mn:0000AE79                 cmp     edx, [ebp+arg_0]
.text$mn:0000AE7C                 jnz     short loc_AE9D
.text$mn:0000AE7E                 mov     eax, [ebp+arg_4]
.text$mn:0000AE81                 add     eax, [ebp+var_8]
.text$mn:0000AE84                 push    eax
.text$mn:0000AE85                 mov     ecx, [ebp+var_4]
.text$mn:0000AE88                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:0000AE8D                 mov     ecx, [ebp+arg_4]
.text$mn:0000AE90                 push    ecx
.text$mn:0000AE91                 push    0
.text$mn:0000AE93                 mov     ecx, [ebp+var_4]
.text$mn:0000AE96                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000AE9B                 jmp     short loc_AEE2
.text$mn:0000AE9D ; ---------------------------------------------------------------------------
.text$mn:0000AE9D
.text$mn:0000AE9D loc_AE9D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000AE9D                 push    0
.text$mn:0000AE9F                 mov     edx, [ebp+var_8]
.text$mn:0000AEA2                 push    edx
.text$mn:0000AEA3                 mov     ecx, [ebp+var_4]
.text$mn:0000AEA6                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000AEAB                 movzx   eax, al
.text$mn:0000AEAE                 test    eax, eax
.text$mn:0000AEB0                 jz      short loc_AEE2
.text$mn:0000AEB2                 mov     ecx, [ebp+var_8]
.text$mn:0000AEB5                 push    ecx             ; int
.text$mn:0000AEB6                 mov     ecx, [ebp+arg_0]
.text$mn:0000AEB9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AEBE                 mov     edx, [ebp+arg_4]
.text$mn:0000AEC1                 lea     eax, [eax+edx*2]
.text$mn:0000AEC4                 push    eax             ; Src
.text$mn:0000AEC5                 mov     ecx, [ebp+var_4]
.text$mn:0000AEC8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AECD                 push    eax             ; Dst
.text$mn:0000AECE                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000AED3                 add     esp, 0Ch
.text$mn:0000AED6                 mov     ecx, [ebp+var_8]
.text$mn:0000AED9                 push    ecx
.text$mn:0000AEDA                 mov     ecx, [ebp+var_4]
.text$mn:0000AEDD                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000AEE2
.text$mn:0000AEE2 loc_AEE2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:0000AEE2                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:0000AEE2                 mov     eax, [ebp+var_4]
.text$mn:0000AEE5                 mov     esp, ebp
.text$mn:0000AEE7                 pop     ebp
.text$mn:0000AEE8                 retn    0Ch
.text$mn:0000AEE8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000AEE8
.text$mn:0000AEE8 ; ---------------------------------------------------------------------------
.text$mn:0000AEEB                 align 4
.text$mn:0000AEEB _text$mn        ends
.text$mn:0000AEEB
.text$mn:0000AEEC ; ===========================================================================
.text$mn:0000AEEC
.text$mn:0000AEEC ; Segment type: Pure code
.text$mn:0000AEEC ; Segment permissions: Read/Execute
.text$mn:0000AEEC _text$mn        segment para public 'CODE' use32
.text$mn:0000AEEC                 assume cs:_text$mn
.text$mn:0000AEEC                 ;org 0AEECh
.text$mn:0000AEEC ; COMDAT (pick any)
.text$mn:0000AEEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AEEC
.text$mn:0000AEEC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEEC
.text$mn:0000AEEC ; Attributes: bp-based frame
.text$mn:0000AEEC
.text$mn:0000AEEC ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000AEEC                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000AEEC ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000AEEC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000AEEC
.text$mn:0000AEEC arg_0           = dword ptr  8
.text$mn:0000AEEC arg_4           = dword ptr  0Ch
.text$mn:0000AEEC
.text$mn:0000AEEC                 push    ebp
.text$mn:0000AEED                 mov     ebp, esp
.text$mn:0000AEEF                 mov     eax, [ebp+arg_0]
.text$mn:0000AEF2                 mov     ecx, [ebp+arg_4]
.text$mn:0000AEF5                 mov     dl, [ecx]
.text$mn:0000AEF7                 mov     [eax], dl
.text$mn:0000AEF9                 pop     ebp
.text$mn:0000AEFA                 retn
.text$mn:0000AEFA ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000AEFA
.text$mn:0000AEFA ; ---------------------------------------------------------------------------
.text$mn:0000AEFB                 align 4
.text$mn:0000AEFB _text$mn        ends
.text$mn:0000AEFB
.text$mn:0000AEFC ; ===========================================================================
.text$mn:0000AEFC
.text$mn:0000AEFC ; Segment type: Pure code
.text$mn:0000AEFC ; Segment permissions: Read/Execute
.text$mn:0000AEFC _text$mn        segment para public 'CODE' use32
.text$mn:0000AEFC                 assume cs:_text$mn
.text$mn:0000AEFC                 ;org 0AEFCh
.text$mn:0000AEFC ; COMDAT (pick any)
.text$mn:0000AEFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AEFC
.text$mn:0000AEFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEFC
.text$mn:0000AEFC ; Attributes: bp-based frame
.text$mn:0000AEFC
.text$mn:0000AEFC ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:0000AEFC                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:0000AEFC ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:0000AEFC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:0000AEFC
.text$mn:0000AEFC arg_0           = dword ptr  8
.text$mn:0000AEFC arg_4           = dword ptr  0Ch
.text$mn:0000AEFC
.text$mn:0000AEFC                 push    ebp
.text$mn:0000AEFD                 mov     ebp, esp
.text$mn:0000AEFF                 mov     eax, [ebp+arg_0]
.text$mn:0000AF02                 mov     ecx, [ebp+arg_4]
.text$mn:0000AF05                 mov     dx, [ecx]
.text$mn:0000AF08                 mov     [eax], dx
.text$mn:0000AF0B                 pop     ebp
.text$mn:0000AF0C                 retn
.text$mn:0000AF0C ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:0000AF0C
.text$mn:0000AF0C ; ---------------------------------------------------------------------------
.text$mn:0000AF0D                 align 10h
.text$mn:0000AF0D _text$mn        ends
.text$mn:0000AF0D
.text$mn:0000AF10 ; ===========================================================================
.text$mn:0000AF10
.text$mn:0000AF10 ; Segment type: Pure code
.text$mn:0000AF10 ; Segment permissions: Read/Execute
.text$mn:0000AF10 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF10                 assume cs:_text$mn
.text$mn:0000AF10                 ;org 0AF10h
.text$mn:0000AF10 ; COMDAT (pick any)
.text$mn:0000AF10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AF10
.text$mn:0000AF10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF10
.text$mn:0000AF10 ; Attributes: bp-based frame
.text$mn:0000AF10
.text$mn:0000AF10 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>> __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::begin(void)const
.text$mn:0000AF10                 public ?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.text$mn:0000AF10 ?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ proc near
.text$mn:0000AF10                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+A7p
.text$mn:0000AF10
.text$mn:0000AF10 var_14          = dword ptr -14h
.text$mn:0000AF10 var_10          = dword ptr -10h
.text$mn:0000AF10 var_C           = dword ptr -0Ch
.text$mn:0000AF10 var_4           = dword ptr -4
.text$mn:0000AF10 arg_0           = dword ptr  8
.text$mn:0000AF10
.text$mn:0000AF10                 push    ebp
.text$mn:0000AF11                 mov     ebp, esp
.text$mn:0000AF13                 push    0FFFFFFFFh
.text$mn:0000AF15                 push    offset __ehhandler$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.text$mn:0000AF1A                 mov     eax, large fs:0
.text$mn:0000AF20                 push    eax
.text$mn:0000AF21                 sub     esp, 8
.text$mn:0000AF24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AF29                 xor     eax, ebp
.text$mn:0000AF2B                 push    eax
.text$mn:0000AF2C                 lea     eax, [ebp+var_C]
.text$mn:0000AF2F                 mov     large fs:0, eax
.text$mn:0000AF35                 mov     [ebp+var_10], ecx
.text$mn:0000AF38                 mov     [ebp+var_14], 0
.text$mn:0000AF3F                 mov     eax, [ebp+var_10]
.text$mn:0000AF42                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000AF43                 mov     ecx, [ebp+var_10]
.text$mn:0000AF46                 mov     edx, [ecx+4]
.text$mn:0000AF49                 push    edx             ; int
.text$mn:0000AF4A                 mov     ecx, [ebp+arg_0]
.text$mn:0000AF4D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(KeyCombo *,std::_Container_base12 const *)
.text$mn:0000AF52                 mov     [ebp+var_4], 0
.text$mn:0000AF59                 mov     eax, [ebp+var_14]
.text$mn:0000AF5C                 or      eax, 1
.text$mn:0000AF5F                 mov     [ebp+var_14], eax
.text$mn:0000AF62                 mov     eax, [ebp+arg_0]
.text$mn:0000AF65                 mov     ecx, [ebp+var_C]
.text$mn:0000AF68                 mov     large fs:0, ecx
.text$mn:0000AF6F                 pop     ecx
.text$mn:0000AF70                 mov     esp, ebp
.text$mn:0000AF72                 pop     ebp
.text$mn:0000AF73                 retn    4
.text$mn:0000AF73 ?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ endp
.text$mn:0000AF73
.text$mn:0000AF73 ; ---------------------------------------------------------------------------
.text$mn:0000AF76                 align 4
.text$mn:0000AF76 _text$mn        ends
.text$mn:0000AF76
.text$x:0000AF78 ; ===========================================================================
.text$x:0000AF78
.text$x:0000AF78 ; Segment type: Pure code
.text$x:0000AF78 ; Segment permissions: Read/Execute
.text$x:0000AF78 _text$x         segment para public 'CODE' use32
.text$x:0000AF78                 assume cs:_text$x
.text$x:0000AF78                 ;org 0AF78h
.text$x:0000AF78 ; COMDAT (pick associative to section at AF10)
.text$x:0000AF78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AF78
.text$x:0000AF78 ; =============== S U B R O U T I N E =======================================
.text$x:0000AF78
.text$x:0000AF78
.text$x:0000AF78 __unwindfunclet$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000AF78                                         ; DATA XREF: .xdata$x:0000D484o
.text$x:0000AF78                 mov     eax, [ebp-14h]
.text$x:0000AF7B                 and     eax, 1
.text$x:0000AF7E                 jz      $LN4
.text$x:0000AF84                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000AF88                 mov     ecx, [ebp+8]
.text$x:0000AF8B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:0000AF90 ; ---------------------------------------------------------------------------
.text$x:0000AF90
.text$x:0000AF90 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0+6j
.text$x:0000AF90                 retn
.text$x:0000AF90 __unwindfunclet$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0 endp
.text$x:0000AF90
.text$x:0000AF91
.text$x:0000AF91 ; =============== S U B R O U T I N E =======================================
.text$x:0000AF91
.text$x:0000AF91
.text$x:0000AF91 __ehhandler$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ proc near
.text$x:0000AF91                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::begin(void)+5o
.text$x:0000AF91
.text$x:0000AF91 arg_4           = dword ptr  8
.text$x:0000AF91
.text$x:0000AF91                 mov     edx, [esp+arg_4]
.text$x:0000AF95                 lea     eax, [edx+0Ch]
.text$x:0000AF98                 mov     ecx, [edx-0Ch]
.text$x:0000AF9B                 xor     ecx, eax
.text$x:0000AF9D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AFA2                 mov     eax, offset __ehfuncinfo$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.text$x:0000AFA7                 jmp     ___CxxFrameHandler3
.text$x:0000AFA7 __ehhandler$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ endp
.text$x:0000AFA7
.text$x:0000AFA7 _text$x         ends
.text$x:0000AFA7
.text$mn:0000AFAC ; ===========================================================================
.text$mn:0000AFAC
.text$mn:0000AFAC ; Segment type: Pure code
.text$mn:0000AFAC ; Segment permissions: Read/Execute
.text$mn:0000AFAC _text$mn        segment para public 'CODE' use32
.text$mn:0000AFAC                 assume cs:_text$mn
.text$mn:0000AFAC                 ;org 0AFACh
.text$mn:0000AFAC ; COMDAT (pick any)
.text$mn:0000AFAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000AFAC
.text$mn:0000AFAC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFAC
.text$mn:0000AFAC ; Attributes: bp-based frame
.text$mn:0000AFAC
.text$mn:0000AFAC ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>> __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::begin(void)const
.text$mn:0000AFAC                 public ?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.text$mn:0000AFAC ?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ proc near
.text$mn:0000AFAC                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+A7p
.text$mn:0000AFAC
.text$mn:0000AFAC var_14          = dword ptr -14h
.text$mn:0000AFAC var_10          = dword ptr -10h
.text$mn:0000AFAC var_C           = dword ptr -0Ch
.text$mn:0000AFAC var_4           = dword ptr -4
.text$mn:0000AFAC arg_0           = dword ptr  8
.text$mn:0000AFAC
.text$mn:0000AFAC                 push    ebp
.text$mn:0000AFAD                 mov     ebp, esp
.text$mn:0000AFAF                 push    0FFFFFFFFh
.text$mn:0000AFB1                 push    offset __ehhandler$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.text$mn:0000AFB6                 mov     eax, large fs:0
.text$mn:0000AFBC                 push    eax
.text$mn:0000AFBD                 sub     esp, 8
.text$mn:0000AFC0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AFC5                 xor     eax, ebp
.text$mn:0000AFC7                 push    eax
.text$mn:0000AFC8                 lea     eax, [ebp+var_C]
.text$mn:0000AFCB                 mov     large fs:0, eax
.text$mn:0000AFD1                 mov     [ebp+var_10], ecx
.text$mn:0000AFD4                 mov     [ebp+var_14], 0
.text$mn:0000AFDB                 mov     eax, [ebp+var_10]
.text$mn:0000AFDE                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000AFDF                 mov     ecx, [ebp+var_10]
.text$mn:0000AFE2                 mov     edx, [ecx+4]
.text$mn:0000AFE5                 push    edx             ; int
.text$mn:0000AFE6                 mov     ecx, [ebp+arg_0]
.text$mn:0000AFE9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(recordedMacroStep *,std::_Container_base12 const *)
.text$mn:0000AFEE                 mov     [ebp+var_4], 0
.text$mn:0000AFF5                 mov     eax, [ebp+var_14]
.text$mn:0000AFF8                 or      eax, 1
.text$mn:0000AFFB                 mov     [ebp+var_14], eax
.text$mn:0000AFFE                 mov     eax, [ebp+arg_0]
.text$mn:0000B001                 mov     ecx, [ebp+var_C]
.text$mn:0000B004                 mov     large fs:0, ecx
.text$mn:0000B00B                 pop     ecx
.text$mn:0000B00C                 mov     esp, ebp
.text$mn:0000B00E                 pop     ebp
.text$mn:0000B00F                 retn    4
.text$mn:0000B00F ?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ endp
.text$mn:0000B00F
.text$mn:0000B00F ; ---------------------------------------------------------------------------
.text$mn:0000B012                 align 4
.text$mn:0000B012 _text$mn        ends
.text$mn:0000B012
.text$x:0000B014 ; ===========================================================================
.text$x:0000B014
.text$x:0000B014 ; Segment type: Pure code
.text$x:0000B014 ; Segment permissions: Read/Execute
.text$x:0000B014 _text$x         segment para public 'CODE' use32
.text$x:0000B014                 assume cs:_text$x
.text$x:0000B014                 ;org 0B014h
.text$x:0000B014 ; COMDAT (pick associative to section at AFAC)
.text$x:0000B014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B014
.text$x:0000B014 ; =============== S U B R O U T I N E =======================================
.text$x:0000B014
.text$x:0000B014
.text$x:0000B014 __unwindfunclet$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000B014                                         ; DATA XREF: .xdata$x:0000D874o
.text$x:0000B014                 mov     eax, [ebp-14h]
.text$x:0000B017                 and     eax, 1
.text$x:0000B01A                 jz      $LN4_1
.text$x:0000B020                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B024                 mov     ecx, [ebp+8]
.text$x:0000B027                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:0000B02C ; ---------------------------------------------------------------------------
.text$x:0000B02C
.text$x:0000B02C $LN4_1:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0+6j
.text$x:0000B02C                 retn
.text$x:0000B02C __unwindfunclet$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0 endp
.text$x:0000B02C
.text$x:0000B02D
.text$x:0000B02D ; =============== S U B R O U T I N E =======================================
.text$x:0000B02D
.text$x:0000B02D
.text$x:0000B02D __ehhandler$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ proc near
.text$x:0000B02D                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::begin(void)+5o
.text$x:0000B02D
.text$x:0000B02D arg_4           = dword ptr  8
.text$x:0000B02D
.text$x:0000B02D                 mov     edx, [esp+arg_4]
.text$x:0000B031                 lea     eax, [edx+0Ch]
.text$x:0000B034                 mov     ecx, [edx-0Ch]
.text$x:0000B037                 xor     ecx, eax
.text$x:0000B039                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B03E                 mov     eax, offset __ehfuncinfo$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.text$x:0000B043                 jmp     ___CxxFrameHandler3
.text$x:0000B043 __ehhandler$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ endp
.text$x:0000B043
.text$x:0000B043 _text$x         ends
.text$x:0000B043
.text$mn:0000B048 ; ===========================================================================
.text$mn:0000B048
.text$mn:0000B048 ; Segment type: Pure code
.text$mn:0000B048 ; Segment permissions: Read/Execute
.text$mn:0000B048 _text$mn        segment para public 'CODE' use32
.text$mn:0000B048                 assume cs:_text$mn
.text$mn:0000B048                 ;org 0B048h
.text$mn:0000B048 ; COMDAT (pick any)
.text$mn:0000B048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B048
.text$mn:0000B048 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B048
.text$mn:0000B048 ; Attributes: bp-based frame
.text$mn:0000B048
.text$mn:0000B048 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>> __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::begin(void)
.text$mn:0000B048                 public ?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ
.text$mn:0000B048 ?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ proc near
.text$mn:0000B048                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+AECp
.text$mn:0000B048
.text$mn:0000B048 var_14          = dword ptr -14h
.text$mn:0000B048 var_10          = dword ptr -10h
.text$mn:0000B048 var_C           = dword ptr -0Ch
.text$mn:0000B048 var_4           = dword ptr -4
.text$mn:0000B048 arg_0           = dword ptr  8
.text$mn:0000B048
.text$mn:0000B048                 push    ebp
.text$mn:0000B049                 mov     ebp, esp
.text$mn:0000B04B                 push    0FFFFFFFFh
.text$mn:0000B04D                 push    offset __ehhandler$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ
.text$mn:0000B052                 mov     eax, large fs:0
.text$mn:0000B058                 push    eax
.text$mn:0000B059                 sub     esp, 8
.text$mn:0000B05C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B061                 xor     eax, ebp
.text$mn:0000B063                 push    eax
.text$mn:0000B064                 lea     eax, [ebp+var_C]
.text$mn:0000B067                 mov     large fs:0, eax
.text$mn:0000B06D                 mov     [ebp+var_10], ecx
.text$mn:0000B070                 mov     [ebp+var_14], 0
.text$mn:0000B077                 mov     eax, [ebp+var_10]
.text$mn:0000B07A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B07B                 mov     ecx, [ebp+var_10]
.text$mn:0000B07E                 mov     edx, [ecx+4]
.text$mn:0000B081                 push    edx             ; int
.text$mn:0000B082                 mov     ecx, [ebp+arg_0]
.text$mn:0000B085                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(MacroShortcut *,std::_Container_base12 const *)
.text$mn:0000B08A                 mov     [ebp+var_4], 0
.text$mn:0000B091                 mov     eax, [ebp+var_14]
.text$mn:0000B094                 or      eax, 1
.text$mn:0000B097                 mov     [ebp+var_14], eax
.text$mn:0000B09A                 mov     eax, [ebp+arg_0]
.text$mn:0000B09D                 mov     ecx, [ebp+var_C]
.text$mn:0000B0A0                 mov     large fs:0, ecx
.text$mn:0000B0A7                 pop     ecx
.text$mn:0000B0A8                 mov     esp, ebp
.text$mn:0000B0AA                 pop     ebp
.text$mn:0000B0AB                 retn    4
.text$mn:0000B0AB ?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ endp
.text$mn:0000B0AB
.text$mn:0000B0AB ; ---------------------------------------------------------------------------
.text$mn:0000B0AE                 align 10h
.text$mn:0000B0AE _text$mn        ends
.text$mn:0000B0AE
.text$x:0000B0B0 ; ===========================================================================
.text$x:0000B0B0
.text$x:0000B0B0 ; Segment type: Pure code
.text$x:0000B0B0 ; Segment permissions: Read/Execute
.text$x:0000B0B0 _text$x         segment para public 'CODE' use32
.text$x:0000B0B0                 assume cs:_text$x
.text$x:0000B0B0                 ;org 0B0B0h
.text$x:0000B0B0 ; COMDAT (pick associative to section at B048)
.text$x:0000B0B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B0B0
.text$x:0000B0B0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B0B0
.text$x:0000B0B0
.text$x:0000B0B0 __unwindfunclet$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000B0B0                                         ; DATA XREF: .xdata$x:0000DBACo
.text$x:0000B0B0                 mov     eax, [ebp-14h]
.text$x:0000B0B3                 and     eax, 1
.text$x:0000B0B6                 jz      $LN4_4
.text$x:0000B0BC                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B0C0                 mov     ecx, [ebp+8]
.text$x:0000B0C3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:0000B0C8 ; ---------------------------------------------------------------------------
.text$x:0000B0C8
.text$x:0000B0C8 $LN4_4:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ$0+6j
.text$x:0000B0C8                 retn
.text$x:0000B0C8 __unwindfunclet$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ$0 endp
.text$x:0000B0C8
.text$x:0000B0C9
.text$x:0000B0C9 ; =============== S U B R O U T I N E =======================================
.text$x:0000B0C9
.text$x:0000B0C9
.text$x:0000B0C9 __ehhandler$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ proc near
.text$x:0000B0C9                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::begin(void)+5o
.text$x:0000B0C9
.text$x:0000B0C9 arg_4           = dword ptr  8
.text$x:0000B0C9
.text$x:0000B0C9                 mov     edx, [esp+arg_4]
.text$x:0000B0CD                 lea     eax, [edx+0Ch]
.text$x:0000B0D0                 mov     ecx, [edx-0Ch]
.text$x:0000B0D3                 xor     ecx, eax
.text$x:0000B0D5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B0DA                 mov     eax, offset __ehfuncinfo$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ
.text$x:0000B0DF                 jmp     ___CxxFrameHandler3
.text$x:0000B0DF __ehhandler$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ endp
.text$x:0000B0DF
.text$x:0000B0DF _text$x         ends
.text$x:0000B0DF
.text$mn:0000B0E4 ; ===========================================================================
.text$mn:0000B0E4
.text$mn:0000B0E4 ; Segment type: Pure code
.text$mn:0000B0E4 ; Segment permissions: Read/Execute
.text$mn:0000B0E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B0E4                 assume cs:_text$mn
.text$mn:0000B0E4                 ;org 0B0E4h
.text$mn:0000B0E4 ; COMDAT (pick any)
.text$mn:0000B0E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B0E4
.text$mn:0000B0E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B0E4
.text$mn:0000B0E4 ; Attributes: bp-based frame
.text$mn:0000B0E4
.text$mn:0000B0E4 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>> __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::begin(void)
.text$mn:0000B0E4                 public ?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ
.text$mn:0000B0E4 ?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ proc near
.text$mn:0000B0E4                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+CCBp
.text$mn:0000B0E4
.text$mn:0000B0E4 var_14          = dword ptr -14h
.text$mn:0000B0E4 var_10          = dword ptr -10h
.text$mn:0000B0E4 var_C           = dword ptr -0Ch
.text$mn:0000B0E4 var_4           = dword ptr -4
.text$mn:0000B0E4 arg_0           = dword ptr  8
.text$mn:0000B0E4
.text$mn:0000B0E4                 push    ebp
.text$mn:0000B0E5                 mov     ebp, esp
.text$mn:0000B0E7                 push    0FFFFFFFFh
.text$mn:0000B0E9                 push    offset __ehhandler$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ
.text$mn:0000B0EE                 mov     eax, large fs:0
.text$mn:0000B0F4                 push    eax
.text$mn:0000B0F5                 sub     esp, 8
.text$mn:0000B0F8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B0FD                 xor     eax, ebp
.text$mn:0000B0FF                 push    eax
.text$mn:0000B100                 lea     eax, [ebp+var_C]
.text$mn:0000B103                 mov     large fs:0, eax
.text$mn:0000B109                 mov     [ebp+var_10], ecx
.text$mn:0000B10C                 mov     [ebp+var_14], 0
.text$mn:0000B113                 mov     eax, [ebp+var_10]
.text$mn:0000B116                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B117                 mov     ecx, [ebp+var_10]
.text$mn:0000B11A                 mov     edx, [ecx+4]
.text$mn:0000B11D                 push    edx             ; int
.text$mn:0000B11E                 mov     ecx, [ebp+arg_0]
.text$mn:0000B121                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(UserCommand *,std::_Container_base12 const *)
.text$mn:0000B126                 mov     [ebp+var_4], 0
.text$mn:0000B12D                 mov     eax, [ebp+var_14]
.text$mn:0000B130                 or      eax, 1
.text$mn:0000B133                 mov     [ebp+var_14], eax
.text$mn:0000B136                 mov     eax, [ebp+arg_0]
.text$mn:0000B139                 mov     ecx, [ebp+var_C]
.text$mn:0000B13C                 mov     large fs:0, ecx
.text$mn:0000B143                 pop     ecx
.text$mn:0000B144                 mov     esp, ebp
.text$mn:0000B146                 pop     ebp
.text$mn:0000B147                 retn    4
.text$mn:0000B147 ?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ endp
.text$mn:0000B147
.text$mn:0000B147 ; ---------------------------------------------------------------------------
.text$mn:0000B14A                 align 4
.text$mn:0000B14A _text$mn        ends
.text$mn:0000B14A
.text$x:0000B14C ; ===========================================================================
.text$x:0000B14C
.text$x:0000B14C ; Segment type: Pure code
.text$x:0000B14C ; Segment permissions: Read/Execute
.text$x:0000B14C _text$x         segment para public 'CODE' use32
.text$x:0000B14C                 assume cs:_text$x
.text$x:0000B14C                 ;org 0B14Ch
.text$x:0000B14C ; COMDAT (pick associative to section at B0E4)
.text$x:0000B14C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B14C
.text$x:0000B14C ; =============== S U B R O U T I N E =======================================
.text$x:0000B14C
.text$x:0000B14C
.text$x:0000B14C __unwindfunclet$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000B14C                                         ; DATA XREF: .xdata$x:0000DC74o
.text$x:0000B14C                 mov     eax, [ebp-14h]
.text$x:0000B14F                 and     eax, 1
.text$x:0000B152                 jz      $LN4_5
.text$x:0000B158                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B15C                 mov     ecx, [ebp+8]
.text$x:0000B15F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:0000B164 ; ---------------------------------------------------------------------------
.text$x:0000B164
.text$x:0000B164 $LN4_5:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ$0+6j
.text$x:0000B164                 retn
.text$x:0000B164 __unwindfunclet$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ$0 endp
.text$x:0000B164
.text$x:0000B165
.text$x:0000B165 ; =============== S U B R O U T I N E =======================================
.text$x:0000B165
.text$x:0000B165
.text$x:0000B165 __ehhandler$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ proc near
.text$x:0000B165                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::begin(void)+5o
.text$x:0000B165
.text$x:0000B165 arg_4           = dword ptr  8
.text$x:0000B165
.text$x:0000B165                 mov     edx, [esp+arg_4]
.text$x:0000B169                 lea     eax, [edx+0Ch]
.text$x:0000B16C                 mov     ecx, [edx-0Ch]
.text$x:0000B16F                 xor     ecx, eax
.text$x:0000B171                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B176                 mov     eax, offset __ehfuncinfo$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ
.text$x:0000B17B                 jmp     ___CxxFrameHandler3
.text$x:0000B17B __ehhandler$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ endp
.text$x:0000B17B
.text$x:0000B17B _text$x         ends
.text$x:0000B17B
.text$mn:0000B180 ; ===========================================================================
.text$mn:0000B180
.text$mn:0000B180 ; Segment type: Pure code
.text$mn:0000B180 ; Segment permissions: Read/Execute
.text$mn:0000B180 _text$mn        segment para public 'CODE' use32
.text$mn:0000B180                 assume cs:_text$mn
.text$mn:0000B180                 ;org 0B180h
.text$mn:0000B180 ; COMDAT (pick any)
.text$mn:0000B180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B180
.text$mn:0000B180 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B180
.text$mn:0000B180 ; Attributes: bp-based frame
.text$mn:0000B180
.text$mn:0000B180 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:0000B180                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:0000B180 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:0000B180                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+34Bp
.text$mn:0000B180                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+4C3p ...
.text$mn:0000B180
.text$mn:0000B180 var_4           = dword ptr -4
.text$mn:0000B180
.text$mn:0000B180                 push    ebp
.text$mn:0000B181                 mov     ebp, esp
.text$mn:0000B183                 push    ecx
.text$mn:0000B184                 mov     [ebp+var_4], ecx
.text$mn:0000B187                 mov     ecx, [ebp+var_4]
.text$mn:0000B18A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000B18F                 mov     esp, ebp
.text$mn:0000B191                 pop     ebp
.text$mn:0000B192                 retn
.text$mn:0000B192 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:0000B192
.text$mn:0000B192 ; ---------------------------------------------------------------------------
.text$mn:0000B193                 align 4
.text$mn:0000B193 _text$mn        ends
.text$mn:0000B193
.text$mn:0000B194 ; ===========================================================================
.text$mn:0000B194
.text$mn:0000B194 ; Segment type: Pure code
.text$mn:0000B194 ; Segment permissions: Read/Execute
.text$mn:0000B194 _text$mn        segment para public 'CODE' use32
.text$mn:0000B194                 assume cs:_text$mn
.text$mn:0000B194                 ;org 0B194h
.text$mn:0000B194 ; COMDAT (pick any)
.text$mn:0000B194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B194
.text$mn:0000B194 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B194
.text$mn:0000B194 ; Attributes: bp-based frame
.text$mn:0000B194
.text$mn:0000B194 ; public: unsigned int __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::capacity(void)const
.text$mn:0000B194                 public ?capacity@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ
.text$mn:0000B194 ?capacity@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B194                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+11Bp
.text$mn:0000B194
.text$mn:0000B194 var_4           = dword ptr -4
.text$mn:0000B194
.text$mn:0000B194                 push    ebp
.text$mn:0000B195                 mov     ebp, esp
.text$mn:0000B197                 push    ecx
.text$mn:0000B198                 mov     [ebp+var_4], ecx
.text$mn:0000B19B                 mov     eax, [ebp+var_4]
.text$mn:0000B19E                 mov     ecx, [ebp+var_4]
.text$mn:0000B1A1                 mov     eax, [eax+0Ch]
.text$mn:0000B1A4                 sub     eax, [ecx+4]
.text$mn:0000B1A7                 sar     eax, 2
.text$mn:0000B1AA                 mov     esp, ebp
.text$mn:0000B1AC                 pop     ebp
.text$mn:0000B1AD                 retn
.text$mn:0000B1AD ?capacity@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ endp
.text$mn:0000B1AD
.text$mn:0000B1AD ; ---------------------------------------------------------------------------
.text$mn:0000B1AE                 align 10h
.text$mn:0000B1AE _text$mn        ends
.text$mn:0000B1AE
.text$mn:0000B1B0 ; ===========================================================================
.text$mn:0000B1B0
.text$mn:0000B1B0 ; Segment type: Pure code
.text$mn:0000B1B0 ; Segment permissions: Read/Execute
.text$mn:0000B1B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B1B0                 assume cs:_text$mn
.text$mn:0000B1B0                 ;org 0B1B0h
.text$mn:0000B1B0 ; COMDAT (pick any)
.text$mn:0000B1B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B1B0
.text$mn:0000B1B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1B0
.text$mn:0000B1B0 ; Attributes: bp-based frame
.text$mn:0000B1B0
.text$mn:0000B1B0 ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::capacity(void)const
.text$mn:0000B1B0                 public ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000B1B0 ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B1B0                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+Cp
.text$mn:0000B1B0
.text$mn:0000B1B0 var_4           = dword ptr -4
.text$mn:0000B1B0
.text$mn:0000B1B0                 push    ebp
.text$mn:0000B1B1                 mov     ebp, esp
.text$mn:0000B1B3                 push    ecx
.text$mn:0000B1B4                 mov     [ebp+var_4], ecx
.text$mn:0000B1B7                 mov     eax, [ebp+var_4]
.text$mn:0000B1BA                 mov     ecx, [ebp+var_4]
.text$mn:0000B1BD                 mov     eax, [eax+0Ch]
.text$mn:0000B1C0                 sub     eax, [ecx+4]
.text$mn:0000B1C3                 cdq
.text$mn:0000B1C4                 mov     ecx, 3Ch ; '<'
.text$mn:0000B1C9                 idiv    ecx
.text$mn:0000B1CB                 mov     esp, ebp
.text$mn:0000B1CD                 pop     ebp
.text$mn:0000B1CE                 retn
.text$mn:0000B1CE ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000B1CE
.text$mn:0000B1CE ; ---------------------------------------------------------------------------
.text$mn:0000B1CF                 align 10h
.text$mn:0000B1CF _text$mn        ends
.text$mn:0000B1CF
.text$mn:0000B1D0 ; ===========================================================================
.text$mn:0000B1D0
.text$mn:0000B1D0 ; Segment type: Pure code
.text$mn:0000B1D0 ; Segment permissions: Read/Execute
.text$mn:0000B1D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B1D0                 assume cs:_text$mn
.text$mn:0000B1D0                 ;org 0B1D0h
.text$mn:0000B1D0 ; COMDAT (pick any)
.text$mn:0000B1D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B1D0
.text$mn:0000B1D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1D0
.text$mn:0000B1D0 ; Attributes: bp-based frame
.text$mn:0000B1D0
.text$mn:0000B1D0 ; public: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::capacity(void)const
.text$mn:0000B1D0                 public ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:0000B1D0 ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B1D0                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+11Bp
.text$mn:0000B1D0
.text$mn:0000B1D0 var_4           = dword ptr -4
.text$mn:0000B1D0
.text$mn:0000B1D0                 push    ebp
.text$mn:0000B1D1                 mov     ebp, esp
.text$mn:0000B1D3                 push    ecx
.text$mn:0000B1D4                 mov     [ebp+var_4], ecx
.text$mn:0000B1D7                 mov     eax, [ebp+var_4]
.text$mn:0000B1DA                 mov     ecx, [ebp+var_4]
.text$mn:0000B1DD                 mov     eax, [eax+0Ch]
.text$mn:0000B1E0                 sub     eax, [ecx+4]
.text$mn:0000B1E3                 cdq
.text$mn:0000B1E4                 mov     ecx, 2Ch ; ','
.text$mn:0000B1E9                 idiv    ecx
.text$mn:0000B1EB                 mov     esp, ebp
.text$mn:0000B1ED                 pop     ebp
.text$mn:0000B1EE                 retn
.text$mn:0000B1EE ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:0000B1EE
.text$mn:0000B1EE ; ---------------------------------------------------------------------------
.text$mn:0000B1EF                 align 10h
.text$mn:0000B1EF _text$mn        ends
.text$mn:0000B1EF
.text$mn:0000B1F0 ; ===========================================================================
.text$mn:0000B1F0
.text$mn:0000B1F0 ; Segment type: Pure code
.text$mn:0000B1F0 ; Segment permissions: Read/Execute
.text$mn:0000B1F0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B1F0                 assume cs:_text$mn
.text$mn:0000B1F0                 ;org 0B1F0h
.text$mn:0000B1F0 ; COMDAT (pick any)
.text$mn:0000B1F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B1F0
.text$mn:0000B1F0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1F0
.text$mn:0000B1F0 ; Attributes: bp-based frame
.text$mn:0000B1F0
.text$mn:0000B1F0 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000B1F0                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000B1F0 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000B1F0                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000B1F0
.text$mn:0000B1F0 var_4           = dword ptr -4
.text$mn:0000B1F0
.text$mn:0000B1F0                 push    ebp
.text$mn:0000B1F1                 mov     ebp, esp
.text$mn:0000B1F3                 push    ecx
.text$mn:0000B1F4                 mov     [ebp+var_4], ecx
.text$mn:0000B1F7                 mov     eax, [ebp+var_4]
.text$mn:0000B1FA                 mov     eax, [eax+4]
.text$mn:0000B1FD                 mov     esp, ebp
.text$mn:0000B1FF                 pop     ebp
.text$mn:0000B200                 retn
.text$mn:0000B200 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000B200
.text$mn:0000B200 ; ---------------------------------------------------------------------------
.text$mn:0000B201                 align 4
.text$mn:0000B201 _text$mn        ends
.text$mn:0000B201
.text$mn:0000B204 ; ===========================================================================
.text$mn:0000B204
.text$mn:0000B204 ; Segment type: Pure code
.text$mn:0000B204 ; Segment permissions: Read/Execute
.text$mn:0000B204 _text$mn        segment para public 'CODE' use32
.text$mn:0000B204                 assume cs:_text$mn
.text$mn:0000B204                 ;org 0B204h
.text$mn:0000B204 ; COMDAT (pick any)
.text$mn:0000B204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B204
.text$mn:0000B204 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B204
.text$mn:0000B204 ; Attributes: bp-based frame
.text$mn:0000B204
.text$mn:0000B204 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000B204                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000B204 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000B204                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000B204                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000B204
.text$mn:0000B204 var_4           = dword ptr -4
.text$mn:0000B204
.text$mn:0000B204                 push    ebp
.text$mn:0000B205                 mov     ebp, esp
.text$mn:0000B207                 push    ecx
.text$mn:0000B208                 mov     [ebp+var_4], ecx
.text$mn:0000B20B                 mov     eax, [ebp+var_4]
.text$mn:0000B20E                 mov     eax, [eax+4]
.text$mn:0000B211                 mov     esp, ebp
.text$mn:0000B213                 pop     ebp
.text$mn:0000B214                 retn
.text$mn:0000B214 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000B214
.text$mn:0000B214 ; ---------------------------------------------------------------------------
.text$mn:0000B215                 align 4
.text$mn:0000B215 _text$mn        ends
.text$mn:0000B215
.text$mn:0000B218 ; ===========================================================================
.text$mn:0000B218
.text$mn:0000B218 ; Segment type: Pure code
.text$mn:0000B218 ; Segment permissions: Read/Execute
.text$mn:0000B218 _text$mn        segment para public 'CODE' use32
.text$mn:0000B218                 assume cs:_text$mn
.text$mn:0000B218                 ;org 0B218h
.text$mn:0000B218 ; COMDAT (pick any)
.text$mn:0000B218                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B218
.text$mn:0000B218 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B218
.text$mn:0000B218 ; Attributes: bp-based frame
.text$mn:0000B218
.text$mn:0000B218 ; public: void __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::clear(void)
.text$mn:0000B218                 public ?clear@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEXXZ
.text$mn:0000B218 ?clear@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEXXZ proc near
.text$mn:0000B218                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+9Fp
.text$mn:0000B218
.text$mn:0000B218 var_4           = dword ptr -4
.text$mn:0000B218
.text$mn:0000B218                 push    ebp
.text$mn:0000B219                 mov     ebp, esp
.text$mn:0000B21B                 push    ecx
.text$mn:0000B21C                 mov     [ebp+var_4], ecx
.text$mn:0000B21F                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000B222                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000B227                 mov     eax, [ebp+var_4]
.text$mn:0000B22A                 mov     ecx, [eax+8]
.text$mn:0000B22D                 push    ecx
.text$mn:0000B22E                 mov     edx, [ebp+var_4]
.text$mn:0000B231                 mov     eax, [edx+4]
.text$mn:0000B234                 push    eax
.text$mn:0000B235                 mov     ecx, [ebp+var_4]
.text$mn:0000B238                 call    ?_Destroy@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEXPAUKeyCombo@@0@Z ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Destroy(KeyCombo *,KeyCombo *)
.text$mn:0000B23D                 mov     ecx, [ebp+var_4]
.text$mn:0000B240                 mov     edx, [ebp+var_4]
.text$mn:0000B243                 mov     eax, [edx+4]
.text$mn:0000B246                 mov     [ecx+8], eax
.text$mn:0000B249                 mov     esp, ebp
.text$mn:0000B24B                 pop     ebp
.text$mn:0000B24C                 retn
.text$mn:0000B24C ?clear@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEXXZ endp
.text$mn:0000B24C
.text$mn:0000B24C ; ---------------------------------------------------------------------------
.text$mn:0000B24D                 align 10h
.text$mn:0000B24D _text$mn        ends
.text$mn:0000B24D
.text$mn:0000B250 ; ===========================================================================
.text$mn:0000B250
.text$mn:0000B250 ; Segment type: Pure code
.text$mn:0000B250 ; Segment permissions: Read/Execute
.text$mn:0000B250 _text$mn        segment para public 'CODE' use32
.text$mn:0000B250                 assume cs:_text$mn
.text$mn:0000B250                 ;org 0B250h
.text$mn:0000B250 ; COMDAT (pick any)
.text$mn:0000B250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B250
.text$mn:0000B250 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B250
.text$mn:0000B250 ; Attributes: bp-based frame
.text$mn:0000B250
.text$mn:0000B250 ; public: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::clear(void)
.text$mn:0000B250                 public ?clear@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXXZ
.text$mn:0000B250 ?clear@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXXZ proc near
.text$mn:0000B250                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+9Fp
.text$mn:0000B250
.text$mn:0000B250 var_4           = dword ptr -4
.text$mn:0000B250
.text$mn:0000B250                 push    ebp
.text$mn:0000B251                 mov     ebp, esp
.text$mn:0000B253                 push    ecx
.text$mn:0000B254                 mov     [ebp+var_4], ecx
.text$mn:0000B257                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000B25A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000B25F                 mov     eax, [ebp+var_4]
.text$mn:0000B262                 mov     ecx, [eax+8]
.text$mn:0000B265                 push    ecx
.text$mn:0000B266                 mov     edx, [ebp+var_4]
.text$mn:0000B269                 mov     eax, [edx+4]
.text$mn:0000B26C                 push    eax
.text$mn:0000B26D                 mov     ecx, [ebp+var_4]
.text$mn:0000B270                 call    ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)
.text$mn:0000B275                 mov     ecx, [ebp+var_4]
.text$mn:0000B278                 mov     edx, [ebp+var_4]
.text$mn:0000B27B                 mov     eax, [edx+4]
.text$mn:0000B27E                 mov     [ecx+8], eax
.text$mn:0000B281                 mov     esp, ebp
.text$mn:0000B283                 pop     ebp
.text$mn:0000B284                 retn
.text$mn:0000B284 ?clear@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXXZ endp
.text$mn:0000B284
.text$mn:0000B284 ; ---------------------------------------------------------------------------
.text$mn:0000B285                 align 4
.text$mn:0000B285 _text$mn        ends
.text$mn:0000B285
.text$mn:0000B288 ; ===========================================================================
.text$mn:0000B288
.text$mn:0000B288 ; Segment type: Pure code
.text$mn:0000B288 ; Segment permissions: Read/Execute
.text$mn:0000B288 _text$mn        segment para public 'CODE' use32
.text$mn:0000B288                 assume cs:_text$mn
.text$mn:0000B288                 ;org 0B288h
.text$mn:0000B288 ; COMDAT (pick any)
.text$mn:0000B288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B288
.text$mn:0000B288 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B288
.text$mn:0000B288 ; Attributes: bp-based frame
.text$mn:0000B288
.text$mn:0000B288 ; void __thiscall BabyGridWrapper::clear(BabyGridWrapper *__hidden this)
.text$mn:0000B288                 public ?clear@BabyGridWrapper@@QAEXXZ
.text$mn:0000B288 ?clear@BabyGridWrapper@@QAEXXZ proc near
.text$mn:0000B288                                         ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+45p
.text$mn:0000B288
.text$mn:0000B288 var_4           = dword ptr -4
.text$mn:0000B288
.text$mn:0000B288                 push    ebp
.text$mn:0000B289                 mov     ebp, esp
.text$mn:0000B28B                 push    ecx
.text$mn:0000B28C                 mov     [ebp+var_4], ecx
.text$mn:0000B28F                 push    0               ; lParam
.text$mn:0000B291                 push    0               ; wParam
.text$mn:0000B293                 push    1F5Dh           ; Msg
.text$mn:0000B298                 mov     eax, [ebp+var_4]
.text$mn:0000B29B                 mov     ecx, [eax+0Ch]
.text$mn:0000B29E                 push    ecx             ; hWnd
.text$mn:0000B29F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000B2A5                 mov     esp, ebp
.text$mn:0000B2A7                 pop     ebp
.text$mn:0000B2A8                 retn
.text$mn:0000B2A8 ?clear@BabyGridWrapper@@QAEXXZ endp
.text$mn:0000B2A8
.text$mn:0000B2A8 ; ---------------------------------------------------------------------------
.text$mn:0000B2A9                 align 4
.text$mn:0000B2A9 _text$mn        ends
.text$mn:0000B2A9
.text$mn:0000B2AC ; ===========================================================================
.text$mn:0000B2AC
.text$mn:0000B2AC ; Segment type: Pure code
.text$mn:0000B2AC ; Segment permissions: Read/Execute
.text$mn:0000B2AC _text$mn        segment para public 'CODE' use32
.text$mn:0000B2AC                 assume cs:_text$mn
.text$mn:0000B2AC                 ;org 0B2ACh
.text$mn:0000B2AC ; COMDAT (pick any)
.text$mn:0000B2AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B2AC
.text$mn:0000B2AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2AC
.text$mn:0000B2AC ; Attributes: bp-based frame
.text$mn:0000B2AC
.text$mn:0000B2AC ; int __stdcall std::allocator<KeyCombo>::construct(void *, int)
.text$mn:0000B2AC                 public ?construct@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@ABU3@@Z
.text$mn:0000B2AC ?construct@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@ABU3@@Z proc near
.text$mn:0000B2AC                                         ; CODE XREF: std::allocator_traits<std::allocator<KeyCombo>>::construct<KeyCombo,KeyCombo const &>(std::allocator<KeyCombo> &,KeyCombo *,KeyCombo const &)+17p
.text$mn:0000B2AC
.text$mn:0000B2AC var_C           = dword ptr -0Ch
.text$mn:0000B2AC var_8           = dword ptr -8
.text$mn:0000B2AC var_4           = dword ptr -4
.text$mn:0000B2AC arg_0           = dword ptr  8
.text$mn:0000B2AC arg_4           = dword ptr  0Ch
.text$mn:0000B2AC
.text$mn:0000B2AC                 push    ebp
.text$mn:0000B2AD                 mov     ebp, esp
.text$mn:0000B2AF                 sub     esp, 0Ch
.text$mn:0000B2B2                 mov     [ebp+var_C], ecx
.text$mn:0000B2B5                 mov     eax, [ebp+arg_0]
.text$mn:0000B2B8                 push    eax             ; void *
.text$mn:0000B2B9                 push    4               ; unsigned int
.text$mn:0000B2BB                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000B2C0                 add     esp, 8
.text$mn:0000B2C3                 mov     [ebp+var_4], eax
.text$mn:0000B2C6                 cmp     [ebp+var_4], 0
.text$mn:0000B2CA                 jz      short loc_B2DE
.text$mn:0000B2CC                 mov     ecx, [ebp+arg_4]
.text$mn:0000B2CF                 mov     edx, [ecx]
.text$mn:0000B2D1                 mov     eax, [ebp+var_4]
.text$mn:0000B2D4                 mov     [eax], edx
.text$mn:0000B2D6                 mov     ecx, [ebp+var_4]
.text$mn:0000B2D9                 mov     [ebp+var_8], ecx
.text$mn:0000B2DC                 jmp     short loc_B2E5
.text$mn:0000B2DE ; ---------------------------------------------------------------------------
.text$mn:0000B2DE
.text$mn:0000B2DE loc_B2DE:                               ; CODE XREF: std::allocator<KeyCombo>::construct(KeyCombo *,KeyCombo const &)+1Ej
.text$mn:0000B2DE                 mov     [ebp+var_8], 0
.text$mn:0000B2E5
.text$mn:0000B2E5 loc_B2E5:                               ; CODE XREF: std::allocator<KeyCombo>::construct(KeyCombo *,KeyCombo const &)+30j
.text$mn:0000B2E5                 mov     esp, ebp
.text$mn:0000B2E7                 pop     ebp
.text$mn:0000B2E8                 retn    8
.text$mn:0000B2E8 ?construct@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@ABU3@@Z endp
.text$mn:0000B2E8
.text$mn:0000B2E8 ; ---------------------------------------------------------------------------
.text$mn:0000B2EB                 align 4
.text$mn:0000B2EB _text$mn        ends
.text$mn:0000B2EB
.text$mn:0000B2EC ; ===========================================================================
.text$mn:0000B2EC
.text$mn:0000B2EC ; Segment type: Pure code
.text$mn:0000B2EC ; Segment permissions: Read/Execute
.text$mn:0000B2EC _text$mn        segment para public 'CODE' use32
.text$mn:0000B2EC                 assume cs:_text$mn
.text$mn:0000B2EC                 ;org 0B2ECh
.text$mn:0000B2EC ; COMDAT (pick any)
.text$mn:0000B2EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B2EC
.text$mn:0000B2EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2EC
.text$mn:0000B2EC ; Attributes: bp-based frame
.text$mn:0000B2EC
.text$mn:0000B2EC ; int __stdcall std::allocator<recordedMacroStep>::construct(void *, int)
.text$mn:0000B2EC                 public ?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z
.text$mn:0000B2EC ?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z proc near
.text$mn:0000B2EC                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep const &>(std::allocator<recordedMacroStep> &,recordedMacroStep *,recordedMacroStep const &)+17p
.text$mn:0000B2EC
.text$mn:0000B2EC var_1C          = dword ptr -1Ch
.text$mn:0000B2EC var_18          = dword ptr -18h
.text$mn:0000B2EC var_14          = dword ptr -14h
.text$mn:0000B2EC var_10          = dword ptr -10h
.text$mn:0000B2EC var_C           = dword ptr -0Ch
.text$mn:0000B2EC var_4           = dword ptr -4
.text$mn:0000B2EC arg_0           = dword ptr  8
.text$mn:0000B2EC arg_4           = dword ptr  0Ch
.text$mn:0000B2EC
.text$mn:0000B2EC                 push    ebp
.text$mn:0000B2ED                 mov     ebp, esp
.text$mn:0000B2EF                 push    0FFFFFFFFh
.text$mn:0000B2F1                 push    offset __ehhandler$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z
.text$mn:0000B2F6                 mov     eax, large fs:0
.text$mn:0000B2FC                 push    eax
.text$mn:0000B2FD                 sub     esp, 10h
.text$mn:0000B300                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B305                 xor     eax, ebp
.text$mn:0000B307                 push    eax
.text$mn:0000B308                 lea     eax, [ebp+var_C]
.text$mn:0000B30B                 mov     large fs:0, eax
.text$mn:0000B311                 mov     [ebp+var_18], ecx
.text$mn:0000B314                 mov     eax, [ebp+arg_0]
.text$mn:0000B317                 push    eax             ; void *
.text$mn:0000B318                 push    2Ch ; ','       ; unsigned int
.text$mn:0000B31A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000B31F                 add     esp, 8
.text$mn:0000B322                 mov     [ebp+var_10], eax
.text$mn:0000B325                 mov     [ebp+var_4], 0
.text$mn:0000B32C                 cmp     [ebp+var_10], 0
.text$mn:0000B330                 jz      short loc_B343
.text$mn:0000B332                 mov     ecx, [ebp+arg_4]
.text$mn:0000B335                 push    ecx
.text$mn:0000B336                 mov     ecx, [ebp+var_10]
.text$mn:0000B339                 call    ??0recordedMacroStep@@QAE@ABU0@@Z ; recordedMacroStep::recordedMacroStep(recordedMacroStep const &)
.text$mn:0000B33E                 mov     [ebp+var_14], eax
.text$mn:0000B341                 jmp     short loc_B34A
.text$mn:0000B343 ; ---------------------------------------------------------------------------
.text$mn:0000B343
.text$mn:0000B343 loc_B343:                               ; CODE XREF: std::allocator<recordedMacroStep>::construct(recordedMacroStep *,recordedMacroStep const &)+44j
.text$mn:0000B343                 mov     [ebp+var_14], 0
.text$mn:0000B34A
.text$mn:0000B34A loc_B34A:                               ; CODE XREF: std::allocator<recordedMacroStep>::construct(recordedMacroStep *,recordedMacroStep const &)+55j
.text$mn:0000B34A                 mov     edx, [ebp+var_14]
.text$mn:0000B34D                 mov     [ebp+var_1C], edx
.text$mn:0000B350                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B357                 mov     ecx, [ebp+var_C]
.text$mn:0000B35A                 mov     large fs:0, ecx
.text$mn:0000B361                 pop     ecx
.text$mn:0000B362                 mov     esp, ebp
.text$mn:0000B364                 pop     ebp
.text$mn:0000B365                 retn    8
.text$mn:0000B365 ?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z endp
.text$mn:0000B365
.text$mn:0000B365 _text$mn        ends
.text$mn:0000B365
.text$x:0000B368 ; ===========================================================================
.text$x:0000B368
.text$x:0000B368 ; Segment type: Pure code
.text$x:0000B368 ; Segment permissions: Read/Execute
.text$x:0000B368 _text$x         segment para public 'CODE' use32
.text$x:0000B368                 assume cs:_text$x
.text$x:0000B368                 ;org 0B368h
.text$x:0000B368 ; COMDAT (pick associative to section at B2EC)
.text$x:0000B368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B368
.text$x:0000B368 ; =============== S U B R O U T I N E =======================================
.text$x:0000B368
.text$x:0000B368
.text$x:0000B368 __unwindfunclet$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z$0 proc near
.text$x:0000B368                                         ; DATA XREF: .xdata$x:0000D6A4o
.text$x:0000B368                 mov     eax, [ebp+8]
.text$x:0000B36B                 push    eax
.text$x:0000B36C                 mov     eax, [ebp-10h]
.text$x:0000B36F                 push    eax             ; void *
.text$x:0000B370                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000B375                 add     esp, 8
.text$x:0000B378                 retn
.text$x:0000B378 __unwindfunclet$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z$0 endp
.text$x:0000B378
.text$x:0000B379
.text$x:0000B379 ; =============== S U B R O U T I N E =======================================
.text$x:0000B379
.text$x:0000B379
.text$x:0000B379 __ehhandler$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z proc near
.text$x:0000B379                                         ; DATA XREF: std::allocator<recordedMacroStep>::construct(recordedMacroStep *,recordedMacroStep const &)+5o
.text$x:0000B379
.text$x:0000B379 arg_4           = dword ptr  8
.text$x:0000B379
.text$x:0000B379                 mov     edx, [esp+arg_4]
.text$x:0000B37D                 lea     eax, [edx+0Ch]
.text$x:0000B380                 mov     ecx, [edx-14h]
.text$x:0000B383                 xor     ecx, eax
.text$x:0000B385                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B38A                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z
.text$x:0000B38F                 jmp     ___CxxFrameHandler3
.text$x:0000B38F __ehhandler$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z endp
.text$x:0000B38F
.text$x:0000B38F _text$x         ends
.text$x:0000B38F
.text$mn:0000B394 ; ===========================================================================
.text$mn:0000B394
.text$mn:0000B394 ; Segment type: Pure code
.text$mn:0000B394 ; Segment permissions: Read/Execute
.text$mn:0000B394 _text$mn        segment para public 'CODE' use32
.text$mn:0000B394                 assume cs:_text$mn
.text$mn:0000B394                 ;org 0B394h
.text$mn:0000B394 ; COMDAT (pick any)
.text$mn:0000B394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B394
.text$mn:0000B394 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B394
.text$mn:0000B394 ; Attributes: bp-based frame
.text$mn:0000B394
.text$mn:0000B394 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:0000B394                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000B394 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:0000B394                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000B394
.text$mn:0000B394 var_4           = dword ptr -4
.text$mn:0000B394 Dst             = dword ptr  8
.text$mn:0000B394 Src             = dword ptr  0Ch
.text$mn:0000B394 Size            = dword ptr  10h
.text$mn:0000B394
.text$mn:0000B394                 push    ebp
.text$mn:0000B395                 mov     ebp, esp
.text$mn:0000B397                 push    ecx
.text$mn:0000B398                 cmp     [ebp+Size], 0
.text$mn:0000B39C                 jnz     short loc_B3A6
.text$mn:0000B39E                 mov     eax, [ebp+Dst]
.text$mn:0000B3A1                 mov     [ebp+var_4], eax
.text$mn:0000B3A4                 jmp     short loc_B3BD
.text$mn:0000B3A6 ; ---------------------------------------------------------------------------
.text$mn:0000B3A6
.text$mn:0000B3A6 loc_B3A6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000B3A6                 mov     ecx, [ebp+Size]
.text$mn:0000B3A9                 push    ecx             ; Size
.text$mn:0000B3AA                 mov     edx, [ebp+Src]
.text$mn:0000B3AD                 push    edx             ; Src
.text$mn:0000B3AE                 mov     eax, [ebp+Dst]
.text$mn:0000B3B1                 push    eax             ; Dst
.text$mn:0000B3B2                 call    _memcpy
.text$mn:0000B3B7                 add     esp, 0Ch
.text$mn:0000B3BA                 mov     [ebp+var_4], eax
.text$mn:0000B3BD
.text$mn:0000B3BD loc_B3BD:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000B3BD                 mov     eax, [ebp+var_4]
.text$mn:0000B3C0                 mov     esp, ebp
.text$mn:0000B3C2                 pop     ebp
.text$mn:0000B3C3                 retn
.text$mn:0000B3C3 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000B3C3
.text$mn:0000B3C3 _text$mn        ends
.text$mn:0000B3C3
.text$mn:0000B3C4 ; ===========================================================================
.text$mn:0000B3C4
.text$mn:0000B3C4 ; Segment type: Pure code
.text$mn:0000B3C4 ; Segment permissions: Read/Execute
.text$mn:0000B3C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3C4                 assume cs:_text$mn
.text$mn:0000B3C4                 ;org 0B3C4h
.text$mn:0000B3C4 ; COMDAT (pick any)
.text$mn:0000B3C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B3C4
.text$mn:0000B3C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3C4
.text$mn:0000B3C4 ; Attributes: bp-based frame
.text$mn:0000B3C4
.text$mn:0000B3C4 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:0000B3C4                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000B3C4 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000B3C4                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:0000B3C4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000B3C4
.text$mn:0000B3C4 var_4           = dword ptr -4
.text$mn:0000B3C4 Dst             = dword ptr  8
.text$mn:0000B3C4 Src             = dword ptr  0Ch
.text$mn:0000B3C4 arg_8           = dword ptr  10h
.text$mn:0000B3C4
.text$mn:0000B3C4                 push    ebp
.text$mn:0000B3C5                 mov     ebp, esp
.text$mn:0000B3C7                 push    ecx
.text$mn:0000B3C8                 cmp     [ebp+arg_8], 0
.text$mn:0000B3CC                 jnz     short loc_B3D6
.text$mn:0000B3CE                 mov     eax, [ebp+Dst]
.text$mn:0000B3D1                 mov     [ebp+var_4], eax
.text$mn:0000B3D4                 jmp     short loc_B3ED
.text$mn:0000B3D6 ; ---------------------------------------------------------------------------
.text$mn:0000B3D6
.text$mn:0000B3D6 loc_B3D6:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000B3D6                 mov     ecx, [ebp+arg_8]
.text$mn:0000B3D9                 push    ecx             ; int
.text$mn:0000B3DA                 mov     edx, [ebp+Src]
.text$mn:0000B3DD                 push    edx             ; Src
.text$mn:0000B3DE                 mov     eax, [ebp+Dst]
.text$mn:0000B3E1                 push    eax             ; Dst
.text$mn:0000B3E2                 call    _wmemcpy
.text$mn:0000B3E7                 add     esp, 0Ch
.text$mn:0000B3EA                 mov     [ebp+var_4], eax
.text$mn:0000B3ED
.text$mn:0000B3ED loc_B3ED:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000B3ED                 mov     eax, [ebp+var_4]
.text$mn:0000B3F0                 mov     esp, ebp
.text$mn:0000B3F2                 pop     ebp
.text$mn:0000B3F3                 retn
.text$mn:0000B3F3 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000B3F3
.text$mn:0000B3F3 _text$mn        ends
.text$mn:0000B3F3
.text$mn:0000B3F4 ; ===========================================================================
.text$mn:0000B3F4
.text$mn:0000B3F4 ; Segment type: Pure code
.text$mn:0000B3F4 ; Segment permissions: Read/Execute
.text$mn:0000B3F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3F4                 assume cs:_text$mn
.text$mn:0000B3F4                 ;org 0B3F4h
.text$mn:0000B3F4 ; COMDAT (pick any)
.text$mn:0000B3F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B3F4
.text$mn:0000B3F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3F4
.text$mn:0000B3F4 ; Attributes: bp-based frame
.text$mn:0000B3F4
.text$mn:0000B3F4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:0000B3F4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:0000B3F4 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:0000B3F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:0000B3F4
.text$mn:0000B3F4 var_4           = dword ptr -4
.text$mn:0000B3F4 arg_0           = dword ptr  8
.text$mn:0000B3F4 arg_4           = dword ptr  0Ch
.text$mn:0000B3F4
.text$mn:0000B3F4                 push    ebp
.text$mn:0000B3F5                 mov     ebp, esp
.text$mn:0000B3F7                 push    ecx
.text$mn:0000B3F8                 mov     [ebp+var_4], ecx
.text$mn:0000B3FB                 mov     eax, [ebp+arg_4]
.text$mn:0000B3FE                 push    eax             ; int
.text$mn:0000B3FF                 mov     ecx, [ebp+arg_0]
.text$mn:0000B402                 push    ecx             ; void *
.text$mn:0000B403                 mov     ecx, [ebp+var_4]
.text$mn:0000B406                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000B40B                 mov     esp, ebp
.text$mn:0000B40D                 pop     ebp
.text$mn:0000B40E                 retn    8
.text$mn:0000B40E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000B40E
.text$mn:0000B40E ; ---------------------------------------------------------------------------
.text$mn:0000B411                 align 4
.text$mn:0000B411 _text$mn        ends
.text$mn:0000B411
.text$mn:0000B414 ; ===========================================================================
.text$mn:0000B414
.text$mn:0000B414 ; Segment type: Pure code
.text$mn:0000B414 ; Segment permissions: Read/Execute
.text$mn:0000B414 _text$mn        segment para public 'CODE' use32
.text$mn:0000B414                 assume cs:_text$mn
.text$mn:0000B414                 ;org 0B414h
.text$mn:0000B414 ; COMDAT (pick any)
.text$mn:0000B414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B414
.text$mn:0000B414 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B414
.text$mn:0000B414 ; Attributes: bp-based frame
.text$mn:0000B414
.text$mn:0000B414 ; int __stdcall std::_Wrap_alloc<std::allocator<KeyCombo>>::deallocate(void *, int)
.text$mn:0000B414                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@I@Z
.text$mn:0000B414 ?deallocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@I@Z proc near
.text$mn:0000B414                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+1BBp
.text$mn:0000B414                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::_Tidy(void)+55p
.text$mn:0000B414
.text$mn:0000B414 var_4           = dword ptr -4
.text$mn:0000B414 arg_0           = dword ptr  8
.text$mn:0000B414 arg_4           = dword ptr  0Ch
.text$mn:0000B414
.text$mn:0000B414                 push    ebp
.text$mn:0000B415                 mov     ebp, esp
.text$mn:0000B417                 push    ecx
.text$mn:0000B418                 mov     [ebp+var_4], ecx
.text$mn:0000B41B                 mov     eax, [ebp+arg_4]
.text$mn:0000B41E                 push    eax             ; int
.text$mn:0000B41F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B422                 push    ecx             ; void *
.text$mn:0000B423                 mov     ecx, [ebp+var_4]
.text$mn:0000B426                 call    ?deallocate@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@I@Z ; std::allocator<KeyCombo>::deallocate(KeyCombo *,uint)
.text$mn:0000B42B                 mov     esp, ebp
.text$mn:0000B42D                 pop     ebp
.text$mn:0000B42E                 retn    8
.text$mn:0000B42E ?deallocate@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAEXPAUKeyCombo@@I@Z endp
.text$mn:0000B42E
.text$mn:0000B42E ; ---------------------------------------------------------------------------
.text$mn:0000B431                 align 4
.text$mn:0000B431 _text$mn        ends
.text$mn:0000B431
.text$mn:0000B434 ; ===========================================================================
.text$mn:0000B434
.text$mn:0000B434 ; Segment type: Pure code
.text$mn:0000B434 ; Segment permissions: Read/Execute
.text$mn:0000B434 _text$mn        segment para public 'CODE' use32
.text$mn:0000B434                 assume cs:_text$mn
.text$mn:0000B434                 ;org 0B434h
.text$mn:0000B434 ; COMDAT (pick any)
.text$mn:0000B434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B434
.text$mn:0000B434 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B434
.text$mn:0000B434 ; Attributes: bp-based frame
.text$mn:0000B434
.text$mn:0000B434 ; int __stdcall std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(void *, int)
.text$mn:0000B434                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z
.text$mn:0000B434 ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z proc near
.text$mn:0000B434                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000B434                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+FAp ...
.text$mn:0000B434
.text$mn:0000B434 var_4           = dword ptr -4
.text$mn:0000B434 arg_0           = dword ptr  8
.text$mn:0000B434 arg_4           = dword ptr  0Ch
.text$mn:0000B434
.text$mn:0000B434                 push    ebp
.text$mn:0000B435                 mov     ebp, esp
.text$mn:0000B437                 push    ecx
.text$mn:0000B438                 mov     [ebp+var_4], ecx
.text$mn:0000B43B                 mov     eax, [ebp+arg_4]
.text$mn:0000B43E                 push    eax             ; int
.text$mn:0000B43F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B442                 push    ecx             ; void *
.text$mn:0000B443                 mov     ecx, [ebp+var_4]
.text$mn:0000B446                 call    ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::allocator<MenuItemUnit>::deallocate(MenuItemUnit *,uint)
.text$mn:0000B44B                 mov     esp, ebp
.text$mn:0000B44D                 pop     ebp
.text$mn:0000B44E                 retn    8
.text$mn:0000B44E ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z endp
.text$mn:0000B44E
.text$mn:0000B44E ; ---------------------------------------------------------------------------
.text$mn:0000B451                 align 4
.text$mn:0000B451 _text$mn        ends
.text$mn:0000B451
.text$mn:0000B454 ; ===========================================================================
.text$mn:0000B454
.text$mn:0000B454 ; Segment type: Pure code
.text$mn:0000B454 ; Segment permissions: Read/Execute
.text$mn:0000B454 _text$mn        segment para public 'CODE' use32
.text$mn:0000B454                 assume cs:_text$mn
.text$mn:0000B454                 ;org 0B454h
.text$mn:0000B454 ; COMDAT (pick any)
.text$mn:0000B454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B454
.text$mn:0000B454 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B454
.text$mn:0000B454 ; Attributes: bp-based frame
.text$mn:0000B454
.text$mn:0000B454 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:0000B454                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000B454 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000B454                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Free_proxy(void)+32p
.text$mn:0000B454                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Free_proxy(void)+32p ...
.text$mn:0000B454
.text$mn:0000B454 var_4           = dword ptr -4
.text$mn:0000B454 arg_0           = dword ptr  8
.text$mn:0000B454 arg_4           = dword ptr  0Ch
.text$mn:0000B454
.text$mn:0000B454                 push    ebp
.text$mn:0000B455                 mov     ebp, esp
.text$mn:0000B457                 push    ecx
.text$mn:0000B458                 mov     [ebp+var_4], ecx
.text$mn:0000B45B                 mov     eax, [ebp+arg_4]
.text$mn:0000B45E                 push    eax             ; int
.text$mn:0000B45F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B462                 push    ecx             ; void *
.text$mn:0000B463                 mov     ecx, [ebp+var_4]
.text$mn:0000B466                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000B46B                 mov     esp, ebp
.text$mn:0000B46D                 pop     ebp
.text$mn:0000B46E                 retn    8
.text$mn:0000B46E ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000B46E
.text$mn:0000B46E ; ---------------------------------------------------------------------------
.text$mn:0000B471                 align 4
.text$mn:0000B471 _text$mn        ends
.text$mn:0000B471
.text$mn:0000B474 ; ===========================================================================
.text$mn:0000B474
.text$mn:0000B474 ; Segment type: Pure code
.text$mn:0000B474 ; Segment permissions: Read/Execute
.text$mn:0000B474 _text$mn        segment para public 'CODE' use32
.text$mn:0000B474                 assume cs:_text$mn
.text$mn:0000B474                 ;org 0B474h
.text$mn:0000B474 ; COMDAT (pick any)
.text$mn:0000B474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B474
.text$mn:0000B474 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B474
.text$mn:0000B474 ; Attributes: bp-based frame
.text$mn:0000B474
.text$mn:0000B474 ; int __stdcall std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(void *, int)
.text$mn:0000B474                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z
.text$mn:0000B474 ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z proc near
.text$mn:0000B474                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+1C0p
.text$mn:0000B474                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Tidy(void)+5Cp
.text$mn:0000B474
.text$mn:0000B474 var_4           = dword ptr -4
.text$mn:0000B474 arg_0           = dword ptr  8
.text$mn:0000B474 arg_4           = dword ptr  0Ch
.text$mn:0000B474
.text$mn:0000B474                 push    ebp
.text$mn:0000B475                 mov     ebp, esp
.text$mn:0000B477                 push    ecx
.text$mn:0000B478                 mov     [ebp+var_4], ecx
.text$mn:0000B47B                 mov     eax, [ebp+arg_4]
.text$mn:0000B47E                 push    eax             ; int
.text$mn:0000B47F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B482                 push    ecx             ; void *
.text$mn:0000B483                 mov     ecx, [ebp+var_4]
.text$mn:0000B486                 call    ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z ; std::allocator<recordedMacroStep>::deallocate(recordedMacroStep *,uint)
.text$mn:0000B48B                 mov     esp, ebp
.text$mn:0000B48D                 pop     ebp
.text$mn:0000B48E                 retn    8
.text$mn:0000B48E ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z endp
.text$mn:0000B48E
.text$mn:0000B48E ; ---------------------------------------------------------------------------
.text$mn:0000B491                 align 4
.text$mn:0000B491 _text$mn        ends
.text$mn:0000B491
.text$mn:0000B494 ; ===========================================================================
.text$mn:0000B494
.text$mn:0000B494 ; Segment type: Pure code
.text$mn:0000B494 ; Segment permissions: Read/Execute
.text$mn:0000B494 _text$mn        segment para public 'CODE' use32
.text$mn:0000B494                 assume cs:_text$mn
.text$mn:0000B494                 ;org 0B494h
.text$mn:0000B494 ; COMDAT (pick any)
.text$mn:0000B494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B494
.text$mn:0000B494 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B494
.text$mn:0000B494 ; Attributes: bp-based frame
.text$mn:0000B494
.text$mn:0000B494 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:0000B494                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:0000B494 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:0000B494                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:0000B494
.text$mn:0000B494 var_4           = dword ptr -4
.text$mn:0000B494 arg_0           = dword ptr  8
.text$mn:0000B494 arg_4           = dword ptr  0Ch
.text$mn:0000B494
.text$mn:0000B494                 push    ebp
.text$mn:0000B495                 mov     ebp, esp
.text$mn:0000B497                 push    ecx
.text$mn:0000B498                 mov     [ebp+var_4], ecx
.text$mn:0000B49B                 mov     eax, [ebp+arg_4]
.text$mn:0000B49E                 push    eax             ; int
.text$mn:0000B49F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B4A2                 push    ecx             ; void *
.text$mn:0000B4A3                 mov     ecx, [ebp+var_4]
.text$mn:0000B4A6                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000B4AB                 mov     esp, ebp
.text$mn:0000B4AD                 pop     ebp
.text$mn:0000B4AE                 retn    8
.text$mn:0000B4AE ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000B4AE
.text$mn:0000B4AE ; ---------------------------------------------------------------------------
.text$mn:0000B4B1                 align 4
.text$mn:0000B4B1 _text$mn        ends
.text$mn:0000B4B1
.text$mn:0000B4B4 ; ===========================================================================
.text$mn:0000B4B4
.text$mn:0000B4B4 ; Segment type: Pure code
.text$mn:0000B4B4 ; Segment permissions: Read/Execute
.text$mn:0000B4B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B4B4                 assume cs:_text$mn
.text$mn:0000B4B4                 ;org 0B4B4h
.text$mn:0000B4B4 ; COMDAT (pick any)
.text$mn:0000B4B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B4B4
.text$mn:0000B4B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B4B4
.text$mn:0000B4B4 ; Attributes: bp-based frame
.text$mn:0000B4B4
.text$mn:0000B4B4 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:0000B4B4                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:0000B4B4 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:0000B4B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:0000B4B4
.text$mn:0000B4B4 var_4           = dword ptr -4
.text$mn:0000B4B4 arg_0           = dword ptr  8
.text$mn:0000B4B4
.text$mn:0000B4B4                 push    ebp
.text$mn:0000B4B5                 mov     ebp, esp
.text$mn:0000B4B7                 push    ecx
.text$mn:0000B4B8                 mov     [ebp+var_4], ecx
.text$mn:0000B4BB                 mov     eax, [ebp+arg_0]
.text$mn:0000B4BE                 push    eax             ; void *
.text$mn:0000B4BF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B4C4                 add     esp, 4
.text$mn:0000B4C7                 mov     esp, ebp
.text$mn:0000B4C9                 pop     ebp
.text$mn:0000B4CA                 retn    8
.text$mn:0000B4CA ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000B4CA
.text$mn:0000B4CA ; ---------------------------------------------------------------------------
.text$mn:0000B4CD                 align 10h
.text$mn:0000B4CD _text$mn        ends
.text$mn:0000B4CD
.text$mn:0000B4D0 ; ===========================================================================
.text$mn:0000B4D0
.text$mn:0000B4D0 ; Segment type: Pure code
.text$mn:0000B4D0 ; Segment permissions: Read/Execute
.text$mn:0000B4D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B4D0                 assume cs:_text$mn
.text$mn:0000B4D0                 ;org 0B4D0h
.text$mn:0000B4D0 ; COMDAT (pick any)
.text$mn:0000B4D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B4D0
.text$mn:0000B4D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B4D0
.text$mn:0000B4D0 ; Attributes: bp-based frame
.text$mn:0000B4D0
.text$mn:0000B4D0 ; int __stdcall std::allocator<KeyCombo>::deallocate(void *, int)
.text$mn:0000B4D0                 public ?deallocate@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@I@Z
.text$mn:0000B4D0 ?deallocate@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@I@Z proc near
.text$mn:0000B4D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::deallocate(KeyCombo *,uint)+12p
.text$mn:0000B4D0
.text$mn:0000B4D0 var_4           = dword ptr -4
.text$mn:0000B4D0 arg_0           = dword ptr  8
.text$mn:0000B4D0
.text$mn:0000B4D0                 push    ebp
.text$mn:0000B4D1                 mov     ebp, esp
.text$mn:0000B4D3                 push    ecx
.text$mn:0000B4D4                 mov     [ebp+var_4], ecx
.text$mn:0000B4D7                 mov     eax, [ebp+arg_0]
.text$mn:0000B4DA                 push    eax             ; void *
.text$mn:0000B4DB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B4E0                 add     esp, 4
.text$mn:0000B4E3                 mov     esp, ebp
.text$mn:0000B4E5                 pop     ebp
.text$mn:0000B4E6                 retn    8
.text$mn:0000B4E6 ?deallocate@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@I@Z endp
.text$mn:0000B4E6
.text$mn:0000B4E6 ; ---------------------------------------------------------------------------
.text$mn:0000B4E9                 align 4
.text$mn:0000B4E9 _text$mn        ends
.text$mn:0000B4E9
.text$mn:0000B4EC ; ===========================================================================
.text$mn:0000B4EC
.text$mn:0000B4EC ; Segment type: Pure code
.text$mn:0000B4EC ; Segment permissions: Read/Execute
.text$mn:0000B4EC _text$mn        segment para public 'CODE' use32
.text$mn:0000B4EC                 assume cs:_text$mn
.text$mn:0000B4EC                 ;org 0B4ECh
.text$mn:0000B4EC ; COMDAT (pick any)
.text$mn:0000B4EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B4EC
.text$mn:0000B4EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B4EC
.text$mn:0000B4EC ; Attributes: bp-based frame
.text$mn:0000B4EC
.text$mn:0000B4EC ; int __stdcall std::allocator<MenuItemUnit>::deallocate(void *, int)
.text$mn:0000B4EC                 public ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z
.text$mn:0000B4EC ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z proc near
.text$mn:0000B4EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)+12p
.text$mn:0000B4EC
.text$mn:0000B4EC var_4           = dword ptr -4
.text$mn:0000B4EC arg_0           = dword ptr  8
.text$mn:0000B4EC
.text$mn:0000B4EC                 push    ebp
.text$mn:0000B4ED                 mov     ebp, esp
.text$mn:0000B4EF                 push    ecx
.text$mn:0000B4F0                 mov     [ebp+var_4], ecx
.text$mn:0000B4F3                 mov     eax, [ebp+arg_0]
.text$mn:0000B4F6                 push    eax             ; void *
.text$mn:0000B4F7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B4FC                 add     esp, 4
.text$mn:0000B4FF                 mov     esp, ebp
.text$mn:0000B501                 pop     ebp
.text$mn:0000B502                 retn    8
.text$mn:0000B502 ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z endp
.text$mn:0000B502
.text$mn:0000B502 ; ---------------------------------------------------------------------------
.text$mn:0000B505                 align 4
.text$mn:0000B505 _text$mn        ends
.text$mn:0000B505
.text$mn:0000B508 ; ===========================================================================
.text$mn:0000B508
.text$mn:0000B508 ; Segment type: Pure code
.text$mn:0000B508 ; Segment permissions: Read/Execute
.text$mn:0000B508 _text$mn        segment para public 'CODE' use32
.text$mn:0000B508                 assume cs:_text$mn
.text$mn:0000B508                 ;org 0B508h
.text$mn:0000B508 ; COMDAT (pick any)
.text$mn:0000B508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B508
.text$mn:0000B508 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B508
.text$mn:0000B508 ; Attributes: bp-based frame
.text$mn:0000B508
.text$mn:0000B508 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000B508                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000B508 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000B508                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000B508                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:0000B508
.text$mn:0000B508 var_4           = dword ptr -4
.text$mn:0000B508 arg_0           = dword ptr  8
.text$mn:0000B508
.text$mn:0000B508                 push    ebp
.text$mn:0000B509                 mov     ebp, esp
.text$mn:0000B50B                 push    ecx
.text$mn:0000B50C                 mov     [ebp+var_4], ecx
.text$mn:0000B50F                 mov     eax, [ebp+arg_0]
.text$mn:0000B512                 push    eax             ; void *
.text$mn:0000B513                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B518                 add     esp, 4
.text$mn:0000B51B                 mov     esp, ebp
.text$mn:0000B51D                 pop     ebp
.text$mn:0000B51E                 retn    8
.text$mn:0000B51E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000B51E
.text$mn:0000B51E ; ---------------------------------------------------------------------------
.text$mn:0000B521                 align 4
.text$mn:0000B521 _text$mn        ends
.text$mn:0000B521
.text$mn:0000B524 ; ===========================================================================
.text$mn:0000B524
.text$mn:0000B524 ; Segment type: Pure code
.text$mn:0000B524 ; Segment permissions: Read/Execute
.text$mn:0000B524 _text$mn        segment para public 'CODE' use32
.text$mn:0000B524                 assume cs:_text$mn
.text$mn:0000B524                 ;org 0B524h
.text$mn:0000B524 ; COMDAT (pick any)
.text$mn:0000B524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B524
.text$mn:0000B524 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B524
.text$mn:0000B524 ; Attributes: bp-based frame
.text$mn:0000B524
.text$mn:0000B524 ; int __stdcall std::allocator<recordedMacroStep>::deallocate(void *, int)
.text$mn:0000B524                 public ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z
.text$mn:0000B524 ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z proc near
.text$mn:0000B524                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(recordedMacroStep *,uint)+12p
.text$mn:0000B524
.text$mn:0000B524 var_4           = dword ptr -4
.text$mn:0000B524 arg_0           = dword ptr  8
.text$mn:0000B524
.text$mn:0000B524                 push    ebp
.text$mn:0000B525                 mov     ebp, esp
.text$mn:0000B527                 push    ecx
.text$mn:0000B528                 mov     [ebp+var_4], ecx
.text$mn:0000B52B                 mov     eax, [ebp+arg_0]
.text$mn:0000B52E                 push    eax             ; void *
.text$mn:0000B52F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B534                 add     esp, 4
.text$mn:0000B537                 mov     esp, ebp
.text$mn:0000B539                 pop     ebp
.text$mn:0000B53A                 retn    8
.text$mn:0000B53A ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z endp
.text$mn:0000B53A
.text$mn:0000B53A ; ---------------------------------------------------------------------------
.text$mn:0000B53D                 align 10h
.text$mn:0000B53D _text$mn        ends
.text$mn:0000B53D
.text$mn:0000B540 ; ===========================================================================
.text$mn:0000B540
.text$mn:0000B540 ; Segment type: Pure code
.text$mn:0000B540 ; Segment permissions: Read/Execute
.text$mn:0000B540 _text$mn        segment para public 'CODE' use32
.text$mn:0000B540                 assume cs:_text$mn
.text$mn:0000B540                 ;org 0B540h
.text$mn:0000B540 ; COMDAT (pick any)
.text$mn:0000B540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B540
.text$mn:0000B540 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B540
.text$mn:0000B540 ; Attributes: bp-based frame
.text$mn:0000B540
.text$mn:0000B540 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:0000B540                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:0000B540 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:0000B540                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:0000B540
.text$mn:0000B540 var_4           = dword ptr -4
.text$mn:0000B540 arg_0           = dword ptr  8
.text$mn:0000B540
.text$mn:0000B540                 push    ebp
.text$mn:0000B541                 mov     ebp, esp
.text$mn:0000B543                 push    ecx
.text$mn:0000B544                 mov     [ebp+var_4], ecx
.text$mn:0000B547                 mov     eax, [ebp+arg_0]
.text$mn:0000B54A                 push    eax             ; void *
.text$mn:0000B54B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000B550                 add     esp, 4
.text$mn:0000B553                 mov     esp, ebp
.text$mn:0000B555                 pop     ebp
.text$mn:0000B556                 retn    8
.text$mn:0000B556 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000B556
.text$mn:0000B556 ; ---------------------------------------------------------------------------
.text$mn:0000B559                 align 4
.text$mn:0000B559 _text$mn        ends
.text$mn:0000B559
.text$mn:0000B55C ; ===========================================================================
.text$mn:0000B55C
.text$mn:0000B55C ; Segment type: Pure code
.text$mn:0000B55C ; Segment permissions: Read/Execute
.text$mn:0000B55C _text$mn        segment para public 'CODE' use32
.text$mn:0000B55C                 assume cs:_text$mn
.text$mn:0000B55C                 ;org 0B55Ch
.text$mn:0000B55C ; COMDAT (pick any)
.text$mn:0000B55C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B55C
.text$mn:0000B55C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B55C
.text$mn:0000B55C ; Attributes: bp-based frame
.text$mn:0000B55C
.text$mn:0000B55C ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:0000B55C                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000B55C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000B55C                                         ; DATA XREF: .rdata:0000E950o
.text$mn:0000B55C
.text$mn:0000B55C var_4           = dword ptr -4
.text$mn:0000B55C arg_0           = dword ptr  8
.text$mn:0000B55C arg_4           = dword ptr  0Ch
.text$mn:0000B55C
.text$mn:0000B55C                 push    ebp
.text$mn:0000B55D                 mov     ebp, esp
.text$mn:0000B55F                 push    ecx
.text$mn:0000B560                 mov     [ebp+var_4], ecx
.text$mn:0000B563                 mov     eax, [ebp+arg_4]
.text$mn:0000B566                 push    eax             ; int
.text$mn:0000B567                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000B56C                 add     esp, 4
.text$mn:0000B56F                 test    eax, eax
.text$mn:0000B571                 jz      short loc_B58C
.text$mn:0000B573                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000B578                 push    eax             ; struct std::error_category *
.text$mn:0000B579                 mov     ecx, [ebp+arg_4]
.text$mn:0000B57C                 push    ecx             ; int
.text$mn:0000B57D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B580                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000B585                 mov     eax, [ebp+arg_0]
.text$mn:0000B588                 jmp     short loc_B5A1
.text$mn:0000B58A ; ---------------------------------------------------------------------------
.text$mn:0000B58A                 jmp     short loc_B5A1
.text$mn:0000B58C ; ---------------------------------------------------------------------------
.text$mn:0000B58C
.text$mn:0000B58C loc_B58C:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000B58C                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000B591                 push    eax             ; struct std::error_category *
.text$mn:0000B592                 mov     edx, [ebp+arg_4]
.text$mn:0000B595                 push    edx             ; int
.text$mn:0000B596                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B599                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000B59E                 mov     eax, [ebp+arg_0]
.text$mn:0000B5A1
.text$mn:0000B5A1 loc_B5A1:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000B5A1                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000B5A1                 mov     esp, ebp
.text$mn:0000B5A3                 pop     ebp
.text$mn:0000B5A4                 retn    8
.text$mn:0000B5A4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000B5A4
.text$mn:0000B5A4 ; ---------------------------------------------------------------------------
.text$mn:0000B5A7                 align 4
.text$mn:0000B5A7 _text$mn        ends
.text$mn:0000B5A7
.text$mn:0000B5A8 ; ===========================================================================
.text$mn:0000B5A8
.text$mn:0000B5A8 ; Segment type: Pure code
.text$mn:0000B5A8 ; Segment permissions: Read/Execute
.text$mn:0000B5A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B5A8                 assume cs:_text$mn
.text$mn:0000B5A8                 ;org 0B5A8h
.text$mn:0000B5A8 ; COMDAT (pick any)
.text$mn:0000B5A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B5A8
.text$mn:0000B5A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B5A8
.text$mn:0000B5A8 ; Attributes: bp-based frame
.text$mn:0000B5A8
.text$mn:0000B5A8 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000B5A8                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000B5A8 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000B5A8                                         ; DATA XREF: .rdata:0000E8C0o
.text$mn:0000B5A8                                         ; .rdata:0000E8DCo ...
.text$mn:0000B5A8
.text$mn:0000B5A8 var_4           = dword ptr -4
.text$mn:0000B5A8 arg_0           = dword ptr  8
.text$mn:0000B5A8 arg_4           = dword ptr  0Ch
.text$mn:0000B5A8
.text$mn:0000B5A8                 push    ebp
.text$mn:0000B5A9                 mov     ebp, esp
.text$mn:0000B5AB                 push    ecx
.text$mn:0000B5AC                 mov     [ebp+var_4], ecx
.text$mn:0000B5AF                 mov     eax, [ebp+var_4]
.text$mn:0000B5B2                 push    eax             ; struct std::error_category *
.text$mn:0000B5B3                 mov     ecx, [ebp+arg_4]
.text$mn:0000B5B6                 push    ecx             ; int
.text$mn:0000B5B7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B5BA                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000B5BF                 mov     eax, [ebp+arg_0]
.text$mn:0000B5C2                 mov     esp, ebp
.text$mn:0000B5C4                 pop     ebp
.text$mn:0000B5C5                 retn    8
.text$mn:0000B5C5 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000B5C5
.text$mn:0000B5C5 _text$mn        ends
.text$mn:0000B5C5
.text$mn:0000B5C8 ; ===========================================================================
.text$mn:0000B5C8
.text$mn:0000B5C8 ; Segment type: Pure code
.text$mn:0000B5C8 ; Segment permissions: Read/Execute
.text$mn:0000B5C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B5C8                 assume cs:_text$mn
.text$mn:0000B5C8                 ;org 0B5C8h
.text$mn:0000B5C8 ; COMDAT (pick any)
.text$mn:0000B5C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B5C8
.text$mn:0000B5C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B5C8
.text$mn:0000B5C8 ; Attributes: bp-based frame
.text$mn:0000B5C8
.text$mn:0000B5C8 ; void __thiscall StaticDialog::destroy(StaticDialog *__hidden this)
.text$mn:0000B5C8                 public ?destroy@StaticDialog@@UAEXXZ
.text$mn:0000B5C8 ?destroy@StaticDialog@@UAEXXZ proc near ; CODE XREF: StaticDialog::~StaticDialog(void)+59p
.text$mn:0000B5C8                                         ; DATA XREF: .rdata:0000E7B4o ...
.text$mn:0000B5C8
.text$mn:0000B5C8 var_4           = dword ptr -4
.text$mn:0000B5C8
.text$mn:0000B5C8                 push    ebp
.text$mn:0000B5C9                 mov     ebp, esp
.text$mn:0000B5CB                 push    ecx
.text$mn:0000B5CC                 mov     [ebp+var_4], ecx
.text$mn:0000B5CF                 mov     eax, [ebp+var_4]
.text$mn:0000B5D2                 mov     ecx, [eax+0Ch]
.text$mn:0000B5D5                 push    ecx             ; lParam
.text$mn:0000B5D6                 push    1               ; wParam
.text$mn:0000B5D8                 push    7F4h            ; Msg
.text$mn:0000B5DD                 mov     edx, [ebp+var_4]
.text$mn:0000B5E0                 mov     eax, [edx+8]
.text$mn:0000B5E3                 push    eax             ; hWnd
.text$mn:0000B5E4                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000B5EA                 mov     ecx, [ebp+var_4]
.text$mn:0000B5ED                 mov     edx, [ecx+0Ch]
.text$mn:0000B5F0                 push    edx             ; hWnd
.text$mn:0000B5F1                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:0000B5F7                 mov     esp, ebp
.text$mn:0000B5F9                 pop     ebp
.text$mn:0000B5FA                 retn
.text$mn:0000B5FA ?destroy@StaticDialog@@UAEXXZ endp
.text$mn:0000B5FA
.text$mn:0000B5FA ; ---------------------------------------------------------------------------
.text$mn:0000B5FB                 align 4
.text$mn:0000B5FB _text$mn        ends
.text$mn:0000B5FB
.text$mn:0000B5FC ; ===========================================================================
.text$mn:0000B5FC
.text$mn:0000B5FC ; Segment type: Pure code
.text$mn:0000B5FC ; Segment permissions: Read/Execute
.text$mn:0000B5FC _text$mn        segment para public 'CODE' use32
.text$mn:0000B5FC                 assume cs:_text$mn
.text$mn:0000B5FC                 ;org 0B5FCh
.text$mn:0000B5FC ; COMDAT (pick any)
.text$mn:0000B5FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B5FC
.text$mn:0000B5FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B5FC
.text$mn:0000B5FC ; Attributes: bp-based frame
.text$mn:0000B5FC
.text$mn:0000B5FC ; void __thiscall ContextMenu::display(ContextMenu *this, const struct tagPOINT *)
.text$mn:0000B5FC                 public ?display@ContextMenu@@QBEXABUtagPOINT@@@Z
.text$mn:0000B5FC ?display@ContextMenu@@QBEXABUtagPOINT@@@Z proc near
.text$mn:0000B5FC                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+10C4p
.text$mn:0000B5FC
.text$mn:0000B5FC var_4           = dword ptr -4
.text$mn:0000B5FC arg_0           = dword ptr  8
.text$mn:0000B5FC
.text$mn:0000B5FC                 push    ebp
.text$mn:0000B5FD                 mov     ebp, esp
.text$mn:0000B5FF                 push    ecx
.text$mn:0000B600                 mov     [ebp+var_4], ecx
.text$mn:0000B603                 push    0               ; prcRect
.text$mn:0000B605                 mov     eax, [ebp+var_4]
.text$mn:0000B608                 mov     ecx, [eax]
.text$mn:0000B60A                 push    ecx             ; hWnd
.text$mn:0000B60B                 push    0               ; nReserved
.text$mn:0000B60D                 mov     edx, [ebp+arg_0]
.text$mn:0000B610                 mov     eax, [edx+4]
.text$mn:0000B613                 push    eax             ; y
.text$mn:0000B614                 mov     ecx, [ebp+arg_0]
.text$mn:0000B617                 mov     edx, [ecx]
.text$mn:0000B619                 push    edx             ; x
.text$mn:0000B61A                 push    0               ; uFlags
.text$mn:0000B61C                 mov     eax, [ebp+var_4]
.text$mn:0000B61F                 mov     ecx, [eax+4]
.text$mn:0000B622                 push    ecx             ; hMenu
.text$mn:0000B623                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:0000B629                 mov     esp, ebp
.text$mn:0000B62B                 pop     ebp
.text$mn:0000B62C                 retn    4
.text$mn:0000B62C ?display@ContextMenu@@QBEXABUtagPOINT@@@Z endp
.text$mn:0000B62C
.text$mn:0000B62C ; ---------------------------------------------------------------------------
.text$mn:0000B62F                 align 10h
.text$mn:0000B62F _text$mn        ends
.text$mn:0000B62F
.text$mn:0000B630 ; ===========================================================================
.text$mn:0000B630
.text$mn:0000B630 ; Segment type: Pure code
.text$mn:0000B630 ; Segment permissions: Read/Execute
.text$mn:0000B630 _text$mn        segment para public 'CODE' use32
.text$mn:0000B630                 assume cs:_text$mn
.text$mn:0000B630                 ;org 0B630h
.text$mn:0000B630 ; COMDAT (pick any)
.text$mn:0000B630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B630
.text$mn:0000B630 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B630
.text$mn:0000B630 ; Attributes: bp-based frame
.text$mn:0000B630
.text$mn:0000B630 ; void __thiscall Window::display(Window *this, bool)
.text$mn:0000B630                 public ?display@Window@@UBEX_N@Z
.text$mn:0000B630 ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:0000E784o
.text$mn:0000B630
.text$mn:0000B630 var_8           = dword ptr -8
.text$mn:0000B630 nCmdShow        = dword ptr -4
.text$mn:0000B630 arg_0           = byte ptr  8
.text$mn:0000B630
.text$mn:0000B630                 push    ebp
.text$mn:0000B631                 mov     ebp, esp
.text$mn:0000B633                 sub     esp, 8
.text$mn:0000B636                 mov     [ebp+var_8], ecx
.text$mn:0000B639                 movzx   eax, [ebp+arg_0]
.text$mn:0000B63D                 test    eax, eax
.text$mn:0000B63F                 jz      short loc_B64A
.text$mn:0000B641                 mov     [ebp+nCmdShow], 5
.text$mn:0000B648                 jmp     short loc_B651
.text$mn:0000B64A ; ---------------------------------------------------------------------------
.text$mn:0000B64A
.text$mn:0000B64A loc_B64A:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:0000B64A                 mov     [ebp+nCmdShow], 0
.text$mn:0000B651
.text$mn:0000B651 loc_B651:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:0000B651                 mov     ecx, [ebp+nCmdShow]
.text$mn:0000B654                 push    ecx             ; nCmdShow
.text$mn:0000B655                 mov     edx, [ebp+var_8]
.text$mn:0000B658                 mov     eax, [edx+0Ch]
.text$mn:0000B65B                 push    eax             ; hWnd
.text$mn:0000B65C                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:0000B662                 mov     esp, ebp
.text$mn:0000B664                 pop     ebp
.text$mn:0000B665                 retn    4
.text$mn:0000B665 ?display@Window@@UBEX_N@Z endp
.text$mn:0000B665
.text$mn:0000B665 _text$mn        ends
.text$mn:0000B665
.text$mn:0000B668 ; ===========================================================================
.text$mn:0000B668
.text$mn:0000B668 ; Segment type: Pure code
.text$mn:0000B668 ; Segment permissions: Read/Execute
.text$mn:0000B668 _text$mn        segment para public 'CODE' use32
.text$mn:0000B668                 assume cs:_text$mn
.text$mn:0000B668                 ;org 0B668h
.text$mn:0000B668 ; COMDAT (pick any)
.text$mn:0000B668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B668
.text$mn:0000B668 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B668
.text$mn:0000B668 ; Attributes: bp-based frame
.text$mn:0000B668
.text$mn:0000B668 ; int __thiscall ScintillaKeyMap::doDialog(ScintillaKeyMap *__hidden this)
.text$mn:0000B668                 public ?doDialog@ScintillaKeyMap@@UAEHXZ
.text$mn:0000B668 ?doDialog@ScintillaKeyMap@@UAEHXZ proc near
.text$mn:0000B668                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+92Dp
.text$mn:0000B668                                         ; DATA XREF: .rdata:0000EA5Co
.text$mn:0000B668
.text$mn:0000B668 dwInitParam     = dword ptr -4
.text$mn:0000B668
.text$mn:0000B668                 push    ebp
.text$mn:0000B669                 mov     ebp, esp
.text$mn:0000B66B                 push    ecx
.text$mn:0000B66C                 mov     [ebp+dwInitParam], ecx
.text$mn:0000B66F                 mov     eax, [ebp+dwInitParam]
.text$mn:0000B672                 push    eax             ; dwInitParam
.text$mn:0000B673                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:0000B678                 mov     ecx, [ebp+dwInitParam]
.text$mn:0000B67B                 mov     edx, [ecx+8]
.text$mn:0000B67E                 push    edx             ; hWndParent
.text$mn:0000B67F                 push    offset TemplateName ; lpTemplateName
.text$mn:0000B684                 mov     eax, [ebp+dwInitParam]
.text$mn:0000B687                 mov     ecx, [eax+4]
.text$mn:0000B68A                 push    ecx             ; hInstance
.text$mn:0000B68B                 call    dword ptr ds:__imp__DialogBoxParamW@20 ; DialogBoxParamW(x,x,x,x,x)
.text$mn:0000B691                 mov     esp, ebp
.text$mn:0000B693                 pop     ebp
.text$mn:0000B694                 retn
.text$mn:0000B694 ?doDialog@ScintillaKeyMap@@UAEHXZ endp
.text$mn:0000B694
.text$mn:0000B694 ; ---------------------------------------------------------------------------
.text$mn:0000B695                 align 4
.text$mn:0000B695 _text$mn        ends
.text$mn:0000B695
.text$mn:0000B698 ; ===========================================================================
.text$mn:0000B698
.text$mn:0000B698 ; Segment type: Pure code
.text$mn:0000B698 ; Segment permissions: Read/Execute
.text$mn:0000B698 _text$mn        segment para public 'CODE' use32
.text$mn:0000B698                 assume cs:_text$mn
.text$mn:0000B698                 ;org 0B698h
.text$mn:0000B698 ; COMDAT (pick any)
.text$mn:0000B698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B698
.text$mn:0000B698 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B698
.text$mn:0000B698 ; Attributes: bp-based frame
.text$mn:0000B698
.text$mn:0000B698 ; int __thiscall Shortcut::doDialog(Shortcut *__hidden this)
.text$mn:0000B698                 public ?doDialog@Shortcut@@UAEHXZ
.text$mn:0000B698 ?doDialog@Shortcut@@UAEHXZ proc near    ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+2B9p
.text$mn:0000B698                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+426p ...
.text$mn:0000B698
.text$mn:0000B698 dwInitParam     = dword ptr -4
.text$mn:0000B698
.text$mn:0000B698                 push    ebp
.text$mn:0000B699                 mov     ebp, esp
.text$mn:0000B69B                 push    ecx
.text$mn:0000B69C                 mov     [ebp+dwInitParam], ecx
.text$mn:0000B69F                 mov     eax, [ebp+dwInitParam]
.text$mn:0000B6A2                 push    eax             ; dwInitParam
.text$mn:0000B6A3                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:0000B6A8                 mov     ecx, [ebp+dwInitParam]
.text$mn:0000B6AB                 mov     edx, [ecx+8]
.text$mn:0000B6AE                 push    edx             ; hWndParent
.text$mn:0000B6AF                 push    (offset loc_1383+5) ; lpTemplateName
.text$mn:0000B6B4                 mov     eax, [ebp+dwInitParam]
.text$mn:0000B6B7                 mov     ecx, [eax+4]
.text$mn:0000B6BA                 push    ecx             ; hInstance
.text$mn:0000B6BB                 call    dword ptr ds:__imp__DialogBoxParamW@20 ; DialogBoxParamW(x,x,x,x,x)
.text$mn:0000B6C1                 mov     esp, ebp
.text$mn:0000B6C3                 pop     ebp
.text$mn:0000B6C4                 retn
.text$mn:0000B6C4 ?doDialog@Shortcut@@UAEHXZ endp
.text$mn:0000B6C4
.text$mn:0000B6C4 ; ---------------------------------------------------------------------------
.text$mn:0000B6C5                 align 4
.text$mn:0000B6C5 _text$mn        ends
.text$mn:0000B6C5
.text$mn:0000B6C8 ; ===========================================================================
.text$mn:0000B6C8
.text$mn:0000B6C8 ; Segment type: Pure code
.text$mn:0000B6C8 ; Segment permissions: Read/Execute
.text$mn:0000B6C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6C8                 assume cs:_text$mn
.text$mn:0000B6C8                 ;org 0B6C8h
.text$mn:0000B6C8 ; COMDAT (pick any)
.text$mn:0000B6C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B6C8
.text$mn:0000B6C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6C8
.text$mn:0000B6C8 ; Attributes: bp-based frame
.text$mn:0000B6C8
.text$mn:0000B6C8 ; public: bool __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::empty(void)const
.text$mn:0000B6C8                 public ?empty@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE_NXZ
.text$mn:0000B6C8 ?empty@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE_NXZ proc near
.text$mn:0000B6C8                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+90p
.text$mn:0000B6C8
.text$mn:0000B6C8 var_8           = dword ptr -8
.text$mn:0000B6C8 var_4           = dword ptr -4
.text$mn:0000B6C8
.text$mn:0000B6C8                 push    ebp
.text$mn:0000B6C9                 mov     ebp, esp
.text$mn:0000B6CB                 sub     esp, 8
.text$mn:0000B6CE                 mov     [ebp+var_4], ecx
.text$mn:0000B6D1                 mov     eax, [ebp+var_4]
.text$mn:0000B6D4                 mov     ecx, [ebp+var_4]
.text$mn:0000B6D7                 mov     edx, [eax+4]
.text$mn:0000B6DA                 cmp     edx, [ecx+8]
.text$mn:0000B6DD                 jnz     short loc_B6E8
.text$mn:0000B6DF                 mov     [ebp+var_8], 1
.text$mn:0000B6E6                 jmp     short loc_B6EF
.text$mn:0000B6E8 ; ---------------------------------------------------------------------------
.text$mn:0000B6E8
.text$mn:0000B6E8 loc_B6E8:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::empty(void)+15j
.text$mn:0000B6E8                 mov     [ebp+var_8], 0
.text$mn:0000B6EF
.text$mn:0000B6EF loc_B6EF:                               ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::empty(void)+1Ej
.text$mn:0000B6EF                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000B6F2                 mov     esp, ebp
.text$mn:0000B6F4                 pop     ebp
.text$mn:0000B6F5                 retn
.text$mn:0000B6F5 ?empty@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE_NXZ endp
.text$mn:0000B6F5
.text$mn:0000B6F5 ; ---------------------------------------------------------------------------
.text$mn:0000B6F6                 align 4
.text$mn:0000B6F6 _text$mn        ends
.text$mn:0000B6F6
.text$mn:0000B6F8 ; ===========================================================================
.text$mn:0000B6F8
.text$mn:0000B6F8 ; Segment type: Pure code
.text$mn:0000B6F8 ; Segment permissions: Read/Execute
.text$mn:0000B6F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6F8                 assume cs:_text$mn
.text$mn:0000B6F8                 ;org 0B6F8h
.text$mn:0000B6F8 ; COMDAT (pick any)
.text$mn:0000B6F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B6F8
.text$mn:0000B6F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6F8
.text$mn:0000B6F8 ; Attributes: bp-based frame
.text$mn:0000B6F8
.text$mn:0000B6F8 ; public: bool __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::empty(void)const
.text$mn:0000B6F8                 public ?empty@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE_NXZ
.text$mn:0000B6F8 ?empty@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE_NXZ proc near
.text$mn:0000B6F8                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+90p
.text$mn:0000B6F8
.text$mn:0000B6F8 var_8           = dword ptr -8
.text$mn:0000B6F8 var_4           = dword ptr -4
.text$mn:0000B6F8
.text$mn:0000B6F8                 push    ebp
.text$mn:0000B6F9                 mov     ebp, esp
.text$mn:0000B6FB                 sub     esp, 8
.text$mn:0000B6FE                 mov     [ebp+var_4], ecx
.text$mn:0000B701                 mov     eax, [ebp+var_4]
.text$mn:0000B704                 mov     ecx, [ebp+var_4]
.text$mn:0000B707                 mov     edx, [eax+4]
.text$mn:0000B70A                 cmp     edx, [ecx+8]
.text$mn:0000B70D                 jnz     short loc_B718
.text$mn:0000B70F                 mov     [ebp+var_8], 1
.text$mn:0000B716                 jmp     short loc_B71F
.text$mn:0000B718 ; ---------------------------------------------------------------------------
.text$mn:0000B718
.text$mn:0000B718 loc_B718:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::empty(void)+15j
.text$mn:0000B718                 mov     [ebp+var_8], 0
.text$mn:0000B71F
.text$mn:0000B71F loc_B71F:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::empty(void)+1Ej
.text$mn:0000B71F                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000B722                 mov     esp, ebp
.text$mn:0000B724                 pop     ebp
.text$mn:0000B725                 retn
.text$mn:0000B725 ?empty@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE_NXZ endp
.text$mn:0000B725
.text$mn:0000B725 ; ---------------------------------------------------------------------------
.text$mn:0000B726                 align 4
.text$mn:0000B726 _text$mn        ends
.text$mn:0000B726
.text$mn:0000B728 ; ===========================================================================
.text$mn:0000B728
.text$mn:0000B728 ; Segment type: Pure code
.text$mn:0000B728 ; Segment permissions: Read/Execute
.text$mn:0000B728 _text$mn        segment para public 'CODE' use32
.text$mn:0000B728                 assume cs:_text$mn
.text$mn:0000B728                 ;org 0B728h
.text$mn:0000B728 ; COMDAT (pick any)
.text$mn:0000B728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B728
.text$mn:0000B728 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B728
.text$mn:0000B728 ; Attributes: bp-based frame
.text$mn:0000B728
.text$mn:0000B728 ; void __thiscall ContextMenu::enableItem(ContextMenu *this, UINT uIDEnableItem, bool)
.text$mn:0000B728                 public ?enableItem@ContextMenu@@QBEXH_N@Z
.text$mn:0000B728 ?enableItem@ContextMenu@@QBEXH_N@Z proc near
.text$mn:0000B728                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+109Ep
.text$mn:0000B728                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+10B2p
.text$mn:0000B728
.text$mn:0000B728 var_C           = dword ptr -0Ch
.text$mn:0000B728 uEnable         = dword ptr -8
.text$mn:0000B728 var_4           = dword ptr -4
.text$mn:0000B728 uIDEnableItem   = dword ptr  8
.text$mn:0000B728 arg_4           = byte ptr  0Ch
.text$mn:0000B728
.text$mn:0000B728                 push    ebp
.text$mn:0000B729                 mov     ebp, esp
.text$mn:0000B72B                 sub     esp, 0Ch
.text$mn:0000B72E                 mov     [ebp+var_C], ecx
.text$mn:0000B731                 movzx   eax, [ebp+arg_4]
.text$mn:0000B735                 test    eax, eax
.text$mn:0000B737                 jz      short loc_B742
.text$mn:0000B739                 mov     [ebp+var_4], 0
.text$mn:0000B740                 jmp     short loc_B749
.text$mn:0000B742 ; ---------------------------------------------------------------------------
.text$mn:0000B742
.text$mn:0000B742 loc_B742:                               ; CODE XREF: ContextMenu::enableItem(int,bool)+Fj
.text$mn:0000B742                 mov     [ebp+var_4], 3
.text$mn:0000B749
.text$mn:0000B749 loc_B749:                               ; CODE XREF: ContextMenu::enableItem(int,bool)+18j
.text$mn:0000B749                 mov     ecx, [ebp+var_4]
.text$mn:0000B74C                 mov     [ebp+uEnable], ecx
.text$mn:0000B74F                 mov     edx, [ebp+uEnable]
.text$mn:0000B752                 push    edx             ; uEnable
.text$mn:0000B753                 mov     eax, [ebp+uIDEnableItem]
.text$mn:0000B756                 push    eax             ; uIDEnableItem
.text$mn:0000B757                 mov     ecx, [ebp+var_C]
.text$mn:0000B75A                 mov     edx, [ecx+4]
.text$mn:0000B75D                 push    edx             ; hMenu
.text$mn:0000B75E                 call    dword ptr ds:__imp__EnableMenuItem@12 ; EnableMenuItem(x,x,x)
.text$mn:0000B764                 mov     esp, ebp
.text$mn:0000B766                 pop     ebp
.text$mn:0000B767                 retn    8
.text$mn:0000B767 ?enableItem@ContextMenu@@QBEXH_N@Z endp
.text$mn:0000B767
.text$mn:0000B767 ; ---------------------------------------------------------------------------
.text$mn:0000B76A                 align 4
.text$mn:0000B76A _text$mn        ends
.text$mn:0000B76A
.text$mn:0000B76C ; ===========================================================================
.text$mn:0000B76C
.text$mn:0000B76C ; Segment type: Pure code
.text$mn:0000B76C ; Segment permissions: Read/Execute
.text$mn:0000B76C _text$mn        segment para public 'CODE' use32
.text$mn:0000B76C                 assume cs:_text$mn
.text$mn:0000B76C                 ;org 0B76Ch
.text$mn:0000B76C ; COMDAT (pick any)
.text$mn:0000B76C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B76C
.text$mn:0000B76C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B76C
.text$mn:0000B76C ; Attributes: bp-based frame
.text$mn:0000B76C
.text$mn:0000B76C ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct KeyCombo>>> __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::end(void)const
.text$mn:0000B76C                 public ?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.text$mn:0000B76C ?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ proc near
.text$mn:0000B76C                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+89p
.text$mn:0000B76C
.text$mn:0000B76C var_14          = dword ptr -14h
.text$mn:0000B76C var_10          = dword ptr -10h
.text$mn:0000B76C var_C           = dword ptr -0Ch
.text$mn:0000B76C var_4           = dword ptr -4
.text$mn:0000B76C arg_0           = dword ptr  8
.text$mn:0000B76C
.text$mn:0000B76C                 push    ebp
.text$mn:0000B76D                 mov     ebp, esp
.text$mn:0000B76F                 push    0FFFFFFFFh
.text$mn:0000B771                 push    offset __ehhandler$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.text$mn:0000B776                 mov     eax, large fs:0
.text$mn:0000B77C                 push    eax
.text$mn:0000B77D                 sub     esp, 8
.text$mn:0000B780                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B785                 xor     eax, ebp
.text$mn:0000B787                 push    eax
.text$mn:0000B788                 lea     eax, [ebp+var_C]
.text$mn:0000B78B                 mov     large fs:0, eax
.text$mn:0000B791                 mov     [ebp+var_10], ecx
.text$mn:0000B794                 mov     [ebp+var_14], 0
.text$mn:0000B79B                 mov     eax, [ebp+var_10]
.text$mn:0000B79E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B79F                 mov     ecx, [ebp+var_10]
.text$mn:0000B7A2                 mov     edx, [ecx+8]
.text$mn:0000B7A5                 push    edx             ; int
.text$mn:0000B7A6                 mov     ecx, [ebp+arg_0]
.text$mn:0000B7A9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(KeyCombo *,std::_Container_base12 const *)
.text$mn:0000B7AE                 mov     [ebp+var_4], 0
.text$mn:0000B7B5                 mov     eax, [ebp+var_14]
.text$mn:0000B7B8                 or      eax, 1
.text$mn:0000B7BB                 mov     [ebp+var_14], eax
.text$mn:0000B7BE                 mov     eax, [ebp+arg_0]
.text$mn:0000B7C1                 mov     ecx, [ebp+var_C]
.text$mn:0000B7C4                 mov     large fs:0, ecx
.text$mn:0000B7CB                 pop     ecx
.text$mn:0000B7CC                 mov     esp, ebp
.text$mn:0000B7CE                 pop     ebp
.text$mn:0000B7CF                 retn    4
.text$mn:0000B7CF ?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ endp
.text$mn:0000B7CF
.text$mn:0000B7CF ; ---------------------------------------------------------------------------
.text$mn:0000B7D2                 align 4
.text$mn:0000B7D2 _text$mn        ends
.text$mn:0000B7D2
.text$x:0000B7D4 ; ===========================================================================
.text$x:0000B7D4
.text$x:0000B7D4 ; Segment type: Pure code
.text$x:0000B7D4 ; Segment permissions: Read/Execute
.text$x:0000B7D4 _text$x         segment para public 'CODE' use32
.text$x:0000B7D4                 assume cs:_text$x
.text$x:0000B7D4                 ;org 0B7D4h
.text$x:0000B7D4 ; COMDAT (pick associative to section at B76C)
.text$x:0000B7D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B7D4
.text$x:0000B7D4 ; =============== S U B R O U T I N E =======================================
.text$x:0000B7D4
.text$x:0000B7D4
.text$x:0000B7D4 __unwindfunclet$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000B7D4                                         ; DATA XREF: .xdata$x:0000D4B0o
.text$x:0000B7D4                 mov     eax, [ebp-14h]
.text$x:0000B7D7                 and     eax, 1
.text$x:0000B7DA                 jz      $LN4_0
.text$x:0000B7E0                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B7E4                 mov     ecx, [ebp+8]
.text$x:0000B7E7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<KeyCombo>>>(void)
.text$x:0000B7EC ; ---------------------------------------------------------------------------
.text$x:0000B7EC
.text$x:0000B7EC $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0+6j
.text$x:0000B7EC                 retn
.text$x:0000B7EC __unwindfunclet$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0 endp
.text$x:0000B7EC
.text$x:0000B7ED
.text$x:0000B7ED ; =============== S U B R O U T I N E =======================================
.text$x:0000B7ED
.text$x:0000B7ED
.text$x:0000B7ED __ehhandler$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ proc near
.text$x:0000B7ED                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::end(void)+5o
.text$x:0000B7ED
.text$x:0000B7ED arg_4           = dword ptr  8
.text$x:0000B7ED
.text$x:0000B7ED                 mov     edx, [esp+arg_4]
.text$x:0000B7F1                 lea     eax, [edx+0Ch]
.text$x:0000B7F4                 mov     ecx, [edx-0Ch]
.text$x:0000B7F7                 xor     ecx, eax
.text$x:0000B7F9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B7FE                 mov     eax, offset __ehfuncinfo$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.text$x:0000B803                 jmp     ___CxxFrameHandler3
.text$x:0000B803 __ehhandler$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ endp
.text$x:0000B803
.text$x:0000B803 _text$x         ends
.text$x:0000B803
.text$mn:0000B808 ; ===========================================================================
.text$mn:0000B808
.text$mn:0000B808 ; Segment type: Pure code
.text$mn:0000B808 ; Segment permissions: Read/Execute
.text$mn:0000B808 _text$mn        segment para public 'CODE' use32
.text$mn:0000B808                 assume cs:_text$mn
.text$mn:0000B808                 ;org 0B808h
.text$mn:0000B808 ; COMDAT (pick any)
.text$mn:0000B808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B808
.text$mn:0000B808 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B808
.text$mn:0000B808 ; Attributes: bp-based frame
.text$mn:0000B808
.text$mn:0000B808 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct recordedMacroStep>>> __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::end(void)const
.text$mn:0000B808                 public ?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.text$mn:0000B808 ?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ proc near
.text$mn:0000B808                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+89p
.text$mn:0000B808
.text$mn:0000B808 var_14          = dword ptr -14h
.text$mn:0000B808 var_10          = dword ptr -10h
.text$mn:0000B808 var_C           = dword ptr -0Ch
.text$mn:0000B808 var_4           = dword ptr -4
.text$mn:0000B808 arg_0           = dword ptr  8
.text$mn:0000B808
.text$mn:0000B808                 push    ebp
.text$mn:0000B809                 mov     ebp, esp
.text$mn:0000B80B                 push    0FFFFFFFFh
.text$mn:0000B80D                 push    offset __ehhandler$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.text$mn:0000B812                 mov     eax, large fs:0
.text$mn:0000B818                 push    eax
.text$mn:0000B819                 sub     esp, 8
.text$mn:0000B81C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B821                 xor     eax, ebp
.text$mn:0000B823                 push    eax
.text$mn:0000B824                 lea     eax, [ebp+var_C]
.text$mn:0000B827                 mov     large fs:0, eax
.text$mn:0000B82D                 mov     [ebp+var_10], ecx
.text$mn:0000B830                 mov     [ebp+var_14], 0
.text$mn:0000B837                 mov     eax, [ebp+var_10]
.text$mn:0000B83A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000B83B                 mov     ecx, [ebp+var_10]
.text$mn:0000B83E                 mov     edx, [ecx+8]
.text$mn:0000B841                 push    edx             ; int
.text$mn:0000B842                 mov     ecx, [ebp+arg_0]
.text$mn:0000B845                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(recordedMacroStep *,std::_Container_base12 const *)
.text$mn:0000B84A                 mov     [ebp+var_4], 0
.text$mn:0000B851                 mov     eax, [ebp+var_14]
.text$mn:0000B854                 or      eax, 1
.text$mn:0000B857                 mov     [ebp+var_14], eax
.text$mn:0000B85A                 mov     eax, [ebp+arg_0]
.text$mn:0000B85D                 mov     ecx, [ebp+var_C]
.text$mn:0000B860                 mov     large fs:0, ecx
.text$mn:0000B867                 pop     ecx
.text$mn:0000B868                 mov     esp, ebp
.text$mn:0000B86A                 pop     ebp
.text$mn:0000B86B                 retn    4
.text$mn:0000B86B ?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ endp
.text$mn:0000B86B
.text$mn:0000B86B ; ---------------------------------------------------------------------------
.text$mn:0000B86E                 align 10h
.text$mn:0000B86E _text$mn        ends
.text$mn:0000B86E
.text$x:0000B870 ; ===========================================================================
.text$x:0000B870
.text$x:0000B870 ; Segment type: Pure code
.text$x:0000B870 ; Segment permissions: Read/Execute
.text$x:0000B870 _text$x         segment para public 'CODE' use32
.text$x:0000B870                 assume cs:_text$x
.text$x:0000B870                 ;org 0B870h
.text$x:0000B870 ; COMDAT (pick associative to section at B808)
.text$x:0000B870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B870
.text$x:0000B870 ; =============== S U B R O U T I N E =======================================
.text$x:0000B870
.text$x:0000B870
.text$x:0000B870 __unwindfunclet$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0 proc near
.text$x:0000B870                                         ; DATA XREF: .xdata$x:0000D8A0o
.text$x:0000B870                 mov     eax, [ebp-14h]
.text$x:0000B873                 and     eax, 1
.text$x:0000B876                 jz      $LN4_2
.text$x:0000B87C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000B880                 mov     ecx, [ebp+8]
.text$x:0000B883                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<recordedMacroStep>>>(void)
.text$x:0000B888 ; ---------------------------------------------------------------------------
.text$x:0000B888
.text$x:0000B888 $LN4_2:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0+6j
.text$x:0000B888                 retn
.text$x:0000B888 __unwindfunclet$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0 endp
.text$x:0000B888
.text$x:0000B889
.text$x:0000B889 ; =============== S U B R O U T I N E =======================================
.text$x:0000B889
.text$x:0000B889
.text$x:0000B889 __ehhandler$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ proc near
.text$x:0000B889                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::end(void)+5o
.text$x:0000B889
.text$x:0000B889 arg_4           = dword ptr  8
.text$x:0000B889
.text$x:0000B889                 mov     edx, [esp+arg_4]
.text$x:0000B88D                 lea     eax, [edx+0Ch]
.text$x:0000B890                 mov     ecx, [edx-0Ch]
.text$x:0000B893                 xor     ecx, eax
.text$x:0000B895                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B89A                 mov     eax, offset __ehfuncinfo$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.text$x:0000B89F                 jmp     ___CxxFrameHandler3
.text$x:0000B89F __ehhandler$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ endp
.text$x:0000B89F
.text$x:0000B89F _text$x         ends
.text$x:0000B89F
.text$mn:0000B8A4 ; ===========================================================================
.text$mn:0000B8A4
.text$mn:0000B8A4 ; Segment type: Pure code
.text$mn:0000B8A4 ; Segment permissions: Read/Execute
.text$mn:0000B8A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8A4                 assume cs:_text$mn
.text$mn:0000B8A4                 ;org 0B8A4h
.text$mn:0000B8A4 ; COMDAT (pick any)
.text$mn:0000B8A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B8A4
.text$mn:0000B8A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8A4
.text$mn:0000B8A4 ; Attributes: bp-based frame
.text$mn:0000B8A4
.text$mn:0000B8A4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000B8A4                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000B8A4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000B8A4                                         ; DATA XREF: .rdata:0000E8C4o
.text$mn:0000B8A4                                         ; .rdata:0000E8E0o ...
.text$mn:0000B8A4
.text$mn:0000B8A4 var_8           = dword ptr -8
.text$mn:0000B8A4 var_4           = dword ptr -4
.text$mn:0000B8A4 arg_0           = dword ptr  8
.text$mn:0000B8A4 arg_4           = dword ptr  0Ch
.text$mn:0000B8A4
.text$mn:0000B8A4                 push    ebp
.text$mn:0000B8A5                 mov     ebp, esp
.text$mn:0000B8A7                 sub     esp, 8
.text$mn:0000B8AA                 mov     [ebp+var_8], ecx
.text$mn:0000B8AD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B8B0                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000B8B5                 push    eax
.text$mn:0000B8B6                 mov     ecx, [ebp+var_8]
.text$mn:0000B8B9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000B8BE                 movzx   eax, al
.text$mn:0000B8C1                 test    eax, eax
.text$mn:0000B8C3                 jz      short loc_B8DB
.text$mn:0000B8C5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000B8C8                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000B8CD                 cmp     eax, [ebp+arg_4]
.text$mn:0000B8D0                 jnz     short loc_B8DB
.text$mn:0000B8D2                 mov     [ebp+var_4], 1
.text$mn:0000B8D9                 jmp     short loc_B8E2
.text$mn:0000B8DB ; ---------------------------------------------------------------------------
.text$mn:0000B8DB
.text$mn:0000B8DB loc_B8DB:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000B8DB                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000B8DB                 mov     [ebp+var_4], 0
.text$mn:0000B8E2
.text$mn:0000B8E2 loc_B8E2:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000B8E2                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000B8E5                 mov     esp, ebp
.text$mn:0000B8E7                 pop     ebp
.text$mn:0000B8E8                 retn    8
.text$mn:0000B8E8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000B8E8
.text$mn:0000B8E8 ; ---------------------------------------------------------------------------
.text$mn:0000B8EB                 align 4
.text$mn:0000B8EB _text$mn        ends
.text$mn:0000B8EB
.text$mn:0000B8EC ; ===========================================================================
.text$mn:0000B8EC
.text$mn:0000B8EC ; Segment type: Pure code
.text$mn:0000B8EC ; Segment permissions: Read/Execute
.text$mn:0000B8EC _text$mn        segment para public 'CODE' use32
.text$mn:0000B8EC                 assume cs:_text$mn
.text$mn:0000B8EC                 ;org 0B8ECh
.text$mn:0000B8EC ; COMDAT (pick any)
.text$mn:0000B8EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B8EC
.text$mn:0000B8EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8EC
.text$mn:0000B8EC ; Attributes: bp-based frame
.text$mn:0000B8EC
.text$mn:0000B8EC ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000B8EC                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000B8EC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000B8EC                                         ; DATA XREF: .rdata:0000E8C8o
.text$mn:0000B8EC                                         ; .rdata:0000E8E4o ...
.text$mn:0000B8EC
.text$mn:0000B8EC var_C           = byte ptr -0Ch
.text$mn:0000B8EC var_4           = dword ptr -4
.text$mn:0000B8EC arg_0           = dword ptr  8
.text$mn:0000B8EC arg_4           = dword ptr  0Ch
.text$mn:0000B8EC
.text$mn:0000B8EC                 push    ebp
.text$mn:0000B8ED                 mov     ebp, esp
.text$mn:0000B8EF                 sub     esp, 0Ch
.text$mn:0000B8F2                 mov     [ebp+var_4], ecx
.text$mn:0000B8F5                 mov     eax, [ebp+arg_4]
.text$mn:0000B8F8                 push    eax             ; std::error_condition *
.text$mn:0000B8F9                 mov     ecx, [ebp+arg_0]
.text$mn:0000B8FC                 push    ecx
.text$mn:0000B8FD                 lea     edx, [ebp+var_C]
.text$mn:0000B900                 push    edx
.text$mn:0000B901                 mov     eax, [ebp+var_4]
.text$mn:0000B904                 mov     edx, [eax]
.text$mn:0000B906                 mov     ecx, [ebp+var_4]
.text$mn:0000B909                 mov     eax, [edx+0Ch]
.text$mn:0000B90C                 call    eax
.text$mn:0000B90E                 mov     ecx, eax
.text$mn:0000B910                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:0000B915                 mov     esp, ebp
.text$mn:0000B917                 pop     ebp
.text$mn:0000B918                 retn    8
.text$mn:0000B918 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000B918
.text$mn:0000B918 ; ---------------------------------------------------------------------------
.text$mn:0000B91B                 align 4
.text$mn:0000B91B _text$mn        ends
.text$mn:0000B91B
.text$mn:0000B91C ; ===========================================================================
.text$mn:0000B91C
.text$mn:0000B91C ; Segment type: Pure code
.text$mn:0000B91C ; Segment permissions: Read/Execute
.text$mn:0000B91C _text$mn        segment para public 'CODE' use32
.text$mn:0000B91C                 assume cs:_text$mn
.text$mn:0000B91C                 ;org 0B91Ch
.text$mn:0000B91C ; COMDAT (pick any)
.text$mn:0000B91C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B91C
.text$mn:0000B91C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B91C
.text$mn:0000B91C ; Attributes: bp-based frame
.text$mn:0000B91C
.text$mn:0000B91C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000B91C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000B91C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000B91C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000B91C
.text$mn:0000B91C var_4           = dword ptr -4
.text$mn:0000B91C arg_0           = dword ptr  8
.text$mn:0000B91C
.text$mn:0000B91C                 push    ebp
.text$mn:0000B91D                 mov     ebp, esp
.text$mn:0000B91F                 push    ecx
.text$mn:0000B920                 mov     [ebp+var_4], ecx
.text$mn:0000B923                 mov     eax, [ebp+var_4]
.text$mn:0000B926                 mov     ecx, [eax+14h]
.text$mn:0000B929                 cmp     ecx, [ebp+arg_0]
.text$mn:0000B92C                 jnb     short loc_B936
.text$mn:0000B92E                 mov     ecx, [ebp+var_4]
.text$mn:0000B931                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000B936
.text$mn:0000B936 loc_B936:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000B936                 mov     edx, [ebp+arg_0]
.text$mn:0000B939                 push    edx
.text$mn:0000B93A                 mov     ecx, [ebp+var_4]
.text$mn:0000B93D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000B942                 mov     eax, [ebp+var_4]
.text$mn:0000B945                 mov     esp, ebp
.text$mn:0000B947                 pop     ebp
.text$mn:0000B948                 retn    4
.text$mn:0000B948 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000B948
.text$mn:0000B948 ; ---------------------------------------------------------------------------
.text$mn:0000B94B                 align 4
.text$mn:0000B94B _text$mn        ends
.text$mn:0000B94B
.text$mn:0000B94C ; ===========================================================================
.text$mn:0000B94C
.text$mn:0000B94C ; Segment type: Pure code
.text$mn:0000B94C ; Segment permissions: Read/Execute
.text$mn:0000B94C _text$mn        segment para public 'CODE' use32
.text$mn:0000B94C                 assume cs:_text$mn
.text$mn:0000B94C                 ;org 0B94Ch
.text$mn:0000B94C ; COMDAT (pick any)
.text$mn:0000B94C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B94C
.text$mn:0000B94C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B94C
.text$mn:0000B94C ; Attributes: bp-based frame
.text$mn:0000B94C
.text$mn:0000B94C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000B94C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000B94C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000B94C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000B94C
.text$mn:0000B94C var_C           = dword ptr -0Ch
.text$mn:0000B94C Dst             = dword ptr -8
.text$mn:0000B94C var_4           = dword ptr -4
.text$mn:0000B94C arg_0           = dword ptr  8
.text$mn:0000B94C arg_4           = dword ptr  0Ch
.text$mn:0000B94C
.text$mn:0000B94C                 push    ebp
.text$mn:0000B94D                 mov     ebp, esp
.text$mn:0000B94F                 sub     esp, 0Ch
.text$mn:0000B952                 mov     [ebp+var_4], ecx
.text$mn:0000B955                 mov     eax, [ebp+var_4]
.text$mn:0000B958                 mov     ecx, [eax+14h]
.text$mn:0000B95B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000B95E                 jnb     short loc_B968
.text$mn:0000B960                 mov     ecx, [ebp+var_4]
.text$mn:0000B963                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000B968
.text$mn:0000B968 loc_B968:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000B968                 mov     edx, [ebp+var_4]
.text$mn:0000B96B                 mov     eax, [edx+14h]
.text$mn:0000B96E                 sub     eax, [ebp+arg_0]
.text$mn:0000B971                 cmp     eax, [ebp+arg_4]
.text$mn:0000B974                 ja      short loc_B984
.text$mn:0000B976                 mov     ecx, [ebp+arg_0]
.text$mn:0000B979                 push    ecx
.text$mn:0000B97A                 mov     ecx, [ebp+var_4]
.text$mn:0000B97D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000B982                 jmp     short loc_B9CA
.text$mn:0000B984 ; ---------------------------------------------------------------------------
.text$mn:0000B984
.text$mn:0000B984 loc_B984:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000B984                 cmp     [ebp+arg_4], 0
.text$mn:0000B988                 jbe     short loc_B9CA
.text$mn:0000B98A                 mov     ecx, [ebp+var_4]
.text$mn:0000B98D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000B992                 add     eax, [ebp+arg_0]
.text$mn:0000B995                 mov     [ebp+Dst], eax
.text$mn:0000B998                 mov     edx, [ebp+var_4]
.text$mn:0000B99B                 mov     eax, [edx+14h]
.text$mn:0000B99E                 sub     eax, [ebp+arg_4]
.text$mn:0000B9A1                 mov     [ebp+var_C], eax
.text$mn:0000B9A4                 mov     ecx, [ebp+var_C]
.text$mn:0000B9A7                 sub     ecx, [ebp+arg_0]
.text$mn:0000B9AA                 push    ecx             ; Size
.text$mn:0000B9AB                 mov     edx, [ebp+Dst]
.text$mn:0000B9AE                 add     edx, [ebp+arg_4]
.text$mn:0000B9B1                 push    edx             ; Src
.text$mn:0000B9B2                 mov     eax, [ebp+Dst]
.text$mn:0000B9B5                 push    eax             ; Dst
.text$mn:0000B9B6                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000B9BB                 add     esp, 0Ch
.text$mn:0000B9BE                 mov     ecx, [ebp+var_C]
.text$mn:0000B9C1                 push    ecx
.text$mn:0000B9C2                 mov     ecx, [ebp+var_4]
.text$mn:0000B9C5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000B9CA
.text$mn:0000B9CA loc_B9CA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000B9CA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000B9CA                 mov     eax, [ebp+var_4]
.text$mn:0000B9CD                 mov     esp, ebp
.text$mn:0000B9CF                 pop     ebp
.text$mn:0000B9D0                 retn    8
.text$mn:0000B9D0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000B9D0
.text$mn:0000B9D0 ; ---------------------------------------------------------------------------
.text$mn:0000B9D3                 align 4
.text$mn:0000B9D3 _text$mn        ends
.text$mn:0000B9D3
.text$mn:0000B9D4 ; ===========================================================================
.text$mn:0000B9D4
.text$mn:0000B9D4 ; Segment type: Pure code
.text$mn:0000B9D4 ; Segment permissions: Read/Execute
.text$mn:0000B9D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B9D4                 assume cs:_text$mn
.text$mn:0000B9D4                 ;org 0B9D4h
.text$mn:0000B9D4 ; COMDAT (pick any)
.text$mn:0000B9D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000B9D4
.text$mn:0000B9D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B9D4
.text$mn:0000B9D4 ; Attributes: bp-based frame
.text$mn:0000B9D4
.text$mn:0000B9D4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:0000B9D4                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:0000B9D4 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000B9D4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:0000B9D4
.text$mn:0000B9D4 var_4           = dword ptr -4
.text$mn:0000B9D4 arg_0           = dword ptr  8
.text$mn:0000B9D4
.text$mn:0000B9D4                 push    ebp
.text$mn:0000B9D5                 mov     ebp, esp
.text$mn:0000B9D7                 push    ecx
.text$mn:0000B9D8                 mov     [ebp+var_4], ecx
.text$mn:0000B9DB                 mov     eax, [ebp+var_4]
.text$mn:0000B9DE                 mov     ecx, [eax+14h]
.text$mn:0000B9E1                 cmp     ecx, [ebp+arg_0]
.text$mn:0000B9E4                 jnb     short loc_B9EE
.text$mn:0000B9E6                 mov     ecx, [ebp+var_4]
.text$mn:0000B9E9                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000B9EE
.text$mn:0000B9EE loc_B9EE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000B9EE                 mov     edx, [ebp+arg_0]
.text$mn:0000B9F1                 push    edx
.text$mn:0000B9F2                 mov     ecx, [ebp+var_4]
.text$mn:0000B9F5                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000B9FA                 mov     eax, [ebp+var_4]
.text$mn:0000B9FD                 mov     esp, ebp
.text$mn:0000B9FF                 pop     ebp
.text$mn:0000BA00                 retn    4
.text$mn:0000BA00 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000BA00
.text$mn:0000BA00 ; ---------------------------------------------------------------------------
.text$mn:0000BA03                 align 4
.text$mn:0000BA03 _text$mn        ends
.text$mn:0000BA03
.text$mn:0000BA04 ; ===========================================================================
.text$mn:0000BA04
.text$mn:0000BA04 ; Segment type: Pure code
.text$mn:0000BA04 ; Segment permissions: Read/Execute
.text$mn:0000BA04 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA04                 assume cs:_text$mn
.text$mn:0000BA04                 ;org 0BA04h
.text$mn:0000BA04 ; COMDAT (pick any)
.text$mn:0000BA04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BA04
.text$mn:0000BA04 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA04
.text$mn:0000BA04 ; Attributes: bp-based frame
.text$mn:0000BA04
.text$mn:0000BA04 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0000BA04                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0000BA04 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000BA04                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0000BA04
.text$mn:0000BA04 var_C           = dword ptr -0Ch
.text$mn:0000BA04 Dst             = dword ptr -8
.text$mn:0000BA04 var_4           = dword ptr -4
.text$mn:0000BA04 arg_0           = dword ptr  8
.text$mn:0000BA04 arg_4           = dword ptr  0Ch
.text$mn:0000BA04
.text$mn:0000BA04                 push    ebp
.text$mn:0000BA05                 mov     ebp, esp
.text$mn:0000BA07                 sub     esp, 0Ch
.text$mn:0000BA0A                 mov     [ebp+var_4], ecx
.text$mn:0000BA0D                 mov     eax, [ebp+var_4]
.text$mn:0000BA10                 mov     ecx, [eax+14h]
.text$mn:0000BA13                 cmp     ecx, [ebp+arg_0]
.text$mn:0000BA16                 jnb     short loc_BA20
.text$mn:0000BA18                 mov     ecx, [ebp+var_4]
.text$mn:0000BA1B                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000BA20
.text$mn:0000BA20 loc_BA20:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:0000BA20                 mov     edx, [ebp+var_4]
.text$mn:0000BA23                 mov     eax, [edx+14h]
.text$mn:0000BA26                 sub     eax, [ebp+arg_0]
.text$mn:0000BA29                 cmp     eax, [ebp+arg_4]
.text$mn:0000BA2C                 ja      short loc_BA3C
.text$mn:0000BA2E                 mov     ecx, [ebp+arg_0]
.text$mn:0000BA31                 push    ecx
.text$mn:0000BA32                 mov     ecx, [ebp+var_4]
.text$mn:0000BA35                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000BA3A                 jmp     short loc_BA88
.text$mn:0000BA3C ; ---------------------------------------------------------------------------
.text$mn:0000BA3C
.text$mn:0000BA3C loc_BA3C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:0000BA3C                 cmp     [ebp+arg_4], 0
.text$mn:0000BA40                 jbe     short loc_BA88
.text$mn:0000BA42                 mov     ecx, [ebp+var_4]
.text$mn:0000BA45                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000BA4A                 mov     edx, [ebp+arg_0]
.text$mn:0000BA4D                 lea     eax, [eax+edx*2]
.text$mn:0000BA50                 mov     [ebp+Dst], eax
.text$mn:0000BA53                 mov     ecx, [ebp+var_4]
.text$mn:0000BA56                 mov     edx, [ecx+14h]
.text$mn:0000BA59                 sub     edx, [ebp+arg_4]
.text$mn:0000BA5C                 mov     [ebp+var_C], edx
.text$mn:0000BA5F                 mov     eax, [ebp+var_C]
.text$mn:0000BA62                 sub     eax, [ebp+arg_0]
.text$mn:0000BA65                 push    eax             ; int
.text$mn:0000BA66                 mov     ecx, [ebp+arg_4]
.text$mn:0000BA69                 mov     edx, [ebp+Dst]
.text$mn:0000BA6C                 lea     eax, [edx+ecx*2]
.text$mn:0000BA6F                 push    eax             ; Src
.text$mn:0000BA70                 mov     ecx, [ebp+Dst]
.text$mn:0000BA73                 push    ecx             ; Dst
.text$mn:0000BA74                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000BA79                 add     esp, 0Ch
.text$mn:0000BA7C                 mov     edx, [ebp+var_C]
.text$mn:0000BA7F                 push    edx
.text$mn:0000BA80                 mov     ecx, [ebp+var_4]
.text$mn:0000BA83                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000BA88
.text$mn:0000BA88 loc_BA88:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:0000BA88                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:0000BA88                 mov     eax, [ebp+var_4]
.text$mn:0000BA8B                 mov     esp, ebp
.text$mn:0000BA8D                 pop     ebp
.text$mn:0000BA8E                 retn    8
.text$mn:0000BA8E ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000BA8E
.text$mn:0000BA8E ; ---------------------------------------------------------------------------
.text$mn:0000BA91                 align 4
.text$mn:0000BA91 _text$mn        ends
.text$mn:0000BA91
.text$mn:0000BA94 ; ===========================================================================
.text$mn:0000BA94
.text$mn:0000BA94 ; Segment type: Pure code
.text$mn:0000BA94 ; Segment permissions: Read/Execute
.text$mn:0000BA94 _text$mn        segment para public 'CODE' use32
.text$mn:0000BA94                 assume cs:_text$mn
.text$mn:0000BA94                 ;org 0BA94h
.text$mn:0000BA94 ; COMDAT (pick any)
.text$mn:0000BA94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BA94
.text$mn:0000BA94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BA94
.text$mn:0000BA94 ; Attributes: bp-based frame
.text$mn:0000BA94
.text$mn:0000BA94 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>> __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::erase(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class MacroShortcut>>>)
.text$mn:0000BA94                 public ?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.text$mn:0000BA94 ?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z proc near
.text$mn:0000BA94                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+B84p
.text$mn:0000BA94
.text$mn:0000BA94 var_24          = dword ptr -24h
.text$mn:0000BA94 var_20          = dword ptr -20h
.text$mn:0000BA94 var_1C          = dword ptr -1Ch
.text$mn:0000BA94 var_18          = dword ptr -18h
.text$mn:0000BA94 var_14          = dword ptr -14h
.text$mn:0000BA94 var_10          = dword ptr -10h
.text$mn:0000BA94 var_C           = dword ptr -0Ch
.text$mn:0000BA94 var_4           = dword ptr -4
.text$mn:0000BA94 arg_0           = dword ptr  8
.text$mn:0000BA94 arg_4           = byte ptr  0Ch
.text$mn:0000BA94 arg_C           = dword ptr  14h
.text$mn:0000BA94
.text$mn:0000BA94                 push    ebp
.text$mn:0000BA95                 mov     ebp, esp
.text$mn:0000BA97                 push    0FFFFFFFFh
.text$mn:0000BA99                 push    offset __ehhandler$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.text$mn:0000BA9E                 mov     eax, large fs:0
.text$mn:0000BAA4                 push    eax
.text$mn:0000BAA5                 sub     esp, 18h
.text$mn:0000BAA8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BAAD                 xor     eax, ebp
.text$mn:0000BAAF                 push    eax
.text$mn:0000BAB0                 lea     eax, [ebp+var_C]
.text$mn:0000BAB3                 mov     large fs:0, eax
.text$mn:0000BAB9                 mov     [ebp+var_10], ecx
.text$mn:0000BABC                 mov     [ebp+var_14], 0
.text$mn:0000BAC3                 mov     [ebp+var_4], 1
.text$mn:0000BACA                 lea     ecx, [ebp+arg_4] ; this
.text$mn:0000BACD                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000BAD2                 cmp     eax, [ebp+var_10]
.text$mn:0000BAD5                 jnz     short loc_BAED
.text$mn:0000BAD7                 mov     eax, [ebp+var_10]
.text$mn:0000BADA                 mov     ecx, [ebp+arg_C]
.text$mn:0000BADD                 cmp     ecx, [eax+4]
.text$mn:0000BAE0                 jb      short loc_BAED
.text$mn:0000BAE2                 mov     edx, [ebp+var_10]
.text$mn:0000BAE5                 mov     eax, [edx+8]
.text$mn:0000BAE8                 cmp     eax, [ebp+arg_C]
.text$mn:0000BAEB                 ja      short loc_BB04
.text$mn:0000BAED
.text$mn:0000BAED loc_BAED:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+41j
.text$mn:0000BAED                                         ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+4Cj
.text$mn:0000BAED                 push    5A2h            ; unsigned int
.text$mn:0000BAF2                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000BAF7                 push    offset ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; "vector erase iterator outside range"
.text$mn:0000BAFC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000BB01                 add     esp, 0Ch
.text$mn:0000BB04
.text$mn:0000BB04 loc_BB04:                               ; CODE XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+57j
.text$mn:0000BB04                 mov     ecx, [ebp+arg_C]
.text$mn:0000BB07                 push    ecx
.text$mn:0000BB08                 mov     edx, [ebp+var_10]
.text$mn:0000BB0B                 mov     eax, [edx+8]
.text$mn:0000BB0E                 push    eax
.text$mn:0000BB0F                 mov     ecx, [ebp+arg_C]
.text$mn:0000BB12                 add     ecx, 13Ch
.text$mn:0000BB18                 push    ecx
.text$mn:0000BB19                 call    ??$_Move@PAVMacroShortcut@@PAV1@@std@@YAPAVMacroShortcut@@PAV1@00@Z ; std::_Move<MacroShortcut *,MacroShortcut *>(MacroShortcut *,MacroShortcut *,MacroShortcut *)
.text$mn:0000BB1E                 add     esp, 0Ch
.text$mn:0000BB21                 mov     edx, [ebp+var_10]
.text$mn:0000BB24                 mov     eax, [edx+8]
.text$mn:0000BB27                 push    eax
.text$mn:0000BB28                 mov     ecx, [ebp+var_10]
.text$mn:0000BB2B                 mov     edx, [ecx+8]
.text$mn:0000BB2E                 sub     edx, 13Ch
.text$mn:0000BB34                 push    edx
.text$mn:0000BB35                 mov     ecx, [ebp+var_10]
.text$mn:0000BB38                 call    ?_Destroy@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IAEXPAVMacroShortcut@@0@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Destroy(MacroShortcut *,MacroShortcut *)
.text$mn:0000BB3D                 mov     eax, [ebp+var_10]
.text$mn:0000BB40                 mov     ecx, [eax+8]
.text$mn:0000BB43                 push    ecx
.text$mn:0000BB44                 mov     edx, [ebp+arg_C]
.text$mn:0000BB47                 push    edx
.text$mn:0000BB48                 mov     ecx, [ebp+var_10]
.text$mn:0000BB4B                 call    ?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Orphan_range(MacroShortcut *,MacroShortcut *)
.text$mn:0000BB50                 mov     eax, [ebp+var_10]
.text$mn:0000BB53                 mov     ecx, [eax+8]
.text$mn:0000BB56                 sub     ecx, 13Ch
.text$mn:0000BB5C                 mov     edx, [ebp+var_10]
.text$mn:0000BB5F                 mov     [edx+8], ecx
.text$mn:0000BB62                 sub     esp, 0Ch
.text$mn:0000BB65                 mov     ecx, esp
.text$mn:0000BB67                 mov     [ebp+var_1C], esp
.text$mn:0000BB6A                 lea     eax, [ebp+arg_4]
.text$mn:0000BB6D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000BB6E                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>> const &)
.text$mn:0000BB73                 mov     [ebp+var_18], eax
.text$mn:0000BB76                 mov     ecx, [ebp+var_18]
.text$mn:0000BB79                 mov     [ebp+var_20], ecx
.text$mn:0000BB7C                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000BB80                 mov     edx, [ebp+arg_0]
.text$mn:0000BB83                 push    edx
.text$mn:0000BB84                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000BB88                 mov     ecx, [ebp+var_10]
.text$mn:0000BB8B                 call    ?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z ; std::vector<MacroShortcut,std::allocator<MacroShortcut>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)
.text$mn:0000BB90                 mov     [ebp+var_24], eax
.text$mn:0000BB93                 mov     eax, [ebp+var_14]
.text$mn:0000BB96                 or      eax, 1
.text$mn:0000BB99                 mov     [ebp+var_14], eax
.text$mn:0000BB9C                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000BBA0                 lea     ecx, [ebp+arg_4]
.text$mn:0000BBA3                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$mn:0000BBA8                 mov     eax, [ebp+arg_0]
.text$mn:0000BBAB                 mov     ecx, [ebp+var_C]
.text$mn:0000BBAE                 mov     large fs:0, ecx
.text$mn:0000BBB5                 pop     ecx
.text$mn:0000BBB6                 mov     esp, ebp
.text$mn:0000BBB8                 pop     ebp
.text$mn:0000BBB9                 retn    10h
.text$mn:0000BBB9 ?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z endp
.text$mn:0000BBB9
.text$mn:0000BBB9 _text$mn        ends
.text$mn:0000BBB9
.text$x:0000BBBC ; ===========================================================================
.text$x:0000BBBC
.text$x:0000BBBC ; Segment type: Pure code
.text$x:0000BBBC ; Segment permissions: Read/Execute
.text$x:0000BBBC _text$x         segment para public 'CODE' use32
.text$x:0000BBBC                 assume cs:_text$x
.text$x:0000BBBC                 ;org 0BBBCh
.text$x:0000BBBC ; COMDAT (pick associative to section at BA94)
.text$x:0000BBBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BBBC
.text$x:0000BBBC ; =============== S U B R O U T I N E =======================================
.text$x:0000BBBC
.text$x:0000BBBC
.text$x:0000BBBC __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$0 proc near
.text$x:0000BBBC                                         ; DATA XREF: .xdata$x:0000DC14o
.text$x:0000BBBC                 lea     ecx, [ebp+0Ch]
.text$x:0000BBBF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:0000BBBF __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$0 endp
.text$x:0000BBBF
.text$x:0000BBC4
.text$x:0000BBC4 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBC4
.text$x:0000BBC4
.text$x:0000BBC4 __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$1 proc near
.text$x:0000BBC4                                         ; DATA XREF: .xdata$x:0000DC1Co
.text$x:0000BBC4                 mov     ecx, [ebp-1Ch]
.text$x:0000BBC7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:0000BBC7 __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$1 endp
.text$x:0000BBC7
.text$x:0000BBCC
.text$x:0000BBCC ; =============== S U B R O U T I N E =======================================
.text$x:0000BBCC
.text$x:0000BBCC
.text$x:0000BBCC __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$2 proc near
.text$x:0000BBCC                                         ; DATA XREF: .xdata$x:0000DC0Co
.text$x:0000BBCC                 mov     eax, [ebp-14h]
.text$x:0000BBCF                 and     eax, 1
.text$x:0000BBD2                 jz      $LN8_0
.text$x:0000BBD8                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000BBDC                 mov     ecx, [ebp+8]
.text$x:0000BBDF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>(void)
.text$x:0000BBE4 ; ---------------------------------------------------------------------------
.text$x:0000BBE4
.text$x:0000BBE4 $LN8_0:                                 ; CODE XREF: __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$2+6j
.text$x:0000BBE4                 retn
.text$x:0000BBE4 __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$2 endp
.text$x:0000BBE4
.text$x:0000BBE5
.text$x:0000BBE5 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBE5
.text$x:0000BBE5
.text$x:0000BBE5 __ehhandler$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z proc near
.text$x:0000BBE5                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+5o
.text$x:0000BBE5
.text$x:0000BBE5 arg_4           = dword ptr  8
.text$x:0000BBE5
.text$x:0000BBE5                 mov     edx, [esp+arg_4]
.text$x:0000BBE9                 lea     eax, [edx+0Ch]
.text$x:0000BBEC                 mov     ecx, [edx-1Ch]
.text$x:0000BBEF                 xor     ecx, eax
.text$x:0000BBF1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BBF6                 mov     eax, offset __ehfuncinfo$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.text$x:0000BBFB                 jmp     ___CxxFrameHandler3
.text$x:0000BBFB __ehhandler$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z endp
.text$x:0000BBFB
.text$x:0000BBFB _text$x         ends
.text$x:0000BBFB
.text$mn:0000BC00 ; ===========================================================================
.text$mn:0000BC00
.text$mn:0000BC00 ; Segment type: Pure code
.text$mn:0000BC00 ; Segment permissions: Read/Execute
.text$mn:0000BC00 _text$mn        segment para public 'CODE' use32
.text$mn:0000BC00                 assume cs:_text$mn
.text$mn:0000BC00                 ;org 0BC00h
.text$mn:0000BC00 ; COMDAT (pick any)
.text$mn:0000BC00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BC00
.text$mn:0000BC00 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BC00
.text$mn:0000BC00 ; Attributes: bp-based frame
.text$mn:0000BC00
.text$mn:0000BC00 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>> __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::erase(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class UserCommand>>>)
.text$mn:0000BC00                 public ?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.text$mn:0000BC00 ?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z proc near
.text$mn:0000BC00                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+D63p
.text$mn:0000BC00
.text$mn:0000BC00 var_24          = dword ptr -24h
.text$mn:0000BC00 var_20          = dword ptr -20h
.text$mn:0000BC00 var_1C          = dword ptr -1Ch
.text$mn:0000BC00 var_18          = dword ptr -18h
.text$mn:0000BC00 var_14          = dword ptr -14h
.text$mn:0000BC00 var_10          = dword ptr -10h
.text$mn:0000BC00 var_C           = dword ptr -0Ch
.text$mn:0000BC00 var_4           = dword ptr -4
.text$mn:0000BC00 arg_0           = dword ptr  8
.text$mn:0000BC00 arg_4           = byte ptr  0Ch
.text$mn:0000BC00 arg_C           = dword ptr  14h
.text$mn:0000BC00
.text$mn:0000BC00                 push    ebp
.text$mn:0000BC01                 mov     ebp, esp
.text$mn:0000BC03                 push    0FFFFFFFFh
.text$mn:0000BC05                 push    offset __ehhandler$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.text$mn:0000BC0A                 mov     eax, large fs:0
.text$mn:0000BC10                 push    eax
.text$mn:0000BC11                 sub     esp, 18h
.text$mn:0000BC14                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BC19                 xor     eax, ebp
.text$mn:0000BC1B                 push    eax
.text$mn:0000BC1C                 lea     eax, [ebp+var_C]
.text$mn:0000BC1F                 mov     large fs:0, eax
.text$mn:0000BC25                 mov     [ebp+var_10], ecx
.text$mn:0000BC28                 mov     [ebp+var_14], 0
.text$mn:0000BC2F                 mov     [ebp+var_4], 1
.text$mn:0000BC36                 lea     ecx, [ebp+arg_4] ; this
.text$mn:0000BC39                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:0000BC3E                 cmp     eax, [ebp+var_10]
.text$mn:0000BC41                 jnz     short loc_BC59
.text$mn:0000BC43                 mov     eax, [ebp+var_10]
.text$mn:0000BC46                 mov     ecx, [ebp+arg_C]
.text$mn:0000BC49                 cmp     ecx, [eax+4]
.text$mn:0000BC4C                 jb      short loc_BC59
.text$mn:0000BC4E                 mov     edx, [ebp+var_10]
.text$mn:0000BC51                 mov     eax, [edx+8]
.text$mn:0000BC54                 cmp     eax, [ebp+arg_C]
.text$mn:0000BC57                 ja      short loc_BC70
.text$mn:0000BC59
.text$mn:0000BC59 loc_BC59:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+41j
.text$mn:0000BC59                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+4Cj
.text$mn:0000BC59                 push    5A2h            ; unsigned int
.text$mn:0000BC5E                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000BC63                 push    offset ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; "vector erase iterator outside range"
.text$mn:0000BC68                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000BC6D                 add     esp, 0Ch
.text$mn:0000BC70
.text$mn:0000BC70 loc_BC70:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+57j
.text$mn:0000BC70                 mov     ecx, [ebp+arg_C]
.text$mn:0000BC73                 push    ecx
.text$mn:0000BC74                 mov     edx, [ebp+var_10]
.text$mn:0000BC77                 mov     eax, [edx+8]
.text$mn:0000BC7A                 push    eax
.text$mn:0000BC7B                 mov     ecx, [ebp+arg_C]
.text$mn:0000BC7E                 add     ecx, 148h
.text$mn:0000BC84                 push    ecx
.text$mn:0000BC85                 call    ??$_Move@PAVUserCommand@@PAV1@@std@@YAPAVUserCommand@@PAV1@00@Z ; std::_Move<UserCommand *,UserCommand *>(UserCommand *,UserCommand *,UserCommand *)
.text$mn:0000BC8A                 add     esp, 0Ch
.text$mn:0000BC8D                 mov     edx, [ebp+var_10]
.text$mn:0000BC90                 mov     eax, [edx+8]
.text$mn:0000BC93                 push    eax
.text$mn:0000BC94                 mov     ecx, [ebp+var_10]
.text$mn:0000BC97                 mov     edx, [ecx+8]
.text$mn:0000BC9A                 sub     edx, 148h
.text$mn:0000BCA0                 push    edx
.text$mn:0000BCA1                 mov     ecx, [ebp+var_10]
.text$mn:0000BCA4                 call    ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Destroy(UserCommand *,UserCommand *)
.text$mn:0000BCA9                 mov     eax, [ebp+var_10]
.text$mn:0000BCAC                 mov     ecx, [eax+8]
.text$mn:0000BCAF                 push    ecx
.text$mn:0000BCB0                 mov     edx, [ebp+arg_C]
.text$mn:0000BCB3                 push    edx
.text$mn:0000BCB4                 mov     ecx, [ebp+var_10]
.text$mn:0000BCB7                 call    ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)
.text$mn:0000BCBC                 mov     eax, [ebp+var_10]
.text$mn:0000BCBF                 mov     ecx, [eax+8]
.text$mn:0000BCC2                 sub     ecx, 148h
.text$mn:0000BCC8                 mov     edx, [ebp+var_10]
.text$mn:0000BCCB                 mov     [edx+8], ecx
.text$mn:0000BCCE                 sub     esp, 0Ch
.text$mn:0000BCD1                 mov     ecx, esp
.text$mn:0000BCD3                 mov     [ebp+var_1C], esp
.text$mn:0000BCD6                 lea     eax, [ebp+arg_4]
.text$mn:0000BCD9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000BCDA                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>> const &)
.text$mn:0000BCDF                 mov     [ebp+var_18], eax
.text$mn:0000BCE2                 mov     ecx, [ebp+var_18]
.text$mn:0000BCE5                 mov     [ebp+var_20], ecx
.text$mn:0000BCE8                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000BCEC                 mov     edx, [ebp+arg_0]
.text$mn:0000BCEF                 push    edx
.text$mn:0000BCF0                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000BCF4                 mov     ecx, [ebp+var_10]
.text$mn:0000BCF7                 call    ?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)
.text$mn:0000BCFC                 mov     [ebp+var_24], eax
.text$mn:0000BCFF                 mov     eax, [ebp+var_14]
.text$mn:0000BD02                 or      eax, 1
.text$mn:0000BD05                 mov     [ebp+var_14], eax
.text$mn:0000BD08                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000BD0C                 lea     ecx, [ebp+arg_4]
.text$mn:0000BD0F                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$mn:0000BD14                 mov     eax, [ebp+arg_0]
.text$mn:0000BD17                 mov     ecx, [ebp+var_C]
.text$mn:0000BD1A                 mov     large fs:0, ecx
.text$mn:0000BD21                 pop     ecx
.text$mn:0000BD22                 mov     esp, ebp
.text$mn:0000BD24                 pop     ebp
.text$mn:0000BD25                 retn    10h
.text$mn:0000BD25 ?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z endp
.text$mn:0000BD25
.text$mn:0000BD25 _text$mn        ends
.text$mn:0000BD25
.text$x:0000BD28 ; ===========================================================================
.text$x:0000BD28
.text$x:0000BD28 ; Segment type: Pure code
.text$x:0000BD28 ; Segment permissions: Read/Execute
.text$x:0000BD28 _text$x         segment para public 'CODE' use32
.text$x:0000BD28                 assume cs:_text$x
.text$x:0000BD28                 ;org 0BD28h
.text$x:0000BD28 ; COMDAT (pick associative to section at BC00)
.text$x:0000BD28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BD28
.text$x:0000BD28 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD28
.text$x:0000BD28
.text$x:0000BD28 __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$0 proc near
.text$x:0000BD28                                         ; DATA XREF: .xdata$x:0000DCDCo
.text$x:0000BD28                 lea     ecx, [ebp+0Ch]
.text$x:0000BD2B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:0000BD2B __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$0 endp
.text$x:0000BD2B
.text$x:0000BD30
.text$x:0000BD30 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD30
.text$x:0000BD30
.text$x:0000BD30 __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$1 proc near
.text$x:0000BD30                                         ; DATA XREF: .xdata$x:0000DCE4o
.text$x:0000BD30                 mov     ecx, [ebp-1Ch]
.text$x:0000BD33                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:0000BD33 __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$1 endp
.text$x:0000BD33
.text$x:0000BD38
.text$x:0000BD38 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD38
.text$x:0000BD38
.text$x:0000BD38 __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$2 proc near
.text$x:0000BD38                                         ; DATA XREF: .xdata$x:0000DCD4o
.text$x:0000BD38                 mov     eax, [ebp-14h]
.text$x:0000BD3B                 and     eax, 1
.text$x:0000BD3E                 jz      $LN8_1
.text$x:0000BD44                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000BD48                 mov     ecx, [ebp+8]
.text$x:0000BD4B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>(void)
.text$x:0000BD50 ; ---------------------------------------------------------------------------
.text$x:0000BD50
.text$x:0000BD50 $LN8_1:                                 ; CODE XREF: __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$2+6j
.text$x:0000BD50                 retn
.text$x:0000BD50 __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$2 endp
.text$x:0000BD50
.text$x:0000BD51
.text$x:0000BD51 ; =============== S U B R O U T I N E =======================================
.text$x:0000BD51
.text$x:0000BD51
.text$x:0000BD51 __ehhandler$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z proc near
.text$x:0000BD51                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+5o
.text$x:0000BD51
.text$x:0000BD51 arg_4           = dword ptr  8
.text$x:0000BD51
.text$x:0000BD51                 mov     edx, [esp+arg_4]
.text$x:0000BD55                 lea     eax, [edx+0Ch]
.text$x:0000BD58                 mov     ecx, [edx-1Ch]
.text$x:0000BD5B                 xor     ecx, eax
.text$x:0000BD5D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BD62                 mov     eax, offset __ehfuncinfo$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.text$x:0000BD67                 jmp     ___CxxFrameHandler3
.text$x:0000BD67 __ehhandler$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z endp
.text$x:0000BD67
.text$x:0000BD67 _text$x         ends
.text$x:0000BD67
.text$mn:0000BD6C ; ===========================================================================
.text$mn:0000BD6C
.text$mn:0000BD6C ; Segment type: Pure code
.text$mn:0000BD6C ; Segment permissions: Read/Execute
.text$mn:0000BD6C _text$mn        segment para public 'CODE' use32
.text$mn:0000BD6C                 assume cs:_text$mn
.text$mn:0000BD6C                 ;org 0BD6Ch
.text$mn:0000BD6C ; COMDAT (pick any)
.text$mn:0000BD6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BD6C
.text$mn:0000BD6C ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD6C
.text$mn:0000BD6C ; Attributes: bp-based frame
.text$mn:0000BD6C
.text$mn:0000BD6C ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:0000BD6C                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:0000BD6C ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000BD6C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:0000BD6C                 push    ebp
.text$mn:0000BD6D                 mov     ebp, esp
.text$mn:0000BD6F                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000BD74                 pop     ebp
.text$mn:0000BD75                 retn
.text$mn:0000BD75 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000BD75
.text$mn:0000BD75 ; ---------------------------------------------------------------------------
.text$mn:0000BD76                 align 4
.text$mn:0000BD76 _text$mn        ends
.text$mn:0000BD76
.text$mn:0000BD78 ; ===========================================================================
.text$mn:0000BD78
.text$mn:0000BD78 ; Segment type: Pure code
.text$mn:0000BD78 ; Segment permissions: Read/Execute
.text$mn:0000BD78 _text$mn        segment para public 'CODE' use32
.text$mn:0000BD78                 assume cs:_text$mn
.text$mn:0000BD78                 ;org 0BD78h
.text$mn:0000BD78 ; COMDAT (pick any)
.text$mn:0000BD78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BD78
.text$mn:0000BD78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD78
.text$mn:0000BD78 ; Attributes: bp-based frame
.text$mn:0000BD78
.text$mn:0000BD78 ; struct Accelerator *__thiscall NppParameters::getAccelerator(NppParameters *__hidden this)
.text$mn:0000BD78                 public ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ
.text$mn:0000BD78 ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ proc near
.text$mn:0000BD78                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+377p
.text$mn:0000BD78                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+4EFp ...
.text$mn:0000BD78
.text$mn:0000BD78 var_4           = dword ptr -4
.text$mn:0000BD78
.text$mn:0000BD78                 push    ebp
.text$mn:0000BD79                 mov     ebp, esp
.text$mn:0000BD7B                 push    ecx
.text$mn:0000BD7C                 mov     [ebp+var_4], ecx
.text$mn:0000BD7F                 mov     eax, [ebp+var_4]
.text$mn:0000BD82                 mov     eax, [eax+1CBA0h]
.text$mn:0000BD88                 mov     esp, ebp
.text$mn:0000BD8A                 pop     ebp
.text$mn:0000BD8B                 retn
.text$mn:0000BD8B ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ endp
.text$mn:0000BD8B
.text$mn:0000BD8B _text$mn        ends
.text$mn:0000BD8B
.text$mn:0000BD8C ; ===========================================================================
.text$mn:0000BD8C
.text$mn:0000BD8C ; Segment type: Pure code
.text$mn:0000BD8C ; Segment permissions: Read/Execute
.text$mn:0000BD8C _text$mn        segment para public 'CODE' use32
.text$mn:0000BD8C                 assume cs:_text$mn
.text$mn:0000BD8C                 ;org 0BD8Ch
.text$mn:0000BD8C ; COMDAT (pick any)
.text$mn:0000BD8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BD8C
.text$mn:0000BD8C ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD8C
.text$mn:0000BD8C ; Attributes: bp-based frame
.text$mn:0000BD8C
.text$mn:0000BD8C ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:0000BD8C                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:0000BD8C ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:0000BD8C                                         ; CODE XREF: ShortcutMapper::getClientRect(tagRECT &)+Ep
.text$mn:0000BD8C                                         ; DATA XREF: .rdata:0000E794o ...
.text$mn:0000BD8C
.text$mn:0000BD8C var_4           = dword ptr -4
.text$mn:0000BD8C lpRect          = dword ptr  8
.text$mn:0000BD8C
.text$mn:0000BD8C                 push    ebp
.text$mn:0000BD8D                 mov     ebp, esp
.text$mn:0000BD8F                 push    ecx
.text$mn:0000BD90                 mov     [ebp+var_4], ecx
.text$mn:0000BD93                 mov     eax, [ebp+lpRect]
.text$mn:0000BD96                 push    eax             ; lpRect
.text$mn:0000BD97                 mov     ecx, [ebp+var_4]
.text$mn:0000BD9A                 mov     edx, [ecx+0Ch]
.text$mn:0000BD9D                 push    edx             ; hWnd
.text$mn:0000BD9E                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000BDA4                 mov     esp, ebp
.text$mn:0000BDA6                 pop     ebp
.text$mn:0000BDA7                 retn    4
.text$mn:0000BDA7 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000BDA7
.text$mn:0000BDA7 ; ---------------------------------------------------------------------------
.text$mn:0000BDAA                 align 4
.text$mn:0000BDAA _text$mn        ends
.text$mn:0000BDAA
.text$mn:0000BDAC ; ===========================================================================
.text$mn:0000BDAC
.text$mn:0000BDAC ; Segment type: Pure code
.text$mn:0000BDAC ; Segment permissions: Read/Execute
.text$mn:0000BDAC _text$mn        segment para public 'CODE' use32
.text$mn:0000BDAC                 assume cs:_text$mn
.text$mn:0000BDAC                 ;org 0BDACh
.text$mn:0000BDAC ; COMDAT (pick any)
.text$mn:0000BDAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BDAC
.text$mn:0000BDAC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDAC
.text$mn:0000BDAC ; Attributes: bp-based frame
.text$mn:0000BDAC
.text$mn:0000BDAC ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:0000BDAC                 public ?getHeight@Window@@UBEHXZ
.text$mn:0000BDAC ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:0000E7A0o
.text$mn:0000BDAC                                         ; .rdata:0000E7D4o ...
.text$mn:0000BDAC
.text$mn:0000BDAC var_18          = dword ptr -18h
.text$mn:0000BDAC Rect            = tagRECT ptr -14h
.text$mn:0000BDAC var_4           = dword ptr -4
.text$mn:0000BDAC
.text$mn:0000BDAC                 push    ebp
.text$mn:0000BDAD                 mov     ebp, esp
.text$mn:0000BDAF                 sub     esp, 18h
.text$mn:0000BDB2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BDB7                 xor     eax, ebp
.text$mn:0000BDB9                 mov     [ebp+var_4], eax
.text$mn:0000BDBC                 mov     [ebp+var_18], ecx
.text$mn:0000BDBF                 lea     eax, [ebp+Rect]
.text$mn:0000BDC2                 push    eax             ; lpRect
.text$mn:0000BDC3                 mov     ecx, [ebp+var_18]
.text$mn:0000BDC6                 mov     edx, [ecx+0Ch]
.text$mn:0000BDC9                 push    edx             ; hWnd
.text$mn:0000BDCA                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000BDD0                 mov     eax, [ebp+var_18]
.text$mn:0000BDD3                 mov     ecx, [eax+0Ch]
.text$mn:0000BDD6                 push    ecx             ; hWnd
.text$mn:0000BDD7                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000BDDD                 cmp     eax, 1
.text$mn:0000BDE0                 jnz     short loc_BDEA
.text$mn:0000BDE2                 mov     eax, [ebp+Rect.bottom]
.text$mn:0000BDE5                 sub     eax, [ebp+Rect.top]
.text$mn:0000BDE8                 jmp     short loc_BDEC
.text$mn:0000BDEA ; ---------------------------------------------------------------------------
.text$mn:0000BDEA
.text$mn:0000BDEA loc_BDEA:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:0000BDEA                 xor     eax, eax
.text$mn:0000BDEC
.text$mn:0000BDEC loc_BDEC:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:0000BDEC                 mov     ecx, [ebp+var_4]
.text$mn:0000BDEF                 xor     ecx, ebp
.text$mn:0000BDF1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000BDF6                 mov     esp, ebp
.text$mn:0000BDF8                 pop     ebp
.text$mn:0000BDF9                 retn
.text$mn:0000BDF9 ?getHeight@Window@@UBEHXZ endp
.text$mn:0000BDF9
.text$mn:0000BDF9 ; ---------------------------------------------------------------------------
.text$mn:0000BDFA                 align 4
.text$mn:0000BDFA _text$mn        ends
.text$mn:0000BDFA
.text$mn:0000BDFC ; ===========================================================================
.text$mn:0000BDFC
.text$mn:0000BDFC ; Segment type: Pure code
.text$mn:0000BDFC ; Segment permissions: Read/Execute
.text$mn:0000BDFC _text$mn        segment para public 'CODE' use32
.text$mn:0000BDFC                 assume cs:_text$mn
.text$mn:0000BDFC                 ;org 0BDFCh
.text$mn:0000BDFC ; COMDAT (pick any)
.text$mn:0000BDFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BDFC
.text$mn:0000BDFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BDFC
.text$mn:0000BDFC ; Attributes: bp-based frame
.text$mn:0000BDFC
.text$mn:0000BDFC ; unsigned __int32 __thiscall CommandShortcut::getID(CommandShortcut *__hidden this)
.text$mn:0000BDFC                 public ?getID@CommandShortcut@@QBEKXZ
.text$mn:0000BDFC ?getID@CommandShortcut@@QBEKXZ proc near
.text$mn:0000BDFC                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+B0Cp
.text$mn:0000BDFC                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+C4Ep ...
.text$mn:0000BDFC
.text$mn:0000BDFC var_4           = dword ptr -4
.text$mn:0000BDFC
.text$mn:0000BDFC                 push    ebp
.text$mn:0000BDFD                 mov     ebp, esp
.text$mn:0000BDFF                 push    ecx
.text$mn:0000BE00                 mov     [ebp+var_4], ecx
.text$mn:0000BE03                 mov     eax, [ebp+var_4]
.text$mn:0000BE06                 mov     eax, [eax+128h]
.text$mn:0000BE0C                 mov     esp, ebp
.text$mn:0000BE0E                 pop     ebp
.text$mn:0000BE0F                 retn
.text$mn:0000BE0F ?getID@CommandShortcut@@QBEKXZ endp
.text$mn:0000BE0F
.text$mn:0000BE0F _text$mn        ends
.text$mn:0000BE0F
.text$mn:0000BE10 ; ===========================================================================
.text$mn:0000BE10
.text$mn:0000BE10 ; Segment type: Pure code
.text$mn:0000BE10 ; Segment permissions: Read/Execute
.text$mn:0000BE10 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE10                 assume cs:_text$mn
.text$mn:0000BE10                 ;org 0BE10h
.text$mn:0000BE10 ; COMDAT (pick any)
.text$mn:0000BE10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE10
.text$mn:0000BE10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE10
.text$mn:0000BE10 ; Attributes: bp-based frame
.text$mn:0000BE10
.text$mn:0000BE10 ; unsigned __int32 __thiscall PluginCmdShortcut::getID(PluginCmdShortcut *__hidden this)
.text$mn:0000BE10                 public ?getID@PluginCmdShortcut@@QBEKXZ
.text$mn:0000BE10 ?getID@PluginCmdShortcut@@QBEKXZ proc near
.text$mn:0000BE10                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+810p
.text$mn:0000BE10
.text$mn:0000BE10 var_4           = dword ptr -4
.text$mn:0000BE10
.text$mn:0000BE10                 push    ebp
.text$mn:0000BE11                 mov     ebp, esp
.text$mn:0000BE13                 push    ecx
.text$mn:0000BE14                 mov     [ebp+var_4], ecx
.text$mn:0000BE17                 mov     eax, [ebp+var_4]
.text$mn:0000BE1A                 mov     eax, [eax+12Ch]
.text$mn:0000BE20                 mov     esp, ebp
.text$mn:0000BE22                 pop     ebp
.text$mn:0000BE23                 retn
.text$mn:0000BE23 ?getID@PluginCmdShortcut@@QBEKXZ endp
.text$mn:0000BE23
.text$mn:0000BE23 _text$mn        ends
.text$mn:0000BE23
.text$mn:0000BE24 ; ===========================================================================
.text$mn:0000BE24
.text$mn:0000BE24 ; Segment type: Pure code
.text$mn:0000BE24 ; Segment permissions: Read/Execute
.text$mn:0000BE24 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE24                 assume cs:_text$mn
.text$mn:0000BE24                 ;org 0BE24h
.text$mn:0000BE24 ; COMDAT (pick any)
.text$mn:0000BE24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE24
.text$mn:0000BE24 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE24
.text$mn:0000BE24 ; Attributes: bp-based frame
.text$mn:0000BE24
.text$mn:0000BE24 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:0000BE24                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:0000BE24 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:0000BE24                                         ; CODE XREF: ShortcutMapper::getClientRect(tagRECT &)+15p
.text$mn:0000BE24                                         ; ShortcutMapper::getClientRect(tagRECT &)+32p ...
.text$mn:0000BE24                 push    ebp
.text$mn:0000BE25                 mov     ebp, esp
.text$mn:0000BE27                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:0000BE2C                 pop     ebp
.text$mn:0000BE2D                 retn
.text$mn:0000BE2D ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:0000BE2D
.text$mn:0000BE2D ; ---------------------------------------------------------------------------
.text$mn:0000BE2E                 align 10h
.text$mn:0000BE2E _text$mn        ends
.text$mn:0000BE2E
.text$mn:0000BE30 ; ===========================================================================
.text$mn:0000BE30
.text$mn:0000BE30 ; Segment type: Pure code
.text$mn:0000BE30 ; Segment permissions: Read/Execute
.text$mn:0000BE30 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE30                 assume cs:_text$mn
.text$mn:0000BE30                 ;org 0BE30h
.text$mn:0000BE30 ; COMDAT (pick any)
.text$mn:0000BE30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE30
.text$mn:0000BE30 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE30
.text$mn:0000BE30 ; Attributes: bp-based frame
.text$mn:0000BE30
.text$mn:0000BE30 ; const struct KeyCombo *__thiscall Shortcut::getKeyCombo(Shortcut *__hidden this)
.text$mn:0000BE30                 public ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ
.text$mn:0000BE30 ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ proc near
.text$mn:0000BE30                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+821p
.text$mn:0000BE30                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+835p ...
.text$mn:0000BE30
.text$mn:0000BE30 var_4           = dword ptr -4
.text$mn:0000BE30
.text$mn:0000BE30                 push    ebp
.text$mn:0000BE31                 mov     ebp, esp
.text$mn:0000BE33                 push    ecx
.text$mn:0000BE34                 mov     [ebp+var_4], ecx
.text$mn:0000BE37                 mov     eax, [ebp+var_4]
.text$mn:0000BE3A                 add     eax, 20h ; ' '
.text$mn:0000BE3D                 mov     esp, ebp
.text$mn:0000BE3F                 pop     ebp
.text$mn:0000BE40                 retn
.text$mn:0000BE40 ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ endp
.text$mn:0000BE40
.text$mn:0000BE40 ; ---------------------------------------------------------------------------
.text$mn:0000BE41                 align 4
.text$mn:0000BE41 _text$mn        ends
.text$mn:0000BE41
.text$mn:0000BE44 ; ===========================================================================
.text$mn:0000BE44
.text$mn:0000BE44 ; Segment type: Pure code
.text$mn:0000BE44 ; Segment permissions: Read/Execute
.text$mn:0000BE44 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE44                 assume cs:_text$mn
.text$mn:0000BE44                 ;org 0BE44h
.text$mn:0000BE44 ; COMDAT (pick any)
.text$mn:0000BE44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE44
.text$mn:0000BE44 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE44
.text$mn:0000BE44 ; Attributes: bp-based frame
.text$mn:0000BE44
.text$mn:0000BE44 ; public: class std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>> & __thiscall NppParameters::getMacroList(void)
.text$mn:0000BE44                 public ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ
.text$mn:0000BE44 ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ proc near
.text$mn:0000BE44                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+3AFp
.text$mn:0000BE44                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+AD4p ...
.text$mn:0000BE44
.text$mn:0000BE44 var_4           = dword ptr -4
.text$mn:0000BE44
.text$mn:0000BE44                 push    ebp
.text$mn:0000BE45                 mov     ebp, esp
.text$mn:0000BE47                 push    ecx
.text$mn:0000BE48                 mov     [ebp+var_4], ecx
.text$mn:0000BE4B                 mov     eax, [ebp+var_4]
.text$mn:0000BE4E                 add     eax, 1C924h
.text$mn:0000BE53                 mov     esp, ebp
.text$mn:0000BE55                 pop     ebp
.text$mn:0000BE56                 retn
.text$mn:0000BE56 ?getMacroList@NppParameters@@QAEAAV?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@XZ endp
.text$mn:0000BE56
.text$mn:0000BE56 ; ---------------------------------------------------------------------------
.text$mn:0000BE57                 align 4
.text$mn:0000BE57 _text$mn        ends
.text$mn:0000BE57
.text$mn:0000BE58 ; ===========================================================================
.text$mn:0000BE58
.text$mn:0000BE58 ; Segment type: Pure code
.text$mn:0000BE58 ; Segment permissions: Read/Execute
.text$mn:0000BE58 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE58                 assume cs:_text$mn
.text$mn:0000BE58                 ;org 0BE58h
.text$mn:0000BE58 ; COMDAT (pick any)
.text$mn:0000BE58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE58
.text$mn:0000BE58 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE58
.text$mn:0000BE58 ; Attributes: bp-based frame
.text$mn:0000BE58
.text$mn:0000BE58 ; const wchar_t *__thiscall Shortcut::getMenuName(Shortcut *__hidden this)
.text$mn:0000BE58                 public ?getMenuName@Shortcut@@QBEPB_WXZ
.text$mn:0000BE58 ?getMenuName@Shortcut@@QBEPB_WXZ proc near
.text$mn:0000BE58                                         ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+41p
.text$mn:0000BE58                                         ; Shortcut::operator=(Shortcut const &)+32p ...
.text$mn:0000BE58
.text$mn:0000BE58 var_4           = dword ptr -4
.text$mn:0000BE58
.text$mn:0000BE58                 push    ebp
.text$mn:0000BE59                 mov     ebp, esp
.text$mn:0000BE5B                 push    ecx
.text$mn:0000BE5C                 mov     [ebp+var_4], ecx
.text$mn:0000BE5F                 mov     eax, [ebp+var_4]
.text$mn:0000BE62                 add     eax, 0A6h ; 'ª'
.text$mn:0000BE67                 mov     esp, ebp
.text$mn:0000BE69                 pop     ebp
.text$mn:0000BE6A                 retn
.text$mn:0000BE6A ?getMenuName@Shortcut@@QBEPB_WXZ endp
.text$mn:0000BE6A
.text$mn:0000BE6A ; ---------------------------------------------------------------------------
.text$mn:0000BE6B                 align 4
.text$mn:0000BE6B _text$mn        ends
.text$mn:0000BE6B
.text$mn:0000BE6C ; ===========================================================================
.text$mn:0000BE6C
.text$mn:0000BE6C ; Segment type: Pure code
.text$mn:0000BE6C ; Segment permissions: Read/Execute
.text$mn:0000BE6C _text$mn        segment para public 'CODE' use32
.text$mn:0000BE6C                 assume cs:_text$mn
.text$mn:0000BE6C                 ;org 0BE6Ch
.text$mn:0000BE6C ; COMDAT (pick any)
.text$mn:0000BE6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE6C
.text$mn:0000BE6C ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE6C
.text$mn:0000BE6C ; Attributes: bp-based frame
.text$mn:0000BE6C
.text$mn:0000BE6C ; const wchar_t *__thiscall Shortcut::getName(Shortcut *__hidden this)
.text$mn:0000BE6C                 public ?getName@Shortcut@@QBEPB_WXZ
.text$mn:0000BE6C ?getName@Shortcut@@QBEPB_WXZ proc near  ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+47Ep
.text$mn:0000BE6C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+608p ...
.text$mn:0000BE6C
.text$mn:0000BE6C var_4           = dword ptr -4
.text$mn:0000BE6C
.text$mn:0000BE6C                 push    ebp
.text$mn:0000BE6D                 mov     ebp, esp
.text$mn:0000BE6F                 push    ecx
.text$mn:0000BE70                 mov     [ebp+var_4], ecx
.text$mn:0000BE73                 mov     eax, [ebp+var_4]
.text$mn:0000BE76                 add     eax, 26h ; '&'
.text$mn:0000BE79                 mov     esp, ebp
.text$mn:0000BE7B                 pop     ebp
.text$mn:0000BE7C                 retn
.text$mn:0000BE7C ?getName@Shortcut@@QBEPB_WXZ endp
.text$mn:0000BE7C
.text$mn:0000BE7C ; ---------------------------------------------------------------------------
.text$mn:0000BE7D                 align 10h
.text$mn:0000BE7D _text$mn        ends
.text$mn:0000BE7D
.text$mn:0000BE80 ; ===========================================================================
.text$mn:0000BE80
.text$mn:0000BE80 ; Segment type: Pure code
.text$mn:0000BE80 ; Segment permissions: Read/Execute
.text$mn:0000BE80 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE80                 assume cs:_text$mn
.text$mn:0000BE80                 ;org 0BE80h
.text$mn:0000BE80 ; COMDAT (pick any)
.text$mn:0000BE80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE80
.text$mn:0000BE80 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE80
.text$mn:0000BE80 ; Attributes: bp-based frame
.text$mn:0000BE80
.text$mn:0000BE80 ; public: class std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>> & __thiscall NppParameters::getPluginCommandList(void)
.text$mn:0000BE80                 public ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ
.text$mn:0000BE80 ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ proc near
.text$mn:0000BE80                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+6B1p
.text$mn:0000BE80                                         ; ShortcutMapper::fillOutBabyGrid(void)+11Cp ...
.text$mn:0000BE80
.text$mn:0000BE80 var_4           = dword ptr -4
.text$mn:0000BE80
.text$mn:0000BE80                 push    ebp
.text$mn:0000BE81                 mov     ebp, esp
.text$mn:0000BE83                 push    ecx
.text$mn:0000BE84                 mov     [ebp+var_4], ecx
.text$mn:0000BE87                 mov     eax, [ebp+var_4]
.text$mn:0000BE8A                 add     eax, 1C944h
.text$mn:0000BE8F                 mov     esp, ebp
.text$mn:0000BE91                 pop     ebp
.text$mn:0000BE92                 retn
.text$mn:0000BE92 ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ endp
.text$mn:0000BE92
.text$mn:0000BE92 ; ---------------------------------------------------------------------------
.text$mn:0000BE93                 align 4
.text$mn:0000BE93 _text$mn        ends
.text$mn:0000BE93
.text$mn:0000BE94 ; ===========================================================================
.text$mn:0000BE94
.text$mn:0000BE94 ; Segment type: Pure code
.text$mn:0000BE94 ; Segment permissions: Read/Execute
.text$mn:0000BE94 _text$mn        segment para public 'CODE' use32
.text$mn:0000BE94                 assume cs:_text$mn
.text$mn:0000BE94                 ;org 0BE94h
.text$mn:0000BE94 ; COMDAT (pick any)
.text$mn:0000BE94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BE94
.text$mn:0000BE94 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE94
.text$mn:0000BE94 ; Attributes: bp-based frame
.text$mn:0000BE94
.text$mn:0000BE94 ; struct ScintillaAccelerator *__thiscall NppParameters::getScintillaAccelerator(NppParameters *__hidden this)
.text$mn:0000BE94                 public ?getScintillaAccelerator@NppParameters@@QAEPAVScintillaAccelerator@@XZ
.text$mn:0000BE94 ?getScintillaAccelerator@NppParameters@@QAEPAVScintillaAccelerator@@XZ proc near
.text$mn:0000BE94                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+9EBp
.text$mn:0000BE94
.text$mn:0000BE94 var_4           = dword ptr -4
.text$mn:0000BE94
.text$mn:0000BE94                 push    ebp
.text$mn:0000BE95                 mov     ebp, esp
.text$mn:0000BE97                 push    ecx
.text$mn:0000BE98                 mov     [ebp+var_4], ecx
.text$mn:0000BE9B                 mov     eax, [ebp+var_4]
.text$mn:0000BE9E                 mov     eax, [eax+1CBA4h]
.text$mn:0000BEA4                 mov     esp, ebp
.text$mn:0000BEA6                 pop     ebp
.text$mn:0000BEA7                 retn
.text$mn:0000BEA7 ?getScintillaAccelerator@NppParameters@@QAEPAVScintillaAccelerator@@XZ endp
.text$mn:0000BEA7
.text$mn:0000BEA7 _text$mn        ends
.text$mn:0000BEA7
.text$mn:0000BEA8 ; ===========================================================================
.text$mn:0000BEA8
.text$mn:0000BEA8 ; Segment type: Pure code
.text$mn:0000BEA8 ; Segment permissions: Read/Execute
.text$mn:0000BEA8 _text$mn        segment para public 'CODE' use32
.text$mn:0000BEA8                 assume cs:_text$mn
.text$mn:0000BEA8                 ;org 0BEA8h
.text$mn:0000BEA8 ; COMDAT (pick any)
.text$mn:0000BEA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BEA8
.text$mn:0000BEA8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BEA8
.text$mn:0000BEA8 ; Attributes: bp-based frame
.text$mn:0000BEA8
.text$mn:0000BEA8 ; public: class std::vector<class ScintillaKeyMap, class std::allocator<class ScintillaKeyMap>> & __thiscall NppParameters::getScintillaKeyList(void)
.text$mn:0000BEA8                 public ?getScintillaKeyList@NppParameters@@QAEAAV?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@XZ
.text$mn:0000BEA8 ?getScintillaKeyList@NppParameters@@QAEAAV?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@XZ proc near
.text$mn:0000BEA8                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+8B6p
.text$mn:0000BEA8                                         ; ShortcutMapper::fillOutBabyGrid(void)+14Dp ...
.text$mn:0000BEA8
.text$mn:0000BEA8 var_4           = dword ptr -4
.text$mn:0000BEA8
.text$mn:0000BEA8                 push    ebp
.text$mn:0000BEA9                 mov     ebp, esp
.text$mn:0000BEAB                 push    ecx
.text$mn:0000BEAC                 mov     [ebp+var_4], ecx
.text$mn:0000BEAF                 mov     eax, [ebp+var_4]
.text$mn:0000BEB2                 add     eax, 1C964h
.text$mn:0000BEB7                 mov     esp, ebp
.text$mn:0000BEB9                 pop     ebp
.text$mn:0000BEBA                 retn
.text$mn:0000BEBA ?getScintillaKeyList@NppParameters@@QAEAAV?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@XZ endp
.text$mn:0000BEBA
.text$mn:0000BEBA ; ---------------------------------------------------------------------------
.text$mn:0000BEBB                 align 4
.text$mn:0000BEBB _text$mn        ends
.text$mn:0000BEBB
.text$mn:0000BEBC ; ===========================================================================
.text$mn:0000BEBC
.text$mn:0000BEBC ; Segment type: Pure code
.text$mn:0000BEBC ; Segment permissions: Read/Execute
.text$mn:0000BEBC _text$mn        segment para public 'CODE' use32
.text$mn:0000BEBC                 assume cs:_text$mn
.text$mn:0000BEBC                 ;org 0BEBCh
.text$mn:0000BEBC ; COMDAT (pick any)
.text$mn:0000BEBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BEBC
.text$mn:0000BEBC ; =============== S U B R O U T I N E =======================================
.text$mn:0000BEBC
.text$mn:0000BEBC ; Attributes: bp-based frame
.text$mn:0000BEBC
.text$mn:0000BEBC ; int __thiscall BabyGridWrapper::getSelectedRow(BabyGridWrapper *__hidden this)
.text$mn:0000BEBC                 public ?getSelectedRow@BabyGridWrapper@@QAEHXZ
.text$mn:0000BEBC ?getSelectedRow@BabyGridWrapper@@QAEHXZ proc near
.text$mn:0000BEBC                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+20Bp
.text$mn:0000BEBC                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+A55p
.text$mn:0000BEBC
.text$mn:0000BEBC var_4           = dword ptr -4
.text$mn:0000BEBC
.text$mn:0000BEBC                 push    ebp
.text$mn:0000BEBD                 mov     ebp, esp
.text$mn:0000BEBF                 push    ecx
.text$mn:0000BEC0                 mov     [ebp+var_4], ecx
.text$mn:0000BEC3                 push    0               ; lParam
.text$mn:0000BEC5                 push    0               ; wParam
.text$mn:0000BEC7                 push    1F73h           ; Msg
.text$mn:0000BECC                 mov     eax, [ebp+var_4]
.text$mn:0000BECF                 mov     ecx, [eax+0Ch]
.text$mn:0000BED2                 push    ecx             ; hWnd
.text$mn:0000BED3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000BED9                 mov     esp, ebp
.text$mn:0000BEDB                 pop     ebp
.text$mn:0000BEDC                 retn
.text$mn:0000BEDC ?getSelectedRow@BabyGridWrapper@@QAEHXZ endp
.text$mn:0000BEDC
.text$mn:0000BEDC ; ---------------------------------------------------------------------------
.text$mn:0000BEDD                 align 10h
.text$mn:0000BEDD _text$mn        ends
.text$mn:0000BEDD
.text$mn:0000BEE0 ; ===========================================================================
.text$mn:0000BEE0
.text$mn:0000BEE0 ; Segment type: Pure code
.text$mn:0000BEE0 ; Segment permissions: Read/Execute
.text$mn:0000BEE0 _text$mn        segment para public 'CODE' use32
.text$mn:0000BEE0                 assume cs:_text$mn
.text$mn:0000BEE0                 ;org 0BEE0h
.text$mn:0000BEE0 ; COMDAT (pick any)
.text$mn:0000BEE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BEE0
.text$mn:0000BEE0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BEE0
.text$mn:0000BEE0 ; Attributes: bp-based frame
.text$mn:0000BEE0
.text$mn:0000BEE0 ; public: class std::vector<class UserCommand, class std::allocator<class UserCommand>> & __thiscall NppParameters::getUserCommandList(void)
.text$mn:0000BEE0                 public ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ
.text$mn:0000BEE0 ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ proc near
.text$mn:0000BEE0                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+527p
.text$mn:0000BEE0                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+CB3p ...
.text$mn:0000BEE0
.text$mn:0000BEE0 var_4           = dword ptr -4
.text$mn:0000BEE0
.text$mn:0000BEE0                 push    ebp
.text$mn:0000BEE1                 mov     ebp, esp
.text$mn:0000BEE3                 push    ecx
.text$mn:0000BEE4                 mov     [ebp+var_4], ecx
.text$mn:0000BEE7                 mov     eax, [ebp+var_4]
.text$mn:0000BEEA                 add     eax, 1C934h
.text$mn:0000BEEF                 mov     esp, ebp
.text$mn:0000BEF1                 pop     ebp
.text$mn:0000BEF2                 retn
.text$mn:0000BEF2 ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ endp
.text$mn:0000BEF2
.text$mn:0000BEF2 ; ---------------------------------------------------------------------------
.text$mn:0000BEF3                 align 4
.text$mn:0000BEF3 _text$mn        ends
.text$mn:0000BEF3
.text$mn:0000BEF4 ; ===========================================================================
.text$mn:0000BEF4
.text$mn:0000BEF4 ; Segment type: Pure code
.text$mn:0000BEF4 ; Segment permissions: Read/Execute
.text$mn:0000BEF4 _text$mn        segment para public 'CODE' use32
.text$mn:0000BEF4                 assume cs:_text$mn
.text$mn:0000BEF4                 ;org 0BEF4h
.text$mn:0000BEF4 ; COMDAT (pick any)
.text$mn:0000BEF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BEF4
.text$mn:0000BEF4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BEF4
.text$mn:0000BEF4 ; Attributes: bp-based frame
.text$mn:0000BEF4
.text$mn:0000BEF4 ; public: class std::vector<class CommandShortcut, class std::allocator<class CommandShortcut>> & __thiscall NppParameters::getUserShortcuts(void)
.text$mn:0000BEF4                 public ?getUserShortcuts@NppParameters@@QAEAAV?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@XZ
.text$mn:0000BEF4 ?getUserShortcuts@NppParameters@@QAEAAV?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@XZ proc near
.text$mn:0000BEF4                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+242p
.text$mn:0000BEF4                                         ; ShortcutMapper::fillOutBabyGrid(void)+83p ...
.text$mn:0000BEF4
.text$mn:0000BEF4 var_4           = dword ptr -4
.text$mn:0000BEF4
.text$mn:0000BEF4                 push    ebp
.text$mn:0000BEF5                 mov     ebp, esp
.text$mn:0000BEF7                 push    ecx
.text$mn:0000BEF8                 mov     [ebp+var_4], ecx
.text$mn:0000BEFB                 mov     eax, [ebp+var_4]
.text$mn:0000BEFE                 add     eax, 1C904h
.text$mn:0000BF03                 mov     esp, ebp
.text$mn:0000BF05                 pop     ebp
.text$mn:0000BF06                 retn
.text$mn:0000BF06 ?getUserShortcuts@NppParameters@@QAEAAV?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@XZ endp
.text$mn:0000BF06
.text$mn:0000BF06 ; ---------------------------------------------------------------------------
.text$mn:0000BF07                 align 4
.text$mn:0000BF07 _text$mn        ends
.text$mn:0000BF07
.text$mn:0000BF08 ; ===========================================================================
.text$mn:0000BF08
.text$mn:0000BF08 ; Segment type: Pure code
.text$mn:0000BF08 ; Segment permissions: Read/Execute
.text$mn:0000BF08 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF08                 assume cs:_text$mn
.text$mn:0000BF08                 ;org 0BF08h
.text$mn:0000BF08 ; COMDAT (pick any)
.text$mn:0000BF08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF08
.text$mn:0000BF08 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF08
.text$mn:0000BF08 ; Attributes: bp-based frame
.text$mn:0000BF08
.text$mn:0000BF08 ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:0000BF08                 public ?getWidth@Window@@UBEHXZ
.text$mn:0000BF08 ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:0000E79Co
.text$mn:0000BF08                                         ; .rdata:0000E7D0o ...
.text$mn:0000BF08
.text$mn:0000BF08 var_18          = dword ptr -18h
.text$mn:0000BF08 Rect            = tagRECT ptr -14h
.text$mn:0000BF08 var_4           = dword ptr -4
.text$mn:0000BF08
.text$mn:0000BF08                 push    ebp
.text$mn:0000BF09                 mov     ebp, esp
.text$mn:0000BF0B                 sub     esp, 18h
.text$mn:0000BF0E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000BF13                 xor     eax, ebp
.text$mn:0000BF15                 mov     [ebp+var_4], eax
.text$mn:0000BF18                 mov     [ebp+var_18], ecx
.text$mn:0000BF1B                 lea     eax, [ebp+Rect]
.text$mn:0000BF1E                 push    eax             ; lpRect
.text$mn:0000BF1F                 mov     ecx, [ebp+var_18]
.text$mn:0000BF22                 mov     edx, [ecx+0Ch]
.text$mn:0000BF25                 push    edx             ; hWnd
.text$mn:0000BF26                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000BF2C                 mov     eax, [ebp+Rect.right]
.text$mn:0000BF2F                 sub     eax, [ebp+Rect.left]
.text$mn:0000BF32                 mov     ecx, [ebp+var_4]
.text$mn:0000BF35                 xor     ecx, ebp
.text$mn:0000BF37                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000BF3C                 mov     esp, ebp
.text$mn:0000BF3E                 pop     ebp
.text$mn:0000BF3F                 retn
.text$mn:0000BF3F ?getWidth@Window@@UBEHXZ endp
.text$mn:0000BF3F
.text$mn:0000BF3F _text$mn        ends
.text$mn:0000BF3F
.text$mn:0000BF40 ; ===========================================================================
.text$mn:0000BF40
.text$mn:0000BF40 ; Segment type: Pure code
.text$mn:0000BF40 ; Segment permissions: Read/Execute
.text$mn:0000BF40 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF40                 assume cs:_text$mn
.text$mn:0000BF40                 ;org 0BF40h
.text$mn:0000BF40 ; COMDAT (pick any)
.text$mn:0000BF40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF40
.text$mn:0000BF40 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF40
.text$mn:0000BF40 ; Attributes: bp-based frame
.text$mn:0000BF40
.text$mn:0000BF40 ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:0000BF40                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:0000BF40 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:0000BF40                                         ; DATA XREF: .rdata:0000E798o
.text$mn:0000BF40                                         ; .rdata:0000E7CCo ...
.text$mn:0000BF40
.text$mn:0000BF40 var_4           = dword ptr -4
.text$mn:0000BF40 lpRect          = dword ptr  8
.text$mn:0000BF40
.text$mn:0000BF40                 push    ebp
.text$mn:0000BF41                 mov     ebp, esp
.text$mn:0000BF43                 push    ecx
.text$mn:0000BF44                 mov     [ebp+var_4], ecx
.text$mn:0000BF47                 mov     eax, [ebp+lpRect]
.text$mn:0000BF4A                 push    eax             ; lpRect
.text$mn:0000BF4B                 mov     ecx, [ebp+var_4]
.text$mn:0000BF4E                 mov     edx, [ecx+0Ch]
.text$mn:0000BF51                 push    edx             ; hWnd
.text$mn:0000BF52                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:0000BF58                 mov     esp, ebp
.text$mn:0000BF5A                 pop     ebp
.text$mn:0000BF5B                 retn    4
.text$mn:0000BF5B ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000BF5B
.text$mn:0000BF5B ; ---------------------------------------------------------------------------
.text$mn:0000BF5E                 align 10h
.text$mn:0000BF5E _text$mn        ends
.text$mn:0000BF5E
.text$mn:0000BF60 ; ===========================================================================
.text$mn:0000BF60
.text$mn:0000BF60 ; Segment type: Pure code
.text$mn:0000BF60 ; Segment permissions: Read/Execute
.text$mn:0000BF60 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF60                 assume cs:_text$mn
.text$mn:0000BF60                 ;org 0BF60h
.text$mn:0000BF60 ; COMDAT (pick any)
.text$mn:0000BF60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF60
.text$mn:0000BF60 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF60
.text$mn:0000BF60 ; Attributes: bp-based frame
.text$mn:0000BF60
.text$mn:0000BF60 ; void __thiscall BabyGridWrapper::hideCursor(BabyGridWrapper *__hidden this)
.text$mn:0000BF60                 public ?hideCursor@BabyGridWrapper@@QAEXXZ
.text$mn:0000BF60 ?hideCursor@BabyGridWrapper@@QAEXXZ proc near
.text$mn:0000BF60                                         ; CODE XREF: ShortcutMapper::initBabyGrid(void)+63p
.text$mn:0000BF60
.text$mn:0000BF60 var_4           = dword ptr -4
.text$mn:0000BF60
.text$mn:0000BF60                 push    ebp
.text$mn:0000BF61                 mov     ebp, esp
.text$mn:0000BF63                 push    ecx
.text$mn:0000BF64                 mov     [ebp+var_4], ecx
.text$mn:0000BF67                 push    0               ; unsigned __int32
.text$mn:0000BF69                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000BF6C                 call    ?setCursorColour@BabyGridWrapper@@QAEXK@Z ; BabyGridWrapper::setCursorColour(ulong)
.text$mn:0000BF71                 mov     esp, ebp
.text$mn:0000BF73                 pop     ebp
.text$mn:0000BF74                 retn
.text$mn:0000BF74 ?hideCursor@BabyGridWrapper@@QAEXXZ endp
.text$mn:0000BF74
.text$mn:0000BF74 ; ---------------------------------------------------------------------------
.text$mn:0000BF75                 align 4
.text$mn:0000BF75 _text$mn        ends
.text$mn:0000BF75
.text$mn:0000BF78 ; ===========================================================================
.text$mn:0000BF78
.text$mn:0000BF78 ; Segment type: Pure code
.text$mn:0000BF78 ; Segment permissions: Read/Execute
.text$mn:0000BF78 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF78                 assume cs:_text$mn
.text$mn:0000BF78                 ;org 0BF78h
.text$mn:0000BF78 ; COMDAT (pick any)
.text$mn:0000BF78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF78
.text$mn:0000BF78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF78
.text$mn:0000BF78 ; Attributes: bp-based frame
.text$mn:0000BF78
.text$mn:0000BF78 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:0000BF78                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000BF78 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:0000BF78                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+2AEp
.text$mn:0000BF78                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+41Bp ...
.text$mn:0000BF78
.text$mn:0000BF78 var_4           = dword ptr -4
.text$mn:0000BF78 arg_0           = dword ptr  8
.text$mn:0000BF78 arg_4           = dword ptr  0Ch
.text$mn:0000BF78
.text$mn:0000BF78                 push    ebp
.text$mn:0000BF79                 mov     ebp, esp
.text$mn:0000BF7B                 push    ecx
.text$mn:0000BF7C                 mov     [ebp+var_4], ecx
.text$mn:0000BF7F                 mov     eax, [ebp+var_4]
.text$mn:0000BF82                 mov     ecx, [ebp+arg_0]
.text$mn:0000BF85                 mov     [eax+4], ecx
.text$mn:0000BF88                 mov     edx, [ebp+var_4]
.text$mn:0000BF8B                 mov     eax, [ebp+arg_4]
.text$mn:0000BF8E                 mov     [edx+8], eax
.text$mn:0000BF91                 mov     esp, ebp
.text$mn:0000BF93                 pop     ebp
.text$mn:0000BF94                 retn    8
.text$mn:0000BF94 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:0000BF94
.text$mn:0000BF94 ; ---------------------------------------------------------------------------
.text$mn:0000BF97                 align 4
.text$mn:0000BF97 _text$mn        ends
.text$mn:0000BF97
.text$mn:0000BF98 ; ===========================================================================
.text$mn:0000BF98
.text$mn:0000BF98 ; Segment type: Pure code
.text$mn:0000BF98 ; Segment permissions: Read/Execute
.text$mn:0000BF98 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF98                 assume cs:_text$mn
.text$mn:0000BF98                 ;org 0BF98h
.text$mn:0000BF98 ; COMDAT (pick any)
.text$mn:0000BF98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BF98
.text$mn:0000BF98 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF98
.text$mn:0000BF98 ; Attributes: bp-based frame
.text$mn:0000BF98
.text$mn:0000BF98 ; bool __thiscall ContextMenu::isCreated(ContextMenu *__hidden this)
.text$mn:0000BF98                 public ?isCreated@ContextMenu@@QBE_NXZ
.text$mn:0000BF98 ?isCreated@ContextMenu@@QBE_NXZ proc near
.text$mn:0000BF98                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+F84p
.text$mn:0000BF98
.text$mn:0000BF98 var_8           = dword ptr -8
.text$mn:0000BF98 var_4           = dword ptr -4
.text$mn:0000BF98
.text$mn:0000BF98                 push    ebp
.text$mn:0000BF99                 mov     ebp, esp
.text$mn:0000BF9B                 sub     esp, 8
.text$mn:0000BF9E                 mov     [ebp+var_8], ecx
.text$mn:0000BFA1                 mov     eax, [ebp+var_8]
.text$mn:0000BFA4                 cmp     dword ptr [eax+4], 0
.text$mn:0000BFA8                 jz      short loc_BFB3
.text$mn:0000BFAA                 mov     [ebp+var_4], 1
.text$mn:0000BFB1                 jmp     short loc_BFBA
.text$mn:0000BFB3 ; ---------------------------------------------------------------------------
.text$mn:0000BFB3
.text$mn:0000BFB3 loc_BFB3:                               ; CODE XREF: ContextMenu::isCreated(void)+10j
.text$mn:0000BFB3                 mov     [ebp+var_4], 0
.text$mn:0000BFBA
.text$mn:0000BFBA loc_BFBA:                               ; CODE XREF: ContextMenu::isCreated(void)+19j
.text$mn:0000BFBA                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000BFBD                 mov     esp, ebp
.text$mn:0000BFBF                 pop     ebp
.text$mn:0000BFC0                 retn
.text$mn:0000BFC0 ?isCreated@ContextMenu@@QBE_NXZ endp
.text$mn:0000BFC0
.text$mn:0000BFC0 ; ---------------------------------------------------------------------------
.text$mn:0000BFC1                 align 4
.text$mn:0000BFC1 _text$mn        ends
.text$mn:0000BFC1
.text$mn:0000BFC4 ; ===========================================================================
.text$mn:0000BFC4
.text$mn:0000BFC4 ; Segment type: Pure code
.text$mn:0000BFC4 ; Segment permissions: Read/Execute
.text$mn:0000BFC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000BFC4                 assume cs:_text$mn
.text$mn:0000BFC4                 ;org 0BFC4h
.text$mn:0000BFC4 ; COMDAT (pick any)
.text$mn:0000BFC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BFC4
.text$mn:0000BFC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BFC4
.text$mn:0000BFC4 ; Attributes: bp-based frame
.text$mn:0000BFC4
.text$mn:0000BFC4 ; bool __thiscall StaticDialog::isCreated(StaticDialog *__hidden this)
.text$mn:0000BFC4                 public ?isCreated@StaticDialog@@UBE_NXZ
.text$mn:0000BFC4 ?isCreated@StaticDialog@@UBE_NXZ proc near
.text$mn:0000BFC4                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+39p
.text$mn:0000BFC4                                         ; DATA XREF: .rdata:0000E7E0o ...
.text$mn:0000BFC4
.text$mn:0000BFC4 var_8           = dword ptr -8
.text$mn:0000BFC4 var_4           = dword ptr -4
.text$mn:0000BFC4
.text$mn:0000BFC4                 push    ebp
.text$mn:0000BFC5                 mov     ebp, esp
.text$mn:0000BFC7                 sub     esp, 8
.text$mn:0000BFCA                 mov     [ebp+var_8], ecx
.text$mn:0000BFCD                 mov     eax, [ebp+var_8]
.text$mn:0000BFD0                 cmp     dword ptr [eax+0Ch], 0
.text$mn:0000BFD4                 jz      short loc_BFDF
.text$mn:0000BFD6                 mov     [ebp+var_4], 1
.text$mn:0000BFDD                 jmp     short loc_BFE6
.text$mn:0000BFDF ; ---------------------------------------------------------------------------
.text$mn:0000BFDF
.text$mn:0000BFDF loc_BFDF:                               ; CODE XREF: StaticDialog::isCreated(void)+10j
.text$mn:0000BFDF                 mov     [ebp+var_4], 0
.text$mn:0000BFE6
.text$mn:0000BFE6 loc_BFE6:                               ; CODE XREF: StaticDialog::isCreated(void)+19j
.text$mn:0000BFE6                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000BFE9                 mov     esp, ebp
.text$mn:0000BFEB                 pop     ebp
.text$mn:0000BFEC                 retn
.text$mn:0000BFEC ?isCreated@StaticDialog@@UBE_NXZ endp
.text$mn:0000BFEC
.text$mn:0000BFEC ; ---------------------------------------------------------------------------
.text$mn:0000BFED                 align 10h
.text$mn:0000BFED _text$mn        ends
.text$mn:0000BFED
.text$mn:0000BFF0 ; ===========================================================================
.text$mn:0000BFF0
.text$mn:0000BFF0 ; Segment type: Pure code
.text$mn:0000BFF0 ; Segment permissions: Read/Execute
.text$mn:0000BFF0 _text$mn        segment para public 'CODE' use32
.text$mn:0000BFF0                 assume cs:_text$mn
.text$mn:0000BFF0                 ;org 0BFF0h
.text$mn:0000BFF0 ; COMDAT (pick any)
.text$mn:0000BFF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000BFF0
.text$mn:0000BFF0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BFF0
.text$mn:0000BFF0 ; Attributes: bp-based frame
.text$mn:0000BFF0
.text$mn:0000BFF0 ; bool __thiscall Shortcut::isEnabled(Shortcut *__hidden this)
.text$mn:0000BFF0                 public ?isEnabled@Shortcut@@UBE_NXZ
.text$mn:0000BFF0 ?isEnabled@Shortcut@@UBE_NXZ proc near  ; DATA XREF: .rdata:0000E9C4o
.text$mn:0000BFF0                                         ; .rdata:0000EA14o ...
.text$mn:0000BFF0
.text$mn:0000BFF0 var_8           = dword ptr -8
.text$mn:0000BFF0 var_4           = dword ptr -4
.text$mn:0000BFF0
.text$mn:0000BFF0                 push    ebp
.text$mn:0000BFF1                 mov     ebp, esp
.text$mn:0000BFF3                 sub     esp, 8
.text$mn:0000BFF6                 mov     [ebp+var_8], ecx
.text$mn:0000BFF9                 mov     eax, [ebp+var_8]
.text$mn:0000BFFC                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000C000                 test    ecx, ecx
.text$mn:0000C002                 jz      short loc_C00D
.text$mn:0000C004                 mov     [ebp+var_4], 1
.text$mn:0000C00B                 jmp     short loc_C014
.text$mn:0000C00D ; ---------------------------------------------------------------------------
.text$mn:0000C00D
.text$mn:0000C00D loc_C00D:                               ; CODE XREF: Shortcut::isEnabled(void)+12j
.text$mn:0000C00D                 mov     [ebp+var_4], 0
.text$mn:0000C014
.text$mn:0000C014 loc_C014:                               ; CODE XREF: Shortcut::isEnabled(void)+1Bj
.text$mn:0000C014                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000C017                 mov     esp, ebp
.text$mn:0000C019                 pop     ebp
.text$mn:0000C01A                 retn
.text$mn:0000C01A ?isEnabled@Shortcut@@UBE_NXZ endp
.text$mn:0000C01A
.text$mn:0000C01A ; ---------------------------------------------------------------------------
.text$mn:0000C01B                 align 4
.text$mn:0000C01B _text$mn        ends
.text$mn:0000C01B
.text$mn:0000C01C ; ===========================================================================
.text$mn:0000C01C
.text$mn:0000C01C ; Segment type: Pure code
.text$mn:0000C01C ; Segment permissions: Read/Execute
.text$mn:0000C01C _text$mn        segment para public 'CODE' use32
.text$mn:0000C01C                 assume cs:_text$mn
.text$mn:0000C01C                 ;org 0C01Ch
.text$mn:0000C01C ; COMDAT (pick any)
.text$mn:0000C01C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C01C
.text$mn:0000C01C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C01C
.text$mn:0000C01C ; Attributes: bp-based frame
.text$mn:0000C01C
.text$mn:0000C01C ; bool __thiscall PluginCmdShortcut::isValid(PluginCmdShortcut *__hidden this)
.text$mn:0000C01C                 public ?isValid@PluginCmdShortcut@@UBE_NXZ
.text$mn:0000C01C ?isValid@PluginCmdShortcut@@UBE_NXZ proc near
.text$mn:0000C01C                                         ; DATA XREF: .rdata:0000EB50o
.text$mn:0000C01C
.text$mn:0000C01C var_4           = dword ptr -4
.text$mn:0000C01C
.text$mn:0000C01C                 push    ebp
.text$mn:0000C01D                 mov     ebp, esp
.text$mn:0000C01F                 push    ecx
.text$mn:0000C020                 mov     [ebp+var_4], ecx
.text$mn:0000C023                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000C026                 call    ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.text$mn:0000C02B                 movzx   eax, al
.text$mn:0000C02E                 test    eax, eax
.text$mn:0000C030                 jnz     short loc_C036
.text$mn:0000C032                 xor     al, al
.text$mn:0000C034                 jmp     short loc_C05F
.text$mn:0000C036 ; ---------------------------------------------------------------------------
.text$mn:0000C036
.text$mn:0000C036 loc_C036:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+14j
.text$mn:0000C036                 push    0
.text$mn:0000C038                 mov     ecx, [ebp+var_4]
.text$mn:0000C03B                 add     ecx, 130h
.text$mn:0000C041                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:0000C046                 movzx   ecx, word ptr [eax]
.text$mn:0000C049                 test    ecx, ecx
.text$mn:0000C04B                 jz      short loc_C059
.text$mn:0000C04D                 mov     edx, [ebp+var_4]
.text$mn:0000C050                 cmp     dword ptr [edx+14Ch], 0FFFFFFFFh
.text$mn:0000C057                 jnz     short loc_C05D
.text$mn:0000C059
.text$mn:0000C059 loc_C059:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+2Fj
.text$mn:0000C059                 xor     al, al
.text$mn:0000C05B                 jmp     short loc_C05F
.text$mn:0000C05D ; ---------------------------------------------------------------------------
.text$mn:0000C05D
.text$mn:0000C05D loc_C05D:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+3Bj
.text$mn:0000C05D                 mov     al, 1
.text$mn:0000C05F
.text$mn:0000C05F loc_C05F:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+18j
.text$mn:0000C05F                                         ; PluginCmdShortcut::isValid(void)+3Fj
.text$mn:0000C05F                 mov     esp, ebp
.text$mn:0000C061                 pop     ebp
.text$mn:0000C062                 retn
.text$mn:0000C062 ?isValid@PluginCmdShortcut@@UBE_NXZ endp
.text$mn:0000C062
.text$mn:0000C062 ; ---------------------------------------------------------------------------
.text$mn:0000C063                 align 4
.text$mn:0000C063 _text$mn        ends
.text$mn:0000C063
.text$mn:0000C064 ; ===========================================================================
.text$mn:0000C064
.text$mn:0000C064 ; Segment type: Pure code
.text$mn:0000C064 ; Segment permissions: Read/Execute
.text$mn:0000C064 _text$mn        segment para public 'CODE' use32
.text$mn:0000C064                 assume cs:_text$mn
.text$mn:0000C064                 ;org 0C064h
.text$mn:0000C064 ; COMDAT (pick any)
.text$mn:0000C064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C064
.text$mn:0000C064 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C064
.text$mn:0000C064 ; Attributes: bp-based frame
.text$mn:0000C064
.text$mn:0000C064 ; bool __thiscall Shortcut::isValid(Shortcut *__hidden this)
.text$mn:0000C064                 public ?isValid@Shortcut@@UBE_NXZ
.text$mn:0000C064 ?isValid@Shortcut@@UBE_NXZ proc near    ; CODE XREF: PluginCmdShortcut::isValid(void)+Ap
.text$mn:0000C064                                         ; DATA XREF: .rdata:0000E9C0o ...
.text$mn:0000C064
.text$mn:0000C064 var_8           = dword ptr -8
.text$mn:0000C064 var_4           = dword ptr -4
.text$mn:0000C064
.text$mn:0000C064                 push    ebp
.text$mn:0000C065                 mov     ebp, esp
.text$mn:0000C067                 sub     esp, 8
.text$mn:0000C06A                 mov     [ebp+var_4], ecx
.text$mn:0000C06D                 mov     eax, [ebp+var_4]
.text$mn:0000C070                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000C074                 test    ecx, ecx
.text$mn:0000C076                 jnz     short loc_C07F
.text$mn:0000C078                 mov     al, 1
.text$mn:0000C07A                 jmp     loc_C10C
.text$mn:0000C07F ; ---------------------------------------------------------------------------
.text$mn:0000C07F
.text$mn:0000C07F loc_C07F:                               ; CODE XREF: Shortcut::isValid(void)+12j
.text$mn:0000C07F                 mov     edx, [ebp+var_4]
.text$mn:0000C082                 movzx   eax, byte ptr [edx+23h]
.text$mn:0000C086                 cmp     eax, 41h ; 'A'
.text$mn:0000C089                 jl      short loc_C097
.text$mn:0000C08B                 mov     ecx, [ebp+var_4]
.text$mn:0000C08E                 movzx   edx, byte ptr [ecx+23h]
.text$mn:0000C092                 cmp     edx, 5Ah ; 'Z'
.text$mn:0000C095                 jle     short loc_C0DF
.text$mn:0000C097
.text$mn:0000C097 loc_C097:                               ; CODE XREF: Shortcut::isValid(void)+25j
.text$mn:0000C097                 mov     eax, [ebp+var_4]
.text$mn:0000C09A                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000C09E                 cmp     ecx, 30h ; '0'
.text$mn:0000C0A1                 jl      short loc_C0AF
.text$mn:0000C0A3                 mov     edx, [ebp+var_4]
.text$mn:0000C0A6                 movzx   eax, byte ptr [edx+23h]
.text$mn:0000C0AA                 cmp     eax, 39h ; '9'
.text$mn:0000C0AD                 jle     short loc_C0DF
.text$mn:0000C0AF
.text$mn:0000C0AF loc_C0AF:                               ; CODE XREF: Shortcut::isValid(void)+3Dj
.text$mn:0000C0AF                 mov     ecx, [ebp+var_4]
.text$mn:0000C0B2                 movzx   edx, byte ptr [ecx+23h]
.text$mn:0000C0B6                 cmp     edx, 20h ; ' '
.text$mn:0000C0B9                 jz      short loc_C0DF
.text$mn:0000C0BB                 mov     eax, [ebp+var_4]
.text$mn:0000C0BE                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000C0C2                 cmp     ecx, 14h
.text$mn:0000C0C5                 jz      short loc_C0DF
.text$mn:0000C0C7                 mov     edx, [ebp+var_4]
.text$mn:0000C0CA                 movzx   eax, byte ptr [edx+23h]
.text$mn:0000C0CE                 cmp     eax, 8
.text$mn:0000C0D1                 jz      short loc_C0DF
.text$mn:0000C0D3                 mov     ecx, [ebp+var_4]
.text$mn:0000C0D6                 movzx   edx, byte ptr [ecx+23h]
.text$mn:0000C0DA                 cmp     edx, 0Dh
.text$mn:0000C0DD                 jnz     short loc_C10A
.text$mn:0000C0DF
.text$mn:0000C0DF loc_C0DF:                               ; CODE XREF: Shortcut::isValid(void)+31j
.text$mn:0000C0DF                                         ; Shortcut::isValid(void)+49j ...
.text$mn:0000C0DF                 mov     eax, [ebp+var_4]
.text$mn:0000C0E2                 movzx   ecx, byte ptr [eax+20h]
.text$mn:0000C0E6                 test    ecx, ecx
.text$mn:0000C0E8                 jnz     short loc_C0FE
.text$mn:0000C0EA                 mov     edx, [ebp+var_4]
.text$mn:0000C0ED                 movzx   eax, byte ptr [edx+21h]
.text$mn:0000C0F1                 test    eax, eax
.text$mn:0000C0F3                 jnz     short loc_C0FE
.text$mn:0000C0F5                 mov     [ebp+var_8], 0
.text$mn:0000C0FC                 jmp     short loc_C105
.text$mn:0000C0FE ; ---------------------------------------------------------------------------
.text$mn:0000C0FE
.text$mn:0000C0FE loc_C0FE:                               ; CODE XREF: Shortcut::isValid(void)+84j
.text$mn:0000C0FE                                         ; Shortcut::isValid(void)+8Fj
.text$mn:0000C0FE                 mov     [ebp+var_8], 1
.text$mn:0000C105
.text$mn:0000C105 loc_C105:                               ; CODE XREF: Shortcut::isValid(void)+98j
.text$mn:0000C105                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000C108                 jmp     short loc_C10C
.text$mn:0000C10A ; ---------------------------------------------------------------------------
.text$mn:0000C10A
.text$mn:0000C10A loc_C10A:                               ; CODE XREF: Shortcut::isValid(void)+79j
.text$mn:0000C10A                 mov     al, 1
.text$mn:0000C10C
.text$mn:0000C10C loc_C10C:                               ; CODE XREF: Shortcut::isValid(void)+16j
.text$mn:0000C10C                                         ; Shortcut::isValid(void)+A4j
.text$mn:0000C10C                 mov     esp, ebp
.text$mn:0000C10E                 pop     ebp
.text$mn:0000C10F                 retn
.text$mn:0000C10F ?isValid@Shortcut@@UBE_NXZ endp
.text$mn:0000C10F
.text$mn:0000C10F _text$mn        ends
.text$mn:0000C10F
.text$mn:0000C110 ; ===========================================================================
.text$mn:0000C110
.text$mn:0000C110 ; Segment type: Pure code
.text$mn:0000C110 ; Segment permissions: Read/Execute
.text$mn:0000C110 _text$mn        segment para public 'CODE' use32
.text$mn:0000C110                 assume cs:_text$mn
.text$mn:0000C110                 ;org 0C110h
.text$mn:0000C110 ; COMDAT (pick any)
.text$mn:0000C110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C110
.text$mn:0000C110 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C110
.text$mn:0000C110 ; Attributes: bp-based frame
.text$mn:0000C110
.text$mn:0000C110 ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:0000C110                 public ?isVisible@Window@@UBE_NXZ
.text$mn:0000C110 ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:0000E7A4o
.text$mn:0000C110                                         ; .rdata:0000E7D8o ...
.text$mn:0000C110
.text$mn:0000C110 var_8           = dword ptr -8
.text$mn:0000C110 var_1           = byte ptr -1
.text$mn:0000C110
.text$mn:0000C110                 push    ebp
.text$mn:0000C111                 mov     ebp, esp
.text$mn:0000C113                 sub     esp, 8
.text$mn:0000C116                 mov     [ebp+var_8], ecx
.text$mn:0000C119                 mov     eax, [ebp+var_8]
.text$mn:0000C11C                 mov     ecx, [eax+0Ch]
.text$mn:0000C11F                 push    ecx             ; hWnd
.text$mn:0000C120                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000C126                 test    eax, eax
.text$mn:0000C128                 jz      short loc_C130
.text$mn:0000C12A                 mov     [ebp+var_1], 1
.text$mn:0000C12E                 jmp     short loc_C134
.text$mn:0000C130 ; ---------------------------------------------------------------------------
.text$mn:0000C130
.text$mn:0000C130 loc_C130:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:0000C130                 mov     [ebp+var_1], 0
.text$mn:0000C134
.text$mn:0000C134 loc_C134:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:0000C134                 mov     al, [ebp+var_1]
.text$mn:0000C137                 mov     esp, ebp
.text$mn:0000C139                 pop     ebp
.text$mn:0000C13A                 retn
.text$mn:0000C13A ?isVisible@Window@@UBE_NXZ endp
.text$mn:0000C13A
.text$mn:0000C13A ; ---------------------------------------------------------------------------
.text$mn:0000C13B                 align 4
.text$mn:0000C13B _text$mn        ends
.text$mn:0000C13B
.text$mn:0000C13C ; ===========================================================================
.text$mn:0000C13C
.text$mn:0000C13C ; Segment type: Pure code
.text$mn:0000C13C ; Segment permissions: Read/Execute
.text$mn:0000C13C _text$mn        segment para public 'CODE' use32
.text$mn:0000C13C                 assume cs:_text$mn
.text$mn:0000C13C                 ;org 0C13Ch
.text$mn:0000C13C ; COMDAT (pick any)
.text$mn:0000C13C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C13C
.text$mn:0000C13C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C13C
.text$mn:0000C13C ; Attributes: bp-based frame
.text$mn:0000C13C
.text$mn:0000C13C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000C13C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000C13C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000C13C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000C13C
.text$mn:0000C13C var_4           = dword ptr -4
.text$mn:0000C13C Str             = dword ptr  8
.text$mn:0000C13C
.text$mn:0000C13C                 push    ebp
.text$mn:0000C13D                 mov     ebp, esp
.text$mn:0000C13F                 push    ecx
.text$mn:0000C140                 mov     eax, [ebp+Str]
.text$mn:0000C143                 movsx   ecx, byte ptr [eax]
.text$mn:0000C146                 test    ecx, ecx
.text$mn:0000C148                 jnz     short loc_C153
.text$mn:0000C14A                 mov     [ebp+var_4], 0
.text$mn:0000C151                 jmp     short loc_C162
.text$mn:0000C153 ; ---------------------------------------------------------------------------
.text$mn:0000C153
.text$mn:0000C153 loc_C153:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000C153                 mov     edx, [ebp+Str]
.text$mn:0000C156                 push    edx             ; Str
.text$mn:0000C157                 call    _strlen
.text$mn:0000C15C                 add     esp, 4
.text$mn:0000C15F                 mov     [ebp+var_4], eax
.text$mn:0000C162
.text$mn:0000C162 loc_C162:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000C162                 mov     eax, [ebp+var_4]
.text$mn:0000C165                 mov     esp, ebp
.text$mn:0000C167                 pop     ebp
.text$mn:0000C168                 retn
.text$mn:0000C168 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000C168
.text$mn:0000C168 ; ---------------------------------------------------------------------------
.text$mn:0000C169                 align 4
.text$mn:0000C169 _text$mn        ends
.text$mn:0000C169
.text$mn:0000C16C ; ===========================================================================
.text$mn:0000C16C
.text$mn:0000C16C ; Segment type: Pure code
.text$mn:0000C16C ; Segment permissions: Read/Execute
.text$mn:0000C16C _text$mn        segment para public 'CODE' use32
.text$mn:0000C16C                 assume cs:_text$mn
.text$mn:0000C16C                 ;org 0C16Ch
.text$mn:0000C16C ; COMDAT (pick any)
.text$mn:0000C16C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C16C
.text$mn:0000C16C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C16C
.text$mn:0000C16C ; Attributes: bp-based frame
.text$mn:0000C16C
.text$mn:0000C16C ; void __thiscall BabyGridWrapper::makeColAutoWidth(BabyGridWrapper *this, bool)
.text$mn:0000C16C                 public ?makeColAutoWidth@BabyGridWrapper@@QAEX_N@Z
.text$mn:0000C16C ?makeColAutoWidth@BabyGridWrapper@@QAEX_N@Z proc near
.text$mn:0000C16C                                         ; CODE XREF: ShortcutMapper::initBabyGrid(void)+70p
.text$mn:0000C16C
.text$mn:0000C16C var_8           = dword ptr -8
.text$mn:0000C16C wParam          = dword ptr -4
.text$mn:0000C16C arg_0           = byte ptr  8
.text$mn:0000C16C
.text$mn:0000C16C                 push    ebp
.text$mn:0000C16D                 mov     ebp, esp
.text$mn:0000C16F                 sub     esp, 8
.text$mn:0000C172                 mov     [ebp+var_8], ecx
.text$mn:0000C175                 movzx   eax, [ebp+arg_0]
.text$mn:0000C179                 test    eax, eax
.text$mn:0000C17B                 jz      short loc_C186
.text$mn:0000C17D                 mov     [ebp+wParam], 1
.text$mn:0000C184                 jmp     short loc_C18D
.text$mn:0000C186 ; ---------------------------------------------------------------------------
.text$mn:0000C186
.text$mn:0000C186 loc_C186:                               ; CODE XREF: BabyGridWrapper::makeColAutoWidth(bool)+Fj
.text$mn:0000C186                 mov     [ebp+wParam], 0
.text$mn:0000C18D
.text$mn:0000C18D loc_C18D:                               ; CODE XREF: BabyGridWrapper::makeColAutoWidth(bool)+18j
.text$mn:0000C18D                 push    0               ; lParam
.text$mn:0000C18F                 mov     ecx, [ebp+wParam]
.text$mn:0000C192                 push    ecx             ; wParam
.text$mn:0000C193                 push    1F81h           ; Msg
.text$mn:0000C198                 mov     edx, [ebp+var_8]
.text$mn:0000C19B                 mov     eax, [edx+0Ch]
.text$mn:0000C19E                 push    eax             ; hWnd
.text$mn:0000C19F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000C1A5                 mov     esp, ebp
.text$mn:0000C1A7                 pop     ebp
.text$mn:0000C1A8                 retn    4
.text$mn:0000C1A8 ?makeColAutoWidth@BabyGridWrapper@@QAEX_N@Z endp
.text$mn:0000C1A8
.text$mn:0000C1A8 ; ---------------------------------------------------------------------------
.text$mn:0000C1AB                 align 4
.text$mn:0000C1AB _text$mn        ends
.text$mn:0000C1AB
.text$mn:0000C1AC ; ===========================================================================
.text$mn:0000C1AC
.text$mn:0000C1AC ; Segment type: Pure code
.text$mn:0000C1AC ; Segment permissions: Read/Execute
.text$mn:0000C1AC _text$mn        segment para public 'CODE' use32
.text$mn:0000C1AC                 assume cs:_text$mn
.text$mn:0000C1AC                 ;org 0C1ACh
.text$mn:0000C1AC ; COMDAT (pick any)
.text$mn:0000C1AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C1AC
.text$mn:0000C1AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1AC
.text$mn:0000C1AC ; Attributes: bp-based frame
.text$mn:0000C1AC
.text$mn:0000C1AC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000C1AC                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000C1AC ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000C1AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000C1AC
.text$mn:0000C1AC var_4           = dword ptr -4
.text$mn:0000C1AC
.text$mn:0000C1AC                 push    ebp
.text$mn:0000C1AD                 mov     ebp, esp
.text$mn:0000C1AF                 push    ecx
.text$mn:0000C1B0                 mov     [ebp+var_4], ecx
.text$mn:0000C1B3                 mov     eax, [ebp+var_4]
.text$mn:0000C1B6                 push    eax
.text$mn:0000C1B7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000C1BC                 add     esp, 4
.text$mn:0000C1BF                 mov     esp, ebp
.text$mn:0000C1C1                 pop     ebp
.text$mn:0000C1C2                 retn
.text$mn:0000C1C2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000C1C2
.text$mn:0000C1C2 ; ---------------------------------------------------------------------------
.text$mn:0000C1C3                 align 4
.text$mn:0000C1C3 _text$mn        ends
.text$mn:0000C1C3
.text$mn:0000C1C4 ; ===========================================================================
.text$mn:0000C1C4
.text$mn:0000C1C4 ; Segment type: Pure code
.text$mn:0000C1C4 ; Segment permissions: Read/Execute
.text$mn:0000C1C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C1C4                 assume cs:_text$mn
.text$mn:0000C1C4                 ;org 0C1C4h
.text$mn:0000C1C4 ; COMDAT (pick any)
.text$mn:0000C1C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C1C4
.text$mn:0000C1C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1C4
.text$mn:0000C1C4 ; Attributes: bp-based frame
.text$mn:0000C1C4
.text$mn:0000C1C4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct KeyCombo>>::max_size(void)const
.text$mn:0000C1C4                 public ?max_size@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ
.text$mn:0000C1C4 ?max_size@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C1C4                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::max_size(void)+17p
.text$mn:0000C1C4
.text$mn:0000C1C4 var_4           = dword ptr -4
.text$mn:0000C1C4
.text$mn:0000C1C4                 push    ebp
.text$mn:0000C1C5                 mov     ebp, esp
.text$mn:0000C1C7                 push    ecx
.text$mn:0000C1C8                 mov     [ebp+var_4], ecx
.text$mn:0000C1CB                 mov     eax, [ebp+var_4]
.text$mn:0000C1CE                 push    eax
.text$mn:0000C1CF                 call    ?max_size@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAIABV?$allocator@UKeyCombo@@@2@@Z ; std::allocator_traits<std::allocator<KeyCombo>>::max_size(std::allocator<KeyCombo> const &)
.text$mn:0000C1D4                 add     esp, 4
.text$mn:0000C1D7                 mov     esp, ebp
.text$mn:0000C1D9                 pop     ebp
.text$mn:0000C1DA                 retn
.text$mn:0000C1DA ?max_size@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ endp
.text$mn:0000C1DA
.text$mn:0000C1DA ; ---------------------------------------------------------------------------
.text$mn:0000C1DB                 align 4
.text$mn:0000C1DB _text$mn        ends
.text$mn:0000C1DB
.text$mn:0000C1DC ; ===========================================================================
.text$mn:0000C1DC
.text$mn:0000C1DC ; Segment type: Pure code
.text$mn:0000C1DC ; Segment permissions: Read/Execute
.text$mn:0000C1DC _text$mn        segment para public 'CODE' use32
.text$mn:0000C1DC                 assume cs:_text$mn
.text$mn:0000C1DC                 ;org 0C1DCh
.text$mn:0000C1DC ; COMDAT (pick any)
.text$mn:0000C1DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C1DC
.text$mn:0000C1DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1DC
.text$mn:0000C1DC ; Attributes: bp-based frame
.text$mn:0000C1DC
.text$mn:0000C1DC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::max_size(void)const
.text$mn:0000C1DC                 public ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000C1DC ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C1DC                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::max_size(void)+17p
.text$mn:0000C1DC
.text$mn:0000C1DC var_4           = dword ptr -4
.text$mn:0000C1DC
.text$mn:0000C1DC                 push    ebp
.text$mn:0000C1DD                 mov     ebp, esp
.text$mn:0000C1DF                 push    ecx
.text$mn:0000C1E0                 mov     [ebp+var_4], ecx
.text$mn:0000C1E3                 mov     eax, [ebp+var_4]
.text$mn:0000C1E6                 push    eax
.text$mn:0000C1E7                 call    ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z ; std::allocator_traits<std::allocator<MenuItemUnit>>::max_size(std::allocator<MenuItemUnit> const &)
.text$mn:0000C1EC                 add     esp, 4
.text$mn:0000C1EF                 mov     esp, ebp
.text$mn:0000C1F1                 pop     ebp
.text$mn:0000C1F2                 retn
.text$mn:0000C1F2 ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000C1F2
.text$mn:0000C1F2 ; ---------------------------------------------------------------------------
.text$mn:0000C1F3                 align 4
.text$mn:0000C1F3 _text$mn        ends
.text$mn:0000C1F3
.text$mn:0000C1F4 ; ===========================================================================
.text$mn:0000C1F4
.text$mn:0000C1F4 ; Segment type: Pure code
.text$mn:0000C1F4 ; Segment permissions: Read/Execute
.text$mn:0000C1F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C1F4                 assume cs:_text$mn
.text$mn:0000C1F4                 ;org 0C1F4h
.text$mn:0000C1F4 ; COMDAT (pick any)
.text$mn:0000C1F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C1F4
.text$mn:0000C1F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1F4
.text$mn:0000C1F4 ; Attributes: bp-based frame
.text$mn:0000C1F4
.text$mn:0000C1F4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::max_size(void)const
.text$mn:0000C1F4                 public ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:0000C1F4 ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C1F4                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::max_size(void)+17p
.text$mn:0000C1F4
.text$mn:0000C1F4 var_4           = dword ptr -4
.text$mn:0000C1F4
.text$mn:0000C1F4                 push    ebp
.text$mn:0000C1F5                 mov     ebp, esp
.text$mn:0000C1F7                 push    ecx
.text$mn:0000C1F8                 mov     [ebp+var_4], ecx
.text$mn:0000C1FB                 mov     eax, [ebp+var_4]
.text$mn:0000C1FE                 push    eax
.text$mn:0000C1FF                 call    ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::max_size(std::allocator<recordedMacroStep> const &)
.text$mn:0000C204                 add     esp, 4
.text$mn:0000C207                 mov     esp, ebp
.text$mn:0000C209                 pop     ebp
.text$mn:0000C20A                 retn
.text$mn:0000C20A ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:0000C20A
.text$mn:0000C20A ; ---------------------------------------------------------------------------
.text$mn:0000C20B                 align 4
.text$mn:0000C20B _text$mn        ends
.text$mn:0000C20B
.text$mn:0000C20C ; ===========================================================================
.text$mn:0000C20C
.text$mn:0000C20C ; Segment type: Pure code
.text$mn:0000C20C ; Segment permissions: Read/Execute
.text$mn:0000C20C _text$mn        segment para public 'CODE' use32
.text$mn:0000C20C                 assume cs:_text$mn
.text$mn:0000C20C                 ;org 0C20Ch
.text$mn:0000C20C ; COMDAT (pick any)
.text$mn:0000C20C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C20C
.text$mn:0000C20C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C20C
.text$mn:0000C20C ; Attributes: bp-based frame
.text$mn:0000C20C
.text$mn:0000C20C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000C20C                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000C20C ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000C20C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000C20C
.text$mn:0000C20C var_4           = dword ptr -4
.text$mn:0000C20C
.text$mn:0000C20C                 push    ebp
.text$mn:0000C20D                 mov     ebp, esp
.text$mn:0000C20F                 push    ecx
.text$mn:0000C210                 mov     [ebp+var_4], ecx
.text$mn:0000C213                 mov     eax, [ebp+var_4]
.text$mn:0000C216                 push    eax
.text$mn:0000C217                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:0000C21C                 add     esp, 4
.text$mn:0000C21F                 mov     esp, ebp
.text$mn:0000C221                 pop     ebp
.text$mn:0000C222                 retn
.text$mn:0000C222 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000C222
.text$mn:0000C222 ; ---------------------------------------------------------------------------
.text$mn:0000C223                 align 4
.text$mn:0000C223 _text$mn        ends
.text$mn:0000C223
.text$mn:0000C224 ; ===========================================================================
.text$mn:0000C224
.text$mn:0000C224 ; Segment type: Pure code
.text$mn:0000C224 ; Segment permissions: Read/Execute
.text$mn:0000C224 _text$mn        segment para public 'CODE' use32
.text$mn:0000C224                 assume cs:_text$mn
.text$mn:0000C224                 ;org 0C224h
.text$mn:0000C224 ; COMDAT (pick any)
.text$mn:0000C224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C224
.text$mn:0000C224 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C224
.text$mn:0000C224 ; Attributes: bp-based frame
.text$mn:0000C224
.text$mn:0000C224 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000C224                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000C224 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000C224                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000C224
.text$mn:0000C224 var_4           = dword ptr -4
.text$mn:0000C224
.text$mn:0000C224                 push    ebp
.text$mn:0000C225                 mov     ebp, esp
.text$mn:0000C227                 push    ecx
.text$mn:0000C228                 mov     [ebp+var_4], ecx
.text$mn:0000C22B                 or      eax, 0FFFFFFFFh
.text$mn:0000C22E                 mov     esp, ebp
.text$mn:0000C230                 pop     ebp
.text$mn:0000C231                 retn
.text$mn:0000C231 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000C231
.text$mn:0000C231 ; ---------------------------------------------------------------------------
.text$mn:0000C232                 align 4
.text$mn:0000C232 _text$mn        ends
.text$mn:0000C232
.text$mn:0000C234 ; ===========================================================================
.text$mn:0000C234
.text$mn:0000C234 ; Segment type: Pure code
.text$mn:0000C234 ; Segment permissions: Read/Execute
.text$mn:0000C234 _text$mn        segment para public 'CODE' use32
.text$mn:0000C234                 assume cs:_text$mn
.text$mn:0000C234                 ;org 0C234h
.text$mn:0000C234 ; COMDAT (pick any)
.text$mn:0000C234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C234
.text$mn:0000C234 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C234
.text$mn:0000C234 ; Attributes: bp-based frame
.text$mn:0000C234
.text$mn:0000C234 ; public: unsigned int __thiscall std::allocator<struct KeyCombo>::max_size(void)const
.text$mn:0000C234                 public ?max_size@?$allocator@UKeyCombo@@@std@@QBEIXZ
.text$mn:0000C234 ?max_size@?$allocator@UKeyCombo@@@std@@QBEIXZ proc near
.text$mn:0000C234                                         ; CODE XREF: std::allocator_traits<std::allocator<KeyCombo>>::max_size(std::allocator<KeyCombo> const &)+6p
.text$mn:0000C234
.text$mn:0000C234 var_4           = dword ptr -4
.text$mn:0000C234
.text$mn:0000C234                 push    ebp
.text$mn:0000C235                 mov     ebp, esp
.text$mn:0000C237                 push    ecx
.text$mn:0000C238                 mov     [ebp+var_4], ecx
.text$mn:0000C23B                 mov     eax, 3FFFFFFFh
.text$mn:0000C240                 mov     esp, ebp
.text$mn:0000C242                 pop     ebp
.text$mn:0000C243                 retn
.text$mn:0000C243 ?max_size@?$allocator@UKeyCombo@@@std@@QBEIXZ endp
.text$mn:0000C243
.text$mn:0000C243 _text$mn        ends
.text$mn:0000C243
.text$mn:0000C244 ; ===========================================================================
.text$mn:0000C244
.text$mn:0000C244 ; Segment type: Pure code
.text$mn:0000C244 ; Segment permissions: Read/Execute
.text$mn:0000C244 _text$mn        segment para public 'CODE' use32
.text$mn:0000C244                 assume cs:_text$mn
.text$mn:0000C244                 ;org 0C244h
.text$mn:0000C244 ; COMDAT (pick any)
.text$mn:0000C244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C244
.text$mn:0000C244 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C244
.text$mn:0000C244 ; Attributes: bp-based frame
.text$mn:0000C244
.text$mn:0000C244 ; public: unsigned int __thiscall std::allocator<struct MenuItemUnit>::max_size(void)const
.text$mn:0000C244                 public ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ
.text$mn:0000C244 ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ proc near
.text$mn:0000C244                                         ; CODE XREF: std::allocator_traits<std::allocator<MenuItemUnit>>::max_size(std::allocator<MenuItemUnit> const &)+6p
.text$mn:0000C244
.text$mn:0000C244 var_4           = dword ptr -4
.text$mn:0000C244
.text$mn:0000C244                 push    ebp
.text$mn:0000C245                 mov     ebp, esp
.text$mn:0000C247                 push    ecx
.text$mn:0000C248                 mov     [ebp+var_4], ecx
.text$mn:0000C24B                 mov     eax, 4444444h
.text$mn:0000C250                 mov     esp, ebp
.text$mn:0000C252                 pop     ebp
.text$mn:0000C253                 retn
.text$mn:0000C253 ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ endp
.text$mn:0000C253
.text$mn:0000C253 _text$mn        ends
.text$mn:0000C253
.text$mn:0000C254 ; ===========================================================================
.text$mn:0000C254
.text$mn:0000C254 ; Segment type: Pure code
.text$mn:0000C254 ; Segment permissions: Read/Execute
.text$mn:0000C254 _text$mn        segment para public 'CODE' use32
.text$mn:0000C254                 assume cs:_text$mn
.text$mn:0000C254                 ;org 0C254h
.text$mn:0000C254 ; COMDAT (pick any)
.text$mn:0000C254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C254
.text$mn:0000C254 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C254
.text$mn:0000C254 ; Attributes: bp-based frame
.text$mn:0000C254
.text$mn:0000C254 ; public: unsigned int __thiscall std::allocator<struct recordedMacroStep>::max_size(void)const
.text$mn:0000C254                 public ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ
.text$mn:0000C254 ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ proc near
.text$mn:0000C254                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::max_size(std::allocator<recordedMacroStep> const &)+6p
.text$mn:0000C254
.text$mn:0000C254 var_4           = dword ptr -4
.text$mn:0000C254
.text$mn:0000C254                 push    ebp
.text$mn:0000C255                 mov     ebp, esp
.text$mn:0000C257                 push    ecx
.text$mn:0000C258                 mov     [ebp+var_4], ecx
.text$mn:0000C25B                 mov     eax, 5D1745Dh
.text$mn:0000C260                 mov     esp, ebp
.text$mn:0000C262                 pop     ebp
.text$mn:0000C263                 retn
.text$mn:0000C263 ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ endp
.text$mn:0000C263
.text$mn:0000C263 _text$mn        ends
.text$mn:0000C263
.text$mn:0000C264 ; ===========================================================================
.text$mn:0000C264
.text$mn:0000C264 ; Segment type: Pure code
.text$mn:0000C264 ; Segment permissions: Read/Execute
.text$mn:0000C264 _text$mn        segment para public 'CODE' use32
.text$mn:0000C264                 assume cs:_text$mn
.text$mn:0000C264                 ;org 0C264h
.text$mn:0000C264 ; COMDAT (pick any)
.text$mn:0000C264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C264
.text$mn:0000C264 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C264
.text$mn:0000C264 ; Attributes: bp-based frame
.text$mn:0000C264
.text$mn:0000C264 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000C264                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000C264 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000C264                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000C264
.text$mn:0000C264 var_4           = dword ptr -4
.text$mn:0000C264
.text$mn:0000C264                 push    ebp
.text$mn:0000C265                 mov     ebp, esp
.text$mn:0000C267                 push    ecx
.text$mn:0000C268                 mov     [ebp+var_4], ecx
.text$mn:0000C26B                 mov     eax, 7FFFFFFFh
.text$mn:0000C270                 mov     esp, ebp
.text$mn:0000C272                 pop     ebp
.text$mn:0000C273                 retn
.text$mn:0000C273 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000C273
.text$mn:0000C273 _text$mn        ends
.text$mn:0000C273
.text$mn:0000C274 ; ===========================================================================
.text$mn:0000C274
.text$mn:0000C274 ; Segment type: Pure code
.text$mn:0000C274 ; Segment permissions: Read/Execute
.text$mn:0000C274 _text$mn        segment para public 'CODE' use32
.text$mn:0000C274                 assume cs:_text$mn
.text$mn:0000C274                 ;org 0C274h
.text$mn:0000C274 ; COMDAT (pick any)
.text$mn:0000C274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C274
.text$mn:0000C274 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C274
.text$mn:0000C274 ; Attributes: bp-based frame
.text$mn:0000C274
.text$mn:0000C274 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000C274                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000C274 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000C274                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000C274
.text$mn:0000C274 arg_0           = dword ptr  8
.text$mn:0000C274
.text$mn:0000C274                 push    ebp
.text$mn:0000C275                 mov     ebp, esp
.text$mn:0000C277                 mov     ecx, [ebp+arg_0]
.text$mn:0000C27A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000C27F                 pop     ebp
.text$mn:0000C280                 retn
.text$mn:0000C280 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:0000C280
.text$mn:0000C280 ; ---------------------------------------------------------------------------
.text$mn:0000C281                 align 4
.text$mn:0000C281 _text$mn        ends
.text$mn:0000C281
.text$mn:0000C284 ; ===========================================================================
.text$mn:0000C284
.text$mn:0000C284 ; Segment type: Pure code
.text$mn:0000C284 ; Segment permissions: Read/Execute
.text$mn:0000C284 _text$mn        segment para public 'CODE' use32
.text$mn:0000C284                 assume cs:_text$mn
.text$mn:0000C284                 ;org 0C284h
.text$mn:0000C284 ; COMDAT (pick any)
.text$mn:0000C284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C284
.text$mn:0000C284 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C284
.text$mn:0000C284 ; Attributes: bp-based frame
.text$mn:0000C284
.text$mn:0000C284 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct KeyCombo>>::max_size(class std::allocator<struct KeyCombo> const &)
.text$mn:0000C284                 public ?max_size@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAIABV?$allocator@UKeyCombo@@@2@@Z
.text$mn:0000C284 ?max_size@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAIABV?$allocator@UKeyCombo@@@2@@Z proc near
.text$mn:0000C284                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::max_size(void)+Bp
.text$mn:0000C284
.text$mn:0000C284 arg_0           = dword ptr  8
.text$mn:0000C284
.text$mn:0000C284                 push    ebp
.text$mn:0000C285                 mov     ebp, esp
.text$mn:0000C287                 mov     ecx, [ebp+arg_0]
.text$mn:0000C28A                 call    ?max_size@?$allocator@UKeyCombo@@@std@@QBEIXZ ; std::allocator<KeyCombo>::max_size(void)
.text$mn:0000C28F                 pop     ebp
.text$mn:0000C290                 retn
.text$mn:0000C290 ?max_size@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SAIABV?$allocator@UKeyCombo@@@2@@Z endp
.text$mn:0000C290
.text$mn:0000C290 ; ---------------------------------------------------------------------------
.text$mn:0000C291                 align 4
.text$mn:0000C291 _text$mn        ends
.text$mn:0000C291
.text$mn:0000C294 ; ===========================================================================
.text$mn:0000C294
.text$mn:0000C294 ; Segment type: Pure code
.text$mn:0000C294 ; Segment permissions: Read/Execute
.text$mn:0000C294 _text$mn        segment para public 'CODE' use32
.text$mn:0000C294                 assume cs:_text$mn
.text$mn:0000C294                 ;org 0C294h
.text$mn:0000C294 ; COMDAT (pick any)
.text$mn:0000C294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C294
.text$mn:0000C294 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C294
.text$mn:0000C294 ; Attributes: bp-based frame
.text$mn:0000C294
.text$mn:0000C294 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct MenuItemUnit>>::max_size(class std::allocator<struct MenuItemUnit> const &)
.text$mn:0000C294                 public ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z
.text$mn:0000C294 ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z proc near
.text$mn:0000C294                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::max_size(void)+Bp
.text$mn:0000C294
.text$mn:0000C294 arg_0           = dword ptr  8
.text$mn:0000C294
.text$mn:0000C294                 push    ebp
.text$mn:0000C295                 mov     ebp, esp
.text$mn:0000C297                 mov     ecx, [ebp+arg_0]
.text$mn:0000C29A                 call    ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ ; std::allocator<MenuItemUnit>::max_size(void)
.text$mn:0000C29F                 pop     ebp
.text$mn:0000C2A0                 retn
.text$mn:0000C2A0 ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z endp
.text$mn:0000C2A0
.text$mn:0000C2A0 ; ---------------------------------------------------------------------------
.text$mn:0000C2A1                 align 4
.text$mn:0000C2A1 _text$mn        ends
.text$mn:0000C2A1
.text$mn:0000C2A4 ; ===========================================================================
.text$mn:0000C2A4
.text$mn:0000C2A4 ; Segment type: Pure code
.text$mn:0000C2A4 ; Segment permissions: Read/Execute
.text$mn:0000C2A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2A4                 assume cs:_text$mn
.text$mn:0000C2A4                 ;org 0C2A4h
.text$mn:0000C2A4 ; COMDAT (pick any)
.text$mn:0000C2A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2A4
.text$mn:0000C2A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2A4
.text$mn:0000C2A4 ; Attributes: bp-based frame
.text$mn:0000C2A4
.text$mn:0000C2A4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct recordedMacroStep>>::max_size(class std::allocator<struct recordedMacroStep> const &)
.text$mn:0000C2A4                 public ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z
.text$mn:0000C2A4 ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z proc near
.text$mn:0000C2A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::max_size(void)+Bp
.text$mn:0000C2A4
.text$mn:0000C2A4 arg_0           = dword ptr  8
.text$mn:0000C2A4
.text$mn:0000C2A4                 push    ebp
.text$mn:0000C2A5                 mov     ebp, esp
.text$mn:0000C2A7                 mov     ecx, [ebp+arg_0]
.text$mn:0000C2AA                 call    ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ ; std::allocator<recordedMacroStep>::max_size(void)
.text$mn:0000C2AF                 pop     ebp
.text$mn:0000C2B0                 retn
.text$mn:0000C2B0 ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z endp
.text$mn:0000C2B0
.text$mn:0000C2B0 ; ---------------------------------------------------------------------------
.text$mn:0000C2B1                 align 4
.text$mn:0000C2B1 _text$mn        ends
.text$mn:0000C2B1
.text$mn:0000C2B4 ; ===========================================================================
.text$mn:0000C2B4
.text$mn:0000C2B4 ; Segment type: Pure code
.text$mn:0000C2B4 ; Segment permissions: Read/Execute
.text$mn:0000C2B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2B4                 assume cs:_text$mn
.text$mn:0000C2B4                 ;org 0C2B4h
.text$mn:0000C2B4 ; COMDAT (pick any)
.text$mn:0000C2B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2B4
.text$mn:0000C2B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2B4
.text$mn:0000C2B4 ; Attributes: bp-based frame
.text$mn:0000C2B4
.text$mn:0000C2B4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:0000C2B4                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:0000C2B4 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:0000C2B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:0000C2B4
.text$mn:0000C2B4 arg_0           = dword ptr  8
.text$mn:0000C2B4
.text$mn:0000C2B4                 push    ebp
.text$mn:0000C2B5                 mov     ebp, esp
.text$mn:0000C2B7                 mov     ecx, [ebp+arg_0]
.text$mn:0000C2BA                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000C2BF                 pop     ebp
.text$mn:0000C2C0                 retn
.text$mn:0000C2C0 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:0000C2C0
.text$mn:0000C2C0 ; ---------------------------------------------------------------------------
.text$mn:0000C2C1                 align 4
.text$mn:0000C2C1 _text$mn        ends
.text$mn:0000C2C1
.text$mn:0000C2C4 ; ===========================================================================
.text$mn:0000C2C4
.text$mn:0000C2C4 ; Segment type: Pure code
.text$mn:0000C2C4 ; Segment permissions: Read/Execute
.text$mn:0000C2C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2C4                 assume cs:_text$mn
.text$mn:0000C2C4                 ;org 0C2C4h
.text$mn:0000C2C4 ; COMDAT (pick any)
.text$mn:0000C2C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C2C4
.text$mn:0000C2C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2C4
.text$mn:0000C2C4 ; Attributes: bp-based frame
.text$mn:0000C2C4
.text$mn:0000C2C4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000C2C4                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000C2C4 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000C2C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000C2C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000C2C4
.text$mn:0000C2C4 var_10          = dword ptr -10h
.text$mn:0000C2C4 var_C           = dword ptr -0Ch
.text$mn:0000C2C4 var_8           = dword ptr -8
.text$mn:0000C2C4 var_1           = byte ptr -1
.text$mn:0000C2C4
.text$mn:0000C2C4                 push    ebp
.text$mn:0000C2C5                 mov     ebp, esp
.text$mn:0000C2C7                 sub     esp, 10h
.text$mn:0000C2CA                 mov     [ebp+var_10], ecx
.text$mn:0000C2CD                 lea     eax, [ebp+var_1]
.text$mn:0000C2D0                 push    eax
.text$mn:0000C2D1                 mov     ecx, [ebp+var_10]
.text$mn:0000C2D4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000C2D9                 mov     ecx, eax
.text$mn:0000C2DB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:0000C2E0                 mov     [ebp+var_8], eax
.text$mn:0000C2E3                 cmp     [ebp+var_8], 1
.text$mn:0000C2E7                 ja      short loc_C2F2
.text$mn:0000C2E9                 mov     [ebp+var_C], 1
.text$mn:0000C2F0                 jmp     short loc_C2FB
.text$mn:0000C2F2 ; ---------------------------------------------------------------------------
.text$mn:0000C2F2
.text$mn:0000C2F2 loc_C2F2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000C2F2                 mov     ecx, [ebp+var_8]
.text$mn:0000C2F5                 sub     ecx, 1
.text$mn:0000C2F8                 mov     [ebp+var_C], ecx
.text$mn:0000C2FB
.text$mn:0000C2FB loc_C2FB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000C2FB                 mov     eax, [ebp+var_C]
.text$mn:0000C2FE                 mov     esp, ebp
.text$mn:0000C300                 pop     ebp
.text$mn:0000C301                 retn
.text$mn:0000C301 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000C301
.text$mn:0000C301 ; ---------------------------------------------------------------------------
.text$mn:0000C302                 align 4
.text$mn:0000C302 _text$mn        ends
.text$mn:0000C302
.text$mn:0000C304 ; ===========================================================================
.text$mn:0000C304
.text$mn:0000C304 ; Segment type: Pure code
.text$mn:0000C304 ; Segment permissions: Read/Execute
.text$mn:0000C304 _text$mn        segment para public 'CODE' use32
.text$mn:0000C304                 assume cs:_text$mn
.text$mn:0000C304                 ;org 0C304h
.text$mn:0000C304 ; COMDAT (pick any)
.text$mn:0000C304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C304
.text$mn:0000C304 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C304
.text$mn:0000C304 ; Attributes: bp-based frame
.text$mn:0000C304
.text$mn:0000C304 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000C304                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000C304 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000C304                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000C304                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000C304
.text$mn:0000C304 var_10          = dword ptr -10h
.text$mn:0000C304 var_C           = dword ptr -0Ch
.text$mn:0000C304 var_8           = dword ptr -8
.text$mn:0000C304 var_1           = byte ptr -1
.text$mn:0000C304
.text$mn:0000C304                 push    ebp
.text$mn:0000C305                 mov     ebp, esp
.text$mn:0000C307                 sub     esp, 10h
.text$mn:0000C30A                 mov     [ebp+var_10], ecx
.text$mn:0000C30D                 lea     eax, [ebp+var_1]
.text$mn:0000C310                 push    eax
.text$mn:0000C311                 mov     ecx, [ebp+var_10]
.text$mn:0000C314                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000C319                 mov     ecx, eax
.text$mn:0000C31B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000C320                 mov     [ebp+var_8], eax
.text$mn:0000C323                 cmp     [ebp+var_8], 1
.text$mn:0000C327                 ja      short loc_C332
.text$mn:0000C329                 mov     [ebp+var_C], 1
.text$mn:0000C330                 jmp     short loc_C33B
.text$mn:0000C332 ; ---------------------------------------------------------------------------
.text$mn:0000C332
.text$mn:0000C332 loc_C332:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000C332                 mov     ecx, [ebp+var_8]
.text$mn:0000C335                 sub     ecx, 1
.text$mn:0000C338                 mov     [ebp+var_C], ecx
.text$mn:0000C33B
.text$mn:0000C33B loc_C33B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000C33B                 mov     eax, [ebp+var_C]
.text$mn:0000C33E                 mov     esp, ebp
.text$mn:0000C340                 pop     ebp
.text$mn:0000C341                 retn
.text$mn:0000C341 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000C341
.text$mn:0000C341 ; ---------------------------------------------------------------------------
.text$mn:0000C342                 align 4
.text$mn:0000C342 _text$mn        ends
.text$mn:0000C342
.text$mn:0000C344 ; ===========================================================================
.text$mn:0000C344
.text$mn:0000C344 ; Segment type: Pure code
.text$mn:0000C344 ; Segment permissions: Read/Execute
.text$mn:0000C344 _text$mn        segment para public 'CODE' use32
.text$mn:0000C344                 assume cs:_text$mn
.text$mn:0000C344                 ;org 0C344h
.text$mn:0000C344 ; COMDAT (pick any)
.text$mn:0000C344                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C344
.text$mn:0000C344 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C344
.text$mn:0000C344 ; Attributes: bp-based frame
.text$mn:0000C344
.text$mn:0000C344 ; public: unsigned int __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::max_size(void)const
.text$mn:0000C344                 public ?max_size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ
.text$mn:0000C344 ?max_size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C344                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Buy(uint)+36p
.text$mn:0000C344
.text$mn:0000C344 var_8           = dword ptr -8
.text$mn:0000C344 var_1           = byte ptr -1
.text$mn:0000C344
.text$mn:0000C344                 push    ebp
.text$mn:0000C345                 mov     ebp, esp
.text$mn:0000C347                 sub     esp, 8
.text$mn:0000C34A                 mov     [ebp+var_8], ecx
.text$mn:0000C34D                 lea     eax, [ebp+var_1]
.text$mn:0000C350                 push    eax
.text$mn:0000C351                 mov     ecx, [ebp+var_8]
.text$mn:0000C354                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<KeyCombo,std::allocator<KeyCombo>>>::_Getal(void)
.text$mn:0000C359                 mov     ecx, eax
.text$mn:0000C35B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<KeyCombo>>::max_size(void)
.text$mn:0000C360                 mov     esp, ebp
.text$mn:0000C362                 pop     ebp
.text$mn:0000C363                 retn
.text$mn:0000C363 ?max_size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ endp
.text$mn:0000C363
.text$mn:0000C363 _text$mn        ends
.text$mn:0000C363
.text$mn:0000C364 ; ===========================================================================
.text$mn:0000C364
.text$mn:0000C364 ; Segment type: Pure code
.text$mn:0000C364 ; Segment permissions: Read/Execute
.text$mn:0000C364 _text$mn        segment para public 'CODE' use32
.text$mn:0000C364                 assume cs:_text$mn
.text$mn:0000C364                 ;org 0C364h
.text$mn:0000C364 ; COMDAT (pick any)
.text$mn:0000C364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C364
.text$mn:0000C364 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C364
.text$mn:0000C364 ; Attributes: bp-based frame
.text$mn:0000C364
.text$mn:0000C364 ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::max_size(void)const
.text$mn:0000C364                 public ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000C364 ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C364                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+17p
.text$mn:0000C364                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+18p
.text$mn:0000C364
.text$mn:0000C364 var_8           = dword ptr -8
.text$mn:0000C364 var_1           = byte ptr -1
.text$mn:0000C364
.text$mn:0000C364                 push    ebp
.text$mn:0000C365                 mov     ebp, esp
.text$mn:0000C367                 sub     esp, 8
.text$mn:0000C36A                 mov     [ebp+var_8], ecx
.text$mn:0000C36D                 lea     eax, [ebp+var_1]
.text$mn:0000C370                 push    eax
.text$mn:0000C371                 mov     ecx, [ebp+var_8]
.text$mn:0000C374                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000C379                 mov     ecx, eax
.text$mn:0000C37B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::max_size(void)
.text$mn:0000C380                 mov     esp, ebp
.text$mn:0000C382                 pop     ebp
.text$mn:0000C383                 retn
.text$mn:0000C383 ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000C383
.text$mn:0000C383 _text$mn        ends
.text$mn:0000C383
.text$mn:0000C384 ; ===========================================================================
.text$mn:0000C384
.text$mn:0000C384 ; Segment type: Pure code
.text$mn:0000C384 ; Segment permissions: Read/Execute
.text$mn:0000C384 _text$mn        segment para public 'CODE' use32
.text$mn:0000C384                 assume cs:_text$mn
.text$mn:0000C384                 ;org 0C384h
.text$mn:0000C384 ; COMDAT (pick any)
.text$mn:0000C384                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C384
.text$mn:0000C384 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C384
.text$mn:0000C384 ; Attributes: bp-based frame
.text$mn:0000C384
.text$mn:0000C384 ; public: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::max_size(void)const
.text$mn:0000C384                 public ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:0000C384 ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C384                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Buy(uint)+36p
.text$mn:0000C384
.text$mn:0000C384 var_8           = dword ptr -8
.text$mn:0000C384 var_1           = byte ptr -1
.text$mn:0000C384
.text$mn:0000C384                 push    ebp
.text$mn:0000C385                 mov     ebp, esp
.text$mn:0000C387                 sub     esp, 8
.text$mn:0000C38A                 mov     [ebp+var_8], ecx
.text$mn:0000C38D                 lea     eax, [ebp+var_1]
.text$mn:0000C390                 push    eax
.text$mn:0000C391                 mov     ecx, [ebp+var_8]
.text$mn:0000C394                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000C399                 mov     ecx, eax
.text$mn:0000C39B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::max_size(void)
.text$mn:0000C3A0                 mov     esp, ebp
.text$mn:0000C3A2                 pop     ebp
.text$mn:0000C3A3                 retn
.text$mn:0000C3A3 ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:0000C3A3
.text$mn:0000C3A3 _text$mn        ends
.text$mn:0000C3A3
.text$mn:0000C3A4 ; ===========================================================================
.text$mn:0000C3A4
.text$mn:0000C3A4 ; Segment type: Pure code
.text$mn:0000C3A4 ; Segment permissions: Read/Execute
.text$mn:0000C3A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C3A4                 assume cs:_text$mn
.text$mn:0000C3A4                 ;org 0C3A4h
.text$mn:0000C3A4 ; COMDAT (pick any)
.text$mn:0000C3A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C3A4
.text$mn:0000C3A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C3A4
.text$mn:0000C3A4 ; Attributes: bp-based frame
.text$mn:0000C3A4
.text$mn:0000C3A4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000C3A4                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C3A4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000C3A4                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000C3A4                                         ; DATA XREF: .rdata:0000E8D8o
.text$mn:0000C3A4
.text$mn:0000C3A4 var_1C          = dword ptr -1Ch
.text$mn:0000C3A4 var_18          = dword ptr -18h
.text$mn:0000C3A4 Str             = dword ptr -14h
.text$mn:0000C3A4 var_10          = dword ptr -10h
.text$mn:0000C3A4 var_C           = dword ptr -0Ch
.text$mn:0000C3A4 var_4           = dword ptr -4
.text$mn:0000C3A4 arg_0           = dword ptr  8
.text$mn:0000C3A4 arg_4           = dword ptr  0Ch
.text$mn:0000C3A4
.text$mn:0000C3A4                 push    ebp
.text$mn:0000C3A5                 mov     ebp, esp
.text$mn:0000C3A7                 push    0FFFFFFFFh
.text$mn:0000C3A9                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C3AE                 mov     eax, large fs:0
.text$mn:0000C3B4                 push    eax
.text$mn:0000C3B5                 sub     esp, 10h
.text$mn:0000C3B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C3BD                 xor     eax, ebp
.text$mn:0000C3BF                 push    eax
.text$mn:0000C3C0                 lea     eax, [ebp+var_C]
.text$mn:0000C3C3                 mov     large fs:0, eax
.text$mn:0000C3C9                 mov     [ebp+var_1C], ecx
.text$mn:0000C3CC                 mov     [ebp+var_18], 0
.text$mn:0000C3D3                 mov     eax, [ebp+arg_4]
.text$mn:0000C3D6                 push    eax             ; int
.text$mn:0000C3D7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000C3DC                 add     esp, 4
.text$mn:0000C3DF                 mov     [ebp+var_10], eax
.text$mn:0000C3E2                 cmp     [ebp+var_10], 0
.text$mn:0000C3E6                 jz      short loc_C3F0
.text$mn:0000C3E8                 mov     ecx, [ebp+var_10]
.text$mn:0000C3EB                 mov     [ebp+Str], ecx
.text$mn:0000C3EE                 jmp     short loc_C3F7
.text$mn:0000C3F0 ; ---------------------------------------------------------------------------
.text$mn:0000C3F0
.text$mn:0000C3F0 loc_C3F0:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:0000C3F0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000C3F7
.text$mn:0000C3F7 loc_C3F7:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000C3F7                 mov     edx, [ebp+Str]
.text$mn:0000C3FA                 push    edx             ; Str
.text$mn:0000C3FB                 mov     ecx, [ebp+arg_0]
.text$mn:0000C3FE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000C403                 mov     [ebp+var_4], 0
.text$mn:0000C40A                 mov     eax, [ebp+var_18]
.text$mn:0000C40D                 or      eax, 1
.text$mn:0000C410                 mov     [ebp+var_18], eax
.text$mn:0000C413                 mov     eax, [ebp+arg_0]
.text$mn:0000C416                 mov     ecx, [ebp+var_C]
.text$mn:0000C419                 mov     large fs:0, ecx
.text$mn:0000C420                 pop     ecx
.text$mn:0000C421                 mov     esp, ebp
.text$mn:0000C423                 pop     ebp
.text$mn:0000C424                 retn    8
.text$mn:0000C424 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000C424
.text$mn:0000C424 ; ---------------------------------------------------------------------------
.text$mn:0000C427                 align 4
.text$mn:0000C427 _text$mn        ends
.text$mn:0000C427
.text$x:0000C428 ; ===========================================================================
.text$x:0000C428
.text$x:0000C428 ; Segment type: Pure code
.text$x:0000C428 ; Segment permissions: Read/Execute
.text$x:0000C428 _text$x         segment para public 'CODE' use32
.text$x:0000C428                 assume cs:_text$x
.text$x:0000C428                 ;org 0C428h
.text$x:0000C428 ; COMDAT (pick associative to section at C3A4)
.text$x:0000C428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C428
.text$x:0000C428 ; =============== S U B R O U T I N E =======================================
.text$x:0000C428
.text$x:0000C428
.text$x:0000C428 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000C428                                         ; DATA XREF: .xdata$x:0000CF3Co
.text$x:0000C428                 mov     eax, [ebp-18h]
.text$x:0000C42B                 and     eax, 1
.text$x:0000C42E                 jz      $LN6
.text$x:0000C434                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000C438                 mov     ecx, [ebp+8]
.text$x:0000C43B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000C440 ; ---------------------------------------------------------------------------
.text$x:0000C440
.text$x:0000C440 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000C440                 retn
.text$x:0000C440 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000C440
.text$x:0000C441
.text$x:0000C441 ; =============== S U B R O U T I N E =======================================
.text$x:0000C441
.text$x:0000C441
.text$x:0000C441 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000C441                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:0000C441
.text$x:0000C441 arg_4           = dword ptr  8
.text$x:0000C441
.text$x:0000C441                 mov     edx, [esp+arg_4]
.text$x:0000C445                 lea     eax, [edx+0Ch]
.text$x:0000C448                 mov     ecx, [edx-14h]
.text$x:0000C44B                 xor     ecx, eax
.text$x:0000C44D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C452                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000C457                 jmp     ___CxxFrameHandler3
.text$x:0000C457 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000C457
.text$x:0000C457 _text$x         ends
.text$x:0000C457
.text$mn:0000C45C ; ===========================================================================
.text$mn:0000C45C
.text$mn:0000C45C ; Segment type: Pure code
.text$mn:0000C45C ; Segment permissions: Read/Execute
.text$mn:0000C45C _text$mn        segment para public 'CODE' use32
.text$mn:0000C45C                 assume cs:_text$mn
.text$mn:0000C45C                 ;org 0C45Ch
.text$mn:0000C45C ; COMDAT (pick any)
.text$mn:0000C45C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C45C
.text$mn:0000C45C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C45C
.text$mn:0000C45C ; Attributes: bp-based frame
.text$mn:0000C45C
.text$mn:0000C45C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000C45C                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C45C ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000C45C                                         ; DATA XREF: .rdata:0000E90Co
.text$mn:0000C45C
.text$mn:0000C45C var_14          = dword ptr -14h
.text$mn:0000C45C var_10          = dword ptr -10h
.text$mn:0000C45C var_C           = dword ptr -0Ch
.text$mn:0000C45C var_4           = dword ptr -4
.text$mn:0000C45C arg_0           = dword ptr  8
.text$mn:0000C45C arg_4           = dword ptr  0Ch
.text$mn:0000C45C
.text$mn:0000C45C                 push    ebp
.text$mn:0000C45D                 mov     ebp, esp
.text$mn:0000C45F                 push    0FFFFFFFFh
.text$mn:0000C461                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C466                 mov     eax, large fs:0
.text$mn:0000C46C                 push    eax
.text$mn:0000C46D                 sub     esp, 8
.text$mn:0000C470                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C475                 xor     eax, ebp
.text$mn:0000C477                 push    eax
.text$mn:0000C478                 lea     eax, [ebp+var_C]
.text$mn:0000C47B                 mov     large fs:0, eax
.text$mn:0000C481                 mov     [ebp+var_14], ecx
.text$mn:0000C484                 mov     [ebp+var_10], 0
.text$mn:0000C48B                 cmp     [ebp+arg_4], 1
.text$mn:0000C48F                 jnz     short loc_C4B5
.text$mn:0000C491                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000C496                 mov     ecx, [ebp+arg_0]
.text$mn:0000C499                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000C49E                 mov     [ebp+var_4], 0
.text$mn:0000C4A5                 mov     eax, [ebp+var_10]
.text$mn:0000C4A8                 or      eax, 1
.text$mn:0000C4AB                 mov     [ebp+var_10], eax
.text$mn:0000C4AE                 mov     eax, [ebp+arg_0]
.text$mn:0000C4B1                 jmp     short loc_C4D8
.text$mn:0000C4B3 ; ---------------------------------------------------------------------------
.text$mn:0000C4B3                 jmp     short loc_C4D8
.text$mn:0000C4B5 ; ---------------------------------------------------------------------------
.text$mn:0000C4B5
.text$mn:0000C4B5 loc_C4B5:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000C4B5                 mov     ecx, [ebp+arg_4]
.text$mn:0000C4B8                 push    ecx
.text$mn:0000C4B9                 mov     edx, [ebp+arg_0]
.text$mn:0000C4BC                 push    edx
.text$mn:0000C4BD                 mov     ecx, [ebp+var_14]
.text$mn:0000C4C0                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000C4C5                 mov     [ebp+var_4], 0
.text$mn:0000C4CC                 mov     eax, [ebp+var_10]
.text$mn:0000C4CF                 or      eax, 1
.text$mn:0000C4D2                 mov     [ebp+var_10], eax
.text$mn:0000C4D5                 mov     eax, [ebp+arg_0]
.text$mn:0000C4D8
.text$mn:0000C4D8 loc_C4D8:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000C4D8                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000C4D8                 mov     ecx, [ebp+var_C]
.text$mn:0000C4DB                 mov     large fs:0, ecx
.text$mn:0000C4E2                 pop     ecx
.text$mn:0000C4E3                 mov     esp, ebp
.text$mn:0000C4E5                 pop     ebp
.text$mn:0000C4E6                 retn    8
.text$mn:0000C4E6 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000C4E6
.text$mn:0000C4E6 ; ---------------------------------------------------------------------------
.text$mn:0000C4E9                 align 4
.text$mn:0000C4E9 _text$mn        ends
.text$mn:0000C4E9
.text$x:0000C4EC ; ===========================================================================
.text$x:0000C4EC
.text$x:0000C4EC ; Segment type: Pure code
.text$x:0000C4EC ; Segment permissions: Read/Execute
.text$x:0000C4EC _text$x         segment para public 'CODE' use32
.text$x:0000C4EC                 assume cs:_text$x
.text$x:0000C4EC                 ;org 0C4ECh
.text$x:0000C4EC ; COMDAT (pick associative to section at C45C)
.text$x:0000C4EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C4EC
.text$x:0000C4EC ; =============== S U B R O U T I N E =======================================
.text$x:0000C4EC
.text$x:0000C4EC
.text$x:0000C4EC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000C4EC                                         ; DATA XREF: .xdata$x:0000CFC0o
.text$x:0000C4EC                 mov     eax, [ebp-10h]
.text$x:0000C4EF                 and     eax, 1
.text$x:0000C4F2                 jz      $LN6_0
.text$x:0000C4F8                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000C4FC                 mov     ecx, [ebp+8]
.text$x:0000C4FF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000C504 ; ---------------------------------------------------------------------------
.text$x:0000C504
.text$x:0000C504 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000C504                 retn
.text$x:0000C504 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000C504
.text$x:0000C505
.text$x:0000C505 ; =============== S U B R O U T I N E =======================================
.text$x:0000C505
.text$x:0000C505
.text$x:0000C505 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000C505                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000C505
.text$x:0000C505 arg_4           = dword ptr  8
.text$x:0000C505
.text$x:0000C505                 mov     edx, [esp+arg_4]
.text$x:0000C509                 lea     eax, [edx+0Ch]
.text$x:0000C50C                 mov     ecx, [edx-0Ch]
.text$x:0000C50F                 xor     ecx, eax
.text$x:0000C511                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C516                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000C51B                 jmp     ___CxxFrameHandler3
.text$x:0000C51B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000C51B
.text$x:0000C51B _text$x         ends
.text$x:0000C51B
.text$mn:0000C520 ; ===========================================================================
.text$mn:0000C520
.text$mn:0000C520 ; Segment type: Pure code
.text$mn:0000C520 ; Segment permissions: Read/Execute
.text$mn:0000C520 _text$mn        segment para public 'CODE' use32
.text$mn:0000C520                 assume cs:_text$mn
.text$mn:0000C520                 ;org 0C520h
.text$mn:0000C520 ; COMDAT (pick any)
.text$mn:0000C520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C520
.text$mn:0000C520 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C520
.text$mn:0000C520 ; Attributes: bp-based frame
.text$mn:0000C520
.text$mn:0000C520 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:0000C520                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C520 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000C520                                         ; DATA XREF: .rdata:0000E94Co
.text$mn:0000C520
.text$mn:0000C520 var_1C          = dword ptr -1Ch
.text$mn:0000C520 var_18          = dword ptr -18h
.text$mn:0000C520 Str             = dword ptr -14h
.text$mn:0000C520 var_10          = dword ptr -10h
.text$mn:0000C520 var_C           = dword ptr -0Ch
.text$mn:0000C520 var_4           = dword ptr -4
.text$mn:0000C520 arg_0           = dword ptr  8
.text$mn:0000C520 arg_4           = dword ptr  0Ch
.text$mn:0000C520
.text$mn:0000C520                 push    ebp
.text$mn:0000C521                 mov     ebp, esp
.text$mn:0000C523                 push    0FFFFFFFFh
.text$mn:0000C525                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000C52A                 mov     eax, large fs:0
.text$mn:0000C530                 push    eax
.text$mn:0000C531                 sub     esp, 10h
.text$mn:0000C534                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000C539                 xor     eax, ebp
.text$mn:0000C53B                 push    eax
.text$mn:0000C53C                 lea     eax, [ebp+var_C]
.text$mn:0000C53F                 mov     large fs:0, eax
.text$mn:0000C545                 mov     [ebp+var_1C], ecx
.text$mn:0000C548                 mov     [ebp+var_18], 0
.text$mn:0000C54F                 mov     eax, [ebp+arg_4]
.text$mn:0000C552                 push    eax             ; int
.text$mn:0000C553                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000C558                 add     esp, 4
.text$mn:0000C55B                 mov     [ebp+var_10], eax
.text$mn:0000C55E                 cmp     [ebp+var_10], 0
.text$mn:0000C562                 jz      short loc_C56C
.text$mn:0000C564                 mov     ecx, [ebp+var_10]
.text$mn:0000C567                 mov     [ebp+Str], ecx
.text$mn:0000C56A                 jmp     short loc_C573
.text$mn:0000C56C ; ---------------------------------------------------------------------------
.text$mn:0000C56C
.text$mn:0000C56C loc_C56C:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000C56C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000C573
.text$mn:0000C573 loc_C573:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000C573                 mov     edx, [ebp+Str]
.text$mn:0000C576                 push    edx             ; Str
.text$mn:0000C577                 mov     ecx, [ebp+arg_0]
.text$mn:0000C57A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000C57F                 mov     [ebp+var_4], 0
.text$mn:0000C586                 mov     eax, [ebp+var_18]
.text$mn:0000C589                 or      eax, 1
.text$mn:0000C58C                 mov     [ebp+var_18], eax
.text$mn:0000C58F                 mov     eax, [ebp+arg_0]
.text$mn:0000C592                 mov     ecx, [ebp+var_C]
.text$mn:0000C595                 mov     large fs:0, ecx
.text$mn:0000C59C                 pop     ecx
.text$mn:0000C59D                 mov     esp, ebp
.text$mn:0000C59F                 pop     ebp
.text$mn:0000C5A0                 retn    8
.text$mn:0000C5A0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000C5A0
.text$mn:0000C5A0 ; ---------------------------------------------------------------------------
.text$mn:0000C5A3                 align 4
.text$mn:0000C5A3 _text$mn        ends
.text$mn:0000C5A3
.text$x:0000C5A4 ; ===========================================================================
.text$x:0000C5A4
.text$x:0000C5A4 ; Segment type: Pure code
.text$x:0000C5A4 ; Segment permissions: Read/Execute
.text$x:0000C5A4 _text$x         segment para public 'CODE' use32
.text$x:0000C5A4                 assume cs:_text$x
.text$x:0000C5A4                 ;org 0C5A4h
.text$x:0000C5A4 ; COMDAT (pick associative to section at C520)
.text$x:0000C5A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C5A4
.text$x:0000C5A4 ; =============== S U B R O U T I N E =======================================
.text$x:0000C5A4
.text$x:0000C5A4
.text$x:0000C5A4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000C5A4                                         ; DATA XREF: .xdata$x:0000D044o
.text$x:0000C5A4                 mov     eax, [ebp-18h]
.text$x:0000C5A7                 and     eax, 1
.text$x:0000C5AA                 jz      $LN6_1
.text$x:0000C5B0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000C5B4                 mov     ecx, [ebp+8]
.text$x:0000C5B7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000C5BC ; ---------------------------------------------------------------------------
.text$x:0000C5BC
.text$x:0000C5BC $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000C5BC                 retn
.text$x:0000C5BC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000C5BC
.text$x:0000C5BD
.text$x:0000C5BD ; =============== S U B R O U T I N E =======================================
.text$x:0000C5BD
.text$x:0000C5BD
.text$x:0000C5BD __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000C5BD                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000C5BD
.text$x:0000C5BD arg_4           = dword ptr  8
.text$x:0000C5BD
.text$x:0000C5BD                 mov     edx, [esp+arg_4]
.text$x:0000C5C1                 lea     eax, [edx+0Ch]
.text$x:0000C5C4                 mov     ecx, [edx-14h]
.text$x:0000C5C7                 xor     ecx, eax
.text$x:0000C5C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C5CE                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000C5D3                 jmp     ___CxxFrameHandler3
.text$x:0000C5D3 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000C5D3
.text$x:0000C5D3 _text$x         ends
.text$x:0000C5D3
.text$mn:0000C5D8 ; ===========================================================================
.text$mn:0000C5D8
.text$mn:0000C5D8 ; Segment type: Pure code
.text$mn:0000C5D8 ; Segment permissions: Read/Execute
.text$mn:0000C5D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000C5D8                 assume cs:_text$mn
.text$mn:0000C5D8                 ;org 0C5D8h
.text$mn:0000C5D8 ; COMDAT (pick any)
.text$mn:0000C5D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C5D8
.text$mn:0000C5D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C5D8
.text$mn:0000C5D8 ; Attributes: bp-based frame
.text$mn:0000C5D8
.text$mn:0000C5D8 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:0000C5D8                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000C5D8 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:0000C5D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:0000C5D8
.text$mn:0000C5D8 var_4           = dword ptr -4
.text$mn:0000C5D8 Dst             = dword ptr  8
.text$mn:0000C5D8 Src             = dword ptr  0Ch
.text$mn:0000C5D8 Size            = dword ptr  10h
.text$mn:0000C5D8
.text$mn:0000C5D8                 push    ebp
.text$mn:0000C5D9                 mov     ebp, esp
.text$mn:0000C5DB                 push    ecx
.text$mn:0000C5DC                 cmp     [ebp+Size], 0
.text$mn:0000C5E0                 jnz     short loc_C5EA
.text$mn:0000C5E2                 mov     eax, [ebp+Dst]
.text$mn:0000C5E5                 mov     [ebp+var_4], eax
.text$mn:0000C5E8                 jmp     short loc_C601
.text$mn:0000C5EA ; ---------------------------------------------------------------------------
.text$mn:0000C5EA
.text$mn:0000C5EA loc_C5EA:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000C5EA                 mov     ecx, [ebp+Size]
.text$mn:0000C5ED                 push    ecx             ; Size
.text$mn:0000C5EE                 mov     edx, [ebp+Src]
.text$mn:0000C5F1                 push    edx             ; Src
.text$mn:0000C5F2                 mov     eax, [ebp+Dst]
.text$mn:0000C5F5                 push    eax             ; Dst
.text$mn:0000C5F6                 call    _memmove
.text$mn:0000C5FB                 add     esp, 0Ch
.text$mn:0000C5FE                 mov     [ebp+var_4], eax
.text$mn:0000C601
.text$mn:0000C601 loc_C601:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:0000C601                 mov     eax, [ebp+var_4]
.text$mn:0000C604                 mov     esp, ebp
.text$mn:0000C606                 pop     ebp
.text$mn:0000C607                 retn
.text$mn:0000C607 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000C607
.text$mn:0000C607 _text$mn        ends
.text$mn:0000C607
.text$mn:0000C608 ; ===========================================================================
.text$mn:0000C608
.text$mn:0000C608 ; Segment type: Pure code
.text$mn:0000C608 ; Segment permissions: Read/Execute
.text$mn:0000C608 _text$mn        segment para public 'CODE' use32
.text$mn:0000C608                 assume cs:_text$mn
.text$mn:0000C608                 ;org 0C608h
.text$mn:0000C608 ; COMDAT (pick any)
.text$mn:0000C608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C608
.text$mn:0000C608 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C608
.text$mn:0000C608 ; Attributes: bp-based frame
.text$mn:0000C608
.text$mn:0000C608 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:0000C608                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000C608 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000C608                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:0000C608
.text$mn:0000C608 var_4           = dword ptr -4
.text$mn:0000C608 Dst             = dword ptr  8
.text$mn:0000C608 Src             = dword ptr  0Ch
.text$mn:0000C608 arg_8           = dword ptr  10h
.text$mn:0000C608
.text$mn:0000C608                 push    ebp
.text$mn:0000C609                 mov     ebp, esp
.text$mn:0000C60B                 push    ecx
.text$mn:0000C60C                 cmp     [ebp+arg_8], 0
.text$mn:0000C610                 jnz     short loc_C61A
.text$mn:0000C612                 mov     eax, [ebp+Dst]
.text$mn:0000C615                 mov     [ebp+var_4], eax
.text$mn:0000C618                 jmp     short loc_C631
.text$mn:0000C61A ; ---------------------------------------------------------------------------
.text$mn:0000C61A
.text$mn:0000C61A loc_C61A:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000C61A                 mov     ecx, [ebp+arg_8]
.text$mn:0000C61D                 push    ecx             ; int
.text$mn:0000C61E                 mov     edx, [ebp+Src]
.text$mn:0000C621                 push    edx             ; Src
.text$mn:0000C622                 mov     eax, [ebp+Dst]
.text$mn:0000C625                 push    eax             ; Dst
.text$mn:0000C626                 call    _wmemmove
.text$mn:0000C62B                 add     esp, 0Ch
.text$mn:0000C62E                 mov     [ebp+var_4], eax
.text$mn:0000C631
.text$mn:0000C631 loc_C631:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000C631                 mov     eax, [ebp+var_4]
.text$mn:0000C634                 mov     esp, ebp
.text$mn:0000C636                 pop     ebp
.text$mn:0000C637                 retn
.text$mn:0000C637 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000C637
.text$mn:0000C637 _text$mn        ends
.text$mn:0000C637
.text$mn:0000C638 ; ===========================================================================
.text$mn:0000C638
.text$mn:0000C638 ; Segment type: Pure code
.text$mn:0000C638 ; Segment permissions: Read/Execute
.text$mn:0000C638 _text$mn        segment para public 'CODE' use32
.text$mn:0000C638                 assume cs:_text$mn
.text$mn:0000C638                 ;org 0C638h
.text$mn:0000C638 ; COMDAT (pick any)
.text$mn:0000C638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C638
.text$mn:0000C638 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C638
.text$mn:0000C638 ; Attributes: bp-based frame
.text$mn:0000C638
.text$mn:0000C638 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000C638                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000C638 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000C638                                         ; DATA XREF: .rdata:0000E8D4o
.text$mn:0000C638
.text$mn:0000C638 var_4           = dword ptr -4
.text$mn:0000C638
.text$mn:0000C638                 push    ebp
.text$mn:0000C639                 mov     ebp, esp
.text$mn:0000C63B                 push    ecx
.text$mn:0000C63C                 mov     [ebp+var_4], ecx
.text$mn:0000C63F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000C644                 mov     esp, ebp
.text$mn:0000C646                 pop     ebp
.text$mn:0000C647                 retn
.text$mn:0000C647 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000C647
.text$mn:0000C647 _text$mn        ends
.text$mn:0000C647
.text$mn:0000C648 ; ===========================================================================
.text$mn:0000C648
.text$mn:0000C648 ; Segment type: Pure code
.text$mn:0000C648 ; Segment permissions: Read/Execute
.text$mn:0000C648 _text$mn        segment para public 'CODE' use32
.text$mn:0000C648                 assume cs:_text$mn
.text$mn:0000C648                 ;org 0C648h
.text$mn:0000C648 ; COMDAT (pick any)
.text$mn:0000C648                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C648
.text$mn:0000C648 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C648
.text$mn:0000C648 ; Attributes: bp-based frame
.text$mn:0000C648
.text$mn:0000C648 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000C648                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000C648 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000C648                                         ; DATA XREF: .rdata:0000E908o
.text$mn:0000C648
.text$mn:0000C648 var_4           = dword ptr -4
.text$mn:0000C648
.text$mn:0000C648                 push    ebp
.text$mn:0000C649                 mov     ebp, esp
.text$mn:0000C64B                 push    ecx
.text$mn:0000C64C                 mov     [ebp+var_4], ecx
.text$mn:0000C64F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000C654                 mov     esp, ebp
.text$mn:0000C656                 pop     ebp
.text$mn:0000C657                 retn
.text$mn:0000C657 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000C657
.text$mn:0000C657 _text$mn        ends
.text$mn:0000C657
.text$mn:0000C658 ; ===========================================================================
.text$mn:0000C658
.text$mn:0000C658 ; Segment type: Pure code
.text$mn:0000C658 ; Segment permissions: Read/Execute
.text$mn:0000C658 _text$mn        segment para public 'CODE' use32
.text$mn:0000C658                 assume cs:_text$mn
.text$mn:0000C658                 ;org 0C658h
.text$mn:0000C658 ; COMDAT (pick any)
.text$mn:0000C658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C658
.text$mn:0000C658 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C658
.text$mn:0000C658 ; Attributes: bp-based frame
.text$mn:0000C658
.text$mn:0000C658 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000C658                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000C658 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000C658                                         ; DATA XREF: .rdata:0000E948o
.text$mn:0000C658
.text$mn:0000C658 var_4           = dword ptr -4
.text$mn:0000C658
.text$mn:0000C658                 push    ebp
.text$mn:0000C659                 mov     ebp, esp
.text$mn:0000C65B                 push    ecx
.text$mn:0000C65C                 mov     [ebp+var_4], ecx
.text$mn:0000C65F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000C664                 mov     esp, ebp
.text$mn:0000C666                 pop     ebp
.text$mn:0000C667                 retn
.text$mn:0000C667 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000C667
.text$mn:0000C667 _text$mn        ends
.text$mn:0000C667
.text$mn:0000C668 ; ===========================================================================
.text$mn:0000C668
.text$mn:0000C668 ; Segment type: Pure code
.text$mn:0000C668 ; Segment permissions: Read/Execute
.text$mn:0000C668 _text$mn        segment para public 'CODE' use32
.text$mn:0000C668                 assume cs:_text$mn
.text$mn:0000C668                 ;org 0C668h
.text$mn:0000C668 ; COMDAT (pick any)
.text$mn:0000C668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C668
.text$mn:0000C668 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C668
.text$mn:0000C668 ; Attributes: bp-based frame
.text$mn:0000C668
.text$mn:0000C668 ; public: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::push_back(struct MenuItemUnit &&)
.text$mn:0000C668                 public ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z
.text$mn:0000C668 ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z proc near
.text$mn:0000C668                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+FE0p
.text$mn:0000C668                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+102Ep
.text$mn:0000C668
.text$mn:0000C668 var_C           = dword ptr -0Ch
.text$mn:0000C668 var_8           = dword ptr -8
.text$mn:0000C668 var_2           = byte ptr -2
.text$mn:0000C668 var_1           = byte ptr -1
.text$mn:0000C668 arg_0           = dword ptr  8
.text$mn:0000C668
.text$mn:0000C668                 push    ebp
.text$mn:0000C669                 mov     ebp, esp
.text$mn:0000C66B                 sub     esp, 0Ch
.text$mn:0000C66E                 mov     [ebp+var_8], ecx
.text$mn:0000C671                 mov     eax, [ebp+arg_0]
.text$mn:0000C674                 push    eax
.text$mn:0000C675                 call    ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z ; std::addressof<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000C67A                 add     esp, 4
.text$mn:0000C67D                 push    eax
.text$mn:0000C67E                 mov     ecx, [ebp+var_8]
.text$mn:0000C681                 call    ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)
.text$mn:0000C686                 movzx   ecx, al
.text$mn:0000C689                 test    ecx, ecx
.text$mn:0000C68B                 jz      loc_C71B
.text$mn:0000C691                 mov     edx, [ebp+arg_0]
.text$mn:0000C694                 push    edx
.text$mn:0000C695                 call    ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z ; std::addressof<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000C69A                 add     esp, 4
.text$mn:0000C69D                 mov     ecx, [ebp+var_8]
.text$mn:0000C6A0                 sub     eax, [ecx+4]
.text$mn:0000C6A3                 cdq
.text$mn:0000C6A4                 mov     ecx, 3Ch ; '<'
.text$mn:0000C6A9                 idiv    ecx
.text$mn:0000C6AB                 mov     [ebp+var_C], eax
.text$mn:0000C6AE                 mov     edx, [ebp+var_8]
.text$mn:0000C6B1                 mov     eax, [ebp+var_8]
.text$mn:0000C6B4                 mov     ecx, [edx+8]
.text$mn:0000C6B7                 cmp     ecx, [eax+0Ch]
.text$mn:0000C6BA                 jnz     short loc_C6C6
.text$mn:0000C6BC                 push    1
.text$mn:0000C6BE                 mov     ecx, [ebp+var_8]
.text$mn:0000C6C1                 call    ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)
.text$mn:0000C6C6
.text$mn:0000C6C6 loc_C6C6:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+52j
.text$mn:0000C6C6                 mov     edx, [ebp+var_8]
.text$mn:0000C6C9                 mov     eax, [edx+8]
.text$mn:0000C6CC                 push    eax
.text$mn:0000C6CD                 mov     ecx, [ebp+var_8]
.text$mn:0000C6D0                 mov     edx, [ecx+8]
.text$mn:0000C6D3                 push    edx
.text$mn:0000C6D4                 mov     ecx, [ebp+var_8]
.text$mn:0000C6D7                 call    ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)
.text$mn:0000C6DC                 imul    eax, [ebp+var_C], 3Ch
.text$mn:0000C6E0                 mov     ecx, [ebp+var_8]
.text$mn:0000C6E3                 add     eax, [ecx+4]
.text$mn:0000C6E6                 push    eax
.text$mn:0000C6E7                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000C6EC                 add     esp, 4
.text$mn:0000C6EF                 push    eax             ; int
.text$mn:0000C6F0                 mov     edx, [ebp+var_8]
.text$mn:0000C6F3                 mov     eax, [edx+8]
.text$mn:0000C6F6                 push    eax             ; void *
.text$mn:0000C6F7                 lea     ecx, [ebp+var_1]
.text$mn:0000C6FA                 push    ecx
.text$mn:0000C6FB                 mov     ecx, [ebp+var_8]
.text$mn:0000C6FE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000C703                 mov     ecx, eax
.text$mn:0000C705                 call    ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:0000C70A                 mov     edx, [ebp+var_8]
.text$mn:0000C70D                 mov     eax, [edx+8]
.text$mn:0000C710                 add     eax, 3Ch ; '<'
.text$mn:0000C713                 mov     ecx, [ebp+var_8]
.text$mn:0000C716                 mov     [ecx+8], eax
.text$mn:0000C719                 jmp     short loc_C77F
.text$mn:0000C71B ; ---------------------------------------------------------------------------
.text$mn:0000C71B
.text$mn:0000C71B loc_C71B:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+23j
.text$mn:0000C71B                 mov     edx, [ebp+var_8]
.text$mn:0000C71E                 mov     eax, [ebp+var_8]
.text$mn:0000C721                 mov     ecx, [edx+8]
.text$mn:0000C724                 cmp     ecx, [eax+0Ch]
.text$mn:0000C727                 jnz     short loc_C733
.text$mn:0000C729                 push    1
.text$mn:0000C72B                 mov     ecx, [ebp+var_8]
.text$mn:0000C72E                 call    ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)
.text$mn:0000C733
.text$mn:0000C733 loc_C733:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+BFj
.text$mn:0000C733                 mov     edx, [ebp+var_8]
.text$mn:0000C736                 mov     eax, [edx+8]
.text$mn:0000C739                 push    eax
.text$mn:0000C73A                 mov     ecx, [ebp+var_8]
.text$mn:0000C73D                 mov     edx, [ecx+8]
.text$mn:0000C740                 push    edx
.text$mn:0000C741                 mov     ecx, [ebp+var_8]
.text$mn:0000C744                 call    ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)
.text$mn:0000C749                 mov     eax, [ebp+arg_0]
.text$mn:0000C74C                 push    eax
.text$mn:0000C74D                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000C752                 add     esp, 4
.text$mn:0000C755                 push    eax             ; int
.text$mn:0000C756                 mov     ecx, [ebp+var_8]
.text$mn:0000C759                 mov     edx, [ecx+8]
.text$mn:0000C75C                 push    edx             ; void *
.text$mn:0000C75D                 lea     eax, [ebp+var_2]
.text$mn:0000C760                 push    eax
.text$mn:0000C761                 mov     ecx, [ebp+var_8]
.text$mn:0000C764                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000C769                 mov     ecx, eax
.text$mn:0000C76B                 call    ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:0000C770                 mov     ecx, [ebp+var_8]
.text$mn:0000C773                 mov     edx, [ecx+8]
.text$mn:0000C776                 add     edx, 3Ch ; '<'
.text$mn:0000C779                 mov     eax, [ebp+var_8]
.text$mn:0000C77C                 mov     [eax+8], edx
.text$mn:0000C77F
.text$mn:0000C77F loc_C77F:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+B1j
.text$mn:0000C77F                 mov     esp, ebp
.text$mn:0000C781                 pop     ebp
.text$mn:0000C782                 retn    4
.text$mn:0000C782 ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z endp
.text$mn:0000C782
.text$mn:0000C782 ; ---------------------------------------------------------------------------
.text$mn:0000C785                 align 4
.text$mn:0000C785 _text$mn        ends
.text$mn:0000C785
.text$mn:0000C788 ; ===========================================================================
.text$mn:0000C788
.text$mn:0000C788 ; Segment type: Pure code
.text$mn:0000C788 ; Segment permissions: Read/Execute
.text$mn:0000C788 _text$mn        segment para public 'CODE' use32
.text$mn:0000C788                 assume cs:_text$mn
.text$mn:0000C788                 ;org 0C788h
.text$mn:0000C788 ; COMDAT (pick any)
.text$mn:0000C788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C788
.text$mn:0000C788 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C788
.text$mn:0000C788 ; Attributes: bp-based frame
.text$mn:0000C788
.text$mn:0000C788 ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:0000C788                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000C788 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000C788                                         ; DATA XREF: .rdata:0000E788o
.text$mn:0000C788                                         ; .rdata:0000E7BCo ...
.text$mn:0000C788
.text$mn:0000C788 var_4           = dword ptr -4
.text$mn:0000C788 arg_0           = dword ptr  8
.text$mn:0000C788
.text$mn:0000C788                 push    ebp
.text$mn:0000C789                 mov     ebp, esp
.text$mn:0000C78B                 push    ecx
.text$mn:0000C78C                 mov     [ebp+var_4], ecx
.text$mn:0000C78F                 push    1               ; bRepaint
.text$mn:0000C791                 mov     eax, [ebp+arg_0]
.text$mn:0000C794                 mov     ecx, [eax+0Ch]
.text$mn:0000C797                 push    ecx             ; nHeight
.text$mn:0000C798                 mov     edx, [ebp+arg_0]
.text$mn:0000C79B                 mov     eax, [edx+8]
.text$mn:0000C79E                 push    eax             ; nWidth
.text$mn:0000C79F                 mov     ecx, [ebp+arg_0]
.text$mn:0000C7A2                 mov     edx, [ecx+4]
.text$mn:0000C7A5                 push    edx             ; Y
.text$mn:0000C7A6                 mov     eax, [ebp+arg_0]
.text$mn:0000C7A9                 mov     ecx, [eax]
.text$mn:0000C7AB                 push    ecx             ; X
.text$mn:0000C7AC                 mov     edx, [ebp+var_4]
.text$mn:0000C7AF                 mov     eax, [edx+0Ch]
.text$mn:0000C7B2                 push    eax             ; hWnd
.text$mn:0000C7B3                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000C7B9                 push    0
.text$mn:0000C7BB                 mov     ecx, [ebp+var_4]
.text$mn:0000C7BE                 mov     edx, [ecx]
.text$mn:0000C7C0                 mov     ecx, [ebp+var_4]
.text$mn:0000C7C3                 mov     eax, [edx+18h]
.text$mn:0000C7C6                 call    eax
.text$mn:0000C7C8                 mov     esp, ebp
.text$mn:0000C7CA                 pop     ebp
.text$mn:0000C7CB                 retn    4
.text$mn:0000C7CB ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000C7CB
.text$mn:0000C7CB ; ---------------------------------------------------------------------------
.text$mn:0000C7CE                 align 10h
.text$mn:0000C7CE _text$mn        ends
.text$mn:0000C7CE
.text$mn:0000C7D0 ; ===========================================================================
.text$mn:0000C7D0
.text$mn:0000C7D0 ; Segment type: Pure code
.text$mn:0000C7D0 ; Segment permissions: Read/Execute
.text$mn:0000C7D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C7D0                 assume cs:_text$mn
.text$mn:0000C7D0                 ;org 0C7D0h
.text$mn:0000C7D0 ; COMDAT (pick any)
.text$mn:0000C7D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C7D0
.text$mn:0000C7D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C7D0
.text$mn:0000C7D0 ; Attributes: bp-based frame
.text$mn:0000C7D0
.text$mn:0000C7D0 ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:0000C7D0                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000C7D0 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000C7D0                                         ; DATA XREF: .rdata:0000E78Co
.text$mn:0000C7D0                                         ; .rdata:0000E7C0o ...
.text$mn:0000C7D0
.text$mn:0000C7D0 var_4           = dword ptr -4
.text$mn:0000C7D0 arg_0           = dword ptr  8
.text$mn:0000C7D0
.text$mn:0000C7D0                 push    ebp
.text$mn:0000C7D1                 mov     ebp, esp
.text$mn:0000C7D3                 push    ecx
.text$mn:0000C7D4                 mov     [ebp+var_4], ecx
.text$mn:0000C7D7                 push    1               ; bRepaint
.text$mn:0000C7D9                 mov     eax, [ebp+arg_0]
.text$mn:0000C7DC                 mov     ecx, [ebp+arg_0]
.text$mn:0000C7DF                 mov     edx, [eax+0Ch]
.text$mn:0000C7E2                 sub     edx, [ecx+4]
.text$mn:0000C7E5                 push    edx             ; nHeight
.text$mn:0000C7E6                 mov     eax, [ebp+arg_0]
.text$mn:0000C7E9                 mov     ecx, [ebp+arg_0]
.text$mn:0000C7EC                 mov     edx, [eax+8]
.text$mn:0000C7EF                 sub     edx, [ecx]
.text$mn:0000C7F1                 push    edx             ; nWidth
.text$mn:0000C7F2                 mov     eax, [ebp+arg_0]
.text$mn:0000C7F5                 mov     ecx, [eax+4]
.text$mn:0000C7F8                 push    ecx             ; Y
.text$mn:0000C7F9                 mov     edx, [ebp+arg_0]
.text$mn:0000C7FC                 mov     eax, [edx]
.text$mn:0000C7FE                 push    eax             ; X
.text$mn:0000C7FF                 mov     ecx, [ebp+var_4]
.text$mn:0000C802                 mov     edx, [ecx+0Ch]
.text$mn:0000C805                 push    edx             ; hWnd
.text$mn:0000C806                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000C80C                 push    0
.text$mn:0000C80E                 mov     eax, [ebp+var_4]
.text$mn:0000C811                 mov     edx, [eax]
.text$mn:0000C813                 mov     ecx, [ebp+var_4]
.text$mn:0000C816                 mov     eax, [edx+18h]
.text$mn:0000C819                 call    eax
.text$mn:0000C81B                 mov     esp, ebp
.text$mn:0000C81D                 pop     ebp
.text$mn:0000C81E                 retn    4
.text$mn:0000C81E ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000C81E
.text$mn:0000C81E ; ---------------------------------------------------------------------------
.text$mn:0000C821                 align 4
.text$mn:0000C821 _text$mn        ends
.text$mn:0000C821
.text$mn:0000C824 ; ===========================================================================
.text$mn:0000C824
.text$mn:0000C824 ; Segment type: Pure code
.text$mn:0000C824 ; Segment permissions: Read/Execute
.text$mn:0000C824 _text$mn        segment para public 'CODE' use32
.text$mn:0000C824                 assume cs:_text$mn
.text$mn:0000C824                 ;org 0C824h
.text$mn:0000C824 ; COMDAT (pick any)
.text$mn:0000C824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C824
.text$mn:0000C824 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C824
.text$mn:0000C824 ; Attributes: bp-based frame
.text$mn:0000C824
.text$mn:0000C824 ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:0000C824                 public ?redraw@Window@@UBEX_N@Z
.text$mn:0000C824 ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:0000E790o
.text$mn:0000C824                                         ; .rdata:0000E7C4o ...
.text$mn:0000C824
.text$mn:0000C824 var_4           = dword ptr -4
.text$mn:0000C824 arg_0           = byte ptr  8
.text$mn:0000C824
.text$mn:0000C824                 push    ebp
.text$mn:0000C825                 mov     ebp, esp
.text$mn:0000C827                 push    ecx
.text$mn:0000C828                 mov     [ebp+var_4], ecx
.text$mn:0000C82B                 push    1               ; bErase
.text$mn:0000C82D                 push    0               ; lpRect
.text$mn:0000C82F                 mov     eax, [ebp+var_4]
.text$mn:0000C832                 mov     ecx, [eax+0Ch]
.text$mn:0000C835                 push    ecx             ; hWnd
.text$mn:0000C836                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:0000C83C                 movzx   edx, [ebp+arg_0]
.text$mn:0000C840                 test    edx, edx
.text$mn:0000C842                 jz      short loc_C851
.text$mn:0000C844                 mov     eax, [ebp+var_4]
.text$mn:0000C847                 mov     ecx, [eax+0Ch]
.text$mn:0000C84A                 push    ecx             ; hWnd
.text$mn:0000C84B                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:0000C851
.text$mn:0000C851 loc_C851:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:0000C851                 mov     esp, ebp
.text$mn:0000C853                 pop     ebp
.text$mn:0000C854                 retn    4
.text$mn:0000C854 ?redraw@Window@@UBEX_N@Z endp
.text$mn:0000C854
.text$mn:0000C854 ; ---------------------------------------------------------------------------
.text$mn:0000C857                 align 4
.text$mn:0000C857 _text$mn        ends
.text$mn:0000C857
.text$mn:0000C858 ; ===========================================================================
.text$mn:0000C858
.text$mn:0000C858 ; Segment type: Pure code
.text$mn:0000C858 ; Segment permissions: Read/Execute
.text$mn:0000C858 _text$mn        segment para public 'CODE' use32
.text$mn:0000C858                 assume cs:_text$mn
.text$mn:0000C858                 ;org 0C858h
.text$mn:0000C858 ; COMDAT (pick any)
.text$mn:0000C858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C858
.text$mn:0000C858 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C858
.text$mn:0000C858 ; Attributes: bp-based frame
.text$mn:0000C858
.text$mn:0000C858 ; int __thiscall DPIManager::scaleX(DPIManager *this, int)
.text$mn:0000C858                 public ?scaleX@DPIManager@@QAEHH@Z
.text$mn:0000C858 ?scaleX@DPIManager@@QAEHH@Z proc near   ; CODE XREF: ShortcutMapper::getClientRect(tagRECT &)+5Bp
.text$mn:0000C858
.text$mn:0000C858 var_4           = dword ptr -4
.text$mn:0000C858 nNumber         = dword ptr  8
.text$mn:0000C858
.text$mn:0000C858                 push    ebp
.text$mn:0000C859                 mov     ebp, esp
.text$mn:0000C85B                 push    ecx
.text$mn:0000C85C                 mov     [ebp+var_4], ecx
.text$mn:0000C85F                 push    60h ; '`'       ; nDenominator
.text$mn:0000C861                 mov     eax, [ebp+var_4]
.text$mn:0000C864                 mov     ecx, [eax]
.text$mn:0000C866                 push    ecx             ; nNumerator
.text$mn:0000C867                 mov     edx, [ebp+nNumber]
.text$mn:0000C86A                 push    edx             ; nNumber
.text$mn:0000C86B                 call    dword ptr ds:__imp__MulDiv@12 ; MulDiv(x,x,x)
.text$mn:0000C871                 mov     esp, ebp
.text$mn:0000C873                 pop     ebp
.text$mn:0000C874                 retn    4
.text$mn:0000C874 ?scaleX@DPIManager@@QAEHH@Z endp
.text$mn:0000C874
.text$mn:0000C874 ; ---------------------------------------------------------------------------
.text$mn:0000C877                 align 4
.text$mn:0000C877 _text$mn        ends
.text$mn:0000C877
.text$mn:0000C878 ; ===========================================================================
.text$mn:0000C878
.text$mn:0000C878 ; Segment type: Pure code
.text$mn:0000C878 ; Segment permissions: Read/Execute
.text$mn:0000C878 _text$mn        segment para public 'CODE' use32
.text$mn:0000C878                 assume cs:_text$mn
.text$mn:0000C878                 ;org 0C878h
.text$mn:0000C878 ; COMDAT (pick any)
.text$mn:0000C878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C878
.text$mn:0000C878 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C878
.text$mn:0000C878 ; Attributes: bp-based frame
.text$mn:0000C878
.text$mn:0000C878 ; int __thiscall DPIManager::scaleY(DPIManager *this, int)
.text$mn:0000C878                 public ?scaleY@DPIManager@@QAEHH@Z
.text$mn:0000C878 ?scaleY@DPIManager@@QAEHH@Z proc near   ; CODE XREF: ShortcutMapper::getClientRect(tagRECT &)+1Fp
.text$mn:0000C878                                         ; ShortcutMapper::getClientRect(tagRECT &)+3Cp
.text$mn:0000C878
.text$mn:0000C878 var_4           = dword ptr -4
.text$mn:0000C878 nNumber         = dword ptr  8
.text$mn:0000C878
.text$mn:0000C878                 push    ebp
.text$mn:0000C879                 mov     ebp, esp
.text$mn:0000C87B                 push    ecx
.text$mn:0000C87C                 mov     [ebp+var_4], ecx
.text$mn:0000C87F                 push    60h ; '`'       ; nDenominator
.text$mn:0000C881                 mov     eax, [ebp+var_4]
.text$mn:0000C884                 mov     ecx, [eax+4]
.text$mn:0000C887                 push    ecx             ; nNumerator
.text$mn:0000C888                 mov     edx, [ebp+nNumber]
.text$mn:0000C88B                 push    edx             ; nNumber
.text$mn:0000C88C                 call    dword ptr ds:__imp__MulDiv@12 ; MulDiv(x,x,x)
.text$mn:0000C892                 mov     esp, ebp
.text$mn:0000C894                 pop     ebp
.text$mn:0000C895                 retn    4
.text$mn:0000C895 ?scaleY@DPIManager@@QAEHH@Z endp
.text$mn:0000C895
.text$mn:0000C895 _text$mn        ends
.text$mn:0000C895
.text$mn:0000C898 ; ===========================================================================
.text$mn:0000C898
.text$mn:0000C898 ; Segment type: Pure code
.text$mn:0000C898 ; Segment permissions: Read/Execute
.text$mn:0000C898 _text$mn        segment para public 'CODE' use32
.text$mn:0000C898                 assume cs:_text$mn
.text$mn:0000C898                 ;org 0C898h
.text$mn:0000C898 ; COMDAT (pick any)
.text$mn:0000C898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C898
.text$mn:0000C898 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C898
.text$mn:0000C898 ; Attributes: bp-based frame
.text$mn:0000C898
.text$mn:0000C898 ; public: struct std::_Wrap_alloc<class std::allocator<struct KeyCombo>> __thiscall std::_Wrap_alloc<class std::allocator<struct KeyCombo>>::select_on_container_copy_construction(void)const
.text$mn:0000C898                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AU12@XZ
.text$mn:0000C898 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AU12@XZ proc near
.text$mn:0000C898                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+41p
.text$mn:0000C898
.text$mn:0000C898 var_8           = dword ptr -8
.text$mn:0000C898 var_1           = byte ptr -1
.text$mn:0000C898 arg_0           = dword ptr  8
.text$mn:0000C898
.text$mn:0000C898                 push    ebp
.text$mn:0000C899                 mov     ebp, esp
.text$mn:0000C89B                 sub     esp, 8
.text$mn:0000C89E                 mov     [ebp+var_8], ecx
.text$mn:0000C8A1                 mov     eax, [ebp+var_8]
.text$mn:0000C8A4                 push    eax
.text$mn:0000C8A5                 lea     ecx, [ebp+var_1]
.text$mn:0000C8A8                 push    ecx
.text$mn:0000C8A9                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SA?AV?$allocator@UKeyCombo@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<KeyCombo>>::select_on_container_copy_construction(std::allocator<KeyCombo> const &)
.text$mn:0000C8AE                 add     esp, 8
.text$mn:0000C8B1                 push    eax
.text$mn:0000C8B2                 mov     ecx, [ebp+arg_0]
.text$mn:0000C8B5                 call    ??0?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z ; std::_Wrap_alloc<std::allocator<KeyCombo>>::_Wrap_alloc<std::allocator<KeyCombo>>(std::allocator<KeyCombo> const &)
.text$mn:0000C8BA                 mov     eax, [ebp+arg_0]
.text$mn:0000C8BD                 mov     esp, ebp
.text$mn:0000C8BF                 pop     ebp
.text$mn:0000C8C0                 retn    4
.text$mn:0000C8C0 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000C8C0
.text$mn:0000C8C0 ; ---------------------------------------------------------------------------
.text$mn:0000C8C3                 align 4
.text$mn:0000C8C3 _text$mn        ends
.text$mn:0000C8C3
.text$mn:0000C8C4 ; ===========================================================================
.text$mn:0000C8C4
.text$mn:0000C8C4 ; Segment type: Pure code
.text$mn:0000C8C4 ; Segment permissions: Read/Execute
.text$mn:0000C8C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C8C4                 assume cs:_text$mn
.text$mn:0000C8C4                 ;org 0C8C4h
.text$mn:0000C8C4 ; COMDAT (pick any)
.text$mn:0000C8C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C8C4
.text$mn:0000C8C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C8C4
.text$mn:0000C8C4 ; Attributes: bp-based frame
.text$mn:0000C8C4
.text$mn:0000C8C4 ; public: struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::select_on_container_copy_construction(void)const
.text$mn:0000C8C4                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AU12@XZ
.text$mn:0000C8C4 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AU12@XZ proc near
.text$mn:0000C8C4                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+41p
.text$mn:0000C8C4
.text$mn:0000C8C4 var_8           = dword ptr -8
.text$mn:0000C8C4 var_1           = byte ptr -1
.text$mn:0000C8C4 arg_0           = dword ptr  8
.text$mn:0000C8C4
.text$mn:0000C8C4                 push    ebp
.text$mn:0000C8C5                 mov     ebp, esp
.text$mn:0000C8C7                 sub     esp, 8
.text$mn:0000C8CA                 mov     [ebp+var_8], ecx
.text$mn:0000C8CD                 mov     eax, [ebp+var_8]
.text$mn:0000C8D0                 push    eax
.text$mn:0000C8D1                 lea     ecx, [ebp+var_1]
.text$mn:0000C8D4                 push    ecx
.text$mn:0000C8D5                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SA?AV?$allocator@UrecordedMacroStep@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::select_on_container_copy_construction(std::allocator<recordedMacroStep> const &)
.text$mn:0000C8DA                 add     esp, 8
.text$mn:0000C8DD                 push    eax
.text$mn:0000C8DE                 mov     ecx, [ebp+arg_0]
.text$mn:0000C8E1                 call    ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::_Wrap_alloc<std::allocator<recordedMacroStep>>(std::allocator<recordedMacroStep> const &)
.text$mn:0000C8E6                 mov     eax, [ebp+arg_0]
.text$mn:0000C8E9                 mov     esp, ebp
.text$mn:0000C8EB                 pop     ebp
.text$mn:0000C8EC                 retn    4
.text$mn:0000C8EC ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000C8EC
.text$mn:0000C8EC ; ---------------------------------------------------------------------------
.text$mn:0000C8EF                 align 10h
.text$mn:0000C8EF _text$mn        ends
.text$mn:0000C8EF
.text$mn:0000C8F0 ; ===========================================================================
.text$mn:0000C8F0
.text$mn:0000C8F0 ; Segment type: Pure code
.text$mn:0000C8F0 ; Segment permissions: Read/Execute
.text$mn:0000C8F0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C8F0                 assume cs:_text$mn
.text$mn:0000C8F0                 ;org 0C8F0h
.text$mn:0000C8F0 ; COMDAT (pick any)
.text$mn:0000C8F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C8F0
.text$mn:0000C8F0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C8F0
.text$mn:0000C8F0 ; Attributes: bp-based frame
.text$mn:0000C8F0
.text$mn:0000C8F0 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:0000C8F0                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:0000C8F0 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:0000C8F0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:0000C8F0
.text$mn:0000C8F0 var_8           = dword ptr -8
.text$mn:0000C8F0 var_1           = byte ptr -1
.text$mn:0000C8F0 arg_0           = dword ptr  8
.text$mn:0000C8F0
.text$mn:0000C8F0                 push    ebp
.text$mn:0000C8F1                 mov     ebp, esp
.text$mn:0000C8F3                 sub     esp, 8
.text$mn:0000C8F6                 mov     [ebp+var_8], ecx
.text$mn:0000C8F9                 mov     eax, [ebp+var_8]
.text$mn:0000C8FC                 push    eax
.text$mn:0000C8FD                 lea     ecx, [ebp+var_1]
.text$mn:0000C900                 push    ecx
.text$mn:0000C901                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:0000C906                 add     esp, 8
.text$mn:0000C909                 push    eax
.text$mn:0000C90A                 mov     ecx, [ebp+arg_0]
.text$mn:0000C90D                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:0000C912                 mov     eax, [ebp+arg_0]
.text$mn:0000C915                 mov     esp, ebp
.text$mn:0000C917                 pop     ebp
.text$mn:0000C918                 retn    4
.text$mn:0000C918 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000C918
.text$mn:0000C918 ; ---------------------------------------------------------------------------
.text$mn:0000C91B                 align 4
.text$mn:0000C91B _text$mn        ends
.text$mn:0000C91B
.text$mn:0000C91C ; ===========================================================================
.text$mn:0000C91C
.text$mn:0000C91C ; Segment type: Pure code
.text$mn:0000C91C ; Segment permissions: Read/Execute
.text$mn:0000C91C _text$mn        segment para public 'CODE' use32
.text$mn:0000C91C                 assume cs:_text$mn
.text$mn:0000C91C                 ;org 0C91Ch
.text$mn:0000C91C ; COMDAT (pick any)
.text$mn:0000C91C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C91C
.text$mn:0000C91C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C91C
.text$mn:0000C91C ; Attributes: bp-based frame
.text$mn:0000C91C
.text$mn:0000C91C ; public: class std::allocator<struct KeyCombo> __thiscall std::allocator<struct KeyCombo>::select_on_container_copy_construction(void)const
.text$mn:0000C91C                 public ?select_on_container_copy_construction@?$allocator@UKeyCombo@@@std@@QBE?AV12@XZ
.text$mn:0000C91C ?select_on_container_copy_construction@?$allocator@UKeyCombo@@@std@@QBE?AV12@XZ proc near
.text$mn:0000C91C                                         ; CODE XREF: std::allocator_traits<std::allocator<KeyCombo>>::select_on_container_copy_construction(std::allocator<KeyCombo> const &)+Ap
.text$mn:0000C91C
.text$mn:0000C91C var_4           = dword ptr -4
.text$mn:0000C91C arg_0           = dword ptr  8
.text$mn:0000C91C
.text$mn:0000C91C                 push    ebp
.text$mn:0000C91D                 mov     ebp, esp
.text$mn:0000C91F                 push    ecx
.text$mn:0000C920                 mov     [ebp+var_4], ecx
.text$mn:0000C923                 mov     eax, [ebp+var_4]
.text$mn:0000C926                 push    eax
.text$mn:0000C927                 mov     ecx, [ebp+arg_0]
.text$mn:0000C92A                 call    ??0?$allocator@UKeyCombo@@@std@@QAE@ABV01@@Z ; std::allocator<KeyCombo>::allocator<KeyCombo>(std::allocator<KeyCombo> const &)
.text$mn:0000C92F                 mov     eax, [ebp+arg_0]
.text$mn:0000C932                 mov     esp, ebp
.text$mn:0000C934                 pop     ebp
.text$mn:0000C935                 retn    4
.text$mn:0000C935 ?select_on_container_copy_construction@?$allocator@UKeyCombo@@@std@@QBE?AV12@XZ endp
.text$mn:0000C935
.text$mn:0000C935 _text$mn        ends
.text$mn:0000C935
.text$mn:0000C938 ; ===========================================================================
.text$mn:0000C938
.text$mn:0000C938 ; Segment type: Pure code
.text$mn:0000C938 ; Segment permissions: Read/Execute
.text$mn:0000C938 _text$mn        segment para public 'CODE' use32
.text$mn:0000C938                 assume cs:_text$mn
.text$mn:0000C938                 ;org 0C938h
.text$mn:0000C938 ; COMDAT (pick any)
.text$mn:0000C938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C938
.text$mn:0000C938 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C938
.text$mn:0000C938 ; Attributes: bp-based frame
.text$mn:0000C938
.text$mn:0000C938 ; public: class std::allocator<struct recordedMacroStep> __thiscall std::allocator<struct recordedMacroStep>::select_on_container_copy_construction(void)const
.text$mn:0000C938                 public ?select_on_container_copy_construction@?$allocator@UrecordedMacroStep@@@std@@QBE?AV12@XZ
.text$mn:0000C938 ?select_on_container_copy_construction@?$allocator@UrecordedMacroStep@@@std@@QBE?AV12@XZ proc near
.text$mn:0000C938                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::select_on_container_copy_construction(std::allocator<recordedMacroStep> const &)+Ap
.text$mn:0000C938
.text$mn:0000C938 var_4           = dword ptr -4
.text$mn:0000C938 arg_0           = dword ptr  8
.text$mn:0000C938
.text$mn:0000C938                 push    ebp
.text$mn:0000C939                 mov     ebp, esp
.text$mn:0000C93B                 push    ecx
.text$mn:0000C93C                 mov     [ebp+var_4], ecx
.text$mn:0000C93F                 mov     eax, [ebp+var_4]
.text$mn:0000C942                 push    eax
.text$mn:0000C943                 mov     ecx, [ebp+arg_0]
.text$mn:0000C946                 call    ??0?$allocator@UrecordedMacroStep@@@std@@QAE@ABV01@@Z ; std::allocator<recordedMacroStep>::allocator<recordedMacroStep>(std::allocator<recordedMacroStep> const &)
.text$mn:0000C94B                 mov     eax, [ebp+arg_0]
.text$mn:0000C94E                 mov     esp, ebp
.text$mn:0000C950                 pop     ebp
.text$mn:0000C951                 retn    4
.text$mn:0000C951 ?select_on_container_copy_construction@?$allocator@UrecordedMacroStep@@@std@@QBE?AV12@XZ endp
.text$mn:0000C951
.text$mn:0000C951 _text$mn        ends
.text$mn:0000C951
.text$mn:0000C954 ; ===========================================================================
.text$mn:0000C954
.text$mn:0000C954 ; Segment type: Pure code
.text$mn:0000C954 ; Segment permissions: Read/Execute
.text$mn:0000C954 _text$mn        segment para public 'CODE' use32
.text$mn:0000C954                 assume cs:_text$mn
.text$mn:0000C954                 ;org 0C954h
.text$mn:0000C954 ; COMDAT (pick any)
.text$mn:0000C954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C954
.text$mn:0000C954 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C954
.text$mn:0000C954 ; Attributes: bp-based frame
.text$mn:0000C954
.text$mn:0000C954 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:0000C954                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:0000C954 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:0000C954                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:0000C954
.text$mn:0000C954 var_4           = dword ptr -4
.text$mn:0000C954 arg_0           = dword ptr  8
.text$mn:0000C954
.text$mn:0000C954                 push    ebp
.text$mn:0000C955                 mov     ebp, esp
.text$mn:0000C957                 push    ecx
.text$mn:0000C958                 mov     [ebp+var_4], ecx
.text$mn:0000C95B                 mov     eax, [ebp+var_4]
.text$mn:0000C95E                 push    eax
.text$mn:0000C95F                 mov     ecx, [ebp+arg_0]
.text$mn:0000C962                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000C967                 mov     eax, [ebp+arg_0]
.text$mn:0000C96A                 mov     esp, ebp
.text$mn:0000C96C                 pop     ebp
.text$mn:0000C96D                 retn    4
.text$mn:0000C96D ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:0000C96D
.text$mn:0000C96D _text$mn        ends
.text$mn:0000C96D
.text$mn:0000C970 ; ===========================================================================
.text$mn:0000C970
.text$mn:0000C970 ; Segment type: Pure code
.text$mn:0000C970 ; Segment permissions: Read/Execute
.text$mn:0000C970 _text$mn        segment para public 'CODE' use32
.text$mn:0000C970                 assume cs:_text$mn
.text$mn:0000C970                 ;org 0C970h
.text$mn:0000C970 ; COMDAT (pick any)
.text$mn:0000C970                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C970
.text$mn:0000C970 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C970
.text$mn:0000C970 ; Attributes: bp-based frame
.text$mn:0000C970
.text$mn:0000C970 ; public: static class std::allocator<struct KeyCombo> __cdecl std::allocator_traits<class std::allocator<struct KeyCombo>>::select_on_container_copy_construction(class std::allocator<struct KeyCombo> const &)
.text$mn:0000C970                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SA?AV?$allocator@UKeyCombo@@@2@ABV32@@Z
.text$mn:0000C970 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SA?AV?$allocator@UKeyCombo@@@2@ABV32@@Z proc near
.text$mn:0000C970                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<KeyCombo>>::select_on_container_copy_construction(void)+11p
.text$mn:0000C970
.text$mn:0000C970 arg_0           = dword ptr  8
.text$mn:0000C970 arg_4           = dword ptr  0Ch
.text$mn:0000C970
.text$mn:0000C970                 push    ebp
.text$mn:0000C971                 mov     ebp, esp
.text$mn:0000C973                 mov     eax, [ebp+arg_0]
.text$mn:0000C976                 push    eax
.text$mn:0000C977                 mov     ecx, [ebp+arg_4]
.text$mn:0000C97A                 call    ?select_on_container_copy_construction@?$allocator@UKeyCombo@@@std@@QBE?AV12@XZ ; std::allocator<KeyCombo>::select_on_container_copy_construction(void)
.text$mn:0000C97F                 mov     eax, [ebp+arg_0]
.text$mn:0000C982                 pop     ebp
.text$mn:0000C983                 retn
.text$mn:0000C983 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UKeyCombo@@@std@@@std@@SA?AV?$allocator@UKeyCombo@@@2@ABV32@@Z endp
.text$mn:0000C983
.text$mn:0000C983 _text$mn        ends
.text$mn:0000C983
.text$mn:0000C984 ; ===========================================================================
.text$mn:0000C984
.text$mn:0000C984 ; Segment type: Pure code
.text$mn:0000C984 ; Segment permissions: Read/Execute
.text$mn:0000C984 _text$mn        segment para public 'CODE' use32
.text$mn:0000C984                 assume cs:_text$mn
.text$mn:0000C984                 ;org 0C984h
.text$mn:0000C984 ; COMDAT (pick any)
.text$mn:0000C984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C984
.text$mn:0000C984 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C984
.text$mn:0000C984 ; Attributes: bp-based frame
.text$mn:0000C984
.text$mn:0000C984 ; public: static class std::allocator<struct recordedMacroStep> __cdecl std::allocator_traits<class std::allocator<struct recordedMacroStep>>::select_on_container_copy_construction(class std::allocator<struct recordedMacroStep> const &)
.text$mn:0000C984                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SA?AV?$allocator@UrecordedMacroStep@@@2@ABV32@@Z
.text$mn:0000C984 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SA?AV?$allocator@UrecordedMacroStep@@@2@ABV32@@Z proc near
.text$mn:0000C984                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::select_on_container_copy_construction(void)+11p
.text$mn:0000C984
.text$mn:0000C984 arg_0           = dword ptr  8
.text$mn:0000C984 arg_4           = dword ptr  0Ch
.text$mn:0000C984
.text$mn:0000C984                 push    ebp
.text$mn:0000C985                 mov     ebp, esp
.text$mn:0000C987                 mov     eax, [ebp+arg_0]
.text$mn:0000C98A                 push    eax
.text$mn:0000C98B                 mov     ecx, [ebp+arg_4]
.text$mn:0000C98E                 call    ?select_on_container_copy_construction@?$allocator@UrecordedMacroStep@@@std@@QBE?AV12@XZ ; std::allocator<recordedMacroStep>::select_on_container_copy_construction(void)
.text$mn:0000C993                 mov     eax, [ebp+arg_0]
.text$mn:0000C996                 pop     ebp
.text$mn:0000C997                 retn
.text$mn:0000C997 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SA?AV?$allocator@UrecordedMacroStep@@@2@ABV32@@Z endp
.text$mn:0000C997
.text$mn:0000C997 _text$mn        ends
.text$mn:0000C997
.text$mn:0000C998 ; ===========================================================================
.text$mn:0000C998
.text$mn:0000C998 ; Segment type: Pure code
.text$mn:0000C998 ; Segment permissions: Read/Execute
.text$mn:0000C998 _text$mn        segment para public 'CODE' use32
.text$mn:0000C998                 assume cs:_text$mn
.text$mn:0000C998                 ;org 0C998h
.text$mn:0000C998 ; COMDAT (pick any)
.text$mn:0000C998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C998
.text$mn:0000C998 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C998
.text$mn:0000C998 ; Attributes: bp-based frame
.text$mn:0000C998
.text$mn:0000C998 ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:0000C998                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:0000C998 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:0000C998                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:0000C998
.text$mn:0000C998 arg_0           = dword ptr  8
.text$mn:0000C998 arg_4           = dword ptr  0Ch
.text$mn:0000C998
.text$mn:0000C998                 push    ebp
.text$mn:0000C999                 mov     ebp, esp
.text$mn:0000C99B                 mov     eax, [ebp+arg_0]
.text$mn:0000C99E                 push    eax
.text$mn:0000C99F                 mov     ecx, [ebp+arg_4]
.text$mn:0000C9A2                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:0000C9A7                 mov     eax, [ebp+arg_0]
.text$mn:0000C9AA                 pop     ebp
.text$mn:0000C9AB                 retn
.text$mn:0000C9AB ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:0000C9AB
.text$mn:0000C9AB _text$mn        ends
.text$mn:0000C9AB
.text$mn:0000C9AC ; ===========================================================================
.text$mn:0000C9AC
.text$mn:0000C9AC ; Segment type: Pure code
.text$mn:0000C9AC ; Segment permissions: Read/Execute
.text$mn:0000C9AC _text$mn        segment para public 'CODE' use32
.text$mn:0000C9AC                 assume cs:_text$mn
.text$mn:0000C9AC                 ;org 0C9ACh
.text$mn:0000C9AC ; COMDAT (pick any)
.text$mn:0000C9AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C9AC
.text$mn:0000C9AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C9AC
.text$mn:0000C9AC ; Attributes: bp-based frame
.text$mn:0000C9AC
.text$mn:0000C9AC ; void __thiscall BabyGridWrapper::setColWidth(BabyGridWrapper *this, WPARAM wParam, unsigned int)
.text$mn:0000C9AC                 public ?setColWidth@BabyGridWrapper@@QAEXII@Z
.text$mn:0000C9AC ?setColWidth@BabyGridWrapper@@QAEXII@Z proc near
.text$mn:0000C9AC                                         ; CODE XREF: ShortcutMapper::initBabyGrid(void)+8Cp
.text$mn:0000C9AC                                         ; ShortcutMapper::initBabyGrid(void)+9Ep
.text$mn:0000C9AC
.text$mn:0000C9AC var_4           = dword ptr -4
.text$mn:0000C9AC wParam          = dword ptr  8
.text$mn:0000C9AC lParam          = dword ptr  0Ch
.text$mn:0000C9AC
.text$mn:0000C9AC                 push    ebp
.text$mn:0000C9AD                 mov     ebp, esp
.text$mn:0000C9AF                 push    ecx
.text$mn:0000C9B0                 mov     [ebp+var_4], ecx
.text$mn:0000C9B3                 mov     eax, [ebp+lParam]
.text$mn:0000C9B6                 push    eax             ; lParam
.text$mn:0000C9B7                 mov     ecx, [ebp+wParam]
.text$mn:0000C9BA                 push    ecx             ; wParam
.text$mn:0000C9BB                 push    1F63h           ; Msg
.text$mn:0000C9C0                 mov     edx, [ebp+var_4]
.text$mn:0000C9C3                 mov     eax, [edx+0Ch]
.text$mn:0000C9C6                 push    eax             ; hWnd
.text$mn:0000C9C7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000C9CD                 mov     esp, ebp
.text$mn:0000C9CF                 pop     ebp
.text$mn:0000C9D0                 retn    8
.text$mn:0000C9D0 ?setColWidth@BabyGridWrapper@@QAEXII@Z endp
.text$mn:0000C9D0
.text$mn:0000C9D0 ; ---------------------------------------------------------------------------
.text$mn:0000C9D3                 align 4
.text$mn:0000C9D3 _text$mn        ends
.text$mn:0000C9D3
.text$mn:0000C9D4 ; ===========================================================================
.text$mn:0000C9D4
.text$mn:0000C9D4 ; Segment type: Pure code
.text$mn:0000C9D4 ; Segment permissions: Read/Execute
.text$mn:0000C9D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C9D4                 assume cs:_text$mn
.text$mn:0000C9D4                 ;org 0C9D4h
.text$mn:0000C9D4 ; COMDAT (pick any)
.text$mn:0000C9D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000C9D4
.text$mn:0000C9D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C9D4
.text$mn:0000C9D4 ; Attributes: bp-based frame
.text$mn:0000C9D4
.text$mn:0000C9D4 ; void __thiscall BabyGridWrapper::setColsNumbered(BabyGridWrapper *this, bool)
.text$mn:0000C9D4                 public ?setColsNumbered@BabyGridWrapper@@QAEX_N@Z
.text$mn:0000C9D4 ?setColsNumbered@BabyGridWrapper@@QAEX_N@Z proc near
.text$mn:0000C9D4                                         ; CODE XREF: ShortcutMapper::initBabyGrid(void)+7Dp
.text$mn:0000C9D4
.text$mn:0000C9D4 var_8           = dword ptr -8
.text$mn:0000C9D4 wParam          = dword ptr -4
.text$mn:0000C9D4 arg_0           = byte ptr  8
.text$mn:0000C9D4
.text$mn:0000C9D4                 push    ebp
.text$mn:0000C9D5                 mov     ebp, esp
.text$mn:0000C9D7                 sub     esp, 8
.text$mn:0000C9DA                 mov     [ebp+var_8], ecx
.text$mn:0000C9DD                 movzx   eax, [ebp+arg_0]
.text$mn:0000C9E1                 test    eax, eax
.text$mn:0000C9E3                 jz      short loc_C9EE
.text$mn:0000C9E5                 mov     [ebp+wParam], 1
.text$mn:0000C9EC                 jmp     short loc_C9F5
.text$mn:0000C9EE ; ---------------------------------------------------------------------------
.text$mn:0000C9EE
.text$mn:0000C9EE loc_C9EE:                               ; CODE XREF: BabyGridWrapper::setColsNumbered(bool)+Fj
.text$mn:0000C9EE                 mov     [ebp+wParam], 0
.text$mn:0000C9F5
.text$mn:0000C9F5 loc_C9F5:                               ; CODE XREF: BabyGridWrapper::setColsNumbered(bool)+18j
.text$mn:0000C9F5                 push    0               ; lParam
.text$mn:0000C9F7                 mov     ecx, [ebp+wParam]
.text$mn:0000C9FA                 push    ecx             ; wParam
.text$mn:0000C9FB                 push    1F6Dh           ; Msg
.text$mn:0000CA00                 mov     edx, [ebp+var_8]
.text$mn:0000CA03                 mov     eax, [edx+0Ch]
.text$mn:0000CA06                 push    eax             ; hWnd
.text$mn:0000CA07                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000CA0D                 mov     esp, ebp
.text$mn:0000CA0F                 pop     ebp
.text$mn:0000CA10                 retn    4
.text$mn:0000CA10 ?setColsNumbered@BabyGridWrapper@@QAEX_N@Z endp
.text$mn:0000CA10
.text$mn:0000CA10 ; ---------------------------------------------------------------------------
.text$mn:0000CA13                 align 4
.text$mn:0000CA13 _text$mn        ends
.text$mn:0000CA13
.text$mn:0000CA14 ; ===========================================================================
.text$mn:0000CA14
.text$mn:0000CA14 ; Segment type: Pure code
.text$mn:0000CA14 ; Segment permissions: Read/Execute
.text$mn:0000CA14 _text$mn        segment para public 'CODE' use32
.text$mn:0000CA14                 assume cs:_text$mn
.text$mn:0000CA14                 ;org 0CA14h
.text$mn:0000CA14 ; COMDAT (pick any)
.text$mn:0000CA14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CA14
.text$mn:0000CA14 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CA14
.text$mn:0000CA14 ; Attributes: bp-based frame
.text$mn:0000CA14
.text$mn:0000CA14 ; void __thiscall BabyGridWrapper::setCursorColour(BabyGridWrapper *this, unsigned __int32)
.text$mn:0000CA14                 public ?setCursorColour@BabyGridWrapper@@QAEXK@Z
.text$mn:0000CA14 ?setCursorColour@BabyGridWrapper@@QAEXK@Z proc near
.text$mn:0000CA14                                         ; CODE XREF: BabyGridWrapper::hideCursor(void)+Cp
.text$mn:0000CA14
.text$mn:0000CA14 var_4           = dword ptr -4
.text$mn:0000CA14 wParam          = dword ptr  8
.text$mn:0000CA14
.text$mn:0000CA14                 push    ebp
.text$mn:0000CA15                 mov     ebp, esp
.text$mn:0000CA17                 push    ecx
.text$mn:0000CA18                 mov     [ebp+var_4], ecx
.text$mn:0000CA1B                 push    0               ; lParam
.text$mn:0000CA1D                 mov     eax, [ebp+wParam]
.text$mn:0000CA20                 push    eax             ; wParam
.text$mn:0000CA21                 push    1F69h           ; Msg
.text$mn:0000CA26                 mov     ecx, [ebp+var_4]
.text$mn:0000CA29                 mov     edx, [ecx+0Ch]
.text$mn:0000CA2C                 push    edx             ; hWnd
.text$mn:0000CA2D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000CA33                 mov     esp, ebp
.text$mn:0000CA35                 pop     ebp
.text$mn:0000CA36                 retn    4
.text$mn:0000CA36 ?setCursorColour@BabyGridWrapper@@QAEXK@Z endp
.text$mn:0000CA36
.text$mn:0000CA36 ; ---------------------------------------------------------------------------
.text$mn:0000CA39                 align 4
.text$mn:0000CA39 _text$mn        ends
.text$mn:0000CA39
.text$mn:0000CA3C ; ===========================================================================
.text$mn:0000CA3C
.text$mn:0000CA3C ; Segment type: Pure code
.text$mn:0000CA3C ; Segment permissions: Read/Execute
.text$mn:0000CA3C _text$mn        segment para public 'CODE' use32
.text$mn:0000CA3C                 assume cs:_text$mn
.text$mn:0000CA3C                 ;org 0CA3Ch
.text$mn:0000CA3C ; COMDAT (pick any)
.text$mn:0000CA3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CA3C
.text$mn:0000CA3C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CA3C
.text$mn:0000CA3C ; Attributes: bp-based frame
.text$mn:0000CA3C
.text$mn:0000CA3C ; void __thiscall CommandShortcut::setID(CommandShortcut *this, unsigned __int32)
.text$mn:0000CA3C                 public ?setID@CommandShortcut@@QAEXK@Z
.text$mn:0000CA3C ?setID@CommandShortcut@@QAEXK@Z proc near
.text$mn:0000CA3C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+C5Dp
.text$mn:0000CA3C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+E3Cp
.text$mn:0000CA3C
.text$mn:0000CA3C var_4           = dword ptr -4
.text$mn:0000CA3C arg_0           = dword ptr  8
.text$mn:0000CA3C
.text$mn:0000CA3C                 push    ebp
.text$mn:0000CA3D                 mov     ebp, esp
.text$mn:0000CA3F                 push    ecx
.text$mn:0000CA40                 mov     [ebp+var_4], ecx
.text$mn:0000CA43                 mov     eax, [ebp+var_4]
.text$mn:0000CA46                 mov     ecx, [ebp+arg_0]
.text$mn:0000CA49                 mov     [eax+128h], ecx
.text$mn:0000CA4F                 mov     esp, ebp
.text$mn:0000CA51                 pop     ebp
.text$mn:0000CA52                 retn    4
.text$mn:0000CA52 ?setID@CommandShortcut@@QAEXK@Z endp
.text$mn:0000CA52
.text$mn:0000CA52 ; ---------------------------------------------------------------------------
.text$mn:0000CA55                 align 4
.text$mn:0000CA55 _text$mn        ends
.text$mn:0000CA55
.text$mn:0000CA58 ; ===========================================================================
.text$mn:0000CA58
.text$mn:0000CA58 ; Segment type: Pure code
.text$mn:0000CA58 ; Segment permissions: Read/Execute
.text$mn:0000CA58 _text$mn        segment para public 'CODE' use32
.text$mn:0000CA58                 assume cs:_text$mn
.text$mn:0000CA58                 ;org 0CA58h
.text$mn:0000CA58 ; COMDAT (pick any)
.text$mn:0000CA58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CA58
.text$mn:0000CA58 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CA58
.text$mn:0000CA58 ; Attributes: bp-based frame
.text$mn:0000CA58
.text$mn:0000CA58 ; void __thiscall BabyGridWrapper::setLineColNumber(BabyGridWrapper *this, WPARAM wParam, unsigned int)
.text$mn:0000CA58                 public ?setLineColNumber@BabyGridWrapper@@QAEXII@Z
.text$mn:0000CA58 ?setLineColNumber@BabyGridWrapper@@QAEXII@Z proc near
.text$mn:0000CA58                                         ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+A7p
.text$mn:0000CA58                                         ; ShortcutMapper::fillOutBabyGrid(void)+DBp ...
.text$mn:0000CA58
.text$mn:0000CA58 var_4           = dword ptr -4
.text$mn:0000CA58 wParam          = dword ptr  8
.text$mn:0000CA58 lParam          = dword ptr  0Ch
.text$mn:0000CA58
.text$mn:0000CA58                 push    ebp
.text$mn:0000CA59                 mov     ebp, esp
.text$mn:0000CA5B                 push    ecx
.text$mn:0000CA5C                 mov     [ebp+var_4], ecx
.text$mn:0000CA5F                 mov     eax, [ebp+lParam]
.text$mn:0000CA62                 push    eax             ; lParam
.text$mn:0000CA63                 mov     ecx, [ebp+wParam]
.text$mn:0000CA66                 push    ecx             ; wParam
.text$mn:0000CA67                 push    1F5Eh           ; Msg
.text$mn:0000CA6C                 mov     edx, [ebp+var_4]
.text$mn:0000CA6F                 mov     eax, [edx+0Ch]
.text$mn:0000CA72                 push    eax             ; hWnd
.text$mn:0000CA73                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000CA79                 mov     esp, ebp
.text$mn:0000CA7B                 pop     ebp
.text$mn:0000CA7C                 retn    8
.text$mn:0000CA7C ?setLineColNumber@BabyGridWrapper@@QAEXII@Z endp
.text$mn:0000CA7C
.text$mn:0000CA7C ; ---------------------------------------------------------------------------
.text$mn:0000CA7F                 align 10h
.text$mn:0000CA7F _text$mn        ends
.text$mn:0000CA7F
.text$mn:0000CA80 ; ===========================================================================
.text$mn:0000CA80
.text$mn:0000CA80 ; Segment type: Pure code
.text$mn:0000CA80 ; Segment permissions: Read/Execute
.text$mn:0000CA80 _text$mn        segment para public 'CODE' use32
.text$mn:0000CA80                 assume cs:_text$mn
.text$mn:0000CA80                 ;org 0CA80h
.text$mn:0000CA80 ; COMDAT (pick any)
.text$mn:0000CA80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CA80
.text$mn:0000CA80 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CA80
.text$mn:0000CA80 ; Attributes: bp-based frame
.text$mn:0000CA80
.text$mn:0000CA80 ; void __thiscall BabyGridWrapper::setText(BabyGridWrapper *this, unsigned int, unsigned int, const wchar_t *)
.text$mn:0000CA80                 public ?setText@BabyGridWrapper@@QAEXIIPB_W@Z
.text$mn:0000CA80 ?setText@BabyGridWrapper@@QAEXIIPB_W@Z proc near
.text$mn:0000CA80                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+360p
.text$mn:0000CA80                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+493p ...
.text$mn:0000CA80
.text$mn:0000CA80 wParam          = dword ptr -0Ch
.text$mn:0000CA80 var_8           = dword ptr -8
.text$mn:0000CA80 var_4           = dword ptr -4
.text$mn:0000CA80 arg_0           = dword ptr  8
.text$mn:0000CA80 arg_4           = dword ptr  0Ch
.text$mn:0000CA80 lParam          = dword ptr  10h
.text$mn:0000CA80
.text$mn:0000CA80                 push    ebp
.text$mn:0000CA81                 mov     ebp, esp
.text$mn:0000CA83                 sub     esp, 0Ch
.text$mn:0000CA86                 mov     [ebp+var_4], ecx
.text$mn:0000CA89                 mov     eax, [ebp+arg_0]
.text$mn:0000CA8C                 mov     [ebp+wParam], eax
.text$mn:0000CA8F                 mov     ecx, [ebp+arg_4]
.text$mn:0000CA92                 mov     [ebp+var_8], ecx
.text$mn:0000CA95                 mov     edx, [ebp+lParam]
.text$mn:0000CA98                 push    edx             ; lParam
.text$mn:0000CA99                 lea     eax, [ebp+wParam]
.text$mn:0000CA9C                 push    eax             ; wParam
.text$mn:0000CA9D                 push    1F5Bh           ; Msg
.text$mn:0000CAA2                 mov     ecx, [ebp+var_4]
.text$mn:0000CAA5                 mov     edx, [ecx+0Ch]
.text$mn:0000CAA8                 push    edx             ; hWnd
.text$mn:0000CAA9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000CAAF                 mov     esp, ebp
.text$mn:0000CAB1                 pop     ebp
.text$mn:0000CAB2                 retn    0Ch
.text$mn:0000CAB2 ?setText@BabyGridWrapper@@QAEXIIPB_W@Z endp
.text$mn:0000CAB2
.text$mn:0000CAB2 ; ---------------------------------------------------------------------------
.text$mn:0000CAB5                 align 4
.text$mn:0000CAB5 _text$mn        ends
.text$mn:0000CAB5
.text$mn:0000CAB8 ; ===========================================================================
.text$mn:0000CAB8
.text$mn:0000CAB8 ; Segment type: Pure code
.text$mn:0000CAB8 ; Segment permissions: Read/Execute
.text$mn:0000CAB8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CAB8                 assume cs:_text$mn
.text$mn:0000CAB8                 ;org 0CAB8h
.text$mn:0000CAB8 ; COMDAT (pick any)
.text$mn:0000CAB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CAB8
.text$mn:0000CAB8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CAB8
.text$mn:0000CAB8 ; Attributes: bp-based frame
.text$mn:0000CAB8
.text$mn:0000CAB8 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:0000CAB8                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000CAB8 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000CAB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:0000CAB8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:0000CAB8
.text$mn:0000CAB8 var_4           = dword ptr -4
.text$mn:0000CAB8
.text$mn:0000CAB8                 push    ebp
.text$mn:0000CAB9                 mov     ebp, esp
.text$mn:0000CABB                 push    ecx
.text$mn:0000CABC                 mov     [ebp+var_4], ecx
.text$mn:0000CABF                 mov     eax, [ebp+var_4]
.text$mn:0000CAC2                 mov     eax, [eax+14h]
.text$mn:0000CAC5                 mov     esp, ebp
.text$mn:0000CAC7                 pop     ebp
.text$mn:0000CAC8                 retn
.text$mn:0000CAC8 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000CAC8
.text$mn:0000CAC8 ; ---------------------------------------------------------------------------
.text$mn:0000CAC9                 align 4
.text$mn:0000CAC9 _text$mn        ends
.text$mn:0000CAC9
.text$mn:0000CACC ; ===========================================================================
.text$mn:0000CACC
.text$mn:0000CACC ; Segment type: Pure code
.text$mn:0000CACC ; Segment permissions: Read/Execute
.text$mn:0000CACC _text$mn        segment para public 'CODE' use32
.text$mn:0000CACC                 assume cs:_text$mn
.text$mn:0000CACC                 ;org 0CACCh
.text$mn:0000CACC ; COMDAT (pick any)
.text$mn:0000CACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CACC
.text$mn:0000CACC ; =============== S U B R O U T I N E =======================================
.text$mn:0000CACC
.text$mn:0000CACC ; Attributes: bp-based frame
.text$mn:0000CACC
.text$mn:0000CACC ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000CACC                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000CACC ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000CACC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:0000CACC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:0000CACC
.text$mn:0000CACC var_4           = dword ptr -4
.text$mn:0000CACC
.text$mn:0000CACC                 push    ebp
.text$mn:0000CACD                 mov     ebp, esp
.text$mn:0000CACF                 push    ecx
.text$mn:0000CAD0                 mov     [ebp+var_4], ecx
.text$mn:0000CAD3                 mov     eax, [ebp+var_4]
.text$mn:0000CAD6                 mov     eax, [eax+14h]
.text$mn:0000CAD9                 mov     esp, ebp
.text$mn:0000CADB                 pop     ebp
.text$mn:0000CADC                 retn
.text$mn:0000CADC ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000CADC
.text$mn:0000CADC ; ---------------------------------------------------------------------------
.text$mn:0000CADD                 align 10h
.text$mn:0000CADD _text$mn        ends
.text$mn:0000CADD
.text$mn:0000CAE0 ; ===========================================================================
.text$mn:0000CAE0
.text$mn:0000CAE0 ; Segment type: Pure code
.text$mn:0000CAE0 ; Segment permissions: Read/Execute
.text$mn:0000CAE0 _text$mn        segment para public 'CODE' use32
.text$mn:0000CAE0                 assume cs:_text$mn
.text$mn:0000CAE0                 ;org 0CAE0h
.text$mn:0000CAE0 ; COMDAT (pick any)
.text$mn:0000CAE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CAE0
.text$mn:0000CAE0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CAE0
.text$mn:0000CAE0 ; Attributes: bp-based frame
.text$mn:0000CAE0
.text$mn:0000CAE0 ; public: unsigned int __thiscall std::vector<struct KeyCombo, class std::allocator<struct KeyCombo>>::size(void)const
.text$mn:0000CAE0                 public ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ
.text$mn:0000CAE0 ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CAE0                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::vector<KeyCombo,std::allocator<KeyCombo>>(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+59p
.text$mn:0000CAE0                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator=(std::vector<KeyCombo,std::allocator<KeyCombo>> const &)+ACp ...
.text$mn:0000CAE0
.text$mn:0000CAE0 var_4           = dword ptr -4
.text$mn:0000CAE0
.text$mn:0000CAE0                 push    ebp
.text$mn:0000CAE1                 mov     ebp, esp
.text$mn:0000CAE3                 push    ecx
.text$mn:0000CAE4                 mov     [ebp+var_4], ecx
.text$mn:0000CAE7                 mov     eax, [ebp+var_4]
.text$mn:0000CAEA                 mov     ecx, [ebp+var_4]
.text$mn:0000CAED                 mov     eax, [eax+8]
.text$mn:0000CAF0                 sub     eax, [ecx+4]
.text$mn:0000CAF3                 sar     eax, 2
.text$mn:0000CAF6                 mov     esp, ebp
.text$mn:0000CAF8                 pop     ebp
.text$mn:0000CAF9                 retn
.text$mn:0000CAF9 ?size@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBEIXZ endp
.text$mn:0000CAF9
.text$mn:0000CAF9 ; ---------------------------------------------------------------------------
.text$mn:0000CAFA                 align 4
.text$mn:0000CAFA _text$mn        ends
.text$mn:0000CAFA
.text$mn:0000CAFC ; ===========================================================================
.text$mn:0000CAFC
.text$mn:0000CAFC ; Segment type: Pure code
.text$mn:0000CAFC ; Segment permissions: Read/Execute
.text$mn:0000CAFC _text$mn        segment para public 'CODE' use32
.text$mn:0000CAFC                 assume cs:_text$mn
.text$mn:0000CAFC                 ;org 0CAFCh
.text$mn:0000CAFC ; COMDAT (pick any)
.text$mn:0000CAFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CAFC
.text$mn:0000CAFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000CAFC
.text$mn:0000CAFC ; Attributes: bp-based frame
.text$mn:0000CAFC
.text$mn:0000CAFC ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::size(void)const
.text$mn:0000CAFC                 public ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000CAFC ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CAFC                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+A9p
.text$mn:0000CAFC                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+22p ...
.text$mn:0000CAFC
.text$mn:0000CAFC var_4           = dword ptr -4
.text$mn:0000CAFC
.text$mn:0000CAFC                 push    ebp
.text$mn:0000CAFD                 mov     ebp, esp
.text$mn:0000CAFF                 push    ecx
.text$mn:0000CB00                 mov     [ebp+var_4], ecx
.text$mn:0000CB03                 mov     eax, [ebp+var_4]
.text$mn:0000CB06                 mov     ecx, [ebp+var_4]
.text$mn:0000CB09                 mov     eax, [eax+8]
.text$mn:0000CB0C                 sub     eax, [ecx+4]
.text$mn:0000CB0F                 cdq
.text$mn:0000CB10                 mov     ecx, 3Ch ; '<'
.text$mn:0000CB15                 idiv    ecx
.text$mn:0000CB17                 mov     esp, ebp
.text$mn:0000CB19                 pop     ebp
.text$mn:0000CB1A                 retn
.text$mn:0000CB1A ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000CB1A
.text$mn:0000CB1A ; ---------------------------------------------------------------------------
.text$mn:0000CB1B                 align 4
.text$mn:0000CB1B _text$mn        ends
.text$mn:0000CB1B
.text$mn:0000CB1C ; ===========================================================================
.text$mn:0000CB1C
.text$mn:0000CB1C ; Segment type: Pure code
.text$mn:0000CB1C ; Segment permissions: Read/Execute
.text$mn:0000CB1C _text$mn        segment para public 'CODE' use32
.text$mn:0000CB1C                 assume cs:_text$mn
.text$mn:0000CB1C                 ;org 0CB1Ch
.text$mn:0000CB1C ; COMDAT (pick any)
.text$mn:0000CB1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CB1C
.text$mn:0000CB1C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CB1C
.text$mn:0000CB1C ; Attributes: bp-based frame
.text$mn:0000CB1C
.text$mn:0000CB1C ; public: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::size(void)const
.text$mn:0000CB1C                 public ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:0000CB1C ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CB1C                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::vector<recordedMacroStep,std::allocator<recordedMacroStep>>(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+59p
.text$mn:0000CB1C                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::operator=(std::vector<recordedMacroStep,std::allocator<recordedMacroStep>> const &)+ACp ...
.text$mn:0000CB1C
.text$mn:0000CB1C var_4           = dword ptr -4
.text$mn:0000CB1C
.text$mn:0000CB1C                 push    ebp
.text$mn:0000CB1D                 mov     ebp, esp
.text$mn:0000CB1F                 push    ecx
.text$mn:0000CB20                 mov     [ebp+var_4], ecx
.text$mn:0000CB23                 mov     eax, [ebp+var_4]
.text$mn:0000CB26                 mov     ecx, [ebp+var_4]
.text$mn:0000CB29                 mov     eax, [eax+8]
.text$mn:0000CB2C                 sub     eax, [ecx+4]
.text$mn:0000CB2F                 cdq
.text$mn:0000CB30                 mov     ecx, 2Ch ; ','
.text$mn:0000CB35                 idiv    ecx
.text$mn:0000CB37                 mov     esp, ebp
.text$mn:0000CB39                 pop     ebp
.text$mn:0000CB3A                 retn
.text$mn:0000CB3A ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:0000CB3A
.text$mn:0000CB3A ; ---------------------------------------------------------------------------
.text$mn:0000CB3B                 align 4
.text$mn:0000CB3B _text$mn        ends
.text$mn:0000CB3B
.text$mn:0000CB3C ; ===========================================================================
.text$mn:0000CB3C
.text$mn:0000CB3C ; Segment type: Pure code
.text$mn:0000CB3C ; Segment permissions: Read/Execute
.text$mn:0000CB3C _text$mn        segment para public 'CODE' use32
.text$mn:0000CB3C                 assume cs:_text$mn
.text$mn:0000CB3C                 ;org 0CB3Ch
.text$mn:0000CB3C ; COMDAT (pick any)
.text$mn:0000CB3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CB3C
.text$mn:0000CB3C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CB3C
.text$mn:0000CB3C ; Attributes: bp-based frame
.text$mn:0000CB3C
.text$mn:0000CB3C ; public: unsigned int __thiscall std::vector<class CommandShortcut, class std::allocator<class CommandShortcut>>::size(void)const
.text$mn:0000CB3C                 public ?size@?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QBEIXZ
.text$mn:0000CB3C ?size@?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CB3C                                         ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+8Ap
.text$mn:0000CB3C                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+Ap
.text$mn:0000CB3C
.text$mn:0000CB3C var_4           = dword ptr -4
.text$mn:0000CB3C
.text$mn:0000CB3C                 push    ebp
.text$mn:0000CB3D                 mov     ebp, esp
.text$mn:0000CB3F                 push    ecx
.text$mn:0000CB40                 mov     [ebp+var_4], ecx
.text$mn:0000CB43                 mov     eax, [ebp+var_4]
.text$mn:0000CB46                 mov     ecx, [ebp+var_4]
.text$mn:0000CB49                 mov     eax, [eax+8]
.text$mn:0000CB4C                 sub     eax, [ecx+4]
.text$mn:0000CB4F                 cdq
.text$mn:0000CB50                 mov     ecx, 12Ch
.text$mn:0000CB55                 idiv    ecx
.text$mn:0000CB57                 mov     esp, ebp
.text$mn:0000CB59                 pop     ebp
.text$mn:0000CB5A                 retn
.text$mn:0000CB5A ?size@?$vector@VCommandShortcut@@V?$allocator@VCommandShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:0000CB5A
.text$mn:0000CB5A ; ---------------------------------------------------------------------------
.text$mn:0000CB5B                 align 4
.text$mn:0000CB5B _text$mn        ends
.text$mn:0000CB5B
.text$mn:0000CB5C ; ===========================================================================
.text$mn:0000CB5C
.text$mn:0000CB5C ; Segment type: Pure code
.text$mn:0000CB5C ; Segment permissions: Read/Execute
.text$mn:0000CB5C _text$mn        segment para public 'CODE' use32
.text$mn:0000CB5C                 assume cs:_text$mn
.text$mn:0000CB5C                 ;org 0CB5Ch
.text$mn:0000CB5C ; COMDAT (pick any)
.text$mn:0000CB5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CB5C
.text$mn:0000CB5C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CB5C
.text$mn:0000CB5C ; Attributes: bp-based frame
.text$mn:0000CB5C
.text$mn:0000CB5C ; public: unsigned int __thiscall std::vector<class MacroShortcut, class std::allocator<class MacroShortcut>>::size(void)const
.text$mn:0000CB5C                 public ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ
.text$mn:0000CB5C ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CB5C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+BC1p
.text$mn:0000CB5C                                         ; ShortcutMapper::fillOutBabyGrid(void)+BEp ...
.text$mn:0000CB5C
.text$mn:0000CB5C var_4           = dword ptr -4
.text$mn:0000CB5C
.text$mn:0000CB5C                 push    ebp
.text$mn:0000CB5D                 mov     ebp, esp
.text$mn:0000CB5F                 push    ecx
.text$mn:0000CB60                 mov     [ebp+var_4], ecx
.text$mn:0000CB63                 mov     eax, [ebp+var_4]
.text$mn:0000CB66                 mov     ecx, [ebp+var_4]
.text$mn:0000CB69                 mov     eax, [eax+8]
.text$mn:0000CB6C                 sub     eax, [ecx+4]
.text$mn:0000CB6F                 cdq
.text$mn:0000CB70                 mov     ecx, 13Ch
.text$mn:0000CB75                 idiv    ecx
.text$mn:0000CB77                 mov     esp, ebp
.text$mn:0000CB79                 pop     ebp
.text$mn:0000CB7A                 retn
.text$mn:0000CB7A ?size@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:0000CB7A
.text$mn:0000CB7A ; ---------------------------------------------------------------------------
.text$mn:0000CB7B                 align 4
.text$mn:0000CB7B _text$mn        ends
.text$mn:0000CB7B
.text$mn:0000CB7C ; ===========================================================================
.text$mn:0000CB7C
.text$mn:0000CB7C ; Segment type: Pure code
.text$mn:0000CB7C ; Segment permissions: Read/Execute
.text$mn:0000CB7C _text$mn        segment para public 'CODE' use32
.text$mn:0000CB7C                 assume cs:_text$mn
.text$mn:0000CB7C                 ;org 0CB7Ch
.text$mn:0000CB7C ; COMDAT (pick any)
.text$mn:0000CB7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CB7C
.text$mn:0000CB7C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CB7C
.text$mn:0000CB7C ; Attributes: bp-based frame
.text$mn:0000CB7C
.text$mn:0000CB7C ; public: unsigned int __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::size(void)const
.text$mn:0000CB7C                 public ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ
.text$mn:0000CB7C ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CB7C                                         ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+123p
.text$mn:0000CB7C                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+Ap
.text$mn:0000CB7C
.text$mn:0000CB7C var_4           = dword ptr -4
.text$mn:0000CB7C
.text$mn:0000CB7C                 push    ebp
.text$mn:0000CB7D                 mov     ebp, esp
.text$mn:0000CB7F                 push    ecx
.text$mn:0000CB80                 mov     [ebp+var_4], ecx
.text$mn:0000CB83                 mov     eax, [ebp+var_4]
.text$mn:0000CB86                 mov     ecx, [ebp+var_4]
.text$mn:0000CB89                 mov     eax, [eax+8]
.text$mn:0000CB8C                 sub     eax, [ecx+4]
.text$mn:0000CB8F                 cdq
.text$mn:0000CB90                 mov     ecx, 150h
.text$mn:0000CB95                 idiv    ecx
.text$mn:0000CB97                 mov     esp, ebp
.text$mn:0000CB99                 pop     ebp
.text$mn:0000CB9A                 retn
.text$mn:0000CB9A ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:0000CB9A
.text$mn:0000CB9A ; ---------------------------------------------------------------------------
.text$mn:0000CB9B                 align 4
.text$mn:0000CB9B _text$mn        ends
.text$mn:0000CB9B
.text$mn:0000CB9C ; ===========================================================================
.text$mn:0000CB9C
.text$mn:0000CB9C ; Segment type: Pure code
.text$mn:0000CB9C ; Segment permissions: Read/Execute
.text$mn:0000CB9C _text$mn        segment para public 'CODE' use32
.text$mn:0000CB9C                 assume cs:_text$mn
.text$mn:0000CB9C                 ;org 0CB9Ch
.text$mn:0000CB9C ; COMDAT (pick any)
.text$mn:0000CB9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CB9C
.text$mn:0000CB9C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CB9C
.text$mn:0000CB9C ; Attributes: bp-based frame
.text$mn:0000CB9C
.text$mn:0000CB9C ; public: unsigned int __thiscall std::vector<class ScintillaKeyMap, class std::allocator<class ScintillaKeyMap>>::size(void)const
.text$mn:0000CB9C                 public ?size@?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QBEIXZ
.text$mn:0000CB9C ?size@?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CB9C                                         ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+154p
.text$mn:0000CB9C                                         ; std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)+Ap
.text$mn:0000CB9C
.text$mn:0000CB9C var_4           = dword ptr -4
.text$mn:0000CB9C
.text$mn:0000CB9C                 push    ebp
.text$mn:0000CB9D                 mov     ebp, esp
.text$mn:0000CB9F                 push    ecx
.text$mn:0000CBA0                 mov     [ebp+var_4], ecx
.text$mn:0000CBA3                 mov     eax, [ebp+var_4]
.text$mn:0000CBA6                 mov     ecx, [ebp+var_4]
.text$mn:0000CBA9                 mov     eax, [eax+8]
.text$mn:0000CBAC                 sub     eax, [ecx+4]
.text$mn:0000CBAF                 cdq
.text$mn:0000CBB0                 mov     ecx, 144h
.text$mn:0000CBB5                 idiv    ecx
.text$mn:0000CBB7                 mov     esp, ebp
.text$mn:0000CBB9                 pop     ebp
.text$mn:0000CBBA                 retn
.text$mn:0000CBBA ?size@?$vector@VScintillaKeyMap@@V?$allocator@VScintillaKeyMap@@@std@@@std@@QBEIXZ endp
.text$mn:0000CBBA
.text$mn:0000CBBA ; ---------------------------------------------------------------------------
.text$mn:0000CBBB                 align 4
.text$mn:0000CBBB _text$mn        ends
.text$mn:0000CBBB
.text$mn:0000CBBC ; ===========================================================================
.text$mn:0000CBBC
.text$mn:0000CBBC ; Segment type: Pure code
.text$mn:0000CBBC ; Segment permissions: Read/Execute
.text$mn:0000CBBC _text$mn        segment para public 'CODE' use32
.text$mn:0000CBBC                 assume cs:_text$mn
.text$mn:0000CBBC                 ;org 0CBBCh
.text$mn:0000CBBC ; COMDAT (pick any)
.text$mn:0000CBBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CBBC
.text$mn:0000CBBC ; =============== S U B R O U T I N E =======================================
.text$mn:0000CBBC
.text$mn:0000CBBC ; Attributes: bp-based frame
.text$mn:0000CBBC
.text$mn:0000CBBC ; public: unsigned int __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::size(void)const
.text$mn:0000CBBC                 public ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ
.text$mn:0000CBBC ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:0000CBBC                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+DA0p
.text$mn:0000CBBC                                         ; ShortcutMapper::fillOutBabyGrid(void)+F2p ...
.text$mn:0000CBBC
.text$mn:0000CBBC var_4           = dword ptr -4
.text$mn:0000CBBC
.text$mn:0000CBBC                 push    ebp
.text$mn:0000CBBD                 mov     ebp, esp
.text$mn:0000CBBF                 push    ecx
.text$mn:0000CBC0                 mov     [ebp+var_4], ecx
.text$mn:0000CBC3                 mov     eax, [ebp+var_4]
.text$mn:0000CBC6                 mov     ecx, [ebp+var_4]
.text$mn:0000CBC9                 mov     eax, [eax+8]
.text$mn:0000CBCC                 sub     eax, [ecx+4]
.text$mn:0000CBCF                 cdq
.text$mn:0000CBD0                 mov     ecx, 148h
.text$mn:0000CBD5                 idiv    ecx
.text$mn:0000CBD7                 mov     esp, ebp
.text$mn:0000CBD9                 pop     ebp
.text$mn:0000CBDA                 retn
.text$mn:0000CBDA ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ endp
.text$mn:0000CBDA
.text$mn:0000CBDA ; ---------------------------------------------------------------------------
.text$mn:0000CBDB                 align 4
.text$mn:0000CBDB _text$mn        ends
.text$mn:0000CBDB
.text$mn:0000CBDC ; ===========================================================================
.text$mn:0000CBDC
.text$mn:0000CBDC ; Segment type: Pure code
.text$mn:0000CBDC ; Segment permissions: Read/Execute
.text$mn:0000CBDC _text$mn        segment para public 'CODE' use32
.text$mn:0000CBDC                 assume cs:_text$mn
.text$mn:0000CBDC                 ;org 0CBDCh
.text$mn:0000CBDC ; COMDAT (pick any)
.text$mn:0000CBDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CBDC
.text$mn:0000CBDC ; =============== S U B R O U T I N E =======================================
.text$mn:0000CBDC
.text$mn:0000CBDC ; Attributes: bp-based frame
.text$mn:0000CBDC
.text$mn:0000CBDC ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0000CBDC                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0000CBDC ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000CBDC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_B58Cp
.text$mn:0000CBDC                 push    ebp
.text$mn:0000CBDD                 mov     ebp, esp
.text$mn:0000CBDF                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000CBE4                 pop     ebp
.text$mn:0000CBE5                 retn
.text$mn:0000CBE5 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000CBE5
.text$mn:0000CBE5 ; ---------------------------------------------------------------------------
.text$mn:0000CBE6                 align 4
.text$mn:0000CBE6 _text$mn        ends
.text$mn:0000CBE6
.text$mn:0000CBE8 ; ===========================================================================
.text$mn:0000CBE8
.text$mn:0000CBE8 ; Segment type: Pure code
.text$mn:0000CBE8 ; Segment permissions: Read/Execute
.text$mn:0000CBE8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CBE8                 assume cs:_text$mn
.text$mn:0000CBE8                 ;org 0CBE8h
.text$mn:0000CBE8 ; COMDAT (pick any)
.text$mn:0000CBE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CBE8
.text$mn:0000CBE8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CBE8
.text$mn:0000CBE8 ; Attributes: bp-based frame
.text$mn:0000CBE8
.text$mn:0000CBE8 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000CBE8                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000CBE8 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000CBE8
.text$mn:0000CBE8 var_4           = dword ptr -4
.text$mn:0000CBE8
.text$mn:0000CBE8                 push    ebp
.text$mn:0000CBE9                 mov     ebp, esp
.text$mn:0000CBEB                 push    ecx
.text$mn:0000CBEC                 mov     [ebp+var_4], ecx
.text$mn:0000CBEF                 mov     eax, [ebp+var_4]
.text$mn:0000CBF2                 mov     eax, [eax]
.text$mn:0000CBF4                 mov     esp, ebp
.text$mn:0000CBF6                 pop     ebp
.text$mn:0000CBF7                 retn
.text$mn:0000CBF7 ?value@error_code@std@@QBEHXZ endp
.text$mn:0000CBF7
.text$mn:0000CBF7 _text$mn        ends
.text$mn:0000CBF7
.text$mn:0000CBF8 ; ===========================================================================
.text$mn:0000CBF8
.text$mn:0000CBF8 ; Segment type: Pure code
.text$mn:0000CBF8 ; Segment permissions: Read/Execute
.text$mn:0000CBF8 _text$mn        segment para public 'CODE' use32
.text$mn:0000CBF8                 assume cs:_text$mn
.text$mn:0000CBF8                 ;org 0CBF8h
.text$mn:0000CBF8 ; COMDAT (pick any)
.text$mn:0000CBF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CBF8
.text$mn:0000CBF8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CBF8
.text$mn:0000CBF8 ; Attributes: bp-based frame
.text$mn:0000CBF8
.text$mn:0000CBF8 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000CBF8                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000CBF8 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000CBF8                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000CBF8                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000CBF8
.text$mn:0000CBF8 var_4           = dword ptr -4
.text$mn:0000CBF8
.text$mn:0000CBF8                 push    ebp
.text$mn:0000CBF9                 mov     ebp, esp
.text$mn:0000CBFB                 push    ecx
.text$mn:0000CBFC                 mov     [ebp+var_4], ecx
.text$mn:0000CBFF                 mov     eax, [ebp+var_4]
.text$mn:0000CC02                 mov     eax, [eax]
.text$mn:0000CC04                 mov     esp, ebp
.text$mn:0000CC06                 pop     ebp
.text$mn:0000CC07                 retn
.text$mn:0000CC07 ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000CC07
.text$mn:0000CC07 _text$mn        ends
.text$mn:0000CC07
.text$mn:0000CC08 ; ===========================================================================
.text$mn:0000CC08
.text$mn:0000CC08 ; Segment type: Pure code
.text$mn:0000CC08 ; Segment permissions: Read/Execute
.text$mn:0000CC08 _text$mn        segment para public 'CODE' use32
.text$mn:0000CC08                 assume cs:_text$mn
.text$mn:0000CC08                 ;org 0CC08h
.text$mn:0000CC08 ; COMDAT (pick any)
.text$mn:0000CC08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CC08
.text$mn:0000CC08 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CC08
.text$mn:0000CC08 ; Attributes: bp-based frame
.text$mn:0000CC08
.text$mn:0000CC08                 public _hypot
.text$mn:0000CC08 _hypot          proc near
.text$mn:0000CC08
.text$mn:0000CC08 var_10          = qword ptr -10h
.text$mn:0000CC08 var_8           = qword ptr -8
.text$mn:0000CC08 arg_0           = qword ptr  8
.text$mn:0000CC08 arg_8           = qword ptr  10h
.text$mn:0000CC08
.text$mn:0000CC08                 push    ebp
.text$mn:0000CC09                 mov     ebp, esp
.text$mn:0000CC0B                 sub     esp, 8
.text$mn:0000CC0E                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000CC13                 movsd   [esp+8+var_8], xmm0
.text$mn:0000CC18                 sub     esp, 8
.text$mn:0000CC1B                 movsd   xmm0, [ebp+arg_0]
.text$mn:0000CC20                 movsd   [esp+10h+var_10], xmm0
.text$mn:0000CC25                 call    __hypot
.text$mn:0000CC2A                 add     esp, 10h
.text$mn:0000CC2D                 pop     ebp
.text$mn:0000CC2E                 retn
.text$mn:0000CC2E _hypot          endp
.text$mn:0000CC2E
.text$mn:0000CC2E ; ---------------------------------------------------------------------------
.text$mn:0000CC2F                 align 10h
.text$mn:0000CC2F _text$mn        ends
.text$mn:0000CC2F
.text$mn:0000CC30 ; ===========================================================================
.text$mn:0000CC30
.text$mn:0000CC30 ; Segment type: Pure code
.text$mn:0000CC30 ; Segment permissions: Read/Execute
.text$mn:0000CC30 _text$mn        segment para public 'CODE' use32
.text$mn:0000CC30                 assume cs:_text$mn
.text$mn:0000CC30                 ;org 0CC30h
.text$mn:0000CC30 ; COMDAT (pick any)
.text$mn:0000CC30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CC30
.text$mn:0000CC30 ; =============== S U B R O U T I N E =======================================
.text$mn:0000CC30
.text$mn:0000CC30 ; Attributes: bp-based frame
.text$mn:0000CC30
.text$mn:0000CC30 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:0000CC30                 public _wmemcpy
.text$mn:0000CC30 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000CC30
.text$mn:0000CC30 Dst             = dword ptr  8
.text$mn:0000CC30 Src             = dword ptr  0Ch
.text$mn:0000CC30 arg_8           = dword ptr  10h
.text$mn:0000CC30
.text$mn:0000CC30                 push    ebp
.text$mn:0000CC31                 mov     ebp, esp
.text$mn:0000CC33                 mov     eax, [ebp+arg_8]
.text$mn:0000CC36                 shl     eax, 1
.text$mn:0000CC38                 push    eax             ; Size
.text$mn:0000CC39                 mov     ecx, [ebp+Src]
.text$mn:0000CC3C                 push    ecx             ; Src
.text$mn:0000CC3D                 mov     edx, [ebp+Dst]
.text$mn:0000CC40                 push    edx             ; Dst
.text$mn:0000CC41                 call    _memcpy
.text$mn:0000CC46                 add     esp, 0Ch
.text$mn:0000CC49                 pop     ebp
.text$mn:0000CC4A                 retn
.text$mn:0000CC4A _wmemcpy        endp
.text$mn:0000CC4A
.text$mn:0000CC4A ; ---------------------------------------------------------------------------
.text$mn:0000CC4B                 align 4
.text$mn:0000CC4B _text$mn        ends
.text$mn:0000CC4B
.text$mn:0000CC4C ; ===========================================================================
.text$mn:0000CC4C
.text$mn:0000CC4C ; Segment type: Pure code
.text$mn:0000CC4C ; Segment permissions: Read/Execute
.text$mn:0000CC4C _text$mn        segment para public 'CODE' use32
.text$mn:0000CC4C                 assume cs:_text$mn
.text$mn:0000CC4C                 ;org 0CC4Ch
.text$mn:0000CC4C ; COMDAT (pick any)
.text$mn:0000CC4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000CC4C
.text$mn:0000CC4C ; =============== S U B R O U T I N E =======================================
.text$mn:0000CC4C
.text$mn:0000CC4C ; Attributes: bp-based frame
.text$mn:0000CC4C
.text$mn:0000CC4C ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:0000CC4C                 public _wmemmove
.text$mn:0000CC4C _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000CC4C
.text$mn:0000CC4C Dst             = dword ptr  8
.text$mn:0000CC4C Src             = dword ptr  0Ch
.text$mn:0000CC4C arg_8           = dword ptr  10h
.text$mn:0000CC4C
.text$mn:0000CC4C                 push    ebp
.text$mn:0000CC4D                 mov     ebp, esp
.text$mn:0000CC4F                 mov     eax, [ebp+arg_8]
.text$mn:0000CC52                 shl     eax, 1
.text$mn:0000CC54                 push    eax             ; Size
.text$mn:0000CC55                 mov     ecx, [ebp+Src]
.text$mn:0000CC58                 push    ecx             ; Src
.text$mn:0000CC59                 mov     edx, [ebp+Dst]
.text$mn:0000CC5C                 push    edx             ; Dst
.text$mn:0000CC5D                 call    _memmove
.text$mn:0000CC62                 add     esp, 0Ch
.text$mn:0000CC65                 pop     ebp
.text$mn:0000CC66                 retn
.text$mn:0000CC66 _wmemmove       endp
.text$mn:0000CC66
.text$mn:0000CC66 ; ---------------------------------------------------------------------------
.text$mn:0000CC67                 align 4
.text$mn:0000CC67 _text$mn        ends
.text$mn:0000CC67
.xdata$x:0000CC68 ; ===========================================================================
.xdata$x:0000CC68
.xdata$x:0000CC68 ; Segment type: Pure data
.xdata$x:0000CC68 ; Segment permissions: Read
.xdata$x:0000CC68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CC68                 assume cs:_xdata$x
.xdata$x:0000CC68                 ;org 0CC68h
.xdata$x:0000CC68 ; COMDAT (pick associative to section at 66E0)
.xdata$x:0000CC68 __unwindtable$??0StaticDialog@@QAE@XZ db 0FFh
.xdata$x:0000CC68                                         ; DATA XREF: .xdata$x:0000CC78o
.xdata$x:0000CC69                 db 0FFh
.xdata$x:0000CC6A                 db 0FFh
.xdata$x:0000CC6B                 db 0FFh
.xdata$x:0000CC6C                 dd offset __unwindfunclet$??0StaticDialog@@QAE@XZ$0
.xdata$x:0000CC70 __ehfuncinfo$??0StaticDialog@@QAE@XZ db  22h ; "
.xdata$x:0000CC70                                         ; DATA XREF: __ehhandler$??0StaticDialog@@QAE@XZ+11o
.xdata$x:0000CC71                 db    5
.xdata$x:0000CC72                 db  93h ; ô
.xdata$x:0000CC73                 db  19h
.xdata$x:0000CC74                 db    1
.xdata$x:0000CC75                 db    0
.xdata$x:0000CC76                 db    0
.xdata$x:0000CC77                 db    0
.xdata$x:0000CC78                 dd offset __unwindtable$??0StaticDialog@@QAE@XZ
.xdata$x:0000CC7C                 db    0
.xdata$x:0000CC7D                 db    0
.xdata$x:0000CC7E                 db    0
.xdata$x:0000CC7F                 db    0
.xdata$x:0000CC80                 db    0
.xdata$x:0000CC81                 db    0
.xdata$x:0000CC82                 db    0
.xdata$x:0000CC83                 db    0
.xdata$x:0000CC84                 db    0
.xdata$x:0000CC85                 db    0
.xdata$x:0000CC86                 db    0
.xdata$x:0000CC87                 db    0
.xdata$x:0000CC88                 db    0
.xdata$x:0000CC89                 db    0
.xdata$x:0000CC8A                 db    0
.xdata$x:0000CC8B                 db    0
.xdata$x:0000CC8C                 db    0
.xdata$x:0000CC8D                 db    0
.xdata$x:0000CC8E                 db    0
.xdata$x:0000CC8F                 db    0
.xdata$x:0000CC90                 db    0
.xdata$x:0000CC91                 db    0
.xdata$x:0000CC92                 db    0
.xdata$x:0000CC93                 db    0
.xdata$x:0000CC93 _xdata$x        ends
.xdata$x:0000CC93
.xdata$x:0000CC94 ; ===========================================================================
.xdata$x:0000CC94
.xdata$x:0000CC94 ; Segment type: Pure data
.xdata$x:0000CC94 ; Segment permissions: Read
.xdata$x:0000CC94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CC94                 assume cs:_xdata$x
.xdata$x:0000CC94                 ;org 0CC94h
.xdata$x:0000CC94 ; COMDAT (pick associative to section at 79D4)
.xdata$x:0000CC94 __unwindtable$??1StaticDialog@@UAE@XZ db 0FFh
.xdata$x:0000CC94                                         ; DATA XREF: .xdata$x:0000CCA4o
.xdata$x:0000CC95                 db 0FFh
.xdata$x:0000CC96                 db 0FFh
.xdata$x:0000CC97                 db 0FFh
.xdata$x:0000CC98                 dd offset __unwindfunclet$??1StaticDialog@@UAE@XZ$0
.xdata$x:0000CC9C __ehfuncinfo$??1StaticDialog@@UAE@XZ db  22h ; "
.xdata$x:0000CC9C                                         ; DATA XREF: __ehhandler$??1StaticDialog@@UAE@XZ+11o
.xdata$x:0000CC9D                 db    5
.xdata$x:0000CC9E                 db  93h ; ô
.xdata$x:0000CC9F                 db  19h
.xdata$x:0000CCA0                 db    1
.xdata$x:0000CCA1                 db    0
.xdata$x:0000CCA2                 db    0
.xdata$x:0000CCA3                 db    0
.xdata$x:0000CCA4                 dd offset __unwindtable$??1StaticDialog@@UAE@XZ
.xdata$x:0000CCA8                 align 20h
.xdata$x:0000CCA8 _xdata$x        ends
.xdata$x:0000CCA8
.xdata$x:0000CCC0 ; ===========================================================================
.xdata$x:0000CCC0
.xdata$x:0000CCC0 ; Segment type: Pure data
.xdata$x:0000CCC0 ; Segment permissions: Read
.xdata$x:0000CCC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CCC0                 assume cs:_xdata$x
.xdata$x:0000CCC0                 ;org 0CCC0h
.xdata$x:0000CCC0 ; COMDAT (pick associative to section at A208)
.xdata$x:0000CCC0 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000CCC0                                         ; DATA XREF: .xdata$x:0000CCD0o
.xdata$x:0000CCC1                 db 0FFh
.xdata$x:0000CCC2                 db 0FFh
.xdata$x:0000CCC3                 db 0FFh
.xdata$x:0000CCC4                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000CCC8 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000CCC8                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000CCC9                 db    5
.xdata$x:0000CCCA                 db  93h ; ô
.xdata$x:0000CCCB                 db  19h
.xdata$x:0000CCCC                 db    1
.xdata$x:0000CCCD                 db    0
.xdata$x:0000CCCE                 db    0
.xdata$x:0000CCCF                 db    0
.xdata$x:0000CCD0                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000CCD4                 db    0
.xdata$x:0000CCD5                 db    0
.xdata$x:0000CCD6                 db    0
.xdata$x:0000CCD7                 db    0
.xdata$x:0000CCD8                 db    0
.xdata$x:0000CCD9                 db    0
.xdata$x:0000CCDA                 db    0
.xdata$x:0000CCDB                 db    0
.xdata$x:0000CCDC                 db    0
.xdata$x:0000CCDD                 db    0
.xdata$x:0000CCDE                 db    0
.xdata$x:0000CCDF                 db    0
.xdata$x:0000CCE0                 db    0
.xdata$x:0000CCE1                 db    0
.xdata$x:0000CCE2                 db    0
.xdata$x:0000CCE3                 db    0
.xdata$x:0000CCE4                 db    0
.xdata$x:0000CCE5                 db    0
.xdata$x:0000CCE6                 db    0
.xdata$x:0000CCE7                 db    0
.xdata$x:0000CCE8                 db    0
.xdata$x:0000CCE9                 db    0
.xdata$x:0000CCEA                 db    0
.xdata$x:0000CCEB                 db    0
.xdata$x:0000CCEB _xdata$x        ends
.xdata$x:0000CCEB
.xdata$x:0000CCEC ; ===========================================================================
.xdata$x:0000CCEC
.xdata$x:0000CCEC ; Segment type: Pure data
.xdata$x:0000CCEC ; Segment permissions: Read
.xdata$x:0000CCEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CCEC                 assume cs:_xdata$x
.xdata$x:0000CCEC                 ;org 0CCECh
.xdata$x:0000CCEC ; COMDAT (pick associative to section at 8498)
.xdata$x:0000CCEC __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:0000CCEC                                         ; DATA XREF: .xdata$x:0000CCFCo
.xdata$x:0000CCED                 db 0FFh
.xdata$x:0000CCEE                 db 0FFh
.xdata$x:0000CCEF                 db 0FFh
.xdata$x:0000CCF0                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:0000CCF4 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:0000CCF4                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:0000CCF5                 db    5
.xdata$x:0000CCF6                 db  93h ; ô
.xdata$x:0000CCF7                 db  19h
.xdata$x:0000CCF8                 db    1
.xdata$x:0000CCF9                 db    0
.xdata$x:0000CCFA                 db    0
.xdata$x:0000CCFB                 db    0
.xdata$x:0000CCFC                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:0000CD00                 db    0
.xdata$x:0000CD01                 db    0
.xdata$x:0000CD02                 db    0
.xdata$x:0000CD03                 db    0
.xdata$x:0000CD04                 db    0
.xdata$x:0000CD05                 db    0
.xdata$x:0000CD06                 db    0
.xdata$x:0000CD07                 db    0
.xdata$x:0000CD08                 db    0
.xdata$x:0000CD09                 db    0
.xdata$x:0000CD0A                 db    0
.xdata$x:0000CD0B                 db    0
.xdata$x:0000CD0C                 db    0
.xdata$x:0000CD0D                 db    0
.xdata$x:0000CD0E                 db    0
.xdata$x:0000CD0F                 db    0
.xdata$x:0000CD10                 db    0
.xdata$x:0000CD11                 db    0
.xdata$x:0000CD12                 db    0
.xdata$x:0000CD13                 db    0
.xdata$x:0000CD14                 db    0
.xdata$x:0000CD15                 db    0
.xdata$x:0000CD16                 db    0
.xdata$x:0000CD17                 db    0
.xdata$x:0000CD17 _xdata$x        ends
.xdata$x:0000CD17
.xdata$x:0000CD18 ; ===========================================================================
.xdata$x:0000CD18
.xdata$x:0000CD18 ; Segment type: Pure data
.xdata$x:0000CD18 ; Segment permissions: Read
.xdata$x:0000CD18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD18                 assume cs:_xdata$x
.xdata$x:0000CD18                 ;org 0CD18h
.xdata$x:0000CD18 ; COMDAT (pick associative to section at 7C10)
.xdata$x:0000CD18 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:0000CD18                                         ; DATA XREF: .xdata$x:0000CD28o
.xdata$x:0000CD19                 db 0FFh
.xdata$x:0000CD1A                 db 0FFh
.xdata$x:0000CD1B                 db 0FFh
.xdata$x:0000CD1C                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:0000CD20 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:0000CD20                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:0000CD21                 db    5
.xdata$x:0000CD22                 db  93h ; ô
.xdata$x:0000CD23                 db  19h
.xdata$x:0000CD24                 db    1
.xdata$x:0000CD25                 db    0
.xdata$x:0000CD26                 db    0
.xdata$x:0000CD27                 db    0
.xdata$x:0000CD28                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:0000CD2C                 db    0
.xdata$x:0000CD2D                 db    0
.xdata$x:0000CD2E                 db    0
.xdata$x:0000CD2F                 db    0
.xdata$x:0000CD30                 db    0
.xdata$x:0000CD31                 db    0
.xdata$x:0000CD32                 db    0
.xdata$x:0000CD33                 db    0
.xdata$x:0000CD34                 db    0
.xdata$x:0000CD35                 db    0
.xdata$x:0000CD36                 db    0
.xdata$x:0000CD37                 db    0
.xdata$x:0000CD38                 db    0
.xdata$x:0000CD39                 db    0
.xdata$x:0000CD3A                 db    0
.xdata$x:0000CD3B                 db    0
.xdata$x:0000CD3C                 db    0
.xdata$x:0000CD3D                 db    0
.xdata$x:0000CD3E                 db    0
.xdata$x:0000CD3F                 db    0
.xdata$x:0000CD40                 db    0
.xdata$x:0000CD41                 db    0
.xdata$x:0000CD42                 db    0
.xdata$x:0000CD43                 db    0
.xdata$x:0000CD43 _xdata$x        ends
.xdata$x:0000CD43
.xdata$x:0000CD44 ; ===========================================================================
.xdata$x:0000CD44
.xdata$x:0000CD44 ; Segment type: Pure data
.xdata$x:0000CD44 ; Segment permissions: Read
.xdata$x:0000CD44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD44                 assume cs:_xdata$x
.xdata$x:0000CD44                 ;org 0CD44h
.xdata$x:0000CD44 ; COMDAT (pick associative to section at 92B4)
.xdata$x:0000CD44 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:0000CD44                                         ; DATA XREF: .xdata$x:0000CD5Co
.xdata$x:0000CD45                 db 0FFh
.xdata$x:0000CD46                 db 0FFh
.xdata$x:0000CD47                 db 0FFh
.xdata$x:0000CD48                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:0000CD4C                 db 0FFh
.xdata$x:0000CD4D                 db 0FFh
.xdata$x:0000CD4E                 db 0FFh
.xdata$x:0000CD4F                 db 0FFh
.xdata$x:0000CD50                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:0000CD54 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:0000CD54                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:0000CD55                 db    5
.xdata$x:0000CD56                 db  93h ; ô
.xdata$x:0000CD57                 db  19h
.xdata$x:0000CD58                 db    2
.xdata$x:0000CD59                 db    0
.xdata$x:0000CD5A                 db    0
.xdata$x:0000CD5B                 db    0
.xdata$x:0000CD5C                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:0000CD60                 db    0
.xdata$x:0000CD61                 db    0
.xdata$x:0000CD62                 db    0
.xdata$x:0000CD63                 db    0
.xdata$x:0000CD64                 db    0
.xdata$x:0000CD65                 db    0
.xdata$x:0000CD66                 db    0
.xdata$x:0000CD67                 db    0
.xdata$x:0000CD68                 db    0
.xdata$x:0000CD69                 db    0
.xdata$x:0000CD6A                 db    0
.xdata$x:0000CD6B                 db    0
.xdata$x:0000CD6C                 db    0
.xdata$x:0000CD6D                 db    0
.xdata$x:0000CD6E                 db    0
.xdata$x:0000CD6F                 db    0
.xdata$x:0000CD70                 db    0
.xdata$x:0000CD71                 db    0
.xdata$x:0000CD72                 db    0
.xdata$x:0000CD73                 db    0
.xdata$x:0000CD74                 db    0
.xdata$x:0000CD75                 db    0
.xdata$x:0000CD76                 db    0
.xdata$x:0000CD77                 db    0
.xdata$x:0000CD77 _xdata$x        ends
.xdata$x:0000CD77
.xdata$x:0000CD78 ; ===========================================================================
.xdata$x:0000CD78
.xdata$x:0000CD78 ; Segment type: Pure data
.xdata$x:0000CD78 ; Segment permissions: Read
.xdata$x:0000CD78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD78                 assume cs:_xdata$x
.xdata$x:0000CD78                 ;org 0CD78h
.xdata$x:0000CD78 ; COMDAT (pick associative to section at 520C)
.xdata$x:0000CD78 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CD78                                         ; DATA XREF: .xdata$x:0000CD88o
.xdata$x:0000CD79                 db 0FFh
.xdata$x:0000CD7A                 db 0FFh
.xdata$x:0000CD7B                 db 0FFh
.xdata$x:0000CD7C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000CD80 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CD80                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000CD81                 db    5
.xdata$x:0000CD82                 db  93h ; ô
.xdata$x:0000CD83                 db  19h
.xdata$x:0000CD84                 db    1
.xdata$x:0000CD85                 db    0
.xdata$x:0000CD86                 db    0
.xdata$x:0000CD87                 db    0
.xdata$x:0000CD88                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000CD8C                 db    0
.xdata$x:0000CD8D                 db    0
.xdata$x:0000CD8E                 db    0
.xdata$x:0000CD8F                 db    0
.xdata$x:0000CD90                 db    0
.xdata$x:0000CD91                 db    0
.xdata$x:0000CD92                 db    0
.xdata$x:0000CD93                 db    0
.xdata$x:0000CD94                 db    0
.xdata$x:0000CD95                 db    0
.xdata$x:0000CD96                 db    0
.xdata$x:0000CD97                 db    0
.xdata$x:0000CD98                 db    0
.xdata$x:0000CD99                 db    0
.xdata$x:0000CD9A                 db    0
.xdata$x:0000CD9B                 db    0
.xdata$x:0000CD9C                 db    0
.xdata$x:0000CD9D                 db    0
.xdata$x:0000CD9E                 db    0
.xdata$x:0000CD9F                 db    0
.xdata$x:0000CDA0                 db    0
.xdata$x:0000CDA1                 db    0
.xdata$x:0000CDA2                 db    0
.xdata$x:0000CDA3                 db    0
.xdata$x:0000CDA3 _xdata$x        ends
.xdata$x:0000CDA3
.xdata$x:0000CDA4 ; ===========================================================================
.xdata$x:0000CDA4
.xdata$x:0000CDA4 ; Segment type: Pure data
.xdata$x:0000CDA4 ; Segment permissions: Read
.xdata$x:0000CDA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDA4                 assume cs:_xdata$x
.xdata$x:0000CDA4                 ;org 0CDA4h
.xdata$x:0000CDA4 ; COMDAT (pick associative to section at 6E0C)
.xdata$x:0000CDA4 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CDA4                                         ; DATA XREF: .xdata$x:0000CDB4o
.xdata$x:0000CDA5                 db 0FFh
.xdata$x:0000CDA6                 db 0FFh
.xdata$x:0000CDA7                 db 0FFh
.xdata$x:0000CDA8                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000CDAC __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CDAC                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000CDAD                 db    5
.xdata$x:0000CDAE                 db  93h ; ô
.xdata$x:0000CDAF                 db  19h
.xdata$x:0000CDB0                 db    1
.xdata$x:0000CDB1                 db    0
.xdata$x:0000CDB2                 db    0
.xdata$x:0000CDB3                 db    0
.xdata$x:0000CDB4                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000CDB8                 db    0
.xdata$x:0000CDB9                 db    0
.xdata$x:0000CDBA                 db    0
.xdata$x:0000CDBB                 db    0
.xdata$x:0000CDBC                 db    0
.xdata$x:0000CDBD                 db    0
.xdata$x:0000CDBE                 db    0
.xdata$x:0000CDBF                 db    0
.xdata$x:0000CDC0                 db    0
.xdata$x:0000CDC1                 db    0
.xdata$x:0000CDC2                 db    0
.xdata$x:0000CDC3                 db    0
.xdata$x:0000CDC4                 db    0
.xdata$x:0000CDC5                 db    0
.xdata$x:0000CDC6                 db    0
.xdata$x:0000CDC7                 db    0
.xdata$x:0000CDC8                 db    0
.xdata$x:0000CDC9                 db    0
.xdata$x:0000CDCA                 db    0
.xdata$x:0000CDCB                 db    0
.xdata$x:0000CDCC                 db    0
.xdata$x:0000CDCD                 db    0
.xdata$x:0000CDCE                 db    0
.xdata$x:0000CDCF                 db    0
.xdata$x:0000CDCF _xdata$x        ends
.xdata$x:0000CDCF
.xdata$x:0000CDD0 ; ===========================================================================
.xdata$x:0000CDD0
.xdata$x:0000CDD0 ; Segment type: Pure data
.xdata$x:0000CDD0 ; Segment permissions: Read
.xdata$x:0000CDD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDD0                 assume cs:_xdata$x
.xdata$x:0000CDD0                 ;org 0CDD0h
.xdata$x:0000CDD0 ; COMDAT (pick associative to section at 5114)
.xdata$x:0000CDD0 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000CDD0                                         ; DATA XREF: .xdata$x:0000CDE0o
.xdata$x:0000CDD1                 db 0FFh
.xdata$x:0000CDD2                 db 0FFh
.xdata$x:0000CDD3                 db 0FFh
.xdata$x:0000CDD4                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000CDD8 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000CDD8                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000CDD9                 db    5
.xdata$x:0000CDDA                 db  93h ; ô
.xdata$x:0000CDDB                 db  19h
.xdata$x:0000CDDC                 db    1
.xdata$x:0000CDDD                 db    0
.xdata$x:0000CDDE                 db    0
.xdata$x:0000CDDF                 db    0
.xdata$x:0000CDE0                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000CDE4                 db    0
.xdata$x:0000CDE5                 db    0
.xdata$x:0000CDE6                 db    0
.xdata$x:0000CDE7                 db    0
.xdata$x:0000CDE8                 db    0
.xdata$x:0000CDE9                 db    0
.xdata$x:0000CDEA                 db    0
.xdata$x:0000CDEB                 db    0
.xdata$x:0000CDEC                 db    0
.xdata$x:0000CDED                 db    0
.xdata$x:0000CDEE                 db    0
.xdata$x:0000CDEF                 db    0
.xdata$x:0000CDF0                 db    0
.xdata$x:0000CDF1                 db    0
.xdata$x:0000CDF2                 db    0
.xdata$x:0000CDF3                 db    0
.xdata$x:0000CDF4                 db    0
.xdata$x:0000CDF5                 db    0
.xdata$x:0000CDF6                 db    0
.xdata$x:0000CDF7                 db    0
.xdata$x:0000CDF8                 db    0
.xdata$x:0000CDF9                 db    0
.xdata$x:0000CDFA                 db    0
.xdata$x:0000CDFB                 db    0
.xdata$x:0000CDFB _xdata$x        ends
.xdata$x:0000CDFB
.xdata$x:0000CDFC ; ===========================================================================
.xdata$x:0000CDFC
.xdata$x:0000CDFC ; Segment type: Pure data
.xdata$x:0000CDFC ; Segment permissions: Read
.xdata$x:0000CDFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDFC                 assume cs:_xdata$x
.xdata$x:0000CDFC                 ;org 0CDFCh
.xdata$x:0000CDFC ; COMDAT (pick associative to section at 6D1C)
.xdata$x:0000CDFC __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CDFC                                         ; DATA XREF: .xdata$x:0000CE0Co
.xdata$x:0000CDFD                 db 0FFh
.xdata$x:0000CDFE                 db 0FFh
.xdata$x:0000CDFF                 db 0FFh
.xdata$x:0000CE00                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000CE04 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CE04                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000CE05                 db    5
.xdata$x:0000CE06                 db  93h ; ô
.xdata$x:0000CE07                 db  19h
.xdata$x:0000CE08                 db    1
.xdata$x:0000CE09                 db    0
.xdata$x:0000CE0A                 db    0
.xdata$x:0000CE0B                 db    0
.xdata$x:0000CE0C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000CE10                 db    0
.xdata$x:0000CE11                 db    0
.xdata$x:0000CE12                 db    0
.xdata$x:0000CE13                 db    0
.xdata$x:0000CE14                 db    0
.xdata$x:0000CE15                 db    0
.xdata$x:0000CE16                 db    0
.xdata$x:0000CE17                 db    0
.xdata$x:0000CE18                 db    0
.xdata$x:0000CE19                 db    0
.xdata$x:0000CE1A                 db    0
.xdata$x:0000CE1B                 db    0
.xdata$x:0000CE1C                 db    0
.xdata$x:0000CE1D                 db    0
.xdata$x:0000CE1E                 db    0
.xdata$x:0000CE1F                 db    0
.xdata$x:0000CE20                 db    0
.xdata$x:0000CE21                 db    0
.xdata$x:0000CE22                 db    0
.xdata$x:0000CE23                 db    0
.xdata$x:0000CE24                 db    0
.xdata$x:0000CE25                 db    0
.xdata$x:0000CE26                 db    0
.xdata$x:0000CE27                 db    0
.xdata$x:0000CE27 _xdata$x        ends
.xdata$x:0000CE27
.xdata$x:0000CE28 ; ===========================================================================
.xdata$x:0000CE28
.xdata$x:0000CE28 ; Segment type: Pure data
.xdata$x:0000CE28 ; Segment permissions: Read
.xdata$x:0000CE28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE28                 assume cs:_xdata$x
.xdata$x:0000CE28                 ;org 0CE28h
.xdata$x:0000CE28 ; COMDAT (pick associative to section at 5E2C)
.xdata$x:0000CE28 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000CE28                                         ; DATA XREF: .xdata$x:0000CE38o
.xdata$x:0000CE29                 db 0FFh
.xdata$x:0000CE2A                 db 0FFh
.xdata$x:0000CE2B                 db 0FFh
.xdata$x:0000CE2C                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000CE30 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000CE30                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000CE31                 db    5
.xdata$x:0000CE32                 db  93h ; ô
.xdata$x:0000CE33                 db  19h
.xdata$x:0000CE34                 db    1
.xdata$x:0000CE35                 db    0
.xdata$x:0000CE36                 db    0
.xdata$x:0000CE37                 db    0
.xdata$x:0000CE38                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:0000CE3C                 db    0
.xdata$x:0000CE3D                 db    0
.xdata$x:0000CE3E                 db    0
.xdata$x:0000CE3F                 db    0
.xdata$x:0000CE40                 db    0
.xdata$x:0000CE41                 db    0
.xdata$x:0000CE42                 db    0
.xdata$x:0000CE43                 db    0
.xdata$x:0000CE44                 db    0
.xdata$x:0000CE45                 db    0
.xdata$x:0000CE46                 db    0
.xdata$x:0000CE47                 db    0
.xdata$x:0000CE48                 db    0
.xdata$x:0000CE49                 db    0
.xdata$x:0000CE4A                 db    0
.xdata$x:0000CE4B                 db    0
.xdata$x:0000CE4C                 db    0
.xdata$x:0000CE4D                 db    0
.xdata$x:0000CE4E                 db    0
.xdata$x:0000CE4F                 db    0
.xdata$x:0000CE50                 db    0
.xdata$x:0000CE51                 db    0
.xdata$x:0000CE52                 db    0
.xdata$x:0000CE53                 db    0
.xdata$x:0000CE53 _xdata$x        ends
.xdata$x:0000CE53
.xdata$x:0000CE54 ; ===========================================================================
.xdata$x:0000CE54
.xdata$x:0000CE54 ; Segment type: Pure data
.xdata$x:0000CE54 ; Segment permissions: Read
.xdata$x:0000CE54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE54                 assume cs:_xdata$x
.xdata$x:0000CE54                 ;org 0CE54h
.xdata$x:0000CE54 ; COMDAT (pick associative to section at 7444)
.xdata$x:0000CE54 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000CE54                                         ; DATA XREF: .xdata$x:0000CE64o
.xdata$x:0000CE55                 db 0FFh
.xdata$x:0000CE56                 db 0FFh
.xdata$x:0000CE57                 db 0FFh
.xdata$x:0000CE58                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000CE5C __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CE5C                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000CE5D                 db    5
.xdata$x:0000CE5E                 db  93h ; ô
.xdata$x:0000CE5F                 db  19h
.xdata$x:0000CE60                 db    1
.xdata$x:0000CE61                 db    0
.xdata$x:0000CE62                 db    0
.xdata$x:0000CE63                 db    0
.xdata$x:0000CE64                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000CE68                 align 20h
.xdata$x:0000CE68 _xdata$x        ends
.xdata$x:0000CE68
.xdata$x:0000CE80 ; ===========================================================================
.xdata$x:0000CE80
.xdata$x:0000CE80 ; Segment type: Pure data
.xdata$x:0000CE80 ; Segment permissions: Read
.xdata$x:0000CE80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE80                 assume cs:_xdata$x
.xdata$x:0000CE80                 ;org 0CE80h
.xdata$x:0000CE80 ; COMDAT (pick associative to section at 9668)
.xdata$x:0000CE80 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000CE80                                         ; DATA XREF: .xdata$x:0000CF08o
.xdata$x:0000CE81                 db    0
.xdata$x:0000CE82                 db    0
.xdata$x:0000CE83                 db    0
.xdata$x:0000CE84                 db    0
.xdata$x:0000CE85                 db    0
.xdata$x:0000CE86                 db    0
.xdata$x:0000CE87                 db    0
.xdata$x:0000CE88                 db    0
.xdata$x:0000CE89                 db    0
.xdata$x:0000CE8A                 db    0
.xdata$x:0000CE8B                 db    0
.xdata$x:0000CE8C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000CE90 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000CE90                                         ; DATA XREF: .xdata$x:0000CEF4o
.xdata$x:0000CE91                 db    0
.xdata$x:0000CE92                 db    0
.xdata$x:0000CE93                 db    0
.xdata$x:0000CE94                 db    0
.xdata$x:0000CE95                 db    0
.xdata$x:0000CE96                 db    0
.xdata$x:0000CE97                 db    0
.xdata$x:0000CE98                 db    0
.xdata$x:0000CE99                 db    0
.xdata$x:0000CE9A                 db    0
.xdata$x:0000CE9B                 db    0
.xdata$x:0000CE9C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000CEA0 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000CEA0                                         ; DATA XREF: .xdata$x:0000CEC8o
.xdata$x:0000CEA1                 db 0FFh
.xdata$x:0000CEA2                 db 0FFh
.xdata$x:0000CEA3                 db 0FFh
.xdata$x:0000CEA4                 db    0
.xdata$x:0000CEA5                 db    0
.xdata$x:0000CEA6                 db    0
.xdata$x:0000CEA7                 db    0
.xdata$x:0000CEA8                 db 0FFh
.xdata$x:0000CEA9                 db 0FFh
.xdata$x:0000CEAA                 db 0FFh
.xdata$x:0000CEAB                 db 0FFh
.xdata$x:0000CEAC                 db    0
.xdata$x:0000CEAD                 db    0
.xdata$x:0000CEAE                 db    0
.xdata$x:0000CEAF                 db    0
.xdata$x:0000CEB0                 db    1
.xdata$x:0000CEB1                 db    0
.xdata$x:0000CEB2                 db    0
.xdata$x:0000CEB3                 db    0
.xdata$x:0000CEB4                 db    0
.xdata$x:0000CEB5                 db    0
.xdata$x:0000CEB6                 db    0
.xdata$x:0000CEB7                 db    0
.xdata$x:0000CEB8                 db    1
.xdata$x:0000CEB9                 db    0
.xdata$x:0000CEBA                 db    0
.xdata$x:0000CEBB                 db    0
.xdata$x:0000CEBC                 db    0
.xdata$x:0000CEBD                 db    0
.xdata$x:0000CEBE                 db    0
.xdata$x:0000CEBF                 db    0
.xdata$x:0000CEC0 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000CEC0                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000CEC1                 db    5
.xdata$x:0000CEC2                 db  93h ; ô
.xdata$x:0000CEC3                 db  19h
.xdata$x:0000CEC4                 db    4
.xdata$x:0000CEC5                 db    0
.xdata$x:0000CEC6                 db    0
.xdata$x:0000CEC7                 db    0
.xdata$x:0000CEC8                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000CECC                 db    2
.xdata$x:0000CECD                 db    0
.xdata$x:0000CECE                 db    0
.xdata$x:0000CECF                 db    0
.xdata$x:0000CED0                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000CED4                 db    0
.xdata$x:0000CED5                 db    0
.xdata$x:0000CED6                 db    0
.xdata$x:0000CED7                 db    0
.xdata$x:0000CED8                 db    0
.xdata$x:0000CED9                 db    0
.xdata$x:0000CEDA                 db    0
.xdata$x:0000CEDB                 db    0
.xdata$x:0000CEDC                 db    0
.xdata$x:0000CEDD                 db    0
.xdata$x:0000CEDE                 db    0
.xdata$x:0000CEDF                 db    0
.xdata$x:0000CEE0                 db    0
.xdata$x:0000CEE1                 db    0
.xdata$x:0000CEE2                 db    0
.xdata$x:0000CEE3                 db    0
.xdata$x:0000CEE4 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000CEE4                                         ; DATA XREF: .xdata$x:0000CED0o
.xdata$x:0000CEE5                 db    0
.xdata$x:0000CEE6                 db    0
.xdata$x:0000CEE7                 db    0
.xdata$x:0000CEE8                 db    2
.xdata$x:0000CEE9                 db    0
.xdata$x:0000CEEA                 db    0
.xdata$x:0000CEEB                 db    0
.xdata$x:0000CEEC                 db    3
.xdata$x:0000CEED                 db    0
.xdata$x:0000CEEE                 db    0
.xdata$x:0000CEEF                 db    0
.xdata$x:0000CEF0                 db    1
.xdata$x:0000CEF1                 db    0
.xdata$x:0000CEF2                 db    0
.xdata$x:0000CEF3                 db    0
.xdata$x:0000CEF4                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:0000CEF8                 align 10h
.xdata$x:0000CF00                 db    3
.xdata$x:0000CF01                 db    0
.xdata$x:0000CF02                 db    0
.xdata$x:0000CF03                 db    0
.xdata$x:0000CF04                 db    1
.xdata$x:0000CF05                 db    0
.xdata$x:0000CF06                 db    0
.xdata$x:0000CF07                 db    0
.xdata$x:0000CF08                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:0000CF08 _xdata$x        ends
.xdata$x:0000CF08
.xdata$x:0000CF0C ; ===========================================================================
.xdata$x:0000CF0C
.xdata$x:0000CF0C ; Segment type: Pure data
.xdata$x:0000CF0C ; Segment permissions: Read
.xdata$x:0000CF0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF0C                 assume cs:_xdata$x
.xdata$x:0000CF0C                 ;org 0CF0Ch
.xdata$x:0000CF0C ; COMDAT (pick associative to section at 6880)
.xdata$x:0000CF0C __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000CF0C                                         ; DATA XREF: .xdata$x:0000CF1Co
.xdata$x:0000CF0D                 db 0FFh
.xdata$x:0000CF0E                 db 0FFh
.xdata$x:0000CF0F                 db 0FFh
.xdata$x:0000CF10                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:0000CF14 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000CF14                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:0000CF15                 db    5
.xdata$x:0000CF16                 db  93h ; ô
.xdata$x:0000CF17                 db  19h
.xdata$x:0000CF18                 db    1
.xdata$x:0000CF19                 db    0
.xdata$x:0000CF1A                 db    0
.xdata$x:0000CF1B                 db    0
.xdata$x:0000CF1C                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000CF20                 db    0
.xdata$x:0000CF21                 db    0
.xdata$x:0000CF22                 db    0
.xdata$x:0000CF23                 db    0
.xdata$x:0000CF24                 db    0
.xdata$x:0000CF25                 db    0
.xdata$x:0000CF26                 db    0
.xdata$x:0000CF27                 db    0
.xdata$x:0000CF28                 db    0
.xdata$x:0000CF29                 db    0
.xdata$x:0000CF2A                 db    0
.xdata$x:0000CF2B                 db    0
.xdata$x:0000CF2C                 db    0
.xdata$x:0000CF2D                 db    0
.xdata$x:0000CF2E                 db    0
.xdata$x:0000CF2F                 db    0
.xdata$x:0000CF30                 db    0
.xdata$x:0000CF31                 db    0
.xdata$x:0000CF32                 db    0
.xdata$x:0000CF33                 db    0
.xdata$x:0000CF34                 db    0
.xdata$x:0000CF35                 db    0
.xdata$x:0000CF36                 db    0
.xdata$x:0000CF37                 db    0
.xdata$x:0000CF37 _xdata$x        ends
.xdata$x:0000CF37
.xdata$x:0000CF38 ; ===========================================================================
.xdata$x:0000CF38
.xdata$x:0000CF38 ; Segment type: Pure data
.xdata$x:0000CF38 ; Segment permissions: Read
.xdata$x:0000CF38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF38                 assume cs:_xdata$x
.xdata$x:0000CF38                 ;org 0CF38h
.xdata$x:0000CF38 ; COMDAT (pick associative to section at C3A4)
.xdata$x:0000CF38 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000CF38                                         ; DATA XREF: .xdata$x:0000CF48o
.xdata$x:0000CF39                 db 0FFh
.xdata$x:0000CF3A                 db 0FFh
.xdata$x:0000CF3B                 db 0FFh
.xdata$x:0000CF3C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000CF40 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000CF40                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000CF41                 db    5
.xdata$x:0000CF42                 db  93h ; ô
.xdata$x:0000CF43                 db  19h
.xdata$x:0000CF44                 db    1
.xdata$x:0000CF45                 db    0
.xdata$x:0000CF46                 db    0
.xdata$x:0000CF47                 db    0
.xdata$x:0000CF48                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000CF4C                 db    0
.xdata$x:0000CF4D                 db    0
.xdata$x:0000CF4E                 db    0
.xdata$x:0000CF4F                 db    0
.xdata$x:0000CF50                 db    0
.xdata$x:0000CF51                 db    0
.xdata$x:0000CF52                 db    0
.xdata$x:0000CF53                 db    0
.xdata$x:0000CF54                 db    0
.xdata$x:0000CF55                 db    0
.xdata$x:0000CF56                 db    0
.xdata$x:0000CF57                 db    0
.xdata$x:0000CF58                 db    0
.xdata$x:0000CF59                 db    0
.xdata$x:0000CF5A                 db    0
.xdata$x:0000CF5B                 db    0
.xdata$x:0000CF5C                 db    0
.xdata$x:0000CF5D                 db    0
.xdata$x:0000CF5E                 db    0
.xdata$x:0000CF5F                 db    0
.xdata$x:0000CF60                 db    0
.xdata$x:0000CF61                 db    0
.xdata$x:0000CF62                 db    0
.xdata$x:0000CF63                 db    0
.xdata$x:0000CF63 _xdata$x        ends
.xdata$x:0000CF63
.xdata$x:0000CF64 ; ===========================================================================
.xdata$x:0000CF64
.xdata$x:0000CF64 ; Segment type: Pure data
.xdata$x:0000CF64 ; Segment permissions: Read
.xdata$x:0000CF64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF64                 assume cs:_xdata$x
.xdata$x:0000CF64                 ;org 0CF64h
.xdata$x:0000CF64 ; COMDAT (pick associative to section at 7B30)
.xdata$x:0000CF64 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000CF64                                         ; DATA XREF: .xdata$x:0000CF74o
.xdata$x:0000CF65                 db 0FFh
.xdata$x:0000CF66                 db 0FFh
.xdata$x:0000CF67                 db 0FFh
.xdata$x:0000CF68                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000CF6C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000CF6C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000CF6D                 db    5
.xdata$x:0000CF6E                 db  93h ; ô
.xdata$x:0000CF6F                 db  19h
.xdata$x:0000CF70                 db    1
.xdata$x:0000CF71                 db    0
.xdata$x:0000CF72                 db    0
.xdata$x:0000CF73                 db    0
.xdata$x:0000CF74                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000CF78                 db    0
.xdata$x:0000CF79                 db    0
.xdata$x:0000CF7A                 db    0
.xdata$x:0000CF7B                 db    0
.xdata$x:0000CF7C                 db    0
.xdata$x:0000CF7D                 db    0
.xdata$x:0000CF7E                 db    0
.xdata$x:0000CF7F                 db    0
.xdata$x:0000CF80                 db    0
.xdata$x:0000CF81                 db    0
.xdata$x:0000CF82                 db    0
.xdata$x:0000CF83                 db    0
.xdata$x:0000CF84                 db    0
.xdata$x:0000CF85                 db    0
.xdata$x:0000CF86                 db    0
.xdata$x:0000CF87                 db    0
.xdata$x:0000CF88                 db    0
.xdata$x:0000CF89                 db    0
.xdata$x:0000CF8A                 db    0
.xdata$x:0000CF8B                 db    0
.xdata$x:0000CF8C                 db    0
.xdata$x:0000CF8D                 db    0
.xdata$x:0000CF8E                 db    0
.xdata$x:0000CF8F                 db    0
.xdata$x:0000CF8F _xdata$x        ends
.xdata$x:0000CF8F
.xdata$x:0000CF90 ; ===========================================================================
.xdata$x:0000CF90
.xdata$x:0000CF90 ; Segment type: Pure data
.xdata$x:0000CF90 ; Segment permissions: Read
.xdata$x:0000CF90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF90                 assume cs:_xdata$x
.xdata$x:0000CF90                 ;org 0CF90h
.xdata$x:0000CF90 ; COMDAT (pick associative to section at 690C)
.xdata$x:0000CF90 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000CF90                                         ; DATA XREF: .xdata$x:0000CFA0o
.xdata$x:0000CF91                 db 0FFh
.xdata$x:0000CF92                 db 0FFh
.xdata$x:0000CF93                 db 0FFh
.xdata$x:0000CF94                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000CF98 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000CF98                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000CF99                 db    5
.xdata$x:0000CF9A                 db  93h ; ô
.xdata$x:0000CF9B                 db  19h
.xdata$x:0000CF9C                 db    1
.xdata$x:0000CF9D                 db    0
.xdata$x:0000CF9E                 db    0
.xdata$x:0000CF9F                 db    0
.xdata$x:0000CFA0                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000CFA4                 db    0
.xdata$x:0000CFA5                 db    0
.xdata$x:0000CFA6                 db    0
.xdata$x:0000CFA7                 db    0
.xdata$x:0000CFA8                 db    0
.xdata$x:0000CFA9                 db    0
.xdata$x:0000CFAA                 db    0
.xdata$x:0000CFAB                 db    0
.xdata$x:0000CFAC                 db    0
.xdata$x:0000CFAD                 db    0
.xdata$x:0000CFAE                 db    0
.xdata$x:0000CFAF                 db    0
.xdata$x:0000CFB0                 db    0
.xdata$x:0000CFB1                 db    0
.xdata$x:0000CFB2                 db    0
.xdata$x:0000CFB3                 db    0
.xdata$x:0000CFB4                 db    0
.xdata$x:0000CFB5                 db    0
.xdata$x:0000CFB6                 db    0
.xdata$x:0000CFB7                 db    0
.xdata$x:0000CFB8                 db    0
.xdata$x:0000CFB9                 db    0
.xdata$x:0000CFBA                 db    0
.xdata$x:0000CFBB                 db    0
.xdata$x:0000CFBB _xdata$x        ends
.xdata$x:0000CFBB
.xdata$x:0000CFBC ; ===========================================================================
.xdata$x:0000CFBC
.xdata$x:0000CFBC ; Segment type: Pure data
.xdata$x:0000CFBC ; Segment permissions: Read
.xdata$x:0000CFBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CFBC                 assume cs:_xdata$x
.xdata$x:0000CFBC                 ;org 0CFBCh
.xdata$x:0000CFBC ; COMDAT (pick associative to section at C45C)
.xdata$x:0000CFBC __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000CFBC                                         ; DATA XREF: .xdata$x:0000CFCCo
.xdata$x:0000CFBD                 db 0FFh
.xdata$x:0000CFBE                 db 0FFh
.xdata$x:0000CFBF                 db 0FFh
.xdata$x:0000CFC0                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000CFC4 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000CFC4                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000CFC5                 db    5
.xdata$x:0000CFC6                 db  93h ; ô
.xdata$x:0000CFC7                 db  19h
.xdata$x:0000CFC8                 db    1
.xdata$x:0000CFC9                 db    0
.xdata$x:0000CFCA                 db    0
.xdata$x:0000CFCB                 db    0
.xdata$x:0000CFCC                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000CFD0                 db    0
.xdata$x:0000CFD1                 db    0
.xdata$x:0000CFD2                 db    0
.xdata$x:0000CFD3                 db    0
.xdata$x:0000CFD4                 db    0
.xdata$x:0000CFD5                 db    0
.xdata$x:0000CFD6                 db    0
.xdata$x:0000CFD7                 db    0
.xdata$x:0000CFD8                 db    0
.xdata$x:0000CFD9                 db    0
.xdata$x:0000CFDA                 db    0
.xdata$x:0000CFDB                 db    0
.xdata$x:0000CFDC                 db    0
.xdata$x:0000CFDD                 db    0
.xdata$x:0000CFDE                 db    0
.xdata$x:0000CFDF                 db    0
.xdata$x:0000CFE0                 db    0
.xdata$x:0000CFE1                 db    0
.xdata$x:0000CFE2                 db    0
.xdata$x:0000CFE3                 db    0
.xdata$x:0000CFE4                 db    0
.xdata$x:0000CFE5                 db    0
.xdata$x:0000CFE6                 db    0
.xdata$x:0000CFE7                 db    0
.xdata$x:0000CFE7 _xdata$x        ends
.xdata$x:0000CFE7
.xdata$x:0000CFE8 ; ===========================================================================
.xdata$x:0000CFE8
.xdata$x:0000CFE8 ; Segment type: Pure data
.xdata$x:0000CFE8 ; Segment permissions: Read
.xdata$x:0000CFE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CFE8                 assume cs:_xdata$x
.xdata$x:0000CFE8                 ;org 0CFE8h
.xdata$x:0000CFE8 ; COMDAT (pick associative to section at 7BA0)
.xdata$x:0000CFE8 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000CFE8                                         ; DATA XREF: .xdata$x:0000CFF8o
.xdata$x:0000CFE9                 db 0FFh
.xdata$x:0000CFEA                 db 0FFh
.xdata$x:0000CFEB                 db 0FFh
.xdata$x:0000CFEC                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000CFF0 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000CFF0                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000CFF1                 db    5
.xdata$x:0000CFF2                 db  93h ; ô
.xdata$x:0000CFF3                 db  19h
.xdata$x:0000CFF4                 db    1
.xdata$x:0000CFF5                 db    0
.xdata$x:0000CFF6                 db    0
.xdata$x:0000CFF7                 db    0
.xdata$x:0000CFF8                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000CFFC                 db    0
.xdata$x:0000CFFD                 db    0
.xdata$x:0000CFFE                 db    0
.xdata$x:0000CFFF                 db    0
.xdata$x:0000D000                 db    0
.xdata$x:0000D001                 db    0
.xdata$x:0000D002                 db    0
.xdata$x:0000D003                 db    0
.xdata$x:0000D004                 db    0
.xdata$x:0000D005                 db    0
.xdata$x:0000D006                 db    0
.xdata$x:0000D007                 db    0
.xdata$x:0000D008                 db    0
.xdata$x:0000D009                 db    0
.xdata$x:0000D00A                 db    0
.xdata$x:0000D00B                 db    0
.xdata$x:0000D00C                 db    0
.xdata$x:0000D00D                 db    0
.xdata$x:0000D00E                 db    0
.xdata$x:0000D00F                 db    0
.xdata$x:0000D010                 db    0
.xdata$x:0000D011                 db    0
.xdata$x:0000D012                 db    0
.xdata$x:0000D013                 db    0
.xdata$x:0000D013 _xdata$x        ends
.xdata$x:0000D013
.xdata$x:0000D014 ; ===========================================================================
.xdata$x:0000D014
.xdata$x:0000D014 ; Segment type: Pure data
.xdata$x:0000D014 ; Segment permissions: Read
.xdata$x:0000D014 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D014                 assume cs:_xdata$x
.xdata$x:0000D014                 ;org 0D014h
.xdata$x:0000D014 ; COMDAT (pick associative to section at 69DC)
.xdata$x:0000D014 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000D014                                         ; DATA XREF: .xdata$x:0000D024o
.xdata$x:0000D015                 db 0FFh
.xdata$x:0000D016                 db 0FFh
.xdata$x:0000D017                 db 0FFh
.xdata$x:0000D018                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000D01C __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000D01C                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000D01D                 db    5
.xdata$x:0000D01E                 db  93h ; ô
.xdata$x:0000D01F                 db  19h
.xdata$x:0000D020                 db    1
.xdata$x:0000D021                 db    0
.xdata$x:0000D022                 db    0
.xdata$x:0000D023                 db    0
.xdata$x:0000D024                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000D028                 align 20h
.xdata$x:0000D028 _xdata$x        ends
.xdata$x:0000D028
.xdata$x:0000D040 ; ===========================================================================
.xdata$x:0000D040
.xdata$x:0000D040 ; Segment type: Pure data
.xdata$x:0000D040 ; Segment permissions: Read
.xdata$x:0000D040 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D040                 assume cs:_xdata$x
.xdata$x:0000D040                 ;org 0D040h
.xdata$x:0000D040 ; COMDAT (pick associative to section at C520)
.xdata$x:0000D040 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000D040                                         ; DATA XREF: .xdata$x:0000D050o
.xdata$x:0000D041                 db 0FFh
.xdata$x:0000D042                 db 0FFh
.xdata$x:0000D043                 db 0FFh
.xdata$x:0000D044                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000D048 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000D048                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000D049                 db    5
.xdata$x:0000D04A                 db  93h ; ô
.xdata$x:0000D04B                 db  19h
.xdata$x:0000D04C                 db    1
.xdata$x:0000D04D                 db    0
.xdata$x:0000D04E                 db    0
.xdata$x:0000D04F                 db    0
.xdata$x:0000D050                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000D054                 db    0
.xdata$x:0000D055                 db    0
.xdata$x:0000D056                 db    0
.xdata$x:0000D057                 db    0
.xdata$x:0000D058                 db    0
.xdata$x:0000D059                 db    0
.xdata$x:0000D05A                 db    0
.xdata$x:0000D05B                 db    0
.xdata$x:0000D05C                 db    0
.xdata$x:0000D05D                 db    0
.xdata$x:0000D05E                 db    0
.xdata$x:0000D05F                 db    0
.xdata$x:0000D060                 db    0
.xdata$x:0000D061                 db    0
.xdata$x:0000D062                 db    0
.xdata$x:0000D063                 db    0
.xdata$x:0000D064                 db    0
.xdata$x:0000D065                 db    0
.xdata$x:0000D066                 db    0
.xdata$x:0000D067                 db    0
.xdata$x:0000D068                 db    0
.xdata$x:0000D069                 db    0
.xdata$x:0000D06A                 db    0
.xdata$x:0000D06B                 db    0
.xdata$x:0000D06B _xdata$x        ends
.xdata$x:0000D06B
.xdata$x:0000D06C ; ===========================================================================
.xdata$x:0000D06C
.xdata$x:0000D06C ; Segment type: Pure data
.xdata$x:0000D06C ; Segment permissions: Read
.xdata$x:0000D06C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D06C                 assume cs:_xdata$x
.xdata$x:0000D06C                 ;org 0D06Ch
.xdata$x:0000D06C ; COMDAT (pick associative to section at 7C94)
.xdata$x:0000D06C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000D06C                                         ; DATA XREF: .xdata$x:0000D07Co
.xdata$x:0000D06D                 db 0FFh
.xdata$x:0000D06E                 db 0FFh
.xdata$x:0000D06F                 db 0FFh
.xdata$x:0000D070                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000D074 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000D074                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000D075                 db    5
.xdata$x:0000D076                 db  93h ; ô
.xdata$x:0000D077                 db  19h
.xdata$x:0000D078                 db    1
.xdata$x:0000D079                 db    0
.xdata$x:0000D07A                 db    0
.xdata$x:0000D07B                 db    0
.xdata$x:0000D07C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000D080                 db    0
.xdata$x:0000D081                 db    0
.xdata$x:0000D082                 db    0
.xdata$x:0000D083                 db    0
.xdata$x:0000D084                 db    0
.xdata$x:0000D085                 db    0
.xdata$x:0000D086                 db    0
.xdata$x:0000D087                 db    0
.xdata$x:0000D088                 db    0
.xdata$x:0000D089                 db    0
.xdata$x:0000D08A                 db    0
.xdata$x:0000D08B                 db    0
.xdata$x:0000D08C                 db    0
.xdata$x:0000D08D                 db    0
.xdata$x:0000D08E                 db    0
.xdata$x:0000D08F                 db    0
.xdata$x:0000D090                 db    0
.xdata$x:0000D091                 db    0
.xdata$x:0000D092                 db    0
.xdata$x:0000D093                 db    0
.xdata$x:0000D094                 db    0
.xdata$x:0000D095                 db    0
.xdata$x:0000D096                 db    0
.xdata$x:0000D097                 db    0
.xdata$x:0000D097 _xdata$x        ends
.xdata$x:0000D097
.xdata$x:0000D098 ; ===========================================================================
.xdata$x:0000D098
.xdata$x:0000D098 ; Segment type: Pure data
.xdata$x:0000D098 ; Segment permissions: Read
.xdata$x:0000D098 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D098                 assume cs:_xdata$x
.xdata$x:0000D098                 ;org 0D098h
.xdata$x:0000D098 ; COMDAT (pick associative to section at 5294)
.xdata$x:0000D098 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D098                                         ; DATA XREF: .xdata$x:0000D0A8o
.xdata$x:0000D099                 db 0FFh
.xdata$x:0000D09A                 db 0FFh
.xdata$x:0000D09B                 db 0FFh
.xdata$x:0000D09C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000D0A0 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D0A0                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000D0A1                 db    5
.xdata$x:0000D0A2                 db  93h ; ô
.xdata$x:0000D0A3                 db  19h
.xdata$x:0000D0A4                 db    1
.xdata$x:0000D0A5                 db    0
.xdata$x:0000D0A6                 db    0
.xdata$x:0000D0A7                 db    0
.xdata$x:0000D0A8                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000D0AC                 db    0
.xdata$x:0000D0AD                 db    0
.xdata$x:0000D0AE                 db    0
.xdata$x:0000D0AF                 db    0
.xdata$x:0000D0B0                 db    0
.xdata$x:0000D0B1                 db    0
.xdata$x:0000D0B2                 db    0
.xdata$x:0000D0B3                 db    0
.xdata$x:0000D0B4                 db    0
.xdata$x:0000D0B5                 db    0
.xdata$x:0000D0B6                 db    0
.xdata$x:0000D0B7                 db    0
.xdata$x:0000D0B8                 db    0
.xdata$x:0000D0B9                 db    0
.xdata$x:0000D0BA                 db    0
.xdata$x:0000D0BB                 db    0
.xdata$x:0000D0BC                 db    0
.xdata$x:0000D0BD                 db    0
.xdata$x:0000D0BE                 db    0
.xdata$x:0000D0BF                 db    0
.xdata$x:0000D0C0                 db    0
.xdata$x:0000D0C1                 db    0
.xdata$x:0000D0C2                 db    0
.xdata$x:0000D0C3                 db    0
.xdata$x:0000D0C3 _xdata$x        ends
.xdata$x:0000D0C3
.xdata$x:0000D0C4 ; ===========================================================================
.xdata$x:0000D0C4
.xdata$x:0000D0C4 ; Segment type: Pure data
.xdata$x:0000D0C4 ; Segment permissions: Read
.xdata$x:0000D0C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D0C4                 assume cs:_xdata$x
.xdata$x:0000D0C4                 ;org 0D0C4h
.xdata$x:0000D0C4 ; COMDAT (pick associative to section at 6E7C)
.xdata$x:0000D0C4 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D0C4                                         ; DATA XREF: .xdata$x:0000D0D4o
.xdata$x:0000D0C5                 db 0FFh
.xdata$x:0000D0C6                 db 0FFh
.xdata$x:0000D0C7                 db 0FFh
.xdata$x:0000D0C8                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000D0CC __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D0CC                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000D0CD                 db    5
.xdata$x:0000D0CE                 db  93h ; ô
.xdata$x:0000D0CF                 db  19h
.xdata$x:0000D0D0                 db    1
.xdata$x:0000D0D1                 db    0
.xdata$x:0000D0D2                 db    0
.xdata$x:0000D0D3                 db    0
.xdata$x:0000D0D4                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000D0D8                 db    0
.xdata$x:0000D0D9                 db    0
.xdata$x:0000D0DA                 db    0
.xdata$x:0000D0DB                 db    0
.xdata$x:0000D0DC                 db    0
.xdata$x:0000D0DD                 db    0
.xdata$x:0000D0DE                 db    0
.xdata$x:0000D0DF                 db    0
.xdata$x:0000D0E0                 db    0
.xdata$x:0000D0E1                 db    0
.xdata$x:0000D0E2                 db    0
.xdata$x:0000D0E3                 db    0
.xdata$x:0000D0E4                 db    0
.xdata$x:0000D0E5                 db    0
.xdata$x:0000D0E6                 db    0
.xdata$x:0000D0E7                 db    0
.xdata$x:0000D0E8                 db    0
.xdata$x:0000D0E9                 db    0
.xdata$x:0000D0EA                 db    0
.xdata$x:0000D0EB                 db    0
.xdata$x:0000D0EC                 db    0
.xdata$x:0000D0ED                 db    0
.xdata$x:0000D0EE                 db    0
.xdata$x:0000D0EF                 db    0
.xdata$x:0000D0EF _xdata$x        ends
.xdata$x:0000D0EF
.xdata$x:0000D0F0 ; ===========================================================================
.xdata$x:0000D0F0
.xdata$x:0000D0F0 ; Segment type: Pure data
.xdata$x:0000D0F0 ; Segment permissions: Read
.xdata$x:0000D0F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D0F0                 assume cs:_xdata$x
.xdata$x:0000D0F0                 ;org 0D0F0h
.xdata$x:0000D0F0 ; COMDAT (pick associative to section at 5190)
.xdata$x:0000D0F0 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000D0F0                                         ; DATA XREF: .xdata$x:0000D100o
.xdata$x:0000D0F1                 db 0FFh
.xdata$x:0000D0F2                 db 0FFh
.xdata$x:0000D0F3                 db 0FFh
.xdata$x:0000D0F4                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000D0F8 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000D0F8                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000D0F9                 db    5
.xdata$x:0000D0FA                 db  93h ; ô
.xdata$x:0000D0FB                 db  19h
.xdata$x:0000D0FC                 db    1
.xdata$x:0000D0FD                 db    0
.xdata$x:0000D0FE                 db    0
.xdata$x:0000D0FF                 db    0
.xdata$x:0000D100                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000D104                 db    0
.xdata$x:0000D105                 db    0
.xdata$x:0000D106                 db    0
.xdata$x:0000D107                 db    0
.xdata$x:0000D108                 db    0
.xdata$x:0000D109                 db    0
.xdata$x:0000D10A                 db    0
.xdata$x:0000D10B                 db    0
.xdata$x:0000D10C                 db    0
.xdata$x:0000D10D                 db    0
.xdata$x:0000D10E                 db    0
.xdata$x:0000D10F                 db    0
.xdata$x:0000D110                 db    0
.xdata$x:0000D111                 db    0
.xdata$x:0000D112                 db    0
.xdata$x:0000D113                 db    0
.xdata$x:0000D114                 db    0
.xdata$x:0000D115                 db    0
.xdata$x:0000D116                 db    0
.xdata$x:0000D117                 db    0
.xdata$x:0000D118                 db    0
.xdata$x:0000D119                 db    0
.xdata$x:0000D11A                 db    0
.xdata$x:0000D11B                 db    0
.xdata$x:0000D11B _xdata$x        ends
.xdata$x:0000D11B
.xdata$x:0000D11C ; ===========================================================================
.xdata$x:0000D11C
.xdata$x:0000D11C ; Segment type: Pure data
.xdata$x:0000D11C ; Segment permissions: Read
.xdata$x:0000D11C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D11C                 assume cs:_xdata$x
.xdata$x:0000D11C                 ;org 0D11Ch
.xdata$x:0000D11C ; COMDAT (pick associative to section at 6D94)
.xdata$x:0000D11C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D11C                                         ; DATA XREF: .xdata$x:0000D12Co
.xdata$x:0000D11D                 db 0FFh
.xdata$x:0000D11E                 db 0FFh
.xdata$x:0000D11F                 db 0FFh
.xdata$x:0000D120                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D124 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D124                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D125                 db    5
.xdata$x:0000D126                 db  93h ; ô
.xdata$x:0000D127                 db  19h
.xdata$x:0000D128                 db    1
.xdata$x:0000D129                 db    0
.xdata$x:0000D12A                 db    0
.xdata$x:0000D12B                 db    0
.xdata$x:0000D12C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D130                 db    0
.xdata$x:0000D131                 db    0
.xdata$x:0000D132                 db    0
.xdata$x:0000D133                 db    0
.xdata$x:0000D134                 db    0
.xdata$x:0000D135                 db    0
.xdata$x:0000D136                 db    0
.xdata$x:0000D137                 db    0
.xdata$x:0000D138                 db    0
.xdata$x:0000D139                 db    0
.xdata$x:0000D13A                 db    0
.xdata$x:0000D13B                 db    0
.xdata$x:0000D13C                 db    0
.xdata$x:0000D13D                 db    0
.xdata$x:0000D13E                 db    0
.xdata$x:0000D13F                 db    0
.xdata$x:0000D140                 db    0
.xdata$x:0000D141                 db    0
.xdata$x:0000D142                 db    0
.xdata$x:0000D143                 db    0
.xdata$x:0000D144                 db    0
.xdata$x:0000D145                 db    0
.xdata$x:0000D146                 db    0
.xdata$x:0000D147                 db    0
.xdata$x:0000D147 _xdata$x        ends
.xdata$x:0000D147
.xdata$x:0000D148 ; ===========================================================================
.xdata$x:0000D148
.xdata$x:0000D148 ; Segment type: Pure data
.xdata$x:0000D148 ; Segment permissions: Read
.xdata$x:0000D148 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D148                 assume cs:_xdata$x
.xdata$x:0000D148                 ;org 0D148h
.xdata$x:0000D148 ; COMDAT (pick associative to section at 5EC4)
.xdata$x:0000D148 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D148                                         ; DATA XREF: .xdata$x:0000D158o
.xdata$x:0000D149                 db 0FFh
.xdata$x:0000D14A                 db 0FFh
.xdata$x:0000D14B                 db 0FFh
.xdata$x:0000D14C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D150 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D150                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D151                 db    5
.xdata$x:0000D152                 db  93h ; ô
.xdata$x:0000D153                 db  19h
.xdata$x:0000D154                 db    1
.xdata$x:0000D155                 db    0
.xdata$x:0000D156                 db    0
.xdata$x:0000D157                 db    0
.xdata$x:0000D158                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:0000D15C                 db    0
.xdata$x:0000D15D                 db    0
.xdata$x:0000D15E                 db    0
.xdata$x:0000D15F                 db    0
.xdata$x:0000D160                 db    0
.xdata$x:0000D161                 db    0
.xdata$x:0000D162                 db    0
.xdata$x:0000D163                 db    0
.xdata$x:0000D164                 db    0
.xdata$x:0000D165                 db    0
.xdata$x:0000D166                 db    0
.xdata$x:0000D167                 db    0
.xdata$x:0000D168                 db    0
.xdata$x:0000D169                 db    0
.xdata$x:0000D16A                 db    0
.xdata$x:0000D16B                 db    0
.xdata$x:0000D16C                 db    0
.xdata$x:0000D16D                 db    0
.xdata$x:0000D16E                 db    0
.xdata$x:0000D16F                 db    0
.xdata$x:0000D170                 db    0
.xdata$x:0000D171                 db    0
.xdata$x:0000D172                 db    0
.xdata$x:0000D173                 db    0
.xdata$x:0000D173 _xdata$x        ends
.xdata$x:0000D173
.xdata$x:0000D174 ; ===========================================================================
.xdata$x:0000D174
.xdata$x:0000D174 ; Segment type: Pure data
.xdata$x:0000D174 ; Segment permissions: Read
.xdata$x:0000D174 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D174                 assume cs:_xdata$x
.xdata$x:0000D174                 ;org 0D174h
.xdata$x:0000D174 ; COMDAT (pick associative to section at 74C0)
.xdata$x:0000D174 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D174                                         ; DATA XREF: .xdata$x:0000D184o
.xdata$x:0000D175                 db 0FFh
.xdata$x:0000D176                 db 0FFh
.xdata$x:0000D177                 db 0FFh
.xdata$x:0000D178                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000D17C __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D17C                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000D17D                 db    5
.xdata$x:0000D17E                 db  93h ; ô
.xdata$x:0000D17F                 db  19h
.xdata$x:0000D180                 db    1
.xdata$x:0000D181                 db    0
.xdata$x:0000D182                 db    0
.xdata$x:0000D183                 db    0
.xdata$x:0000D184                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000D188                 align 20h
.xdata$x:0000D188 _xdata$x        ends
.xdata$x:0000D188
.xdata$x:0000D1A0 ; ===========================================================================
.xdata$x:0000D1A0
.xdata$x:0000D1A0 ; Segment type: Pure data
.xdata$x:0000D1A0 ; Segment permissions: Read
.xdata$x:0000D1A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D1A0                 assume cs:_xdata$x
.xdata$x:0000D1A0                 ;org 0D1A0h
.xdata$x:0000D1A0 ; COMDAT (pick associative to section at 9828)
.xdata$x:0000D1A0 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000D1A0                                         ; DATA XREF: .xdata$x:0000D228o
.xdata$x:0000D1A1                 db    0
.xdata$x:0000D1A2                 db    0
.xdata$x:0000D1A3                 db    0
.xdata$x:0000D1A4                 db    0
.xdata$x:0000D1A5                 db    0
.xdata$x:0000D1A6                 db    0
.xdata$x:0000D1A7                 db    0
.xdata$x:0000D1A8                 db    0
.xdata$x:0000D1A9                 db    0
.xdata$x:0000D1AA                 db    0
.xdata$x:0000D1AB                 db    0
.xdata$x:0000D1AC                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:0000D1B0 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000D1B0                                         ; DATA XREF: .xdata$x:0000D214o
.xdata$x:0000D1B1                 db    0
.xdata$x:0000D1B2                 db    0
.xdata$x:0000D1B3                 db    0
.xdata$x:0000D1B4                 db    0
.xdata$x:0000D1B5                 db    0
.xdata$x:0000D1B6                 db    0
.xdata$x:0000D1B7                 db    0
.xdata$x:0000D1B8                 db    0
.xdata$x:0000D1B9                 db    0
.xdata$x:0000D1BA                 db    0
.xdata$x:0000D1BB                 db    0
.xdata$x:0000D1BC                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:0000D1C0 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000D1C0                                         ; DATA XREF: .xdata$x:0000D1E8o
.xdata$x:0000D1C1                 db 0FFh
.xdata$x:0000D1C2                 db 0FFh
.xdata$x:0000D1C3                 db 0FFh
.xdata$x:0000D1C4                 db    0
.xdata$x:0000D1C5                 db    0
.xdata$x:0000D1C6                 db    0
.xdata$x:0000D1C7                 db    0
.xdata$x:0000D1C8                 db 0FFh
.xdata$x:0000D1C9                 db 0FFh
.xdata$x:0000D1CA                 db 0FFh
.xdata$x:0000D1CB                 db 0FFh
.xdata$x:0000D1CC                 db    0
.xdata$x:0000D1CD                 db    0
.xdata$x:0000D1CE                 db    0
.xdata$x:0000D1CF                 db    0
.xdata$x:0000D1D0                 db    1
.xdata$x:0000D1D1                 db    0
.xdata$x:0000D1D2                 db    0
.xdata$x:0000D1D3                 db    0
.xdata$x:0000D1D4                 db    0
.xdata$x:0000D1D5                 db    0
.xdata$x:0000D1D6                 db    0
.xdata$x:0000D1D7                 db    0
.xdata$x:0000D1D8                 db    1
.xdata$x:0000D1D9                 db    0
.xdata$x:0000D1DA                 db    0
.xdata$x:0000D1DB                 db    0
.xdata$x:0000D1DC                 db    0
.xdata$x:0000D1DD                 db    0
.xdata$x:0000D1DE                 db    0
.xdata$x:0000D1DF                 db    0
.xdata$x:0000D1E0 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000D1E0                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:0000D1E1                 db    5
.xdata$x:0000D1E2                 db  93h ; ô
.xdata$x:0000D1E3                 db  19h
.xdata$x:0000D1E4                 db    4
.xdata$x:0000D1E5                 db    0
.xdata$x:0000D1E6                 db    0
.xdata$x:0000D1E7                 db    0
.xdata$x:0000D1E8                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000D1EC                 db    2
.xdata$x:0000D1ED                 db    0
.xdata$x:0000D1EE                 db    0
.xdata$x:0000D1EF                 db    0
.xdata$x:0000D1F0                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000D1F4                 db    0
.xdata$x:0000D1F5                 db    0
.xdata$x:0000D1F6                 db    0
.xdata$x:0000D1F7                 db    0
.xdata$x:0000D1F8                 db    0
.xdata$x:0000D1F9                 db    0
.xdata$x:0000D1FA                 db    0
.xdata$x:0000D1FB                 db    0
.xdata$x:0000D1FC                 db    0
.xdata$x:0000D1FD                 db    0
.xdata$x:0000D1FE                 db    0
.xdata$x:0000D1FF                 db    0
.xdata$x:0000D200                 db    0
.xdata$x:0000D201                 db    0
.xdata$x:0000D202                 db    0
.xdata$x:0000D203                 db    0
.xdata$x:0000D204 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000D204                                         ; DATA XREF: .xdata$x:0000D1F0o
.xdata$x:0000D205                 db    0
.xdata$x:0000D206                 db    0
.xdata$x:0000D207                 db    0
.xdata$x:0000D208                 db    2
.xdata$x:0000D209                 db    0
.xdata$x:0000D20A                 db    0
.xdata$x:0000D20B                 db    0
.xdata$x:0000D20C                 db    3
.xdata$x:0000D20D                 db    0
.xdata$x:0000D20E                 db    0
.xdata$x:0000D20F                 db    0
.xdata$x:0000D210                 db    1
.xdata$x:0000D211                 db    0
.xdata$x:0000D212                 db    0
.xdata$x:0000D213                 db    0
.xdata$x:0000D214                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000D218                 align 10h
.xdata$x:0000D220                 db    3
.xdata$x:0000D221                 db    0
.xdata$x:0000D222                 db    0
.xdata$x:0000D223                 db    0
.xdata$x:0000D224                 db    1
.xdata$x:0000D225                 db    0
.xdata$x:0000D226                 db    0
.xdata$x:0000D227                 db    0
.xdata$x:0000D228                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000D228 _xdata$x        ends
.xdata$x:0000D228
.xdata$x:0000D22C ; ===========================================================================
.xdata$x:0000D22C
.xdata$x:0000D22C ; Segment type: Pure data
.xdata$x:0000D22C ; Segment permissions: Read
.xdata$x:0000D22C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D22C                 assume cs:_xdata$x
.xdata$x:0000D22C                 ;org 0D22Ch
.xdata$x:0000D22C ; COMDAT (pick associative to section at 6638)
.xdata$x:0000D22C __unwindtable$??0Shortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000D22C                                         ; DATA XREF: .xdata$x:0000D23Co
.xdata$x:0000D22D                 db 0FFh
.xdata$x:0000D22E                 db 0FFh
.xdata$x:0000D22F                 db 0FFh
.xdata$x:0000D230                 dd offset __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0
.xdata$x:0000D234 __ehfuncinfo$??0Shortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000D234                                         ; DATA XREF: __ehhandler$??0Shortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000D235                 db    5
.xdata$x:0000D236                 db  93h ; ô
.xdata$x:0000D237                 db  19h
.xdata$x:0000D238                 db    1
.xdata$x:0000D239                 db    0
.xdata$x:0000D23A                 db    0
.xdata$x:0000D23B                 db    0
.xdata$x:0000D23C                 dd offset __unwindtable$??0Shortcut@@QAE@ABV0@@Z
.xdata$x:0000D240                 db    0
.xdata$x:0000D241                 db    0
.xdata$x:0000D242                 db    0
.xdata$x:0000D243                 db    0
.xdata$x:0000D244                 db    0
.xdata$x:0000D245                 db    0
.xdata$x:0000D246                 db    0
.xdata$x:0000D247                 db    0
.xdata$x:0000D248                 db    0
.xdata$x:0000D249                 db    0
.xdata$x:0000D24A                 db    0
.xdata$x:0000D24B                 db    0
.xdata$x:0000D24C                 db    0
.xdata$x:0000D24D                 db    0
.xdata$x:0000D24E                 db    0
.xdata$x:0000D24F                 db    0
.xdata$x:0000D250                 db    0
.xdata$x:0000D251                 db    0
.xdata$x:0000D252                 db    0
.xdata$x:0000D253                 db    0
.xdata$x:0000D254                 db    0
.xdata$x:0000D255                 db    0
.xdata$x:0000D256                 db    0
.xdata$x:0000D257                 db    0
.xdata$x:0000D257 _xdata$x        ends
.xdata$x:0000D257
.xdata$x:0000D258 ; ===========================================================================
.xdata$x:0000D258
.xdata$x:0000D258 ; Segment type: Pure data
.xdata$x:0000D258 ; Segment permissions: Read
.xdata$x:0000D258 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D258                 assume cs:_xdata$x
.xdata$x:0000D258                 ;org 0D258h
.xdata$x:0000D258 ; COMDAT (pick associative to section at 7964)
.xdata$x:0000D258 __unwindtable$??1Shortcut@@UAE@XZ db 0FFh ; DATA XREF: .xdata$x:0000D268o
.xdata$x:0000D259                 db 0FFh
.xdata$x:0000D25A                 db 0FFh
.xdata$x:0000D25B                 db 0FFh
.xdata$x:0000D25C                 dd offset __unwindfunclet$??1Shortcut@@UAE@XZ$0
.xdata$x:0000D260 __ehfuncinfo$??1Shortcut@@UAE@XZ db  22h ; "
.xdata$x:0000D260                                         ; DATA XREF: __ehhandler$??1Shortcut@@UAE@XZ+11o
.xdata$x:0000D261                 db    5
.xdata$x:0000D262                 db  93h ; ô
.xdata$x:0000D263                 db  19h
.xdata$x:0000D264                 db    1
.xdata$x:0000D265                 db    0
.xdata$x:0000D266                 db    0
.xdata$x:0000D267                 db    0
.xdata$x:0000D268                 dd offset __unwindtable$??1Shortcut@@UAE@XZ
.xdata$x:0000D26C                 db    0
.xdata$x:0000D26D                 db    0
.xdata$x:0000D26E                 db    0
.xdata$x:0000D26F                 db    0
.xdata$x:0000D270                 db    0
.xdata$x:0000D271                 db    0
.xdata$x:0000D272                 db    0
.xdata$x:0000D273                 db    0
.xdata$x:0000D274                 db    0
.xdata$x:0000D275                 db    0
.xdata$x:0000D276                 db    0
.xdata$x:0000D277                 db    0
.xdata$x:0000D278                 db    0
.xdata$x:0000D279                 db    0
.xdata$x:0000D27A                 db    0
.xdata$x:0000D27B                 db    0
.xdata$x:0000D27C                 db    0
.xdata$x:0000D27D                 db    0
.xdata$x:0000D27E                 db    0
.xdata$x:0000D27F                 db    0
.xdata$x:0000D280                 db    0
.xdata$x:0000D281                 db    0
.xdata$x:0000D282                 db    0
.xdata$x:0000D283                 db    0
.xdata$x:0000D283 _xdata$x        ends
.xdata$x:0000D283
.xdata$x:0000D284 ; ===========================================================================
.xdata$x:0000D284
.xdata$x:0000D284 ; Segment type: Pure data
.xdata$x:0000D284 ; Segment permissions: Read
.xdata$x:0000D284 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D284                 assume cs:_xdata$x
.xdata$x:0000D284                 ;org 0D284h
.xdata$x:0000D284 ; COMDAT (pick associative to section at 76A4)
.xdata$x:0000D284 __unwindtable$??1CommandShortcut@@UAE@XZ db 0FFh
.xdata$x:0000D284                                         ; DATA XREF: .xdata$x:0000D294o
.xdata$x:0000D285                 db 0FFh
.xdata$x:0000D286                 db 0FFh
.xdata$x:0000D287                 db 0FFh
.xdata$x:0000D288                 dd offset __unwindfunclet$??1CommandShortcut@@UAE@XZ$0
.xdata$x:0000D28C __ehfuncinfo$??1CommandShortcut@@UAE@XZ db  22h ; "
.xdata$x:0000D28C                                         ; DATA XREF: __ehhandler$??1CommandShortcut@@UAE@XZ+11o
.xdata$x:0000D28D                 db    5
.xdata$x:0000D28E                 db  93h ; ô
.xdata$x:0000D28F                 db  19h
.xdata$x:0000D290                 db    1
.xdata$x:0000D291                 db    0
.xdata$x:0000D292                 db    0
.xdata$x:0000D293                 db    0
.xdata$x:0000D294                 dd offset __unwindtable$??1CommandShortcut@@UAE@XZ
.xdata$x:0000D298                 db    0
.xdata$x:0000D299                 db    0
.xdata$x:0000D29A                 db    0
.xdata$x:0000D29B                 db    0
.xdata$x:0000D29C                 db    0
.xdata$x:0000D29D                 db    0
.xdata$x:0000D29E                 db    0
.xdata$x:0000D29F                 db    0
.xdata$x:0000D2A0                 db    0
.xdata$x:0000D2A1                 db    0
.xdata$x:0000D2A2                 db    0
.xdata$x:0000D2A3                 db    0
.xdata$x:0000D2A4                 db    0
.xdata$x:0000D2A5                 db    0
.xdata$x:0000D2A6                 db    0
.xdata$x:0000D2A7                 db    0
.xdata$x:0000D2A8                 db    0
.xdata$x:0000D2A9                 db    0
.xdata$x:0000D2AA                 db    0
.xdata$x:0000D2AB                 db    0
.xdata$x:0000D2AC                 db    0
.xdata$x:0000D2AD                 db    0
.xdata$x:0000D2AE                 db    0
.xdata$x:0000D2AF                 db    0
.xdata$x:0000D2AF _xdata$x        ends
.xdata$x:0000D2AF
.xdata$x:0000D2B0 ; ===========================================================================
.xdata$x:0000D2B0
.xdata$x:0000D2B0 ; Segment type: Pure data
.xdata$x:0000D2B0 ; Segment permissions: Read
.xdata$x:0000D2B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D2B0                 assume cs:_xdata$x
.xdata$x:0000D2B0                 ;org 0D2B0h
.xdata$x:0000D2B0 ; COMDAT (pick associative to section at 628C)
.xdata$x:0000D2B0 __unwindtable$??0CommandShortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000D2B0                                         ; DATA XREF: .xdata$x:0000D2C0o
.xdata$x:0000D2B1                 db 0FFh
.xdata$x:0000D2B2                 db 0FFh
.xdata$x:0000D2B3                 db 0FFh
.xdata$x:0000D2B4                 dd offset __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0
.xdata$x:0000D2B8 __ehfuncinfo$??0CommandShortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000D2B8                                         ; DATA XREF: __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000D2B9                 db    5
.xdata$x:0000D2BA                 db  93h ; ô
.xdata$x:0000D2BB                 db  19h
.xdata$x:0000D2BC                 db    1
.xdata$x:0000D2BD                 db    0
.xdata$x:0000D2BE                 db    0
.xdata$x:0000D2BF                 db    0
.xdata$x:0000D2C0                 dd offset __unwindtable$??0CommandShortcut@@QAE@ABV0@@Z
.xdata$x:0000D2C4                 db    0
.xdata$x:0000D2C5                 db    0
.xdata$x:0000D2C6                 db    0
.xdata$x:0000D2C7                 db    0
.xdata$x:0000D2C8                 db    0
.xdata$x:0000D2C9                 db    0
.xdata$x:0000D2CA                 db    0
.xdata$x:0000D2CB                 db    0
.xdata$x:0000D2CC                 db    0
.xdata$x:0000D2CD                 db    0
.xdata$x:0000D2CE                 db    0
.xdata$x:0000D2CF                 db    0
.xdata$x:0000D2D0                 db    0
.xdata$x:0000D2D1                 db    0
.xdata$x:0000D2D2                 db    0
.xdata$x:0000D2D3                 db    0
.xdata$x:0000D2D4                 db    0
.xdata$x:0000D2D5                 db    0
.xdata$x:0000D2D6                 db    0
.xdata$x:0000D2D7                 db    0
.xdata$x:0000D2D8                 db    0
.xdata$x:0000D2D9                 db    0
.xdata$x:0000D2DA                 db    0
.xdata$x:0000D2DB                 db    0
.xdata$x:0000D2DB _xdata$x        ends
.xdata$x:0000D2DB
.xdata$x:0000D2DC ; ===========================================================================
.xdata$x:0000D2DC
.xdata$x:0000D2DC ; Segment type: Pure data
.xdata$x:0000D2DC ; Segment permissions: Read
.xdata$x:0000D2DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D2DC                 assume cs:_xdata$x
.xdata$x:0000D2DC                 ;org 0D2DCh
.xdata$x:0000D2DC ; COMDAT (pick associative to section at 5AB8)
.xdata$x:0000D2DC __unwindtable$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D2DC                                         ; DATA XREF: .xdata$x:0000D2ECo
.xdata$x:0000D2DD                 db 0FFh
.xdata$x:0000D2DE                 db 0FFh
.xdata$x:0000D2DF                 db 0FFh
.xdata$x:0000D2E0                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D2E4 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D2E4                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D2E5                 db    5
.xdata$x:0000D2E6                 db  93h ; ô
.xdata$x:0000D2E7                 db  19h
.xdata$x:0000D2E8                 db    1
.xdata$x:0000D2E9                 db    0
.xdata$x:0000D2EA                 db    0
.xdata$x:0000D2EB                 db    0
.xdata$x:0000D2EC                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.xdata$x:0000D2F0                 db    0
.xdata$x:0000D2F1                 db    0
.xdata$x:0000D2F2                 db    0
.xdata$x:0000D2F3                 db    0
.xdata$x:0000D2F4                 db    0
.xdata$x:0000D2F5                 db    0
.xdata$x:0000D2F6                 db    0
.xdata$x:0000D2F7                 db    0
.xdata$x:0000D2F8                 db    0
.xdata$x:0000D2F9                 db    0
.xdata$x:0000D2FA                 db    0
.xdata$x:0000D2FB                 db    0
.xdata$x:0000D2FC                 db    0
.xdata$x:0000D2FD                 db    0
.xdata$x:0000D2FE                 db    0
.xdata$x:0000D2FF                 db    0
.xdata$x:0000D300                 db    0
.xdata$x:0000D301                 db    0
.xdata$x:0000D302                 db    0
.xdata$x:0000D303                 db    0
.xdata$x:0000D304                 db    0
.xdata$x:0000D305                 db    0
.xdata$x:0000D306                 db    0
.xdata$x:0000D307                 db    0
.xdata$x:0000D307 _xdata$x        ends
.xdata$x:0000D307
.xdata$x:0000D308 ; ===========================================================================
.xdata$x:0000D308
.xdata$x:0000D308 ; Segment type: Pure data
.xdata$x:0000D308 ; Segment permissions: Read
.xdata$x:0000D308 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D308                 assume cs:_xdata$x
.xdata$x:0000D308                 ;org 0D308h
.xdata$x:0000D308 ; COMDAT (pick associative to section at 72F4)
.xdata$x:0000D308 __unwindtable$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D308                                         ; DATA XREF: .xdata$x:0000D318o
.xdata$x:0000D309                 db 0FFh
.xdata$x:0000D30A                 db 0FFh
.xdata$x:0000D30B                 db 0FFh
.xdata$x:0000D30C                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D310 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D310                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D311                 db    5
.xdata$x:0000D312                 db  93h ; ô
.xdata$x:0000D313                 db  19h
.xdata$x:0000D314                 db    1
.xdata$x:0000D315                 db    0
.xdata$x:0000D316                 db    0
.xdata$x:0000D317                 db    0
.xdata$x:0000D318                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@QAE@XZ
.xdata$x:0000D31C                 db    0
.xdata$x:0000D31D                 db    0
.xdata$x:0000D31E                 db    0
.xdata$x:0000D31F                 db    0
.xdata$x:0000D320                 db    0
.xdata$x:0000D321                 db    0
.xdata$x:0000D322                 db    0
.xdata$x:0000D323                 db    0
.xdata$x:0000D324                 db    0
.xdata$x:0000D325                 db    0
.xdata$x:0000D326                 db    0
.xdata$x:0000D327                 db    0
.xdata$x:0000D328                 db    0
.xdata$x:0000D329                 db    0
.xdata$x:0000D32A                 db    0
.xdata$x:0000D32B                 db    0
.xdata$x:0000D32C                 db    0
.xdata$x:0000D32D                 db    0
.xdata$x:0000D32E                 db    0
.xdata$x:0000D32F                 db    0
.xdata$x:0000D330                 db    0
.xdata$x:0000D331                 db    0
.xdata$x:0000D332                 db    0
.xdata$x:0000D333                 db    0
.xdata$x:0000D333 _xdata$x        ends
.xdata$x:0000D333
.xdata$x:0000D334 ; ===========================================================================
.xdata$x:0000D334
.xdata$x:0000D334 ; Segment type: Pure data
.xdata$x:0000D334 ; Segment permissions: Read
.xdata$x:0000D334 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D334                 assume cs:_xdata$x
.xdata$x:0000D334                 ;org 0D334h
.xdata$x:0000D334 ; COMDAT (pick associative to section at 531C)
.xdata$x:0000D334 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z db 0FFh
.xdata$x:0000D334                                         ; DATA XREF: .xdata$x:0000D344o
.xdata$x:0000D335                 db 0FFh
.xdata$x:0000D336                 db 0FFh
.xdata$x:0000D337                 db 0FFh
.xdata$x:0000D338                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z$0
.xdata$x:0000D33C __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z db  22h ; "
.xdata$x:0000D33C                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z+11o
.xdata$x:0000D33D                 db    5
.xdata$x:0000D33E                 db  93h ; ô
.xdata$x:0000D33F                 db  19h
.xdata$x:0000D340                 db    1
.xdata$x:0000D341                 db    0
.xdata$x:0000D342                 db    0
.xdata$x:0000D343                 db    0
.xdata$x:0000D344                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@ABV?$allocator@UKeyCombo@@@1@@Z
.xdata$x:0000D348                 align 20h
.xdata$x:0000D348 _xdata$x        ends
.xdata$x:0000D348
.xdata$x:0000D360 ; ===========================================================================
.xdata$x:0000D360
.xdata$x:0000D360 ; Segment type: Pure data
.xdata$x:0000D360 ; Segment permissions: Read
.xdata$x:0000D360 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D360                 assume cs:_xdata$x
.xdata$x:0000D360                 ;org 0D360h
.xdata$x:0000D360 ; COMDAT (pick associative to section at 6EEC)
.xdata$x:0000D360 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D360                                         ; DATA XREF: .xdata$x:0000D370o
.xdata$x:0000D361                 db 0FFh
.xdata$x:0000D362                 db 0FFh
.xdata$x:0000D363                 db 0FFh
.xdata$x:0000D364                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D368 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D368                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D369                 db    5
.xdata$x:0000D36A                 db  93h ; ô
.xdata$x:0000D36B                 db  19h
.xdata$x:0000D36C                 db    1
.xdata$x:0000D36D                 db    0
.xdata$x:0000D36E                 db    0
.xdata$x:0000D36F                 db    0
.xdata$x:0000D370                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D374                 db    0
.xdata$x:0000D375                 db    0
.xdata$x:0000D376                 db    0
.xdata$x:0000D377                 db    0
.xdata$x:0000D378                 db    0
.xdata$x:0000D379                 db    0
.xdata$x:0000D37A                 db    0
.xdata$x:0000D37B                 db    0
.xdata$x:0000D37C                 db    0
.xdata$x:0000D37D                 db    0
.xdata$x:0000D37E                 db    0
.xdata$x:0000D37F                 db    0
.xdata$x:0000D380                 db    0
.xdata$x:0000D381                 db    0
.xdata$x:0000D382                 db    0
.xdata$x:0000D383                 db    0
.xdata$x:0000D384                 db    0
.xdata$x:0000D385                 db    0
.xdata$x:0000D386                 db    0
.xdata$x:0000D387                 db    0
.xdata$x:0000D388                 db    0
.xdata$x:0000D389                 db    0
.xdata$x:0000D38A                 db    0
.xdata$x:0000D38B                 db    0
.xdata$x:0000D38B _xdata$x        ends
.xdata$x:0000D38B
.xdata$x:0000D38C ; ===========================================================================
.xdata$x:0000D38C
.xdata$x:0000D38C ; Segment type: Pure data
.xdata$x:0000D38C ; Segment permissions: Read
.xdata$x:0000D38C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D38C                 assume cs:_xdata$x
.xdata$x:0000D38C                 ;org 0D38Ch
.xdata$x:0000D38C ; COMDAT (pick associative to section at 5F74)
.xdata$x:0000D38C __catchsym$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:0000D38C                                         ; DATA XREF: .xdata$x:0000D3ACo
.xdata$x:0000D38D                 db    0
.xdata$x:0000D38E                 db    0
.xdata$x:0000D38F                 db    0
.xdata$x:0000D390                 db    0
.xdata$x:0000D391                 db    0
.xdata$x:0000D392                 db    0
.xdata$x:0000D393                 db    0
.xdata$x:0000D394                 db    0
.xdata$x:0000D395                 db    0
.xdata$x:0000D396                 db    0
.xdata$x:0000D397                 db    0
.xdata$x:0000D398                 dd offset __catch$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D39C __tryblocktable$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:0000D39C                                         ; DATA XREF: .xdata$x:0000D3C0o
.xdata$x:0000D39D                 db    0
.xdata$x:0000D39E                 db    0
.xdata$x:0000D39F                 db    0
.xdata$x:0000D3A0                 db    3
.xdata$x:0000D3A1                 db    0
.xdata$x:0000D3A2                 db    0
.xdata$x:0000D3A3                 db    0
.xdata$x:0000D3A4                 db    4
.xdata$x:0000D3A5                 db    0
.xdata$x:0000D3A6                 db    0
.xdata$x:0000D3A7                 db    0
.xdata$x:0000D3A8                 db    1
.xdata$x:0000D3A9                 db    0
.xdata$x:0000D3AA                 db    0
.xdata$x:0000D3AB                 db    0
.xdata$x:0000D3AC                 dd offset __catchsym$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:0000D3B0 __ehfuncinfo$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D3B0                                         ; DATA XREF: __ehhandler$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D3B1                 db    5
.xdata$x:0000D3B2                 db  93h ; ô
.xdata$x:0000D3B3                 db  19h
.xdata$x:0000D3B4                 db    5
.xdata$x:0000D3B5                 db    0
.xdata$x:0000D3B6                 db    0
.xdata$x:0000D3B7                 db    0
.xdata$x:0000D3B8                 dd offset __unwindtable$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D3BC                 db    1
.xdata$x:0000D3BD                 db    0
.xdata$x:0000D3BE                 db    0
.xdata$x:0000D3BF                 db    0
.xdata$x:0000D3C0                 dd offset __tryblocktable$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D3C4                 db    0
.xdata$x:0000D3C5                 db    0
.xdata$x:0000D3C6                 db    0
.xdata$x:0000D3C7                 db    0
.xdata$x:0000D3C8                 db    0
.xdata$x:0000D3C9                 db    0
.xdata$x:0000D3CA                 db    0
.xdata$x:0000D3CB                 db    0
.xdata$x:0000D3CC                 db    0
.xdata$x:0000D3CD                 db    0
.xdata$x:0000D3CE                 db    0
.xdata$x:0000D3CF                 db    0
.xdata$x:0000D3D0                 db    0
.xdata$x:0000D3D1                 db    0
.xdata$x:0000D3D2                 db    0
.xdata$x:0000D3D3                 db    0
.xdata$x:0000D3D4 __unwindtable$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D3D4                                         ; DATA XREF: .xdata$x:0000D3B8o
.xdata$x:0000D3D5                 db 0FFh
.xdata$x:0000D3D6                 db 0FFh
.xdata$x:0000D3D7                 db 0FFh
.xdata$x:0000D3D8                 dd offset __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:0000D3DC                 db    0
.xdata$x:0000D3DD                 db    0
.xdata$x:0000D3DE                 db    0
.xdata$x:0000D3DF                 db    0
.xdata$x:0000D3E0                 db    0
.xdata$x:0000D3E1                 db    0
.xdata$x:0000D3E2                 db    0
.xdata$x:0000D3E3                 db    0
.xdata$x:0000D3E4                 db    1
.xdata$x:0000D3E5                 db    0
.xdata$x:0000D3E6                 db    0
.xdata$x:0000D3E7                 db    0
.xdata$x:0000D3E8                 dd offset __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:0000D3EC                 db    2
.xdata$x:0000D3ED                 db    0
.xdata$x:0000D3EE                 db    0
.xdata$x:0000D3EF                 db    0
.xdata$x:0000D3F0                 dd offset __unwindfunclet$??0?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:0000D3F4                 db    0
.xdata$x:0000D3F5                 db    0
.xdata$x:0000D3F6                 db    0
.xdata$x:0000D3F7                 db    0
.xdata$x:0000D3F8                 db    0
.xdata$x:0000D3F9                 db    0
.xdata$x:0000D3FA                 db    0
.xdata$x:0000D3FB                 db    0
.xdata$x:0000D3FB _xdata$x        ends
.xdata$x:0000D3FB
.xdata$x:0000D3FC ; ===========================================================================
.xdata$x:0000D3FC
.xdata$x:0000D3FC ; Segment type: Pure data
.xdata$x:0000D3FC ; Segment permissions: Read
.xdata$x:0000D3FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D3FC                 assume cs:_xdata$x
.xdata$x:0000D3FC                 ;org 0D3FCh
.xdata$x:0000D3FC ; COMDAT (pick associative to section at 753C)
.xdata$x:0000D3FC __unwindtable$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D3FC                                         ; DATA XREF: .xdata$x:0000D40Co
.xdata$x:0000D3FD                 db 0FFh
.xdata$x:0000D3FE                 db 0FFh
.xdata$x:0000D3FF                 db 0FFh
.xdata$x:0000D400                 dd offset __unwindfunclet$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D404 __ehfuncinfo$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D404                                         ; DATA XREF: __ehhandler$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D405                 db    5
.xdata$x:0000D406                 db  93h ; ô
.xdata$x:0000D407                 db  19h
.xdata$x:0000D408                 db    1
.xdata$x:0000D409                 db    0
.xdata$x:0000D40A                 db    0
.xdata$x:0000D40B                 db    0
.xdata$x:0000D40C                 dd offset __unwindtable$??1?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAE@XZ
.xdata$x:0000D410                 db    0
.xdata$x:0000D411                 db    0
.xdata$x:0000D412                 db    0
.xdata$x:0000D413                 db    0
.xdata$x:0000D414                 db    0
.xdata$x:0000D415                 db    0
.xdata$x:0000D416                 db    0
.xdata$x:0000D417                 db    0
.xdata$x:0000D418                 db    0
.xdata$x:0000D419                 db    0
.xdata$x:0000D41A                 db    0
.xdata$x:0000D41B                 db    0
.xdata$x:0000D41C                 db    0
.xdata$x:0000D41D                 db    0
.xdata$x:0000D41E                 db    0
.xdata$x:0000D41F                 db    0
.xdata$x:0000D420                 db    0
.xdata$x:0000D421                 db    0
.xdata$x:0000D422                 db    0
.xdata$x:0000D423                 db    0
.xdata$x:0000D424                 db    0
.xdata$x:0000D425                 db    0
.xdata$x:0000D426                 db    0
.xdata$x:0000D427                 db    0
.xdata$x:0000D427 _xdata$x        ends
.xdata$x:0000D427
.xdata$x:0000D428 ; ===========================================================================
.xdata$x:0000D428
.xdata$x:0000D428 ; Segment type: Pure data
.xdata$x:0000D428 ; Segment permissions: Read
.xdata$x:0000D428 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D428                 assume cs:_xdata$x
.xdata$x:0000D428                 ;org 0D428h
.xdata$x:0000D428 ; COMDAT (pick associative to section at 7E14)
.xdata$x:0000D428 __catchsym$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z$2 db    0
.xdata$x:0000D428                                         ; DATA XREF: .xdata$x:0000D458o
.xdata$x:0000D429                 db    0
.xdata$x:0000D42A                 db    0
.xdata$x:0000D42B                 db    0
.xdata$x:0000D42C                 db    0
.xdata$x:0000D42D                 db    0
.xdata$x:0000D42E                 db    0
.xdata$x:0000D42F                 db    0
.xdata$x:0000D430                 db    0
.xdata$x:0000D431                 db    0
.xdata$x:0000D432                 db    0
.xdata$x:0000D433                 db    0
.xdata$x:0000D434                 dd offset __catch$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z$0
.xdata$x:0000D438 __unwindtable$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z db 0FFh
.xdata$x:0000D438                                         ; DATA XREF: .xdata$x:0000D464o
.xdata$x:0000D439                 db 0FFh
.xdata$x:0000D43A                 db 0FFh
.xdata$x:0000D43B                 db 0FFh
.xdata$x:0000D43C                 db    0
.xdata$x:0000D43D                 db    0
.xdata$x:0000D43E                 db    0
.xdata$x:0000D43F                 db    0
.xdata$x:0000D440                 db 0FFh
.xdata$x:0000D441                 db 0FFh
.xdata$x:0000D442                 db 0FFh
.xdata$x:0000D443                 db 0FFh
.xdata$x:0000D444                 db    0
.xdata$x:0000D445                 db    0
.xdata$x:0000D446                 db    0
.xdata$x:0000D447                 db    0
.xdata$x:0000D448 __tryblocktable$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z db    0
.xdata$x:0000D448                                         ; DATA XREF: .xdata$x:0000D46Co
.xdata$x:0000D449                 db    0
.xdata$x:0000D44A                 db    0
.xdata$x:0000D44B                 db    0
.xdata$x:0000D44C                 db    0
.xdata$x:0000D44D                 db    0
.xdata$x:0000D44E                 db    0
.xdata$x:0000D44F                 db    0
.xdata$x:0000D450                 db    1
.xdata$x:0000D451                 db    0
.xdata$x:0000D452                 db    0
.xdata$x:0000D453                 db    0
.xdata$x:0000D454                 db    1
.xdata$x:0000D455                 db    0
.xdata$x:0000D456                 db    0
.xdata$x:0000D457                 db    0
.xdata$x:0000D458                 dd offset __catchsym$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z$2
.xdata$x:0000D45C __ehfuncinfo$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z db  22h ; "
.xdata$x:0000D45C                                         ; DATA XREF: __ehhandler$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z+11o
.xdata$x:0000D45D                 db    5
.xdata$x:0000D45E                 db  93h ; ô
.xdata$x:0000D45F                 db  19h
.xdata$x:0000D460                 db    2
.xdata$x:0000D461                 db    0
.xdata$x:0000D462                 db    0
.xdata$x:0000D463                 db    0
.xdata$x:0000D464                 dd offset __unwindtable$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:0000D468                 db    1
.xdata$x:0000D469                 db    0
.xdata$x:0000D46A                 db    0
.xdata$x:0000D46B                 db    0
.xdata$x:0000D46C                 dd offset __tryblocktable$??4?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:0000D470                 align 20h
.xdata$x:0000D470 _xdata$x        ends
.xdata$x:0000D470
.xdata$x:0000D480 ; ===========================================================================
.xdata$x:0000D480
.xdata$x:0000D480 ; Segment type: Pure data
.xdata$x:0000D480 ; Segment permissions: Read
.xdata$x:0000D480 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D480                 assume cs:_xdata$x
.xdata$x:0000D480                 ;org 0D480h
.xdata$x:0000D480 ; COMDAT (pick associative to section at AF10)
.xdata$x:0000D480 __unwindtable$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000D480                                         ; DATA XREF: .xdata$x:0000D490o
.xdata$x:0000D481                 db 0FFh
.xdata$x:0000D482                 db 0FFh
.xdata$x:0000D483                 db 0FFh
.xdata$x:0000D484                 dd offset __unwindfunclet$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0
.xdata$x:0000D488 __ehfuncinfo$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000D488                                         ; DATA XREF: __ehhandler$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ+11o
.xdata$x:0000D489                 db    5
.xdata$x:0000D48A                 db  93h ; ô
.xdata$x:0000D48B                 db  19h
.xdata$x:0000D48C                 db    1
.xdata$x:0000D48D                 db    0
.xdata$x:0000D48E                 db    0
.xdata$x:0000D48F                 db    0
.xdata$x:0000D490                 dd offset __unwindtable$?begin@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.xdata$x:0000D494                 db    0
.xdata$x:0000D495                 db    0
.xdata$x:0000D496                 db    0
.xdata$x:0000D497                 db    0
.xdata$x:0000D498                 db    0
.xdata$x:0000D499                 db    0
.xdata$x:0000D49A                 db    0
.xdata$x:0000D49B                 db    0
.xdata$x:0000D49C                 db    0
.xdata$x:0000D49D                 db    0
.xdata$x:0000D49E                 db    0
.xdata$x:0000D49F                 db    0
.xdata$x:0000D4A0                 db    0
.xdata$x:0000D4A1                 db    0
.xdata$x:0000D4A2                 db    0
.xdata$x:0000D4A3                 db    0
.xdata$x:0000D4A4                 db    0
.xdata$x:0000D4A5                 db    0
.xdata$x:0000D4A6                 db    0
.xdata$x:0000D4A7                 db    0
.xdata$x:0000D4A8                 db    0
.xdata$x:0000D4A9                 db    0
.xdata$x:0000D4AA                 db    0
.xdata$x:0000D4AB                 db    0
.xdata$x:0000D4AB _xdata$x        ends
.xdata$x:0000D4AB
.xdata$x:0000D4AC ; ===========================================================================
.xdata$x:0000D4AC
.xdata$x:0000D4AC ; Segment type: Pure data
.xdata$x:0000D4AC ; Segment permissions: Read
.xdata$x:0000D4AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4AC                 assume cs:_xdata$x
.xdata$x:0000D4AC                 ;org 0D4ACh
.xdata$x:0000D4AC ; COMDAT (pick associative to section at B76C)
.xdata$x:0000D4AC __unwindtable$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000D4AC                                         ; DATA XREF: .xdata$x:0000D4BCo
.xdata$x:0000D4AD                 db 0FFh
.xdata$x:0000D4AE                 db 0FFh
.xdata$x:0000D4AF                 db 0FFh
.xdata$x:0000D4B0                 dd offset __unwindfunclet$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ$0
.xdata$x:0000D4B4 __ehfuncinfo$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000D4B4                                         ; DATA XREF: __ehhandler$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ+11o
.xdata$x:0000D4B5                 db    5
.xdata$x:0000D4B6                 db  93h ; ô
.xdata$x:0000D4B7                 db  19h
.xdata$x:0000D4B8                 db    1
.xdata$x:0000D4B9                 db    0
.xdata$x:0000D4BA                 db    0
.xdata$x:0000D4BB                 db    0
.xdata$x:0000D4BC                 dd offset __unwindtable$?end@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@2@XZ
.xdata$x:0000D4C0                 db    0
.xdata$x:0000D4C1                 db    0
.xdata$x:0000D4C2                 db    0
.xdata$x:0000D4C3                 db    0
.xdata$x:0000D4C4                 db    0
.xdata$x:0000D4C5                 db    0
.xdata$x:0000D4C6                 db    0
.xdata$x:0000D4C7                 db    0
.xdata$x:0000D4C8                 db    0
.xdata$x:0000D4C9                 db    0
.xdata$x:0000D4CA                 db    0
.xdata$x:0000D4CB                 db    0
.xdata$x:0000D4CC                 db    0
.xdata$x:0000D4CD                 db    0
.xdata$x:0000D4CE                 db    0
.xdata$x:0000D4CF                 db    0
.xdata$x:0000D4D0                 db    0
.xdata$x:0000D4D1                 db    0
.xdata$x:0000D4D2                 db    0
.xdata$x:0000D4D3                 db    0
.xdata$x:0000D4D4                 db    0
.xdata$x:0000D4D5                 db    0
.xdata$x:0000D4D6                 db    0
.xdata$x:0000D4D7                 db    0
.xdata$x:0000D4D7 _xdata$x        ends
.xdata$x:0000D4D7
.xdata$x:0000D4D8 ; ===========================================================================
.xdata$x:0000D4D8
.xdata$x:0000D4D8 ; Segment type: Pure data
.xdata$x:0000D4D8 ; Segment permissions: Read
.xdata$x:0000D4D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4D8                 assume cs:_xdata$x
.xdata$x:0000D4D8                 ;org 0D4D8h
.xdata$x:0000D4D8 ; COMDAT (pick associative to section at 78D0)
.xdata$x:0000D4D8 __unwindtable$??1ScintillaKeyMap@@UAE@XZ db 0FFh
.xdata$x:0000D4D8                                         ; DATA XREF: .xdata$x:0000D4F0o
.xdata$x:0000D4D9                 db 0FFh
.xdata$x:0000D4DA                 db 0FFh
.xdata$x:0000D4DB                 db 0FFh
.xdata$x:0000D4DC                 dd offset __unwindfunclet$??1ScintillaKeyMap@@UAE@XZ$0
.xdata$x:0000D4E0                 db    0
.xdata$x:0000D4E1                 db    0
.xdata$x:0000D4E2                 db    0
.xdata$x:0000D4E3                 db    0
.xdata$x:0000D4E4                 dd offset __unwindfunclet$??1ScintillaKeyMap@@UAE@XZ$1
.xdata$x:0000D4E8 __ehfuncinfo$??1ScintillaKeyMap@@UAE@XZ db  22h ; "
.xdata$x:0000D4E8                                         ; DATA XREF: __ehhandler$??1ScintillaKeyMap@@UAE@XZ+11o
.xdata$x:0000D4E9                 db    5
.xdata$x:0000D4EA                 db  93h ; ô
.xdata$x:0000D4EB                 db  19h
.xdata$x:0000D4EC                 db    2
.xdata$x:0000D4ED                 db    0
.xdata$x:0000D4EE                 db    0
.xdata$x:0000D4EF                 db    0
.xdata$x:0000D4F0                 dd offset __unwindtable$??1ScintillaKeyMap@@UAE@XZ
.xdata$x:0000D4F4                 db    0
.xdata$x:0000D4F5                 db    0
.xdata$x:0000D4F6                 db    0
.xdata$x:0000D4F7                 db    0
.xdata$x:0000D4F8                 db    0
.xdata$x:0000D4F9                 db    0
.xdata$x:0000D4FA                 db    0
.xdata$x:0000D4FB                 db    0
.xdata$x:0000D4FC                 db    0
.xdata$x:0000D4FD                 db    0
.xdata$x:0000D4FE                 db    0
.xdata$x:0000D4FF                 db    0
.xdata$x:0000D500                 db    0
.xdata$x:0000D501                 db    0
.xdata$x:0000D502                 db    0
.xdata$x:0000D503                 db    0
.xdata$x:0000D504                 db    0
.xdata$x:0000D505                 db    0
.xdata$x:0000D506                 db    0
.xdata$x:0000D507                 db    0
.xdata$x:0000D508                 db    0
.xdata$x:0000D509                 db    0
.xdata$x:0000D50A                 db    0
.xdata$x:0000D50B                 db    0
.xdata$x:0000D50B _xdata$x        ends
.xdata$x:0000D50B
.xdata$x:0000D50C ; ===========================================================================
.xdata$x:0000D50C
.xdata$x:0000D50C ; Segment type: Pure data
.xdata$x:0000D50C ; Segment permissions: Read
.xdata$x:0000D50C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D50C                 assume cs:_xdata$x
.xdata$x:0000D50C                 ;org 0D50Ch
.xdata$x:0000D50C ; COMDAT (pick associative to section at 6554)
.xdata$x:0000D50C __unwindtable$??0ScintillaKeyMap@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000D50C                                         ; DATA XREF: .xdata$x:0000D524o
.xdata$x:0000D50D                 db 0FFh
.xdata$x:0000D50E                 db 0FFh
.xdata$x:0000D50F                 db 0FFh
.xdata$x:0000D510                 dd offset __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$0
.xdata$x:0000D514                 align 8
.xdata$x:0000D518                 dd offset __unwindfunclet$??0ScintillaKeyMap@@QAE@ABV0@@Z$1
.xdata$x:0000D51C __ehfuncinfo$??0ScintillaKeyMap@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000D51C                                         ; DATA XREF: __ehhandler$??0ScintillaKeyMap@@QAE@ABV0@@Z+11o
.xdata$x:0000D51D                 db    5
.xdata$x:0000D51E                 db  93h ; ô
.xdata$x:0000D51F                 db  19h
.xdata$x:0000D520                 db    2
.xdata$x:0000D521                 db    0
.xdata$x:0000D522                 db    0
.xdata$x:0000D523                 db    0
.xdata$x:0000D524                 dd offset __unwindtable$??0ScintillaKeyMap@@QAE@ABV0@@Z
.xdata$x:0000D528                 align 20h
.xdata$x:0000D528 _xdata$x        ends
.xdata$x:0000D528
.xdata$x:0000D540 ; ===========================================================================
.xdata$x:0000D540
.xdata$x:0000D540 ; Segment type: Pure data
.xdata$x:0000D540 ; Segment permissions: Read
.xdata$x:0000D540 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D540                 assume cs:_xdata$x
.xdata$x:0000D540                 ;org 0D540h
.xdata$x:0000D540 ; COMDAT (pick associative to section at 4DDC)
.xdata$x:0000D540 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D540                                         ; DATA XREF: .xdata$x:0000D550o
.xdata$x:0000D541                 db 0FFh
.xdata$x:0000D542                 db 0FFh
.xdata$x:0000D543                 db 0FFh
.xdata$x:0000D544                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000D548 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D548                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000D549                 db    5
.xdata$x:0000D54A                 db  93h ; ô
.xdata$x:0000D54B                 db  19h
.xdata$x:0000D54C                 db    1
.xdata$x:0000D54D                 db    0
.xdata$x:0000D54E                 db    0
.xdata$x:0000D54F                 db    0
.xdata$x:0000D550                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000D554                 db    0
.xdata$x:0000D555                 db    0
.xdata$x:0000D556                 db    0
.xdata$x:0000D557                 db    0
.xdata$x:0000D558                 db    0
.xdata$x:0000D559                 db    0
.xdata$x:0000D55A                 db    0
.xdata$x:0000D55B                 db    0
.xdata$x:0000D55C                 db    0
.xdata$x:0000D55D                 db    0
.xdata$x:0000D55E                 db    0
.xdata$x:0000D55F                 db    0
.xdata$x:0000D560                 db    0
.xdata$x:0000D561                 db    0
.xdata$x:0000D562                 db    0
.xdata$x:0000D563                 db    0
.xdata$x:0000D564                 db    0
.xdata$x:0000D565                 db    0
.xdata$x:0000D566                 db    0
.xdata$x:0000D567                 db    0
.xdata$x:0000D568                 db    0
.xdata$x:0000D569                 db    0
.xdata$x:0000D56A                 db    0
.xdata$x:0000D56B                 db    0
.xdata$x:0000D56B _xdata$x        ends
.xdata$x:0000D56B
.xdata$x:0000D56C ; ===========================================================================
.xdata$x:0000D56C
.xdata$x:0000D56C ; Segment type: Pure data
.xdata$x:0000D56C ; Segment permissions: Read
.xdata$x:0000D56C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D56C                 assume cs:_xdata$x
.xdata$x:0000D56C                 ;org 0D56Ch
.xdata$x:0000D56C ; COMDAT (pick associative to section at 6B5C)
.xdata$x:0000D56C __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000D56C                                         ; DATA XREF: .xdata$x:0000D57Co
.xdata$x:0000D56D                 db 0FFh
.xdata$x:0000D56E                 db 0FFh
.xdata$x:0000D56F                 db 0FFh
.xdata$x:0000D570                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000D574 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D574                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000D575                 db    5
.xdata$x:0000D576                 db  93h ; ô
.xdata$x:0000D577                 db  19h
.xdata$x:0000D578                 db    1
.xdata$x:0000D579                 db    0
.xdata$x:0000D57A                 db    0
.xdata$x:0000D57B                 db    0
.xdata$x:0000D57C                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000D580                 db    0
.xdata$x:0000D581                 db    0
.xdata$x:0000D582                 db    0
.xdata$x:0000D583                 db    0
.xdata$x:0000D584                 db    0
.xdata$x:0000D585                 db    0
.xdata$x:0000D586                 db    0
.xdata$x:0000D587                 db    0
.xdata$x:0000D588                 db    0
.xdata$x:0000D589                 db    0
.xdata$x:0000D58A                 db    0
.xdata$x:0000D58B                 db    0
.xdata$x:0000D58C                 db    0
.xdata$x:0000D58D                 db    0
.xdata$x:0000D58E                 db    0
.xdata$x:0000D58F                 db    0
.xdata$x:0000D590                 db    0
.xdata$x:0000D591                 db    0
.xdata$x:0000D592                 db    0
.xdata$x:0000D593                 db    0
.xdata$x:0000D594                 db    0
.xdata$x:0000D595                 db    0
.xdata$x:0000D596                 db    0
.xdata$x:0000D597                 db    0
.xdata$x:0000D597 _xdata$x        ends
.xdata$x:0000D597
.xdata$x:0000D598 ; ===========================================================================
.xdata$x:0000D598
.xdata$x:0000D598 ; Segment type: Pure data
.xdata$x:0000D598 ; Segment permissions: Read
.xdata$x:0000D598 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D598                 assume cs:_xdata$x
.xdata$x:0000D598                 ;org 0D598h
.xdata$x:0000D598 ; COMDAT (pick associative to section at 4D64)
.xdata$x:0000D598 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000D598                                         ; DATA XREF: .xdata$x:0000D5A8o
.xdata$x:0000D599                 db 0FFh
.xdata$x:0000D59A                 db 0FFh
.xdata$x:0000D59B                 db 0FFh
.xdata$x:0000D59C                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000D5A0 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000D5A0                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000D5A1                 db    5
.xdata$x:0000D5A2                 db  93h ; ô
.xdata$x:0000D5A3                 db  19h
.xdata$x:0000D5A4                 db    1
.xdata$x:0000D5A5                 db    0
.xdata$x:0000D5A6                 db    0
.xdata$x:0000D5A7                 db    0
.xdata$x:0000D5A8                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UKeyCombo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000D5AC                 db    0
.xdata$x:0000D5AD                 db    0
.xdata$x:0000D5AE                 db    0
.xdata$x:0000D5AF                 db    0
.xdata$x:0000D5B0                 db    0
.xdata$x:0000D5B1                 db    0
.xdata$x:0000D5B2                 db    0
.xdata$x:0000D5B3                 db    0
.xdata$x:0000D5B4                 db    0
.xdata$x:0000D5B5                 db    0
.xdata$x:0000D5B6                 db    0
.xdata$x:0000D5B7                 db    0
.xdata$x:0000D5B8                 db    0
.xdata$x:0000D5B9                 db    0
.xdata$x:0000D5BA                 db    0
.xdata$x:0000D5BB                 db    0
.xdata$x:0000D5BC                 db    0
.xdata$x:0000D5BD                 db    0
.xdata$x:0000D5BE                 db    0
.xdata$x:0000D5BF                 db    0
.xdata$x:0000D5C0                 db    0
.xdata$x:0000D5C1                 db    0
.xdata$x:0000D5C2                 db    0
.xdata$x:0000D5C3                 db    0
.xdata$x:0000D5C3 _xdata$x        ends
.xdata$x:0000D5C3
.xdata$x:0000D5C4 ; ===========================================================================
.xdata$x:0000D5C4
.xdata$x:0000D5C4 ; Segment type: Pure data
.xdata$x:0000D5C4 ; Segment permissions: Read
.xdata$x:0000D5C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5C4                 assume cs:_xdata$x
.xdata$x:0000D5C4                 ;org 0D5C4h
.xdata$x:0000D5C4 ; COMDAT (pick associative to section at 5514)
.xdata$x:0000D5C4 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000D5C4                                         ; DATA XREF: .xdata$x:0000D5D4o
.xdata$x:0000D5C5                 db 0FFh
.xdata$x:0000D5C6                 db 0FFh
.xdata$x:0000D5C7                 db 0FFh
.xdata$x:0000D5C8                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z$0
.xdata$x:0000D5CC __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000D5CC                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000D5CD                 db    5
.xdata$x:0000D5CE                 db  93h ; ô
.xdata$x:0000D5CF                 db  19h
.xdata$x:0000D5D0                 db    1
.xdata$x:0000D5D1                 db    0
.xdata$x:0000D5D2                 db    0
.xdata$x:0000D5D3                 db    0
.xdata$x:0000D5D4                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@PAUKeyCombo@@PBU_Container_base12@1@@Z
.xdata$x:0000D5D8                 db    0
.xdata$x:0000D5D9                 db    0
.xdata$x:0000D5DA                 db    0
.xdata$x:0000D5DB                 db    0
.xdata$x:0000D5DC                 db    0
.xdata$x:0000D5DD                 db    0
.xdata$x:0000D5DE                 db    0
.xdata$x:0000D5DF                 db    0
.xdata$x:0000D5E0                 db    0
.xdata$x:0000D5E1                 db    0
.xdata$x:0000D5E2                 db    0
.xdata$x:0000D5E3                 db    0
.xdata$x:0000D5E4                 db    0
.xdata$x:0000D5E5                 db    0
.xdata$x:0000D5E6                 db    0
.xdata$x:0000D5E7                 db    0
.xdata$x:0000D5E8                 db    0
.xdata$x:0000D5E9                 db    0
.xdata$x:0000D5EA                 db    0
.xdata$x:0000D5EB                 db    0
.xdata$x:0000D5EC                 db    0
.xdata$x:0000D5ED                 db    0
.xdata$x:0000D5EE                 db    0
.xdata$x:0000D5EF                 db    0
.xdata$x:0000D5EF _xdata$x        ends
.xdata$x:0000D5EF
.xdata$x:0000D5F0 ; ===========================================================================
.xdata$x:0000D5F0
.xdata$x:0000D5F0 ; Segment type: Pure data
.xdata$x:0000D5F0 ; Segment permissions: Read
.xdata$x:0000D5F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5F0                 assume cs:_xdata$x
.xdata$x:0000D5F0                 ;org 0D5F0h
.xdata$x:0000D5F0 ; COMDAT (pick associative to section at 7054)
.xdata$x:0000D5F0 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D5F0                                         ; DATA XREF: .xdata$x:0000D600o
.xdata$x:0000D5F1                 db 0FFh
.xdata$x:0000D5F2                 db 0FFh
.xdata$x:0000D5F3                 db 0FFh
.xdata$x:0000D5F4                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D5F8 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D5F8                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D5F9                 db    5
.xdata$x:0000D5FA                 db  93h ; ô
.xdata$x:0000D5FB                 db  19h
.xdata$x:0000D5FC                 db    1
.xdata$x:0000D5FD                 db    0
.xdata$x:0000D5FE                 db    0
.xdata$x:0000D5FF                 db    0
.xdata$x:0000D600                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D604                 db    0
.xdata$x:0000D605                 db    0
.xdata$x:0000D606                 db    0
.xdata$x:0000D607                 db    0
.xdata$x:0000D608                 db    0
.xdata$x:0000D609                 db    0
.xdata$x:0000D60A                 db    0
.xdata$x:0000D60B                 db    0
.xdata$x:0000D60C                 db    0
.xdata$x:0000D60D                 db    0
.xdata$x:0000D60E                 db    0
.xdata$x:0000D60F                 db    0
.xdata$x:0000D610                 db    0
.xdata$x:0000D611                 db    0
.xdata$x:0000D612                 db    0
.xdata$x:0000D613                 db    0
.xdata$x:0000D614                 db    0
.xdata$x:0000D615                 db    0
.xdata$x:0000D616                 db    0
.xdata$x:0000D617                 db    0
.xdata$x:0000D618                 db    0
.xdata$x:0000D619                 db    0
.xdata$x:0000D61A                 db    0
.xdata$x:0000D61B                 db    0
.xdata$x:0000D61B _xdata$x        ends
.xdata$x:0000D61B
.xdata$x:0000D61C ; ===========================================================================
.xdata$x:0000D61C
.xdata$x:0000D61C ; Segment type: Pure data
.xdata$x:0000D61C ; Segment permissions: Read
.xdata$x:0000D61C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D61C                 assume cs:_xdata$x
.xdata$x:0000D61C                 ;org 0D61Ch
.xdata$x:0000D61C ; COMDAT (pick associative to section at 5490)
.xdata$x:0000D61C __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D61C                                         ; DATA XREF: .xdata$x:0000D62Co
.xdata$x:0000D61D                 db 0FFh
.xdata$x:0000D61E                 db 0FFh
.xdata$x:0000D61F                 db 0FFh
.xdata$x:0000D620                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D624 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D624                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D625                 db    5
.xdata$x:0000D626                 db  93h ; ô
.xdata$x:0000D627                 db  19h
.xdata$x:0000D628                 db    1
.xdata$x:0000D629                 db    0
.xdata$x:0000D62A                 db    0
.xdata$x:0000D62B                 db    0
.xdata$x:0000D62C                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D630                 db    0
.xdata$x:0000D631                 db    0
.xdata$x:0000D632                 db    0
.xdata$x:0000D633                 db    0
.xdata$x:0000D634                 db    0
.xdata$x:0000D635                 db    0
.xdata$x:0000D636                 db    0
.xdata$x:0000D637                 db    0
.xdata$x:0000D638                 db    0
.xdata$x:0000D639                 db    0
.xdata$x:0000D63A                 db    0
.xdata$x:0000D63B                 db    0
.xdata$x:0000D63C                 db    0
.xdata$x:0000D63D                 db    0
.xdata$x:0000D63E                 db    0
.xdata$x:0000D63F                 db    0
.xdata$x:0000D640                 db    0
.xdata$x:0000D641                 db    0
.xdata$x:0000D642                 db    0
.xdata$x:0000D643                 db    0
.xdata$x:0000D644                 db    0
.xdata$x:0000D645                 db    0
.xdata$x:0000D646                 db    0
.xdata$x:0000D647                 db    0
.xdata$x:0000D647 _xdata$x        ends
.xdata$x:0000D647
.xdata$x:0000D648 ; ===========================================================================
.xdata$x:0000D648
.xdata$x:0000D648 ; Segment type: Pure data
.xdata$x:0000D648 ; Segment permissions: Read
.xdata$x:0000D648 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D648                 assume cs:_xdata$x
.xdata$x:0000D648                 ;org 0D648h
.xdata$x:0000D648 ; COMDAT (pick associative to section at 7D18)
.xdata$x:0000D648 __unwindtable$??1recordedMacroStep@@QAE@XZ db 0FFh
.xdata$x:0000D648                                         ; DATA XREF: .xdata$x:0000D658o
.xdata$x:0000D649                 db 0FFh
.xdata$x:0000D64A                 db 0FFh
.xdata$x:0000D64B                 db 0FFh
.xdata$x:0000D64C                 dd offset __unwindfunclet$??1recordedMacroStep@@QAE@XZ$0
.xdata$x:0000D650 __ehfuncinfo$??1recordedMacroStep@@QAE@XZ db  22h ; "
.xdata$x:0000D650                                         ; DATA XREF: __ehhandler$??1recordedMacroStep@@QAE@XZ+11o
.xdata$x:0000D651                 db    5
.xdata$x:0000D652                 db  93h ; ô
.xdata$x:0000D653                 db  19h
.xdata$x:0000D654                 db    1
.xdata$x:0000D655                 db    0
.xdata$x:0000D656                 db    0
.xdata$x:0000D657                 db    0
.xdata$x:0000D658                 dd offset __unwindtable$??1recordedMacroStep@@QAE@XZ
.xdata$x:0000D65C                 db    0
.xdata$x:0000D65D                 db    0
.xdata$x:0000D65E                 db    0
.xdata$x:0000D65F                 db    0
.xdata$x:0000D660                 db    0
.xdata$x:0000D661                 db    0
.xdata$x:0000D662                 db    0
.xdata$x:0000D663                 db    0
.xdata$x:0000D664                 db    0
.xdata$x:0000D665                 db    0
.xdata$x:0000D666                 db    0
.xdata$x:0000D667                 db    0
.xdata$x:0000D668                 db    0
.xdata$x:0000D669                 db    0
.xdata$x:0000D66A                 db    0
.xdata$x:0000D66B                 db    0
.xdata$x:0000D66C                 db    0
.xdata$x:0000D66D                 db    0
.xdata$x:0000D66E                 db    0
.xdata$x:0000D66F                 db    0
.xdata$x:0000D670                 db    0
.xdata$x:0000D671                 db    0
.xdata$x:0000D672                 db    0
.xdata$x:0000D673                 db    0
.xdata$x:0000D673 _xdata$x        ends
.xdata$x:0000D673
.xdata$x:0000D674 ; ===========================================================================
.xdata$x:0000D674
.xdata$x:0000D674 ; Segment type: Pure data
.xdata$x:0000D674 ; Segment permissions: Read
.xdata$x:0000D674 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D674                 assume cs:_xdata$x
.xdata$x:0000D674                 ;org 0D674h
.xdata$x:0000D674 ; COMDAT (pick associative to section at 6AAC)
.xdata$x:0000D674 __unwindtable$??0recordedMacroStep@@QAE@ABU0@@Z db 0FFh
.xdata$x:0000D674                                         ; DATA XREF: .xdata$x:0000D684o
.xdata$x:0000D675                 db 0FFh
.xdata$x:0000D676                 db 0FFh
.xdata$x:0000D677                 db 0FFh
.xdata$x:0000D678                 dd offset __unwindfunclet$??0recordedMacroStep@@QAE@ABU0@@Z$0
.xdata$x:0000D67C __ehfuncinfo$??0recordedMacroStep@@QAE@ABU0@@Z db  22h ; "
.xdata$x:0000D67C                                         ; DATA XREF: __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z+11o
.xdata$x:0000D67D                 db    5
.xdata$x:0000D67E                 db  93h ; ô
.xdata$x:0000D67F                 db  19h
.xdata$x:0000D680                 db    1
.xdata$x:0000D681                 db    0
.xdata$x:0000D682                 db    0
.xdata$x:0000D683                 db    0
.xdata$x:0000D684                 dd offset __unwindtable$??0recordedMacroStep@@QAE@ABU0@@Z
.xdata$x:0000D688                 align 20h
.xdata$x:0000D688 _xdata$x        ends
.xdata$x:0000D688
.xdata$x:0000D6A0 ; ===========================================================================
.xdata$x:0000D6A0
.xdata$x:0000D6A0 ; Segment type: Pure data
.xdata$x:0000D6A0 ; Segment permissions: Read
.xdata$x:0000D6A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D6A0                 assume cs:_xdata$x
.xdata$x:0000D6A0                 ;org 0D6A0h
.xdata$x:0000D6A0 ; COMDAT (pick associative to section at B2EC)
.xdata$x:0000D6A0 __unwindtable$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z db 0FFh
.xdata$x:0000D6A0                                         ; DATA XREF: .xdata$x:0000D6B0o
.xdata$x:0000D6A1                 db 0FFh
.xdata$x:0000D6A2                 db 0FFh
.xdata$x:0000D6A3                 db 0FFh
.xdata$x:0000D6A4                 dd offset __unwindfunclet$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z$0
.xdata$x:0000D6A8 __ehfuncinfo$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z db  22h ; "
.xdata$x:0000D6A8                                         ; DATA XREF: __ehhandler$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z+11o
.xdata$x:0000D6A9                 db    5
.xdata$x:0000D6AA                 db  93h ; ô
.xdata$x:0000D6AB                 db  19h
.xdata$x:0000D6AC                 db    1
.xdata$x:0000D6AD                 db    0
.xdata$x:0000D6AE                 db    0
.xdata$x:0000D6AF                 db    0
.xdata$x:0000D6B0                 dd offset __unwindtable$?construct@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@ABU3@@Z
.xdata$x:0000D6B4                 db    0
.xdata$x:0000D6B5                 db    0
.xdata$x:0000D6B6                 db    0
.xdata$x:0000D6B7                 db    0
.xdata$x:0000D6B8                 db    0
.xdata$x:0000D6B9                 db    0
.xdata$x:0000D6BA                 db    0
.xdata$x:0000D6BB                 db    0
.xdata$x:0000D6BC                 db    0
.xdata$x:0000D6BD                 db    0
.xdata$x:0000D6BE                 db    0
.xdata$x:0000D6BF                 db    0
.xdata$x:0000D6C0                 db    0
.xdata$x:0000D6C1                 db    0
.xdata$x:0000D6C2                 db    0
.xdata$x:0000D6C3                 db    0
.xdata$x:0000D6C4                 db    0
.xdata$x:0000D6C5                 db    0
.xdata$x:0000D6C6                 db    0
.xdata$x:0000D6C7                 db    0
.xdata$x:0000D6C8                 db    0
.xdata$x:0000D6C9                 db    0
.xdata$x:0000D6CA                 db    0
.xdata$x:0000D6CB                 db    0
.xdata$x:0000D6CB _xdata$x        ends
.xdata$x:0000D6CB
.xdata$x:0000D6CC ; ===========================================================================
.xdata$x:0000D6CC
.xdata$x:0000D6CC ; Segment type: Pure data
.xdata$x:0000D6CC ; Segment permissions: Read
.xdata$x:0000D6CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D6CC                 assume cs:_xdata$x
.xdata$x:0000D6CC                 ;org 0D6CCh
.xdata$x:0000D6CC ; COMDAT (pick associative to section at 5BD8)
.xdata$x:0000D6CC __unwindtable$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D6CC                                         ; DATA XREF: .xdata$x:0000D6DCo
.xdata$x:0000D6CD                 db 0FFh
.xdata$x:0000D6CE                 db 0FFh
.xdata$x:0000D6CF                 db 0FFh
.xdata$x:0000D6D0                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D6D4 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D6D4                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D6D5                 db    5
.xdata$x:0000D6D6                 db  93h ; ô
.xdata$x:0000D6D7                 db  19h
.xdata$x:0000D6D8                 db    1
.xdata$x:0000D6D9                 db    0
.xdata$x:0000D6DA                 db    0
.xdata$x:0000D6DB                 db    0
.xdata$x:0000D6DC                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.xdata$x:0000D6E0                 db    0
.xdata$x:0000D6E1                 db    0
.xdata$x:0000D6E2                 db    0
.xdata$x:0000D6E3                 db    0
.xdata$x:0000D6E4                 db    0
.xdata$x:0000D6E5                 db    0
.xdata$x:0000D6E6                 db    0
.xdata$x:0000D6E7                 db    0
.xdata$x:0000D6E8                 db    0
.xdata$x:0000D6E9                 db    0
.xdata$x:0000D6EA                 db    0
.xdata$x:0000D6EB                 db    0
.xdata$x:0000D6EC                 db    0
.xdata$x:0000D6ED                 db    0
.xdata$x:0000D6EE                 db    0
.xdata$x:0000D6EF                 db    0
.xdata$x:0000D6F0                 db    0
.xdata$x:0000D6F1                 db    0
.xdata$x:0000D6F2                 db    0
.xdata$x:0000D6F3                 db    0
.xdata$x:0000D6F4                 db    0
.xdata$x:0000D6F5                 db    0
.xdata$x:0000D6F6                 db    0
.xdata$x:0000D6F7                 db    0
.xdata$x:0000D6F7 _xdata$x        ends
.xdata$x:0000D6F7
.xdata$x:0000D6F8 ; ===========================================================================
.xdata$x:0000D6F8
.xdata$x:0000D6F8 ; Segment type: Pure data
.xdata$x:0000D6F8 ; Segment permissions: Read
.xdata$x:0000D6F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D6F8                 assume cs:_xdata$x
.xdata$x:0000D6F8                 ;org 0D6F8h
.xdata$x:0000D6F8 ; COMDAT (pick associative to section at 73D4)
.xdata$x:0000D6F8 __unwindtable$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D6F8                                         ; DATA XREF: .xdata$x:0000D708o
.xdata$x:0000D6F9                 db 0FFh
.xdata$x:0000D6FA                 db 0FFh
.xdata$x:0000D6FB                 db 0FFh
.xdata$x:0000D6FC                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D700 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D700                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D701                 db    5
.xdata$x:0000D702                 db  93h ; ô
.xdata$x:0000D703                 db  19h
.xdata$x:0000D704                 db    1
.xdata$x:0000D705                 db    0
.xdata$x:0000D706                 db    0
.xdata$x:0000D707                 db    0
.xdata$x:0000D708                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.xdata$x:0000D70C                 db    0
.xdata$x:0000D70D                 db    0
.xdata$x:0000D70E                 db    0
.xdata$x:0000D70F                 db    0
.xdata$x:0000D710                 db    0
.xdata$x:0000D711                 db    0
.xdata$x:0000D712                 db    0
.xdata$x:0000D713                 db    0
.xdata$x:0000D714                 db    0
.xdata$x:0000D715                 db    0
.xdata$x:0000D716                 db    0
.xdata$x:0000D717                 db    0
.xdata$x:0000D718                 db    0
.xdata$x:0000D719                 db    0
.xdata$x:0000D71A                 db    0
.xdata$x:0000D71B                 db    0
.xdata$x:0000D71C                 db    0
.xdata$x:0000D71D                 db    0
.xdata$x:0000D71E                 db    0
.xdata$x:0000D71F                 db    0
.xdata$x:0000D720                 db    0
.xdata$x:0000D721                 db    0
.xdata$x:0000D722                 db    0
.xdata$x:0000D723                 db    0
.xdata$x:0000D723 _xdata$x        ends
.xdata$x:0000D723
.xdata$x:0000D724 ; ===========================================================================
.xdata$x:0000D724
.xdata$x:0000D724 ; Segment type: Pure data
.xdata$x:0000D724 ; Segment permissions: Read
.xdata$x:0000D724 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D724                 assume cs:_xdata$x
.xdata$x:0000D724                 ;org 0D724h
.xdata$x:0000D724 ; COMDAT (pick associative to section at 5414)
.xdata$x:0000D724 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z db 0FFh
.xdata$x:0000D724                                         ; DATA XREF: .xdata$x:0000D734o
.xdata$x:0000D725                 db 0FFh
.xdata$x:0000D726                 db 0FFh
.xdata$x:0000D727                 db 0FFh
.xdata$x:0000D728                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z$0
.xdata$x:0000D72C __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z db  22h ; "
.xdata$x:0000D72C                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z+11o
.xdata$x:0000D72D                 db    5
.xdata$x:0000D72E                 db  93h ; ô
.xdata$x:0000D72F                 db  19h
.xdata$x:0000D730                 db    1
.xdata$x:0000D731                 db    0
.xdata$x:0000D732                 db    0
.xdata$x:0000D733                 db    0
.xdata$x:0000D734                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV?$allocator@UrecordedMacroStep@@@1@@Z
.xdata$x:0000D738                 db    0
.xdata$x:0000D739                 db    0
.xdata$x:0000D73A                 db    0
.xdata$x:0000D73B                 db    0
.xdata$x:0000D73C                 db    0
.xdata$x:0000D73D                 db    0
.xdata$x:0000D73E                 db    0
.xdata$x:0000D73F                 db    0
.xdata$x:0000D740                 db    0
.xdata$x:0000D741                 db    0
.xdata$x:0000D742                 db    0
.xdata$x:0000D743                 db    0
.xdata$x:0000D744                 db    0
.xdata$x:0000D745                 db    0
.xdata$x:0000D746                 db    0
.xdata$x:0000D747                 db    0
.xdata$x:0000D748                 db    0
.xdata$x:0000D749                 db    0
.xdata$x:0000D74A                 db    0
.xdata$x:0000D74B                 db    0
.xdata$x:0000D74C                 db    0
.xdata$x:0000D74D                 db    0
.xdata$x:0000D74E                 db    0
.xdata$x:0000D74F                 db    0
.xdata$x:0000D74F _xdata$x        ends
.xdata$x:0000D74F
.xdata$x:0000D750 ; ===========================================================================
.xdata$x:0000D750
.xdata$x:0000D750 ; Segment type: Pure data
.xdata$x:0000D750 ; Segment permissions: Read
.xdata$x:0000D750 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D750                 assume cs:_xdata$x
.xdata$x:0000D750                 ;org 0D750h
.xdata$x:0000D750 ; COMDAT (pick associative to section at 6FDC)
.xdata$x:0000D750 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D750                                         ; DATA XREF: .xdata$x:0000D760o
.xdata$x:0000D751                 db 0FFh
.xdata$x:0000D752                 db 0FFh
.xdata$x:0000D753                 db 0FFh
.xdata$x:0000D754                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D758 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D758                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D759                 db    5
.xdata$x:0000D75A                 db  93h ; ô
.xdata$x:0000D75B                 db  19h
.xdata$x:0000D75C                 db    1
.xdata$x:0000D75D                 db    0
.xdata$x:0000D75E                 db    0
.xdata$x:0000D75F                 db    0
.xdata$x:0000D760                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000D764                 db    0
.xdata$x:0000D765                 db    0
.xdata$x:0000D766                 db    0
.xdata$x:0000D767                 db    0
.xdata$x:0000D768                 db    0
.xdata$x:0000D769                 db    0
.xdata$x:0000D76A                 db    0
.xdata$x:0000D76B                 db    0
.xdata$x:0000D76C                 db    0
.xdata$x:0000D76D                 db    0
.xdata$x:0000D76E                 db    0
.xdata$x:0000D76F                 db    0
.xdata$x:0000D770                 db    0
.xdata$x:0000D771                 db    0
.xdata$x:0000D772                 db    0
.xdata$x:0000D773                 db    0
.xdata$x:0000D774                 db    0
.xdata$x:0000D775                 db    0
.xdata$x:0000D776                 db    0
.xdata$x:0000D777                 db    0
.xdata$x:0000D778                 db    0
.xdata$x:0000D779                 db    0
.xdata$x:0000D77A                 db    0
.xdata$x:0000D77B                 db    0
.xdata$x:0000D77B _xdata$x        ends
.xdata$x:0000D77B
.xdata$x:0000D77C ; ===========================================================================
.xdata$x:0000D77C
.xdata$x:0000D77C ; Segment type: Pure data
.xdata$x:0000D77C ; Segment permissions: Read
.xdata$x:0000D77C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D77C                 assume cs:_xdata$x
.xdata$x:0000D77C                 ;org 0D77Ch
.xdata$x:0000D77C ; COMDAT (pick associative to section at 6140)
.xdata$x:0000D77C __catchsym$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:0000D77C                                         ; DATA XREF: .xdata$x:0000D79Co
.xdata$x:0000D77D                 db    0
.xdata$x:0000D77E                 db    0
.xdata$x:0000D77F                 db    0
.xdata$x:0000D780                 db    0
.xdata$x:0000D781                 db    0
.xdata$x:0000D782                 db    0
.xdata$x:0000D783                 db    0
.xdata$x:0000D784                 db    0
.xdata$x:0000D785                 db    0
.xdata$x:0000D786                 db    0
.xdata$x:0000D787                 db    0
.xdata$x:0000D788                 dd offset __catch$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000D78C __tryblocktable$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:0000D78C                                         ; DATA XREF: .xdata$x:0000D7B0o
.xdata$x:0000D78D                 db    0
.xdata$x:0000D78E                 db    0
.xdata$x:0000D78F                 db    0
.xdata$x:0000D790                 db    3
.xdata$x:0000D791                 db    0
.xdata$x:0000D792                 db    0
.xdata$x:0000D793                 db    0
.xdata$x:0000D794                 db    4
.xdata$x:0000D795                 db    0
.xdata$x:0000D796                 db    0
.xdata$x:0000D797                 db    0
.xdata$x:0000D798                 db    1
.xdata$x:0000D799                 db    0
.xdata$x:0000D79A                 db    0
.xdata$x:0000D79B                 db    0
.xdata$x:0000D79C                 dd offset __catchsym$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:0000D7A0 __ehfuncinfo$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000D7A0                                         ; DATA XREF: __ehhandler$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000D7A1                 db    5
.xdata$x:0000D7A2                 db  93h ; ô
.xdata$x:0000D7A3                 db  19h
.xdata$x:0000D7A4                 db    5
.xdata$x:0000D7A5                 db    0
.xdata$x:0000D7A6                 db    0
.xdata$x:0000D7A7                 db    0
.xdata$x:0000D7A8                 dd offset __unwindtable$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D7AC                 db    1
.xdata$x:0000D7AD                 db    0
.xdata$x:0000D7AE                 db    0
.xdata$x:0000D7AF                 db    0
.xdata$x:0000D7B0                 dd offset __tryblocktable$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000D7B4                 db    0
.xdata$x:0000D7B5                 db    0
.xdata$x:0000D7B6                 db    0
.xdata$x:0000D7B7                 db    0
.xdata$x:0000D7B8                 db    0
.xdata$x:0000D7B9                 db    0
.xdata$x:0000D7BA                 db    0
.xdata$x:0000D7BB                 db    0
.xdata$x:0000D7BC                 db    0
.xdata$x:0000D7BD                 db    0
.xdata$x:0000D7BE                 db    0
.xdata$x:0000D7BF                 db    0
.xdata$x:0000D7C0                 db    0
.xdata$x:0000D7C1                 db    0
.xdata$x:0000D7C2                 db    0
.xdata$x:0000D7C3                 db    0
.xdata$x:0000D7C4 __unwindtable$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000D7C4                                         ; DATA XREF: .xdata$x:0000D7A8o
.xdata$x:0000D7C5                 db 0FFh
.xdata$x:0000D7C6                 db 0FFh
.xdata$x:0000D7C7                 db 0FFh
.xdata$x:0000D7C8                 dd offset __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:0000D7CC                 db    0
.xdata$x:0000D7CD                 db    0
.xdata$x:0000D7CE                 db    0
.xdata$x:0000D7CF                 db    0
.xdata$x:0000D7D0                 db    0
.xdata$x:0000D7D1                 db    0
.xdata$x:0000D7D2                 db    0
.xdata$x:0000D7D3                 db    0
.xdata$x:0000D7D4                 db    1
.xdata$x:0000D7D5                 db    0
.xdata$x:0000D7D6                 db    0
.xdata$x:0000D7D7                 db    0
.xdata$x:0000D7D8                 dd offset __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:0000D7DC                 db    2
.xdata$x:0000D7DD                 db    0
.xdata$x:0000D7DE                 db    0
.xdata$x:0000D7DF                 db    0
.xdata$x:0000D7E0                 dd offset __unwindfunclet$??0?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:0000D7E4                 db    0
.xdata$x:0000D7E5                 db    0
.xdata$x:0000D7E6                 db    0
.xdata$x:0000D7E7                 db    0
.xdata$x:0000D7E8                 db    0
.xdata$x:0000D7E9                 db    0
.xdata$x:0000D7EA                 db    0
.xdata$x:0000D7EB                 db    0
.xdata$x:0000D7EB _xdata$x        ends
.xdata$x:0000D7EB
.xdata$x:0000D7EC ; ===========================================================================
.xdata$x:0000D7EC
.xdata$x:0000D7EC ; Segment type: Pure data
.xdata$x:0000D7EC ; Segment permissions: Read
.xdata$x:0000D7EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D7EC                 assume cs:_xdata$x
.xdata$x:0000D7EC                 ;org 0D7ECh
.xdata$x:0000D7EC ; COMDAT (pick associative to section at 762C)
.xdata$x:0000D7EC __unwindtable$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000D7EC                                         ; DATA XREF: .xdata$x:0000D7FCo
.xdata$x:0000D7ED                 db 0FFh
.xdata$x:0000D7EE                 db 0FFh
.xdata$x:0000D7EF                 db 0FFh
.xdata$x:0000D7F0                 dd offset __unwindfunclet$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ$0
.xdata$x:0000D7F4 __ehfuncinfo$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000D7F4                                         ; DATA XREF: __ehhandler$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000D7F5                 db    5
.xdata$x:0000D7F6                 db  93h ; ô
.xdata$x:0000D7F7                 db  19h
.xdata$x:0000D7F8                 db    1
.xdata$x:0000D7F9                 db    0
.xdata$x:0000D7FA                 db    0
.xdata$x:0000D7FB                 db    0
.xdata$x:0000D7FC                 dd offset __unwindtable$??1?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.xdata$x:0000D800                 db    0
.xdata$x:0000D801                 db    0
.xdata$x:0000D802                 db    0
.xdata$x:0000D803                 db    0
.xdata$x:0000D804                 db    0
.xdata$x:0000D805                 db    0
.xdata$x:0000D806                 db    0
.xdata$x:0000D807                 db    0
.xdata$x:0000D808                 db    0
.xdata$x:0000D809                 db    0
.xdata$x:0000D80A                 db    0
.xdata$x:0000D80B                 db    0
.xdata$x:0000D80C                 db    0
.xdata$x:0000D80D                 db    0
.xdata$x:0000D80E                 db    0
.xdata$x:0000D80F                 db    0
.xdata$x:0000D810                 db    0
.xdata$x:0000D811                 db    0
.xdata$x:0000D812                 db    0
.xdata$x:0000D813                 db    0
.xdata$x:0000D814                 db    0
.xdata$x:0000D815                 db    0
.xdata$x:0000D816                 db    0
.xdata$x:0000D817                 db    0
.xdata$x:0000D817 _xdata$x        ends
.xdata$x:0000D817
.xdata$x:0000D818 ; ===========================================================================
.xdata$x:0000D818
.xdata$x:0000D818 ; Segment type: Pure data
.xdata$x:0000D818 ; Segment permissions: Read
.xdata$x:0000D818 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D818                 assume cs:_xdata$x
.xdata$x:0000D818                 ;org 0D818h
.xdata$x:0000D818 ; COMDAT (pick associative to section at 8074)
.xdata$x:0000D818 __catchsym$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z$2 db    0
.xdata$x:0000D818                                         ; DATA XREF: .xdata$x:0000D848o
.xdata$x:0000D819                 db    0
.xdata$x:0000D81A                 db    0
.xdata$x:0000D81B                 db    0
.xdata$x:0000D81C                 db    0
.xdata$x:0000D81D                 db    0
.xdata$x:0000D81E                 db    0
.xdata$x:0000D81F                 db    0
.xdata$x:0000D820                 db    0
.xdata$x:0000D821                 db    0
.xdata$x:0000D822                 db    0
.xdata$x:0000D823                 db    0
.xdata$x:0000D824                 dd offset __catch$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z$0
.xdata$x:0000D828 __unwindtable$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z db 0FFh
.xdata$x:0000D828                                         ; DATA XREF: .xdata$x:0000D854o
.xdata$x:0000D829                 db 0FFh
.xdata$x:0000D82A                 db 0FFh
.xdata$x:0000D82B                 db 0FFh
.xdata$x:0000D82C                 db    0
.xdata$x:0000D82D                 db    0
.xdata$x:0000D82E                 db    0
.xdata$x:0000D82F                 db    0
.xdata$x:0000D830                 db 0FFh
.xdata$x:0000D831                 db 0FFh
.xdata$x:0000D832                 db 0FFh
.xdata$x:0000D833                 db 0FFh
.xdata$x:0000D834                 db    0
.xdata$x:0000D835                 db    0
.xdata$x:0000D836                 db    0
.xdata$x:0000D837                 db    0
.xdata$x:0000D838 __tryblocktable$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z db    0
.xdata$x:0000D838                                         ; DATA XREF: .xdata$x:0000D85Co
.xdata$x:0000D839                 db    0
.xdata$x:0000D83A                 db    0
.xdata$x:0000D83B                 db    0
.xdata$x:0000D83C                 db    0
.xdata$x:0000D83D                 db    0
.xdata$x:0000D83E                 db    0
.xdata$x:0000D83F                 db    0
.xdata$x:0000D840                 db    1
.xdata$x:0000D841                 db    0
.xdata$x:0000D842                 db    0
.xdata$x:0000D843                 db    0
.xdata$x:0000D844                 db    1
.xdata$x:0000D845                 db    0
.xdata$x:0000D846                 db    0
.xdata$x:0000D847                 db    0
.xdata$x:0000D848                 dd offset __catchsym$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z$2
.xdata$x:0000D84C __ehfuncinfo$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z db  22h ; "
.xdata$x:0000D84C                                         ; DATA XREF: __ehhandler$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z+11o
.xdata$x:0000D84D                 db    5
.xdata$x:0000D84E                 db  93h ; ô
.xdata$x:0000D84F                 db  19h
.xdata$x:0000D850                 db    2
.xdata$x:0000D851                 db    0
.xdata$x:0000D852                 db    0
.xdata$x:0000D853                 db    0
.xdata$x:0000D854                 dd offset __unwindtable$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:0000D858                 db    1
.xdata$x:0000D859                 db    0
.xdata$x:0000D85A                 db    0
.xdata$x:0000D85B                 db    0
.xdata$x:0000D85C                 dd offset __tryblocktable$??4?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:0000D860                 db    0
.xdata$x:0000D861                 db    0
.xdata$x:0000D862                 db    0
.xdata$x:0000D863                 db    0
.xdata$x:0000D864                 db    0
.xdata$x:0000D865                 db    0
.xdata$x:0000D866                 db    0
.xdata$x:0000D867                 db    0
.xdata$x:0000D868                 db    0
.xdata$x:0000D869                 db    0
.xdata$x:0000D86A                 db    0
.xdata$x:0000D86B                 db    0
.xdata$x:0000D86C                 db    0
.xdata$x:0000D86D                 db    0
.xdata$x:0000D86E                 db    0
.xdata$x:0000D86F                 db    0
.xdata$x:0000D86F _xdata$x        ends
.xdata$x:0000D86F
.xdata$x:0000D870 ; ===========================================================================
.xdata$x:0000D870
.xdata$x:0000D870 ; Segment type: Pure data
.xdata$x:0000D870 ; Segment permissions: Read
.xdata$x:0000D870 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D870                 assume cs:_xdata$x
.xdata$x:0000D870                 ;org 0D870h
.xdata$x:0000D870 ; COMDAT (pick associative to section at AFAC)
.xdata$x:0000D870 __unwindtable$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000D870                                         ; DATA XREF: .xdata$x:0000D880o
.xdata$x:0000D871                 db 0FFh
.xdata$x:0000D872                 db 0FFh
.xdata$x:0000D873                 db 0FFh
.xdata$x:0000D874                 dd offset __unwindfunclet$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0
.xdata$x:0000D878 __ehfuncinfo$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000D878                                         ; DATA XREF: __ehhandler$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ+11o
.xdata$x:0000D879                 db    5
.xdata$x:0000D87A                 db  93h ; ô
.xdata$x:0000D87B                 db  19h
.xdata$x:0000D87C                 db    1
.xdata$x:0000D87D                 db    0
.xdata$x:0000D87E                 db    0
.xdata$x:0000D87F                 db    0
.xdata$x:0000D880                 dd offset __unwindtable$?begin@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.xdata$x:0000D884                 db    0
.xdata$x:0000D885                 db    0
.xdata$x:0000D886                 db    0
.xdata$x:0000D887                 db    0
.xdata$x:0000D888                 db    0
.xdata$x:0000D889                 db    0
.xdata$x:0000D88A                 db    0
.xdata$x:0000D88B                 db    0
.xdata$x:0000D88C                 db    0
.xdata$x:0000D88D                 db    0
.xdata$x:0000D88E                 db    0
.xdata$x:0000D88F                 db    0
.xdata$x:0000D890                 db    0
.xdata$x:0000D891                 db    0
.xdata$x:0000D892                 db    0
.xdata$x:0000D893                 db    0
.xdata$x:0000D894                 db    0
.xdata$x:0000D895                 db    0
.xdata$x:0000D896                 db    0
.xdata$x:0000D897                 db    0
.xdata$x:0000D898                 db    0
.xdata$x:0000D899                 db    0
.xdata$x:0000D89A                 db    0
.xdata$x:0000D89B                 db    0
.xdata$x:0000D89B _xdata$x        ends
.xdata$x:0000D89B
.xdata$x:0000D89C ; ===========================================================================
.xdata$x:0000D89C
.xdata$x:0000D89C ; Segment type: Pure data
.xdata$x:0000D89C ; Segment permissions: Read
.xdata$x:0000D89C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D89C                 assume cs:_xdata$x
.xdata$x:0000D89C                 ;org 0D89Ch
.xdata$x:0000D89C ; COMDAT (pick associative to section at B808)
.xdata$x:0000D89C __unwindtable$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000D89C                                         ; DATA XREF: .xdata$x:0000D8ACo
.xdata$x:0000D89D                 db 0FFh
.xdata$x:0000D89E                 db 0FFh
.xdata$x:0000D89F                 db 0FFh
.xdata$x:0000D8A0                 dd offset __unwindfunclet$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ$0
.xdata$x:0000D8A4 __ehfuncinfo$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000D8A4                                         ; DATA XREF: __ehhandler$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ+11o
.xdata$x:0000D8A5                 db    5
.xdata$x:0000D8A6                 db  93h ; ô
.xdata$x:0000D8A7                 db  19h
.xdata$x:0000D8A8                 db    1
.xdata$x:0000D8A9                 db    0
.xdata$x:0000D8AA                 db    0
.xdata$x:0000D8AB                 db    0
.xdata$x:0000D8AC                 dd offset __unwindtable$?end@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@2@XZ
.xdata$x:0000D8B0                 db    0
.xdata$x:0000D8B1                 db    0
.xdata$x:0000D8B2                 db    0
.xdata$x:0000D8B3                 db    0
.xdata$x:0000D8B4                 db    0
.xdata$x:0000D8B5                 db    0
.xdata$x:0000D8B6                 db    0
.xdata$x:0000D8B7                 db    0
.xdata$x:0000D8B8                 db    0
.xdata$x:0000D8B9                 db    0
.xdata$x:0000D8BA                 db    0
.xdata$x:0000D8BB                 db    0
.xdata$x:0000D8BC                 db    0
.xdata$x:0000D8BD                 db    0
.xdata$x:0000D8BE                 db    0
.xdata$x:0000D8BF                 db    0
.xdata$x:0000D8C0                 db    0
.xdata$x:0000D8C1                 db    0
.xdata$x:0000D8C2                 db    0
.xdata$x:0000D8C3                 db    0
.xdata$x:0000D8C4                 db    0
.xdata$x:0000D8C5                 db    0
.xdata$x:0000D8C6                 db    0
.xdata$x:0000D8C7                 db    0
.xdata$x:0000D8C7 _xdata$x        ends
.xdata$x:0000D8C7
.xdata$x:0000D8C8 ; ===========================================================================
.xdata$x:0000D8C8
.xdata$x:0000D8C8 ; Segment type: Pure data
.xdata$x:0000D8C8 ; Segment permissions: Read
.xdata$x:0000D8C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D8C8                 assume cs:_xdata$x
.xdata$x:0000D8C8                 ;org 0D8C8h
.xdata$x:0000D8C8 ; COMDAT (pick associative to section at 7714)
.xdata$x:0000D8C8 __unwindtable$??1MacroShortcut@@UAE@XZ db 0FFh
.xdata$x:0000D8C8                                         ; DATA XREF: .xdata$x:0000D8E0o
.xdata$x:0000D8C9                 db 0FFh
.xdata$x:0000D8CA                 db 0FFh
.xdata$x:0000D8CB                 db 0FFh
.xdata$x:0000D8CC                 dd offset __unwindfunclet$??1MacroShortcut@@UAE@XZ$0
.xdata$x:0000D8D0                 db    0
.xdata$x:0000D8D1                 db    0
.xdata$x:0000D8D2                 db    0
.xdata$x:0000D8D3                 db    0
.xdata$x:0000D8D4                 dd offset __unwindfunclet$??1MacroShortcut@@UAE@XZ$1
.xdata$x:0000D8D8 __ehfuncinfo$??1MacroShortcut@@UAE@XZ db  22h ; "
.xdata$x:0000D8D8                                         ; DATA XREF: __ehhandler$??1MacroShortcut@@UAE@XZ+11o
.xdata$x:0000D8D9                 db    5
.xdata$x:0000D8DA                 db  93h ; ô
.xdata$x:0000D8DB                 db  19h
.xdata$x:0000D8DC                 db    2
.xdata$x:0000D8DD                 db    0
.xdata$x:0000D8DE                 db    0
.xdata$x:0000D8DF                 db    0
.xdata$x:0000D8E0                 dd offset __unwindtable$??1MacroShortcut@@UAE@XZ
.xdata$x:0000D8E4                 db    0
.xdata$x:0000D8E5                 db    0
.xdata$x:0000D8E6                 db    0
.xdata$x:0000D8E7                 db    0
.xdata$x:0000D8E8                 db    0
.xdata$x:0000D8E9                 db    0
.xdata$x:0000D8EA                 db    0
.xdata$x:0000D8EB                 db    0
.xdata$x:0000D8EC                 db    0
.xdata$x:0000D8ED                 db    0
.xdata$x:0000D8EE                 db    0
.xdata$x:0000D8EF                 db    0
.xdata$x:0000D8F0                 db    0
.xdata$x:0000D8F1                 db    0
.xdata$x:0000D8F2                 db    0
.xdata$x:0000D8F3                 db    0
.xdata$x:0000D8F4                 db    0
.xdata$x:0000D8F5                 db    0
.xdata$x:0000D8F6                 db    0
.xdata$x:0000D8F7                 db    0
.xdata$x:0000D8F8                 db    0
.xdata$x:0000D8F9                 db    0
.xdata$x:0000D8FA                 db    0
.xdata$x:0000D8FB                 db    0
.xdata$x:0000D8FB _xdata$x        ends
.xdata$x:0000D8FB
.xdata$x:0000D8FC ; ===========================================================================
.xdata$x:0000D8FC
.xdata$x:0000D8FC ; Segment type: Pure data
.xdata$x:0000D8FC ; Segment permissions: Read
.xdata$x:0000D8FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D8FC                 assume cs:_xdata$x
.xdata$x:0000D8FC                 ;org 0D8FCh
.xdata$x:0000D8FC ; COMDAT (pick associative to section at 6320)
.xdata$x:0000D8FC __unwindtable$??0MacroShortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000D8FC                                         ; DATA XREF: .xdata$x:0000D914o
.xdata$x:0000D8FD                 db 0FFh
.xdata$x:0000D8FE                 db 0FFh
.xdata$x:0000D8FF                 db 0FFh
.xdata$x:0000D900                 dd offset __unwindfunclet$??0MacroShortcut@@QAE@ABV0@@Z$0
.xdata$x:0000D904                 align 8
.xdata$x:0000D908                 dd offset __unwindfunclet$??0MacroShortcut@@QAE@ABV0@@Z$1
.xdata$x:0000D90C __ehfuncinfo$??0MacroShortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000D90C                                         ; DATA XREF: __ehhandler$??0MacroShortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000D90D                 db    5
.xdata$x:0000D90E                 db  93h ; ô
.xdata$x:0000D90F                 db  19h
.xdata$x:0000D910                 db    2
.xdata$x:0000D911                 db    0
.xdata$x:0000D912                 db    0
.xdata$x:0000D913                 db    0
.xdata$x:0000D914                 dd offset __unwindtable$??0MacroShortcut@@QAE@ABV0@@Z
.xdata$x:0000D918                 db    0
.xdata$x:0000D919                 db    0
.xdata$x:0000D91A                 db    0
.xdata$x:0000D91B                 db    0
.xdata$x:0000D91C                 db    0
.xdata$x:0000D91D                 db    0
.xdata$x:0000D91E                 db    0
.xdata$x:0000D91F                 db    0
.xdata$x:0000D920                 db    0
.xdata$x:0000D921                 db    0
.xdata$x:0000D922                 db    0
.xdata$x:0000D923                 db    0
.xdata$x:0000D924                 db    0
.xdata$x:0000D925                 db    0
.xdata$x:0000D926                 db    0
.xdata$x:0000D927                 db    0
.xdata$x:0000D928                 db    0
.xdata$x:0000D929                 db    0
.xdata$x:0000D92A                 db    0
.xdata$x:0000D92B                 db    0
.xdata$x:0000D92C                 db    0
.xdata$x:0000D92D                 db    0
.xdata$x:0000D92E                 db    0
.xdata$x:0000D92F                 db    0
.xdata$x:0000D92F _xdata$x        ends
.xdata$x:0000D92F
.xdata$x:0000D930 ; ===========================================================================
.xdata$x:0000D930
.xdata$x:0000D930 ; Segment type: Pure data
.xdata$x:0000D930 ; Segment permissions: Read
.xdata$x:0000D930 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D930                 assume cs:_xdata$x
.xdata$x:0000D930                 ;org 0D930h
.xdata$x:0000D930 ; COMDAT (pick associative to section at 7A74)
.xdata$x:0000D930 __unwindtable$??1UserCommand@@UAE@XZ db 0FFh
.xdata$x:0000D930                                         ; DATA XREF: .xdata$x:0000D948o
.xdata$x:0000D931                 db 0FFh
.xdata$x:0000D932                 db 0FFh
.xdata$x:0000D933                 db 0FFh
.xdata$x:0000D934                 dd offset __unwindfunclet$??1UserCommand@@UAE@XZ$0
.xdata$x:0000D938                 db    0
.xdata$x:0000D939                 db    0
.xdata$x:0000D93A                 db    0
.xdata$x:0000D93B                 db    0
.xdata$x:0000D93C                 dd offset __unwindfunclet$??1UserCommand@@UAE@XZ$1
.xdata$x:0000D940 __ehfuncinfo$??1UserCommand@@UAE@XZ db  22h ; "
.xdata$x:0000D940                                         ; DATA XREF: __ehhandler$??1UserCommand@@UAE@XZ+11o
.xdata$x:0000D941                 db    5
.xdata$x:0000D942                 db  93h ; ô
.xdata$x:0000D943                 db  19h
.xdata$x:0000D944                 db    2
.xdata$x:0000D945                 db    0
.xdata$x:0000D946                 db    0
.xdata$x:0000D947                 db    0
.xdata$x:0000D948                 dd offset __unwindtable$??1UserCommand@@UAE@XZ
.xdata$x:0000D94C                 db    0
.xdata$x:0000D94D                 db    0
.xdata$x:0000D94E                 db    0
.xdata$x:0000D94F                 db    0
.xdata$x:0000D950                 db    0
.xdata$x:0000D951                 db    0
.xdata$x:0000D952                 db    0
.xdata$x:0000D953                 db    0
.xdata$x:0000D954                 db    0
.xdata$x:0000D955                 db    0
.xdata$x:0000D956                 db    0
.xdata$x:0000D957                 db    0
.xdata$x:0000D958                 db    0
.xdata$x:0000D959                 db    0
.xdata$x:0000D95A                 db    0
.xdata$x:0000D95B                 db    0
.xdata$x:0000D95C                 db    0
.xdata$x:0000D95D                 db    0
.xdata$x:0000D95E                 db    0
.xdata$x:0000D95F                 db    0
.xdata$x:0000D960                 db    0
.xdata$x:0000D961                 db    0
.xdata$x:0000D962                 db    0
.xdata$x:0000D963                 db    0
.xdata$x:0000D963 _xdata$x        ends
.xdata$x:0000D963
.xdata$x:0000D964 ; ===========================================================================
.xdata$x:0000D964
.xdata$x:0000D964 ; Segment type: Pure data
.xdata$x:0000D964 ; Segment permissions: Read
.xdata$x:0000D964 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D964                 assume cs:_xdata$x
.xdata$x:0000D964                 ;org 0D964h
.xdata$x:0000D964 ; COMDAT (pick associative to section at 675C)
.xdata$x:0000D964 __unwindtable$??0UserCommand@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000D964                                         ; DATA XREF: .xdata$x:0000D97Co
.xdata$x:0000D965                 db 0FFh
.xdata$x:0000D966                 db 0FFh
.xdata$x:0000D967                 db 0FFh
.xdata$x:0000D968                 dd offset __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$0
.xdata$x:0000D96C                 align 10h
.xdata$x:0000D970                 dd offset __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$1
.xdata$x:0000D974 __ehfuncinfo$??0UserCommand@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000D974                                         ; DATA XREF: __ehhandler$??0UserCommand@@QAE@ABV0@@Z+11o
.xdata$x:0000D975                 db    5
.xdata$x:0000D976                 db  93h ; ô
.xdata$x:0000D977                 db  19h
.xdata$x:0000D978                 db    2
.xdata$x:0000D979                 db    0
.xdata$x:0000D97A                 db    0
.xdata$x:0000D97B                 db    0
.xdata$x:0000D97C                 dd offset __unwindtable$??0UserCommand@@QAE@ABV0@@Z
.xdata$x:0000D980                 db    0
.xdata$x:0000D981                 db    0
.xdata$x:0000D982                 db    0
.xdata$x:0000D983                 db    0
.xdata$x:0000D984                 db    0
.xdata$x:0000D985                 db    0
.xdata$x:0000D986                 db    0
.xdata$x:0000D987                 db    0
.xdata$x:0000D988                 db    0
.xdata$x:0000D989                 db    0
.xdata$x:0000D98A                 db    0
.xdata$x:0000D98B                 db    0
.xdata$x:0000D98C                 db    0
.xdata$x:0000D98D                 db    0
.xdata$x:0000D98E                 db    0
.xdata$x:0000D98F                 db    0
.xdata$x:0000D990                 db    0
.xdata$x:0000D991                 db    0
.xdata$x:0000D992                 db    0
.xdata$x:0000D993                 db    0
.xdata$x:0000D994                 db    0
.xdata$x:0000D995                 db    0
.xdata$x:0000D996                 db    0
.xdata$x:0000D997                 db    0
.xdata$x:0000D997 _xdata$x        ends
.xdata$x:0000D997
.xdata$x:0000D998 ; ===========================================================================
.xdata$x:0000D998
.xdata$x:0000D998 ; Segment type: Pure data
.xdata$x:0000D998 ; Segment permissions: Read
.xdata$x:0000D998 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D998                 assume cs:_xdata$x
.xdata$x:0000D998                 ;org 0D998h
.xdata$x:0000D998 ; COMDAT (pick associative to section at 783C)
.xdata$x:0000D998 __unwindtable$??1PluginCmdShortcut@@UAE@XZ db 0FFh
.xdata$x:0000D998                                         ; DATA XREF: .xdata$x:0000D9B0o
.xdata$x:0000D999                 db 0FFh
.xdata$x:0000D99A                 db 0FFh
.xdata$x:0000D99B                 db 0FFh
.xdata$x:0000D99C                 dd offset __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$0
.xdata$x:0000D9A0                 db    0
.xdata$x:0000D9A1                 db    0
.xdata$x:0000D9A2                 db    0
.xdata$x:0000D9A3                 db    0
.xdata$x:0000D9A4                 dd offset __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$1
.xdata$x:0000D9A8 __ehfuncinfo$??1PluginCmdShortcut@@UAE@XZ db  22h ; "
.xdata$x:0000D9A8                                         ; DATA XREF: __ehhandler$??1PluginCmdShortcut@@UAE@XZ+11o
.xdata$x:0000D9A9                 db    5
.xdata$x:0000D9AA                 db  93h ; ô
.xdata$x:0000D9AB                 db  19h
.xdata$x:0000D9AC                 db    2
.xdata$x:0000D9AD                 db    0
.xdata$x:0000D9AE                 db    0
.xdata$x:0000D9AF                 db    0
.xdata$x:0000D9B0                 dd offset __unwindtable$??1PluginCmdShortcut@@UAE@XZ
.xdata$x:0000D9B4                 db    0
.xdata$x:0000D9B5                 db    0
.xdata$x:0000D9B6                 db    0
.xdata$x:0000D9B7                 db    0
.xdata$x:0000D9B8                 db    0
.xdata$x:0000D9B9                 db    0
.xdata$x:0000D9BA                 db    0
.xdata$x:0000D9BB                 db    0
.xdata$x:0000D9BC                 db    0
.xdata$x:0000D9BD                 db    0
.xdata$x:0000D9BE                 db    0
.xdata$x:0000D9BF                 db    0
.xdata$x:0000D9C0                 db    0
.xdata$x:0000D9C1                 db    0
.xdata$x:0000D9C2                 db    0
.xdata$x:0000D9C3                 db    0
.xdata$x:0000D9C4                 db    0
.xdata$x:0000D9C5                 db    0
.xdata$x:0000D9C6                 db    0
.xdata$x:0000D9C7                 db    0
.xdata$x:0000D9C8                 db    0
.xdata$x:0000D9C9                 db    0
.xdata$x:0000D9CA                 db    0
.xdata$x:0000D9CB                 db    0
.xdata$x:0000D9CB _xdata$x        ends
.xdata$x:0000D9CB
.xdata$x:0000D9CC ; ===========================================================================
.xdata$x:0000D9CC
.xdata$x:0000D9CC ; Segment type: Pure data
.xdata$x:0000D9CC ; Segment permissions: Read
.xdata$x:0000D9CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D9CC                 assume cs:_xdata$x
.xdata$x:0000D9CC                 ;org 0D9CCh
.xdata$x:0000D9CC ; COMDAT (pick associative to section at 6480)
.xdata$x:0000D9CC __unwindtable$??0PluginCmdShortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000D9CC                                         ; DATA XREF: .xdata$x:0000D9E4o
.xdata$x:0000D9CD                 db 0FFh
.xdata$x:0000D9CE                 db 0FFh
.xdata$x:0000D9CF                 db 0FFh
.xdata$x:0000D9D0                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$0
.xdata$x:0000D9D4                 align 8
.xdata$x:0000D9D8                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$1
.xdata$x:0000D9DC __ehfuncinfo$??0PluginCmdShortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000D9DC                                         ; DATA XREF: __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000D9DD                 db    5
.xdata$x:0000D9DE                 db  93h ; ô
.xdata$x:0000D9DF                 db  19h
.xdata$x:0000D9E0                 db    2
.xdata$x:0000D9E1                 db    0
.xdata$x:0000D9E2                 db    0
.xdata$x:0000D9E3                 db    0
.xdata$x:0000D9E4                 dd offset __unwindtable$??0PluginCmdShortcut@@QAE@ABV0@@Z
.xdata$x:0000D9E8                 align 20h
.xdata$x:0000D9E8 _xdata$x        ends
.xdata$x:0000D9E8
.xdata$x:0000DA00 ; ===========================================================================
.xdata$x:0000DA00
.xdata$x:0000DA00 ; Segment type: Pure data
.xdata$x:0000DA00 ; Segment permissions: Read
.xdata$x:0000DA00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA00                 assume cs:_xdata$x
.xdata$x:0000DA00                 ;org 0DA00h
.xdata$x:0000DA00 ; COMDAT (pick associative to section at 77A8)
.xdata$x:0000DA00 __unwindtable$??1MenuItemUnit@@QAE@XZ db 0FFh
.xdata$x:0000DA00                                         ; DATA XREF: .xdata$x:0000DA18o
.xdata$x:0000DA01                 db 0FFh
.xdata$x:0000DA02                 db 0FFh
.xdata$x:0000DA03                 db 0FFh
.xdata$x:0000DA04                 dd offset __unwindfunclet$??1MenuItemUnit@@QAE@XZ$0
.xdata$x:0000DA08                 db    0
.xdata$x:0000DA09                 db    0
.xdata$x:0000DA0A                 db    0
.xdata$x:0000DA0B                 db    0
.xdata$x:0000DA0C                 dd offset __unwindfunclet$??1MenuItemUnit@@QAE@XZ$1
.xdata$x:0000DA10 __ehfuncinfo$??1MenuItemUnit@@QAE@XZ db  22h ; "
.xdata$x:0000DA10                                         ; DATA XREF: __ehhandler$??1MenuItemUnit@@QAE@XZ+11o
.xdata$x:0000DA11                 db    5
.xdata$x:0000DA12                 db  93h ; ô
.xdata$x:0000DA13                 db  19h
.xdata$x:0000DA14                 db    2
.xdata$x:0000DA15                 db    0
.xdata$x:0000DA16                 db    0
.xdata$x:0000DA17                 db    0
.xdata$x:0000DA18                 dd offset __unwindtable$??1MenuItemUnit@@QAE@XZ
.xdata$x:0000DA1C                 db    0
.xdata$x:0000DA1D                 db    0
.xdata$x:0000DA1E                 db    0
.xdata$x:0000DA1F                 db    0
.xdata$x:0000DA20                 db    0
.xdata$x:0000DA21                 db    0
.xdata$x:0000DA22                 db    0
.xdata$x:0000DA23                 db    0
.xdata$x:0000DA24                 db    0
.xdata$x:0000DA25                 db    0
.xdata$x:0000DA26                 db    0
.xdata$x:0000DA27                 db    0
.xdata$x:0000DA28                 db    0
.xdata$x:0000DA29                 db    0
.xdata$x:0000DA2A                 db    0
.xdata$x:0000DA2B                 db    0
.xdata$x:0000DA2C                 db    0
.xdata$x:0000DA2D                 db    0
.xdata$x:0000DA2E                 db    0
.xdata$x:0000DA2F                 db    0
.xdata$x:0000DA30                 db    0
.xdata$x:0000DA31                 db    0
.xdata$x:0000DA32                 db    0
.xdata$x:0000DA33                 db    0
.xdata$x:0000DA33 _xdata$x        ends
.xdata$x:0000DA33
.xdata$x:0000DA34 ; ===========================================================================
.xdata$x:0000DA34
.xdata$x:0000DA34 ; Segment type: Pure data
.xdata$x:0000DA34 ; Segment permissions: Read
.xdata$x:0000DA34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA34                 assume cs:_xdata$x
.xdata$x:0000DA34                 ;org 0DA34h
.xdata$x:0000DA34 ; COMDAT (pick associative to section at 63D0)
.xdata$x:0000DA34 __unwindtable$??0MenuItemUnit@@QAE@ABU0@@Z db 0FFh
.xdata$x:0000DA34                                         ; DATA XREF: .xdata$x:0000DA4Co
.xdata$x:0000DA35                 db 0FFh
.xdata$x:0000DA36                 db 0FFh
.xdata$x:0000DA37                 db 0FFh
.xdata$x:0000DA38                 dd offset __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$0
.xdata$x:0000DA3C                 align 10h
.xdata$x:0000DA40                 dd offset __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$1
.xdata$x:0000DA44 __ehfuncinfo$??0MenuItemUnit@@QAE@ABU0@@Z db  22h ; "
.xdata$x:0000DA44                                         ; DATA XREF: __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z+11o
.xdata$x:0000DA45                 db    5
.xdata$x:0000DA46                 db  93h ; ô
.xdata$x:0000DA47                 db  19h
.xdata$x:0000DA48                 db    2
.xdata$x:0000DA49                 db    0
.xdata$x:0000DA4A                 db    0
.xdata$x:0000DA4B                 db    0
.xdata$x:0000DA4C                 dd offset __unwindtable$??0MenuItemUnit@@QAE@ABU0@@Z
.xdata$x:0000DA50                 db    0
.xdata$x:0000DA51                 db    0
.xdata$x:0000DA52                 db    0
.xdata$x:0000DA53                 db    0
.xdata$x:0000DA54                 db    0
.xdata$x:0000DA55                 db    0
.xdata$x:0000DA56                 db    0
.xdata$x:0000DA57                 db    0
.xdata$x:0000DA58                 db    0
.xdata$x:0000DA59                 db    0
.xdata$x:0000DA5A                 db    0
.xdata$x:0000DA5B                 db    0
.xdata$x:0000DA5C                 db    0
.xdata$x:0000DA5D                 db    0
.xdata$x:0000DA5E                 db    0
.xdata$x:0000DA5F                 db    0
.xdata$x:0000DA60                 db    0
.xdata$x:0000DA61                 db    0
.xdata$x:0000DA62                 db    0
.xdata$x:0000DA63                 db    0
.xdata$x:0000DA64                 db    0
.xdata$x:0000DA65                 db    0
.xdata$x:0000DA66                 db    0
.xdata$x:0000DA67                 db    0
.xdata$x:0000DA67 _xdata$x        ends
.xdata$x:0000DA67
.xdata$x:0000DA68 ; ===========================================================================
.xdata$x:0000DA68
.xdata$x:0000DA68 ; Segment type: Pure data
.xdata$x:0000DA68 ; Segment permissions: Read
.xdata$x:0000DA68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DA68                 assume cs:_xdata$x
.xdata$x:0000DA68                 ;org 0DA68h
.xdata$x:0000DA68 __ehfuncinfo$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ db  22h ; "
.xdata$x:0000DA68                                         ; DATA XREF: __ehhandler$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ+1Eo
.xdata$x:0000DA69                 db    5
.xdata$x:0000DA6A                 db  93h ; ô
.xdata$x:0000DA6B                 db  19h
.xdata$x:0000DA6C                 db    5
.xdata$x:0000DA6D                 db    0
.xdata$x:0000DA6E                 db    0
.xdata$x:0000DA6F                 db    0
.xdata$x:0000DA70                 dd offset __unwindtable$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ
.xdata$x:0000DA74                 db    0
.xdata$x:0000DA75                 db    0
.xdata$x:0000DA76                 db    0
.xdata$x:0000DA77                 db    0
.xdata$x:0000DA78                 db    0
.xdata$x:0000DA79                 db    0
.xdata$x:0000DA7A                 db    0
.xdata$x:0000DA7B                 db    0
.xdata$x:0000DA7C                 db    0
.xdata$x:0000DA7D                 db    0
.xdata$x:0000DA7E                 db    0
.xdata$x:0000DA7F                 db    0
.xdata$x:0000DA80                 db    0
.xdata$x:0000DA81                 db    0
.xdata$x:0000DA82                 db    0
.xdata$x:0000DA83                 db    0
.xdata$x:0000DA84                 db    0
.xdata$x:0000DA85                 db    0
.xdata$x:0000DA86                 db    0
.xdata$x:0000DA87                 db    0
.xdata$x:0000DA88                 db    0
.xdata$x:0000DA89                 db    0
.xdata$x:0000DA8A                 db    0
.xdata$x:0000DA8B                 db    0
.xdata$x:0000DA8C __ehfuncinfo$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z db  22h ; "
.xdata$x:0000DA8C                                         ; DATA XREF: __ehhandler$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z+1Eo
.xdata$x:0000DA8D                 db    5
.xdata$x:0000DA8E                 db  93h ; ô
.xdata$x:0000DA8F                 db  19h
.xdata$x:0000DA90                 db  1Ah
.xdata$x:0000DA91                 db    0
.xdata$x:0000DA92                 db    0
.xdata$x:0000DA93                 db    0
.xdata$x:0000DA94                 dd offset __unwindtable$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z
.xdata$x:0000DA98                 db    0
.xdata$x:0000DA99                 db    0
.xdata$x:0000DA9A                 db    0
.xdata$x:0000DA9B                 db    0
.xdata$x:0000DA9C                 db    0
.xdata$x:0000DA9D                 db    0
.xdata$x:0000DA9E                 db    0
.xdata$x:0000DA9F                 db    0
.xdata$x:0000DAA0                 db    0
.xdata$x:0000DAA1                 db    0
.xdata$x:0000DAA2                 db    0
.xdata$x:0000DAA3                 db    0
.xdata$x:0000DAA4                 db    0
.xdata$x:0000DAA5                 db    0
.xdata$x:0000DAA6                 db    0
.xdata$x:0000DAA7                 db    0
.xdata$x:0000DAA8                 db    0
.xdata$x:0000DAA9                 db    0
.xdata$x:0000DAAA                 db    0
.xdata$x:0000DAAB                 db    0
.xdata$x:0000DAAC                 db    0
.xdata$x:0000DAAD                 db    0
.xdata$x:0000DAAE                 db    0
.xdata$x:0000DAAF                 db    0
.xdata$x:0000DAB0 __unwindtable$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ db 0FFh
.xdata$x:0000DAB0                                         ; DATA XREF: .xdata$x:0000DA70o
.xdata$x:0000DAB1                 db 0FFh
.xdata$x:0000DAB2                 db 0FFh
.xdata$x:0000DAB3                 db 0FFh
.xdata$x:0000DAB4                 dd offset __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$0
.xdata$x:0000DAB8                 db 0FFh
.xdata$x:0000DAB9                 db 0FFh
.xdata$x:0000DABA                 db 0FFh
.xdata$x:0000DABB                 db 0FFh
.xdata$x:0000DABC                 dd offset __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$1
.xdata$x:0000DAC0                 db 0FFh
.xdata$x:0000DAC1                 db 0FFh
.xdata$x:0000DAC2                 db 0FFh
.xdata$x:0000DAC3                 db 0FFh
.xdata$x:0000DAC4                 dd offset __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$2
.xdata$x:0000DAC8                 db 0FFh
.xdata$x:0000DAC9                 db 0FFh
.xdata$x:0000DACA                 db 0FFh
.xdata$x:0000DACB                 db 0FFh
.xdata$x:0000DACC                 dd offset __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$3
.xdata$x:0000DAD0                 db 0FFh
.xdata$x:0000DAD1                 db 0FFh
.xdata$x:0000DAD2                 db 0FFh
.xdata$x:0000DAD3                 db 0FFh
.xdata$x:0000DAD4                 dd offset __unwindfunclet$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ$4
.xdata$x:0000DAD8 __unwindtable$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z db 0FFh
.xdata$x:0000DAD8                                         ; DATA XREF: .xdata$x:0000DA94o
.xdata$x:0000DAD9                 db 0FFh
.xdata$x:0000DADA                 db 0FFh
.xdata$x:0000DADB                 db 0FFh
.xdata$x:0000DADC                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$0
.xdata$x:0000DAE0                 db    0
.xdata$x:0000DAE1                 db    0
.xdata$x:0000DAE2                 db    0
.xdata$x:0000DAE3                 db    0
.xdata$x:0000DAE4                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$1
.xdata$x:0000DAE8                 db    1
.xdata$x:0000DAE9                 db    0
.xdata$x:0000DAEA                 db    0
.xdata$x:0000DAEB                 db    0
.xdata$x:0000DAEC                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$2
.xdata$x:0000DAF0                 db 0FFh
.xdata$x:0000DAF1                 db 0FFh
.xdata$x:0000DAF2                 db 0FFh
.xdata$x:0000DAF3                 db 0FFh
.xdata$x:0000DAF4                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$3
.xdata$x:0000DAF8                 db    3
.xdata$x:0000DAF9                 db    0
.xdata$x:0000DAFA                 db    0
.xdata$x:0000DAFB                 db    0
.xdata$x:0000DAFC                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$4
.xdata$x:0000DB00                 db    4
.xdata$x:0000DB01                 db    0
.xdata$x:0000DB02                 db    0
.xdata$x:0000DB03                 db    0
.xdata$x:0000DB04                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$5
.xdata$x:0000DB08                 db 0FFh
.xdata$x:0000DB09                 db 0FFh
.xdata$x:0000DB0A                 db 0FFh
.xdata$x:0000DB0B                 db 0FFh
.xdata$x:0000DB0C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$6
.xdata$x:0000DB10                 db    6
.xdata$x:0000DB11                 db    0
.xdata$x:0000DB12                 db    0
.xdata$x:0000DB13                 db    0
.xdata$x:0000DB14                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$7
.xdata$x:0000DB18                 db    7
.xdata$x:0000DB19                 db    0
.xdata$x:0000DB1A                 db    0
.xdata$x:0000DB1B                 db    0
.xdata$x:0000DB1C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$8
.xdata$x:0000DB20                 db 0FFh
.xdata$x:0000DB21                 db 0FFh
.xdata$x:0000DB22                 db 0FFh
.xdata$x:0000DB23                 db 0FFh
.xdata$x:0000DB24                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$9
.xdata$x:0000DB28                 db    9
.xdata$x:0000DB29                 db    0
.xdata$x:0000DB2A                 db    0
.xdata$x:0000DB2B                 db    0
.xdata$x:0000DB2C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$10
.xdata$x:0000DB30                 db  0Ah
.xdata$x:0000DB31                 db    0
.xdata$x:0000DB32                 db    0
.xdata$x:0000DB33                 db    0
.xdata$x:0000DB34                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$11
.xdata$x:0000DB38                 db 0FFh
.xdata$x:0000DB39                 db 0FFh
.xdata$x:0000DB3A                 db 0FFh
.xdata$x:0000DB3B                 db 0FFh
.xdata$x:0000DB3C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$12
.xdata$x:0000DB40                 db  0Ch
.xdata$x:0000DB41                 db    0
.xdata$x:0000DB42                 db    0
.xdata$x:0000DB43                 db    0
.xdata$x:0000DB44                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$13
.xdata$x:0000DB48                 db  0Dh
.xdata$x:0000DB49                 db    0
.xdata$x:0000DB4A                 db    0
.xdata$x:0000DB4B                 db    0
.xdata$x:0000DB4C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$14
.xdata$x:0000DB50                 db 0FFh
.xdata$x:0000DB51                 db 0FFh
.xdata$x:0000DB52                 db 0FFh
.xdata$x:0000DB53                 db 0FFh
.xdata$x:0000DB54                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$15
.xdata$x:0000DB58                 db  0Fh
.xdata$x:0000DB59                 db    0
.xdata$x:0000DB5A                 db    0
.xdata$x:0000DB5B                 db    0
.xdata$x:0000DB5C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$16
.xdata$x:0000DB60                 db  10h
.xdata$x:0000DB61                 db    0
.xdata$x:0000DB62                 db    0
.xdata$x:0000DB63                 db    0
.xdata$x:0000DB64                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$17
.xdata$x:0000DB68                 db  0Fh
.xdata$x:0000DB69                 db    0
.xdata$x:0000DB6A                 db    0
.xdata$x:0000DB6B                 db    0
.xdata$x:0000DB6C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$19
.xdata$x:0000DB70                 db 0FFh
.xdata$x:0000DB71                 db 0FFh
.xdata$x:0000DB72                 db 0FFh
.xdata$x:0000DB73                 db 0FFh
.xdata$x:0000DB74                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$20
.xdata$x:0000DB78                 db  13h
.xdata$x:0000DB79                 db    0
.xdata$x:0000DB7A                 db    0
.xdata$x:0000DB7B                 db    0
.xdata$x:0000DB7C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$21
.xdata$x:0000DB80                 db  14h
.xdata$x:0000DB81                 db    0
.xdata$x:0000DB82                 db    0
.xdata$x:0000DB83                 db    0
.xdata$x:0000DB84                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$22
.xdata$x:0000DB88                 db  13h
.xdata$x:0000DB89                 db    0
.xdata$x:0000DB8A                 db    0
.xdata$x:0000DB8B                 db    0
.xdata$x:0000DB8C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$24
.xdata$x:0000DB90                 db 0FFh
.xdata$x:0000DB91                 db 0FFh
.xdata$x:0000DB92                 db 0FFh
.xdata$x:0000DB93                 db 0FFh
.xdata$x:0000DB94                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$25
.xdata$x:0000DB98                 db  17h
.xdata$x:0000DB99                 db    0
.xdata$x:0000DB9A                 db    0
.xdata$x:0000DB9B                 db    0
.xdata$x:0000DB9C                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$26
.xdata$x:0000DBA0                 db  17h
.xdata$x:0000DBA1                 db    0
.xdata$x:0000DBA2                 db    0
.xdata$x:0000DBA3                 db    0
.xdata$x:0000DBA4                 dd offset __unwindfunclet$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z$27
.xdata$x:0000DBA4 _xdata$x        ends
.xdata$x:0000DBA4
.xdata$x:0000DBA8 ; ===========================================================================
.xdata$x:0000DBA8
.xdata$x:0000DBA8 ; Segment type: Pure data
.xdata$x:0000DBA8 ; Segment permissions: Read
.xdata$x:0000DBA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DBA8                 assume cs:_xdata$x
.xdata$x:0000DBA8                 ;org 0DBA8h
.xdata$x:0000DBA8 ; COMDAT (pick associative to section at B048)
.xdata$x:0000DBA8 __unwindtable$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000DBA8                                         ; DATA XREF: .xdata$x:0000DBB8o
.xdata$x:0000DBA9                 db 0FFh
.xdata$x:0000DBAA                 db 0FFh
.xdata$x:0000DBAB                 db 0FFh
.xdata$x:0000DBAC                 dd offset __unwindfunclet$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ$0
.xdata$x:0000DBB0 __ehfuncinfo$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000DBB0                                         ; DATA XREF: __ehhandler$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ+11o
.xdata$x:0000DBB1                 db    5
.xdata$x:0000DBB2                 db  93h ; ô
.xdata$x:0000DBB3                 db  19h
.xdata$x:0000DBB4                 db    1
.xdata$x:0000DBB5                 db    0
.xdata$x:0000DBB6                 db    0
.xdata$x:0000DBB7                 db    0
.xdata$x:0000DBB8                 dd offset __unwindtable$?begin@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@XZ
.xdata$x:0000DBBC                 db    0
.xdata$x:0000DBBD                 db    0
.xdata$x:0000DBBE                 db    0
.xdata$x:0000DBBF                 db    0
.xdata$x:0000DBC0                 db    0
.xdata$x:0000DBC1                 db    0
.xdata$x:0000DBC2                 db    0
.xdata$x:0000DBC3                 db    0
.xdata$x:0000DBC4                 db    0
.xdata$x:0000DBC5                 db    0
.xdata$x:0000DBC6                 db    0
.xdata$x:0000DBC7                 db    0
.xdata$x:0000DBC8                 db    0
.xdata$x:0000DBC9                 db    0
.xdata$x:0000DBCA                 db    0
.xdata$x:0000DBCB                 db    0
.xdata$x:0000DBCC                 db    0
.xdata$x:0000DBCD                 db    0
.xdata$x:0000DBCE                 db    0
.xdata$x:0000DBCF                 db    0
.xdata$x:0000DBD0                 db    0
.xdata$x:0000DBD1                 db    0
.xdata$x:0000DBD2                 db    0
.xdata$x:0000DBD3                 db    0
.xdata$x:0000DBD3 _xdata$x        ends
.xdata$x:0000DBD3
.xdata$x:0000DBD4 ; ===========================================================================
.xdata$x:0000DBD4
.xdata$x:0000DBD4 ; Segment type: Pure data
.xdata$x:0000DBD4 ; Segment permissions: Read
.xdata$x:0000DBD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DBD4                 assume cs:_xdata$x
.xdata$x:0000DBD4                 ;org 0DBD4h
.xdata$x:0000DBD4 ; COMDAT (pick associative to section at 9FD0)
.xdata$x:0000DBD4 __unwindtable$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:0000DBD4                                         ; DATA XREF: .xdata$x:0000DBECo
.xdata$x:0000DBD5                 db 0FFh
.xdata$x:0000DBD6                 db 0FFh
.xdata$x:0000DBD7                 db 0FFh
.xdata$x:0000DBD8                 dd offset __unwindfunclet$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$1
.xdata$x:0000DBDC                 align 10h
.xdata$x:0000DBE0                 dd offset __unwindfunclet$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$0
.xdata$x:0000DBE4 __ehfuncinfo$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:0000DBE4                                         ; DATA XREF: __ehhandler$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z+11o
.xdata$x:0000DBE5                 db    5
.xdata$x:0000DBE6                 db  93h ; ô
.xdata$x:0000DBE7                 db  19h
.xdata$x:0000DBE8                 db    2
.xdata$x:0000DBE9                 db    0
.xdata$x:0000DBEA                 db    0
.xdata$x:0000DBEB                 db    0
.xdata$x:0000DBEC                 dd offset __unwindtable$?_Make_iter@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.xdata$x:0000DBF0                 db    0
.xdata$x:0000DBF1                 db    0
.xdata$x:0000DBF2                 db    0
.xdata$x:0000DBF3                 db    0
.xdata$x:0000DBF4                 db    0
.xdata$x:0000DBF5                 db    0
.xdata$x:0000DBF6                 db    0
.xdata$x:0000DBF7                 db    0
.xdata$x:0000DBF8                 db    0
.xdata$x:0000DBF9                 db    0
.xdata$x:0000DBFA                 db    0
.xdata$x:0000DBFB                 db    0
.xdata$x:0000DBFC                 db    0
.xdata$x:0000DBFD                 db    0
.xdata$x:0000DBFE                 db    0
.xdata$x:0000DBFF                 db    0
.xdata$x:0000DC00                 db    0
.xdata$x:0000DC01                 db    0
.xdata$x:0000DC02                 db    0
.xdata$x:0000DC03                 db    0
.xdata$x:0000DC04                 db    0
.xdata$x:0000DC05                 db    0
.xdata$x:0000DC06                 db    0
.xdata$x:0000DC07                 db    0
.xdata$x:0000DC07 _xdata$x        ends
.xdata$x:0000DC07
.xdata$x:0000DC08 ; ===========================================================================
.xdata$x:0000DC08
.xdata$x:0000DC08 ; Segment type: Pure data
.xdata$x:0000DC08 ; Segment permissions: Read
.xdata$x:0000DC08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC08                 assume cs:_xdata$x
.xdata$x:0000DC08                 ;org 0DC08h
.xdata$x:0000DC08 ; COMDAT (pick associative to section at BA94)
.xdata$x:0000DC08 __unwindtable$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:0000DC08                                         ; DATA XREF: .xdata$x:0000DC28o
.xdata$x:0000DC09                 db 0FFh
.xdata$x:0000DC0A                 db 0FFh
.xdata$x:0000DC0B                 db 0FFh
.xdata$x:0000DC0C                 dd offset __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$2
.xdata$x:0000DC10                 db    0
.xdata$x:0000DC11                 db    0
.xdata$x:0000DC12                 db    0
.xdata$x:0000DC13                 db    0
.xdata$x:0000DC14                 dd offset __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$0
.xdata$x:0000DC18                 db    1
.xdata$x:0000DC19                 db    0
.xdata$x:0000DC1A                 db    0
.xdata$x:0000DC1B                 db    0
.xdata$x:0000DC1C                 dd offset __unwindfunclet$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z$1
.xdata$x:0000DC20 __ehfuncinfo$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:0000DC20                                         ; DATA XREF: __ehhandler$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z+11o
.xdata$x:0000DC21                 db    5
.xdata$x:0000DC22                 db  93h ; ô
.xdata$x:0000DC23                 db  19h
.xdata$x:0000DC24                 db    3
.xdata$x:0000DC25                 db    0
.xdata$x:0000DC26                 db    0
.xdata$x:0000DC27                 db    0
.xdata$x:0000DC28                 dd offset __unwindtable$?erase@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@2@@Z
.xdata$x:0000DC2C                 db    0
.xdata$x:0000DC2D                 db    0
.xdata$x:0000DC2E                 db    0
.xdata$x:0000DC2F                 db    0
.xdata$x:0000DC30                 db    0
.xdata$x:0000DC31                 db    0
.xdata$x:0000DC32                 db    0
.xdata$x:0000DC33                 db    0
.xdata$x:0000DC34                 db    0
.xdata$x:0000DC35                 db    0
.xdata$x:0000DC36                 db    0
.xdata$x:0000DC37                 db    0
.xdata$x:0000DC38                 db    0
.xdata$x:0000DC39                 db    0
.xdata$x:0000DC3A                 db    0
.xdata$x:0000DC3B                 db    0
.xdata$x:0000DC3C                 db    0
.xdata$x:0000DC3D                 db    0
.xdata$x:0000DC3E                 db    0
.xdata$x:0000DC3F                 db    0
.xdata$x:0000DC40                 db    0
.xdata$x:0000DC41                 db    0
.xdata$x:0000DC42                 db    0
.xdata$x:0000DC43                 db    0
.xdata$x:0000DC43 _xdata$x        ends
.xdata$x:0000DC43
.xdata$x:0000DC44 ; ===========================================================================
.xdata$x:0000DC44
.xdata$x:0000DC44 ; Segment type: Pure data
.xdata$x:0000DC44 ; Segment permissions: Read
.xdata$x:0000DC44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC44                 assume cs:_xdata$x
.xdata$x:0000DC44                 ;org 0DC44h
.xdata$x:0000DC44 ; COMDAT (pick associative to section at A418)
.xdata$x:0000DC44 __unwindtable$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z db 0FFh
.xdata$x:0000DC44                                         ; DATA XREF: .xdata$x:0000DC54o
.xdata$x:0000DC45                 db 0FFh
.xdata$x:0000DC46                 db 0FFh
.xdata$x:0000DC47                 db 0FFh
.xdata$x:0000DC48                 dd offset __unwindfunclet$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z$0
.xdata$x:0000DC4C __ehfuncinfo$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z db  22h ; "
.xdata$x:0000DC4C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z+11o
.xdata$x:0000DC4D                 db    5
.xdata$x:0000DC4E                 db  93h ; ô
.xdata$x:0000DC4F                 db  19h
.xdata$x:0000DC50                 db    1
.xdata$x:0000DC51                 db    0
.xdata$x:0000DC52                 db    0
.xdata$x:0000DC53                 db    0
.xdata$x:0000DC54                 dd offset __unwindtable$?_Orphan_range@?$vector@VMacroShortcut@@V?$allocator@VMacroShortcut@@@std@@@std@@IBEXPAVMacroShortcut@@0@Z
.xdata$x:0000DC58                 db    0
.xdata$x:0000DC59                 db    0
.xdata$x:0000DC5A                 db    0
.xdata$x:0000DC5B                 db    0
.xdata$x:0000DC5C                 db    0
.xdata$x:0000DC5D                 db    0
.xdata$x:0000DC5E                 db    0
.xdata$x:0000DC5F                 db    0
.xdata$x:0000DC60                 db    0
.xdata$x:0000DC61                 db    0
.xdata$x:0000DC62                 db    0
.xdata$x:0000DC63                 db    0
.xdata$x:0000DC64                 db    0
.xdata$x:0000DC65                 db    0
.xdata$x:0000DC66                 db    0
.xdata$x:0000DC67                 db    0
.xdata$x:0000DC68                 db    0
.xdata$x:0000DC69                 db    0
.xdata$x:0000DC6A                 db    0
.xdata$x:0000DC6B                 db    0
.xdata$x:0000DC6C                 db    0
.xdata$x:0000DC6D                 db    0
.xdata$x:0000DC6E                 db    0
.xdata$x:0000DC6F                 db    0
.xdata$x:0000DC6F _xdata$x        ends
.xdata$x:0000DC6F
.xdata$x:0000DC70 ; ===========================================================================
.xdata$x:0000DC70
.xdata$x:0000DC70 ; Segment type: Pure data
.xdata$x:0000DC70 ; Segment permissions: Read
.xdata$x:0000DC70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC70                 assume cs:_xdata$x
.xdata$x:0000DC70                 ;org 0DC70h
.xdata$x:0000DC70 ; COMDAT (pick associative to section at B0E4)
.xdata$x:0000DC70 __unwindtable$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000DC70                                         ; DATA XREF: .xdata$x:0000DC80o
.xdata$x:0000DC71                 db 0FFh
.xdata$x:0000DC72                 db 0FFh
.xdata$x:0000DC73                 db 0FFh
.xdata$x:0000DC74                 dd offset __unwindfunclet$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ$0
.xdata$x:0000DC78 __ehfuncinfo$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000DC78                                         ; DATA XREF: __ehhandler$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ+11o
.xdata$x:0000DC79                 db    5
.xdata$x:0000DC7A                 db  93h ; ô
.xdata$x:0000DC7B                 db  19h
.xdata$x:0000DC7C                 db    1
.xdata$x:0000DC7D                 db    0
.xdata$x:0000DC7E                 db    0
.xdata$x:0000DC7F                 db    0
.xdata$x:0000DC80                 dd offset __unwindtable$?begin@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@XZ
.xdata$x:0000DC84                 db    0
.xdata$x:0000DC85                 db    0
.xdata$x:0000DC86                 db    0
.xdata$x:0000DC87                 db    0
.xdata$x:0000DC88                 db    0
.xdata$x:0000DC89                 db    0
.xdata$x:0000DC8A                 db    0
.xdata$x:0000DC8B                 db    0
.xdata$x:0000DC8C                 db    0
.xdata$x:0000DC8D                 db    0
.xdata$x:0000DC8E                 db    0
.xdata$x:0000DC8F                 db    0
.xdata$x:0000DC90                 db    0
.xdata$x:0000DC91                 db    0
.xdata$x:0000DC92                 db    0
.xdata$x:0000DC93                 db    0
.xdata$x:0000DC94                 db    0
.xdata$x:0000DC95                 db    0
.xdata$x:0000DC96                 db    0
.xdata$x:0000DC97                 db    0
.xdata$x:0000DC98                 db    0
.xdata$x:0000DC99                 db    0
.xdata$x:0000DC9A                 db    0
.xdata$x:0000DC9B                 db    0
.xdata$x:0000DC9B _xdata$x        ends
.xdata$x:0000DC9B
.xdata$x:0000DC9C ; ===========================================================================
.xdata$x:0000DC9C
.xdata$x:0000DC9C ; Segment type: Pure data
.xdata$x:0000DC9C ; Segment permissions: Read
.xdata$x:0000DC9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC9C                 assume cs:_xdata$x
.xdata$x:0000DC9C                 ;org 0DC9Ch
.xdata$x:0000DC9C ; COMDAT (pick associative to section at A07C)
.xdata$x:0000DC9C __unwindtable$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:0000DC9C                                         ; DATA XREF: .xdata$x:0000DCB4o
.xdata$x:0000DC9D                 db 0FFh
.xdata$x:0000DC9E                 db 0FFh
.xdata$x:0000DC9F                 db 0FFh
.xdata$x:0000DCA0                 dd offset __unwindfunclet$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$1
.xdata$x:0000DCA4                 align 8
.xdata$x:0000DCA8                 dd offset __unwindfunclet$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$0
.xdata$x:0000DCAC __ehfuncinfo$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:0000DCAC                                         ; DATA XREF: __ehhandler$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z+11o
.xdata$x:0000DCAD                 db    5
.xdata$x:0000DCAE                 db  93h ; ô
.xdata$x:0000DCAF                 db  19h
.xdata$x:0000DCB0                 db    2
.xdata$x:0000DCB1                 db    0
.xdata$x:0000DCB2                 db    0
.xdata$x:0000DCB3                 db    0
.xdata$x:0000DCB4                 dd offset __unwindtable$?_Make_iter@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.xdata$x:0000DCB8                 db    0
.xdata$x:0000DCB9                 db    0
.xdata$x:0000DCBA                 db    0
.xdata$x:0000DCBB                 db    0
.xdata$x:0000DCBC                 db    0
.xdata$x:0000DCBD                 db    0
.xdata$x:0000DCBE                 db    0
.xdata$x:0000DCBF                 db    0
.xdata$x:0000DCC0                 db    0
.xdata$x:0000DCC1                 db    0
.xdata$x:0000DCC2                 db    0
.xdata$x:0000DCC3                 db    0
.xdata$x:0000DCC4                 db    0
.xdata$x:0000DCC5                 db    0
.xdata$x:0000DCC6                 db    0
.xdata$x:0000DCC7                 db    0
.xdata$x:0000DCC8                 db    0
.xdata$x:0000DCC9                 db    0
.xdata$x:0000DCCA                 db    0
.xdata$x:0000DCCB                 db    0
.xdata$x:0000DCCC                 db    0
.xdata$x:0000DCCD                 db    0
.xdata$x:0000DCCE                 db    0
.xdata$x:0000DCCF                 db    0
.xdata$x:0000DCCF _xdata$x        ends
.xdata$x:0000DCCF
.xdata$x:0000DCD0 ; ===========================================================================
.xdata$x:0000DCD0
.xdata$x:0000DCD0 ; Segment type: Pure data
.xdata$x:0000DCD0 ; Segment permissions: Read
.xdata$x:0000DCD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DCD0                 assume cs:_xdata$x
.xdata$x:0000DCD0                 ;org 0DCD0h
.xdata$x:0000DCD0 ; COMDAT (pick associative to section at BC00)
.xdata$x:0000DCD0 __unwindtable$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:0000DCD0                                         ; DATA XREF: .xdata$x:0000DCF0o
.xdata$x:0000DCD1                 db 0FFh
.xdata$x:0000DCD2                 db 0FFh
.xdata$x:0000DCD3                 db 0FFh
.xdata$x:0000DCD4                 dd offset __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$2
.xdata$x:0000DCD8                 db    0
.xdata$x:0000DCD9                 db    0
.xdata$x:0000DCDA                 db    0
.xdata$x:0000DCDB                 db    0
.xdata$x:0000DCDC                 dd offset __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$0
.xdata$x:0000DCE0                 db    1
.xdata$x:0000DCE1                 db    0
.xdata$x:0000DCE2                 db    0
.xdata$x:0000DCE3                 db    0
.xdata$x:0000DCE4                 dd offset __unwindfunclet$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z$1
.xdata$x:0000DCE8 __ehfuncinfo$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:0000DCE8                                         ; DATA XREF: __ehhandler$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z+11o
.xdata$x:0000DCE9                 db    5
.xdata$x:0000DCEA                 db  93h ; ô
.xdata$x:0000DCEB                 db  19h
.xdata$x:0000DCEC                 db    3
.xdata$x:0000DCED                 db    0
.xdata$x:0000DCEE                 db    0
.xdata$x:0000DCEF                 db    0
.xdata$x:0000DCF0                 dd offset __unwindtable$?erase@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@2@@Z
.xdata$x:0000DCF4                 db    0
.xdata$x:0000DCF5                 db    0
.xdata$x:0000DCF6                 db    0
.xdata$x:0000DCF7                 db    0
.xdata$x:0000DCF8                 db    0
.xdata$x:0000DCF9                 db    0
.xdata$x:0000DCFA                 db    0
.xdata$x:0000DCFB                 db    0
.xdata$x:0000DCFC                 db    0
.xdata$x:0000DCFD                 db    0
.xdata$x:0000DCFE                 db    0
.xdata$x:0000DCFF                 db    0
.xdata$x:0000DD00                 db    0
.xdata$x:0000DD01                 db    0
.xdata$x:0000DD02                 db    0
.xdata$x:0000DD03                 db    0
.xdata$x:0000DD04                 db    0
.xdata$x:0000DD05                 db    0
.xdata$x:0000DD06                 db    0
.xdata$x:0000DD07                 db    0
.xdata$x:0000DD08                 db    0
.xdata$x:0000DD09                 db    0
.xdata$x:0000DD0A                 db    0
.xdata$x:0000DD0B                 db    0
.xdata$x:0000DD0B _xdata$x        ends
.xdata$x:0000DD0B
.xdata$x:0000DD0C ; ===========================================================================
.xdata$x:0000DD0C
.xdata$x:0000DD0C ; Segment type: Pure data
.xdata$x:0000DD0C ; Segment permissions: Read
.xdata$x:0000DD0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DD0C                 assume cs:_xdata$x
.xdata$x:0000DD0C                 ;org 0DD0Ch
.xdata$x:0000DD0C ; COMDAT (pick associative to section at A4F4)
.xdata$x:0000DD0C __unwindtable$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z db 0FFh
.xdata$x:0000DD0C                                         ; DATA XREF: .xdata$x:0000DD1Co
.xdata$x:0000DD0D                 db 0FFh
.xdata$x:0000DD0E                 db 0FFh
.xdata$x:0000DD0F                 db 0FFh
.xdata$x:0000DD10                 dd offset __unwindfunclet$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z$0
.xdata$x:0000DD14 __ehfuncinfo$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z db  22h ; "
.xdata$x:0000DD14                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z+11o
.xdata$x:0000DD15                 db    5
.xdata$x:0000DD16                 db  93h ; ô
.xdata$x:0000DD17                 db  19h
.xdata$x:0000DD18                 db    1
.xdata$x:0000DD19                 db    0
.xdata$x:0000DD1A                 db    0
.xdata$x:0000DD1B                 db    0
.xdata$x:0000DD1C                 dd offset __unwindtable$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.xdata$x:0000DD20                 db    0
.xdata$x:0000DD21                 db    0
.xdata$x:0000DD22                 db    0
.xdata$x:0000DD23                 db    0
.xdata$x:0000DD24                 db    0
.xdata$x:0000DD25                 db    0
.xdata$x:0000DD26                 db    0
.xdata$x:0000DD27                 db    0
.xdata$x:0000DD28                 db    0
.xdata$x:0000DD29                 db    0
.xdata$x:0000DD2A                 db    0
.xdata$x:0000DD2B                 db    0
.xdata$x:0000DD2C                 db    0
.xdata$x:0000DD2D                 db    0
.xdata$x:0000DD2E                 db    0
.xdata$x:0000DD2F                 db    0
.xdata$x:0000DD30                 db    0
.xdata$x:0000DD31                 db    0
.xdata$x:0000DD32                 db    0
.xdata$x:0000DD33                 db    0
.xdata$x:0000DD34                 db    0
.xdata$x:0000DD35                 db    0
.xdata$x:0000DD36                 db    0
.xdata$x:0000DD37                 db    0
.xdata$x:0000DD37 _xdata$x        ends
.xdata$x:0000DD37
.xdata$x:0000DD38 ; ===========================================================================
.xdata$x:0000DD38
.xdata$x:0000DD38 ; Segment type: Pure data
.xdata$x:0000DD38 ; Segment permissions: Read
.xdata$x:0000DD38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DD38                 assume cs:_xdata$x
.xdata$x:0000DD38                 ;org 0DD38h
.xdata$x:0000DD38 ; COMDAT (pick associative to section at 5B48)
.xdata$x:0000DD38 __unwindtable$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000DD38                                         ; DATA XREF: .xdata$x:0000DD48o
.xdata$x:0000DD39                 db 0FFh
.xdata$x:0000DD3A                 db 0FFh
.xdata$x:0000DD3B                 db 0FFh
.xdata$x:0000DD3C                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000DD40 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DD40                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000DD41                 db    5
.xdata$x:0000DD42                 db  93h ; ô
.xdata$x:0000DD43                 db  19h
.xdata$x:0000DD44                 db    1
.xdata$x:0000DD45                 db    0
.xdata$x:0000DD46                 db    0
.xdata$x:0000DD47                 db    0
.xdata$x:0000DD48                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000DD4C                 db    0
.xdata$x:0000DD4D                 db    0
.xdata$x:0000DD4E                 db    0
.xdata$x:0000DD4F                 db    0
.xdata$x:0000DD50                 db    0
.xdata$x:0000DD51                 db    0
.xdata$x:0000DD52                 db    0
.xdata$x:0000DD53                 db    0
.xdata$x:0000DD54                 db    0
.xdata$x:0000DD55                 db    0
.xdata$x:0000DD56                 db    0
.xdata$x:0000DD57                 db    0
.xdata$x:0000DD58                 db    0
.xdata$x:0000DD59                 db    0
.xdata$x:0000DD5A                 db    0
.xdata$x:0000DD5B                 db    0
.xdata$x:0000DD5C                 db    0
.xdata$x:0000DD5D                 db    0
.xdata$x:0000DD5E                 db    0
.xdata$x:0000DD5F                 db    0
.xdata$x:0000DD60                 db    0
.xdata$x:0000DD61                 db    0
.xdata$x:0000DD62                 db    0
.xdata$x:0000DD63                 db    0
.xdata$x:0000DD63 _xdata$x        ends
.xdata$x:0000DD63
.xdata$x:0000DD64 ; ===========================================================================
.xdata$x:0000DD64
.xdata$x:0000DD64 ; Segment type: Pure data
.xdata$x:0000DD64 ; Segment permissions: Read
.xdata$x:0000DD64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DD64                 assume cs:_xdata$x
.xdata$x:0000DD64                 ;org 0DD64h
.xdata$x:0000DD64 ; COMDAT (pick associative to section at 7364)
.xdata$x:0000DD64 __unwindtable$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000DD64                                         ; DATA XREF: .xdata$x:0000DD74o
.xdata$x:0000DD65                 db 0FFh
.xdata$x:0000DD66                 db 0FFh
.xdata$x:0000DD67                 db 0FFh
.xdata$x:0000DD68                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000DD6C __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DD6C                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000DD6D                 db    5
.xdata$x:0000DD6E                 db  93h ; ô
.xdata$x:0000DD6F                 db  19h
.xdata$x:0000DD70                 db    1
.xdata$x:0000DD71                 db    0
.xdata$x:0000DD72                 db    0
.xdata$x:0000DD73                 db    0
.xdata$x:0000DD74                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000DD78                 db    0
.xdata$x:0000DD79                 db    0
.xdata$x:0000DD7A                 db    0
.xdata$x:0000DD7B                 db    0
.xdata$x:0000DD7C                 db    0
.xdata$x:0000DD7D                 db    0
.xdata$x:0000DD7E                 db    0
.xdata$x:0000DD7F                 db    0
.xdata$x:0000DD80                 db    0
.xdata$x:0000DD81                 db    0
.xdata$x:0000DD82                 db    0
.xdata$x:0000DD83                 db    0
.xdata$x:0000DD84                 db    0
.xdata$x:0000DD85                 db    0
.xdata$x:0000DD86                 db    0
.xdata$x:0000DD87                 db    0
.xdata$x:0000DD88                 db    0
.xdata$x:0000DD89                 db    0
.xdata$x:0000DD8A                 db    0
.xdata$x:0000DD8B                 db    0
.xdata$x:0000DD8C                 db    0
.xdata$x:0000DD8D                 db    0
.xdata$x:0000DD8E                 db    0
.xdata$x:0000DD8F                 db    0
.xdata$x:0000DD8F _xdata$x        ends
.xdata$x:0000DD8F
.xdata$x:0000DD90 ; ===========================================================================
.xdata$x:0000DD90
.xdata$x:0000DD90 ; Segment type: Pure data
.xdata$x:0000DD90 ; Segment permissions: Read
.xdata$x:0000DD90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DD90                 assume cs:_xdata$x
.xdata$x:0000DD90                 ;org 0DD90h
.xdata$x:0000DD90 ; COMDAT (pick associative to section at 5398)
.xdata$x:0000DD90 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z db 0FFh
.xdata$x:0000DD90                                         ; DATA XREF: .xdata$x:0000DDA0o
.xdata$x:0000DD91                 db 0FFh
.xdata$x:0000DD92                 db 0FFh
.xdata$x:0000DD93                 db 0FFh
.xdata$x:0000DD94                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0
.xdata$x:0000DD98 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z db  22h ; "
.xdata$x:0000DD98                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z+11o
.xdata$x:0000DD99                 db    5
.xdata$x:0000DD9A                 db  93h ; ô
.xdata$x:0000DD9B                 db  19h
.xdata$x:0000DD9C                 db    1
.xdata$x:0000DD9D                 db    0
.xdata$x:0000DD9E                 db    0
.xdata$x:0000DD9F                 db    0
.xdata$x:0000DDA0                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.xdata$x:0000DDA4                 db    0
.xdata$x:0000DDA5                 db    0
.xdata$x:0000DDA6                 db    0
.xdata$x:0000DDA7                 db    0
.xdata$x:0000DDA8                 db    0
.xdata$x:0000DDA9                 db    0
.xdata$x:0000DDAA                 db    0
.xdata$x:0000DDAB                 db    0
.xdata$x:0000DDAC                 db    0
.xdata$x:0000DDAD                 db    0
.xdata$x:0000DDAE                 db    0
.xdata$x:0000DDAF                 db    0
.xdata$x:0000DDB0                 db    0
.xdata$x:0000DDB1                 db    0
.xdata$x:0000DDB2                 db    0
.xdata$x:0000DDB3                 db    0
.xdata$x:0000DDB4                 db    0
.xdata$x:0000DDB5                 db    0
.xdata$x:0000DDB6                 db    0
.xdata$x:0000DDB7                 db    0
.xdata$x:0000DDB8                 db    0
.xdata$x:0000DDB9                 db    0
.xdata$x:0000DDBA                 db    0
.xdata$x:0000DDBB                 db    0
.xdata$x:0000DDBB _xdata$x        ends
.xdata$x:0000DDBB
.xdata$x:0000DDBC ; ===========================================================================
.xdata$x:0000DDBC
.xdata$x:0000DDBC ; Segment type: Pure data
.xdata$x:0000DDBC ; Segment permissions: Read
.xdata$x:0000DDBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DDBC                 assume cs:_xdata$x
.xdata$x:0000DDBC                 ;org 0DDBCh
.xdata$x:0000DDBC ; COMDAT (pick associative to section at 6F64)
.xdata$x:0000DDBC __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000DDBC                                         ; DATA XREF: .xdata$x:0000DDCCo
.xdata$x:0000DDBD                 db 0FFh
.xdata$x:0000DDBE                 db 0FFh
.xdata$x:0000DDBF                 db 0FFh
.xdata$x:0000DDC0                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000DDC4 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DDC4                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000DDC5                 db    5
.xdata$x:0000DDC6                 db  93h ; ô
.xdata$x:0000DDC7                 db  19h
.xdata$x:0000DDC8                 db    1
.xdata$x:0000DDC9                 db    0
.xdata$x:0000DDCA                 db    0
.xdata$x:0000DDCB                 db    0
.xdata$x:0000DDCC                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000DDD0                 db    0
.xdata$x:0000DDD1                 db    0
.xdata$x:0000DDD2                 db    0
.xdata$x:0000DDD3                 db    0
.xdata$x:0000DDD4                 db    0
.xdata$x:0000DDD5                 db    0
.xdata$x:0000DDD6                 db    0
.xdata$x:0000DDD7                 db    0
.xdata$x:0000DDD8                 db    0
.xdata$x:0000DDD9                 db    0
.xdata$x:0000DDDA                 db    0
.xdata$x:0000DDDB                 db    0
.xdata$x:0000DDDC                 db    0
.xdata$x:0000DDDD                 db    0
.xdata$x:0000DDDE                 db    0
.xdata$x:0000DDDF                 db    0
.xdata$x:0000DDE0                 db    0
.xdata$x:0000DDE1                 db    0
.xdata$x:0000DDE2                 db    0
.xdata$x:0000DDE3                 db    0
.xdata$x:0000DDE4                 db    0
.xdata$x:0000DDE5                 db    0
.xdata$x:0000DDE6                 db    0
.xdata$x:0000DDE7                 db    0
.xdata$x:0000DDE7 _xdata$x        ends
.xdata$x:0000DDE7
.xdata$x:0000DDE8 ; ===========================================================================
.xdata$x:0000DDE8
.xdata$x:0000DDE8 ; Segment type: Pure data
.xdata$x:0000DDE8 ; Segment permissions: Read
.xdata$x:0000DDE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DDE8                 assume cs:_xdata$x
.xdata$x:0000DDE8                 ;org 0DDE8h
.xdata$x:0000DDE8 ; COMDAT (pick associative to section at 60C0)
.xdata$x:0000DDE8 __unwindtable$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000DDE8                                         ; DATA XREF: .xdata$x:0000DDF8o
.xdata$x:0000DDE9                 db 0FFh
.xdata$x:0000DDEA                 db 0FFh
.xdata$x:0000DDEB                 db 0FFh
.xdata$x:0000DDEC                 dd offset __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000DDF0 __ehfuncinfo$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DDF0                                         ; DATA XREF: __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000DDF1                 db    5
.xdata$x:0000DDF2                 db  93h ; ô
.xdata$x:0000DDF3                 db  19h
.xdata$x:0000DDF4                 db    1
.xdata$x:0000DDF5                 db    0
.xdata$x:0000DDF6                 db    0
.xdata$x:0000DDF7                 db    0
.xdata$x:0000DDF8                 dd offset __unwindtable$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000DDFC                 db    0
.xdata$x:0000DDFD                 db    0
.xdata$x:0000DDFE                 db    0
.xdata$x:0000DDFF                 db    0
.xdata$x:0000DE00                 db    0
.xdata$x:0000DE01                 db    0
.xdata$x:0000DE02                 db    0
.xdata$x:0000DE03                 db    0
.xdata$x:0000DE04                 db    0
.xdata$x:0000DE05                 db    0
.xdata$x:0000DE06                 db    0
.xdata$x:0000DE07                 db    0
.xdata$x:0000DE08                 db    0
.xdata$x:0000DE09                 db    0
.xdata$x:0000DE0A                 db    0
.xdata$x:0000DE0B                 db    0
.xdata$x:0000DE0C                 db    0
.xdata$x:0000DE0D                 db    0
.xdata$x:0000DE0E                 db    0
.xdata$x:0000DE0F                 db    0
.xdata$x:0000DE10                 db    0
.xdata$x:0000DE11                 db    0
.xdata$x:0000DE12                 db    0
.xdata$x:0000DE13                 db    0
.xdata$x:0000DE13 _xdata$x        ends
.xdata$x:0000DE13
.xdata$x:0000DE14 ; ===========================================================================
.xdata$x:0000DE14
.xdata$x:0000DE14 ; Segment type: Pure data
.xdata$x:0000DE14 ; Segment permissions: Read
.xdata$x:0000DE14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DE14                 assume cs:_xdata$x
.xdata$x:0000DE14                 ;org 0DE14h
.xdata$x:0000DE14 ; COMDAT (pick associative to section at 75B4)
.xdata$x:0000DE14 __unwindtable$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000DE14                                         ; DATA XREF: .xdata$x:0000DE24o
.xdata$x:0000DE15                 db 0FFh
.xdata$x:0000DE16                 db 0FFh
.xdata$x:0000DE17                 db 0FFh
.xdata$x:0000DE18                 dd offset __unwindfunclet$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000DE1C __ehfuncinfo$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DE1C                                         ; DATA XREF: __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000DE1D                 db    5
.xdata$x:0000DE1E                 db  93h ; ô
.xdata$x:0000DE1F                 db  19h
.xdata$x:0000DE20                 db    1
.xdata$x:0000DE21                 db    0
.xdata$x:0000DE22                 db    0
.xdata$x:0000DE23                 db    0
.xdata$x:0000DE24                 dd offset __unwindtable$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000DE28                 align 20h
.xdata$x:0000DE28 _xdata$x        ends
.xdata$x:0000DE28
.xdata$x:0000DE40 ; ===========================================================================
.xdata$x:0000DE40
.xdata$x:0000DE40 ; Segment type: Pure data
.xdata$x:0000DE40 ; Segment permissions: Read
.xdata$x:0000DE40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DE40                 assume cs:_xdata$x
.xdata$x:0000DE40                 ;org 0DE40h
.xdata$x:0000DE40 ; COMDAT (pick associative to section at A5D0)
.xdata$x:0000DE40 __catchsym$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000DE40                                         ; DATA XREF: .xdata$x:0000DE70o
.xdata$x:0000DE41                 db    0
.xdata$x:0000DE42                 db    0
.xdata$x:0000DE43                 db    0
.xdata$x:0000DE44                 db    0
.xdata$x:0000DE45                 db    0
.xdata$x:0000DE46                 db    0
.xdata$x:0000DE47                 db    0
.xdata$x:0000DE48                 db    0
.xdata$x:0000DE49                 db    0
.xdata$x:0000DE4A                 db    0
.xdata$x:0000DE4B                 db    0
.xdata$x:0000DE4C                 dd offset __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000DE50 __unwindtable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000DE50                                         ; DATA XREF: .xdata$x:0000DE7Co
.xdata$x:0000DE51                 db 0FFh
.xdata$x:0000DE52                 db 0FFh
.xdata$x:0000DE53                 db 0FFh
.xdata$x:0000DE54                 db    0
.xdata$x:0000DE55                 db    0
.xdata$x:0000DE56                 db    0
.xdata$x:0000DE57                 db    0
.xdata$x:0000DE58                 db 0FFh
.xdata$x:0000DE59                 db 0FFh
.xdata$x:0000DE5A                 db 0FFh
.xdata$x:0000DE5B                 db 0FFh
.xdata$x:0000DE5C                 db    0
.xdata$x:0000DE5D                 db    0
.xdata$x:0000DE5E                 db    0
.xdata$x:0000DE5F                 db    0
.xdata$x:0000DE60 __tryblocktable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000DE60                                         ; DATA XREF: .xdata$x:0000DE84o
.xdata$x:0000DE61                 db    0
.xdata$x:0000DE62                 db    0
.xdata$x:0000DE63                 db    0
.xdata$x:0000DE64                 db    0
.xdata$x:0000DE65                 db    0
.xdata$x:0000DE66                 db    0
.xdata$x:0000DE67                 db    0
.xdata$x:0000DE68                 db    1
.xdata$x:0000DE69                 db    0
.xdata$x:0000DE6A                 db    0
.xdata$x:0000DE6B                 db    0
.xdata$x:0000DE6C                 db    1
.xdata$x:0000DE6D                 db    0
.xdata$x:0000DE6E                 db    0
.xdata$x:0000DE6F                 db    0
.xdata$x:0000DE70                 dd offset __catchsym$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000DE74 __ehfuncinfo$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000DE74                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000DE75                 db    5
.xdata$x:0000DE76                 db  93h ; ô
.xdata$x:0000DE77                 db  19h
.xdata$x:0000DE78                 db    2
.xdata$x:0000DE79                 db    0
.xdata$x:0000DE7A                 db    0
.xdata$x:0000DE7B                 db    0
.xdata$x:0000DE7C                 dd offset __unwindtable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.xdata$x:0000DE80                 db    1
.xdata$x:0000DE81                 db    0
.xdata$x:0000DE82                 db    0
.xdata$x:0000DE83                 db    0
.xdata$x:0000DE84                 dd offset __tryblocktable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.xdata$x:0000DE88                 db    0
.xdata$x:0000DE89                 db    0
.xdata$x:0000DE8A                 db    0
.xdata$x:0000DE8B                 db    0
.xdata$x:0000DE8C                 db    0
.xdata$x:0000DE8D                 db    0
.xdata$x:0000DE8E                 db    0
.xdata$x:0000DE8F                 db    0
.xdata$x:0000DE90                 db    0
.xdata$x:0000DE91                 db    0
.xdata$x:0000DE92                 db    0
.xdata$x:0000DE93                 db    0
.xdata$x:0000DE94                 db    0
.xdata$x:0000DE95                 db    0
.xdata$x:0000DE96                 db    0
.xdata$x:0000DE97                 db    0
.xdata$x:0000DE97 _xdata$x        ends
.xdata$x:0000DE97
.xdata$x:0000DE98 ; ===========================================================================
.xdata$x:0000DE98
.xdata$x:0000DE98 ; Segment type: Pure data
.xdata$x:0000DE98 ; Segment permissions: Read
.xdata$x:0000DE98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DE98                 assume cs:_xdata$x
.xdata$x:0000DE98                 ;org 0DE98h
.xdata$x:0000DE98 ; COMDAT (pick associative to section at A33C)
.xdata$x:0000DE98 __unwindtable$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z db 0FFh
.xdata$x:0000DE98                                         ; DATA XREF: .xdata$x:0000DEA8o
.xdata$x:0000DE99                 db 0FFh
.xdata$x:0000DE9A                 db 0FFh
.xdata$x:0000DE9B                 db 0FFh
.xdata$x:0000DE9C                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z$0
.xdata$x:0000DEA0 __ehfuncinfo$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z db  22h ; "
.xdata$x:0000DEA0                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z+11o
.xdata$x:0000DEA1                 db    5
.xdata$x:0000DEA2                 db  93h ; ô
.xdata$x:0000DEA3                 db  19h
.xdata$x:0000DEA4                 db    1
.xdata$x:0000DEA5                 db    0
.xdata$x:0000DEA6                 db    0
.xdata$x:0000DEA7                 db    0
.xdata$x:0000DEA8                 dd offset __unwindtable$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.xdata$x:0000DEAC                 db    0
.xdata$x:0000DEAD                 db    0
.xdata$x:0000DEAE                 db    0
.xdata$x:0000DEAF                 db    0
.xdata$x:0000DEB0                 db    0
.xdata$x:0000DEB1                 db    0
.xdata$x:0000DEB2                 db    0
.xdata$x:0000DEB3                 db    0
.xdata$x:0000DEB4                 db    0
.xdata$x:0000DEB5                 db    0
.xdata$x:0000DEB6                 db    0
.xdata$x:0000DEB7                 db    0
.xdata$x:0000DEB8                 db    0
.xdata$x:0000DEB9                 db    0
.xdata$x:0000DEBA                 db    0
.xdata$x:0000DEBB                 db    0
.xdata$x:0000DEBC                 db    0
.xdata$x:0000DEBD                 db    0
.xdata$x:0000DEBE                 db    0
.xdata$x:0000DEBF                 db    0
.xdata$x:0000DEC0                 db    0
.xdata$x:0000DEC1                 db    0
.xdata$x:0000DEC2                 db    0
.xdata$x:0000DEC3                 db    0
.xdata$x:0000DEC3 _xdata$x        ends
.xdata$x:0000DEC3
.xdata$x:0000DEC4 ; ===========================================================================
.xdata$x:0000DEC4
.xdata$x:0000DEC4 ; Segment type: Pure data
.xdata$x:0000DEC4 ; Segment permissions: Read
.xdata$x:0000DEC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DEC4                 assume cs:_xdata$x
.xdata$x:0000DEC4                 ;org 0DEC4h
.xdata$x:0000DEC4 ; COMDAT (pick associative to section at 4FB4)
.xdata$x:0000DEC4 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000DEC4                                         ; DATA XREF: .xdata$x:0000DED4o
.xdata$x:0000DEC5                 db 0FFh
.xdata$x:0000DEC6                 db 0FFh
.xdata$x:0000DEC7                 db 0FFh
.xdata$x:0000DEC8                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000DECC __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DECC                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000DECD                 db    5
.xdata$x:0000DECE                 db  93h ; ô
.xdata$x:0000DECF                 db  19h
.xdata$x:0000DED0                 db    1
.xdata$x:0000DED1                 db    0
.xdata$x:0000DED2                 db    0
.xdata$x:0000DED3                 db    0
.xdata$x:0000DED4                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000DED8                 db    0
.xdata$x:0000DED9                 db    0
.xdata$x:0000DEDA                 db    0
.xdata$x:0000DEDB                 db    0
.xdata$x:0000DEDC                 db    0
.xdata$x:0000DEDD                 db    0
.xdata$x:0000DEDE                 db    0
.xdata$x:0000DEDF                 db    0
.xdata$x:0000DEE0                 db    0
.xdata$x:0000DEE1                 db    0
.xdata$x:0000DEE2                 db    0
.xdata$x:0000DEE3                 db    0
.xdata$x:0000DEE4                 db    0
.xdata$x:0000DEE5                 db    0
.xdata$x:0000DEE6                 db    0
.xdata$x:0000DEE7                 db    0
.xdata$x:0000DEE8                 db    0
.xdata$x:0000DEE9                 db    0
.xdata$x:0000DEEA                 db    0
.xdata$x:0000DEEB                 db    0
.xdata$x:0000DEEC                 db    0
.xdata$x:0000DEED                 db    0
.xdata$x:0000DEEE                 db    0
.xdata$x:0000DEEF                 db    0
.xdata$x:0000DEEF _xdata$x        ends
.xdata$x:0000DEEF
.xdata$x:0000DEF0 ; ===========================================================================
.xdata$x:0000DEF0
.xdata$x:0000DEF0 ; Segment type: Pure data
.xdata$x:0000DEF0 ; Segment permissions: Read
.xdata$x:0000DEF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DEF0                 assume cs:_xdata$x
.xdata$x:0000DEF0                 ;org 0DEF0h
.xdata$x:0000DEF0 ; COMDAT (pick associative to section at 6C3C)
.xdata$x:0000DEF0 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000DEF0                                         ; DATA XREF: .xdata$x:0000DF00o
.xdata$x:0000DEF1                 db 0FFh
.xdata$x:0000DEF2                 db 0FFh
.xdata$x:0000DEF3                 db 0FFh
.xdata$x:0000DEF4                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000DEF8 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DEF8                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000DEF9                 db    5
.xdata$x:0000DEFA                 db  93h ; ô
.xdata$x:0000DEFB                 db  19h
.xdata$x:0000DEFC                 db    1
.xdata$x:0000DEFD                 db    0
.xdata$x:0000DEFE                 db    0
.xdata$x:0000DEFF                 db    0
.xdata$x:0000DF00                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000DF04                 db    0
.xdata$x:0000DF05                 db    0
.xdata$x:0000DF06                 db    0
.xdata$x:0000DF07                 db    0
.xdata$x:0000DF08                 db    0
.xdata$x:0000DF09                 db    0
.xdata$x:0000DF0A                 db    0
.xdata$x:0000DF0B                 db    0
.xdata$x:0000DF0C                 db    0
.xdata$x:0000DF0D                 db    0
.xdata$x:0000DF0E                 db    0
.xdata$x:0000DF0F                 db    0
.xdata$x:0000DF10                 db    0
.xdata$x:0000DF11                 db    0
.xdata$x:0000DF12                 db    0
.xdata$x:0000DF13                 db    0
.xdata$x:0000DF14                 db    0
.xdata$x:0000DF15                 db    0
.xdata$x:0000DF16                 db    0
.xdata$x:0000DF17                 db    0
.xdata$x:0000DF18                 db    0
.xdata$x:0000DF19                 db    0
.xdata$x:0000DF1A                 db    0
.xdata$x:0000DF1B                 db    0
.xdata$x:0000DF1B _xdata$x        ends
.xdata$x:0000DF1B
.xdata$x:0000DF1C ; ===========================================================================
.xdata$x:0000DF1C
.xdata$x:0000DF1C ; Segment type: Pure data
.xdata$x:0000DF1C ; Segment permissions: Read
.xdata$x:0000DF1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DF1C                 assume cs:_xdata$x
.xdata$x:0000DF1C                 ;org 0DF1Ch
.xdata$x:0000DF1C ; COMDAT (pick associative to section at 4F3C)
.xdata$x:0000DF1C __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000DF1C                                         ; DATA XREF: .xdata$x:0000DF2Co
.xdata$x:0000DF1D                 db 0FFh
.xdata$x:0000DF1E                 db 0FFh
.xdata$x:0000DF1F                 db 0FFh
.xdata$x:0000DF20                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000DF24 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000DF24                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000DF25                 db    5
.xdata$x:0000DF26                 db  93h ; ô
.xdata$x:0000DF27                 db  19h
.xdata$x:0000DF28                 db    1
.xdata$x:0000DF29                 db    0
.xdata$x:0000DF2A                 db    0
.xdata$x:0000DF2B                 db    0
.xdata$x:0000DF2C                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VMacroShortcut@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000DF30                 db    0
.xdata$x:0000DF31                 db    0
.xdata$x:0000DF32                 db    0
.xdata$x:0000DF33                 db    0
.xdata$x:0000DF34                 db    0
.xdata$x:0000DF35                 db    0
.xdata$x:0000DF36                 db    0
.xdata$x:0000DF37                 db    0
.xdata$x:0000DF38                 db    0
.xdata$x:0000DF39                 db    0
.xdata$x:0000DF3A                 db    0
.xdata$x:0000DF3B                 db    0
.xdata$x:0000DF3C                 db    0
.xdata$x:0000DF3D                 db    0
.xdata$x:0000DF3E                 db    0
.xdata$x:0000DF3F                 db    0
.xdata$x:0000DF40                 db    0
.xdata$x:0000DF41                 db    0
.xdata$x:0000DF42                 db    0
.xdata$x:0000DF43                 db    0
.xdata$x:0000DF44                 db    0
.xdata$x:0000DF45                 db    0
.xdata$x:0000DF46                 db    0
.xdata$x:0000DF47                 db    0
.xdata$x:0000DF47 _xdata$x        ends
.xdata$x:0000DF47
.xdata$x:0000DF48 ; ===========================================================================
.xdata$x:0000DF48
.xdata$x:0000DF48 ; Segment type: Pure data
.xdata$x:0000DF48 ; Segment permissions: Read
.xdata$x:0000DF48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DF48                 assume cs:_xdata$x
.xdata$x:0000DF48                 ;org 0DF48h
.xdata$x:0000DF48 ; COMDAT (pick associative to section at 5734)
.xdata$x:0000DF48 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000DF48                                         ; DATA XREF: .xdata$x:0000DF58o
.xdata$x:0000DF49                 db 0FFh
.xdata$x:0000DF4A                 db 0FFh
.xdata$x:0000DF4B                 db 0FFh
.xdata$x:0000DF4C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z$0
.xdata$x:0000DF50 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000DF50                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000DF51                 db    5
.xdata$x:0000DF52                 db  93h ; ô
.xdata$x:0000DF53                 db  19h
.xdata$x:0000DF54                 db    1
.xdata$x:0000DF55                 db    0
.xdata$x:0000DF56                 db    0
.xdata$x:0000DF57                 db    0
.xdata$x:0000DF58                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.xdata$x:0000DF5C                 db    0
.xdata$x:0000DF5D                 db    0
.xdata$x:0000DF5E                 db    0
.xdata$x:0000DF5F                 db    0
.xdata$x:0000DF60                 db    0
.xdata$x:0000DF61                 db    0
.xdata$x:0000DF62                 db    0
.xdata$x:0000DF63                 db    0
.xdata$x:0000DF64                 db    0
.xdata$x:0000DF65                 db    0
.xdata$x:0000DF66                 db    0
.xdata$x:0000DF67                 db    0
.xdata$x:0000DF68                 db    0
.xdata$x:0000DF69                 db    0
.xdata$x:0000DF6A                 db    0
.xdata$x:0000DF6B                 db    0
.xdata$x:0000DF6C                 db    0
.xdata$x:0000DF6D                 db    0
.xdata$x:0000DF6E                 db    0
.xdata$x:0000DF6F                 db    0
.xdata$x:0000DF70                 db    0
.xdata$x:0000DF71                 db    0
.xdata$x:0000DF72                 db    0
.xdata$x:0000DF73                 db    0
.xdata$x:0000DF73 _xdata$x        ends
.xdata$x:0000DF73
.xdata$x:0000DF74 ; ===========================================================================
.xdata$x:0000DF74
.xdata$x:0000DF74 ; Segment type: Pure data
.xdata$x:0000DF74 ; Segment permissions: Read
.xdata$x:0000DF74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DF74                 assume cs:_xdata$x
.xdata$x:0000DF74                 ;org 0DF74h
.xdata$x:0000DF74 ; COMDAT (pick associative to section at 7134)
.xdata$x:0000DF74 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000DF74                                         ; DATA XREF: .xdata$x:0000DF84o
.xdata$x:0000DF75                 db 0FFh
.xdata$x:0000DF76                 db 0FFh
.xdata$x:0000DF77                 db 0FFh
.xdata$x:0000DF78                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000DF7C __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000DF7C                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000DF7D                 db    5
.xdata$x:0000DF7E                 db  93h ; ô
.xdata$x:0000DF7F                 db  19h
.xdata$x:0000DF80                 db    1
.xdata$x:0000DF81                 db    0
.xdata$x:0000DF82                 db    0
.xdata$x:0000DF83                 db    0
.xdata$x:0000DF84                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000DF88                 align 20h
.xdata$x:0000DF88 _xdata$x        ends
.xdata$x:0000DF88
.xdata$x:0000DFA0 ; ===========================================================================
.xdata$x:0000DFA0
.xdata$x:0000DFA0 ; Segment type: Pure data
.xdata$x:0000DFA0 ; Segment permissions: Read
.xdata$x:0000DFA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DFA0                 assume cs:_xdata$x
.xdata$x:0000DFA0                 ;org 0DFA0h
.xdata$x:0000DFA0 ; COMDAT (pick associative to section at 56B0)
.xdata$x:0000DFA0 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000DFA0                                         ; DATA XREF: .xdata$x:0000DFB0o
.xdata$x:0000DFA1                 db 0FFh
.xdata$x:0000DFA2                 db 0FFh
.xdata$x:0000DFA3                 db 0FFh
.xdata$x:0000DFA4                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000DFA8 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000DFA8                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000DFA9                 db    5
.xdata$x:0000DFAA                 db  93h ; ô
.xdata$x:0000DFAB                 db  19h
.xdata$x:0000DFAC                 db    1
.xdata$x:0000DFAD                 db    0
.xdata$x:0000DFAE                 db    0
.xdata$x:0000DFAF                 db    0
.xdata$x:0000DFB0                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000DFB4                 db    0
.xdata$x:0000DFB5                 db    0
.xdata$x:0000DFB6                 db    0
.xdata$x:0000DFB7                 db    0
.xdata$x:0000DFB8                 db    0
.xdata$x:0000DFB9                 db    0
.xdata$x:0000DFBA                 db    0
.xdata$x:0000DFBB                 db    0
.xdata$x:0000DFBC                 db    0
.xdata$x:0000DFBD                 db    0
.xdata$x:0000DFBE                 db    0
.xdata$x:0000DFBF                 db    0
.xdata$x:0000DFC0                 db    0
.xdata$x:0000DFC1                 db    0
.xdata$x:0000DFC2                 db    0
.xdata$x:0000DFC3                 db    0
.xdata$x:0000DFC4                 db    0
.xdata$x:0000DFC5                 db    0
.xdata$x:0000DFC6                 db    0
.xdata$x:0000DFC7                 db    0
.xdata$x:0000DFC8                 db    0
.xdata$x:0000DFC9                 db    0
.xdata$x:0000DFCA                 db    0
.xdata$x:0000DFCB                 db    0
.xdata$x:0000DFCB _xdata$x        ends
.xdata$x:0000DFCB
.xdata$x:0000DFCC ; ===========================================================================
.xdata$x:0000DFCC
.xdata$x:0000DFCC ; Segment type: Pure data
.xdata$x:0000DFCC ; Segment permissions: Read
.xdata$x:0000DFCC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DFCC                 assume cs:_xdata$x
.xdata$x:0000DFCC                 ;org 0DFCCh
.xdata$x:0000DFCC ; COMDAT (pick associative to section at 5948)
.xdata$x:0000DFCC __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000DFCC                                         ; DATA XREF: .xdata$x:0000DFDCo
.xdata$x:0000DFCD                 db 0FFh
.xdata$x:0000DFCE                 db 0FFh
.xdata$x:0000DFCF                 db 0FFh
.xdata$x:0000DFD0                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z$0
.xdata$x:0000DFD4 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000DFD4                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000DFD5                 db    5
.xdata$x:0000DFD6                 db  93h ; ô
.xdata$x:0000DFD7                 db  19h
.xdata$x:0000DFD8                 db    1
.xdata$x:0000DFD9                 db    0
.xdata$x:0000DFDA                 db    0
.xdata$x:0000DFDB                 db    0
.xdata$x:0000DFDC                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@PAVMacroShortcut@@PBU_Container_base12@1@@Z
.xdata$x:0000DFE0                 db    0
.xdata$x:0000DFE1                 db    0
.xdata$x:0000DFE2                 db    0
.xdata$x:0000DFE3                 db    0
.xdata$x:0000DFE4                 db    0
.xdata$x:0000DFE5                 db    0
.xdata$x:0000DFE6                 db    0
.xdata$x:0000DFE7                 db    0
.xdata$x:0000DFE8                 db    0
.xdata$x:0000DFE9                 db    0
.xdata$x:0000DFEA                 db    0
.xdata$x:0000DFEB                 db    0
.xdata$x:0000DFEC                 db    0
.xdata$x:0000DFED                 db    0
.xdata$x:0000DFEE                 db    0
.xdata$x:0000DFEF                 db    0
.xdata$x:0000DFF0                 db    0
.xdata$x:0000DFF1                 db    0
.xdata$x:0000DFF2                 db    0
.xdata$x:0000DFF3                 db    0
.xdata$x:0000DFF4                 db    0
.xdata$x:0000DFF5                 db    0
.xdata$x:0000DFF6                 db    0
.xdata$x:0000DFF7                 db    0
.xdata$x:0000DFF7 _xdata$x        ends
.xdata$x:0000DFF7
.xdata$x:0000DFF8 ; ===========================================================================
.xdata$x:0000DFF8
.xdata$x:0000DFF8 ; Segment type: Pure data
.xdata$x:0000DFF8 ; Segment permissions: Read
.xdata$x:0000DFF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DFF8                 assume cs:_xdata$x
.xdata$x:0000DFF8                 ;org 0DFF8h
.xdata$x:0000DFF8 ; COMDAT (pick associative to section at 8BE8)
.xdata$x:0000DFF8 __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000DFF8                                         ; DATA XREF: .xdata$x:0000E010o
.xdata$x:0000DFF9                 db 0FFh
.xdata$x:0000DFFA                 db 0FFh
.xdata$x:0000DFFB                 db 0FFh
.xdata$x:0000DFFC                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000E000                 db    0
.xdata$x:0000E001                 db    0
.xdata$x:0000E002                 db    0
.xdata$x:0000E003                 db    0
.xdata$x:0000E004                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000E008 __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000E008                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000E009                 db    5
.xdata$x:0000E00A                 db  93h ; ô
.xdata$x:0000E00B                 db  19h
.xdata$x:0000E00C                 db    2
.xdata$x:0000E00D                 db    0
.xdata$x:0000E00E                 db    0
.xdata$x:0000E00F                 db    0
.xdata$x:0000E010                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000E014                 db    0
.xdata$x:0000E015                 db    0
.xdata$x:0000E016                 db    0
.xdata$x:0000E017                 db    0
.xdata$x:0000E018                 db    0
.xdata$x:0000E019                 db    0
.xdata$x:0000E01A                 db    0
.xdata$x:0000E01B                 db    0
.xdata$x:0000E01C                 db    0
.xdata$x:0000E01D                 db    0
.xdata$x:0000E01E                 db    0
.xdata$x:0000E01F                 db    0
.xdata$x:0000E020                 db    0
.xdata$x:0000E021                 db    0
.xdata$x:0000E022                 db    0
.xdata$x:0000E023                 db    0
.xdata$x:0000E024                 db    0
.xdata$x:0000E025                 db    0
.xdata$x:0000E026                 db    0
.xdata$x:0000E027                 db    0
.xdata$x:0000E028                 db    0
.xdata$x:0000E029                 db    0
.xdata$x:0000E02A                 db    0
.xdata$x:0000E02B                 db    0
.xdata$x:0000E02B _xdata$x        ends
.xdata$x:0000E02B
.xdata$x:0000E02C ; ===========================================================================
.xdata$x:0000E02C
.xdata$x:0000E02C ; Segment type: Pure data
.xdata$x:0000E02C ; Segment permissions: Read
.xdata$x:0000E02C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E02C                 assume cs:_xdata$x
.xdata$x:0000E02C                 ;org 0E02Ch
.xdata$x:0000E02C ; COMDAT (pick associative to section at 7214)
.xdata$x:0000E02C __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E02C                                         ; DATA XREF: .xdata$x:0000E03Co
.xdata$x:0000E02D                 db 0FFh
.xdata$x:0000E02E                 db 0FFh
.xdata$x:0000E02F                 db 0FFh
.xdata$x:0000E030                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E034 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E034                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E035                 db    5
.xdata$x:0000E036                 db  93h ; ô
.xdata$x:0000E037                 db  19h
.xdata$x:0000E038                 db    1
.xdata$x:0000E039                 db    0
.xdata$x:0000E03A                 db    0
.xdata$x:0000E03B                 db    0
.xdata$x:0000E03C                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E040                 db    0
.xdata$x:0000E041                 db    0
.xdata$x:0000E042                 db    0
.xdata$x:0000E043                 db    0
.xdata$x:0000E044                 db    0
.xdata$x:0000E045                 db    0
.xdata$x:0000E046                 db    0
.xdata$x:0000E047                 db    0
.xdata$x:0000E048                 db    0
.xdata$x:0000E049                 db    0
.xdata$x:0000E04A                 db    0
.xdata$x:0000E04B                 db    0
.xdata$x:0000E04C                 db    0
.xdata$x:0000E04D                 db    0
.xdata$x:0000E04E                 db    0
.xdata$x:0000E04F                 db    0
.xdata$x:0000E050                 db    0
.xdata$x:0000E051                 db    0
.xdata$x:0000E052                 db    0
.xdata$x:0000E053                 db    0
.xdata$x:0000E054                 db    0
.xdata$x:0000E055                 db    0
.xdata$x:0000E056                 db    0
.xdata$x:0000E057                 db    0
.xdata$x:0000E057 _xdata$x        ends
.xdata$x:0000E057
.xdata$x:0000E058 ; ===========================================================================
.xdata$x:0000E058
.xdata$x:0000E058 ; Segment type: Pure data
.xdata$x:0000E058 ; Segment permissions: Read
.xdata$x:0000E058 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E058                 assume cs:_xdata$x
.xdata$x:0000E058                 ;org 0E058h
.xdata$x:0000E058 ; COMDAT (pick associative to section at 58D0)
.xdata$x:0000E058 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000E058                                         ; DATA XREF: .xdata$x:0000E068o
.xdata$x:0000E059                 db 0FFh
.xdata$x:0000E05A                 db 0FFh
.xdata$x:0000E05B                 db 0FFh
.xdata$x:0000E05C                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000E060 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000E060                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000E061                 db    5
.xdata$x:0000E062                 db  93h ; ô
.xdata$x:0000E063                 db  19h
.xdata$x:0000E064                 db    1
.xdata$x:0000E065                 db    0
.xdata$x:0000E066                 db    0
.xdata$x:0000E067                 db    0
.xdata$x:0000E068                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VMacroShortcut@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000E06C                 db    0
.xdata$x:0000E06D                 db    0
.xdata$x:0000E06E                 db    0
.xdata$x:0000E06F                 db    0
.xdata$x:0000E070                 db    0
.xdata$x:0000E071                 db    0
.xdata$x:0000E072                 db    0
.xdata$x:0000E073                 db    0
.xdata$x:0000E074                 db    0
.xdata$x:0000E075                 db    0
.xdata$x:0000E076                 db    0
.xdata$x:0000E077                 db    0
.xdata$x:0000E078                 db    0
.xdata$x:0000E079                 db    0
.xdata$x:0000E07A                 db    0
.xdata$x:0000E07B                 db    0
.xdata$x:0000E07C                 db    0
.xdata$x:0000E07D                 db    0
.xdata$x:0000E07E                 db    0
.xdata$x:0000E07F                 db    0
.xdata$x:0000E080                 db    0
.xdata$x:0000E081                 db    0
.xdata$x:0000E082                 db    0
.xdata$x:0000E083                 db    0
.xdata$x:0000E083 _xdata$x        ends
.xdata$x:0000E083
.xdata$x:0000E084 ; ===========================================================================
.xdata$x:0000E084
.xdata$x:0000E084 ; Segment type: Pure data
.xdata$x:0000E084 ; Segment permissions: Read
.xdata$x:0000E084 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E084                 assume cs:_xdata$x
.xdata$x:0000E084                 ;org 0E084h
.xdata$x:0000E084 ; COMDAT (pick associative to section at 50A0)
.xdata$x:0000E084 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E084                                         ; DATA XREF: .xdata$x:0000E094o
.xdata$x:0000E085                 db 0FFh
.xdata$x:0000E086                 db 0FFh
.xdata$x:0000E087                 db 0FFh
.xdata$x:0000E088                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000E08C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E08C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000E08D                 db    5
.xdata$x:0000E08E                 db  93h ; ô
.xdata$x:0000E08F                 db  19h
.xdata$x:0000E090                 db    1
.xdata$x:0000E091                 db    0
.xdata$x:0000E092                 db    0
.xdata$x:0000E093                 db    0
.xdata$x:0000E094                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000E098                 db    0
.xdata$x:0000E099                 db    0
.xdata$x:0000E09A                 db    0
.xdata$x:0000E09B                 db    0
.xdata$x:0000E09C                 db    0
.xdata$x:0000E09D                 db    0
.xdata$x:0000E09E                 db    0
.xdata$x:0000E09F                 db    0
.xdata$x:0000E0A0                 db    0
.xdata$x:0000E0A1                 db    0
.xdata$x:0000E0A2                 db    0
.xdata$x:0000E0A3                 db    0
.xdata$x:0000E0A4                 db    0
.xdata$x:0000E0A5                 db    0
.xdata$x:0000E0A6                 db    0
.xdata$x:0000E0A7                 db    0
.xdata$x:0000E0A8                 db    0
.xdata$x:0000E0A9                 db    0
.xdata$x:0000E0AA                 db    0
.xdata$x:0000E0AB                 db    0
.xdata$x:0000E0AC                 db    0
.xdata$x:0000E0AD                 db    0
.xdata$x:0000E0AE                 db    0
.xdata$x:0000E0AF                 db    0
.xdata$x:0000E0AF _xdata$x        ends
.xdata$x:0000E0AF
.xdata$x:0000E0B0 ; ===========================================================================
.xdata$x:0000E0B0
.xdata$x:0000E0B0 ; Segment type: Pure data
.xdata$x:0000E0B0 ; Segment permissions: Read
.xdata$x:0000E0B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E0B0                 assume cs:_xdata$x
.xdata$x:0000E0B0                 ;org 0E0B0h
.xdata$x:0000E0B0 ; COMDAT (pick associative to section at 6CAC)
.xdata$x:0000E0B0 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E0B0                                         ; DATA XREF: .xdata$x:0000E0C0o
.xdata$x:0000E0B1                 db 0FFh
.xdata$x:0000E0B2                 db 0FFh
.xdata$x:0000E0B3                 db 0FFh
.xdata$x:0000E0B4                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000E0B8 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E0B8                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000E0B9                 db    5
.xdata$x:0000E0BA                 db  93h ; ô
.xdata$x:0000E0BB                 db  19h
.xdata$x:0000E0BC                 db    1
.xdata$x:0000E0BD                 db    0
.xdata$x:0000E0BE                 db    0
.xdata$x:0000E0BF                 db    0
.xdata$x:0000E0C0                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000E0C4                 db    0
.xdata$x:0000E0C5                 db    0
.xdata$x:0000E0C6                 db    0
.xdata$x:0000E0C7                 db    0
.xdata$x:0000E0C8                 db    0
.xdata$x:0000E0C9                 db    0
.xdata$x:0000E0CA                 db    0
.xdata$x:0000E0CB                 db    0
.xdata$x:0000E0CC                 db    0
.xdata$x:0000E0CD                 db    0
.xdata$x:0000E0CE                 db    0
.xdata$x:0000E0CF                 db    0
.xdata$x:0000E0D0                 db    0
.xdata$x:0000E0D1                 db    0
.xdata$x:0000E0D2                 db    0
.xdata$x:0000E0D3                 db    0
.xdata$x:0000E0D4                 db    0
.xdata$x:0000E0D5                 db    0
.xdata$x:0000E0D6                 db    0
.xdata$x:0000E0D7                 db    0
.xdata$x:0000E0D8                 db    0
.xdata$x:0000E0D9                 db    0
.xdata$x:0000E0DA                 db    0
.xdata$x:0000E0DB                 db    0
.xdata$x:0000E0DB _xdata$x        ends
.xdata$x:0000E0DB
.xdata$x:0000E0DC ; ===========================================================================
.xdata$x:0000E0DC
.xdata$x:0000E0DC ; Segment type: Pure data
.xdata$x:0000E0DC ; Segment permissions: Read
.xdata$x:0000E0DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E0DC                 assume cs:_xdata$x
.xdata$x:0000E0DC                 ;org 0E0DCh
.xdata$x:0000E0DC ; COMDAT (pick associative to section at 5028)
.xdata$x:0000E0DC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000E0DC                                         ; DATA XREF: .xdata$x:0000E0ECo
.xdata$x:0000E0DD                 db 0FFh
.xdata$x:0000E0DE                 db 0FFh
.xdata$x:0000E0DF                 db 0FFh
.xdata$x:0000E0E0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000E0E4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000E0E4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000E0E5                 db    5
.xdata$x:0000E0E6                 db  93h ; ô
.xdata$x:0000E0E7                 db  19h
.xdata$x:0000E0E8                 db    1
.xdata$x:0000E0E9                 db    0
.xdata$x:0000E0EA                 db    0
.xdata$x:0000E0EB                 db    0
.xdata$x:0000E0EC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@VUserCommand@@HPBV3@ABV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000E0F0                 db    0
.xdata$x:0000E0F1                 db    0
.xdata$x:0000E0F2                 db    0
.xdata$x:0000E0F3                 db    0
.xdata$x:0000E0F4                 db    0
.xdata$x:0000E0F5                 db    0
.xdata$x:0000E0F6                 db    0
.xdata$x:0000E0F7                 db    0
.xdata$x:0000E0F8                 db    0
.xdata$x:0000E0F9                 db    0
.xdata$x:0000E0FA                 db    0
.xdata$x:0000E0FB                 db    0
.xdata$x:0000E0FC                 db    0
.xdata$x:0000E0FD                 db    0
.xdata$x:0000E0FE                 db    0
.xdata$x:0000E0FF                 db    0
.xdata$x:0000E100                 db    0
.xdata$x:0000E101                 db    0
.xdata$x:0000E102                 db    0
.xdata$x:0000E103                 db    0
.xdata$x:0000E104                 db    0
.xdata$x:0000E105                 db    0
.xdata$x:0000E106                 db    0
.xdata$x:0000E107                 db    0
.xdata$x:0000E107 _xdata$x        ends
.xdata$x:0000E107
.xdata$x:0000E108 ; ===========================================================================
.xdata$x:0000E108
.xdata$x:0000E108 ; Segment type: Pure data
.xdata$x:0000E108 ; Segment permissions: Read
.xdata$x:0000E108 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E108                 assume cs:_xdata$x
.xdata$x:0000E108                 ;org 0E108h
.xdata$x:0000E108 ; COMDAT (pick associative to section at 5844)
.xdata$x:0000E108 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000E108                                         ; DATA XREF: .xdata$x:0000E118o
.xdata$x:0000E109                 db 0FFh
.xdata$x:0000E10A                 db 0FFh
.xdata$x:0000E10B                 db 0FFh
.xdata$x:0000E10C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z$0
.xdata$x:0000E110 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000E110                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000E111                 db    5
.xdata$x:0000E112                 db  93h ; ô
.xdata$x:0000E113                 db  19h
.xdata$x:0000E114                 db    1
.xdata$x:0000E115                 db    0
.xdata$x:0000E116                 db    0
.xdata$x:0000E117                 db    0
.xdata$x:0000E118                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.xdata$x:0000E11C                 db    0
.xdata$x:0000E11D                 db    0
.xdata$x:0000E11E                 db    0
.xdata$x:0000E11F                 db    0
.xdata$x:0000E120                 db    0
.xdata$x:0000E121                 db    0
.xdata$x:0000E122                 db    0
.xdata$x:0000E123                 db    0
.xdata$x:0000E124                 db    0
.xdata$x:0000E125                 db    0
.xdata$x:0000E126                 db    0
.xdata$x:0000E127                 db    0
.xdata$x:0000E128                 db    0
.xdata$x:0000E129                 db    0
.xdata$x:0000E12A                 db    0
.xdata$x:0000E12B                 db    0
.xdata$x:0000E12C                 db    0
.xdata$x:0000E12D                 db    0
.xdata$x:0000E12E                 db    0
.xdata$x:0000E12F                 db    0
.xdata$x:0000E130                 db    0
.xdata$x:0000E131                 db    0
.xdata$x:0000E132                 db    0
.xdata$x:0000E133                 db    0
.xdata$x:0000E133 _xdata$x        ends
.xdata$x:0000E133
.xdata$x:0000E134 ; ===========================================================================
.xdata$x:0000E134
.xdata$x:0000E134 ; Segment type: Pure data
.xdata$x:0000E134 ; Segment permissions: Read
.xdata$x:0000E134 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E134                 assume cs:_xdata$x
.xdata$x:0000E134                 ;org 0E134h
.xdata$x:0000E134 ; COMDAT (pick associative to section at 71A4)
.xdata$x:0000E134 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E134                                         ; DATA XREF: .xdata$x:0000E144o
.xdata$x:0000E135                 db 0FFh
.xdata$x:0000E136                 db 0FFh
.xdata$x:0000E137                 db 0FFh
.xdata$x:0000E138                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E13C __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E13C                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E13D                 db    5
.xdata$x:0000E13E                 db  93h ; ô
.xdata$x:0000E13F                 db  19h
.xdata$x:0000E140                 db    1
.xdata$x:0000E141                 db    0
.xdata$x:0000E142                 db    0
.xdata$x:0000E143                 db    0
.xdata$x:0000E144                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E148                 align 20h
.xdata$x:0000E148 _xdata$x        ends
.xdata$x:0000E148
.xdata$x:0000E160 ; ===========================================================================
.xdata$x:0000E160
.xdata$x:0000E160 ; Segment type: Pure data
.xdata$x:0000E160 ; Segment permissions: Read
.xdata$x:0000E160 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E160                 assume cs:_xdata$x
.xdata$x:0000E160                 ;org 0E160h
.xdata$x:0000E160 ; COMDAT (pick associative to section at 57C0)
.xdata$x:0000E160 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000E160                                         ; DATA XREF: .xdata$x:0000E170o
.xdata$x:0000E161                 db 0FFh
.xdata$x:0000E162                 db 0FFh
.xdata$x:0000E163                 db 0FFh
.xdata$x:0000E164                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000E168 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000E168                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000E169                 db    5
.xdata$x:0000E16A                 db  93h ; ô
.xdata$x:0000E16B                 db  19h
.xdata$x:0000E16C                 db    1
.xdata$x:0000E16D                 db    0
.xdata$x:0000E16E                 db    0
.xdata$x:0000E16F                 db    0
.xdata$x:0000E170                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000E174                 db    0
.xdata$x:0000E175                 db    0
.xdata$x:0000E176                 db    0
.xdata$x:0000E177                 db    0
.xdata$x:0000E178                 db    0
.xdata$x:0000E179                 db    0
.xdata$x:0000E17A                 db    0
.xdata$x:0000E17B                 db    0
.xdata$x:0000E17C                 db    0
.xdata$x:0000E17D                 db    0
.xdata$x:0000E17E                 db    0
.xdata$x:0000E17F                 db    0
.xdata$x:0000E180                 db    0
.xdata$x:0000E181                 db    0
.xdata$x:0000E182                 db    0
.xdata$x:0000E183                 db    0
.xdata$x:0000E184                 db    0
.xdata$x:0000E185                 db    0
.xdata$x:0000E186                 db    0
.xdata$x:0000E187                 db    0
.xdata$x:0000E188                 db    0
.xdata$x:0000E189                 db    0
.xdata$x:0000E18A                 db    0
.xdata$x:0000E18B                 db    0
.xdata$x:0000E18B _xdata$x        ends
.xdata$x:0000E18B
.xdata$x:0000E18C ; ===========================================================================
.xdata$x:0000E18C
.xdata$x:0000E18C ; Segment type: Pure data
.xdata$x:0000E18C ; Segment permissions: Read
.xdata$x:0000E18C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E18C                 assume cs:_xdata$x
.xdata$x:0000E18C                 ;org 0E18Ch
.xdata$x:0000E18C ; COMDAT (pick associative to section at 5A3C)
.xdata$x:0000E18C __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000E18C                                         ; DATA XREF: .xdata$x:0000E19Co
.xdata$x:0000E18D                 db 0FFh
.xdata$x:0000E18E                 db 0FFh
.xdata$x:0000E18F                 db 0FFh
.xdata$x:0000E190                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z$0
.xdata$x:0000E194 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000E194                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000E195                 db    5
.xdata$x:0000E196                 db  93h ; ô
.xdata$x:0000E197                 db  19h
.xdata$x:0000E198                 db    1
.xdata$x:0000E199                 db    0
.xdata$x:0000E19A                 db    0
.xdata$x:0000E19B                 db    0
.xdata$x:0000E19C                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@PAVUserCommand@@PBU_Container_base12@1@@Z
.xdata$x:0000E1A0                 db    0
.xdata$x:0000E1A1                 db    0
.xdata$x:0000E1A2                 db    0
.xdata$x:0000E1A3                 db    0
.xdata$x:0000E1A4                 db    0
.xdata$x:0000E1A5                 db    0
.xdata$x:0000E1A6                 db    0
.xdata$x:0000E1A7                 db    0
.xdata$x:0000E1A8                 db    0
.xdata$x:0000E1A9                 db    0
.xdata$x:0000E1AA                 db    0
.xdata$x:0000E1AB                 db    0
.xdata$x:0000E1AC                 db    0
.xdata$x:0000E1AD                 db    0
.xdata$x:0000E1AE                 db    0
.xdata$x:0000E1AF                 db    0
.xdata$x:0000E1B0                 db    0
.xdata$x:0000E1B1                 db    0
.xdata$x:0000E1B2                 db    0
.xdata$x:0000E1B3                 db    0
.xdata$x:0000E1B4                 db    0
.xdata$x:0000E1B5                 db    0
.xdata$x:0000E1B6                 db    0
.xdata$x:0000E1B7                 db    0
.xdata$x:0000E1B7 _xdata$x        ends
.xdata$x:0000E1B7
.xdata$x:0000E1B8 ; ===========================================================================
.xdata$x:0000E1B8
.xdata$x:0000E1B8 ; Segment type: Pure data
.xdata$x:0000E1B8 ; Segment permissions: Read
.xdata$x:0000E1B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E1B8                 assume cs:_xdata$x
.xdata$x:0000E1B8                 ;org 0E1B8h
.xdata$x:0000E1B8 ; COMDAT (pick associative to section at 8CA4)
.xdata$x:0000E1B8 __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000E1B8                                         ; DATA XREF: .xdata$x:0000E1D0o
.xdata$x:0000E1B9                 db 0FFh
.xdata$x:0000E1BA                 db 0FFh
.xdata$x:0000E1BB                 db 0FFh
.xdata$x:0000E1BC                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000E1C0                 db    0
.xdata$x:0000E1C1                 db    0
.xdata$x:0000E1C2                 db    0
.xdata$x:0000E1C3                 db    0
.xdata$x:0000E1C4                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000E1C8 __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000E1C8                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000E1C9                 db    5
.xdata$x:0000E1CA                 db  93h ; ô
.xdata$x:0000E1CB                 db  19h
.xdata$x:0000E1CC                 db    2
.xdata$x:0000E1CD                 db    0
.xdata$x:0000E1CE                 db    0
.xdata$x:0000E1CF                 db    0
.xdata$x:0000E1D0                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000E1D4                 db    0
.xdata$x:0000E1D5                 db    0
.xdata$x:0000E1D6                 db    0
.xdata$x:0000E1D7                 db    0
.xdata$x:0000E1D8                 db    0
.xdata$x:0000E1D9                 db    0
.xdata$x:0000E1DA                 db    0
.xdata$x:0000E1DB                 db    0
.xdata$x:0000E1DC                 db    0
.xdata$x:0000E1DD                 db    0
.xdata$x:0000E1DE                 db    0
.xdata$x:0000E1DF                 db    0
.xdata$x:0000E1E0                 db    0
.xdata$x:0000E1E1                 db    0
.xdata$x:0000E1E2                 db    0
.xdata$x:0000E1E3                 db    0
.xdata$x:0000E1E4                 db    0
.xdata$x:0000E1E5                 db    0
.xdata$x:0000E1E6                 db    0
.xdata$x:0000E1E7                 db    0
.xdata$x:0000E1E8                 db    0
.xdata$x:0000E1E9                 db    0
.xdata$x:0000E1EA                 db    0
.xdata$x:0000E1EB                 db    0
.xdata$x:0000E1EB _xdata$x        ends
.xdata$x:0000E1EB
.xdata$x:0000E1EC ; ===========================================================================
.xdata$x:0000E1EC
.xdata$x:0000E1EC ; Segment type: Pure data
.xdata$x:0000E1EC ; Segment permissions: Read
.xdata$x:0000E1EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E1EC                 assume cs:_xdata$x
.xdata$x:0000E1EC                 ;org 0E1ECh
.xdata$x:0000E1EC ; COMDAT (pick associative to section at 7284)
.xdata$x:0000E1EC __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E1EC                                         ; DATA XREF: .xdata$x:0000E1FCo
.xdata$x:0000E1ED                 db 0FFh
.xdata$x:0000E1EE                 db 0FFh
.xdata$x:0000E1EF                 db 0FFh
.xdata$x:0000E1F0                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E1F4 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E1F4                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E1F5                 db    5
.xdata$x:0000E1F6                 db  93h ; ô
.xdata$x:0000E1F7                 db  19h
.xdata$x:0000E1F8                 db    1
.xdata$x:0000E1F9                 db    0
.xdata$x:0000E1FA                 db    0
.xdata$x:0000E1FB                 db    0
.xdata$x:0000E1FC                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E200                 db    0
.xdata$x:0000E201                 db    0
.xdata$x:0000E202                 db    0
.xdata$x:0000E203                 db    0
.xdata$x:0000E204                 db    0
.xdata$x:0000E205                 db    0
.xdata$x:0000E206                 db    0
.xdata$x:0000E207                 db    0
.xdata$x:0000E208                 db    0
.xdata$x:0000E209                 db    0
.xdata$x:0000E20A                 db    0
.xdata$x:0000E20B                 db    0
.xdata$x:0000E20C                 db    0
.xdata$x:0000E20D                 db    0
.xdata$x:0000E20E                 db    0
.xdata$x:0000E20F                 db    0
.xdata$x:0000E210                 db    0
.xdata$x:0000E211                 db    0
.xdata$x:0000E212                 db    0
.xdata$x:0000E213                 db    0
.xdata$x:0000E214                 db    0
.xdata$x:0000E215                 db    0
.xdata$x:0000E216                 db    0
.xdata$x:0000E217                 db    0
.xdata$x:0000E217 _xdata$x        ends
.xdata$x:0000E217
.xdata$x:0000E218 ; ===========================================================================
.xdata$x:0000E218
.xdata$x:0000E218 ; Segment type: Pure data
.xdata$x:0000E218 ; Segment permissions: Read
.xdata$x:0000E218 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E218                 assume cs:_xdata$x
.xdata$x:0000E218                 ;org 0E218h
.xdata$x:0000E218 ; COMDAT (pick associative to section at 59C4)
.xdata$x:0000E218 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000E218                                         ; DATA XREF: .xdata$x:0000E228o
.xdata$x:0000E219                 db 0FFh
.xdata$x:0000E21A                 db 0FFh
.xdata$x:0000E21B                 db 0FFh
.xdata$x:0000E21C                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000E220 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000E220                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000E221                 db    5
.xdata$x:0000E222                 db  93h ; ô
.xdata$x:0000E223                 db  19h
.xdata$x:0000E224                 db    1
.xdata$x:0000E225                 db    0
.xdata$x:0000E226                 db    0
.xdata$x:0000E227                 db    0
.xdata$x:0000E228                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VUserCommand@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000E22C                 db    0
.xdata$x:0000E22D                 db    0
.xdata$x:0000E22E                 db    0
.xdata$x:0000E22F                 db    0
.xdata$x:0000E230                 db    0
.xdata$x:0000E231                 db    0
.xdata$x:0000E232                 db    0
.xdata$x:0000E233                 db    0
.xdata$x:0000E234                 db    0
.xdata$x:0000E235                 db    0
.xdata$x:0000E236                 db    0
.xdata$x:0000E237                 db    0
.xdata$x:0000E238                 db    0
.xdata$x:0000E239                 db    0
.xdata$x:0000E23A                 db    0
.xdata$x:0000E23B                 db    0
.xdata$x:0000E23C                 db    0
.xdata$x:0000E23D                 db    0
.xdata$x:0000E23E                 db    0
.xdata$x:0000E23F                 db    0
.xdata$x:0000E240                 db    0
.xdata$x:0000E241                 db    0
.xdata$x:0000E242                 db    0
.xdata$x:0000E243                 db    0
.xdata$x:0000E243 _xdata$x        ends
.xdata$x:0000E243
.xdata$x:0000E244 ; ===========================================================================
.xdata$x:0000E244
.xdata$x:0000E244 ; Segment type: Pure data
.xdata$x:0000E244 ; Segment permissions: Read
.xdata$x:0000E244 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E244                 assume cs:_xdata$x
.xdata$x:0000E244                 ;org 0E244h
.xdata$x:0000E244 ; COMDAT (pick associative to section at 3754)
.xdata$x:0000E244 __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z db 0FFh
.xdata$x:0000E244                                         ; DATA XREF: .xdata$x:0000E26Co
.xdata$x:0000E245                 db 0FFh
.xdata$x:0000E246                 db 0FFh
.xdata$x:0000E247                 db 0FFh
.xdata$x:0000E248                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$0
.xdata$x:0000E24C                 align 10h
.xdata$x:0000E250                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$1
.xdata$x:0000E254                 db    1
.xdata$x:0000E255                 db    0
.xdata$x:0000E256                 db    0
.xdata$x:0000E257                 db    0
.xdata$x:0000E258                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$2
.xdata$x:0000E25C                 db    2
.xdata$x:0000E25D                 db    0
.xdata$x:0000E25E                 db    0
.xdata$x:0000E25F                 db    0
.xdata$x:0000E260                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z$3
.xdata$x:0000E264 __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z db  22h ; "
.xdata$x:0000E264                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z+11o
.xdata$x:0000E265                 db    5
.xdata$x:0000E266                 db  93h ; ô
.xdata$x:0000E267                 db  19h
.xdata$x:0000E268                 db    4
.xdata$x:0000E269                 db    0
.xdata$x:0000E26A                 db    0
.xdata$x:0000E26B                 db    0
.xdata$x:0000E26C                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@@?$vector@UKeyCombo@@V?$allocator@UKeyCombo@@@std@@@std@@IAEPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@1@0PAU2@@Z
.xdata$x:0000E270                 db    0
.xdata$x:0000E271                 db    0
.xdata$x:0000E272                 db    0
.xdata$x:0000E273                 db    0
.xdata$x:0000E274                 db    0
.xdata$x:0000E275                 db    0
.xdata$x:0000E276                 db    0
.xdata$x:0000E277                 db    0
.xdata$x:0000E278                 db    0
.xdata$x:0000E279                 db    0
.xdata$x:0000E27A                 db    0
.xdata$x:0000E27B                 db    0
.xdata$x:0000E27C                 db    0
.xdata$x:0000E27D                 db    0
.xdata$x:0000E27E                 db    0
.xdata$x:0000E27F                 db    0
.xdata$x:0000E280                 db    0
.xdata$x:0000E281                 db    0
.xdata$x:0000E282                 db    0
.xdata$x:0000E283                 db    0
.xdata$x:0000E284                 db    0
.xdata$x:0000E285                 db    0
.xdata$x:0000E286                 db    0
.xdata$x:0000E287                 db    0
.xdata$x:0000E287 _xdata$x        ends
.xdata$x:0000E287
.xdata$x:0000E288 ; ===========================================================================
.xdata$x:0000E288
.xdata$x:0000E288 ; Segment type: Pure data
.xdata$x:0000E288 ; Segment permissions: Read
.xdata$x:0000E288 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E288                 assume cs:_xdata$x
.xdata$x:0000E288                 ;org 0E288h
.xdata$x:0000E288 ; COMDAT (pick associative to section at 4EC8)
.xdata$x:0000E288 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E288                                         ; DATA XREF: .xdata$x:0000E298o
.xdata$x:0000E289                 db 0FFh
.xdata$x:0000E28A                 db 0FFh
.xdata$x:0000E28B                 db 0FFh
.xdata$x:0000E28C                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000E290 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E290                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000E291                 db    5
.xdata$x:0000E292                 db  93h ; ô
.xdata$x:0000E293                 db  19h
.xdata$x:0000E294                 db    1
.xdata$x:0000E295                 db    0
.xdata$x:0000E296                 db    0
.xdata$x:0000E297                 db    0
.xdata$x:0000E298                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000E29C                 db    0
.xdata$x:0000E29D                 db    0
.xdata$x:0000E29E                 db    0
.xdata$x:0000E29F                 db    0
.xdata$x:0000E2A0                 db    0
.xdata$x:0000E2A1                 db    0
.xdata$x:0000E2A2                 db    0
.xdata$x:0000E2A3                 db    0
.xdata$x:0000E2A4                 db    0
.xdata$x:0000E2A5                 db    0
.xdata$x:0000E2A6                 db    0
.xdata$x:0000E2A7                 db    0
.xdata$x:0000E2A8                 db    0
.xdata$x:0000E2A9                 db    0
.xdata$x:0000E2AA                 db    0
.xdata$x:0000E2AB                 db    0
.xdata$x:0000E2AC                 db    0
.xdata$x:0000E2AD                 db    0
.xdata$x:0000E2AE                 db    0
.xdata$x:0000E2AF                 db    0
.xdata$x:0000E2B0                 db    0
.xdata$x:0000E2B1                 db    0
.xdata$x:0000E2B2                 db    0
.xdata$x:0000E2B3                 db    0
.xdata$x:0000E2B3 _xdata$x        ends
.xdata$x:0000E2B3
.xdata$x:0000E2B4 ; ===========================================================================
.xdata$x:0000E2B4
.xdata$x:0000E2B4 ; Segment type: Pure data
.xdata$x:0000E2B4 ; Segment permissions: Read
.xdata$x:0000E2B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E2B4                 assume cs:_xdata$x
.xdata$x:0000E2B4                 ;org 0E2B4h
.xdata$x:0000E2B4 ; COMDAT (pick associative to section at 6BCC)
.xdata$x:0000E2B4 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000E2B4                                         ; DATA XREF: .xdata$x:0000E2C4o
.xdata$x:0000E2B5                 db 0FFh
.xdata$x:0000E2B6                 db 0FFh
.xdata$x:0000E2B7                 db 0FFh
.xdata$x:0000E2B8                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000E2BC __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E2BC                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000E2BD                 db    5
.xdata$x:0000E2BE                 db  93h ; ô
.xdata$x:0000E2BF                 db  19h
.xdata$x:0000E2C0                 db    1
.xdata$x:0000E2C1                 db    0
.xdata$x:0000E2C2                 db    0
.xdata$x:0000E2C3                 db    0
.xdata$x:0000E2C4                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000E2C8                 align 20h
.xdata$x:0000E2C8 _xdata$x        ends
.xdata$x:0000E2C8
.xdata$x:0000E2E0 ; ===========================================================================
.xdata$x:0000E2E0
.xdata$x:0000E2E0 ; Segment type: Pure data
.xdata$x:0000E2E0 ; Segment permissions: Read
.xdata$x:0000E2E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E2E0                 assume cs:_xdata$x
.xdata$x:0000E2E0                 ;org 0E2E0h
.xdata$x:0000E2E0 ; COMDAT (pick associative to section at 4E50)
.xdata$x:0000E2E0 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000E2E0                                         ; DATA XREF: .xdata$x:0000E2F0o
.xdata$x:0000E2E1                 db 0FFh
.xdata$x:0000E2E2                 db 0FFh
.xdata$x:0000E2E3                 db 0FFh
.xdata$x:0000E2E4                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000E2E8 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000E2E8                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000E2E9                 db    5
.xdata$x:0000E2EA                 db  93h ; ô
.xdata$x:0000E2EB                 db  19h
.xdata$x:0000E2EC                 db    1
.xdata$x:0000E2ED                 db    0
.xdata$x:0000E2EE                 db    0
.xdata$x:0000E2EF                 db    0
.xdata$x:0000E2F0                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UrecordedMacroStep@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000E2F4                 db    0
.xdata$x:0000E2F5                 db    0
.xdata$x:0000E2F6                 db    0
.xdata$x:0000E2F7                 db    0
.xdata$x:0000E2F8                 db    0
.xdata$x:0000E2F9                 db    0
.xdata$x:0000E2FA                 db    0
.xdata$x:0000E2FB                 db    0
.xdata$x:0000E2FC                 db    0
.xdata$x:0000E2FD                 db    0
.xdata$x:0000E2FE                 db    0
.xdata$x:0000E2FF                 db    0
.xdata$x:0000E300                 db    0
.xdata$x:0000E301                 db    0
.xdata$x:0000E302                 db    0
.xdata$x:0000E303                 db    0
.xdata$x:0000E304                 db    0
.xdata$x:0000E305                 db    0
.xdata$x:0000E306                 db    0
.xdata$x:0000E307                 db    0
.xdata$x:0000E308                 db    0
.xdata$x:0000E309                 db    0
.xdata$x:0000E30A                 db    0
.xdata$x:0000E30B                 db    0
.xdata$x:0000E30B _xdata$x        ends
.xdata$x:0000E30B
.xdata$x:0000E30C ; ===========================================================================
.xdata$x:0000E30C
.xdata$x:0000E30C ; Segment type: Pure data
.xdata$x:0000E30C ; Segment permissions: Read
.xdata$x:0000E30C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E30C                 assume cs:_xdata$x
.xdata$x:0000E30C                 ;org 0E30Ch
.xdata$x:0000E30C ; COMDAT (pick associative to section at 5624)
.xdata$x:0000E30C __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000E30C                                         ; DATA XREF: .xdata$x:0000E31Co
.xdata$x:0000E30D                 db 0FFh
.xdata$x:0000E30E                 db 0FFh
.xdata$x:0000E30F                 db 0FFh
.xdata$x:0000E310                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z$0
.xdata$x:0000E314 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000E314                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000E315                 db    5
.xdata$x:0000E316                 db  93h ; ô
.xdata$x:0000E317                 db  19h
.xdata$x:0000E318                 db    1
.xdata$x:0000E319                 db    0
.xdata$x:0000E31A                 db    0
.xdata$x:0000E31B                 db    0
.xdata$x:0000E31C                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@PAUrecordedMacroStep@@PBU_Container_base12@1@@Z
.xdata$x:0000E320                 db    0
.xdata$x:0000E321                 db    0
.xdata$x:0000E322                 db    0
.xdata$x:0000E323                 db    0
.xdata$x:0000E324                 db    0
.xdata$x:0000E325                 db    0
.xdata$x:0000E326                 db    0
.xdata$x:0000E327                 db    0
.xdata$x:0000E328                 db    0
.xdata$x:0000E329                 db    0
.xdata$x:0000E32A                 db    0
.xdata$x:0000E32B                 db    0
.xdata$x:0000E32C                 db    0
.xdata$x:0000E32D                 db    0
.xdata$x:0000E32E                 db    0
.xdata$x:0000E32F                 db    0
.xdata$x:0000E330                 db    0
.xdata$x:0000E331                 db    0
.xdata$x:0000E332                 db    0
.xdata$x:0000E333                 db    0
.xdata$x:0000E334                 db    0
.xdata$x:0000E335                 db    0
.xdata$x:0000E336                 db    0
.xdata$x:0000E337                 db    0
.xdata$x:0000E337 _xdata$x        ends
.xdata$x:0000E337
.xdata$x:0000E338 ; ===========================================================================
.xdata$x:0000E338
.xdata$x:0000E338 ; Segment type: Pure data
.xdata$x:0000E338 ; Segment permissions: Read
.xdata$x:0000E338 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E338                 assume cs:_xdata$x
.xdata$x:0000E338                 ;org 0E338h
.xdata$x:0000E338 ; COMDAT (pick associative to section at 70C4)
.xdata$x:0000E338 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000E338                                         ; DATA XREF: .xdata$x:0000E348o
.xdata$x:0000E339                 db 0FFh
.xdata$x:0000E33A                 db 0FFh
.xdata$x:0000E33B                 db 0FFh
.xdata$x:0000E33C                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000E340 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000E340                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000E341                 db    5
.xdata$x:0000E342                 db  93h ; ô
.xdata$x:0000E343                 db  19h
.xdata$x:0000E344                 db    1
.xdata$x:0000E345                 db    0
.xdata$x:0000E346                 db    0
.xdata$x:0000E347                 db    0
.xdata$x:0000E348                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000E34C                 db    0
.xdata$x:0000E34D                 db    0
.xdata$x:0000E34E                 db    0
.xdata$x:0000E34F                 db    0
.xdata$x:0000E350                 db    0
.xdata$x:0000E351                 db    0
.xdata$x:0000E352                 db    0
.xdata$x:0000E353                 db    0
.xdata$x:0000E354                 db    0
.xdata$x:0000E355                 db    0
.xdata$x:0000E356                 db    0
.xdata$x:0000E357                 db    0
.xdata$x:0000E358                 db    0
.xdata$x:0000E359                 db    0
.xdata$x:0000E35A                 db    0
.xdata$x:0000E35B                 db    0
.xdata$x:0000E35C                 db    0
.xdata$x:0000E35D                 db    0
.xdata$x:0000E35E                 db    0
.xdata$x:0000E35F                 db    0
.xdata$x:0000E360                 db    0
.xdata$x:0000E361                 db    0
.xdata$x:0000E362                 db    0
.xdata$x:0000E363                 db    0
.xdata$x:0000E363 _xdata$x        ends
.xdata$x:0000E363
.xdata$x:0000E364 ; ===========================================================================
.xdata$x:0000E364
.xdata$x:0000E364 ; Segment type: Pure data
.xdata$x:0000E364 ; Segment permissions: Read
.xdata$x:0000E364 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E364                 assume cs:_xdata$x
.xdata$x:0000E364                 ;org 0E364h
.xdata$x:0000E364 ; COMDAT (pick associative to section at 55A0)
.xdata$x:0000E364 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000E364                                         ; DATA XREF: .xdata$x:0000E374o
.xdata$x:0000E365                 db 0FFh
.xdata$x:0000E366                 db 0FFh
.xdata$x:0000E367                 db 0FFh
.xdata$x:0000E368                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000E36C __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000E36C                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000E36D                 db    5
.xdata$x:0000E36E                 db  93h ; ô
.xdata$x:0000E36F                 db  19h
.xdata$x:0000E370                 db    1
.xdata$x:0000E371                 db    0
.xdata$x:0000E372                 db    0
.xdata$x:0000E373                 db    0
.xdata$x:0000E374                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000E378                 db    0
.xdata$x:0000E379                 db    0
.xdata$x:0000E37A                 db    0
.xdata$x:0000E37B                 db    0
.xdata$x:0000E37C                 db    0
.xdata$x:0000E37D                 db    0
.xdata$x:0000E37E                 db    0
.xdata$x:0000E37F                 db    0
.xdata$x:0000E380                 db    0
.xdata$x:0000E381                 db    0
.xdata$x:0000E382                 db    0
.xdata$x:0000E383                 db    0
.xdata$x:0000E384                 db    0
.xdata$x:0000E385                 db    0
.xdata$x:0000E386                 db    0
.xdata$x:0000E387                 db    0
.xdata$x:0000E388                 db    0
.xdata$x:0000E389                 db    0
.xdata$x:0000E38A                 db    0
.xdata$x:0000E38B                 db    0
.xdata$x:0000E38C                 db    0
.xdata$x:0000E38D                 db    0
.xdata$x:0000E38E                 db    0
.xdata$x:0000E38F                 db    0
.xdata$x:0000E38F _xdata$x        ends
.xdata$x:0000E38F
.xdata$x:0000E390 ; ===========================================================================
.xdata$x:0000E390
.xdata$x:0000E390 ; Segment type: Pure data
.xdata$x:0000E390 ; Segment permissions: Read
.xdata$x:0000E390 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E390                 assume cs:_xdata$x
.xdata$x:0000E390                 ;org 0E390h
.xdata$x:0000E390 ; COMDAT (pick associative to section at 3854)
.xdata$x:0000E390 __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z db 0FFh
.xdata$x:0000E390                                         ; DATA XREF: .xdata$x:0000E3B8o
.xdata$x:0000E391                 db 0FFh
.xdata$x:0000E392                 db 0FFh
.xdata$x:0000E393                 db 0FFh
.xdata$x:0000E394                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$0
.xdata$x:0000E398                 db    0
.xdata$x:0000E399                 db    0
.xdata$x:0000E39A                 db    0
.xdata$x:0000E39B                 db    0
.xdata$x:0000E39C                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$1
.xdata$x:0000E3A0                 db    1
.xdata$x:0000E3A1                 db    0
.xdata$x:0000E3A2                 db    0
.xdata$x:0000E3A3                 db    0
.xdata$x:0000E3A4                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$2
.xdata$x:0000E3A8                 db    2
.xdata$x:0000E3A9                 db    0
.xdata$x:0000E3AA                 db    0
.xdata$x:0000E3AB                 db    0
.xdata$x:0000E3AC                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z$3
.xdata$x:0000E3B0 __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z db  22h ; "
.xdata$x:0000E3B0                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z+11o
.xdata$x:0000E3B1                 db    5
.xdata$x:0000E3B2                 db  93h ; ô
.xdata$x:0000E3B3                 db  19h
.xdata$x:0000E3B4                 db    4
.xdata$x:0000E3B5                 db    0
.xdata$x:0000E3B6                 db    0
.xdata$x:0000E3B7                 db    0
.xdata$x:0000E3B8                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@1@0PAU2@@Z
.xdata$x:0000E3BC                 db    0
.xdata$x:0000E3BD                 db    0
.xdata$x:0000E3BE                 db    0
.xdata$x:0000E3BF                 db    0
.xdata$x:0000E3C0                 db    0
.xdata$x:0000E3C1                 db    0
.xdata$x:0000E3C2                 db    0
.xdata$x:0000E3C3                 db    0
.xdata$x:0000E3C4                 db    0
.xdata$x:0000E3C5                 db    0
.xdata$x:0000E3C6                 db    0
.xdata$x:0000E3C7                 db    0
.xdata$x:0000E3C8                 db    0
.xdata$x:0000E3C9                 db    0
.xdata$x:0000E3CA                 db    0
.xdata$x:0000E3CB                 db    0
.xdata$x:0000E3CC                 db    0
.xdata$x:0000E3CD                 db    0
.xdata$x:0000E3CE                 db    0
.xdata$x:0000E3CF                 db    0
.xdata$x:0000E3D0                 db    0
.xdata$x:0000E3D1                 db    0
.xdata$x:0000E3D2                 db    0
.xdata$x:0000E3D3                 db    0
.xdata$x:0000E3D3 _xdata$x        ends
.xdata$x:0000E3D3
.xdata$x:0000E3D4 ; ===========================================================================
.xdata$x:0000E3D4
.xdata$x:0000E3D4 ; Segment type: Pure data
.xdata$x:0000E3D4 ; Segment permissions: Read
.xdata$x:0000E3D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E3D4                 assume cs:_xdata$x
.xdata$x:0000E3D4                 ;org 0E3D4h
.xdata$x:0000E3D4 ; COMDAT (pick associative to section at 48A8)
.xdata$x:0000E3D4 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000E3D4                                         ; DATA XREF: .xdata$x:0000E3E4o
.xdata$x:0000E3D5                 db 0FFh
.xdata$x:0000E3D6                 db 0FFh
.xdata$x:0000E3D7                 db 0FFh
.xdata$x:0000E3D8                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000E3DC __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000E3DC                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000E3DD                 db    5
.xdata$x:0000E3DE                 db  93h ; ô
.xdata$x:0000E3DF                 db  19h
.xdata$x:0000E3E0                 db    1
.xdata$x:0000E3E1                 db    0
.xdata$x:0000E3E2                 db    0
.xdata$x:0000E3E3                 db    0
.xdata$x:0000E3E4                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000E3E8                 align 20h
.xdata$x:0000E3E8 _xdata$x        ends
.xdata$x:0000E3E8
.xdata$x:0000E400 ; ===========================================================================
.xdata$x:0000E400
.xdata$x:0000E400 ; Segment type: Pure data
.xdata$x:0000E400 ; Segment permissions: Read
.xdata$x:0000E400 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E400                 assume cs:_xdata$x
.xdata$x:0000E400                 ;org 0E400h
.xdata$x:0000E400 ; COMDAT (pick associative to section at 4178)
.xdata$x:0000E400 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z db 0FFh
.xdata$x:0000E400                                         ; DATA XREF: .xdata$x:0000E428o
.xdata$x:0000E401                 db 0FFh
.xdata$x:0000E402                 db 0FFh
.xdata$x:0000E403                 db 0FFh
.xdata$x:0000E404                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$0
.xdata$x:0000E408                 db    0
.xdata$x:0000E409                 db    0
.xdata$x:0000E40A                 db    0
.xdata$x:0000E40B                 db    0
.xdata$x:0000E40C                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$1
.xdata$x:0000E410                 db    1
.xdata$x:0000E411                 db    0
.xdata$x:0000E412                 db    0
.xdata$x:0000E413                 db    0
.xdata$x:0000E414                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$2
.xdata$x:0000E418                 db    1
.xdata$x:0000E419                 db    0
.xdata$x:0000E41A                 db    0
.xdata$x:0000E41B                 db    0
.xdata$x:0000E41C                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z$3
.xdata$x:0000E420 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z db  22h ; "
.xdata$x:0000E420                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z+11o
.xdata$x:0000E421                 db    5
.xdata$x:0000E422                 db  93h ; ô
.xdata$x:0000E423                 db  19h
.xdata$x:0000E424                 db    4
.xdata$x:0000E425                 db    0
.xdata$x:0000E426                 db    0
.xdata$x:0000E427                 db    0
.xdata$x:0000E428                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@PAUKeyCombo@@U?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@2@@std@@YAPAUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@@Z
.xdata$x:0000E42C                 db    0
.xdata$x:0000E42D                 db    0
.xdata$x:0000E42E                 db    0
.xdata$x:0000E42F                 db    0
.xdata$x:0000E430                 db    0
.xdata$x:0000E431                 db    0
.xdata$x:0000E432                 db    0
.xdata$x:0000E433                 db    0
.xdata$x:0000E434                 db    0
.xdata$x:0000E435                 db    0
.xdata$x:0000E436                 db    0
.xdata$x:0000E437                 db    0
.xdata$x:0000E438                 db    0
.xdata$x:0000E439                 db    0
.xdata$x:0000E43A                 db    0
.xdata$x:0000E43B                 db    0
.xdata$x:0000E43C                 db    0
.xdata$x:0000E43D                 db    0
.xdata$x:0000E43E                 db    0
.xdata$x:0000E43F                 db    0
.xdata$x:0000E440                 db    0
.xdata$x:0000E441                 db    0
.xdata$x:0000E442                 db    0
.xdata$x:0000E443                 db    0
.xdata$x:0000E443 _xdata$x        ends
.xdata$x:0000E443
.xdata$x:0000E444 ; ===========================================================================
.xdata$x:0000E444
.xdata$x:0000E444 ; Segment type: Pure data
.xdata$x:0000E444 ; Segment permissions: Read
.xdata$x:0000E444 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E444                 assume cs:_xdata$x
.xdata$x:0000E444                 ;org 0E444h
.xdata$x:0000E444 ; COMDAT (pick associative to section at 42A0)
.xdata$x:0000E444 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z db 0FFh
.xdata$x:0000E444                                         ; DATA XREF: .xdata$x:0000E46Co
.xdata$x:0000E445                 db 0FFh
.xdata$x:0000E446                 db 0FFh
.xdata$x:0000E447                 db 0FFh
.xdata$x:0000E448                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$0
.xdata$x:0000E44C                 align 10h
.xdata$x:0000E450                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$1
.xdata$x:0000E454                 db    1
.xdata$x:0000E455                 db    0
.xdata$x:0000E456                 db    0
.xdata$x:0000E457                 db    0
.xdata$x:0000E458                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$2
.xdata$x:0000E45C                 db    1
.xdata$x:0000E45D                 db    0
.xdata$x:0000E45E                 db    0
.xdata$x:0000E45F                 db    0
.xdata$x:0000E460                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z$3
.xdata$x:0000E464 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z db  22h ; "
.xdata$x:0000E464                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z+11o
.xdata$x:0000E465                 db    5
.xdata$x:0000E466                 db  93h ; ô
.xdata$x:0000E467                 db  19h
.xdata$x:0000E468                 db    4
.xdata$x:0000E469                 db    0
.xdata$x:0000E46A                 db    0
.xdata$x:0000E46B                 db    0
.xdata$x:0000E46C                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@PAUrecordedMacroStep@@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@@std@@YAPAUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.xdata$x:0000E470                 db    0
.xdata$x:0000E471                 db    0
.xdata$x:0000E472                 db    0
.xdata$x:0000E473                 db    0
.xdata$x:0000E474                 db    0
.xdata$x:0000E475                 db    0
.xdata$x:0000E476                 db    0
.xdata$x:0000E477                 db    0
.xdata$x:0000E478                 db    0
.xdata$x:0000E479                 db    0
.xdata$x:0000E47A                 db    0
.xdata$x:0000E47B                 db    0
.xdata$x:0000E47C                 db    0
.xdata$x:0000E47D                 db    0
.xdata$x:0000E47E                 db    0
.xdata$x:0000E47F                 db    0
.xdata$x:0000E480                 db    0
.xdata$x:0000E481                 db    0
.xdata$x:0000E482                 db    0
.xdata$x:0000E483                 db    0
.xdata$x:0000E484                 db    0
.xdata$x:0000E485                 db    0
.xdata$x:0000E486                 db    0
.xdata$x:0000E487                 db    0
.xdata$x:0000E487 _xdata$x        ends
.xdata$x:0000E487
.xdata$x:0000E488 ; ===========================================================================
.xdata$x:0000E488
.xdata$x:0000E488 ; Segment type: Pure data
.xdata$x:0000E488 ; Segment permissions: Read
.xdata$x:0000E488 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E488                 assume cs:_xdata$x
.xdata$x:0000E488                 ;org 0E488h
.xdata$x:0000E488 ; COMDAT (pick associative to section at 39A0)
.xdata$x:0000E488 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000E488                                         ; DATA XREF: .xdata$x:0000E498o
.xdata$x:0000E489                 db 0FFh
.xdata$x:0000E48A                 db 0FFh
.xdata$x:0000E48B                 db 0FFh
.xdata$x:0000E48C                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z$0
.xdata$x:0000E490 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000E490                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z+11o
.xdata$x:0000E491                 db    5
.xdata$x:0000E492                 db  93h ; ô
.xdata$x:0000E493                 db  19h
.xdata$x:0000E494                 db    1
.xdata$x:0000E495                 db    0
.xdata$x:0000E496                 db    0
.xdata$x:0000E497                 db    0
.xdata$x:0000E498                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@std@@YAPBUKeyCombo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UKeyCombo@@@std@@@std@@@0@@Z
.xdata$x:0000E49C                 db    0
.xdata$x:0000E49D                 db    0
.xdata$x:0000E49E                 db    0
.xdata$x:0000E49F                 db    0
.xdata$x:0000E4A0                 db    0
.xdata$x:0000E4A1                 db    0
.xdata$x:0000E4A2                 db    0
.xdata$x:0000E4A3                 db    0
.xdata$x:0000E4A4                 db    0
.xdata$x:0000E4A5                 db    0
.xdata$x:0000E4A6                 db    0
.xdata$x:0000E4A7                 db    0
.xdata$x:0000E4A8                 db    0
.xdata$x:0000E4A9                 db    0
.xdata$x:0000E4AA                 db    0
.xdata$x:0000E4AB                 db    0
.xdata$x:0000E4AC                 db    0
.xdata$x:0000E4AD                 db    0
.xdata$x:0000E4AE                 db    0
.xdata$x:0000E4AF                 db    0
.xdata$x:0000E4B0                 db    0
.xdata$x:0000E4B1                 db    0
.xdata$x:0000E4B2                 db    0
.xdata$x:0000E4B3                 db    0
.xdata$x:0000E4B3 _xdata$x        ends
.xdata$x:0000E4B3
.xdata$x:0000E4B4 ; ===========================================================================
.xdata$x:0000E4B4
.xdata$x:0000E4B4 ; Segment type: Pure data
.xdata$x:0000E4B4 ; Segment permissions: Read
.xdata$x:0000E4B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E4B4                 assume cs:_xdata$x
.xdata$x:0000E4B4                 ;org 0E4B4h
.xdata$x:0000E4B4 ; COMDAT (pick associative to section at 465C)
.xdata$x:0000E4B4 __unwindtable$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z db 0FFh
.xdata$x:0000E4B4                                         ; DATA XREF: .xdata$x:0000E4C4o
.xdata$x:0000E4B5                 db 0FFh
.xdata$x:0000E4B6                 db 0FFh
.xdata$x:0000E4B7                 db 0FFh
.xdata$x:0000E4B8                 dd offset __unwindfunclet$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z$0
.xdata$x:0000E4BC __ehfuncinfo$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z db  22h ; "
.xdata$x:0000E4BC                                         ; DATA XREF: __ehhandler$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z+11o
.xdata$x:0000E4BD                 db    5
.xdata$x:0000E4BE                 db  93h ; ô
.xdata$x:0000E4BF                 db  19h
.xdata$x:0000E4C0                 db    1
.xdata$x:0000E4C1                 db    0
.xdata$x:0000E4C2                 db    0
.xdata$x:0000E4C3                 db    0
.xdata$x:0000E4C4                 dd offset __unwindtable$??$construct@UKeyCombo@@AAU1@@?$allocator@UKeyCombo@@@std@@QAEXPAUKeyCombo@@AAU2@@Z
.xdata$x:0000E4C8                 align 20h
.xdata$x:0000E4C8 _xdata$x        ends
.xdata$x:0000E4C8
.xdata$x:0000E4E0 ; ===========================================================================
.xdata$x:0000E4E0
.xdata$x:0000E4E0 ; Segment type: Pure data
.xdata$x:0000E4E0 ; Segment permissions: Read
.xdata$x:0000E4E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E4E0                 assume cs:_xdata$x
.xdata$x:0000E4E0                 ;org 0E4E0h
.xdata$x:0000E4E0 ; COMDAT (pick associative to section at 3A1C)
.xdata$x:0000E4E0 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000E4E0                                         ; DATA XREF: .xdata$x:0000E4F0o
.xdata$x:0000E4E1                 db 0FFh
.xdata$x:0000E4E2                 db 0FFh
.xdata$x:0000E4E3                 db 0FFh
.xdata$x:0000E4E4                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z$0
.xdata$x:0000E4E8 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000E4E8                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z+11o
.xdata$x:0000E4E9                 db    5
.xdata$x:0000E4EA                 db  93h ; ô
.xdata$x:0000E4EB                 db  19h
.xdata$x:0000E4EC                 db    1
.xdata$x:0000E4ED                 db    0
.xdata$x:0000E4EE                 db    0
.xdata$x:0000E4EF                 db    0
.xdata$x:0000E4F0                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@std@@YAPBUrecordedMacroStep@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UrecordedMacroStep@@@std@@@std@@@0@@Z
.xdata$x:0000E4F4                 db    0
.xdata$x:0000E4F5                 db    0
.xdata$x:0000E4F6                 db    0
.xdata$x:0000E4F7                 db    0
.xdata$x:0000E4F8                 db    0
.xdata$x:0000E4F9                 db    0
.xdata$x:0000E4FA                 db    0
.xdata$x:0000E4FB                 db    0
.xdata$x:0000E4FC                 db    0
.xdata$x:0000E4FD                 db    0
.xdata$x:0000E4FE                 db    0
.xdata$x:0000E4FF                 db    0
.xdata$x:0000E500                 db    0
.xdata$x:0000E501                 db    0
.xdata$x:0000E502                 db    0
.xdata$x:0000E503                 db    0
.xdata$x:0000E504                 db    0
.xdata$x:0000E505                 db    0
.xdata$x:0000E506                 db    0
.xdata$x:0000E507                 db    0
.xdata$x:0000E508                 db    0
.xdata$x:0000E509                 db    0
.xdata$x:0000E50A                 db    0
.xdata$x:0000E50B                 db    0
.xdata$x:0000E50B _xdata$x        ends
.xdata$x:0000E50B
.xdata$x:0000E50C ; ===========================================================================
.xdata$x:0000E50C
.xdata$x:0000E50C ; Segment type: Pure data
.xdata$x:0000E50C ; Segment permissions: Read
.xdata$x:0000E50C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E50C                 assume cs:_xdata$x
.xdata$x:0000E50C                 ;org 0E50Ch
.xdata$x:0000E50C ; COMDAT (pick associative to section at 47A8)
.xdata$x:0000E50C __unwindtable$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z db 0FFh
.xdata$x:0000E50C                                         ; DATA XREF: .xdata$x:0000E51Co
.xdata$x:0000E50D                 db 0FFh
.xdata$x:0000E50E                 db 0FFh
.xdata$x:0000E50F                 db 0FFh
.xdata$x:0000E510                 dd offset __unwindfunclet$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z$0
.xdata$x:0000E514 __ehfuncinfo$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z db  22h ; "
.xdata$x:0000E514                                         ; DATA XREF: __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z+11o
.xdata$x:0000E515                 db    5
.xdata$x:0000E516                 db  93h ; ô
.xdata$x:0000E517                 db  19h
.xdata$x:0000E518                 db    1
.xdata$x:0000E519                 db    0
.xdata$x:0000E51A                 db    0
.xdata$x:0000E51B                 db    0
.xdata$x:0000E51C                 dd offset __unwindtable$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.xdata$x:0000E520                 db    0
.xdata$x:0000E521                 db    0
.xdata$x:0000E522                 db    0
.xdata$x:0000E523                 db    0
.xdata$x:0000E524                 db    0
.xdata$x:0000E525                 db    0
.xdata$x:0000E526                 db    0
.xdata$x:0000E527                 db    0
.xdata$x:0000E528                 db    0
.xdata$x:0000E529                 db    0
.xdata$x:0000E52A                 db    0
.xdata$x:0000E52B                 db    0
.xdata$x:0000E52C                 db    0
.xdata$x:0000E52D                 db    0
.xdata$x:0000E52E                 db    0
.xdata$x:0000E52F                 db    0
.xdata$x:0000E530                 db    0
.xdata$x:0000E531                 db    0
.xdata$x:0000E532                 db    0
.xdata$x:0000E533                 db    0
.xdata$x:0000E534                 db    0
.xdata$x:0000E535                 db    0
.xdata$x:0000E536                 db    0
.xdata$x:0000E537                 db    0
.xdata$x:0000E537 _xdata$x        ends
.xdata$x:0000E537
.xdata$x:0000E538 ; ===========================================================================
.xdata$x:0000E538
.xdata$x:0000E538 ; Segment type: Pure data
.xdata$x:0000E538 ; Segment permissions: Read
.xdata$x:0000E538 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E538                 assume cs:_xdata$x
.xdata$x:0000E538                 ;org 0E538h
.xdata$x:0000E538 ; COMDAT (pick associative to section at 445C)
.xdata$x:0000E538 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000E538                                         ; DATA XREF: .xdata$x:0000E548o
.xdata$x:0000E539                 db 0FFh
.xdata$x:0000E53A                 db 0FFh
.xdata$x:0000E53B                 db 0FFh
.xdata$x:0000E53C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000E540 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000E540                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000E541                 db    5
.xdata$x:0000E542                 db  93h ; ô
.xdata$x:0000E543                 db  19h
.xdata$x:0000E544                 db    1
.xdata$x:0000E545                 db    0
.xdata$x:0000E546                 db    0
.xdata$x:0000E547                 db    0
.xdata$x:0000E548                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000E54C                 db    0
.xdata$x:0000E54D                 db    0
.xdata$x:0000E54E                 db    0
.xdata$x:0000E54F                 db    0
.xdata$x:0000E550                 db    0
.xdata$x:0000E551                 db    0
.xdata$x:0000E552                 db    0
.xdata$x:0000E553                 db    0
.xdata$x:0000E554                 db    0
.xdata$x:0000E555                 db    0
.xdata$x:0000E556                 db    0
.xdata$x:0000E557                 db    0
.xdata$x:0000E558                 db    0
.xdata$x:0000E559                 db    0
.xdata$x:0000E55A                 db    0
.xdata$x:0000E55B                 db    0
.xdata$x:0000E55C                 db    0
.xdata$x:0000E55D                 db    0
.xdata$x:0000E55E                 db    0
.xdata$x:0000E55F                 db    0
.xdata$x:0000E560                 db    0
.xdata$x:0000E561                 db    0
.xdata$x:0000E562                 db    0
.xdata$x:0000E563                 db    0
.xdata$x:0000E563 _xdata$x        ends
.xdata$x:0000E563
.xdata$x:0000E564 ; ===========================================================================
.xdata$x:0000E564
.xdata$x:0000E564 ; Segment type: Pure data
.xdata$x:0000E564 ; Segment permissions: Read
.xdata$x:0000E564 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E564                 assume cs:_xdata$x
.xdata$x:0000E564                 ;org 0E564h
.xdata$x:0000E564 ; COMDAT (pick associative to section at 455C)
.xdata$x:0000E564 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000E564                                         ; DATA XREF: .xdata$x:0000E574o
.xdata$x:0000E565                 db 0FFh
.xdata$x:0000E566                 db 0FFh
.xdata$x:0000E567                 db 0FFh
.xdata$x:0000E568                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000E56C __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000E56C                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000E56D                 db    5
.xdata$x:0000E56E                 db  93h ; ô
.xdata$x:0000E56F                 db  19h
.xdata$x:0000E570                 db    1
.xdata$x:0000E571                 db    0
.xdata$x:0000E572                 db    0
.xdata$x:0000E573                 db    0
.xdata$x:0000E574                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:0000E578                 db    0
.xdata$x:0000E579                 db    0
.xdata$x:0000E57A                 db    0
.xdata$x:0000E57B                 db    0
.xdata$x:0000E57C                 db    0
.xdata$x:0000E57D                 db    0
.xdata$x:0000E57E                 db    0
.xdata$x:0000E57F                 db    0
.xdata$x:0000E580                 db    0
.xdata$x:0000E581                 db    0
.xdata$x:0000E582                 db    0
.xdata$x:0000E583                 db    0
.xdata$x:0000E584                 db    0
.xdata$x:0000E585                 db    0
.xdata$x:0000E586                 db    0
.xdata$x:0000E587                 db    0
.xdata$x:0000E588                 db    0
.xdata$x:0000E589                 db    0
.xdata$x:0000E58A                 db    0
.xdata$x:0000E58B                 db    0
.xdata$x:0000E58C                 db    0
.xdata$x:0000E58D                 db    0
.xdata$x:0000E58E                 db    0
.xdata$x:0000E58F                 db    0
.xdata$x:0000E58F _xdata$x        ends
.xdata$x:0000E58F
.xdata$x:0000E590 ; ===========================================================================
.xdata$x:0000E590
.xdata$x:0000E590 ; Segment type: Pure data
.xdata$x:0000E590 ; Segment permissions: Read
.xdata$x:0000E590 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E590                 assume cs:_xdata$x
.xdata$x:0000E590                 ;org 0E590h
.xdata$x:0000E590 ; COMDAT (pick associative to section at 3D50)
.xdata$x:0000E590 __catchsym$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000E590                                         ; DATA XREF: .xdata$x:0000E5C0o
.xdata$x:0000E591                 db    0
.xdata$x:0000E592                 db    0
.xdata$x:0000E593                 db    0
.xdata$x:0000E594                 db    0
.xdata$x:0000E595                 db    0
.xdata$x:0000E596                 db    0
.xdata$x:0000E597                 db    0
.xdata$x:0000E598                 db    0
.xdata$x:0000E599                 db    0
.xdata$x:0000E59A                 db    0
.xdata$x:0000E59B                 db    0
.xdata$x:0000E59C                 dd offset __catch$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000E5A0 __unwindtable$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000E5A0                                         ; DATA XREF: .xdata$x:0000E5CCo
.xdata$x:0000E5A1                 db 0FFh
.xdata$x:0000E5A2                 db 0FFh
.xdata$x:0000E5A3                 db 0FFh
.xdata$x:0000E5A4                 db    0
.xdata$x:0000E5A5                 db    0
.xdata$x:0000E5A6                 db    0
.xdata$x:0000E5A7                 db    0
.xdata$x:0000E5A8                 db 0FFh
.xdata$x:0000E5A9                 db 0FFh
.xdata$x:0000E5AA                 db 0FFh
.xdata$x:0000E5AB                 db 0FFh
.xdata$x:0000E5AC                 db    0
.xdata$x:0000E5AD                 db    0
.xdata$x:0000E5AE                 db    0
.xdata$x:0000E5AF                 db    0
.xdata$x:0000E5B0 __tryblocktable$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000E5B0                                         ; DATA XREF: .xdata$x:0000E5D4o
.xdata$x:0000E5B1                 db    0
.xdata$x:0000E5B2                 db    0
.xdata$x:0000E5B3                 db    0
.xdata$x:0000E5B4                 db    0
.xdata$x:0000E5B5                 db    0
.xdata$x:0000E5B6                 db    0
.xdata$x:0000E5B7                 db    0
.xdata$x:0000E5B8                 db    1
.xdata$x:0000E5B9                 db    0
.xdata$x:0000E5BA                 db    0
.xdata$x:0000E5BB                 db    0
.xdata$x:0000E5BC                 db    1
.xdata$x:0000E5BD                 db    0
.xdata$x:0000E5BE                 db    0
.xdata$x:0000E5BF                 db    0
.xdata$x:0000E5C0                 dd offset __catchsym$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000E5C4 __ehfuncinfo$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000E5C4                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000E5C5                 db    5
.xdata$x:0000E5C6                 db  93h ; ô
.xdata$x:0000E5C7                 db  19h
.xdata$x:0000E5C8                 db    2
.xdata$x:0000E5C9                 db    0
.xdata$x:0000E5CA                 db    0
.xdata$x:0000E5CB                 db    0
.xdata$x:0000E5CC                 dd offset __unwindtable$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E5D0                 db    1
.xdata$x:0000E5D1                 db    0
.xdata$x:0000E5D2                 db    0
.xdata$x:0000E5D3                 db    0
.xdata$x:0000E5D4                 dd offset __tryblocktable$??$_Uninit_copy@PBUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E5D8                 db    0
.xdata$x:0000E5D9                 db    0
.xdata$x:0000E5DA                 db    0
.xdata$x:0000E5DB                 db    0
.xdata$x:0000E5DC                 db    0
.xdata$x:0000E5DD                 db    0
.xdata$x:0000E5DE                 db    0
.xdata$x:0000E5DF                 db    0
.xdata$x:0000E5E0                 db    0
.xdata$x:0000E5E1                 db    0
.xdata$x:0000E5E2                 db    0
.xdata$x:0000E5E3                 db    0
.xdata$x:0000E5E4                 db    0
.xdata$x:0000E5E5                 db    0
.xdata$x:0000E5E6                 db    0
.xdata$x:0000E5E7                 db    0
.xdata$x:0000E5E7 _xdata$x        ends
.xdata$x:0000E5E7
.xdata$x:0000E5E8 ; ===========================================================================
.xdata$x:0000E5E8
.xdata$x:0000E5E8 ; Segment type: Pure data
.xdata$x:0000E5E8 ; Segment permissions: Read
.xdata$x:0000E5E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E5E8                 assume cs:_xdata$x
.xdata$x:0000E5E8                 ;org 0E5E8h
.xdata$x:0000E5E8 ; COMDAT (pick associative to section at 3AD0)
.xdata$x:0000E5E8 __catchsym$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000E5E8                                         ; DATA XREF: .xdata$x:0000E618o
.xdata$x:0000E5E9                 db    0
.xdata$x:0000E5EA                 db    0
.xdata$x:0000E5EB                 db    0
.xdata$x:0000E5EC                 db    0
.xdata$x:0000E5ED                 db    0
.xdata$x:0000E5EE                 db    0
.xdata$x:0000E5EF                 db    0
.xdata$x:0000E5F0                 db    0
.xdata$x:0000E5F1                 db    0
.xdata$x:0000E5F2                 db    0
.xdata$x:0000E5F3                 db    0
.xdata$x:0000E5F4                 dd offset __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000E5F8 __unwindtable$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000E5F8                                         ; DATA XREF: .xdata$x:0000E624o
.xdata$x:0000E5F9                 db 0FFh
.xdata$x:0000E5FA                 db 0FFh
.xdata$x:0000E5FB                 db 0FFh
.xdata$x:0000E5FC                 db    0
.xdata$x:0000E5FD                 db    0
.xdata$x:0000E5FE                 db    0
.xdata$x:0000E5FF                 db    0
.xdata$x:0000E600                 db 0FFh
.xdata$x:0000E601                 db 0FFh
.xdata$x:0000E602                 db 0FFh
.xdata$x:0000E603                 db 0FFh
.xdata$x:0000E604                 db    0
.xdata$x:0000E605                 db    0
.xdata$x:0000E606                 db    0
.xdata$x:0000E607                 db    0
.xdata$x:0000E608 __tryblocktable$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000E608                                         ; DATA XREF: .xdata$x:0000E62Co
.xdata$x:0000E609                 db    0
.xdata$x:0000E60A                 db    0
.xdata$x:0000E60B                 db    0
.xdata$x:0000E60C                 db    0
.xdata$x:0000E60D                 db    0
.xdata$x:0000E60E                 db    0
.xdata$x:0000E60F                 db    0
.xdata$x:0000E610                 db    1
.xdata$x:0000E611                 db    0
.xdata$x:0000E612                 db    0
.xdata$x:0000E613                 db    0
.xdata$x:0000E614                 db    1
.xdata$x:0000E615                 db    0
.xdata$x:0000E616                 db    0
.xdata$x:0000E617                 db    0
.xdata$x:0000E618                 dd offset __catchsym$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000E61C __ehfuncinfo$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000E61C                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000E61D                 db    5
.xdata$x:0000E61E                 db  93h ; ô
.xdata$x:0000E61F                 db  19h
.xdata$x:0000E620                 db    2
.xdata$x:0000E621                 db    0
.xdata$x:0000E622                 db    0
.xdata$x:0000E623                 db    0
.xdata$x:0000E624                 dd offset __unwindtable$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E628                 db    1
.xdata$x:0000E629                 db    0
.xdata$x:0000E62A                 db    0
.xdata$x:0000E62B                 db    0
.xdata$x:0000E62C                 dd offset __tryblocktable$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E630                 align 20h
.xdata$x:0000E630 _xdata$x        ends
.xdata$x:0000E630
.xdata$x:0000E640 ; ===========================================================================
.xdata$x:0000E640
.xdata$x:0000E640 ; Segment type: Pure data
.xdata$x:0000E640 ; Segment permissions: Read
.xdata$x:0000E640 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E640                 assume cs:_xdata$x
.xdata$x:0000E640                 ;org 0E640h
.xdata$x:0000E640 ; COMDAT (pick associative to section at 3E90)
.xdata$x:0000E640 __catchsym$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000E640                                         ; DATA XREF: .xdata$x:0000E670o
.xdata$x:0000E641                 db    0
.xdata$x:0000E642                 db    0
.xdata$x:0000E643                 db    0
.xdata$x:0000E644                 db    0
.xdata$x:0000E645                 db    0
.xdata$x:0000E646                 db    0
.xdata$x:0000E647                 db    0
.xdata$x:0000E648                 db    0
.xdata$x:0000E649                 db    0
.xdata$x:0000E64A                 db    0
.xdata$x:0000E64B                 db    0
.xdata$x:0000E64C                 dd offset __catch$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000E650 __unwindtable$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000E650                                         ; DATA XREF: .xdata$x:0000E67Co
.xdata$x:0000E651                 db 0FFh
.xdata$x:0000E652                 db 0FFh
.xdata$x:0000E653                 db 0FFh
.xdata$x:0000E654                 db    0
.xdata$x:0000E655                 db    0
.xdata$x:0000E656                 db    0
.xdata$x:0000E657                 db    0
.xdata$x:0000E658                 db 0FFh
.xdata$x:0000E659                 db 0FFh
.xdata$x:0000E65A                 db 0FFh
.xdata$x:0000E65B                 db 0FFh
.xdata$x:0000E65C                 db    0
.xdata$x:0000E65D                 db    0
.xdata$x:0000E65E                 db    0
.xdata$x:0000E65F                 db    0
.xdata$x:0000E660 __tryblocktable$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000E660                                         ; DATA XREF: .xdata$x:0000E684o
.xdata$x:0000E661                 db    0
.xdata$x:0000E662                 db    0
.xdata$x:0000E663                 db    0
.xdata$x:0000E664                 db    0
.xdata$x:0000E665                 db    0
.xdata$x:0000E666                 db    0
.xdata$x:0000E667                 db    0
.xdata$x:0000E668                 db    1
.xdata$x:0000E669                 db    0
.xdata$x:0000E66A                 db    0
.xdata$x:0000E66B                 db    0
.xdata$x:0000E66C                 db    1
.xdata$x:0000E66D                 db    0
.xdata$x:0000E66E                 db    0
.xdata$x:0000E66F                 db    0
.xdata$x:0000E670                 dd offset __catchsym$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000E674 __ehfuncinfo$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000E674                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000E675                 db    5
.xdata$x:0000E676                 db  93h ; ô
.xdata$x:0000E677                 db  19h
.xdata$x:0000E678                 db    2
.xdata$x:0000E679                 db    0
.xdata$x:0000E67A                 db    0
.xdata$x:0000E67B                 db    0
.xdata$x:0000E67C                 dd offset __unwindtable$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E680                 db    1
.xdata$x:0000E681                 db    0
.xdata$x:0000E682                 db    0
.xdata$x:0000E683                 db    0
.xdata$x:0000E684                 dd offset __tryblocktable$??$_Uninit_copy@PBUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E688                 db    0
.xdata$x:0000E689                 db    0
.xdata$x:0000E68A                 db    0
.xdata$x:0000E68B                 db    0
.xdata$x:0000E68C                 db    0
.xdata$x:0000E68D                 db    0
.xdata$x:0000E68E                 db    0
.xdata$x:0000E68F                 db    0
.xdata$x:0000E690                 db    0
.xdata$x:0000E691                 db    0
.xdata$x:0000E692                 db    0
.xdata$x:0000E693                 db    0
.xdata$x:0000E694                 db    0
.xdata$x:0000E695                 db    0
.xdata$x:0000E696                 db    0
.xdata$x:0000E697                 db    0
.xdata$x:0000E697 _xdata$x        ends
.xdata$x:0000E697
.xdata$x:0000E698 ; ===========================================================================
.xdata$x:0000E698
.xdata$x:0000E698 ; Segment type: Pure data
.xdata$x:0000E698 ; Segment permissions: Read
.xdata$x:0000E698 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E698                 assume cs:_xdata$x
.xdata$x:0000E698                 ;org 0E698h
.xdata$x:0000E698 ; COMDAT (pick associative to section at 3C10)
.xdata$x:0000E698 __catchsym$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000E698                                         ; DATA XREF: .xdata$x:0000E6C8o
.xdata$x:0000E699                 db    0
.xdata$x:0000E69A                 db    0
.xdata$x:0000E69B                 db    0
.xdata$x:0000E69C                 db    0
.xdata$x:0000E69D                 db    0
.xdata$x:0000E69E                 db    0
.xdata$x:0000E69F                 db    0
.xdata$x:0000E6A0                 db    0
.xdata$x:0000E6A1                 db    0
.xdata$x:0000E6A2                 db    0
.xdata$x:0000E6A3                 db    0
.xdata$x:0000E6A4                 dd offset __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000E6A8 __unwindtable$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000E6A8                                         ; DATA XREF: .xdata$x:0000E6D4o
.xdata$x:0000E6A9                 db 0FFh
.xdata$x:0000E6AA                 db 0FFh
.xdata$x:0000E6AB                 db 0FFh
.xdata$x:0000E6AC                 db    0
.xdata$x:0000E6AD                 db    0
.xdata$x:0000E6AE                 db    0
.xdata$x:0000E6AF                 db    0
.xdata$x:0000E6B0                 db 0FFh
.xdata$x:0000E6B1                 db 0FFh
.xdata$x:0000E6B2                 db 0FFh
.xdata$x:0000E6B3                 db 0FFh
.xdata$x:0000E6B4                 db    0
.xdata$x:0000E6B5                 db    0
.xdata$x:0000E6B6                 db    0
.xdata$x:0000E6B7                 db    0
.xdata$x:0000E6B8 __tryblocktable$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000E6B8                                         ; DATA XREF: .xdata$x:0000E6DCo
.xdata$x:0000E6B9                 db    0
.xdata$x:0000E6BA                 db    0
.xdata$x:0000E6BB                 db    0
.xdata$x:0000E6BC                 db    0
.xdata$x:0000E6BD                 db    0
.xdata$x:0000E6BE                 db    0
.xdata$x:0000E6BF                 db    0
.xdata$x:0000E6C0                 db    1
.xdata$x:0000E6C1                 db    0
.xdata$x:0000E6C2                 db    0
.xdata$x:0000E6C3                 db    0
.xdata$x:0000E6C4                 db    1
.xdata$x:0000E6C5                 db    0
.xdata$x:0000E6C6                 db    0
.xdata$x:0000E6C7                 db    0
.xdata$x:0000E6C8                 dd offset __catchsym$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000E6CC __ehfuncinfo$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000E6CC                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000E6CD                 db    5
.xdata$x:0000E6CE                 db  93h ; ô
.xdata$x:0000E6CF                 db  19h
.xdata$x:0000E6D0                 db    2
.xdata$x:0000E6D1                 db    0
.xdata$x:0000E6D2                 db    0
.xdata$x:0000E6D3                 db    0
.xdata$x:0000E6D4                 dd offset __unwindtable$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E6D8                 db    1
.xdata$x:0000E6D9                 db    0
.xdata$x:0000E6DA                 db    0
.xdata$x:0000E6DB                 db    0
.xdata$x:0000E6DC                 dd offset __tryblocktable$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E6E0                 db    0
.xdata$x:0000E6E1                 db    0
.xdata$x:0000E6E2                 db    0
.xdata$x:0000E6E3                 db    0
.xdata$x:0000E6E4                 db    0
.xdata$x:0000E6E5                 db    0
.xdata$x:0000E6E6                 db    0
.xdata$x:0000E6E7                 db    0
.xdata$x:0000E6E8                 db    0
.xdata$x:0000E6E9                 db    0
.xdata$x:0000E6EA                 db    0
.xdata$x:0000E6EB                 db    0
.xdata$x:0000E6EC                 db    0
.xdata$x:0000E6ED                 db    0
.xdata$x:0000E6EE                 db    0
.xdata$x:0000E6EF                 db    0
.xdata$x:0000E6EF _xdata$x        ends
.xdata$x:0000E6EF
.xdata$x:0000E6F0 ; ===========================================================================
.xdata$x:0000E6F0
.xdata$x:0000E6F0 ; Segment type: Pure data
.xdata$x:0000E6F0 ; Segment permissions: Read
.xdata$x:0000E6F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E6F0                 assume cs:_xdata$x
.xdata$x:0000E6F0                 ;org 0E6F0h
.xdata$x:0000E6F0 ; COMDAT (pick associative to section at 3FE0)
.xdata$x:0000E6F0 __catchsym$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000E6F0                                         ; DATA XREF: .xdata$x:0000E720o
.xdata$x:0000E6F1                 db    0
.xdata$x:0000E6F2                 db    0
.xdata$x:0000E6F3                 db    0
.xdata$x:0000E6F4                 db    0
.xdata$x:0000E6F5                 db    0
.xdata$x:0000E6F6                 db    0
.xdata$x:0000E6F7                 db    0
.xdata$x:0000E6F8                 db    0
.xdata$x:0000E6F9                 db    0
.xdata$x:0000E6FA                 db    0
.xdata$x:0000E6FB                 db    0
.xdata$x:0000E6FC                 dd offset __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000E700 __unwindtable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000E700                                         ; DATA XREF: .xdata$x:0000E72Co
.xdata$x:0000E701                 db 0FFh
.xdata$x:0000E702                 db 0FFh
.xdata$x:0000E703                 db 0FFh
.xdata$x:0000E704                 db    0
.xdata$x:0000E705                 db    0
.xdata$x:0000E706                 db    0
.xdata$x:0000E707                 db    0
.xdata$x:0000E708                 db 0FFh
.xdata$x:0000E709                 db 0FFh
.xdata$x:0000E70A                 db 0FFh
.xdata$x:0000E70B                 db 0FFh
.xdata$x:0000E70C                 db    0
.xdata$x:0000E70D                 db    0
.xdata$x:0000E70E                 db    0
.xdata$x:0000E70F                 db    0
.xdata$x:0000E710 __tryblocktable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000E710                                         ; DATA XREF: .xdata$x:0000E734o
.xdata$x:0000E711                 db    0
.xdata$x:0000E712                 db    0
.xdata$x:0000E713                 db    0
.xdata$x:0000E714                 db    0
.xdata$x:0000E715                 db    0
.xdata$x:0000E716                 db    0
.xdata$x:0000E717                 db    0
.xdata$x:0000E718                 db    1
.xdata$x:0000E719                 db    0
.xdata$x:0000E71A                 db    0
.xdata$x:0000E71B                 db    0
.xdata$x:0000E71C                 db    1
.xdata$x:0000E71D                 db    0
.xdata$x:0000E71E                 db    0
.xdata$x:0000E71F                 db    0
.xdata$x:0000E720                 dd offset __catchsym$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000E724 __ehfuncinfo$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000E724                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000E725                 db    5
.xdata$x:0000E726                 db  93h ; ô
.xdata$x:0000E727                 db  19h
.xdata$x:0000E728                 db    2
.xdata$x:0000E729                 db    0
.xdata$x:0000E72A                 db    0
.xdata$x:0000E72B                 db    0
.xdata$x:0000E72C                 dd offset __unwindtable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E730                 db    1
.xdata$x:0000E731                 db    0
.xdata$x:0000E732                 db    0
.xdata$x:0000E733                 db    0
.xdata$x:0000E734                 dd offset __tryblocktable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000E738                 db    0
.xdata$x:0000E739                 db    0
.xdata$x:0000E73A                 db    0
.xdata$x:0000E73B                 db    0
.xdata$x:0000E73C                 db    0
.xdata$x:0000E73D                 db    0
.xdata$x:0000E73E                 db    0
.xdata$x:0000E73F                 db    0
.xdata$x:0000E740                 db    0
.xdata$x:0000E741                 db    0
.xdata$x:0000E742                 db    0
.xdata$x:0000E743                 db    0
.xdata$x:0000E744                 db    0
.xdata$x:0000E745                 db    0
.xdata$x:0000E746                 db    0
.xdata$x:0000E747                 db    0
.xdata$x:0000E747 _xdata$x        ends
.xdata$x:0000E747
.xdata$x:0000E748 ; ===========================================================================
.xdata$x:0000E748
.xdata$x:0000E748 ; Segment type: Pure data
.xdata$x:0000E748 ; Segment permissions: Read
.xdata$x:0000E748 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000E748                 assume cs:_xdata$x
.xdata$x:0000E748                 ;org 0E748h
.xdata$x:0000E748 ; COMDAT (pick associative to section at 49AC)
.xdata$x:0000E748 __unwindtable$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z db 0FFh
.xdata$x:0000E748                                         ; DATA XREF: .xdata$x:0000E758o
.xdata$x:0000E749                 db 0FFh
.xdata$x:0000E74A                 db 0FFh
.xdata$x:0000E74B                 db 0FFh
.xdata$x:0000E74C                 dd offset __unwindfunclet$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z$0
.xdata$x:0000E750 __ehfuncinfo$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z db  22h ; "
.xdata$x:0000E750                                         ; DATA XREF: __ehhandler$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z+11o
.xdata$x:0000E751                 db    5
.xdata$x:0000E752                 db  93h ; ô
.xdata$x:0000E753                 db  19h
.xdata$x:0000E754                 db    1
.xdata$x:0000E755                 db    0
.xdata$x:0000E756                 db    0
.xdata$x:0000E757                 db    0
.xdata$x:0000E758                 dd offset __unwindtable$??$construct@UrecordedMacroStep@@AAU1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@AAU2@@Z
.xdata$x:0000E75C                 db    0
.xdata$x:0000E75D                 db    0
.xdata$x:0000E75E                 db    0
.xdata$x:0000E75F                 db    0
.xdata$x:0000E760                 db    0
.xdata$x:0000E761                 db    0
.xdata$x:0000E762                 db    0
.xdata$x:0000E763                 db    0
.xdata$x:0000E764                 db    0
.xdata$x:0000E765                 db    0
.xdata$x:0000E766                 db    0
.xdata$x:0000E767                 db    0
.xdata$x:0000E768                 db    0
.xdata$x:0000E769                 db    0
.xdata$x:0000E76A                 db    0
.xdata$x:0000E76B                 db    0
.xdata$x:0000E76C                 db    0
.xdata$x:0000E76D                 db    0
.xdata$x:0000E76E                 db    0
.xdata$x:0000E76F                 db    0
.xdata$x:0000E770                 db    0
.xdata$x:0000E771                 db    0
.xdata$x:0000E772                 db    0
.xdata$x:0000E773                 db    0
.xdata$x:0000E773 _xdata$x        ends
.xdata$x:0000E773
.rdata:0000E774 ; ===========================================================================
.rdata:0000E774
.rdata:0000E774 ; Segment type: Pure data
.rdata:0000E774 ; Segment permissions: Read
.rdata:0000E774 _rdata          segment dword public 'DATA' use32
.rdata:0000E774                 assume cs:_rdata
.rdata:0000E774                 ;org 0E774h
.rdata:0000E774 ; COMDAT (pick largest)
.rdata:0000E774                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:0000E778                 public ??_7Window@@6B@
.rdata:0000E778 ; const Window::`vftable'
.rdata:0000E778 ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:0000E778                                         ; DATA XREF: Window::Window(void)+Ao
.rdata:0000E778                                         ; Window::~Window(void)+Ao
.rdata:0000E778                                         ; Window::`vector deleting destructor'(uint)
.rdata:0000E77C                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000E780                 dd offset __purecall
.rdata:0000E784                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:0000E788                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000E78C                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000E790                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000E794                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000E798                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000E79C                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000E7A0                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000E7A4                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000E7A4 _rdata          ends
.rdata:0000E7A4
.rdata:0000E7A8 ; ===========================================================================
.rdata:0000E7A8
.rdata:0000E7A8 ; Segment type: Pure data
.rdata:0000E7A8 ; Segment permissions: Read
.rdata:0000E7A8 _rdata          segment dword public 'DATA' use32
.rdata:0000E7A8                 assume cs:_rdata
.rdata:0000E7A8                 ;org 0E7A8h
.rdata:0000E7A8 ; COMDAT (pick largest)
.rdata:0000E7A8                 dd offset ??_R4StaticDialog@@6B@ ; const StaticDialog::`RTTI Complete Object Locator'
.rdata:0000E7AC                 public ??_7StaticDialog@@6B@
.rdata:0000E7AC ; const StaticDialog::`vftable'
.rdata:0000E7AC ??_7StaticDialog@@6B@ dd offset ??_EStaticDialog@@UAEPAXI@Z
.rdata:0000E7AC                                         ; DATA XREF: StaticDialog::StaticDialog(void)+38o
.rdata:0000E7AC                                         ; StaticDialog::~StaticDialog(void)+29o
.rdata:0000E7AC                                         ; StaticDialog::`vector deleting destructor'(uint)
.rdata:0000E7B0                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000E7B4                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000E7B8                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000E7BC                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000E7C0                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000E7C4                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000E7C8                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000E7CC                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000E7D0                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000E7D4                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000E7D8                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000E7DC                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000E7E0                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000E7E4                 dd offset __purecall
.rdata:0000E7E4 _rdata          ends
.rdata:0000E7E4
.bss:0000E7E8 ; ===========================================================================
.bss:0000E7E8
.bss:0000E7E8 ; Segment type: Uninitialized
.bss:0000E7E8 ; Segment permissions: Read/Write
.bss:0000E7E8 _bss            segment byte public 'BSS' use32
.bss:0000E7E8                 assume cs:_bss
.bss:0000E7E8                 ;org 0E7E8h
.bss:0000E7E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000E7E8 __Tuple_alloc   db    ? ;
.bss:0000E7E9 ; std::_Ignore ignore
.bss:0000E7E9 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:0000E7EA _allocator_arg  db    ? ;
.bss:0000E7EB _piecewise_construct db    ? ;
.bss:0000E7EB _bss            ends
.bss:0000E7EB
.rdata:0000E7EC ; ===========================================================================
.rdata:0000E7EC
.rdata:0000E7EC ; Segment type: Pure data
.rdata:0000E7EC ; Segment permissions: Read
.rdata:0000E7EC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E7EC _rdata          segment para public 'DATA' use32
.rdata:0000E7EC                 assume cs:_rdata
.rdata:0000E7EC                 ;org 0E7ECh
.rdata:0000E7EC ; COMDAT (pick any)
.rdata:0000E7EC                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000E7EC ; wchar_t `string'
.rdata:0000E7EC ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000E7EC                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:0000E7EC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000E7EC                 unicode 0, <clude\xutility>,0
.rdata:0000E7EC _rdata          ends
.rdata:0000E7EC
.rdata:0000E87C ; ===========================================================================
.rdata:0000E87C
.rdata:0000E87C ; Segment type: Pure data
.rdata:0000E87C ; Segment permissions: Read
.rdata:0000E87C _rdata          segment dword public 'DATA' use32
.rdata:0000E87C                 assume cs:_rdata
.rdata:0000E87C                 ;org 0E87Ch
.rdata:0000E87C ; COMDAT (pick any)
.rdata:0000E87C                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000E87C ; wchar_t `string'
.rdata:0000E87C ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000E87C                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000E87C                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000E8AE                 align 10h
.rdata:0000E8AE _rdata          ends
.rdata:0000E8AE
.rdata:0000E8B0 ; ===========================================================================
.rdata:0000E8B0
.rdata:0000E8B0 ; Segment type: Pure data
.rdata:0000E8B0 ; Segment permissions: Read
.rdata:0000E8B0 _rdata          segment dword public 'DATA' use32
.rdata:0000E8B0                 assume cs:_rdata
.rdata:0000E8B0                 ;org 0E8B0h
.rdata:0000E8B0 ; COMDAT (pick largest)
.rdata:0000E8B0                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000E8B4                 public ??_7error_category@std@@6B@
.rdata:0000E8B4 ; const std::error_category::`vftable'
.rdata:0000E8B4 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000E8B4                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000E8B4                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000E8B4                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000E8B8                 dd offset __purecall
.rdata:0000E8BC                 dd offset __purecall
.rdata:0000E8C0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000E8C4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000E8C8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000E8C8 _rdata          ends
.rdata:0000E8C8
.rdata:0000E8CC ; ===========================================================================
.rdata:0000E8CC
.rdata:0000E8CC ; Segment type: Pure data
.rdata:0000E8CC ; Segment permissions: Read
.rdata:0000E8CC _rdata          segment dword public 'DATA' use32
.rdata:0000E8CC                 assume cs:_rdata
.rdata:0000E8CC                 ;org 0E8CCh
.rdata:0000E8CC ; COMDAT (pick largest)
.rdata:0000E8CC                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000E8D0                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000E8D0 ; const std::_Generic_error_category::`vftable'
.rdata:0000E8D0 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000E8D0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000E8D0                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000E8D4                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000E8D8                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000E8DC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000E8E0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000E8E4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000E8E4 _rdata          ends
.rdata:0000E8E4
.rdata:0000E8E8 ; ===========================================================================
.rdata:0000E8E8
.rdata:0000E8E8 ; Segment type: Pure data
.rdata:0000E8E8 ; Segment permissions: Read
.rdata:0000E8E8 _rdata          segment dword public 'DATA' use32
.rdata:0000E8E8                 assume cs:_rdata
.rdata:0000E8E8                 ;org 0E8E8h
.rdata:0000E8E8 ; COMDAT (pick any)
.rdata:0000E8E8                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000E8E8 ; `string'
.rdata:0000E8E8 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000E8E8                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000E8E8 _rdata          ends
.rdata:0000E8E8
.rdata:0000E8F0 ; ===========================================================================
.rdata:0000E8F0
.rdata:0000E8F0 ; Segment type: Pure data
.rdata:0000E8F0 ; Segment permissions: Read
.rdata:0000E8F0 _rdata          segment dword public 'DATA' use32
.rdata:0000E8F0                 assume cs:_rdata
.rdata:0000E8F0                 ;org 0E8F0h
.rdata:0000E8F0 ; COMDAT (pick any)
.rdata:0000E8F0                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000E8F0 ; `string'
.rdata:0000E8F0 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000E8F0                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_C3F0o
.rdata:0000E8F0                                         ; std::_System_error_category::message(int):loc_C56Co
.rdata:0000E8FE                 align 10h
.rdata:0000E8FE _rdata          ends
.rdata:0000E8FE
.rdata:0000E900 ; ===========================================================================
.rdata:0000E900
.rdata:0000E900 ; Segment type: Pure data
.rdata:0000E900 ; Segment permissions: Read
.rdata:0000E900 _rdata          segment dword public 'DATA' use32
.rdata:0000E900                 assume cs:_rdata
.rdata:0000E900                 ;org 0E900h
.rdata:0000E900 ; COMDAT (pick largest)
.rdata:0000E900                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000E904                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000E904 ; const std::_Iostream_error_category::`vftable'
.rdata:0000E904 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000E904                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000E904                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000E908                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000E90C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000E910                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000E914                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000E918                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000E918 _rdata          ends
.rdata:0000E918
.rdata:0000E91C ; ===========================================================================
.rdata:0000E91C
.rdata:0000E91C ; Segment type: Pure data
.rdata:0000E91C ; Segment permissions: Read
.rdata:0000E91C _rdata          segment dword public 'DATA' use32
.rdata:0000E91C                 assume cs:_rdata
.rdata:0000E91C                 ;org 0E91Ch
.rdata:0000E91C ; COMDAT (pick any)
.rdata:0000E91C                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000E91C ; `string'
.rdata:0000E91C ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000E91C                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000E925                 align 4
.rdata:0000E925 _rdata          ends
.rdata:0000E925
.rdata:0000E928 ; ===========================================================================
.rdata:0000E928
.rdata:0000E928 ; Segment type: Pure data
.rdata:0000E928 ; Segment permissions: Read
.rdata:0000E928 _rdata          segment dword public 'DATA' use32
.rdata:0000E928                 assume cs:_rdata
.rdata:0000E928                 ;org 0E928h
.rdata:0000E928 ; COMDAT (pick any)
.rdata:0000E928                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000E928 ; char `string'[]
.rdata:0000E928 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000E928                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000E93E                 align 10h
.rdata:0000E93E _rdata          ends
.rdata:0000E93E
.rdata:0000E940 ; ===========================================================================
.rdata:0000E940
.rdata:0000E940 ; Segment type: Pure data
.rdata:0000E940 ; Segment permissions: Read
.rdata:0000E940 _rdata          segment dword public 'DATA' use32
.rdata:0000E940                 assume cs:_rdata
.rdata:0000E940                 ;org 0E940h
.rdata:0000E940 ; COMDAT (pick largest)
.rdata:0000E940                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000E944                 public ??_7_System_error_category@std@@6B@
.rdata:0000E944 ; const std::_System_error_category::`vftable'
.rdata:0000E944 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000E944                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000E944                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000E948                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000E94C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000E950                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000E954                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000E958                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000E958 _rdata          ends
.rdata:0000E958
.rdata:0000E95C ; ===========================================================================
.rdata:0000E95C
.rdata:0000E95C ; Segment type: Pure data
.rdata:0000E95C ; Segment permissions: Read
.rdata:0000E95C _rdata          segment dword public 'DATA' use32
.rdata:0000E95C                 assume cs:_rdata
.rdata:0000E95C                 ;org 0E95Ch
.rdata:0000E95C ; COMDAT (pick any)
.rdata:0000E95C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000E95C ; `string'
.rdata:0000E95C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000E95C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000E963                 align 4
.rdata:0000E963 _rdata          ends
.rdata:0000E963
.bss:0000E964 ; ===========================================================================
.bss:0000E964
.bss:0000E964 ; Segment type: Uninitialized
.bss:0000E964 ; Segment permissions: Read/Write
.bss:0000E964 _bss            segment dword public 'BSS' use32
.bss:0000E964                 assume cs:_bss
.bss:0000E964                 ;org 0E964h
.bss:0000E964 ; COMDAT (pick any)
.bss:0000E964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000E964                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000E964 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000E964 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000E964                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000E964                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000E965                 db    ? ;
.bss:0000E966                 db    ? ;
.bss:0000E967                 db    ? ;
.bss:0000E967 _bss            ends
.bss:0000E967
.bss:0000E968 ; ===========================================================================
.bss:0000E968
.bss:0000E968 ; Segment type: Uninitialized
.bss:0000E968 ; Segment permissions: Read/Write
.bss:0000E968 _bss            segment dword public 'BSS' use32
.bss:0000E968                 assume cs:_bss
.bss:0000E968                 ;org 0E968h
.bss:0000E968 ; COMDAT (pick any)
.bss:0000E968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000E968                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000E968 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000E968 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000E968                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000E968                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000E969                 db    ? ;
.bss:0000E96A                 db    ? ;
.bss:0000E96B                 db    ? ;
.bss:0000E96B _bss            ends
.bss:0000E96B
.bss:0000E96C ; ===========================================================================
.bss:0000E96C
.bss:0000E96C ; Segment type: Uninitialized
.bss:0000E96C ; Segment permissions: Read/Write
.bss:0000E96C _bss            segment dword public 'BSS' use32
.bss:0000E96C                 assume cs:_bss
.bss:0000E96C                 ;org 0E96Ch
.bss:0000E96C ; COMDAT (pick any)
.bss:0000E96C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000E96C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000E96C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000E96C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000E96C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000E96C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000E96D                 db    ? ;
.bss:0000E96E                 db    ? ;
.bss:0000E96F                 db    ? ;
.bss:0000E96F _bss            ends
.bss:0000E96F
.rdata:0000E970 ; ===========================================================================
.rdata:0000E970
.rdata:0000E970 ; Segment type: Pure data
.rdata:0000E970 ; Segment permissions: Read
.rdata:0000E970 _rdata          segment dword public 'DATA' use32
.rdata:0000E970                 assume cs:_rdata
.rdata:0000E970                 ;org 0E970h
.rdata:0000E970 ; COMDAT (pick any)
.rdata:0000E970                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000E970 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000E970 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000E970                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:0000E970                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7r
.rdata:0000E970 _rdata          ends
.rdata:0000E970
.bss:0000E974 ; ===========================================================================
.bss:0000E974
.bss:0000E974 ; Segment type: Uninitialized
.bss:0000E974 ; Segment permissions: Read/Write
.bss:0000E974 _bss            segment dword public 'BSS' use32
.bss:0000E974                 assume cs:_bss
.bss:0000E974                 ;org 0E974h
.bss:0000E974 ; COMDAT (pick any)
.bss:0000E974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000E974                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000E974 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000E974 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000E974                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000E975                 db    ? ;
.bss:0000E976                 db    ? ;
.bss:0000E977                 db    ? ;
.bss:0000E977 _bss            ends
.bss:0000E977
.bss:0000E978 ; ===========================================================================
.bss:0000E978
.bss:0000E978 ; Segment type: Uninitialized
.bss:0000E978 ; Segment permissions: Read/Write
.bss:0000E978 _bss            segment dword public 'BSS' use32
.bss:0000E978                 assume cs:_bss
.bss:0000E978                 ;org 0E978h
.bss:0000E978 ; COMDAT (pick any)
.bss:0000E978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000E978                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000E978 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000E978 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000E978                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000E979                 db    ? ;
.bss:0000E97A                 db    ? ;
.bss:0000E97B                 db    ? ;
.bss:0000E97B _bss            ends
.bss:0000E97B
.rdata:0000E97C ; ===========================================================================
.rdata:0000E97C
.rdata:0000E97C ; Segment type: Pure data
.rdata:0000E97C ; Segment permissions: Read
.rdata:0000E97C _rdata          segment dword public 'DATA' use32
.rdata:0000E97C                 assume cs:_rdata
.rdata:0000E97C                 ;org 0E97Ch
.rdata:0000E97C ; COMDAT (pick largest)
.rdata:0000E97C                 dd offset ??_R4Shortcut@@6B@ ; const Shortcut::`RTTI Complete Object Locator'
.rdata:0000E980                 public ??_7Shortcut@@6B@
.rdata:0000E980 ; const Shortcut::`vftable'
.rdata:0000E980 ??_7Shortcut@@6B@ dd offset ??_EShortcut@@UAEPAXI@Z
.rdata:0000E980                                         ; DATA XREF: Shortcut::Shortcut(Shortcut const &)+38o
.rdata:0000E980                                         ; Shortcut::`vector deleting destructor'(uint)
.rdata:0000E984                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000E988                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000E98C                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000E990                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000E994                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000E998                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000E99C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000E9A0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000E9A4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000E9A8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000E9AC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000E9B0                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000E9B4                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000E9B8                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000E9BC                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000E9C0                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:0000E9C4                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000E9C8                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000E9C8 _rdata          ends
.rdata:0000E9C8
.rdata:0000E9CC ; ===========================================================================
.rdata:0000E9CC
.rdata:0000E9CC ; Segment type: Pure data
.rdata:0000E9CC ; Segment permissions: Read
.rdata:0000E9CC _rdata          segment dword public 'DATA' use32
.rdata:0000E9CC                 assume cs:_rdata
.rdata:0000E9CC                 ;org 0E9CCh
.rdata:0000E9CC ; COMDAT (pick largest)
.rdata:0000E9CC                 dd offset ??_R4CommandShortcut@@6B@ ; const CommandShortcut::`RTTI Complete Object Locator'
.rdata:0000E9D0                 public ??_7CommandShortcut@@6B@
.rdata:0000E9D0 ; const CommandShortcut::`vftable'
.rdata:0000E9D0 ??_7CommandShortcut@@6B@ dd offset ??_ECommandShortcut@@UAEPAXI@Z
.rdata:0000E9D0                                         ; DATA XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+3Co
.rdata:0000E9D0                                         ; CommandShortcut::`vector deleting destructor'(uint)
.rdata:0000E9D4                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000E9D8                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000E9DC                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000E9E0                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000E9E4                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000E9E8                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000E9EC                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000E9F0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000E9F4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000E9F8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000E9FC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000EA00                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000EA04                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000EA08                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000EA0C                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000EA10                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:0000EA14                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000EA18                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000EA18 _rdata          ends
.rdata:0000EA18
.rdata:0000EA1C ; ===========================================================================
.rdata:0000EA1C
.rdata:0000EA1C ; Segment type: Pure data
.rdata:0000EA1C ; Segment permissions: Read
.rdata:0000EA1C _rdata          segment dword public 'DATA' use32
.rdata:0000EA1C                 assume cs:_rdata
.rdata:0000EA1C                 ;org 0EA1Ch
.rdata:0000EA1C ; COMDAT (pick largest)
.rdata:0000EA1C                 dd offset ??_R4ScintillaKeyMap@@6B@ ; const ScintillaKeyMap::`RTTI Complete Object Locator'
.rdata:0000EA20                 public ??_7ScintillaKeyMap@@6B@
.rdata:0000EA20 ; const ScintillaKeyMap::`vftable'
.rdata:0000EA20 ??_7ScintillaKeyMap@@6B@ dd offset ??_EScintillaKeyMap@@UAEPAXI@Z
.rdata:0000EA20                                         ; DATA XREF: ScintillaKeyMap::ScintillaKeyMap(ScintillaKeyMap const &)+3Co
.rdata:0000EA20                                         ; ScintillaKeyMap::`vector deleting destructor'(uint)
.rdata:0000EA24                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000EA28                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000EA2C                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000EA30                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000EA34                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000EA38                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000EA3C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000EA40                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000EA44                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000EA48                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000EA4C                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000EA50                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000EA54                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000EA58                 dd offset ?run_dlgProc@ScintillaKeyMap@@MAGHIIJ@Z ; ScintillaKeyMap::run_dlgProc(uint,uint,long)
.rdata:0000EA5C                 dd offset ?doDialog@ScintillaKeyMap@@UAEHXZ ; ScintillaKeyMap::doDialog(void)
.rdata:0000EA60                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:0000EA64                 dd offset ?isEnabled@ScintillaKeyMap@@UBE_NXZ ; ScintillaKeyMap::isEnabled(void)
.rdata:0000EA68                 dd offset ?toString@ScintillaKeyMap@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; ScintillaKeyMap::toString(void)
.rdata:0000EA68 _rdata          ends
.rdata:0000EA68
.rdata:0000EA6C ; ===========================================================================
.rdata:0000EA6C
.rdata:0000EA6C ; Segment type: Pure data
.rdata:0000EA6C ; Segment permissions: Read
.rdata:0000EA6C _rdata          segment dword public 'DATA' use32
.rdata:0000EA6C                 assume cs:_rdata
.rdata:0000EA6C                 ;org 0EA6Ch
.rdata:0000EA6C ; COMDAT (pick largest)
.rdata:0000EA6C                 dd offset ??_R4MacroShortcut@@6B@ ; const MacroShortcut::`RTTI Complete Object Locator'
.rdata:0000EA70                 public ??_7MacroShortcut@@6B@
.rdata:0000EA70 ; const MacroShortcut::`vftable'
.rdata:0000EA70 ??_7MacroShortcut@@6B@ dd offset ??_EMacroShortcut@@UAEPAXI@Z
.rdata:0000EA70                                         ; DATA XREF: MacroShortcut::MacroShortcut(MacroShortcut const &)+3Co
.rdata:0000EA70                                         ; MacroShortcut::`vector deleting destructor'(uint)
.rdata:0000EA74                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000EA78                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000EA7C                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000EA80                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000EA84                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000EA88                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000EA8C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000EA90                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000EA94                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000EA98                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000EA9C                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000EAA0                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000EAA4                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000EAA8                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000EAAC                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000EAB0                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:0000EAB4                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000EAB8                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000EAB8 _rdata          ends
.rdata:0000EAB8
.rdata:0000EABC ; ===========================================================================
.rdata:0000EABC
.rdata:0000EABC ; Segment type: Pure data
.rdata:0000EABC ; Segment permissions: Read
.rdata:0000EABC _rdata          segment dword public 'DATA' use32
.rdata:0000EABC                 assume cs:_rdata
.rdata:0000EABC                 ;org 0EABCh
.rdata:0000EABC ; COMDAT (pick largest)
.rdata:0000EABC                 dd offset ??_R4UserCommand@@6B@ ; const UserCommand::`RTTI Complete Object Locator'
.rdata:0000EAC0                 public ??_7UserCommand@@6B@
.rdata:0000EAC0 ; const UserCommand::`vftable'
.rdata:0000EAC0 ??_7UserCommand@@6B@ dd offset ??_EUserCommand@@UAEPAXI@Z
.rdata:0000EAC0                                         ; DATA XREF: UserCommand::UserCommand(UserCommand const &)+3Co
.rdata:0000EAC0                                         ; UserCommand::`vector deleting destructor'(uint)
.rdata:0000EAC4                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000EAC8                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000EACC                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000EAD0                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000EAD4                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000EAD8                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000EADC                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000EAE0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000EAE4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000EAE8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000EAEC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000EAF0                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000EAF4                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000EAF8                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000EAFC                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000EB00                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:0000EB04                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000EB08                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000EB08 _rdata          ends
.rdata:0000EB08
.rdata:0000EB0C ; ===========================================================================
.rdata:0000EB0C
.rdata:0000EB0C ; Segment type: Pure data
.rdata:0000EB0C ; Segment permissions: Read
.rdata:0000EB0C _rdata          segment dword public 'DATA' use32
.rdata:0000EB0C                 assume cs:_rdata
.rdata:0000EB0C                 ;org 0EB0Ch
.rdata:0000EB0C ; COMDAT (pick largest)
.rdata:0000EB0C                 dd offset ??_R4PluginCmdShortcut@@6B@ ; const PluginCmdShortcut::`RTTI Complete Object Locator'
.rdata:0000EB10                 public ??_7PluginCmdShortcut@@6B@
.rdata:0000EB10 ; const PluginCmdShortcut::`vftable'
.rdata:0000EB10 ??_7PluginCmdShortcut@@6B@ dd offset ??_EPluginCmdShortcut@@UAEPAXI@Z
.rdata:0000EB10                                         ; DATA XREF: PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)+3Co
.rdata:0000EB10                                         ; PluginCmdShortcut::`vector deleting destructor'(uint)
.rdata:0000EB14                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000EB18                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000EB1C                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000EB20                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000EB24                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000EB28                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000EB2C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000EB30                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000EB34                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000EB38                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000EB3C                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000EB40                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000EB44                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000EB48                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000EB4C                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000EB50                 dd offset ?isValid@PluginCmdShortcut@@UBE_NXZ ; PluginCmdShortcut::isValid(void)
.rdata:0000EB54                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000EB58                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000EB58 _rdata          ends
.rdata:0000EB58
.rdata:0000EB5C ; ===========================================================================
.rdata:0000EB5C
.rdata:0000EB5C ; Segment type: Pure data
.rdata:0000EB5C ; Segment permissions: Read
.rdata:0000EB5C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000EB5C _rdata          segment para public 'DATA' use32
.rdata:0000EB5C                 assume cs:_rdata
.rdata:0000EB5C                 ;org 0EB5Ch
.rdata:0000EB5C ; COMDAT (pick any)
.rdata:0000EB5C                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000EB5C ; wchar_t `string'
.rdata:0000EB5C ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000EB5C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+17o
.rdata:0000EB5C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co ...
.rdata:0000EB5C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000EB5C                 unicode 0, <clude\xstring>,0
.rdata:0000EBEA                 align 4
.rdata:0000EBEA _rdata          ends
.rdata:0000EBEA
.rdata:0000EBEC ; ===========================================================================
.rdata:0000EBEC
.rdata:0000EBEC ; Segment type: Pure data
.rdata:0000EBEC ; Segment permissions: Read
.rdata:0000EBEC _rdata          segment dword public 'DATA' use32
.rdata:0000EBEC                 assume cs:_rdata
.rdata:0000EBEC                 ;org 0EBECh
.rdata:0000EBEC ; COMDAT (pick any)
.rdata:0000EBEC                 public ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000EBEC ; wchar_t `string'
.rdata:0000EBEC ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000EBEC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+1Co
.rdata:0000EBEC                 unicode 0, <string subscript out of range>,0
.rdata:0000EBEC _rdata          ends
.rdata:0000EBEC
.bss:0000EC28 ; ===========================================================================
.bss:0000EC28
.bss:0000EC28 ; Segment type: Uninitialized
.bss:0000EC28 ; Segment permissions: Read/Write
.bss:0000EC28 _bss            segment dword public 'BSS' use32
.bss:0000EC28                 assume cs:_bss
.bss:0000EC28                 ;org 0EC28h
.bss:0000EC28 ; COMDAT (pick any)
.bss:0000EC28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000EC28                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000EC28 ; std::locale::id std::numpunct<char>::id
.bss:0000EC28 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000EC28                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000EC29                 db    ? ;
.bss:0000EC2A                 db    ? ;
.bss:0000EC2B                 db    ? ;
.bss:0000EC2B _bss            ends
.bss:0000EC2B
.bss:0000EC2C ; ===========================================================================
.bss:0000EC2C
.bss:0000EC2C ; Segment type: Uninitialized
.bss:0000EC2C ; Segment permissions: Read/Write
.bss:0000EC2C _bss            segment dword public 'BSS' use32
.bss:0000EC2C                 assume cs:_bss
.bss:0000EC2C                 ;org 0EC2Ch
.bss:0000EC2C ; COMDAT (pick any)
.bss:0000EC2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000EC2C                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000EC2C ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000EC2C ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000EC2C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000EC2D                 db    ? ;
.bss:0000EC2E                 db    ? ;
.bss:0000EC2F                 db    ? ;
.bss:0000EC2F _bss            ends
.bss:0000EC2F
.rdata:0000EC30 ; ===========================================================================
.rdata:0000EC30
.rdata:0000EC30 ; Segment type: Pure data
.rdata:0000EC30 ; Segment permissions: Read
.rdata:0000EC30 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000EC30 _rdata          segment para public 'DATA' use32
.rdata:0000EC30                 assume cs:_rdata
.rdata:0000EC30                 ;org 0EC30h
.rdata:0000EC30 ; COMDAT (pick any)
.rdata:0000EC30                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000EC30 ; wchar_t `string'
.rdata:0000EC30 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000EC30                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+19o
.rdata:0000EC30                                         ; std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+49o ...
.rdata:0000EC30                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000EC30                 unicode 0, <clude\vector>,0
.rdata:0000EC30 _rdata          ends
.rdata:0000EC30
.rdata:0000ECBC ; ===========================================================================
.rdata:0000ECBC
.rdata:0000ECBC ; Segment type: Pure data
.rdata:0000ECBC ; Segment permissions: Read
.rdata:0000ECBC _rdata          segment dword public 'DATA' use32
.rdata:0000ECBC                 assume cs:_rdata
.rdata:0000ECBC                 ;org 0ECBCh
.rdata:0000ECBC ; COMDAT (pick any)
.rdata:0000ECBC                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000ECBC ; wchar_t `string'
.rdata:0000ECBC ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000ECBC                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+1Eo
.rdata:0000ECBC                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+1Eo ...
.rdata:0000ECBC                 unicode 0, <vector subscript out of range>,0
.rdata:0000ECBC _rdata          ends
.rdata:0000ECBC
.rdata:0000ECF8 ; ===========================================================================
.rdata:0000ECF8
.rdata:0000ECF8 ; Segment type: Pure data
.rdata:0000ECF8 ; Segment permissions: Read
.rdata:0000ECF8 _rdata          segment dword public 'DATA' use32
.rdata:0000ECF8                 assume cs:_rdata
.rdata:0000ECF8                 ;org 0ECF8h
.rdata:0000ECF8 ; COMDAT (pick any)
.rdata:0000ECF8                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000ECF8 ; `string'
.rdata:0000ECF8 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000ECF8                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+2Bo
.rdata:0000ECF8                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+2Bo ...
.rdata:0000ECF8 _rdata          ends
.rdata:0000ECF8
.rdata:0000ED1C ; ===========================================================================
.rdata:0000ED1C
.rdata:0000ED1C ; Segment type: Pure data
.rdata:0000ED1C ; Segment permissions: Read
.rdata:0000ED1C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000ED1C _rdata          segment para public 'DATA' use32
.rdata:0000ED1C                 assume cs:_rdata
.rdata:0000ED1C                 ;org 0ED1Ch
.rdata:0000ED1C ; COMDAT (pick any)
.rdata:0000ED1C                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000ED1C ; `string'
.rdata:0000ED1C ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000ED1C                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint):loc_88C0o
.rdata:0000ED1C                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint):loc_8950o ...
.rdata:0000ED1C                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000ED72                 align 4
.rdata:0000ED72 _rdata          ends
.rdata:0000ED72
.rdata:0000ED74 ; ===========================================================================
.rdata:0000ED74
.rdata:0000ED74 ; Segment type: Pure data
.rdata:0000ED74 ; Segment permissions: Read
.rdata:0000ED74 _rdata          segment dword public 'DATA' use32
.rdata:0000ED74                 assume cs:_rdata
.rdata:0000ED74                 ;org 0ED74h
.rdata:0000ED74 ; COMDAT (pick any)
.rdata:0000ED74                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000ED74 ; `string'
.rdata:0000ED74 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000ED74                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+3Do
.rdata:0000ED74                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+3Do ...
.rdata:0000ED74                 unicode 0, <%s>,0
.rdata:0000ED7A                 align 4
.rdata:0000ED7A _rdata          ends
.rdata:0000ED7A
.rdata:0000ED7C ; ===========================================================================
.rdata:0000ED7C
.rdata:0000ED7C ; Segment type: Pure data
.rdata:0000ED7C ; Segment permissions: Read
.rdata:0000ED7C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000ED7C _rdata          segment para public 'DATA' use32
.rdata:0000ED7C                 assume cs:_rdata
.rdata:0000ED7C                 ;org 0ED7Ch
.rdata:0000ED7C ; COMDAT (pick any)
.rdata:0000ED7C                 public ??_C@_1KC@KHKGAADA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAK?$AAe?$AAy?$AAC?$AAo?$AAm?$AAb?$AAo?$AA?0?$AAc?$AAl?$AAa?$AAs@
.rdata:0000ED7C ; `string'
.rdata:0000ED7C ??_C@_1KC@KHKGAADA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAK?$AAe?$AAy?$AAC?$AAo?$AAm?$AAb?$AAo?$AA?0?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000ED7C                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+6Ao
.rdata:0000ED7C                 unicode 0, <std::vector>
.rdata:0000ED7C                 dw 3Ch
.rdata:0000ED7C                 unicode 0, <struct KeyCombo,class std::allocator>
.rdata:0000ED7C                 dw 3Ch
.rdata:0000ED7C                 unicode 0, <struct KeyCombo>
.rdata:0000ED7C                 dw 3Eh
.rdata:0000ED7C                 unicode 0, < >
.rdata:0000ED7C                 dw 3Eh
.rdata:0000ED7C                 unicode 0, <::operator []>,0
.rdata:0000EE1E                 align 10h
.rdata:0000EE1E _rdata          ends
.rdata:0000EE1E
.rdata:0000EE20 ; ===========================================================================
.rdata:0000EE20
.rdata:0000EE20 ; Segment type: Pure data
.rdata:0000EE20 ; Segment permissions: Read
.rdata:0000EE20 _rdata          segment dword public 'DATA' use32
.rdata:0000EE20                 assume cs:_rdata
.rdata:0000EE20                 ;org 0EE20h
.rdata:0000EE20 ; COMDAT (pick any)
.rdata:0000EE20                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000EE20 ; `string'
.rdata:0000EE20 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000EE20                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+6Fo
.rdata:0000EE20                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+6Fo ...
.rdata:0000EE20                 unicode 0, <"out of range">,0
.rdata:0000EE3E                 align 10h
.rdata:0000EE3E _rdata          ends
.rdata:0000EE3E
.rdata:0000EE40 ; ===========================================================================
.rdata:0000EE40
.rdata:0000EE40 ; Segment type: Pure data
.rdata:0000EE40 ; Segment permissions: Read
.rdata:0000EE40 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000EE40 _rdata          segment para public 'DATA' use32
.rdata:0000EE40                 assume cs:_rdata
.rdata:0000EE40                 ;org 0EE40h
.rdata:0000EE40 ; COMDAT (pick any)
.rdata:0000EE40                 public ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
.rdata:0000EE40 ; wchar_t `string'
.rdata:0000EE40 ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@:
.rdata:0000EE40                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>)+63o
.rdata:0000EE40                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>)+63o
.rdata:0000EE40                 unicode 0, <vector erase iterator outside range>,0
.rdata:0000EE40 _rdata          ends
.rdata:0000EE40
.rdata:0000EE88 ; ===========================================================================
.rdata:0000EE88
.rdata:0000EE88 ; Segment type: Pure data
.rdata:0000EE88 ; Segment permissions: Read
.rdata:0000EE88 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000EE88 _rdata          segment para public 'DATA' use32
.rdata:0000EE88                 assume cs:_rdata
.rdata:0000EE88                 ;org 0EE88h
.rdata:0000EE88 ; COMDAT (pick any)
.rdata:0000EE88                 public ??_C@_1LK@BFNMKIGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu@
.rdata:0000EE88 ; `string'
.rdata:0000EE88 ??_C@_1LK@BFNMKIGH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu@:
.rdata:0000EE88                                         ; DATA XREF: std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+6Ao
.rdata:0000EE88                 unicode 0, <std::vector>
.rdata:0000EE88                 dw 3Ch
.rdata:0000EE88                 unicode 0, <class CommandShortcut,class std::allocator>
.rdata:0000EE88                 dw 3Ch
.rdata:0000EE88                 unicode 0, <class CommandShortcut>
.rdata:0000EE88                 dw 3Eh
.rdata:0000EE88                 unicode 0, < >
.rdata:0000EE88                 dw 3Eh
.rdata:0000EE88                 unicode 0, <::operator []>,0
.rdata:0000EF42                 align 4
.rdata:0000EF42 _rdata          ends
.rdata:0000EF42
.rdata:0000EF44 ; ===========================================================================
.rdata:0000EF44
.rdata:0000EF44 ; Segment type: Pure data
.rdata:0000EF44 ; Segment permissions: Read
.rdata:0000EF44 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000EF44 _rdata          segment para public 'DATA' use32
.rdata:0000EF44                 assume cs:_rdata
.rdata:0000EF44                 ;org 0EF44h
.rdata:0000EF44 ; COMDAT (pick any)
.rdata:0000EF44                 public ??_C@_1LC@OPANGMDH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAM?$AAa?$AAc?$AAr?$AAo?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu?$AAt?$AA?0@
.rdata:0000EF44 ; `string'
.rdata:0000EF44 ??_C@_1LC@OPANGMDH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAM?$AAa?$AAc?$AAr?$AAo?$AAS?$AAh?$AAo?$AAr?$AAt?$AAc?$AAu?$AAt?$AA?0@:
.rdata:0000EF44                                         ; DATA XREF: std::vector<MacroShortcut,std::allocator<MacroShortcut>>::operator[](uint)+6Ao
.rdata:0000EF44                 unicode 0, <std::vector>
.rdata:0000EF44                 dw 3Ch
.rdata:0000EF44                 unicode 0, <class MacroShortcut,class std::allocator>
.rdata:0000EF44                 dw 3Ch
.rdata:0000EF44                 unicode 0, <class MacroShortcut>
.rdata:0000EF44                 dw 3Eh
.rdata:0000EF44                 unicode 0, < >
.rdata:0000EF44                 dw 3Eh
.rdata:0000EF44                 unicode 0, <::operator []>,0
.rdata:0000EFF6                 align 4
.rdata:0000EFF6 _rdata          ends
.rdata:0000EFF6
.rdata:0000EFF8 ; ===========================================================================
.rdata:0000EFF8
.rdata:0000EFF8 ; Segment type: Pure data
.rdata:0000EFF8 ; Segment permissions: Read
.rdata:0000EFF8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000EFF8 _rdata          segment para public 'DATA' use32
.rdata:0000EFF8                 assume cs:_rdata
.rdata:0000EFF8                 ;org 0EFF8h
.rdata:0000EFF8 ; COMDAT (pick any)
.rdata:0000EFF8                 public ??_C@_1KK@IAHNKIAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAU?$AAs?$AAe?$AAr?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?0?$AAc?$AAl@
.rdata:0000EFF8 ; `string'
.rdata:0000EFF8 ??_C@_1KK@IAHNKIAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAU?$AAs?$AAe?$AAr?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?0?$AAc?$AAl@:
.rdata:0000EFF8                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::operator[](uint)+6Ao
.rdata:0000EFF8                 unicode 0, <std::vector>
.rdata:0000EFF8                 dw 3Ch
.rdata:0000EFF8                 unicode 0, <class UserCommand,class std::allocator>
.rdata:0000EFF8                 dw 3Ch
.rdata:0000EFF8                 unicode 0, <class UserCommand>
.rdata:0000EFF8                 dw 3Eh
.rdata:0000EFF8                 unicode 0, < >
.rdata:0000EFF8                 dw 3Eh
.rdata:0000EFF8                 unicode 0, <::operator []>,0
.rdata:0000F0A2                 align 4
.rdata:0000F0A2 _rdata          ends
.rdata:0000F0A2
.rdata:0000F0A4 ; ===========================================================================
.rdata:0000F0A4
.rdata:0000F0A4 ; Segment type: Pure data
.rdata:0000F0A4 ; Segment permissions: Read
.rdata:0000F0A4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F0A4 _rdata          segment para public 'DATA' use32
.rdata:0000F0A4                 assume cs:_rdata
.rdata:0000F0A4                 ;org 0F0A4h
.rdata:0000F0A4 ; COMDAT (pick any)
.rdata:0000F0A4                 public ??_C@_1MC@MGKONNEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAm?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt@
.rdata:0000F0A4 ; `string'
.rdata:0000F0A4 ??_C@_1MC@MGKONNEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAm?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt@:
.rdata:0000F0A4                                         ; DATA XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+6Ao
.rdata:0000F0A4                 unicode 0, <std::vector>
.rdata:0000F0A4                 dw 3Ch
.rdata:0000F0A4                 unicode 0, <class PluginCmdShortcut,class std::allocator>
.rdata:0000F0A4                 dw 3Ch
.rdata:0000F0A4                 unicode 0, <class PluginCmdShortcut>
.rdata:0000F0A4                 dw 3Eh
.rdata:0000F0A4                 unicode 0, < >
.rdata:0000F0A4                 dw 3Eh
.rdata:0000F0A4                 unicode 0, <::operator []>,0
.rdata:0000F166                 align 4
.rdata:0000F166 _rdata          ends
.rdata:0000F166
.rdata:0000F168 ; ===========================================================================
.rdata:0000F168
.rdata:0000F168 ; Segment type: Pure data
.rdata:0000F168 ; Segment permissions: Read
.rdata:0000F168 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F168 _rdata          segment para public 'DATA' use32
.rdata:0000F168                 assume cs:_rdata
.rdata:0000F168                 ;org 0F168h
.rdata:0000F168 ; COMDAT (pick any)
.rdata:0000F168                 public ??_C@_1LK@EFECNNFA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAS?$AAc?$AAi?$AAn?$AAt?$AAi?$AAl?$AAl?$AAa?$AAK?$AAe?$AAy?$AAM?$AAa@
.rdata:0000F168 ; `string'
.rdata:0000F168 ??_C@_1LK@EFECNNFA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAS?$AAc?$AAi?$AAn?$AAt?$AAi?$AAl?$AAl?$AAa?$AAK?$AAe?$AAy?$AAM?$AAa@:
.rdata:0000F168                                         ; DATA XREF: std::vector<ScintillaKeyMap,std::allocator<ScintillaKeyMap>>::operator[](uint)+6Ao
.rdata:0000F168                 unicode 0, <std::vector>
.rdata:0000F168                 dw 3Ch
.rdata:0000F168                 unicode 0, <class ScintillaKeyMap,class std::allocator>
.rdata:0000F168                 dw 3Ch
.rdata:0000F168                 unicode 0, <class ScintillaKeyMap>
.rdata:0000F168                 dw 3Eh
.rdata:0000F168                 unicode 0, < >
.rdata:0000F168                 dw 3Eh
.rdata:0000F168                 unicode 0, <::operator []>,0
.rdata:0000F222                 align 4
.rdata:0000F222 _rdata          ends
.rdata:0000F222
.rdata:0000F224 ; ===========================================================================
.rdata:0000F224
.rdata:0000F224 ; Segment type: Pure data
.rdata:0000F224 ; Segment permissions: Read
.rdata:0000F224 _rdata          segment dword public 'DATA' use32
.rdata:0000F224                 assume cs:_rdata
.rdata:0000F224                 ;org 0F224h
.rdata:0000F224 ; COMDAT (pick any)
.rdata:0000F224                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000F224 ; char `string'[]
.rdata:0000F224 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000F224                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000F224                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000F224 _rdata          ends
.rdata:0000F224
.rdata:0000F234 ; ===========================================================================
.rdata:0000F234
.rdata:0000F234 ; Segment type: Pure data
.rdata:0000F234 ; Segment permissions: Read
.rdata:0000F234 _rdata          segment dword public 'DATA' use32
.rdata:0000F234                 assume cs:_rdata
.rdata:0000F234                 ;org 0F234h
.rdata:0000F234 ; COMDAT (pick any)
.rdata:0000F234                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000F234 ; char `string'[]
.rdata:0000F234 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000F234                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000F234                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:0000F234 _rdata          ends
.rdata:0000F234
.rdata:0000F24C ; ===========================================================================
.rdata:0000F24C
.rdata:0000F24C ; Segment type: Pure data
.rdata:0000F24C ; Segment permissions: Read
.rdata:0000F24C _rdata          segment dword public 'DATA' use32
.rdata:0000F24C                 assume cs:_rdata
.rdata:0000F24C                 ;org 0F24Ch
.rdata:0000F24C ; COMDAT (pick any)
.rdata:0000F24C                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000F24C ; char `string'[]
.rdata:0000F24C ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000F24C                                         ; DATA XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::_Xlen(void)+7o
.rdata:0000F24C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Xlen(void)+7o ...
.rdata:0000F25F                 align 10h
.rdata:0000F25F _rdata          ends
.rdata:0000F25F
.rdata:0000F260 ; ===========================================================================
.rdata:0000F260
.rdata:0000F260 ; Segment type: Pure data
.rdata:0000F260 ; Segment permissions: Read
.rdata:0000F260 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F260 _rdata          segment para public 'DATA' use32
.rdata:0000F260                 assume cs:_rdata
.rdata:0000F260                 ;org 0F260h
.rdata:0000F260 ; COMDAT (pick any)
.rdata:0000F260                 public ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:0000F260 ; wchar_t `string'
.rdata:0000F260 ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:0000F260                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+52o
.rdata:0000F260                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+52o
.rdata:0000F260                 unicode 0, <vector iterator + offset out of range>,0
.rdata:0000F260 _rdata          ends
.rdata:0000F260
.rdata:0000F2AC ; ===========================================================================
.rdata:0000F2AC
.rdata:0000F2AC ; Segment type: Pure data
.rdata:0000F2AC ; Segment permissions: Read
.rdata:0000F2AC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F2AC _rdata          segment para public 'DATA' use32
.rdata:0000F2AC                 assume cs:_rdata
.rdata:0000F2AC                 ;org 0F2ACh
.rdata:0000F2AC ; COMDAT (pick any)
.rdata:0000F2AC                 public ??_C@_1OG@IKOELCPO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000F2AC ; `string'
.rdata:0000F2AC ??_C@_1OG@IKOELCPO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000F2AC                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MacroShortcut>>>::operator+=(int)+9Eo
.rdata:0000F2AC                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000F2AC                 dw 3Ch
.rdata:0000F2AC                 unicode 0, <class std::_Vector_val>
.rdata:0000F2AC                 dw 3Ch
.rdata:0000F2AC                 unicode 0, <struct std::_Simple_types>
.rdata:0000F2AC                 dw 3Ch
.rdata:0000F2AC                 unicode 0, <class MacroShortcut>
.rdata:0000F2AC                 dw 3Eh
.rdata:0000F2AC                 unicode 0, < >
.rdata:0000F2AC                 dw 3Eh
.rdata:0000F2AC                 unicode 0, < >
.rdata:0000F2AC                 dw 3Eh
.rdata:0000F2AC                 unicode 0, <::operator +=>,0
.rdata:0000F392                 align 4
.rdata:0000F392 _rdata          ends
.rdata:0000F392
.rdata:0000F394 ; ===========================================================================
.rdata:0000F394
.rdata:0000F394 ; Segment type: Pure data
.rdata:0000F394 ; Segment permissions: Read
.rdata:0000F394 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F394 _rdata          segment para public 'DATA' use32
.rdata:0000F394                 assume cs:_rdata
.rdata:0000F394                 ;org 0F394h
.rdata:0000F394 ; COMDAT (pick any)
.rdata:0000F394                 public ??_C@_1OC@IGLELAPI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000F394 ; `string'
.rdata:0000F394 ??_C@_1OC@IGLELAPI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000F394                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<UserCommand>>>::operator+=(int)+9Eo
.rdata:0000F394                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000F394                 dw 3Ch
.rdata:0000F394                 unicode 0, <class std::_Vector_val>
.rdata:0000F394                 dw 3Ch
.rdata:0000F394                 unicode 0, <struct std::_Simple_types>
.rdata:0000F394                 dw 3Ch
.rdata:0000F394                 unicode 0, <class UserCommand>
.rdata:0000F394                 dw 3Eh
.rdata:0000F394                 unicode 0, < >
.rdata:0000F394                 dw 3Eh
.rdata:0000F394                 unicode 0, < >
.rdata:0000F394                 dw 3Eh
.rdata:0000F394                 unicode 0, <::operator +=>,0
.rdata:0000F476                 align 4
.rdata:0000F476 _rdata          ends
.rdata:0000F476
.rdata:0000F478 ; ===========================================================================
.rdata:0000F478
.rdata:0000F478 ; Segment type: Pure data
.rdata:0000F478 ; Segment permissions: Read
.rdata:0000F478 _rdata          segment dword public 'DATA' use32
.rdata:0000F478                 assume cs:_rdata
.rdata:0000F478                 ;org 0F478h
.rdata:0000F478 ; COMDAT (pick any)
.rdata:0000F478                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000F478 ; wchar_t `string'
.rdata:0000F478 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000F478                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000F478                                         ; std::_Debug_pointer<KeyCombo>(KeyCombo *,wchar_t const *,uint)+11o ...
.rdata:0000F478                 unicode 0, <invalid null pointer>,0
.rdata:0000F4A2                 align 4
.rdata:0000F4A2 _rdata          ends
.rdata:0000F4A2
.rdata:0000F4A4 ; ===========================================================================
.rdata:0000F4A4
.rdata:0000F4A4 ; Segment type: Pure data
.rdata:0000F4A4 ; Segment permissions: Read
.rdata:0000F4A4 _rdata          segment dword public 'DATA' use32
.rdata:0000F4A4                 assume cs:_rdata
.rdata:0000F4A4                 ;org 0F4A4h
.rdata:0000F4A4 ; COMDAT (pick any)
.rdata:0000F4A4                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000F4A4 ; wchar_t `string'
.rdata:0000F4A4 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000F4A4                                         ; DATA XREF: std::_Debug_range2<KeyCombo *>(KeyCombo *,KeyCombo *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000F4A4                                         ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000F4A4                 unicode 0, <invalid iterator range>,0
.rdata:0000F4D2                 align 4
.rdata:0000F4D2 _rdata          ends
.rdata:0000F4D2
.rdata:0000F4D4 ; ===========================================================================
.rdata:0000F4D4
.rdata:0000F4D4 ; Segment type: Pure data
.rdata:0000F4D4 ; Segment permissions: Read
.rdata:0000F4D4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000F4D4 _rdata          segment para public 'DATA' use32
.rdata:0000F4D4                 assume cs:_rdata
.rdata:0000F4D4                 ;org 0F4D4h
.rdata:0000F4D4 ; COMDAT (pick any)
.rdata:0000F4D4                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000F4D4 ; wchar_t `string'
.rdata:0000F4D4 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000F4D4                                         ; DATA XREF: std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+2Fo
.rdata:0000F4D4                                         ; std::_Uninit_copy<KeyCombo *,KeyCombo *,std::allocator<KeyCombo>>(KeyCombo *,KeyCombo *,KeyCombo *,std::_Wrap_alloc<std::allocator<KeyCombo>> &,std::_Nonscalar_ptr_iterator_tag)+49o ...
.rdata:0000F4D4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000F4D4                 unicode 0, <clude\xmemory>,0
.rdata:0000F562                 align 4
.rdata:0000F562 _rdata          ends
.rdata:0000F562
.rdata$r:0000F564 ; ===========================================================================
.rdata$r:0000F564
.rdata$r:0000F564 ; Segment type: Pure data
.rdata$r:0000F564 ; Segment permissions: Read
.rdata$r:0000F564 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F564                 assume cs:_rdata$r
.rdata$r:0000F564                 ;org 0F564h
.rdata$r:0000F564 ; COMDAT (pick any)
.rdata$r:0000F564                 public ??_R4Window@@6B@
.rdata$r:0000F564 ; const Window::`RTTI Complete Object Locator'
.rdata$r:0000F564 ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:0000E774o
.rdata$r:0000F565                 db    0
.rdata$r:0000F566                 db    0
.rdata$r:0000F567                 db    0
.rdata$r:0000F568                 db    0
.rdata$r:0000F569                 db    0
.rdata$r:0000F56A                 db    0
.rdata$r:0000F56B                 db    0
.rdata$r:0000F56C                 db    0
.rdata$r:0000F56D                 db    0
.rdata$r:0000F56E                 db    0
.rdata$r:0000F56F                 db    0
.rdata$r:0000F570                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:0000F574                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F574 _rdata$r        ends
.rdata$r:0000F574
.data$r:0000F578 ; ===========================================================================
.data$r:0000F578
.data$r:0000F578 ; Segment type: Pure data
.data$r:0000F578 ; Segment permissions: Read/Write
.data$r:0000F578 _data$r         segment dword public 'DATA' use32
.data$r:0000F578                 assume cs:_data$r
.data$r:0000F578                 ;org 0F578h
.data$r:0000F578 ; COMDAT (pick any)
.data$r:0000F578                 public ??_R0?AVWindow@@@8
.data$r:0000F578 ; class Window `RTTI Type Descriptor'
.data$r:0000F578 ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F578                                         ; DATA XREF: .rdata$r:0000F570o
.data$r:0000F578                                         ; .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F578                                         ; const type_info::`vftable'
.data$r:0000F57C                 align 10h
.data$r:0000F580 a_?avwindow@@   db '.?AVWindow@@',0
.data$r:0000F58D                 align 10h
.data$r:0000F58D _data$r         ends
.data$r:0000F58D
.rdata$r:0000F590 ; ===========================================================================
.rdata$r:0000F590
.rdata$r:0000F590 ; Segment type: Pure data
.rdata$r:0000F590 ; Segment permissions: Read
.rdata$r:0000F590 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F590                 assume cs:_rdata$r
.rdata$r:0000F590                 ;org 0F590h
.rdata$r:0000F590 ; COMDAT (pick any)
.rdata$r:0000F590                 public ??_R3Window@@8
.rdata$r:0000F590 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F590 ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:0000F574o
.rdata$r:0000F590                                         ; .rdata$r:0000F5C0o
.rdata$r:0000F591                 db    0
.rdata$r:0000F592                 db    0
.rdata$r:0000F593                 db    0
.rdata$r:0000F594                 db    0
.rdata$r:0000F595                 db    0
.rdata$r:0000F596                 db    0
.rdata$r:0000F597                 db    0
.rdata$r:0000F598                 db    1
.rdata$r:0000F599                 db    0
.rdata$r:0000F59A                 db    0
.rdata$r:0000F59B                 db    0
.rdata$r:0000F59C                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:0000F59C _rdata$r        ends
.rdata$r:0000F59C
.rdata$r:0000F5A0 ; ===========================================================================
.rdata$r:0000F5A0
.rdata$r:0000F5A0 ; Segment type: Pure data
.rdata$r:0000F5A0 ; Segment permissions: Read
.rdata$r:0000F5A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F5A0                 assume cs:_rdata$r
.rdata$r:0000F5A0                 ;org 0F5A0h
.rdata$r:0000F5A0 ; COMDAT (pick any)
.rdata$r:0000F5A0                 public ??_R2Window@@8
.rdata$r:0000F5A0 ; Window::`RTTI Base Class Array'
.rdata$r:0000F5A0 ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:0000F5A0                                         ; DATA XREF: .rdata$r:0000F59Co
.rdata$r:0000F5A0                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F5A4                 db    0
.rdata$r:0000F5A5                 align 4
.rdata$r:0000F5A5 _rdata$r        ends
.rdata$r:0000F5A5
.rdata$r:0000F5A8 ; ===========================================================================
.rdata$r:0000F5A8
.rdata$r:0000F5A8 ; Segment type: Pure data
.rdata$r:0000F5A8 ; Segment permissions: Read
.rdata$r:0000F5A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F5A8                 assume cs:_rdata$r
.rdata$r:0000F5A8                 ;org 0F5A8h
.rdata$r:0000F5A8 ; COMDAT (pick any)
.rdata$r:0000F5A8                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:0000F5A8 ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F5A8 ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:0000F5A8                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:0000F5A8                                         ; .rdata$r:0000F608o ...
.rdata$r:0000F5A8                                         ; Window `RTTI Type Descriptor'
.rdata$r:0000F5AC                 db    0
.rdata$r:0000F5AD                 db    0
.rdata$r:0000F5AE                 db    0
.rdata$r:0000F5AF                 db    0
.rdata$r:0000F5B0                 db    0
.rdata$r:0000F5B1                 db    0
.rdata$r:0000F5B2                 db    0
.rdata$r:0000F5B3                 db    0
.rdata$r:0000F5B4                 db 0FFh
.rdata$r:0000F5B5                 db 0FFh
.rdata$r:0000F5B6                 db 0FFh
.rdata$r:0000F5B7                 db 0FFh
.rdata$r:0000F5B8                 db    0
.rdata$r:0000F5B9                 db    0
.rdata$r:0000F5BA                 db    0
.rdata$r:0000F5BB                 db    0
.rdata$r:0000F5BC                 db  40h ; @
.rdata$r:0000F5BD                 db    0
.rdata$r:0000F5BE                 db    0
.rdata$r:0000F5BF                 db    0
.rdata$r:0000F5C0                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F5C0 _rdata$r        ends
.rdata$r:0000F5C0
.rdata$r:0000F5C4 ; ===========================================================================
.rdata$r:0000F5C4
.rdata$r:0000F5C4 ; Segment type: Pure data
.rdata$r:0000F5C4 ; Segment permissions: Read
.rdata$r:0000F5C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F5C4                 assume cs:_rdata$r
.rdata$r:0000F5C4                 ;org 0F5C4h
.rdata$r:0000F5C4 ; COMDAT (pick any)
.rdata$r:0000F5C4                 public ??_R4StaticDialog@@6B@
.rdata$r:0000F5C4 ; const StaticDialog::`RTTI Complete Object Locator'
.rdata$r:0000F5C4 ??_R4StaticDialog@@6B@ db    0          ; DATA XREF: .rdata:0000E7A8o
.rdata$r:0000F5C5                 db    0
.rdata$r:0000F5C6                 db    0
.rdata$r:0000F5C7                 db    0
.rdata$r:0000F5C8                 db    0
.rdata$r:0000F5C9                 db    0
.rdata$r:0000F5CA                 db    0
.rdata$r:0000F5CB                 db    0
.rdata$r:0000F5CC                 db    0
.rdata$r:0000F5CD                 db    0
.rdata$r:0000F5CE                 db    0
.rdata$r:0000F5CF                 db    0
.rdata$r:0000F5D0                 dd offset ??_R0?AVStaticDialog@@@8 ; StaticDialog `RTTI Type Descriptor'
.rdata$r:0000F5D4                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F5D4 _rdata$r        ends
.rdata$r:0000F5D4
.data$r:0000F5D8 ; ===========================================================================
.data$r:0000F5D8
.data$r:0000F5D8 ; Segment type: Pure data
.data$r:0000F5D8 ; Segment permissions: Read/Write
.data$r:0000F5D8 _data$r         segment dword public 'DATA' use32
.data$r:0000F5D8                 assume cs:_data$r
.data$r:0000F5D8                 ;org 0F5D8h
.data$r:0000F5D8 ; COMDAT (pick any)
.data$r:0000F5D8                 public ??_R0?AVStaticDialog@@@8
.data$r:0000F5D8 ; class StaticDialog `RTTI Type Descriptor'
.data$r:0000F5D8 ??_R0?AVStaticDialog@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F5D8                                         ; DATA XREF: .rdata$r:0000F5D0o
.data$r:0000F5D8                                         ; .rdata$r:StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F5D8                                         ; const type_info::`vftable'
.data$r:0000F5DC                 align 10h
.data$r:0000F5E0 a_?avstaticdial db '.?AVStaticDialog@@',0
.data$r:0000F5F3                 align 4
.data$r:0000F5F3 _data$r         ends
.data$r:0000F5F3
.rdata$r:0000F5F4 ; ===========================================================================
.rdata$r:0000F5F4
.rdata$r:0000F5F4 ; Segment type: Pure data
.rdata$r:0000F5F4 ; Segment permissions: Read
.rdata$r:0000F5F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F5F4                 assume cs:_rdata$r
.rdata$r:0000F5F4                 ;org 0F5F4h
.rdata$r:0000F5F4 ; COMDAT (pick any)
.rdata$r:0000F5F4                 public ??_R3StaticDialog@@8
.rdata$r:0000F5F4 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F5F4 ??_R3StaticDialog@@8 db    0            ; DATA XREF: .rdata$r:0000F5D4o
.rdata$r:0000F5F4                                         ; .rdata$r:0000F628o
.rdata$r:0000F5F5                 db    0
.rdata$r:0000F5F6                 db    0
.rdata$r:0000F5F7                 db    0
.rdata$r:0000F5F8                 db    0
.rdata$r:0000F5F9                 db    0
.rdata$r:0000F5FA                 db    0
.rdata$r:0000F5FB                 db    0
.rdata$r:0000F5FC                 db    2
.rdata$r:0000F5FD                 db    0
.rdata$r:0000F5FE                 db    0
.rdata$r:0000F5FF                 db    0
.rdata$r:0000F600                 dd offset ??_R2StaticDialog@@8 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:0000F600 _rdata$r        ends
.rdata$r:0000F600
.rdata$r:0000F604 ; ===========================================================================
.rdata$r:0000F604
.rdata$r:0000F604 ; Segment type: Pure data
.rdata$r:0000F604 ; Segment permissions: Read
.rdata$r:0000F604 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F604                 assume cs:_rdata$r
.rdata$r:0000F604                 ;org 0F604h
.rdata$r:0000F604 ; COMDAT (pick any)
.rdata$r:0000F604                 public ??_R2StaticDialog@@8
.rdata$r:0000F604 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:0000F604 ??_R2StaticDialog@@8 dd offset ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:0000F604                                         ; DATA XREF: .rdata$r:0000F600o
.rdata$r:0000F604                                         ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F608                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F60C                 db    0
.rdata$r:0000F60D                 align 10h
.rdata$r:0000F60D _rdata$r        ends
.rdata$r:0000F60D
.rdata$r:0000F610 ; ===========================================================================
.rdata$r:0000F610
.rdata$r:0000F610 ; Segment type: Pure data
.rdata$r:0000F610 ; Segment permissions: Read
.rdata$r:0000F610 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F610                 assume cs:_rdata$r
.rdata$r:0000F610                 ;org 0F610h
.rdata$r:0000F610 ; COMDAT (pick any)
.rdata$r:0000F610                 public ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:0000F610 ; StaticDialog::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F610 ??_R1A@?0A@EA@StaticDialog@@8 dd offset ??_R0?AVStaticDialog@@@8
.rdata$r:0000F610                                         ; DATA XREF: .rdata$r:StaticDialog::`RTTI Base Class Array'o
.rdata$r:0000F610                                         ; .rdata$r:0000F848o ...
.rdata$r:0000F610                                         ; StaticDialog `RTTI Type Descriptor'
.rdata$r:0000F614                 db    1
.rdata$r:0000F615                 db    0
.rdata$r:0000F616                 db    0
.rdata$r:0000F617                 db    0
.rdata$r:0000F618                 db    0
.rdata$r:0000F619                 db    0
.rdata$r:0000F61A                 db    0
.rdata$r:0000F61B                 db    0
.rdata$r:0000F61C                 db 0FFh
.rdata$r:0000F61D                 db 0FFh
.rdata$r:0000F61E                 db 0FFh
.rdata$r:0000F61F                 db 0FFh
.rdata$r:0000F620                 db    0
.rdata$r:0000F621                 db    0
.rdata$r:0000F622                 db    0
.rdata$r:0000F623                 db    0
.rdata$r:0000F624                 db  40h ; @
.rdata$r:0000F625                 db    0
.rdata$r:0000F626                 db    0
.rdata$r:0000F627                 db    0
.rdata$r:0000F628                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F628 _rdata$r        ends
.rdata$r:0000F628
.rdata$r:0000F62C ; ===========================================================================
.rdata$r:0000F62C
.rdata$r:0000F62C ; Segment type: Pure data
.rdata$r:0000F62C ; Segment permissions: Read
.rdata$r:0000F62C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F62C                 assume cs:_rdata$r
.rdata$r:0000F62C                 ;org 0F62Ch
.rdata$r:0000F62C ; COMDAT (pick any)
.rdata$r:0000F62C                 public ??_R4error_category@std@@6B@
.rdata$r:0000F62C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000F62C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000E8B0o
.rdata$r:0000F62D                 db    0
.rdata$r:0000F62E                 db    0
.rdata$r:0000F62F                 db    0
.rdata$r:0000F630                 db    0
.rdata$r:0000F631                 db    0
.rdata$r:0000F632                 db    0
.rdata$r:0000F633                 db    0
.rdata$r:0000F634                 db    0
.rdata$r:0000F635                 db    0
.rdata$r:0000F636                 db    0
.rdata$r:0000F637                 db    0
.rdata$r:0000F638                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000F63C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F63C _rdata$r        ends
.rdata$r:0000F63C
.data$r:0000F640 ; ===========================================================================
.data$r:0000F640
.data$r:0000F640 ; Segment type: Pure data
.data$r:0000F640 ; Segment permissions: Read/Write
.data$r:0000F640 _data$r         segment dword public 'DATA' use32
.data$r:0000F640                 assume cs:_data$r
.data$r:0000F640                 ;org 0F640h
.data$r:0000F640 ; COMDAT (pick any)
.data$r:0000F640                 public ??_R0?AVerror_category@std@@@8
.data$r:0000F640 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000F640 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F640                                         ; DATA XREF: .rdata$r:0000F638o
.data$r:0000F640                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F640                                         ; const type_info::`vftable'
.data$r:0000F644                 align 8
.data$r:0000F648 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:0000F661                 align 4
.data$r:0000F661 _data$r         ends
.data$r:0000F661
.rdata$r:0000F664 ; ===========================================================================
.rdata$r:0000F664
.rdata$r:0000F664 ; Segment type: Pure data
.rdata$r:0000F664 ; Segment permissions: Read
.rdata$r:0000F664 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F664                 assume cs:_rdata$r
.rdata$r:0000F664                 ;org 0F664h
.rdata$r:0000F664 ; COMDAT (pick any)
.rdata$r:0000F664                 public ??_R3error_category@std@@8
.rdata$r:0000F664 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F664 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000F63Co
.rdata$r:0000F664                                         ; .rdata$r:0000F694o
.rdata$r:0000F665                 db    0
.rdata$r:0000F666                 db    0
.rdata$r:0000F667                 db    0
.rdata$r:0000F668                 db    0
.rdata$r:0000F669                 db    0
.rdata$r:0000F66A                 db    0
.rdata$r:0000F66B                 db    0
.rdata$r:0000F66C                 db    1
.rdata$r:0000F66D                 db    0
.rdata$r:0000F66E                 db    0
.rdata$r:0000F66F                 db    0
.rdata$r:0000F670                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000F670 _rdata$r        ends
.rdata$r:0000F670
.rdata$r:0000F674 ; ===========================================================================
.rdata$r:0000F674
.rdata$r:0000F674 ; Segment type: Pure data
.rdata$r:0000F674 ; Segment permissions: Read
.rdata$r:0000F674 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F674                 assume cs:_rdata$r
.rdata$r:0000F674                 ;org 0F674h
.rdata$r:0000F674 ; COMDAT (pick any)
.rdata$r:0000F674                 public ??_R2error_category@std@@8
.rdata$r:0000F674 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000F674 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000F674                                         ; DATA XREF: .rdata$r:0000F670o
.rdata$r:0000F674                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F678                 db    0
.rdata$r:0000F679                 align 4
.rdata$r:0000F679 _rdata$r        ends
.rdata$r:0000F679
.rdata$r:0000F67C ; ===========================================================================
.rdata$r:0000F67C
.rdata$r:0000F67C ; Segment type: Pure data
.rdata$r:0000F67C ; Segment permissions: Read
.rdata$r:0000F67C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F67C                 assume cs:_rdata$r
.rdata$r:0000F67C                 ;org 0F67Ch
.rdata$r:0000F67C ; COMDAT (pick any)
.rdata$r:0000F67C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000F67C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F67C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000F67C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000F67C                                         ; .rdata$r:0000F6ECo ...
.rdata$r:0000F67C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000F680                 db    0
.rdata$r:0000F681                 db    0
.rdata$r:0000F682                 db    0
.rdata$r:0000F683                 db    0
.rdata$r:0000F684                 db    0
.rdata$r:0000F685                 db    0
.rdata$r:0000F686                 db    0
.rdata$r:0000F687                 db    0
.rdata$r:0000F688                 db 0FFh
.rdata$r:0000F689                 db 0FFh
.rdata$r:0000F68A                 db 0FFh
.rdata$r:0000F68B                 db 0FFh
.rdata$r:0000F68C                 db    0
.rdata$r:0000F68D                 db    0
.rdata$r:0000F68E                 db    0
.rdata$r:0000F68F                 db    0
.rdata$r:0000F690                 db  40h ; @
.rdata$r:0000F691                 db    0
.rdata$r:0000F692                 db    0
.rdata$r:0000F693                 db    0
.rdata$r:0000F694                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F694 _rdata$r        ends
.rdata$r:0000F694
.rdata$r:0000F698 ; ===========================================================================
.rdata$r:0000F698
.rdata$r:0000F698 ; Segment type: Pure data
.rdata$r:0000F698 ; Segment permissions: Read
.rdata$r:0000F698 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F698                 assume cs:_rdata$r
.rdata$r:0000F698                 ;org 0F698h
.rdata$r:0000F698 ; COMDAT (pick any)
.rdata$r:0000F698                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000F698 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000F698 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000F698                                         ; DATA XREF: .rdata:0000E8CCo
.rdata$r:0000F699                 db    0
.rdata$r:0000F69A                 db    0
.rdata$r:0000F69B                 db    0
.rdata$r:0000F69C                 db    0
.rdata$r:0000F69D                 db    0
.rdata$r:0000F69E                 db    0
.rdata$r:0000F69F                 db    0
.rdata$r:0000F6A0                 db    0
.rdata$r:0000F6A1                 db    0
.rdata$r:0000F6A2                 db    0
.rdata$r:0000F6A3                 db    0
.rdata$r:0000F6A4                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000F6A8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F6A8 _rdata$r        ends
.rdata$r:0000F6A8
.data$r:0000F6AC ; ===========================================================================
.data$r:0000F6AC
.data$r:0000F6AC ; Segment type: Pure data
.data$r:0000F6AC ; Segment permissions: Read/Write
.data$r:0000F6AC _data$r         segment dword public 'DATA' use32
.data$r:0000F6AC                 assume cs:_data$r
.data$r:0000F6AC                 ;org 0F6ACh
.data$r:0000F6AC ; COMDAT (pick any)
.data$r:0000F6AC                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000F6AC ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000F6AC ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F6AC                                         ; DATA XREF: .rdata$r:0000F6A4o
.data$r:0000F6AC                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F6AC                                         ; const type_info::`vftable'
.data$r:0000F6B0                 db    0
.data$r:0000F6B1                 db    0
.data$r:0000F6B2                 db    0
.data$r:0000F6B3                 db    0
.data$r:0000F6B4                 db  2Eh ; .
.data$r:0000F6B5                 db  3Fh ; ?
.data$r:0000F6B6                 db  41h ; A
.data$r:0000F6B7                 db  56h ; V
.data$r:0000F6B8                 db  5Fh ; _
.data$r:0000F6B9                 db  47h ; G
.data$r:0000F6BA                 db  65h ; e
.data$r:0000F6BB                 db  6Eh ; n
.data$r:0000F6BC                 db  65h ; e
.data$r:0000F6BD                 db  72h ; r
.data$r:0000F6BE                 db  69h ; i
.data$r:0000F6BF                 db  63h ; c
.data$r:0000F6C0                 db  5Fh ; _
.data$r:0000F6C1                 db  65h ; e
.data$r:0000F6C2                 db  72h ; r
.data$r:0000F6C3                 db  72h ; r
.data$r:0000F6C4                 db  6Fh ; o
.data$r:0000F6C5                 db  72h ; r
.data$r:0000F6C6                 db  5Fh ; _
.data$r:0000F6C7                 db  63h ; c
.data$r:0000F6C8                 db  61h ; a
.data$r:0000F6C9                 db  74h ; t
.data$r:0000F6CA                 db  65h ; e
.data$r:0000F6CB                 db  67h ; g
.data$r:0000F6CC                 db  6Fh ; o
.data$r:0000F6CD                 db  72h ; r
.data$r:0000F6CE                 db  79h ; y
.data$r:0000F6CF                 db  40h ; @
.data$r:0000F6D0                 db  73h ; s
.data$r:0000F6D1                 db  74h ; t
.data$r:0000F6D2                 db  64h ; d
.data$r:0000F6D3                 db  40h ; @
.data$r:0000F6D4                 db  40h ; @
.data$r:0000F6D5                 db    0
.data$r:0000F6D6                 align 4
.data$r:0000F6D6 _data$r         ends
.data$r:0000F6D6
.rdata$r:0000F6D8 ; ===========================================================================
.rdata$r:0000F6D8
.rdata$r:0000F6D8 ; Segment type: Pure data
.rdata$r:0000F6D8 ; Segment permissions: Read
.rdata$r:0000F6D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F6D8                 assume cs:_rdata$r
.rdata$r:0000F6D8                 ;org 0F6D8h
.rdata$r:0000F6D8 ; COMDAT (pick any)
.rdata$r:0000F6D8                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000F6D8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F6D8 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000F6D8                                         ; DATA XREF: .rdata$r:0000F6A8o
.rdata$r:0000F6D8                                         ; .rdata$r:0000F70Co
.rdata$r:0000F6D9                 db    0
.rdata$r:0000F6DA                 db    0
.rdata$r:0000F6DB                 db    0
.rdata$r:0000F6DC                 db    0
.rdata$r:0000F6DD                 db    0
.rdata$r:0000F6DE                 db    0
.rdata$r:0000F6DF                 db    0
.rdata$r:0000F6E0                 db    2
.rdata$r:0000F6E1                 db    0
.rdata$r:0000F6E2                 db    0
.rdata$r:0000F6E3                 db    0
.rdata$r:0000F6E4                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000F6E4 _rdata$r        ends
.rdata$r:0000F6E4
.rdata$r:0000F6E8 ; ===========================================================================
.rdata$r:0000F6E8
.rdata$r:0000F6E8 ; Segment type: Pure data
.rdata$r:0000F6E8 ; Segment permissions: Read
.rdata$r:0000F6E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F6E8                 assume cs:_rdata$r
.rdata$r:0000F6E8                 ;org 0F6E8h
.rdata$r:0000F6E8 ; COMDAT (pick any)
.rdata$r:0000F6E8                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000F6E8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000F6E8 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000F6E8                                         ; DATA XREF: .rdata$r:0000F6E4o
.rdata$r:0000F6E8                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F6EC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F6F0                 db    0
.rdata$r:0000F6F1                 align 4
.rdata$r:0000F6F1 _rdata$r        ends
.rdata$r:0000F6F1
.rdata$r:0000F6F4 ; ===========================================================================
.rdata$r:0000F6F4
.rdata$r:0000F6F4 ; Segment type: Pure data
.rdata$r:0000F6F4 ; Segment permissions: Read
.rdata$r:0000F6F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F6F4                 assume cs:_rdata$r
.rdata$r:0000F6F4                 ;org 0F6F4h
.rdata$r:0000F6F4 ; COMDAT (pick any)
.rdata$r:0000F6F4                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000F6F4 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F6F4 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000F6F4                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000F6F4                                         ; .rdata$r:0000F764o ...
.rdata$r:0000F6F4                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000F6F8                 db    1
.rdata$r:0000F6F9                 db    0
.rdata$r:0000F6FA                 db    0
.rdata$r:0000F6FB                 db    0
.rdata$r:0000F6FC                 db    0
.rdata$r:0000F6FD                 db    0
.rdata$r:0000F6FE                 db    0
.rdata$r:0000F6FF                 db    0
.rdata$r:0000F700                 db 0FFh
.rdata$r:0000F701                 db 0FFh
.rdata$r:0000F702                 db 0FFh
.rdata$r:0000F703                 db 0FFh
.rdata$r:0000F704                 db    0
.rdata$r:0000F705                 db    0
.rdata$r:0000F706                 db    0
.rdata$r:0000F707                 db    0
.rdata$r:0000F708                 db  40h ; @
.rdata$r:0000F709                 db    0
.rdata$r:0000F70A                 db    0
.rdata$r:0000F70B                 db    0
.rdata$r:0000F70C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F70C _rdata$r        ends
.rdata$r:0000F70C
.rdata$r:0000F710 ; ===========================================================================
.rdata$r:0000F710
.rdata$r:0000F710 ; Segment type: Pure data
.rdata$r:0000F710 ; Segment permissions: Read
.rdata$r:0000F710 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F710                 assume cs:_rdata$r
.rdata$r:0000F710                 ;org 0F710h
.rdata$r:0000F710 ; COMDAT (pick any)
.rdata$r:0000F710                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000F710 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000F710 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000F710                                         ; DATA XREF: .rdata:0000E900o
.rdata$r:0000F711                 db    0
.rdata$r:0000F712                 db    0
.rdata$r:0000F713                 db    0
.rdata$r:0000F714                 db    0
.rdata$r:0000F715                 db    0
.rdata$r:0000F716                 db    0
.rdata$r:0000F717                 db    0
.rdata$r:0000F718                 db    0
.rdata$r:0000F719                 db    0
.rdata$r:0000F71A                 db    0
.rdata$r:0000F71B                 db    0
.rdata$r:0000F71C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000F720                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F720 _rdata$r        ends
.rdata$r:0000F720
.data$r:0000F724 ; ===========================================================================
.data$r:0000F724
.data$r:0000F724 ; Segment type: Pure data
.data$r:0000F724 ; Segment permissions: Read/Write
.data$r:0000F724 _data$r         segment dword public 'DATA' use32
.data$r:0000F724                 assume cs:_data$r
.data$r:0000F724                 ;org 0F724h
.data$r:0000F724 ; COMDAT (pick any)
.data$r:0000F724                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000F724 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000F724 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F724                                         ; DATA XREF: .rdata$r:0000F71Co
.data$r:0000F724                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F724                                         ; const type_info::`vftable'
.data$r:0000F728                 db    0
.data$r:0000F729                 db    0
.data$r:0000F72A                 db    0
.data$r:0000F72B                 db    0
.data$r:0000F72C                 db  2Eh ; .
.data$r:0000F72D                 db  3Fh ; ?
.data$r:0000F72E                 db  41h ; A
.data$r:0000F72F                 db  56h ; V
.data$r:0000F730                 db  5Fh ; _
.data$r:0000F731                 db  49h ; I
.data$r:0000F732                 db  6Fh ; o
.data$r:0000F733                 db  73h ; s
.data$r:0000F734                 db  74h ; t
.data$r:0000F735                 db  72h ; r
.data$r:0000F736                 db  65h ; e
.data$r:0000F737                 db  61h ; a
.data$r:0000F738                 db  6Dh ; m
.data$r:0000F739                 db  5Fh ; _
.data$r:0000F73A                 db  65h ; e
.data$r:0000F73B                 db  72h ; r
.data$r:0000F73C                 db  72h ; r
.data$r:0000F73D                 db  6Fh ; o
.data$r:0000F73E                 db  72h ; r
.data$r:0000F73F                 db  5Fh ; _
.data$r:0000F740                 db  63h ; c
.data$r:0000F741                 db  61h ; a
.data$r:0000F742                 db  74h ; t
.data$r:0000F743                 db  65h ; e
.data$r:0000F744                 db  67h ; g
.data$r:0000F745                 db  6Fh ; o
.data$r:0000F746                 db  72h ; r
.data$r:0000F747                 db  79h ; y
.data$r:0000F748                 db  40h ; @
.data$r:0000F749                 db  73h ; s
.data$r:0000F74A                 db  74h ; t
.data$r:0000F74B                 db  64h ; d
.data$r:0000F74C                 db  40h ; @
.data$r:0000F74D                 db  40h ; @
.data$r:0000F74E                 db    0
.data$r:0000F74F                 align 10h
.data$r:0000F74F _data$r         ends
.data$r:0000F74F
.rdata$r:0000F750 ; ===========================================================================
.rdata$r:0000F750
.rdata$r:0000F750 ; Segment type: Pure data
.rdata$r:0000F750 ; Segment permissions: Read
.rdata$r:0000F750 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F750                 assume cs:_rdata$r
.rdata$r:0000F750                 ;org 0F750h
.rdata$r:0000F750 ; COMDAT (pick any)
.rdata$r:0000F750                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000F750 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F750 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000F750                                         ; DATA XREF: .rdata$r:0000F720o
.rdata$r:0000F750                                         ; .rdata$r:0000F788o
.rdata$r:0000F751                 db    0
.rdata$r:0000F752                 db    0
.rdata$r:0000F753                 db    0
.rdata$r:0000F754                 db    0
.rdata$r:0000F755                 db    0
.rdata$r:0000F756                 db    0
.rdata$r:0000F757                 db    0
.rdata$r:0000F758                 db    3
.rdata$r:0000F759                 db    0
.rdata$r:0000F75A                 db    0
.rdata$r:0000F75B                 db    0
.rdata$r:0000F75C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000F75C _rdata$r        ends
.rdata$r:0000F75C
.rdata$r:0000F760 ; ===========================================================================
.rdata$r:0000F760
.rdata$r:0000F760 ; Segment type: Pure data
.rdata$r:0000F760 ; Segment permissions: Read
.rdata$r:0000F760 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F760                 assume cs:_rdata$r
.rdata$r:0000F760                 ;org 0F760h
.rdata$r:0000F760 ; COMDAT (pick any)
.rdata$r:0000F760                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000F760 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000F760 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000F760                                         ; DATA XREF: .rdata$r:0000F75Co
.rdata$r:0000F760                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F764                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F768                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F76C                 db    0
.rdata$r:0000F76D                 align 10h
.rdata$r:0000F76D _rdata$r        ends
.rdata$r:0000F76D
.rdata$r:0000F770 ; ===========================================================================
.rdata$r:0000F770
.rdata$r:0000F770 ; Segment type: Pure data
.rdata$r:0000F770 ; Segment permissions: Read
.rdata$r:0000F770 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F770                 assume cs:_rdata$r
.rdata$r:0000F770                 ;org 0F770h
.rdata$r:0000F770 ; COMDAT (pick any)
.rdata$r:0000F770                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000F770 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F770 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000F770                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000F770                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000F774                 db    2
.rdata$r:0000F775                 db    0
.rdata$r:0000F776                 db    0
.rdata$r:0000F777                 db    0
.rdata$r:0000F778                 db    0
.rdata$r:0000F779                 db    0
.rdata$r:0000F77A                 db    0
.rdata$r:0000F77B                 db    0
.rdata$r:0000F77C                 db 0FFh
.rdata$r:0000F77D                 db 0FFh
.rdata$r:0000F77E                 db 0FFh
.rdata$r:0000F77F                 db 0FFh
.rdata$r:0000F780                 db    0
.rdata$r:0000F781                 db    0
.rdata$r:0000F782                 db    0
.rdata$r:0000F783                 db    0
.rdata$r:0000F784                 db  40h ; @
.rdata$r:0000F785                 db    0
.rdata$r:0000F786                 db    0
.rdata$r:0000F787                 db    0
.rdata$r:0000F788                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F788 _rdata$r        ends
.rdata$r:0000F788
.rdata$r:0000F78C ; ===========================================================================
.rdata$r:0000F78C
.rdata$r:0000F78C ; Segment type: Pure data
.rdata$r:0000F78C ; Segment permissions: Read
.rdata$r:0000F78C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F78C                 assume cs:_rdata$r
.rdata$r:0000F78C                 ;org 0F78Ch
.rdata$r:0000F78C ; COMDAT (pick any)
.rdata$r:0000F78C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000F78C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000F78C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000E940o
.rdata$r:0000F78D                 db    0
.rdata$r:0000F78E                 db    0
.rdata$r:0000F78F                 db    0
.rdata$r:0000F790                 db    0
.rdata$r:0000F791                 db    0
.rdata$r:0000F792                 db    0
.rdata$r:0000F793                 db    0
.rdata$r:0000F794                 db    0
.rdata$r:0000F795                 db    0
.rdata$r:0000F796                 db    0
.rdata$r:0000F797                 db    0
.rdata$r:0000F798                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000F79C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F79C _rdata$r        ends
.rdata$r:0000F79C
.data$r:0000F7A0 ; ===========================================================================
.data$r:0000F7A0
.data$r:0000F7A0 ; Segment type: Pure data
.data$r:0000F7A0 ; Segment permissions: Read/Write
.data$r:0000F7A0 _data$r         segment dword public 'DATA' use32
.data$r:0000F7A0                 assume cs:_data$r
.data$r:0000F7A0                 ;org 0F7A0h
.data$r:0000F7A0 ; COMDAT (pick any)
.data$r:0000F7A0                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000F7A0 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000F7A0 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F7A0                                         ; DATA XREF: .rdata$r:0000F798o
.data$r:0000F7A0                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F7A0                                         ; const type_info::`vftable'
.data$r:0000F7A4                 align 8
.data$r:0000F7A8 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:0000F7C9                 align 4
.data$r:0000F7C9 _data$r         ends
.data$r:0000F7C9
.rdata$r:0000F7CC ; ===========================================================================
.rdata$r:0000F7CC
.rdata$r:0000F7CC ; Segment type: Pure data
.rdata$r:0000F7CC ; Segment permissions: Read
.rdata$r:0000F7CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F7CC                 assume cs:_rdata$r
.rdata$r:0000F7CC                 ;org 0F7CCh
.rdata$r:0000F7CC ; COMDAT (pick any)
.rdata$r:0000F7CC                 public ??_R3_System_error_category@std@@8
.rdata$r:0000F7CC ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F7CC ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000F79Co
.rdata$r:0000F7CC                                         ; .rdata$r:0000F804o
.rdata$r:0000F7CD                 db    0
.rdata$r:0000F7CE                 db    0
.rdata$r:0000F7CF                 db    0
.rdata$r:0000F7D0                 db    0
.rdata$r:0000F7D1                 db    0
.rdata$r:0000F7D2                 db    0
.rdata$r:0000F7D3                 db    0
.rdata$r:0000F7D4                 db    3
.rdata$r:0000F7D5                 db    0
.rdata$r:0000F7D6                 db    0
.rdata$r:0000F7D7                 db    0
.rdata$r:0000F7D8                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000F7D8 _rdata$r        ends
.rdata$r:0000F7D8
.rdata$r:0000F7DC ; ===========================================================================
.rdata$r:0000F7DC
.rdata$r:0000F7DC ; Segment type: Pure data
.rdata$r:0000F7DC ; Segment permissions: Read
.rdata$r:0000F7DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F7DC                 assume cs:_rdata$r
.rdata$r:0000F7DC                 ;org 0F7DCh
.rdata$r:0000F7DC ; COMDAT (pick any)
.rdata$r:0000F7DC                 public ??_R2_System_error_category@std@@8
.rdata$r:0000F7DC ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000F7DC ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000F7DC                                         ; DATA XREF: .rdata$r:0000F7D8o
.rdata$r:0000F7DC                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F7E0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F7E4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F7E8                 db    0
.rdata$r:0000F7E9                 align 4
.rdata$r:0000F7E9 _rdata$r        ends
.rdata$r:0000F7E9
.rdata$r:0000F7EC ; ===========================================================================
.rdata$r:0000F7EC
.rdata$r:0000F7EC ; Segment type: Pure data
.rdata$r:0000F7EC ; Segment permissions: Read
.rdata$r:0000F7EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F7EC                 assume cs:_rdata$r
.rdata$r:0000F7EC                 ;org 0F7ECh
.rdata$r:0000F7EC ; COMDAT (pick any)
.rdata$r:0000F7EC                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000F7EC ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F7EC ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000F7EC                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000F7EC                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000F7F0                 db    2
.rdata$r:0000F7F1                 db    0
.rdata$r:0000F7F2                 db    0
.rdata$r:0000F7F3                 db    0
.rdata$r:0000F7F4                 db    0
.rdata$r:0000F7F5                 db    0
.rdata$r:0000F7F6                 db    0
.rdata$r:0000F7F7                 db    0
.rdata$r:0000F7F8                 db 0FFh
.rdata$r:0000F7F9                 db 0FFh
.rdata$r:0000F7FA                 db 0FFh
.rdata$r:0000F7FB                 db 0FFh
.rdata$r:0000F7FC                 db    0
.rdata$r:0000F7FD                 db    0
.rdata$r:0000F7FE                 db    0
.rdata$r:0000F7FF                 db    0
.rdata$r:0000F800                 db  40h ; @
.rdata$r:0000F801                 db    0
.rdata$r:0000F802                 db    0
.rdata$r:0000F803                 db    0
.rdata$r:0000F804                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F804 _rdata$r        ends
.rdata$r:0000F804
.rdata$r:0000F808 ; ===========================================================================
.rdata$r:0000F808
.rdata$r:0000F808 ; Segment type: Pure data
.rdata$r:0000F808 ; Segment permissions: Read
.rdata$r:0000F808 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F808                 assume cs:_rdata$r
.rdata$r:0000F808                 ;org 0F808h
.rdata$r:0000F808 ; COMDAT (pick any)
.rdata$r:0000F808                 public ??_R4Shortcut@@6B@
.rdata$r:0000F808 ; const Shortcut::`RTTI Complete Object Locator'
.rdata$r:0000F808 ??_R4Shortcut@@6B@ db    0              ; DATA XREF: .rdata:0000E97Co
.rdata$r:0000F809                 db    0
.rdata$r:0000F80A                 db    0
.rdata$r:0000F80B                 db    0
.rdata$r:0000F80C                 db    0
.rdata$r:0000F80D                 db    0
.rdata$r:0000F80E                 db    0
.rdata$r:0000F80F                 db    0
.rdata$r:0000F810                 db    0
.rdata$r:0000F811                 db    0
.rdata$r:0000F812                 db    0
.rdata$r:0000F813                 db    0
.rdata$r:0000F814                 dd offset ??_R0?AVShortcut@@@8 ; Shortcut `RTTI Type Descriptor'
.rdata$r:0000F818                 dd offset ??_R3Shortcut@@8 ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F818 _rdata$r        ends
.rdata$r:0000F818
.data$r:0000F81C ; ===========================================================================
.data$r:0000F81C
.data$r:0000F81C ; Segment type: Pure data
.data$r:0000F81C ; Segment permissions: Read/Write
.data$r:0000F81C _data$r         segment dword public 'DATA' use32
.data$r:0000F81C                 assume cs:_data$r
.data$r:0000F81C                 ;org 0F81Ch
.data$r:0000F81C ; COMDAT (pick any)
.data$r:0000F81C                 public ??_R0?AVShortcut@@@8
.data$r:0000F81C ; class Shortcut `RTTI Type Descriptor'
.data$r:0000F81C ??_R0?AVShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F81C                                         ; DATA XREF: .rdata$r:0000F814o
.data$r:0000F81C                                         ; .rdata$r:Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F81C                                         ; const type_info::`vftable'
.data$r:0000F820                 db    0
.data$r:0000F821                 db    0
.data$r:0000F822                 db    0
.data$r:0000F823                 db    0
.data$r:0000F824                 db  2Eh ; .
.data$r:0000F825                 db  3Fh ; ?
.data$r:0000F826                 db  41h ; A
.data$r:0000F827                 db  56h ; V
.data$r:0000F828                 db  53h ; S
.data$r:0000F829                 db  68h ; h
.data$r:0000F82A                 db  6Fh ; o
.data$r:0000F82B                 db  72h ; r
.data$r:0000F82C                 db  74h ; t
.data$r:0000F82D                 db  63h ; c
.data$r:0000F82E                 db  75h ; u
.data$r:0000F82F                 db  74h ; t
.data$r:0000F830                 db  40h ; @
.data$r:0000F831                 db  40h ; @
.data$r:0000F832                 db    0
.data$r:0000F833                 align 4
.data$r:0000F833 _data$r         ends
.data$r:0000F833
.rdata$r:0000F834 ; ===========================================================================
.rdata$r:0000F834
.rdata$r:0000F834 ; Segment type: Pure data
.rdata$r:0000F834 ; Segment permissions: Read
.rdata$r:0000F834 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F834                 assume cs:_rdata$r
.rdata$r:0000F834                 ;org 0F834h
.rdata$r:0000F834 ; COMDAT (pick any)
.rdata$r:0000F834                 public ??_R3Shortcut@@8
.rdata$r:0000F834 ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F834 ??_R3Shortcut@@8 db    0                ; DATA XREF: .rdata$r:0000F818o
.rdata$r:0000F834                                         ; .rdata$r:0000F86Co
.rdata$r:0000F835                 db    0
.rdata$r:0000F836                 db    0
.rdata$r:0000F837                 db    0
.rdata$r:0000F838                 db    0
.rdata$r:0000F839                 db    0
.rdata$r:0000F83A                 db    0
.rdata$r:0000F83B                 db    0
.rdata$r:0000F83C                 db    3
.rdata$r:0000F83D                 db    0
.rdata$r:0000F83E                 db    0
.rdata$r:0000F83F                 db    0
.rdata$r:0000F840                 dd offset ??_R2Shortcut@@8 ; Shortcut::`RTTI Base Class Array'
.rdata$r:0000F840 _rdata$r        ends
.rdata$r:0000F840
.rdata$r:0000F844 ; ===========================================================================
.rdata$r:0000F844
.rdata$r:0000F844 ; Segment type: Pure data
.rdata$r:0000F844 ; Segment permissions: Read
.rdata$r:0000F844 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F844                 assume cs:_rdata$r
.rdata$r:0000F844                 ;org 0F844h
.rdata$r:0000F844 ; COMDAT (pick any)
.rdata$r:0000F844                 public ??_R2Shortcut@@8
.rdata$r:0000F844 ; Shortcut::`RTTI Base Class Array'
.rdata$r:0000F844 ??_R2Shortcut@@8 dd offset ??_R1A@?0A@EA@Shortcut@@8
.rdata$r:0000F844                                         ; DATA XREF: .rdata$r:0000F840o
.rdata$r:0000F844                                         ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F848                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F84C                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F850                 db    0
.rdata$r:0000F851                 align 4
.rdata$r:0000F851 _rdata$r        ends
.rdata$r:0000F851
.rdata$r:0000F854 ; ===========================================================================
.rdata$r:0000F854
.rdata$r:0000F854 ; Segment type: Pure data
.rdata$r:0000F854 ; Segment permissions: Read
.rdata$r:0000F854 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F854                 assume cs:_rdata$r
.rdata$r:0000F854                 ;org 0F854h
.rdata$r:0000F854 ; COMDAT (pick any)
.rdata$r:0000F854                 public ??_R1A@?0A@EA@Shortcut@@8
.rdata$r:0000F854 ; Shortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F854 ??_R1A@?0A@EA@Shortcut@@8 dd offset ??_R0?AVShortcut@@@8
.rdata$r:0000F854                                         ; DATA XREF: .rdata$r:Shortcut::`RTTI Base Class Array'o
.rdata$r:0000F854                                         ; .rdata$r:0000F8B8o ...
.rdata$r:0000F854                                         ; Shortcut `RTTI Type Descriptor'
.rdata$r:0000F858                 db    2
.rdata$r:0000F859                 db    0
.rdata$r:0000F85A                 db    0
.rdata$r:0000F85B                 db    0
.rdata$r:0000F85C                 db    0
.rdata$r:0000F85D                 db    0
.rdata$r:0000F85E                 db    0
.rdata$r:0000F85F                 db    0
.rdata$r:0000F860                 db 0FFh
.rdata$r:0000F861                 db 0FFh
.rdata$r:0000F862                 db 0FFh
.rdata$r:0000F863                 db 0FFh
.rdata$r:0000F864                 db    0
.rdata$r:0000F865                 db    0
.rdata$r:0000F866                 db    0
.rdata$r:0000F867                 db    0
.rdata$r:0000F868                 db  40h ; @
.rdata$r:0000F869                 db    0
.rdata$r:0000F86A                 db    0
.rdata$r:0000F86B                 db    0
.rdata$r:0000F86C                 dd offset ??_R3Shortcut@@8 ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F86C _rdata$r        ends
.rdata$r:0000F86C
.rdata$r:0000F870 ; ===========================================================================
.rdata$r:0000F870
.rdata$r:0000F870 ; Segment type: Pure data
.rdata$r:0000F870 ; Segment permissions: Read
.rdata$r:0000F870 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F870                 assume cs:_rdata$r
.rdata$r:0000F870                 ;org 0F870h
.rdata$r:0000F870 ; COMDAT (pick any)
.rdata$r:0000F870                 public ??_R4CommandShortcut@@6B@
.rdata$r:0000F870 ; const CommandShortcut::`RTTI Complete Object Locator'
.rdata$r:0000F870 ??_R4CommandShortcut@@6B@ db    0       ; DATA XREF: .rdata:0000E9CCo
.rdata$r:0000F871                 db    0
.rdata$r:0000F872                 db    0
.rdata$r:0000F873                 db    0
.rdata$r:0000F874                 db    0
.rdata$r:0000F875                 db    0
.rdata$r:0000F876                 db    0
.rdata$r:0000F877                 db    0
.rdata$r:0000F878                 db    0
.rdata$r:0000F879                 db    0
.rdata$r:0000F87A                 db    0
.rdata$r:0000F87B                 db    0
.rdata$r:0000F87C                 dd offset ??_R0?AVCommandShortcut@@@8 ; CommandShortcut `RTTI Type Descriptor'
.rdata$r:0000F880                 dd offset ??_R3CommandShortcut@@8 ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F880 _rdata$r        ends
.rdata$r:0000F880
.data$r:0000F884 ; ===========================================================================
.data$r:0000F884
.data$r:0000F884 ; Segment type: Pure data
.data$r:0000F884 ; Segment permissions: Read/Write
.data$r:0000F884 _data$r         segment dword public 'DATA' use32
.data$r:0000F884                 assume cs:_data$r
.data$r:0000F884                 ;org 0F884h
.data$r:0000F884 ; COMDAT (pick any)
.data$r:0000F884                 public ??_R0?AVCommandShortcut@@@8
.data$r:0000F884 ; class CommandShortcut `RTTI Type Descriptor'
.data$r:0000F884 ??_R0?AVCommandShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F884                                         ; DATA XREF: .rdata$r:0000F87Co
.data$r:0000F884                                         ; .rdata$r:CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F884                                         ; const type_info::`vftable'
.data$r:0000F888                 db    0
.data$r:0000F889                 db    0
.data$r:0000F88A                 db    0
.data$r:0000F88B                 db    0
.data$r:0000F88C                 db  2Eh ; .
.data$r:0000F88D                 db  3Fh ; ?
.data$r:0000F88E                 db  41h ; A
.data$r:0000F88F                 db  56h ; V
.data$r:0000F890                 db  43h ; C
.data$r:0000F891                 db  6Fh ; o
.data$r:0000F892                 db  6Dh ; m
.data$r:0000F893                 db  6Dh ; m
.data$r:0000F894                 db  61h ; a
.data$r:0000F895                 db  6Eh ; n
.data$r:0000F896                 db  64h ; d
.data$r:0000F897                 db  53h ; S
.data$r:0000F898                 db  68h ; h
.data$r:0000F899                 db  6Fh ; o
.data$r:0000F89A                 db  72h ; r
.data$r:0000F89B                 db  74h ; t
.data$r:0000F89C                 db  63h ; c
.data$r:0000F89D                 db  75h ; u
.data$r:0000F89E                 db  74h ; t
.data$r:0000F89F                 db  40h ; @
.data$r:0000F8A0                 db  40h ; @
.data$r:0000F8A1                 db    0
.data$r:0000F8A2                 align 4
.data$r:0000F8A2 _data$r         ends
.data$r:0000F8A2
.rdata$r:0000F8A4 ; ===========================================================================
.rdata$r:0000F8A4
.rdata$r:0000F8A4 ; Segment type: Pure data
.rdata$r:0000F8A4 ; Segment permissions: Read
.rdata$r:0000F8A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F8A4                 assume cs:_rdata$r
.rdata$r:0000F8A4                 ;org 0F8A4h
.rdata$r:0000F8A4 ; COMDAT (pick any)
.rdata$r:0000F8A4                 public ??_R3CommandShortcut@@8
.rdata$r:0000F8A4 ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F8A4 ??_R3CommandShortcut@@8 db    0         ; DATA XREF: .rdata$r:0000F880o
.rdata$r:0000F8A4                                         ; .rdata$r:0000F8E0o
.rdata$r:0000F8A5                 db    0
.rdata$r:0000F8A6                 db    0
.rdata$r:0000F8A7                 db    0
.rdata$r:0000F8A8                 db    0
.rdata$r:0000F8A9                 db    0
.rdata$r:0000F8AA                 db    0
.rdata$r:0000F8AB                 db    0
.rdata$r:0000F8AC                 db    4
.rdata$r:0000F8AD                 db    0
.rdata$r:0000F8AE                 db    0
.rdata$r:0000F8AF                 db    0
.rdata$r:0000F8B0                 dd offset ??_R2CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Array'
.rdata$r:0000F8B0 _rdata$r        ends
.rdata$r:0000F8B0
.rdata$r:0000F8B4 ; ===========================================================================
.rdata$r:0000F8B4
.rdata$r:0000F8B4 ; Segment type: Pure data
.rdata$r:0000F8B4 ; Segment permissions: Read
.rdata$r:0000F8B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F8B4                 assume cs:_rdata$r
.rdata$r:0000F8B4                 ;org 0F8B4h
.rdata$r:0000F8B4 ; COMDAT (pick any)
.rdata$r:0000F8B4                 public ??_R2CommandShortcut@@8
.rdata$r:0000F8B4 ; CommandShortcut::`RTTI Base Class Array'
.rdata$r:0000F8B4 ??_R2CommandShortcut@@8 dd offset ??_R1A@?0A@EA@CommandShortcut@@8
.rdata$r:0000F8B4                                         ; DATA XREF: .rdata$r:0000F8B0o
.rdata$r:0000F8B4                                         ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F8B8                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F8BC                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F8C0                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F8C4                 db    0
.rdata$r:0000F8C5                 align 4
.rdata$r:0000F8C5 _rdata$r        ends
.rdata$r:0000F8C5
.rdata$r:0000F8C8 ; ===========================================================================
.rdata$r:0000F8C8
.rdata$r:0000F8C8 ; Segment type: Pure data
.rdata$r:0000F8C8 ; Segment permissions: Read
.rdata$r:0000F8C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F8C8                 assume cs:_rdata$r
.rdata$r:0000F8C8                 ;org 0F8C8h
.rdata$r:0000F8C8 ; COMDAT (pick any)
.rdata$r:0000F8C8                 public ??_R1A@?0A@EA@CommandShortcut@@8
.rdata$r:0000F8C8 ; CommandShortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F8C8 ??_R1A@?0A@EA@CommandShortcut@@8 dd offset ??_R0?AVCommandShortcut@@@8
.rdata$r:0000F8C8                                         ; DATA XREF: .rdata$r:CommandShortcut::`RTTI Base Class Array'o
.rdata$r:0000F8C8                                         ; .rdata$r:0000F99Co ...
.rdata$r:0000F8C8                                         ; CommandShortcut `RTTI Type Descriptor'
.rdata$r:0000F8CC                 db    3
.rdata$r:0000F8CD                 db    0
.rdata$r:0000F8CE                 db    0
.rdata$r:0000F8CF                 db    0
.rdata$r:0000F8D0                 db    0
.rdata$r:0000F8D1                 db    0
.rdata$r:0000F8D2                 db    0
.rdata$r:0000F8D3                 db    0
.rdata$r:0000F8D4                 db 0FFh
.rdata$r:0000F8D5                 db 0FFh
.rdata$r:0000F8D6                 db 0FFh
.rdata$r:0000F8D7                 db 0FFh
.rdata$r:0000F8D8                 db    0
.rdata$r:0000F8D9                 db    0
.rdata$r:0000F8DA                 db    0
.rdata$r:0000F8DB                 db    0
.rdata$r:0000F8DC                 db  40h ; @
.rdata$r:0000F8DD                 db    0
.rdata$r:0000F8DE                 db    0
.rdata$r:0000F8DF                 db    0
.rdata$r:0000F8E0                 dd offset ??_R3CommandShortcut@@8 ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F8E0 _rdata$r        ends
.rdata$r:0000F8E0
.rdata$r:0000F8E4 ; ===========================================================================
.rdata$r:0000F8E4
.rdata$r:0000F8E4 ; Segment type: Pure data
.rdata$r:0000F8E4 ; Segment permissions: Read
.rdata$r:0000F8E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F8E4                 assume cs:_rdata$r
.rdata$r:0000F8E4                 ;org 0F8E4h
.rdata$r:0000F8E4 ; COMDAT (pick any)
.rdata$r:0000F8E4                 public ??_R4ScintillaKeyMap@@6B@
.rdata$r:0000F8E4 ; const ScintillaKeyMap::`RTTI Complete Object Locator'
.rdata$r:0000F8E4 ??_R4ScintillaKeyMap@@6B@ db    0       ; DATA XREF: .rdata:0000EA1Co
.rdata$r:0000F8E5                 db    0
.rdata$r:0000F8E6                 db    0
.rdata$r:0000F8E7                 db    0
.rdata$r:0000F8E8                 db    0
.rdata$r:0000F8E9                 db    0
.rdata$r:0000F8EA                 db    0
.rdata$r:0000F8EB                 db    0
.rdata$r:0000F8EC                 db    0
.rdata$r:0000F8ED                 db    0
.rdata$r:0000F8EE                 db    0
.rdata$r:0000F8EF                 db    0
.rdata$r:0000F8F0                 dd offset ??_R0?AVScintillaKeyMap@@@8 ; ScintillaKeyMap `RTTI Type Descriptor'
.rdata$r:0000F8F4                 dd offset ??_R3ScintillaKeyMap@@8 ; ScintillaKeyMap::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F8F4 _rdata$r        ends
.rdata$r:0000F8F4
.data$r:0000F8F8 ; ===========================================================================
.data$r:0000F8F8
.data$r:0000F8F8 ; Segment type: Pure data
.data$r:0000F8F8 ; Segment permissions: Read/Write
.data$r:0000F8F8 _data$r         segment dword public 'DATA' use32
.data$r:0000F8F8                 assume cs:_data$r
.data$r:0000F8F8                 ;org 0F8F8h
.data$r:0000F8F8 ; COMDAT (pick any)
.data$r:0000F8F8                 public ??_R0?AVScintillaKeyMap@@@8
.data$r:0000F8F8 ; class ScintillaKeyMap `RTTI Type Descriptor'
.data$r:0000F8F8 ??_R0?AVScintillaKeyMap@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F8F8                                         ; DATA XREF: .rdata$r:0000F8F0o
.data$r:0000F8F8                                         ; .rdata$r:ScintillaKeyMap::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F8F8                                         ; const type_info::`vftable'
.data$r:0000F8FC                 align 10h
.data$r:0000F900 a_?avscintillak db '.?AVScintillaKeyMap@@',0
.data$r:0000F916                 align 4
.data$r:0000F916 _data$r         ends
.data$r:0000F916
.rdata$r:0000F918 ; ===========================================================================
.rdata$r:0000F918
.rdata$r:0000F918 ; Segment type: Pure data
.rdata$r:0000F918 ; Segment permissions: Read
.rdata$r:0000F918 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F918                 assume cs:_rdata$r
.rdata$r:0000F918                 ;org 0F918h
.rdata$r:0000F918 ; COMDAT (pick any)
.rdata$r:0000F918                 public ??_R3ScintillaKeyMap@@8
.rdata$r:0000F918 ; ScintillaKeyMap::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F918 ??_R3ScintillaKeyMap@@8 db    0         ; DATA XREF: .rdata$r:0000F8F4o
.rdata$r:0000F918                                         ; .rdata$r:0000F954o
.rdata$r:0000F919                 db    0
.rdata$r:0000F91A                 db    0
.rdata$r:0000F91B                 db    0
.rdata$r:0000F91C                 db    0
.rdata$r:0000F91D                 db    0
.rdata$r:0000F91E                 db    0
.rdata$r:0000F91F                 db    0
.rdata$r:0000F920                 db    4
.rdata$r:0000F921                 db    0
.rdata$r:0000F922                 db    0
.rdata$r:0000F923                 db    0
.rdata$r:0000F924                 dd offset ??_R2ScintillaKeyMap@@8 ; ScintillaKeyMap::`RTTI Base Class Array'
.rdata$r:0000F924 _rdata$r        ends
.rdata$r:0000F924
.rdata$r:0000F928 ; ===========================================================================
.rdata$r:0000F928
.rdata$r:0000F928 ; Segment type: Pure data
.rdata$r:0000F928 ; Segment permissions: Read
.rdata$r:0000F928 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F928                 assume cs:_rdata$r
.rdata$r:0000F928                 ;org 0F928h
.rdata$r:0000F928 ; COMDAT (pick any)
.rdata$r:0000F928                 public ??_R2ScintillaKeyMap@@8
.rdata$r:0000F928 ; ScintillaKeyMap::`RTTI Base Class Array'
.rdata$r:0000F928 ??_R2ScintillaKeyMap@@8 dd offset ??_R1A@?0A@EA@ScintillaKeyMap@@8
.rdata$r:0000F928                                         ; DATA XREF: .rdata$r:0000F924o
.rdata$r:0000F928                                         ; ScintillaKeyMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F92C                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F930                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F934                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F938                 db    0
.rdata$r:0000F939                 align 4
.rdata$r:0000F939 _rdata$r        ends
.rdata$r:0000F939
.rdata$r:0000F93C ; ===========================================================================
.rdata$r:0000F93C
.rdata$r:0000F93C ; Segment type: Pure data
.rdata$r:0000F93C ; Segment permissions: Read
.rdata$r:0000F93C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F93C                 assume cs:_rdata$r
.rdata$r:0000F93C                 ;org 0F93Ch
.rdata$r:0000F93C ; COMDAT (pick any)
.rdata$r:0000F93C                 public ??_R1A@?0A@EA@ScintillaKeyMap@@8
.rdata$r:0000F93C ; ScintillaKeyMap::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F93C ??_R1A@?0A@EA@ScintillaKeyMap@@8 dd offset ??_R0?AVScintillaKeyMap@@@8
.rdata$r:0000F93C                                         ; DATA XREF: .rdata$r:ScintillaKeyMap::`RTTI Base Class Array'o
.rdata$r:0000F93C                                         ; ScintillaKeyMap `RTTI Type Descriptor'
.rdata$r:0000F940                 db    3
.rdata$r:0000F941                 db    0
.rdata$r:0000F942                 db    0
.rdata$r:0000F943                 db    0
.rdata$r:0000F944                 db    0
.rdata$r:0000F945                 db    0
.rdata$r:0000F946                 db    0
.rdata$r:0000F947                 db    0
.rdata$r:0000F948                 db 0FFh
.rdata$r:0000F949                 db 0FFh
.rdata$r:0000F94A                 db 0FFh
.rdata$r:0000F94B                 db 0FFh
.rdata$r:0000F94C                 db    0
.rdata$r:0000F94D                 db    0
.rdata$r:0000F94E                 db    0
.rdata$r:0000F94F                 db    0
.rdata$r:0000F950                 db  40h ; @
.rdata$r:0000F951                 db    0
.rdata$r:0000F952                 db    0
.rdata$r:0000F953                 db    0
.rdata$r:0000F954                 dd offset ??_R3ScintillaKeyMap@@8 ; ScintillaKeyMap::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F954 _rdata$r        ends
.rdata$r:0000F954
.rdata$r:0000F958 ; ===========================================================================
.rdata$r:0000F958
.rdata$r:0000F958 ; Segment type: Pure data
.rdata$r:0000F958 ; Segment permissions: Read
.rdata$r:0000F958 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F958                 assume cs:_rdata$r
.rdata$r:0000F958                 ;org 0F958h
.rdata$r:0000F958 ; COMDAT (pick any)
.rdata$r:0000F958                 public ??_R4MacroShortcut@@6B@
.rdata$r:0000F958 ; const MacroShortcut::`RTTI Complete Object Locator'
.rdata$r:0000F958 ??_R4MacroShortcut@@6B@ db    0         ; DATA XREF: .rdata:0000EA6Co
.rdata$r:0000F959                 db    0
.rdata$r:0000F95A                 db    0
.rdata$r:0000F95B                 db    0
.rdata$r:0000F95C                 db    0
.rdata$r:0000F95D                 db    0
.rdata$r:0000F95E                 db    0
.rdata$r:0000F95F                 db    0
.rdata$r:0000F960                 db    0
.rdata$r:0000F961                 db    0
.rdata$r:0000F962                 db    0
.rdata$r:0000F963                 db    0
.rdata$r:0000F964                 dd offset ??_R0?AVMacroShortcut@@@8 ; MacroShortcut `RTTI Type Descriptor'
.rdata$r:0000F968                 dd offset ??_R3MacroShortcut@@8 ; MacroShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F968 _rdata$r        ends
.rdata$r:0000F968
.data$r:0000F96C ; ===========================================================================
.data$r:0000F96C
.data$r:0000F96C ; Segment type: Pure data
.data$r:0000F96C ; Segment permissions: Read/Write
.data$r:0000F96C _data$r         segment dword public 'DATA' use32
.data$r:0000F96C                 assume cs:_data$r
.data$r:0000F96C                 ;org 0F96Ch
.data$r:0000F96C ; COMDAT (pick any)
.data$r:0000F96C                 public ??_R0?AVMacroShortcut@@@8
.data$r:0000F96C ; class MacroShortcut `RTTI Type Descriptor'
.data$r:0000F96C ??_R0?AVMacroShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F96C                                         ; DATA XREF: .rdata$r:0000F964o
.data$r:0000F96C                                         ; .rdata$r:MacroShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F96C                                         ; const type_info::`vftable'
.data$r:0000F970                 db    0
.data$r:0000F971                 db    0
.data$r:0000F972                 db    0
.data$r:0000F973                 db    0
.data$r:0000F974                 db  2Eh ; .
.data$r:0000F975                 db  3Fh ; ?
.data$r:0000F976                 db  41h ; A
.data$r:0000F977                 db  56h ; V
.data$r:0000F978                 db  4Dh ; M
.data$r:0000F979                 db  61h ; a
.data$r:0000F97A                 db  63h ; c
.data$r:0000F97B                 db  72h ; r
.data$r:0000F97C                 db  6Fh ; o
.data$r:0000F97D                 db  53h ; S
.data$r:0000F97E                 db  68h ; h
.data$r:0000F97F                 db  6Fh ; o
.data$r:0000F980                 db  72h ; r
.data$r:0000F981                 db  74h ; t
.data$r:0000F982                 db  63h ; c
.data$r:0000F983                 db  75h ; u
.data$r:0000F984                 db  74h ; t
.data$r:0000F985                 db  40h ; @
.data$r:0000F986                 db  40h ; @
.data$r:0000F987                 db    0
.data$r:0000F987 _data$r         ends
.data$r:0000F987
.rdata$r:0000F988 ; ===========================================================================
.rdata$r:0000F988
.rdata$r:0000F988 ; Segment type: Pure data
.rdata$r:0000F988 ; Segment permissions: Read
.rdata$r:0000F988 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F988                 assume cs:_rdata$r
.rdata$r:0000F988                 ;org 0F988h
.rdata$r:0000F988 ; COMDAT (pick any)
.rdata$r:0000F988                 public ??_R3MacroShortcut@@8
.rdata$r:0000F988 ; MacroShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F988 ??_R3MacroShortcut@@8 db    0           ; DATA XREF: .rdata$r:0000F968o
.rdata$r:0000F988                                         ; .rdata$r:0000F9C8o
.rdata$r:0000F989                 db    0
.rdata$r:0000F98A                 db    0
.rdata$r:0000F98B                 db    0
.rdata$r:0000F98C                 db    0
.rdata$r:0000F98D                 db    0
.rdata$r:0000F98E                 db    0
.rdata$r:0000F98F                 db    0
.rdata$r:0000F990                 db    5
.rdata$r:0000F991                 db    0
.rdata$r:0000F992                 db    0
.rdata$r:0000F993                 db    0
.rdata$r:0000F994                 dd offset ??_R2MacroShortcut@@8 ; MacroShortcut::`RTTI Base Class Array'
.rdata$r:0000F994 _rdata$r        ends
.rdata$r:0000F994
.rdata$r:0000F998 ; ===========================================================================
.rdata$r:0000F998
.rdata$r:0000F998 ; Segment type: Pure data
.rdata$r:0000F998 ; Segment permissions: Read
.rdata$r:0000F998 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F998                 assume cs:_rdata$r
.rdata$r:0000F998                 ;org 0F998h
.rdata$r:0000F998 ; COMDAT (pick any)
.rdata$r:0000F998                 public ??_R2MacroShortcut@@8
.rdata$r:0000F998 ; MacroShortcut::`RTTI Base Class Array'
.rdata$r:0000F998 ??_R2MacroShortcut@@8 dd offset ??_R1A@?0A@EA@MacroShortcut@@8
.rdata$r:0000F998                                         ; DATA XREF: .rdata$r:0000F994o
.rdata$r:0000F998                                         ; MacroShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F99C                 dd offset ??_R1A@?0A@EA@CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F9A0                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F9A4                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F9A8                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000F9AC                 db    0
.rdata$r:0000F9AD                 align 10h
.rdata$r:0000F9AD _rdata$r        ends
.rdata$r:0000F9AD
.rdata$r:0000F9B0 ; ===========================================================================
.rdata$r:0000F9B0
.rdata$r:0000F9B0 ; Segment type: Pure data
.rdata$r:0000F9B0 ; Segment permissions: Read
.rdata$r:0000F9B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F9B0                 assume cs:_rdata$r
.rdata$r:0000F9B0                 ;org 0F9B0h
.rdata$r:0000F9B0 ; COMDAT (pick any)
.rdata$r:0000F9B0                 public ??_R1A@?0A@EA@MacroShortcut@@8
.rdata$r:0000F9B0 ; MacroShortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000F9B0 ??_R1A@?0A@EA@MacroShortcut@@8 dd offset ??_R0?AVMacroShortcut@@@8
.rdata$r:0000F9B0                                         ; DATA XREF: .rdata$r:MacroShortcut::`RTTI Base Class Array'o
.rdata$r:0000F9B0                                         ; MacroShortcut `RTTI Type Descriptor'
.rdata$r:0000F9B4                 db    4
.rdata$r:0000F9B5                 db    0
.rdata$r:0000F9B6                 db    0
.rdata$r:0000F9B7                 db    0
.rdata$r:0000F9B8                 db    0
.rdata$r:0000F9B9                 db    0
.rdata$r:0000F9BA                 db    0
.rdata$r:0000F9BB                 db    0
.rdata$r:0000F9BC                 db 0FFh
.rdata$r:0000F9BD                 db 0FFh
.rdata$r:0000F9BE                 db 0FFh
.rdata$r:0000F9BF                 db 0FFh
.rdata$r:0000F9C0                 db    0
.rdata$r:0000F9C1                 db    0
.rdata$r:0000F9C2                 db    0
.rdata$r:0000F9C3                 db    0
.rdata$r:0000F9C4                 db  40h ; @
.rdata$r:0000F9C5                 db    0
.rdata$r:0000F9C6                 db    0
.rdata$r:0000F9C7                 db    0
.rdata$r:0000F9C8                 dd offset ??_R3MacroShortcut@@8 ; MacroShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F9C8 _rdata$r        ends
.rdata$r:0000F9C8
.rdata$r:0000F9CC ; ===========================================================================
.rdata$r:0000F9CC
.rdata$r:0000F9CC ; Segment type: Pure data
.rdata$r:0000F9CC ; Segment permissions: Read
.rdata$r:0000F9CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F9CC                 assume cs:_rdata$r
.rdata$r:0000F9CC                 ;org 0F9CCh
.rdata$r:0000F9CC ; COMDAT (pick any)
.rdata$r:0000F9CC                 public ??_R4UserCommand@@6B@
.rdata$r:0000F9CC ; const UserCommand::`RTTI Complete Object Locator'
.rdata$r:0000F9CC ??_R4UserCommand@@6B@ db    0           ; DATA XREF: .rdata:0000EABCo
.rdata$r:0000F9CD                 db    0
.rdata$r:0000F9CE                 db    0
.rdata$r:0000F9CF                 db    0
.rdata$r:0000F9D0                 db    0
.rdata$r:0000F9D1                 db    0
.rdata$r:0000F9D2                 db    0
.rdata$r:0000F9D3                 db    0
.rdata$r:0000F9D4                 db    0
.rdata$r:0000F9D5                 db    0
.rdata$r:0000F9D6                 db    0
.rdata$r:0000F9D7                 db    0
.rdata$r:0000F9D8                 dd offset ??_R0?AVUserCommand@@@8 ; UserCommand `RTTI Type Descriptor'
.rdata$r:0000F9DC                 dd offset ??_R3UserCommand@@8 ; UserCommand::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F9DC _rdata$r        ends
.rdata$r:0000F9DC
.data$r:0000F9E0 ; ===========================================================================
.data$r:0000F9E0
.data$r:0000F9E0 ; Segment type: Pure data
.data$r:0000F9E0 ; Segment permissions: Read/Write
.data$r:0000F9E0 _data$r         segment dword public 'DATA' use32
.data$r:0000F9E0                 assume cs:_data$r
.data$r:0000F9E0                 ;org 0F9E0h
.data$r:0000F9E0 ; COMDAT (pick any)
.data$r:0000F9E0                 public ??_R0?AVUserCommand@@@8
.data$r:0000F9E0 ; class UserCommand `RTTI Type Descriptor'
.data$r:0000F9E0 ??_R0?AVUserCommand@@@8 dd offset ??_7type_info@@6B@
.data$r:0000F9E0                                         ; DATA XREF: .rdata$r:0000F9D8o
.data$r:0000F9E0                                         ; .rdata$r:UserCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000F9E0                                         ; const type_info::`vftable'
.data$r:0000F9E4                 align 8
.data$r:0000F9E8 a_?avusercomman db '.?AVUserCommand@@',0
.data$r:0000F9FA                 align 4
.data$r:0000F9FA _data$r         ends
.data$r:0000F9FA
.rdata$r:0000F9FC ; ===========================================================================
.rdata$r:0000F9FC
.rdata$r:0000F9FC ; Segment type: Pure data
.rdata$r:0000F9FC ; Segment permissions: Read
.rdata$r:0000F9FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000F9FC                 assume cs:_rdata$r
.rdata$r:0000F9FC                 ;org 0F9FCh
.rdata$r:0000F9FC ; COMDAT (pick any)
.rdata$r:0000F9FC                 public ??_R3UserCommand@@8
.rdata$r:0000F9FC ; UserCommand::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000F9FC ??_R3UserCommand@@8 db    0             ; DATA XREF: .rdata$r:0000F9DCo
.rdata$r:0000F9FC                                         ; .rdata$r:0000FA3Co
.rdata$r:0000F9FD                 db    0
.rdata$r:0000F9FE                 db    0
.rdata$r:0000F9FF                 db    0
.rdata$r:0000FA00                 db    0
.rdata$r:0000FA01                 db    0
.rdata$r:0000FA02                 db    0
.rdata$r:0000FA03                 db    0
.rdata$r:0000FA04                 db    5
.rdata$r:0000FA05                 db    0
.rdata$r:0000FA06                 db    0
.rdata$r:0000FA07                 db    0
.rdata$r:0000FA08                 dd offset ??_R2UserCommand@@8 ; UserCommand::`RTTI Base Class Array'
.rdata$r:0000FA08 _rdata$r        ends
.rdata$r:0000FA08
.rdata$r:0000FA0C ; ===========================================================================
.rdata$r:0000FA0C
.rdata$r:0000FA0C ; Segment type: Pure data
.rdata$r:0000FA0C ; Segment permissions: Read
.rdata$r:0000FA0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000FA0C                 assume cs:_rdata$r
.rdata$r:0000FA0C                 ;org 0FA0Ch
.rdata$r:0000FA0C ; COMDAT (pick any)
.rdata$r:0000FA0C                 public ??_R2UserCommand@@8
.rdata$r:0000FA0C ; UserCommand::`RTTI Base Class Array'
.rdata$r:0000FA0C ??_R2UserCommand@@8 dd offset ??_R1A@?0A@EA@UserCommand@@8
.rdata$r:0000FA0C                                         ; DATA XREF: .rdata$r:0000FA08o
.rdata$r:0000FA0C                                         ; UserCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA10                 dd offset ??_R1A@?0A@EA@CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA14                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA18                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA1C                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA20                 db    0
.rdata$r:0000FA21                 align 4
.rdata$r:0000FA21 _rdata$r        ends
.rdata$r:0000FA21
.rdata$r:0000FA24 ; ===========================================================================
.rdata$r:0000FA24
.rdata$r:0000FA24 ; Segment type: Pure data
.rdata$r:0000FA24 ; Segment permissions: Read
.rdata$r:0000FA24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000FA24                 assume cs:_rdata$r
.rdata$r:0000FA24                 ;org 0FA24h
.rdata$r:0000FA24 ; COMDAT (pick any)
.rdata$r:0000FA24                 public ??_R1A@?0A@EA@UserCommand@@8
.rdata$r:0000FA24 ; UserCommand::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000FA24 ??_R1A@?0A@EA@UserCommand@@8 dd offset ??_R0?AVUserCommand@@@8
.rdata$r:0000FA24                                         ; DATA XREF: .rdata$r:UserCommand::`RTTI Base Class Array'o
.rdata$r:0000FA24                                         ; UserCommand `RTTI Type Descriptor'
.rdata$r:0000FA28                 db    4
.rdata$r:0000FA29                 db    0
.rdata$r:0000FA2A                 db    0
.rdata$r:0000FA2B                 db    0
.rdata$r:0000FA2C                 db    0
.rdata$r:0000FA2D                 db    0
.rdata$r:0000FA2E                 db    0
.rdata$r:0000FA2F                 db    0
.rdata$r:0000FA30                 db 0FFh
.rdata$r:0000FA31                 db 0FFh
.rdata$r:0000FA32                 db 0FFh
.rdata$r:0000FA33                 db 0FFh
.rdata$r:0000FA34                 db    0
.rdata$r:0000FA35                 db    0
.rdata$r:0000FA36                 db    0
.rdata$r:0000FA37                 db    0
.rdata$r:0000FA38                 db  40h ; @
.rdata$r:0000FA39                 db    0
.rdata$r:0000FA3A                 db    0
.rdata$r:0000FA3B                 db    0
.rdata$r:0000FA3C                 dd offset ??_R3UserCommand@@8 ; UserCommand::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000FA3C _rdata$r        ends
.rdata$r:0000FA3C
.rdata$r:0000FA40 ; ===========================================================================
.rdata$r:0000FA40
.rdata$r:0000FA40 ; Segment type: Pure data
.rdata$r:0000FA40 ; Segment permissions: Read
.rdata$r:0000FA40 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000FA40                 assume cs:_rdata$r
.rdata$r:0000FA40                 ;org 0FA40h
.rdata$r:0000FA40 ; COMDAT (pick any)
.rdata$r:0000FA40                 public ??_R4PluginCmdShortcut@@6B@
.rdata$r:0000FA40 ; const PluginCmdShortcut::`RTTI Complete Object Locator'
.rdata$r:0000FA40 ??_R4PluginCmdShortcut@@6B@ db    0     ; DATA XREF: .rdata:0000EB0Co
.rdata$r:0000FA41                 db    0
.rdata$r:0000FA42                 db    0
.rdata$r:0000FA43                 db    0
.rdata$r:0000FA44                 db    0
.rdata$r:0000FA45                 db    0
.rdata$r:0000FA46                 db    0
.rdata$r:0000FA47                 db    0
.rdata$r:0000FA48                 db    0
.rdata$r:0000FA49                 db    0
.rdata$r:0000FA4A                 db    0
.rdata$r:0000FA4B                 db    0
.rdata$r:0000FA4C                 dd offset ??_R0?AVPluginCmdShortcut@@@8 ; PluginCmdShortcut `RTTI Type Descriptor'
.rdata$r:0000FA50                 dd offset ??_R3PluginCmdShortcut@@8 ; PluginCmdShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000FA50 _rdata$r        ends
.rdata$r:0000FA50
.data$r:0000FA54 ; ===========================================================================
.data$r:0000FA54
.data$r:0000FA54 ; Segment type: Pure data
.data$r:0000FA54 ; Segment permissions: Read/Write
.data$r:0000FA54 _data$r         segment dword public 'DATA' use32
.data$r:0000FA54                 assume cs:_data$r
.data$r:0000FA54                 ;org 0FA54h
.data$r:0000FA54 ; COMDAT (pick any)
.data$r:0000FA54                 public ??_R0?AVPluginCmdShortcut@@@8
.data$r:0000FA54 ; class PluginCmdShortcut `RTTI Type Descriptor'
.data$r:0000FA54 ??_R0?AVPluginCmdShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:0000FA54                                         ; DATA XREF: .rdata$r:0000FA4Co
.data$r:0000FA54                                         ; .rdata$r:PluginCmdShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000FA54                                         ; const type_info::`vftable'
.data$r:0000FA58                 db    0
.data$r:0000FA59                 db    0
.data$r:0000FA5A                 db    0
.data$r:0000FA5B                 db    0
.data$r:0000FA5C                 db  2Eh ; .
.data$r:0000FA5D                 db  3Fh ; ?
.data$r:0000FA5E                 db  41h ; A
.data$r:0000FA5F                 db  56h ; V
.data$r:0000FA60                 db  50h ; P
.data$r:0000FA61                 db  6Ch ; l
.data$r:0000FA62                 db  75h ; u
.data$r:0000FA63                 db  67h ; g
.data$r:0000FA64                 db  69h ; i
.data$r:0000FA65                 db  6Eh ; n
.data$r:0000FA66                 db  43h ; C
.data$r:0000FA67                 db  6Dh ; m
.data$r:0000FA68                 db  64h ; d
.data$r:0000FA69                 db  53h ; S
.data$r:0000FA6A                 db  68h ; h
.data$r:0000FA6B                 db  6Fh ; o
.data$r:0000FA6C                 db  72h ; r
.data$r:0000FA6D                 db  74h ; t
.data$r:0000FA6E                 db  63h ; c
.data$r:0000FA6F                 db  75h ; u
.data$r:0000FA70                 db  74h ; t
.data$r:0000FA71                 db  40h ; @
.data$r:0000FA72                 db  40h ; @
.data$r:0000FA73                 db    0
.data$r:0000FA73 _data$r         ends
.data$r:0000FA73
.rdata$r:0000FA74 ; ===========================================================================
.rdata$r:0000FA74
.rdata$r:0000FA74 ; Segment type: Pure data
.rdata$r:0000FA74 ; Segment permissions: Read
.rdata$r:0000FA74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000FA74                 assume cs:_rdata$r
.rdata$r:0000FA74                 ;org 0FA74h
.rdata$r:0000FA74 ; COMDAT (pick any)
.rdata$r:0000FA74                 public ??_R3PluginCmdShortcut@@8
.rdata$r:0000FA74 ; PluginCmdShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000FA74 ??_R3PluginCmdShortcut@@8 db    0       ; DATA XREF: .rdata$r:0000FA50o
.rdata$r:0000FA74                                         ; .rdata$r:0000FAB4o
.rdata$r:0000FA75                 db    0
.rdata$r:0000FA76                 db    0
.rdata$r:0000FA77                 db    0
.rdata$r:0000FA78                 db    0
.rdata$r:0000FA79                 db    0
.rdata$r:0000FA7A                 db    0
.rdata$r:0000FA7B                 db    0
.rdata$r:0000FA7C                 db    5
.rdata$r:0000FA7D                 db    0
.rdata$r:0000FA7E                 db    0
.rdata$r:0000FA7F                 db    0
.rdata$r:0000FA80                 dd offset ??_R2PluginCmdShortcut@@8 ; PluginCmdShortcut::`RTTI Base Class Array'
.rdata$r:0000FA80 _rdata$r        ends
.rdata$r:0000FA80
.rdata$r:0000FA84 ; ===========================================================================
.rdata$r:0000FA84
.rdata$r:0000FA84 ; Segment type: Pure data
.rdata$r:0000FA84 ; Segment permissions: Read
.rdata$r:0000FA84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000FA84                 assume cs:_rdata$r
.rdata$r:0000FA84                 ;org 0FA84h
.rdata$r:0000FA84 ; COMDAT (pick any)
.rdata$r:0000FA84                 public ??_R2PluginCmdShortcut@@8
.rdata$r:0000FA84 ; PluginCmdShortcut::`RTTI Base Class Array'
.rdata$r:0000FA84 ??_R2PluginCmdShortcut@@8 dd offset ??_R1A@?0A@EA@PluginCmdShortcut@@8
.rdata$r:0000FA84                                         ; DATA XREF: .rdata$r:0000FA80o
.rdata$r:0000FA84                                         ; PluginCmdShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA88                 dd offset ??_R1A@?0A@EA@CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA8C                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA90                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA94                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000FA98                 db    0
.rdata$r:0000FA99                 align 4
.rdata$r:0000FA99 _rdata$r        ends
.rdata$r:0000FA99
.rdata$r:0000FA9C ; ===========================================================================
.rdata$r:0000FA9C
.rdata$r:0000FA9C ; Segment type: Pure data
.rdata$r:0000FA9C ; Segment permissions: Read
.rdata$r:0000FA9C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000FA9C                 assume cs:_rdata$r
.rdata$r:0000FA9C                 ;org 0FA9Ch
.rdata$r:0000FA9C ; COMDAT (pick any)
.rdata$r:0000FA9C                 public ??_R1A@?0A@EA@PluginCmdShortcut@@8
.rdata$r:0000FA9C ; PluginCmdShortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000FA9C ??_R1A@?0A@EA@PluginCmdShortcut@@8 dd offset ??_R0?AVPluginCmdShortcut@@@8
.rdata$r:0000FA9C                                         ; DATA XREF: .rdata$r:PluginCmdShortcut::`RTTI Base Class Array'o
.rdata$r:0000FA9C                                         ; PluginCmdShortcut `RTTI Type Descriptor'
.rdata$r:0000FAA0                 db    4
.rdata$r:0000FAA1                 db    0
.rdata$r:0000FAA2                 db    0
.rdata$r:0000FAA3                 db    0
.rdata$r:0000FAA4                 db    0
.rdata$r:0000FAA5                 db    0
.rdata$r:0000FAA6                 db    0
.rdata$r:0000FAA7                 db    0
.rdata$r:0000FAA8                 db 0FFh
.rdata$r:0000FAA9                 db 0FFh
.rdata$r:0000FAAA                 db 0FFh
.rdata$r:0000FAAB                 db 0FFh
.rdata$r:0000FAAC                 db    0
.rdata$r:0000FAAD                 db    0
.rdata$r:0000FAAE                 db    0
.rdata$r:0000FAAF                 db    0
.rdata$r:0000FAB0                 db  40h ; @
.rdata$r:0000FAB1                 db    0
.rdata$r:0000FAB2                 db    0
.rdata$r:0000FAB3                 db    0
.rdata$r:0000FAB4                 dd offset ??_R3PluginCmdShortcut@@8 ; PluginCmdShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000FAB4 _rdata$r        ends
.rdata$r:0000FAB4
.CRT$XCU:0000FAB8 ; ===========================================================================
.CRT$XCU:0000FAB8
.CRT$XCU:0000FAB8 ; Segment type: Pure data
.CRT$XCU:0000FAB8 ; Segment permissions: Read
.CRT$XCU:0000FAB8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FAB8                 assume cs:_CRT$XCU
.CRT$XCU:0000FAB8                 ;org 0FAB8h
.CRT$XCU:0000FAB8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000FABC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000FAC0 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000FAC4 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000FAC4 _CRT$XCU        ends
.CRT$XCU:0000FAC4
.CRT$XCU:0000FAC8 ; ===========================================================================
.CRT$XCU:0000FAC8
.CRT$XCU:0000FAC8 ; Segment type: Pure data
.CRT$XCU:0000FAC8 ; Segment permissions: Read
.CRT$XCU:0000FAC8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FAC8                 assume cs:_CRT$XCU
.CRT$XCU:0000FAC8                 ;org 0FAC8h
.CRT$XCU:0000FAC8 ; COMDAT (pick associative to section at E964)
.CRT$XCU:0000FAC8 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000FAC8 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000FAC8 _CRT$XCU        ends
.CRT$XCU:0000FAC8
.CRT$XCU:0000FACC ; ===========================================================================
.CRT$XCU:0000FACC
.CRT$XCU:0000FACC ; Segment type: Pure data
.CRT$XCU:0000FACC ; Segment permissions: Read
.CRT$XCU:0000FACC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FACC                 assume cs:_CRT$XCU
.CRT$XCU:0000FACC                 ;org 0FACCh
.CRT$XCU:0000FACC ; COMDAT (pick associative to section at E968)
.CRT$XCU:0000FACC ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000FACC ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000FACC _CRT$XCU        ends
.CRT$XCU:0000FACC
.CRT$XCU:0000FAD0 ; ===========================================================================
.CRT$XCU:0000FAD0
.CRT$XCU:0000FAD0 ; Segment type: Pure data
.CRT$XCU:0000FAD0 ; Segment permissions: Read
.CRT$XCU:0000FAD0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FAD0                 assume cs:_CRT$XCU
.CRT$XCU:0000FAD0                 ;org 0FAD0h
.CRT$XCU:0000FAD0 ; COMDAT (pick associative to section at E96C)
.CRT$XCU:0000FAD0 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000FAD0 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000FAD0 _CRT$XCU        ends
.CRT$XCU:0000FAD0
.CRT$XCU:0000FAD4 ; ===========================================================================
.CRT$XCU:0000FAD4
.CRT$XCU:0000FAD4 ; Segment type: Pure data
.CRT$XCU:0000FAD4 ; Segment permissions: Read
.CRT$XCU:0000FAD4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FAD4                 assume cs:_CRT$XCU
.CRT$XCU:0000FAD4                 ;org 0FAD4h
.CRT$XCU:0000FAD4 ; COMDAT (pick associative to section at E974)
.CRT$XCU:0000FAD4 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000FAD4 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000FAD4 _CRT$XCU        ends
.CRT$XCU:0000FAD4
.CRT$XCU:0000FAD8 ; ===========================================================================
.CRT$XCU:0000FAD8
.CRT$XCU:0000FAD8 ; Segment type: Pure data
.CRT$XCU:0000FAD8 ; Segment permissions: Read
.CRT$XCU:0000FAD8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FAD8                 assume cs:_CRT$XCU
.CRT$XCU:0000FAD8                 ;org 0FAD8h
.CRT$XCU:0000FAD8 ; COMDAT (pick associative to section at E978)
.CRT$XCU:0000FAD8 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000FAD8 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000FAD8 _CRT$XCU        ends
.CRT$XCU:0000FAD8
.CRT$XCU:0000FADC ; ===========================================================================
.CRT$XCU:0000FADC
.CRT$XCU:0000FADC ; Segment type: Pure data
.CRT$XCU:0000FADC ; Segment permissions: Read
.CRT$XCU:0000FADC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FADC                 assume cs:_CRT$XCU
.CRT$XCU:0000FADC                 ;org 0FADCh
.CRT$XCU:0000FADC ; COMDAT (pick associative to section at EC28)
.CRT$XCU:0000FADC ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000FADC ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000FADC _CRT$XCU        ends
.CRT$XCU:0000FADC
.CRT$XCU:0000FAE0 ; ===========================================================================
.CRT$XCU:0000FAE0
.CRT$XCU:0000FAE0 ; Segment type: Pure data
.CRT$XCU:0000FAE0 ; Segment permissions: Read
.CRT$XCU:0000FAE0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000FAE0                 assume cs:_CRT$XCU
.CRT$XCU:0000FAE0                 ;org 0FAE0h
.CRT$XCU:0000FAE0 ; COMDAT (pick associative to section at EC2C)
.CRT$XCU:0000FAE0 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000FAE0 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000FAE0 _CRT$XCU        ends
.CRT$XCU:0000FAE0
UNDEF:0000FAF0 ; ===========================================================================
UNDEF:0000FAF0
UNDEF:0000FAF0 ; Segment type: Externs
UNDEF:0000FAF0 ; UNDEF
UNDEF:0000FAF0                 extrn __purecall:near   ; DATA XREF: .rdata:0000E780o
UNDEF:0000FAF0                                         ; .rdata:0000E7E4o ...
UNDEF:0000FAF4 ; void *__cdecl operator new(unsigned int)
UNDEF:0000FAF4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:0000FAF4                                         ; std::_Allocate<KeyCombo>(uint,KeyCombo *)+23p ...
UNDEF:0000FAF8 ; void __cdecl operator delete(void *)
UNDEF:0000FAF8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: CommandShortcut::`scalar deleting destructor'(uint)+1Bp
UNDEF:0000FAF8                                         ; MacroShortcut::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000FAFC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000FAFC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000FAFC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000FB00                 extrn __invalid_parameter:near
UNDEF:0000FB00                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+74p
UNDEF:0000FB00                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+74p ...
UNDEF:0000FB04 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000FB04                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000FB04                                         ; _wmemcpy+11p
UNDEF:0000FB08 ; size_t __cdecl strlen(const char *Str)
UNDEF:0000FB08                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000FB0C ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000FB0C                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000FB0C                                         ; _wmemmove+11p
UNDEF:0000FB10 ; wchar_t *__cdecl wcsncpy(wchar_t *Dest, const wchar_t *Source, size_t Count)
UNDEF:0000FB10                 extrn _wcsncpy:near     ; CODE XREF: ShortcutMapper::translateTab(int,wchar_t const *)+29p
UNDEF:0000FB14 ; int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator)
UNDEF:0000FB14                 extrn __imp__MulDiv@12:near
UNDEF:0000FB14                                         ; CODE XREF: DPIManager::scaleX(int)+13p
UNDEF:0000FB14                                         ; DPIManager::scaleY(int)+14p
UNDEF:0000FB14                                         ; DATA XREF: ...
UNDEF:0000FB18 ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000FB18                 extrn __imp__lstrcmpW@8:near
UNDEF:0000FB18                                         ; CODE XREF: operator==(Shortcut const &,Shortcut const &)+16p
UNDEF:0000FB18                                         ; DATA XREF: operator==(Shortcut const &,Shortcut const &)+16r
UNDEF:0000FB1C ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000FB1C                 extrn __imp__SendMessageW@16:near
UNDEF:0000FB1C                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+EEp
UNDEF:0000FB1C                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+884p ...
UNDEF:0000FB20 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:0000FB20                 extrn __imp__DestroyWindow@4:near
UNDEF:0000FB20                                         ; CODE XREF: StaticDialog::destroy(void)+29p
UNDEF:0000FB20                                         ; DATA XREF: StaticDialog::destroy(void)+29r
UNDEF:0000FB24 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:0000FB24                 extrn __imp__ShowWindow@8:near
UNDEF:0000FB24                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:0000FB24                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:0000FB28 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:0000FB28                 extrn __imp__MoveWindow@24:near
UNDEF:0000FB28                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:0000FB28                                         ; Window::reSizeToWH(tagRECT &)+36p
UNDEF:0000FB28                                         ; DATA XREF: ...
UNDEF:0000FB2C ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:0000FB2C                 extrn __imp__IsWindowVisible@4:near
UNDEF:0000FB2C                                         ; CODE XREF: Window::getHeight(void)+2Bp
UNDEF:0000FB2C                                         ; Window::isVisible(void)+10p
UNDEF:0000FB2C                                         ; DATA XREF: ...
UNDEF:0000FB30 ; INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:0000FB30                 extrn __imp__DialogBoxParamW@20:near
UNDEF:0000FB30                                         ; CODE XREF: ScintillaKeyMap::doDialog(void)+23p
UNDEF:0000FB30                                         ; Shortcut::doDialog(void)+23p
UNDEF:0000FB30                                         ; DATA XREF: ...
UNDEF:0000FB34 ; BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult)
UNDEF:0000FB34                 extrn __imp__EndDialog@8:near
UNDEF:0000FB34                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+1D1p
UNDEF:0000FB34                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+1EAp
UNDEF:0000FB34                                         ; DATA XREF: ...
UNDEF:0000FB38 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:0000FB38                 extrn __imp__GetDlgItem@8:near
UNDEF:0000FB38                                         ; CODE XREF: ShortcutMapper::initTabs(void)+15p
UNDEF:0000FB38                                         ; ShortcutMapper::fillOutBabyGrid(void)+2D8p ...
UNDEF:0000FB3C ; BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable)
UNDEF:0000FB3C                 extrn __imp__EnableWindow@8:near
UNDEF:0000FB3C                                         ; CODE XREF: ShortcutMapper::fillOutBabyGrid(void)+2DFp
UNDEF:0000FB3C                                         ; ShortcutMapper::fillOutBabyGrid(void)+2FDp ...
UNDEF:0000FB40 ; BOOL __stdcall EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
UNDEF:0000FB40                 extrn __imp__EnableMenuItem@12:near
UNDEF:0000FB40                                         ; CODE XREF: ContextMenu::enableItem(int,bool)+36p
UNDEF:0000FB40                                         ; DATA XREF: ContextMenu::enableItem(int,bool)+36r
UNDEF:0000FB44 ; HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos)
UNDEF:0000FB44                 extrn __imp__GetSubMenu@8:near
UNDEF:0000FB44                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+BE5p
UNDEF:0000FB44                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+DC4p
UNDEF:0000FB44                                         ; DATA XREF: ...
UNDEF:0000FB48 ; BOOL __stdcall RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
UNDEF:0000FB48                 extrn __imp__RemoveMenu@12:near
UNDEF:0000FB48                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+EB2p
UNDEF:0000FB48                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+ED1p ...
UNDEF:0000FB4C ; BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
UNDEF:0000FB4C                 extrn __imp__TrackPopupMenu@28:near
UNDEF:0000FB4C                                         ; CODE XREF: ContextMenu::display(tagPOINT const &)+27p
UNDEF:0000FB4C                                         ; DATA XREF: ContextMenu::display(tagPOINT const &)+27r
UNDEF:0000FB50 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:0000FB50                 extrn __imp__UpdateWindow@4:near
UNDEF:0000FB50                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:0000FB50                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:0000FB54 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:0000FB54                 extrn __imp__InvalidateRect@12:near
UNDEF:0000FB54                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:0000FB54                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:0000FB58 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000FB58                 extrn __imp__GetClientRect@8:near
UNDEF:0000FB58                                         ; CODE XREF: Window::getClientRect(tagRECT &)+12p
UNDEF:0000FB58                                         ; Window::getHeight(void)+1Ep ...
UNDEF:0000FB5C ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000FB5C                 extrn __imp__GetWindowRect@8:near
UNDEF:0000FB5C                                         ; CODE XREF: Window::getWindowRect(tagRECT &)+12p
UNDEF:0000FB5C                                         ; DATA XREF: Window::getWindowRect(tagRECT &)+12r
UNDEF:0000FB60 ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:0000FB60                 extrn __imp__MessageBoxW@16:near
UNDEF:0000FB60                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+A40p
UNDEF:0000FB60                                         ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+A40r
UNDEF:0000FB64 ; BOOL __stdcall GetCursorPos(LPPOINT lpPoint)
UNDEF:0000FB64                 extrn __imp__GetCursorPos@4:near
UNDEF:0000FB64                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+F78p
UNDEF:0000FB64                                         ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+F78r
UNDEF:0000FB68 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:0000FB68                 extrn __imp__SetWindowLongW@12:near
UNDEF:0000FB68                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+50p
UNDEF:0000FB68                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+50r
UNDEF:0000FB6C ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:0000FB6C                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:0000FB6C                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:0000FB70 ; public: virtual void __thiscall StaticDialog::create(int, bool, bool)
UNDEF:0000FB70                 extrn ?create@StaticDialog@@UAEXH_N0@Z:near
UNDEF:0000FB70                                         ; DATA XREF: .rdata:0000E7DCo
UNDEF:0000FB70                                         ; .rdata:0000E9B0o ...
UNDEF:0000FB74 ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:0000FB74                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:0000FB74                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+90p
UNDEF:0000FB78 ; public: virtual void __thiscall StaticDialog::display(bool)const
UNDEF:0000FB78                 extrn ?display@StaticDialog@@UBEX_N@Z:near
UNDEF:0000FB78                                         ; DATA XREF: .rdata:0000E7B8o
UNDEF:0000FB78                                         ; .rdata:0000E98Co ...
UNDEF:0000FB7C ; INT_PTR __stdcall StaticDialog::dlgProc(HWND, UINT, WPARAM, LPARAM)
UNDEF:0000FB7C                 extrn ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z:near
UNDEF:0000FB7C                                         ; DATA XREF: ScintillaKeyMap::doDialog(void)+Bo
UNDEF:0000FB7C                                         ; Shortcut::doDialog(void)+Bo
UNDEF:0000FB80 ; public: virtual void * __thiscall StaticDialog::`vector deleting destructor'(unsigned int)
UNDEF:0000FB80                 extrn ??_EStaticDialog@@UAEPAXI@Z:near ; weak
UNDEF:0000FB80                                         ; DATA XREF: .rdata:const StaticDialog::`vftable'o
UNDEF:0000FB84 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000FB84                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000FB84                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000FB84                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000FB88 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000FB88                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000FB88                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000FB88                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000FB8C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000FB90                 extrn __CrtDbgReportW:near
UNDEF:0000FB90                                         ; CODE XREF: std::vector<KeyCombo,std::allocator<KeyCombo>>::operator[](uint)+50p
UNDEF:0000FB90                                         ; std::vector<CommandShortcut,std::allocator<CommandShortcut>>::operator[](uint)+50p ...
UNDEF:0000FB94 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000FB94                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000FB94                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000FB94                                         ; std::_Debug_pointer<KeyCombo>(KeyCombo *,wchar_t const *,uint)+16p ...
UNDEF:0000FB98 ; void __cdecl std::_Xbad_alloc()
UNDEF:0000FB98                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000FB98                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2DBAp
UNDEF:0000FB98                                         ; std::_Allocate<KeyCombo>(uint,KeyCombo *):loc_2DFCp ...
UNDEF:0000FB9C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000FB9C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000FB9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000FB9C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:0000FBA0 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000FBA0                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000FBA0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000FBA0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:0000FBA4 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000FBA4                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000FBA4                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000FBA8 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000FBA8                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000FBA8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000FBA8                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000FBAC ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000FBAC                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000FBAC                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000FBB0 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000FBB0                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000FBB0                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000FBB4 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000FBB4                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000FBB4                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000FBB8 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000FBB8                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000FBB8                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000FBBC ; public: virtual class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall Shortcut::toString(void)const
UNDEF:0000FBBC                 extrn ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:near
UNDEF:0000FBBC                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+32Ap
UNDEF:0000FBBC                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+4A2p ...
UNDEF:0000FBC0 ; void __thiscall Shortcut::setName(Shortcut *__hidden this, const wchar_t *)
UNDEF:0000FBC0                 extrn ?setName@Shortcut@@QAEXPB_W@Z:near
UNDEF:0000FBC0                                         ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+4Ap
UNDEF:0000FBC0                                         ; Shortcut::operator=(Shortcut const &)+3Bp
UNDEF:0000FBC4 ; protected: virtual int __stdcall Shortcut::run_dlgProc(unsigned int, unsigned int, long)
UNDEF:0000FBC4                 extrn ?run_dlgProc@Shortcut@@MAGHIIJ@Z:near
UNDEF:0000FBC4                                         ; DATA XREF: .rdata:0000E9B8o
UNDEF:0000FBC4                                         ; .rdata:0000EA08o ...
UNDEF:0000FBC8 ; public: virtual void * __thiscall Shortcut::`vector deleting destructor'(unsigned int)
UNDEF:0000FBC8                 extrn ??_EShortcut@@UAEPAXI@Z:near ; weak
UNDEF:0000FBC8                                         ; DATA XREF: .rdata:const Shortcut::`vftable'o
UNDEF:0000FBCC ; public: virtual void * __thiscall CommandShortcut::`vector deleting destructor'(unsigned int)
UNDEF:0000FBCC                 extrn ??_ECommandShortcut@@UAEPAXI@Z:near ; weak
UNDEF:0000FBCC                                         ; DATA XREF: .rdata:const CommandShortcut::`vftable'o
UNDEF:0000FBD0 ; public: virtual bool __thiscall ScintillaKeyMap::isEnabled(void)const
UNDEF:0000FBD0                 extrn ?isEnabled@ScintillaKeyMap@@UBE_NXZ:near
UNDEF:0000FBD0                                         ; DATA XREF: .rdata:0000EA64o
UNDEF:0000FBD4 ; public: virtual class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall ScintillaKeyMap::toString(void)const
UNDEF:0000FBD4                 extrn ?toString@ScintillaKeyMap@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:near
UNDEF:0000FBD4                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+99Ep
UNDEF:0000FBD4                                         ; DATA XREF: .rdata:0000EA68o
UNDEF:0000FBD8 ; protected: virtual int __stdcall ScintillaKeyMap::run_dlgProc(unsigned int, unsigned int, long)
UNDEF:0000FBD8                 extrn ?run_dlgProc@ScintillaKeyMap@@MAGHIIJ@Z:near
UNDEF:0000FBD8                                         ; DATA XREF: .rdata:0000EA58o
UNDEF:0000FBDC ; public: virtual void * __thiscall ScintillaKeyMap::`vector deleting destructor'(unsigned int)
UNDEF:0000FBDC                 extrn ??_EScintillaKeyMap@@UAEPAXI@Z:near ; weak
UNDEF:0000FBDC                                         ; DATA XREF: .rdata:const ScintillaKeyMap::`vftable'o
UNDEF:0000FBE0 ; public: virtual void * __thiscall MacroShortcut::`vector deleting destructor'(unsigned int)
UNDEF:0000FBE0                 extrn ??_EMacroShortcut@@UAEPAXI@Z:near ; weak
UNDEF:0000FBE0                                         ; DATA XREF: .rdata:const MacroShortcut::`vftable'o
UNDEF:0000FBE4 ; public: virtual void * __thiscall UserCommand::`vector deleting destructor'(unsigned int)
UNDEF:0000FBE4                 extrn ??_EUserCommand@@UAEPAXI@Z:near ; weak
UNDEF:0000FBE4                                         ; DATA XREF: .rdata:const UserCommand::`vftable'o
UNDEF:0000FBE8 ; public: virtual void * __thiscall PluginCmdShortcut::`vector deleting destructor'(unsigned int)
UNDEF:0000FBE8                 extrn ??_EPluginCmdShortcut@@UAEPAXI@Z:near ; weak
UNDEF:0000FBE8                                         ; DATA XREF: .rdata:const PluginCmdShortcut::`vftable'o
UNDEF:0000FBEC ; void __thiscall Accelerator::updateShortcuts(Accelerator *__hidden this)
UNDEF:0000FBEC                 extrn ?updateShortcuts@Accelerator@@QAEXXZ:near
UNDEF:0000FBEC                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+37Ep
UNDEF:0000FBEC                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+4F6p ...
UNDEF:0000FBF0 ; void __thiscall ScintillaAccelerator::updateKeys(ScintillaAccelerator *__hidden this)
UNDEF:0000FBF0                 extrn ?updateKeys@ScintillaAccelerator@@QAEXXZ:near
UNDEF:0000FBF0                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+9F2p
UNDEF:0000FBF4 ; _DWORD __thiscall MenuItemUnit::MenuItemUnit(MenuItemUnit *__hidden this, unsigned __int32, const wchar_t *, const wchar_t *)
UNDEF:0000FBF4                 extrn ??0MenuItemUnit@@QAE@KPB_W0@Z:near
UNDEF:0000FBF4                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+FB8p
UNDEF:0000FBF4                                         ; ShortcutMapper::run_dlgProc(uint,uint,long)+1006p
UNDEF:0000FBF8 ; public: void __thiscall ContextMenu::create(struct HWND__ *, class std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>> const &, struct HMENU__ * const)
UNDEF:0000FBF8                 extrn ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z:near
UNDEF:0000FBF8                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+1058p
UNDEF:0000FBFC ; void __thiscall NppParameters::addUserModifiedIndex(NppParameters *__hidden this, int)
UNDEF:0000FBFC                 extrn ?addUserModifiedIndex@NppParameters@@QAEXH@Z:near
UNDEF:0000FBFC                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+2F8p
UNDEF:0000FC00 ; void __thiscall NppParameters::addPluginModifiedIndex(NppParameters *__hidden this, int)
UNDEF:0000FC00                 extrn ?addPluginModifiedIndex@NppParameters@@QAEXH@Z:near
UNDEF:0000FC00                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+779p
UNDEF:0000FC04 ; void __thiscall NppParameters::addScintillaModifiedIndex(NppParameters *__hidden this, int)
UNDEF:0000FC04                 extrn ?addScintillaModifiedIndex@NppParameters@@QAEXH@Z:near
UNDEF:0000FC04                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+96Cp
UNDEF:0000FC08 ; __fastcall __security_check_cookie(x)
UNDEF:0000FC08                 extrn @__security_check_cookie@4:near
UNDEF:0000FC08                                         ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+10E6p
UNDEF:0000FC08                                         ; ShortcutMapper::initBabyGrid(void)+A8p ...
UNDEF:0000FC0C ; __stdcall _CxxThrowException(x, x)
UNDEF:0000FC0C                 extrn __CxxThrowException@8:near
UNDEF:0000FC0C                                         ; CODE XREF: __catch$??$_Uninit_copy@PAUKeyCombo@@PAU1@V?$allocator@UKeyCombo@@@std@@@std@@YAPAUKeyCombo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UKeyCombo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p
UNDEF:0000FC0C                                         ; __catch$??$_Uninit_copy@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
UNDEF:0000FC10                 extrn ___CxxFrameHandler3:near
UNDEF:0000FC10                                         ; CODE XREF: __ehhandler$?run_dlgProc@ShortcutMapper@@MAGHIIJ@Z+23j
UNDEF:0000FC10                                         ; __ehhandler$?fillOutBabyGrid@ShortcutMapper@@AAEXXZ+23j ...
UNDEF:0000FC14                 extrn __chkstk:near     ; CODE XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+16p
UNDEF:0000FC18 ; const type_info::`vftable'
UNDEF:0000FC18                 extrn ??_7type_info@@6B@:near
UNDEF:0000FC18                                         ; DATA XREF: .data$r:Window `RTTI Type Descriptor'o
UNDEF:0000FC18                                         ; .data$r:StaticDialog `RTTI Type Descriptor'o ...
UNDEF:0000FC1C ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000FC1C                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000FC1C                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:0000FC20                 extrn ___security_cookie:near
UNDEF:0000FC20                                         ; DATA XREF: ShortcutMapper::run_dlgProc(uint,uint,long)+1Br
UNDEF:0000FC20                                         ; ShortcutMapper::initBabyGrid(void)+6r ...
UNDEF:0000FC24                 extrn __fltused:near
UNDEF:0000FC24
UNDEF:0000FC24
UNDEF:0000FC24                 end