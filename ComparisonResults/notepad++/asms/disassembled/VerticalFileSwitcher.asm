.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : AE08253ABE7AB23CB43C3C60A2A192DB
.bss:00000000 ; Input CRC32 : 6E38EC95
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\VerticalFileSwitcher.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; includelib "libcpmtd"
.bss:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00000000 ; includelib "LIBCMTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 _bss            segment dword public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00000000 _hWndServer     db    ? ;
.bss:00000001                 db    ? ;
.bss:00000002                 db    ? ;
.bss:00000003                 db    ? ;
.bss:00000004 _hook           db    ? ;
.bss:00000005                 db    ? ;
.bss:00000006                 db    ? ;
.bss:00000007                 db    ? ;
.bss:00000008 _allocator_arg  db    ? ;
.bss:00000009 _piecewise_construct db    ? ;
.bss:0000000A                 align 4
.bss:0000000A _bss            ends
.bss:0000000A
.text$mn:0000000C ; ===========================================================================
.text$mn:0000000C
.text$mn:0000000C ; Segment type: Pure code
.text$mn:0000000C ; Segment permissions: Read/Execute
.text$mn:0000000C _text$mn        segment para public 'CODE' use32
.text$mn:0000000C                 assume cs:_text$mn
.text$mn:0000000C                 ;org 0Ch
.text$mn:0000000C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000000C
.text$mn:0000000C ; =============== S U B R O U T I N E =======================================
.text$mn:0000000C
.text$mn:0000000C ; Attributes: bp-based frame
.text$mn:0000000C
.text$mn:0000000C ; void __thiscall VerticalFileSwitcher::activateDoc(VerticalFileSwitcher *this, struct TaskLstFnStatus *)
.text$mn:0000000C                 public ?activateDoc@VerticalFileSwitcher@@QBEXPAUTaskLstFnStatus@@@Z
.text$mn:0000000C ?activateDoc@VerticalFileSwitcher@@QBEXPAUTaskLstFnStatus@@@Z proc near
.text$mn:0000000C                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+1D4p
.text$mn:0000000C                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+27Ep ...
.text$mn:0000000C
.text$mn:0000000C var_20          = dword ptr -20h
.text$mn:0000000C var_1C          = dword ptr -1Ch
.text$mn:0000000C var_18          = dword ptr -18h
.text$mn:0000000C var_14          = dword ptr -14h
.text$mn:0000000C var_10          = dword ptr -10h
.text$mn:0000000C wParam          = dword ptr -0Ch
.text$mn:0000000C lParam          = dword ptr -8
.text$mn:0000000C var_4           = dword ptr -4
.text$mn:0000000C arg_0           = dword ptr  8
.text$mn:0000000C
.text$mn:0000000C                 push    ebp
.text$mn:0000000D                 mov     ebp, esp
.text$mn:0000000F                 sub     esp, 20h
.text$mn:00000012                 mov     [ebp+var_4], ecx
.text$mn:00000015                 mov     eax, [ebp+arg_0]
.text$mn:00000018                 mov     ecx, [eax]
.text$mn:0000001A                 mov     [ebp+lParam], ecx
.text$mn:0000001D                 mov     edx, [ebp+arg_0]
.text$mn:00000020                 mov     eax, [edx+28h]
.text$mn:00000023                 mov     [ebp+wParam], eax
.text$mn:00000026                 push    0               ; lParam
.text$mn:00000028                 push    0               ; wParam
.text$mn:0000002A                 push    840h            ; Msg
.text$mn:0000002F                 mov     ecx, [ebp+var_4]
.text$mn:00000032                 mov     edx, [ecx+8]
.text$mn:00000035                 push    edx             ; hWnd
.text$mn:00000036                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000003C                 mov     [ebp+var_18], eax
.text$mn:0000003F                 push    0               ; lParam
.text$mn:00000041                 push    0               ; wParam
.text$mn:00000043                 push    824h            ; Msg
.text$mn:00000048                 mov     eax, [ebp+var_4]
.text$mn:0000004B                 mov     ecx, [eax+8]
.text$mn:0000004E                 push    ecx             ; hWnd
.text$mn:0000004F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000055                 mov     [ebp+var_14], eax
.text$mn:00000058                 mov     edx, [ebp+wParam]
.text$mn:0000005B                 cmp     edx, [ebp+var_14]
.text$mn:0000005E                 jnz     short loc_6A
.text$mn:00000060                 mov     eax, [ebp+lParam]
.text$mn:00000063                 cmp     eax, [ebp+var_18]
.text$mn:00000066                 jnz     short loc_6A
.text$mn:00000068                 jmp     short loc_B6
.text$mn:0000006A ; ---------------------------------------------------------------------------
.text$mn:0000006A
.text$mn:0000006A loc_6A:                                 ; CODE XREF: VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)+52j
.text$mn:0000006A                                         ; VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)+5Aj
.text$mn:0000006A                 mov     ecx, [ebp+lParam]
.text$mn:0000006D                 push    ecx             ; lParam
.text$mn:0000006E                 mov     edx, [ebp+wParam]
.text$mn:00000071                 push    edx             ; wParam
.text$mn:00000072                 push    821h            ; Msg
.text$mn:00000077                 mov     eax, [ebp+var_4]
.text$mn:0000007A                 mov     ecx, [eax+8]
.text$mn:0000007D                 push    ecx             ; hWnd
.text$mn:0000007E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000084                 mov     [ebp+var_10], eax
.text$mn:00000087                 mov     edx, [ebp+var_10]
.text$mn:0000008A                 sar     edx, 1Eh
.text$mn:0000008D                 mov     [ebp+var_20], edx
.text$mn:00000090                 mov     eax, [ebp+var_10]
.text$mn:00000093                 shl     eax, 2
.text$mn:00000096                 sar     eax, 2
.text$mn:00000099                 mov     [ebp+var_1C], eax
.text$mn:0000009C                 mov     ecx, [ebp+var_1C]
.text$mn:0000009F                 push    ecx             ; lParam
.text$mn:000000A0                 mov     edx, [ebp+var_20]
.text$mn:000000A3                 push    edx             ; wParam
.text$mn:000000A4                 push    804h            ; Msg
.text$mn:000000A9                 mov     eax, [ebp+var_4]
.text$mn:000000AC                 mov     ecx, [eax+8]
.text$mn:000000AF                 push    ecx             ; hWnd
.text$mn:000000B0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000000B6
.text$mn:000000B6 loc_B6:                                 ; CODE XREF: VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)+5Cj
.text$mn:000000B6                 mov     esp, ebp
.text$mn:000000B8                 pop     ebp
.text$mn:000000B9                 retn    4
.text$mn:000000B9 ?activateDoc@VerticalFileSwitcher@@QBEXPAUTaskLstFnStatus@@@Z endp
.text$mn:000000B9
.text$mn:000000BC
.text$mn:000000BC ; =============== S U B R O U T I N E =======================================
.text$mn:000000BC
.text$mn:000000BC ; Attributes: bp-based frame
.text$mn:000000BC
.text$mn:000000BC ; int __thiscall VerticalFileSwitcher::setHeaderOrder(VerticalFileSwitcher *this, struct tagNMLISTVIEW *)
.text$mn:000000BC                 public ?setHeaderOrder@VerticalFileSwitcher@@QAEHPAUtagNMLISTVIEW@@@Z
.text$mn:000000BC ?setHeaderOrder@VerticalFileSwitcher@@QAEHPAUtagNMLISTVIEW@@@Z proc near
.text$mn:000000BC                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+33Fp
.text$mn:000000BC
.text$mn:000000BC lParam          = dword ptr -38h
.text$mn:000000BC var_34          = dword ptr -34h
.text$mn:000000BC var_18          = dword ptr -18h
.text$mn:000000BC var_14          = dword ptr -14h
.text$mn:000000BC var_10          = dword ptr -10h
.text$mn:000000BC wParam          = dword ptr -0Ch
.text$mn:000000BC var_8           = dword ptr -8
.text$mn:000000BC hWnd            = dword ptr -4
.text$mn:000000BC arg_0           = dword ptr  8
.text$mn:000000BC
.text$mn:000000BC                 push    ebp
.text$mn:000000BD                 mov     ebp, esp
.text$mn:000000BF                 sub     esp, 38h
.text$mn:000000C2                 mov     [ebp+var_18], ecx
.text$mn:000000C5                 mov     eax, [ebp+arg_0]
.text$mn:000000C8                 mov     ecx, [eax+10h]
.text$mn:000000CB                 mov     [ebp+wParam], ecx
.text$mn:000000CE                 mov     [ebp+lParam], 1
.text$mn:000000D5                 mov     edx, [ebp+arg_0]
.text$mn:000000D8                 mov     eax, [edx]
.text$mn:000000DA                 mov     [ebp+hWnd], eax
.text$mn:000000DD                 lea     ecx, [ebp+lParam]
.text$mn:000000E0                 push    ecx             ; lParam
.text$mn:000000E1                 mov     edx, [ebp+wParam]
.text$mn:000000E4                 push    edx             ; wParam
.text$mn:000000E5                 push    105Fh           ; Msg
.text$mn:000000EA                 mov     eax, [ebp+hWnd]
.text$mn:000000ED                 push    eax             ; hWnd
.text$mn:000000EE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000000F4                 mov     ecx, [ebp+var_34]
.text$mn:000000F7                 and     ecx, 400h
.text$mn:000000FD                 jz      short loc_132
.text$mn:000000FF                 mov     edx, [ebp+var_34]
.text$mn:00000102                 and     edx, 0FFFFFBFFh
.text$mn:00000108                 or      edx, 200h
.text$mn:0000010E                 mov     [ebp+var_34], edx
.text$mn:00000111                 lea     eax, [ebp+lParam]
.text$mn:00000114                 push    eax             ; lParam
.text$mn:00000115                 mov     ecx, [ebp+wParam]
.text$mn:00000118                 push    ecx             ; wParam
.text$mn:00000119                 push    1060h           ; Msg
.text$mn:0000011E                 mov     edx, [ebp+hWnd]
.text$mn:00000121                 push    edx             ; hWnd
.text$mn:00000122                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000128                 mov     eax, 1
.text$mn:0000012D                 jmp     loc_22E
.text$mn:00000132 ; ---------------------------------------------------------------------------
.text$mn:00000132
.text$mn:00000132 loc_132:                                ; CODE XREF: VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)+41j
.text$mn:00000132                 mov     eax, [ebp+var_34]
.text$mn:00000135                 and     eax, 200h
.text$mn:0000013A                 jz      short loc_16C
.text$mn:0000013C                 mov     ecx, [ebp+var_34]
.text$mn:0000013F                 and     ecx, 0FFFFFDFFh
.text$mn:00000145                 or      ecx, 400h
.text$mn:0000014B                 mov     [ebp+var_34], ecx
.text$mn:0000014E                 lea     edx, [ebp+lParam]
.text$mn:00000151                 push    edx             ; lParam
.text$mn:00000152                 mov     eax, [ebp+wParam]
.text$mn:00000155                 push    eax             ; wParam
.text$mn:00000156                 push    1060h           ; Msg
.text$mn:0000015B                 mov     ecx, [ebp+hWnd]
.text$mn:0000015E                 push    ecx             ; hWnd
.text$mn:0000015F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000165                 xor     eax, eax
.text$mn:00000167                 jmp     loc_22E
.text$mn:0000016C ; ---------------------------------------------------------------------------
.text$mn:0000016C
.text$mn:0000016C loc_16C:                                ; CODE XREF: VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)+7Ej
.text$mn:0000016C                 push    0               ; lParam
.text$mn:0000016E                 push    0               ; wParam
.text$mn:00000170                 push    101Fh           ; Msg
.text$mn:00000175                 mov     edx, [ebp+hWnd]
.text$mn:00000178                 push    edx             ; hWnd
.text$mn:00000179                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000017F                 mov     [ebp+var_10], eax
.text$mn:00000182                 push    0               ; lParam
.text$mn:00000184                 push    0               ; wParam
.text$mn:00000186                 push    1200h           ; Msg
.text$mn:0000018B                 mov     eax, [ebp+var_10]
.text$mn:0000018E                 push    eax             ; hWnd
.text$mn:0000018F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000195                 mov     [ebp+var_14], eax
.text$mn:00000198                 mov     [ebp+var_8], 0
.text$mn:0000019F                 jmp     short loc_1AA
.text$mn:000001A1 ; ---------------------------------------------------------------------------
.text$mn:000001A1
.text$mn:000001A1 loc_1A1:                                ; CODE XREF: VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)+134j
.text$mn:000001A1                 mov     ecx, [ebp+var_8]
.text$mn:000001A4                 add     ecx, 1
.text$mn:000001A7                 mov     [ebp+var_8], ecx
.text$mn:000001AA
.text$mn:000001AA loc_1AA:                                ; CODE XREF: VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)+E3j
.text$mn:000001AA                 mov     edx, [ebp+var_8]
.text$mn:000001AD                 cmp     edx, [ebp+var_14]
.text$mn:000001B0                 jge     short loc_1F2
.text$mn:000001B2                 lea     eax, [ebp+lParam]
.text$mn:000001B5                 push    eax             ; lParam
.text$mn:000001B6                 mov     ecx, [ebp+var_8]
.text$mn:000001B9                 push    ecx             ; wParam
.text$mn:000001BA                 push    105Fh           ; Msg
.text$mn:000001BF                 mov     edx, [ebp+hWnd]
.text$mn:000001C2                 push    edx             ; hWnd
.text$mn:000001C3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001C9                 mov     eax, [ebp+var_34]
.text$mn:000001CC                 and     eax, 0FFFFFBFFh
.text$mn:000001D1                 and     eax, 0FFFFFDFFh
.text$mn:000001D6                 mov     [ebp+var_34], eax
.text$mn:000001D9                 lea     ecx, [ebp+lParam]
.text$mn:000001DC                 push    ecx             ; lParam
.text$mn:000001DD                 mov     edx, [ebp+var_8]
.text$mn:000001E0                 push    edx             ; wParam
.text$mn:000001E1                 push    1060h           ; Msg
.text$mn:000001E6                 mov     eax, [ebp+hWnd]
.text$mn:000001E9                 push    eax             ; hWnd
.text$mn:000001EA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000001F0                 jmp     short loc_1A1
.text$mn:000001F2 ; ---------------------------------------------------------------------------
.text$mn:000001F2
.text$mn:000001F2 loc_1F2:                                ; CODE XREF: VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)+F4j
.text$mn:000001F2                 lea     ecx, [ebp+lParam]
.text$mn:000001F5                 push    ecx             ; lParam
.text$mn:000001F6                 mov     edx, [ebp+wParam]
.text$mn:000001F9                 push    edx             ; wParam
.text$mn:000001FA                 push    105Fh           ; Msg
.text$mn:000001FF                 mov     eax, [ebp+hWnd]
.text$mn:00000202                 push    eax             ; hWnd
.text$mn:00000203                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000209                 mov     ecx, [ebp+var_34]
.text$mn:0000020C                 or      ecx, 400h
.text$mn:00000212                 mov     [ebp+var_34], ecx
.text$mn:00000215                 lea     edx, [ebp+lParam]
.text$mn:00000218                 push    edx             ; lParam
.text$mn:00000219                 mov     eax, [ebp+wParam]
.text$mn:0000021C                 push    eax             ; wParam
.text$mn:0000021D                 push    1060h           ; Msg
.text$mn:00000222                 mov     ecx, [ebp+hWnd]
.text$mn:00000225                 push    ecx             ; hWnd
.text$mn:00000226                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000022C                 xor     eax, eax
.text$mn:0000022E
.text$mn:0000022E loc_22E:                                ; CODE XREF: VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)+71j
.text$mn:0000022E                                         ; VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)+ABj
.text$mn:0000022E                 mov     esp, ebp
.text$mn:00000230                 pop     ebp
.text$mn:00000231                 retn    4
.text$mn:00000231 ?setHeaderOrder@VerticalFileSwitcher@@QAEHPAUtagNMLISTVIEW@@@Z endp
.text$mn:00000231
.text$mn:00000231 ; ---------------------------------------------------------------------------
.text$mn:00000234                 db 8 dup(0CCh)
.text$mn:0000023C
.text$mn:0000023C ; =============== S U B R O U T I N E =======================================
.text$mn:0000023C
.text$mn:0000023C ; Attributes: bp-based frame
.text$mn:0000023C
.text$mn:0000023C ; int __stdcall VerticalFileSwitcher::run_dlgProc(VerticalFileSwitcher *this, unsigned int, unsigned int, __int32)
.text$mn:0000023C                 public ?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z
.text$mn:0000023C ?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z proc near
.text$mn:0000023C
.text$mn:0000023C var_128         = dword ptr -128h
.text$mn:0000023C var_124         = dword ptr -124h
.text$mn:0000023C var_108         = dword ptr -108h
.text$mn:0000023C var_F4          = dword ptr -0F4h
.text$mn:0000023C var_F0          = dword ptr -0F0h
.text$mn:0000023C var_D4          = dword ptr -0D4h
.text$mn:0000023C lParam          = dword ptr -0C0h
.text$mn:0000023C var_BC          = dword ptr -0BCh
.text$mn:0000023C var_A0          = dword ptr -0A0h
.text$mn:0000023C var_8C          = dword ptr -8Ch
.text$mn:0000023C var_88          = dword ptr -88h
.text$mn:0000023C var_84          = dword ptr -84h
.text$mn:0000023C var_80          = dword ptr -80h
.text$mn:0000023C var_7C          = dword ptr -7Ch
.text$mn:0000023C hWnd            = dword ptr -78h
.text$mn:0000023C wParam          = dword ptr -74h
.text$mn:0000023C var_70          = dword ptr -70h
.text$mn:0000023C var_6C          = dword ptr -6Ch
.text$mn:0000023C nHeight         = dword ptr -68h
.text$mn:0000023C var_64          = dword ptr -64h
.text$mn:0000023C var_60          = dword ptr -60h
.text$mn:0000023C var_5C          = dword ptr -5Ch
.text$mn:0000023C var_58          = dword ptr -58h
.text$mn:0000023C var_54          = dword ptr -54h
.text$mn:0000023C var_50          = dword ptr -50h
.text$mn:0000023C nWidth          = dword ptr -4Ch
.text$mn:0000023C var_48          = dword ptr -48h
.text$mn:0000023C var_44          = dword ptr -44h
.text$mn:0000023C var_40          = dword ptr -40h
.text$mn:0000023C var_3C          = dword ptr -3Ch
.text$mn:0000023C var_38          = dword ptr -38h
.text$mn:0000023C var_34          = dword ptr -34h
.text$mn:0000023C var_30          = dword ptr -30h
.text$mn:0000023C var_2C          = byte ptr -2Ch
.text$mn:0000023C var_10          = dword ptr -10h
.text$mn:0000023C var_C           = dword ptr -0Ch
.text$mn:0000023C var_4           = dword ptr -4
.text$mn:0000023C this            = dword ptr  8
.text$mn:0000023C arg_4           = dword ptr  0Ch
.text$mn:0000023C arg_8           = dword ptr  10h
.text$mn:0000023C arg_C           = dword ptr  14h
.text$mn:0000023C
.text$mn:0000023C                 push    ebp
.text$mn:0000023D                 mov     ebp, esp
.text$mn:0000023F                 push    0FFFFFFFFh
.text$mn:00000241                 push    offset __ehhandler$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z
.text$mn:00000246                 mov     eax, large fs:0
.text$mn:0000024C                 push    eax
.text$mn:0000024D                 sub     esp, 11Ch
.text$mn:00000253                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000258                 xor     eax, ebp
.text$mn:0000025A                 mov     [ebp+var_10], eax
.text$mn:0000025D                 push    eax
.text$mn:0000025E                 lea     eax, [ebp+var_C]
.text$mn:00000261                 mov     large fs:0, eax
.text$mn:00000267                 mov     eax, [ebp+arg_4]
.text$mn:0000026A                 mov     [ebp+var_30], eax
.text$mn:0000026D                 cmp     [ebp+var_30], 4Eh ; 'N'
.text$mn:00000271                 ja      short loc_292
.text$mn:00000273                 cmp     [ebp+var_30], 4Eh ; 'N'
.text$mn:00000277                 jz      short loc_2F1
.text$mn:00000279                 cmp     [ebp+var_30], 2
.text$mn:0000027D                 jz      loc_68C
.text$mn:00000283                 cmp     [ebp+var_30], 5
.text$mn:00000287                 jz      loc_63A
.text$mn:0000028D                 jmp     loc_69F
.text$mn:00000292 ; ---------------------------------------------------------------------------
.text$mn:00000292
.text$mn:00000292 loc_292:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+35j
.text$mn:00000292                 cmp     [ebp+var_30], 110h
.text$mn:00000299                 jz      short loc_2A0
.text$mn:0000029B                 jmp     loc_69F
.text$mn:000002A0 ; ---------------------------------------------------------------------------
.text$mn:000002A0
.text$mn:000002A0 loc_2A0:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+5Dj
.text$mn:000002A0                 mov     ecx, [ebp+this]
.text$mn:000002A3                 mov     edx, [ecx+84h]
.text$mn:000002A9                 push    edx
.text$mn:000002AA                 mov     eax, [ebp+this]
.text$mn:000002AD                 mov     ecx, [eax+0Ch]
.text$mn:000002B0                 push    ecx
.text$mn:000002B1                 mov     edx, [ebp+this]
.text$mn:000002B4                 mov     eax, [edx+4]
.text$mn:000002B7                 push    eax
.text$mn:000002B8                 mov     ecx, [ebp+this]
.text$mn:000002BB                 add     ecx, 6Ch ; 'l'
.text$mn:000002BE                 mov     edx, [ebp+this]
.text$mn:000002C1                 mov     eax, [edx+6Ch]
.text$mn:000002C4                 mov     edx, [eax+30h]
.text$mn:000002C7                 call    edx
.text$mn:000002C9                 mov     ecx, [ebp+this]
.text$mn:000002CC                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:000002CF                 call    ?initList@VerticalFileSwitcherListView@@QAEXXZ ; VerticalFileSwitcherListView::initList(void)
.text$mn:000002D4                 push    1
.text$mn:000002D6                 mov     ecx, [ebp+this]
.text$mn:000002D9                 add     ecx, 6Ch ; 'l'
.text$mn:000002DC                 mov     eax, [ebp+this]
.text$mn:000002DF                 mov     edx, [eax+6Ch]
.text$mn:000002E2                 mov     eax, [edx+0Ch]
.text$mn:000002E5                 call    eax
.text$mn:000002E7                 mov     eax, 1
.text$mn:000002EC                 jmp     loc_6CB
.text$mn:000002F1 ; ---------------------------------------------------------------------------
.text$mn:000002F1
.text$mn:000002F1 loc_2F1:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+3Bj
.text$mn:000002F1                 mov     ecx, [ebp+arg_C]
.text$mn:000002F4                 mov     edx, [ecx+8]
.text$mn:000002F7                 mov     [ebp+var_34], edx
.text$mn:000002FA                 mov     eax, [ebp+var_34]
.text$mn:000002FD                 add     eax, 9Eh ; 'P'
.text$mn:00000302                 mov     [ebp+var_34], eax
.text$mn:00000305                 cmp     [ebp+var_34], 9Ch ; '£'
.text$mn:0000030C                 ja      $LN25
.text$mn:00000312                 mov     ecx, [ebp+var_34]
.text$mn:00000315                 movzx   edx, ds:$LN35[ecx]
.text$mn:0000031C                 jmp     ds:$LN37[edx*4]
.text$mn:00000323 ; ---------------------------------------------------------------------------
.text$mn:00000323
.text$mn:00000323 $LN24:                                  ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0j
.text$mn:00000323                                         ; DATA XREF: .text$mn:000006F8o
.text$mn:00000323                 mov     eax, [ebp+arg_C]
.text$mn:00000326                 mov     [ebp+var_88], eax
.text$mn:0000032C                 mov     ecx, [ebp+var_88]
.text$mn:00000332                 mov     edx, [ecx+0Ch]
.text$mn:00000335                 mov     [ebp+var_80], edx
.text$mn:00000338                 cmp     [ebp+var_80], 0FFFFFFFFh
.text$mn:0000033C                 jnz     short loc_357
.text$mn:0000033E                 push    0               ; lParam
.text$mn:00000340                 push    0A029h          ; wParam
.text$mn:00000345                 push    111h            ; Msg
.text$mn:0000034A                 mov     eax, [ebp+this]
.text$mn:0000034D                 mov     ecx, [eax+8]
.text$mn:00000350                 push    ecx             ; hWnd
.text$mn:00000351                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000357
.text$mn:00000357 loc_357:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+100j
.text$mn:00000357                 mov     eax, 1
.text$mn:0000035C                 jmp     loc_6CB
.text$mn:00000361 ; ---------------------------------------------------------------------------
.text$mn:00000361
.text$mn:00000361 $LN22:                                  ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0j
.text$mn:00000361                                         ; DATA XREF: .text$mn:000006FCo
.text$mn:00000361                 push    11h             ; nVirtKey
.text$mn:00000363                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:00000369                 movsx   edx, ax
.text$mn:0000036C                 and     edx, 80h
.text$mn:00000372                 jnz     short loc_384
.text$mn:00000374                 push    10h             ; nVirtKey
.text$mn:00000376                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:0000037C                 cwde
.text$mn:0000037D                 and     eax, 80h
.text$mn:00000382                 jz      short loc_38E
.text$mn:00000384
.text$mn:00000384 loc_384:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+136j
.text$mn:00000384                 mov     eax, 1
.text$mn:00000389                 jmp     loc_6CB
.text$mn:0000038E ; ---------------------------------------------------------------------------
.text$mn:0000038E
.text$mn:0000038E loc_38E:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+146j
.text$mn:0000038E                 mov     ecx, [ebp+arg_C]
.text$mn:00000391                 mov     [ebp+var_5C], ecx
.text$mn:00000394                 push    0               ; lParam
.text$mn:00000396                 push    0               ; wParam
.text$mn:00000398                 push    1004h           ; Msg
.text$mn:0000039D                 mov     ecx, [ebp+this]
.text$mn:000003A0                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:000003A3                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000003A8                 push    eax             ; hWnd
.text$mn:000003A9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000003AF                 mov     [ebp+var_54], eax
.text$mn:000003B2                 mov     edx, [ebp+var_5C]
.text$mn:000003B5                 mov     eax, [edx+0Ch]
.text$mn:000003B8                 mov     [ebp+var_44], eax
.text$mn:000003BB                 cmp     [ebp+var_44], 0FFFFFFFFh
.text$mn:000003BF                 jz      short loc_3C9
.text$mn:000003C1                 mov     ecx, [ebp+var_44]
.text$mn:000003C4                 cmp     ecx, [ebp+var_54]
.text$mn:000003C7                 jl      short loc_3D3
.text$mn:000003C9
.text$mn:000003C9 loc_3C9:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+183j
.text$mn:000003C9                 mov     eax, 1
.text$mn:000003CE                 jmp     loc_6CB
.text$mn:000003D3 ; ---------------------------------------------------------------------------
.text$mn:000003D3
.text$mn:000003D3 loc_3D3:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+18Bj
.text$mn:000003D3                 mov     [ebp+lParam], 4
.text$mn:000003DD                 mov     edx, [ebp+var_44]
.text$mn:000003E0                 mov     [ebp+var_BC], edx
.text$mn:000003E6                 lea     eax, [ebp+lParam]
.text$mn:000003EC                 push    eax             ; lParam
.text$mn:000003ED                 push    0               ; wParam
.text$mn:000003EF                 push    104Bh           ; Msg
.text$mn:000003F4                 mov     ecx, [ebp+arg_C]
.text$mn:000003F7                 mov     edx, [ecx]
.text$mn:000003F9                 push    edx             ; hWnd
.text$mn:000003FA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000400                 mov     eax, [ebp+var_A0]
.text$mn:00000406                 mov     [ebp+var_64], eax
.text$mn:00000409                 mov     ecx, [ebp+var_64]
.text$mn:0000040C                 push    ecx             ; struct TaskLstFnStatus *
.text$mn:0000040D                 mov     ecx, [ebp+this] ; this
.text$mn:00000410                 call    ?activateDoc@VerticalFileSwitcher@@QBEXPAUTaskLstFnStatus@@@Z ; VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)
.text$mn:00000415                 mov     eax, 1
.text$mn:0000041A                 jmp     loc_6CB
.text$mn:0000041F ; ---------------------------------------------------------------------------
.text$mn:0000041F
.text$mn:0000041F $LN17_0:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0j
.text$mn:0000041F                                         ; DATA XREF: .text$mn:000006F4o
.text$mn:0000041F                 mov     edx, [ebp+arg_C]
.text$mn:00000422                 mov     [ebp+var_84], edx
.text$mn:00000428                 push    0               ; lParam
.text$mn:0000042A                 push    0               ; wParam
.text$mn:0000042C                 push    1004h           ; Msg
.text$mn:00000431                 mov     ecx, [ebp+this]
.text$mn:00000434                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:00000437                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000043C                 push    eax             ; hWnd
.text$mn:0000043D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000443                 mov     [ebp+var_6C], eax
.text$mn:00000446                 mov     ecx, [ebp+this] ; this
.text$mn:00000449                 call    ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ ; VerticalFileSwitcher::nbSelectedFiles(void)
.text$mn:0000044E                 cmp     eax, 1
.text$mn:00000451                 jnz     short loc_4BF
.text$mn:00000453                 mov     eax, [ebp+var_84]
.text$mn:00000459                 mov     ecx, [eax+0Ch]
.text$mn:0000045C                 mov     [ebp+var_40], ecx
.text$mn:0000045F                 cmp     [ebp+var_40], 0FFFFFFFFh
.text$mn:00000463                 jz      short loc_46D
.text$mn:00000465                 mov     edx, [ebp+var_40]
.text$mn:00000468                 cmp     edx, [ebp+var_6C]
.text$mn:0000046B                 jl      short loc_477
.text$mn:0000046D
.text$mn:0000046D loc_46D:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+227j
.text$mn:0000046D                 mov     eax, 1
.text$mn:00000472                 jmp     loc_6CB
.text$mn:00000477 ; ---------------------------------------------------------------------------
.text$mn:00000477
.text$mn:00000477 loc_477:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+22Fj
.text$mn:00000477                 mov     [ebp+var_F4], 4
.text$mn:00000481                 mov     eax, [ebp+var_40]
.text$mn:00000484                 mov     [ebp+var_F0], eax
.text$mn:0000048A                 lea     ecx, [ebp+var_F4]
.text$mn:00000490                 push    ecx             ; lParam
.text$mn:00000491                 push    0               ; wParam
.text$mn:00000493                 push    104Bh           ; Msg
.text$mn:00000498                 mov     edx, [ebp+arg_C]
.text$mn:0000049B                 mov     eax, [edx]
.text$mn:0000049D                 push    eax             ; hWnd
.text$mn:0000049E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000004A4                 mov     ecx, [ebp+var_D4]
.text$mn:000004AA                 mov     [ebp+var_8C], ecx
.text$mn:000004B0                 mov     edx, [ebp+var_8C]
.text$mn:000004B6                 push    edx             ; struct TaskLstFnStatus *
.text$mn:000004B7                 mov     ecx, [ebp+this] ; this
.text$mn:000004BA                 call    ?activateDoc@VerticalFileSwitcher@@QBEXPAUTaskLstFnStatus@@@Z ; VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)
.text$mn:000004BF
.text$mn:000004BF loc_4BF:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+215j
.text$mn:000004BF                 mov     [ebp+var_70], 0FFFFFFFBh
.text$mn:000004C6                 mov     eax, [ebp+this]
.text$mn:000004C9                 mov     ecx, [eax+0Ch]
.text$mn:000004CC                 mov     [ebp+hWnd], ecx
.text$mn:000004CF                 mov     edx, [ebp+hWnd]
.text$mn:000004D2                 push    edx             ; hWnd
.text$mn:000004D3                 call    dword ptr ds:__imp__GetDlgCtrlID@4 ; GetDlgCtrlID(x)
.text$mn:000004D9                 mov     [ebp+wParam], eax
.text$mn:000004DC                 lea     eax, [ebp+hWnd]
.text$mn:000004DF                 push    eax             ; lParam
.text$mn:000004E0                 mov     ecx, [ebp+wParam]
.text$mn:000004E3                 push    ecx             ; wParam
.text$mn:000004E4                 push    4Eh ; 'N'       ; Msg
.text$mn:000004E6                 mov     edx, [ebp+this]
.text$mn:000004E9                 mov     eax, [edx+8]
.text$mn:000004EC                 push    eax             ; hWnd
.text$mn:000004ED                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000004F3                 mov     eax, 1
.text$mn:000004F8                 jmp     loc_6CB
.text$mn:000004FD ; ---------------------------------------------------------------------------
.text$mn:000004FD
.text$mn:000004FD $LN13:                                  ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0j
.text$mn:000004FD                                         ; DATA XREF: .text$mn:$LN37o
.text$mn:000004FD                 mov     ecx, [ebp+arg_C]
.text$mn:00000500                 mov     [ebp+var_38], ecx
.text$mn:00000503                 mov     edx, [ebp+var_38]
.text$mn:00000506                 mov     eax, [edx+18h]
.text$mn:00000509                 mov     [ebp+var_48], eax
.text$mn:0000050C                 cmp     [ebp+var_48], 0FFFFFFFFh
.text$mn:00000510                 jnz     short loc_51C
.text$mn:00000512                 mov     eax, 1
.text$mn:00000517                 jmp     loc_6CB
.text$mn:0000051C ; ---------------------------------------------------------------------------
.text$mn:0000051C
.text$mn:0000051C loc_51C:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+2D4j
.text$mn:0000051C                 mov     ecx, [ebp+var_48]
.text$mn:0000051F                 push    ecx
.text$mn:00000520                 lea     edx, [ebp+var_2C]
.text$mn:00000523                 push    edx
.text$mn:00000524                 mov     ecx, [ebp+this]
.text$mn:00000527                 call    ?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; VerticalFileSwitcher::getFullFilePath(uint)
.text$mn:0000052C                 mov     [ebp+var_4], 0
.text$mn:00000533                 mov     eax, [ebp+var_38]
.text$mn:00000536                 mov     ecx, [eax+14h]
.text$mn:00000539                 push    ecx             ; iMaxLength
.text$mn:0000053A                 lea     ecx, [ebp+var_2C]
.text$mn:0000053D                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000542                 push    eax             ; lpString2
.text$mn:00000543                 mov     edx, [ebp+var_38]
.text$mn:00000546                 mov     eax, [edx+10h]
.text$mn:00000549                 push    eax             ; lpString1
.text$mn:0000054A                 call    dword ptr ds:__imp__lstrcpynW@12 ; lstrcpynW(x,x,x)
.text$mn:00000550                 mov     [ebp+var_7C], 1
.text$mn:00000557                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000055E                 lea     ecx, [ebp+var_2C]
.text$mn:00000561                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000566                 mov     eax, [ebp+var_7C]
.text$mn:00000569                 jmp     loc_6CB
.text$mn:0000056E ; ---------------------------------------------------------------------------
.text$mn:0000056E
.text$mn:0000056E $LN11:                                  ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0j
.text$mn:0000056E                                         ; DATA XREF: .text$mn:000006F0o
.text$mn:0000056E                 mov     ecx, [ebp+arg_C]
.text$mn:00000571                 mov     [ebp+var_3C], ecx
.text$mn:00000574                 mov     edx, [ebp+var_3C]
.text$mn:00000577                 push    edx             ; struct tagNMLISTVIEW *
.text$mn:00000578                 mov     ecx, [ebp+this] ; this
.text$mn:0000057B                 call    ?setHeaderOrder@VerticalFileSwitcher@@QAEHPAUtagNMLISTVIEW@@@Z ; VerticalFileSwitcher::setHeaderOrder(tagNMLISTVIEW *)
.text$mn:00000580                 push    offset ?ListViewCompareProc@@YGHJJJ@Z ; lParam
.text$mn:00000585                 mov     eax, [ebp+var_3C]
.text$mn:00000588                 push    eax             ; wParam
.text$mn:00000589                 push    1051h           ; Msg
.text$mn:0000058E                 mov     ecx, [ebp+var_3C]
.text$mn:00000591                 mov     edx, [ecx]
.text$mn:00000593                 push    edx             ; hWnd
.text$mn:00000594                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000059A                 mov     eax, 1
.text$mn:0000059F                 jmp     loc_6CB
.text$mn:000005A4 ; ---------------------------------------------------------------------------
.text$mn:000005A4
.text$mn:000005A4 $LN10:                                  ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0j
.text$mn:000005A4                                         ; DATA XREF: .text$mn:000006ECo
.text$mn:000005A4                 mov     eax, [ebp+arg_C]
.text$mn:000005A7                 movzx   ecx, word ptr [eax+0Ch]
.text$mn:000005AB                 mov     [ebp+var_58], ecx
.text$mn:000005AE                 cmp     [ebp+var_58], 0Dh
.text$mn:000005B2                 jz      short loc_5B6
.text$mn:000005B4                 jmp     short $LN25
.text$mn:000005B6 ; ---------------------------------------------------------------------------
.text$mn:000005B6
.text$mn:000005B6 loc_5B6:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+376j
.text$mn:000005B6                 push    0               ; lParam
.text$mn:000005B8                 push    0               ; wParam
.text$mn:000005BA                 push    1042h           ; Msg
.text$mn:000005BF                 mov     ecx, [ebp+this]
.text$mn:000005C2                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:000005C5                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000005CA                 push    eax             ; hWnd
.text$mn:000005CB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000005D1                 mov     [ebp+var_50], eax
.text$mn:000005D4                 cmp     [ebp+var_50], 0FFFFFFFFh
.text$mn:000005D8                 jnz     short loc_5E4
.text$mn:000005DA                 mov     eax, 1
.text$mn:000005DF                 jmp     loc_6CB
.text$mn:000005E4 ; ---------------------------------------------------------------------------
.text$mn:000005E4
.text$mn:000005E4 loc_5E4:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+39Cj
.text$mn:000005E4                 mov     [ebp+var_128], 4
.text$mn:000005EE                 mov     edx, [ebp+var_50]
.text$mn:000005F1                 mov     [ebp+var_124], edx
.text$mn:000005F7                 lea     eax, [ebp+var_128]
.text$mn:000005FD                 push    eax             ; lParam
.text$mn:000005FE                 push    0               ; wParam
.text$mn:00000600                 push    104Bh           ; Msg
.text$mn:00000605                 mov     ecx, [ebp+arg_C]
.text$mn:00000608                 mov     edx, [ecx]
.text$mn:0000060A                 push    edx             ; hWnd
.text$mn:0000060B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000611                 mov     eax, [ebp+var_108]
.text$mn:00000617                 mov     [ebp+var_60], eax
.text$mn:0000061A                 mov     ecx, [ebp+var_60]
.text$mn:0000061D                 push    ecx             ; struct TaskLstFnStatus *
.text$mn:0000061E                 mov     ecx, [ebp+this] ; this
.text$mn:00000621                 call    ?activateDoc@VerticalFileSwitcher@@QBEXPAUTaskLstFnStatus@@@Z ; VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)
.text$mn:00000626                 mov     eax, 1
.text$mn:0000062B                 jmp     loc_6CB
.text$mn:00000630 ; ---------------------------------------------------------------------------
.text$mn:00000630
.text$mn:00000630 $LN25:                                  ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+D0j
.text$mn:00000630                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0j ...
.text$mn:00000630                 mov     eax, 1
.text$mn:00000635                 jmp     loc_6CB
.text$mn:0000063A ; ---------------------------------------------------------------------------
.text$mn:0000063A
.text$mn:0000063A loc_63A:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+4Bj
.text$mn:0000063A                 mov     edx, [ebp+arg_C]
.text$mn:0000063D                 and     edx, 0FFFFh
.text$mn:00000643                 movzx   eax, dx
.text$mn:00000646                 mov     [ebp+nWidth], eax
.text$mn:00000649                 mov     ecx, [ebp+arg_C]
.text$mn:0000064C                 shr     ecx, 10h
.text$mn:0000064F                 and     ecx, 0FFFFh
.text$mn:00000655                 movzx   edx, cx
.text$mn:00000658                 mov     [ebp+nHeight], edx
.text$mn:0000065B                 push    1               ; bRepaint
.text$mn:0000065D                 mov     eax, [ebp+nHeight]
.text$mn:00000660                 push    eax             ; nHeight
.text$mn:00000661                 mov     ecx, [ebp+nWidth]
.text$mn:00000664                 push    ecx             ; nWidth
.text$mn:00000665                 push    0               ; Y
.text$mn:00000667                 push    0               ; X
.text$mn:00000669                 mov     ecx, [ebp+this]
.text$mn:0000066C                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:0000066F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000674                 push    eax             ; hWnd
.text$mn:00000675                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000067B                 mov     edx, [ebp+nWidth]
.text$mn:0000067E                 push    edx             ; int
.text$mn:0000067F                 mov     ecx, [ebp+this]
.text$mn:00000682                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:00000685                 call    ?resizeColumns@VerticalFileSwitcherListView@@QAEXH@Z ; VerticalFileSwitcherListView::resizeColumns(int)
.text$mn:0000068A                 jmp     short loc_6B6
.text$mn:0000068C ; ---------------------------------------------------------------------------
.text$mn:0000068C
.text$mn:0000068C loc_68C:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+41j
.text$mn:0000068C                 mov     ecx, [ebp+this]
.text$mn:0000068F                 add     ecx, 6Ch ; 'l'
.text$mn:00000692                 mov     eax, [ebp+this]
.text$mn:00000695                 mov     edx, [eax+6Ch]
.text$mn:00000698                 mov     eax, [edx+8]
.text$mn:0000069B                 call    eax
.text$mn:0000069D                 jmp     short loc_6B6
.text$mn:0000069F ; ---------------------------------------------------------------------------
.text$mn:0000069F
.text$mn:0000069F loc_69F:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+51j
.text$mn:0000069F                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+5Fj
.text$mn:0000069F                 mov     ecx, [ebp+arg_C]
.text$mn:000006A2                 push    ecx             ; __int32
.text$mn:000006A3                 mov     edx, [ebp+arg_8]
.text$mn:000006A6                 push    edx             ; unsigned int
.text$mn:000006A7                 mov     eax, [ebp+arg_4]
.text$mn:000006AA                 push    eax             ; unsigned int
.text$mn:000006AB                 mov     ecx, [ebp+this]
.text$mn:000006AE                 push    ecx             ; this
.text$mn:000006AF                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:000006B4                 jmp     short loc_6CB
.text$mn:000006B6 ; ---------------------------------------------------------------------------
.text$mn:000006B6
.text$mn:000006B6 loc_6B6:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+44Ej
.text$mn:000006B6                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+461j
.text$mn:000006B6                 mov     edx, [ebp+arg_C]
.text$mn:000006B9                 push    edx             ; __int32
.text$mn:000006BA                 mov     eax, [ebp+arg_8]
.text$mn:000006BD                 push    eax             ; unsigned int
.text$mn:000006BE                 mov     ecx, [ebp+arg_4]
.text$mn:000006C1                 push    ecx             ; unsigned int
.text$mn:000006C2                 mov     edx, [ebp+this]
.text$mn:000006C5                 push    edx             ; this
.text$mn:000006C6                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:000006CB
.text$mn:000006CB loc_6CB:                                ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+B0j
.text$mn:000006CB                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+120j ...
.text$mn:000006CB                 mov     ecx, [ebp+var_C]
.text$mn:000006CE                 mov     large fs:0, ecx
.text$mn:000006D5                 pop     ecx
.text$mn:000006D6                 mov     ecx, [ebp+var_10]
.text$mn:000006D9                 xor     ecx, ebp
.text$mn:000006DB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000006E0                 mov     esp, ebp
.text$mn:000006E2                 pop     ebp
.text$mn:000006E3                 retn    10h
.text$mn:000006E3 ?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z endp
.text$mn:000006E3
.text$mn:000006E3 ; ---------------------------------------------------------------------------
.text$mn:000006E6                 align 4
.text$mn:000006E8 $LN37           dd offset $LN13         ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+E0r
.text$mn:000006EC                 dd offset $LN10
.text$mn:000006F0                 dd offset $LN11
.text$mn:000006F4                 dd offset $LN17_0
.text$mn:000006F8                 dd offset $LN24
.text$mn:000006FC                 dd offset $LN22
.text$mn:00000700                 dd offset $LN25
.text$mn:00000704 $LN35           db 0                    ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+D9r
.text$mn:00000705                 db 2 dup(6), 1
.text$mn:00000708                 dd 0Bh dup(6060606h), 6020606h, 19h dup(6060606h), 4060306h
.text$mn:00000708                 dd 0CCCCCC05h, 2 dup(0CCCCCCCCh)
.text$mn:000007AC
.text$mn:000007AC ; =============== S U B R O U T I N E =======================================
.text$mn:000007AC
.text$mn:000007AC ; Attributes: bp-based frame
.text$mn:000007AC
.text$mn:000007AC ; int __stdcall ListViewCompareProc(WPARAM wParam, WPARAM, __int32)
.text$mn:000007AC                 public ?ListViewCompareProc@@YGHJJJ@Z
.text$mn:000007AC ?ListViewCompareProc@@YGHJJJ@Z proc near
.text$mn:000007AC                                         ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+344o
.text$mn:000007AC
.text$mn:000007AC var_4AC         = dword ptr -4ACh
.text$mn:000007AC var_4A4         = dword ptr -4A4h
.text$mn:000007AC var_498         = dword ptr -498h
.text$mn:000007AC var_494         = dword ptr -494h
.text$mn:000007AC lParam          = dword ptr -478h
.text$mn:000007AC var_470         = dword ptr -470h
.text$mn:000007AC var_464         = dword ptr -464h
.text$mn:000007AC var_460         = dword ptr -460h
.text$mn:000007AC var_444         = dword ptr -444h
.text$mn:000007AC var_440         = dword ptr -440h
.text$mn:000007AC var_424         = dword ptr -424h
.text$mn:000007AC var_420         = dword ptr -420h
.text$mn:000007AC var_41C         = dword ptr -41Ch
.text$mn:000007AC var_415         = byte ptr -415h
.text$mn:000007AC String1         = word ptr -414h
.text$mn:000007AC String2         = word ptr -20Ch
.text$mn:000007AC var_4           = dword ptr -4
.text$mn:000007AC wParam          = dword ptr  8
.text$mn:000007AC arg_4           = dword ptr  0Ch
.text$mn:000007AC arg_8           = dword ptr  10h
.text$mn:000007AC
.text$mn:000007AC                 push    ebp
.text$mn:000007AD                 mov     ebp, esp
.text$mn:000007AF                 sub     esp, 4ACh
.text$mn:000007B5                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000007BA                 xor     eax, ebp
.text$mn:000007BC                 mov     [ebp+var_4], eax
.text$mn:000007BF                 mov     eax, [ebp+arg_8]
.text$mn:000007C2                 mov     [ebp+var_41C], eax
.text$mn:000007C8                 mov     ecx, [ebp+var_41C]
.text$mn:000007CE                 mov     edx, [ecx+10h]
.text$mn:000007D1                 mov     [ebp+var_470], edx
.text$mn:000007D7                 mov     [ebp+var_460], 208h
.text$mn:000007E1                 lea     eax, [ebp+String1]
.text$mn:000007E7                 mov     [ebp+var_464], eax
.text$mn:000007ED                 lea     ecx, [ebp+lParam]
.text$mn:000007F3                 push    ecx             ; lParam
.text$mn:000007F4                 mov     edx, [ebp+wParam]
.text$mn:000007F7                 push    edx             ; wParam
.text$mn:000007F8                 push    1073h           ; Msg
.text$mn:000007FD                 mov     eax, [ebp+var_41C]
.text$mn:00000803                 mov     ecx, [eax]
.text$mn:00000805                 push    ecx             ; hWnd
.text$mn:00000806                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000080C                 mov     edx, [ebp+var_41C]
.text$mn:00000812                 mov     eax, [edx+10h]
.text$mn:00000815                 mov     [ebp+var_4A4], eax
.text$mn:0000081B                 mov     [ebp+var_494], 208h
.text$mn:00000825                 lea     ecx, [ebp+String2]
.text$mn:0000082B                 mov     [ebp+var_498], ecx
.text$mn:00000831                 lea     edx, [ebp+var_4AC]
.text$mn:00000837                 push    edx             ; lParam
.text$mn:00000838                 mov     eax, [ebp+arg_4]
.text$mn:0000083B                 push    eax             ; wParam
.text$mn:0000083C                 push    1073h           ; Msg
.text$mn:00000841                 mov     ecx, [ebp+var_41C]
.text$mn:00000847                 mov     edx, [ecx]
.text$mn:00000849                 push    edx             ; hWnd
.text$mn:0000084A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000850                 mov     [ebp+var_444], 1
.text$mn:0000085A                 lea     eax, [ebp+var_444]
.text$mn:00000860                 push    eax             ; lParam
.text$mn:00000861                 mov     ecx, [ebp+var_41C]
.text$mn:00000867                 mov     edx, [ecx+10h]
.text$mn:0000086A                 push    edx             ; wParam
.text$mn:0000086B                 push    105Fh           ; Msg
.text$mn:00000870                 mov     eax, [ebp+var_41C]
.text$mn:00000876                 mov     ecx, [eax]
.text$mn:00000878                 push    ecx             ; hWnd
.text$mn:00000879                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000087F                 mov     edx, [ebp+var_440]
.text$mn:00000885                 and     edx, 400h
.text$mn:0000088B                 jz      short loc_899
.text$mn:0000088D                 mov     [ebp+var_420], 1
.text$mn:00000897                 jmp     short loc_8A3
.text$mn:00000899 ; ---------------------------------------------------------------------------
.text$mn:00000899
.text$mn:00000899 loc_899:                                ; CODE XREF: ListViewCompareProc(long,long,long)+DFj
.text$mn:00000899                 mov     [ebp+var_420], 0
.text$mn:000008A3
.text$mn:000008A3 loc_8A3:                                ; CODE XREF: ListViewCompareProc(long,long,long)+EBj
.text$mn:000008A3                 mov     al, byte ptr [ebp+var_420]
.text$mn:000008A9                 mov     [ebp+var_415], al
.text$mn:000008AF                 lea     ecx, [ebp+String2]
.text$mn:000008B5                 push    ecx             ; lpString2
.text$mn:000008B6                 lea     edx, [ebp+String1]
.text$mn:000008BC                 push    edx             ; lpString1
.text$mn:000008BD                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:000008C3                 mov     [ebp+var_424], eax
.text$mn:000008C9                 movzx   eax, [ebp+var_415]
.text$mn:000008D0                 test    eax, eax
.text$mn:000008D2                 jz      short loc_8DC
.text$mn:000008D4                 mov     eax, [ebp+var_424]
.text$mn:000008DA                 jmp     short loc_8E4
.text$mn:000008DC ; ---------------------------------------------------------------------------
.text$mn:000008DC
.text$mn:000008DC loc_8DC:                                ; CODE XREF: ListViewCompareProc(long,long,long)+126j
.text$mn:000008DC                 xor     eax, eax
.text$mn:000008DE                 sub     eax, [ebp+var_424]
.text$mn:000008E4
.text$mn:000008E4 loc_8E4:                                ; CODE XREF: ListViewCompareProc(long,long,long)+12Ej
.text$mn:000008E4                 mov     ecx, [ebp+var_4]
.text$mn:000008E7                 xor     ecx, ebp
.text$mn:000008E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000008EE                 mov     esp, ebp
.text$mn:000008F0                 pop     ebp
.text$mn:000008F1                 retn    0Ch
.text$mn:000008F1 ?ListViewCompareProc@@YGHJJJ@Z endp
.text$mn:000008F1
.text$mn:000008F1 _text$mn        ends
.text$mn:000008F1
.text$x:000008F4 ; ===========================================================================
.text$x:000008F4
.text$x:000008F4 ; Segment type: Pure code
.text$x:000008F4 ; Segment permissions: Read/Execute
.text$x:000008F4 _text$x         segment para public 'CODE' use32
.text$x:000008F4                 assume cs:_text$x
.text$x:000008F4                 ;org 8F4h
.text$x:000008F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000008F4
.text$x:000008F4 ; =============== S U B R O U T I N E =======================================
.text$x:000008F4
.text$x:000008F4
.text$x:000008F4 __unwindfunclet$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z$0 proc near
.text$x:000008F4                                         ; DATA XREF: .xdata$x:00002BD8o
.text$x:000008F4                 lea     ecx, [ebp-2Ch]
.text$x:000008F7                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000008F7 __unwindfunclet$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z$0 endp
.text$x:000008F7
.text$x:000008FC
.text$x:000008FC ; =============== S U B R O U T I N E =======================================
.text$x:000008FC
.text$x:000008FC
.text$x:000008FC __ehhandler$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z proc near
.text$x:000008FC                                         ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+5o
.text$x:000008FC
.text$x:000008FC arg_4           = dword ptr  8
.text$x:000008FC
.text$x:000008FC                 mov     edx, [esp+arg_4]
.text$x:00000900                 lea     eax, [edx+0Ch]
.text$x:00000903                 mov     ecx, [edx-120h]
.text$x:00000909                 xor     ecx, eax
.text$x:0000090B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000910                 mov     ecx, [edx-4]
.text$x:00000913                 xor     ecx, eax
.text$x:00000915                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000091A                 mov     eax, offset __ehfuncinfo$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z
.text$x:0000091F                 jmp     ___CxxFrameHandler3
.text$x:0000091F __ehhandler$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z endp
.text$x:0000091F
.text$x:0000091F _text$x         ends
.text$x:0000091F
.text$mn:00000924 ; ===========================================================================
.text$mn:00000924
.text$mn:00000924 ; Segment type: Pure code
.text$mn:00000924 ; Segment permissions: Read/Execute
.text$mn:00000924 _text$mn        segment para public 'CODE' use32
.text$mn:00000924                 assume cs:_text$mn
.text$mn:00000924                 ;org 924h
.text$mn:00000924 ; COMDAT (pick any)
.text$mn:00000924                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000924
.text$mn:00000924 ; =============== S U B R O U T I N E =======================================
.text$mn:00000924
.text$mn:00000924 ; Attributes: bp-based frame
.text$mn:00000924
.text$mn:00000924 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000924                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000924 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000924                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000924
.text$mn:00000924 var_4           = dword ptr -4
.text$mn:00000924 arg_0           = dword ptr  8
.text$mn:00000924
.text$mn:00000924                 push    ebp
.text$mn:00000925                 mov     ebp, esp
.text$mn:00000927                 push    ecx
.text$mn:00000928                 mov     [ebp+var_4], 0
.text$mn:0000092F                 cmp     [ebp+arg_0], 0
.text$mn:00000933                 jnz     short loc_937
.text$mn:00000935                 jmp     short loc_957
.text$mn:00000937 ; ---------------------------------------------------------------------------
.text$mn:00000937
.text$mn:00000937 loc_937:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000937                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000093B                 ja      short loc_952
.text$mn:0000093D                 mov     eax, [ebp+arg_0]
.text$mn:00000940                 push    eax             ; unsigned int
.text$mn:00000941                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000946                 add     esp, 4
.text$mn:00000949                 mov     [ebp+var_4], eax
.text$mn:0000094C                 cmp     [ebp+var_4], 0
.text$mn:00000950                 jnz     short loc_957
.text$mn:00000952
.text$mn:00000952 loc_952:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00000952                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000957
.text$mn:00000957 loc_957:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000957                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000957                 mov     eax, [ebp+var_4]
.text$mn:0000095A                 mov     esp, ebp
.text$mn:0000095C                 pop     ebp
.text$mn:0000095D                 retn
.text$mn:0000095D ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:0000095D
.text$mn:0000095D ; ---------------------------------------------------------------------------
.text$mn:0000095E                 align 10h
.text$mn:0000095E _text$mn        ends
.text$mn:0000095E
.text$mn:00000960 ; ===========================================================================
.text$mn:00000960
.text$mn:00000960 ; Segment type: Pure code
.text$mn:00000960 ; Segment permissions: Read/Execute
.text$mn:00000960 _text$mn        segment para public 'CODE' use32
.text$mn:00000960                 assume cs:_text$mn
.text$mn:00000960                 ;org 960h
.text$mn:00000960 ; COMDAT (pick any)
.text$mn:00000960                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000960
.text$mn:00000960 ; =============== S U B R O U T I N E =======================================
.text$mn:00000960
.text$mn:00000960 ; Attributes: bp-based frame
.text$mn:00000960
.text$mn:00000960 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000960                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000960 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000960                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000960
.text$mn:00000960 var_4           = dword ptr -4
.text$mn:00000960 arg_0           = dword ptr  8
.text$mn:00000960
.text$mn:00000960                 push    ebp
.text$mn:00000961                 mov     ebp, esp
.text$mn:00000963                 push    ecx
.text$mn:00000964                 mov     [ebp+var_4], 0
.text$mn:0000096B                 cmp     [ebp+arg_0], 0
.text$mn:0000096F                 jnz     short loc_973
.text$mn:00000971                 jmp     short loc_999
.text$mn:00000973 ; ---------------------------------------------------------------------------
.text$mn:00000973
.text$mn:00000973 loc_973:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000973                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000097A                 ja      short loc_994
.text$mn:0000097C                 mov     eax, [ebp+arg_0]
.text$mn:0000097F                 shl     eax, 3
.text$mn:00000982                 push    eax             ; unsigned int
.text$mn:00000983                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000988                 add     esp, 4
.text$mn:0000098B                 mov     [ebp+var_4], eax
.text$mn:0000098E                 cmp     [ebp+var_4], 0
.text$mn:00000992                 jnz     short loc_999
.text$mn:00000994
.text$mn:00000994 loc_994:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000994                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000999
.text$mn:00000999 loc_999:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000999                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000999                 mov     eax, [ebp+var_4]
.text$mn:0000099C                 mov     esp, ebp
.text$mn:0000099E                 pop     ebp
.text$mn:0000099F                 retn
.text$mn:0000099F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000099F
.text$mn:0000099F _text$mn        ends
.text$mn:0000099F
.text$mn:000009A0 ; ===========================================================================
.text$mn:000009A0
.text$mn:000009A0 ; Segment type: Pure code
.text$mn:000009A0 ; Segment permissions: Read/Execute
.text$mn:000009A0 _text$mn        segment para public 'CODE' use32
.text$mn:000009A0                 assume cs:_text$mn
.text$mn:000009A0                 ;org 9A0h
.text$mn:000009A0 ; COMDAT (pick any)
.text$mn:000009A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009A0
.text$mn:000009A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009A0
.text$mn:000009A0 ; Attributes: bp-based frame
.text$mn:000009A0
.text$mn:000009A0 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000009A0                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000009A0 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000009A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000009A0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000009A0
.text$mn:000009A0 arg_0           = dword ptr  8
.text$mn:000009A0 arg_4           = dword ptr  0Ch
.text$mn:000009A0 arg_8           = dword ptr  10h
.text$mn:000009A0
.text$mn:000009A0                 push    ebp
.text$mn:000009A1                 mov     ebp, esp
.text$mn:000009A3                 cmp     [ebp+arg_0], 0
.text$mn:000009A7                 jnz     short loc_9BE
.text$mn:000009A9                 mov     eax, [ebp+arg_8]
.text$mn:000009AC                 push    eax             ; unsigned int
.text$mn:000009AD                 mov     ecx, [ebp+arg_4]
.text$mn:000009B0                 push    ecx             ; wchar_t *
.text$mn:000009B1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000009B6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000009BB                 add     esp, 0Ch
.text$mn:000009BE
.text$mn:000009BE loc_9BE:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000009BE                 pop     ebp
.text$mn:000009BF                 retn
.text$mn:000009BF ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000009BF
.text$mn:000009BF _text$mn        ends
.text$mn:000009BF
.text$mn:000009C0 ; ===========================================================================
.text$mn:000009C0
.text$mn:000009C0 ; Segment type: Pure code
.text$mn:000009C0 ; Segment permissions: Read/Execute
.text$mn:000009C0 _text$mn        segment para public 'CODE' use32
.text$mn:000009C0                 assume cs:_text$mn
.text$mn:000009C0                 ;org 9C0h
.text$mn:000009C0 ; COMDAT (pick any)
.text$mn:000009C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009C0
.text$mn:000009C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009C0
.text$mn:000009C0 ; Attributes: bp-based frame
.text$mn:000009C0
.text$mn:000009C0 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000009C0                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000009C0 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000009C0                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000009C0                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000009C0
.text$mn:000009C0 arg_0           = dword ptr  8
.text$mn:000009C0
.text$mn:000009C0                 push    ebp
.text$mn:000009C1                 mov     ebp, esp
.text$mn:000009C3                 mov     eax, [ebp+arg_0]
.text$mn:000009C6                 pop     ebp
.text$mn:000009C7                 retn
.text$mn:000009C7 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000009C7
.text$mn:000009C7 _text$mn        ends
.text$mn:000009C7
.text$mn:000009C8 ; ===========================================================================
.text$mn:000009C8
.text$mn:000009C8 ; Segment type: Pure code
.text$mn:000009C8 ; Segment permissions: Read/Execute
.text$mn:000009C8 _text$mn        segment para public 'CODE' use32
.text$mn:000009C8                 assume cs:_text$mn
.text$mn:000009C8                 ;org 9C8h
.text$mn:000009C8 ; COMDAT (pick any)
.text$mn:000009C8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009C8
.text$mn:000009C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009C8
.text$mn:000009C8 ; Attributes: bp-based frame
.text$mn:000009C8
.text$mn:000009C8 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000009C8                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000009C8 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000009C8                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000009C8                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000009C8
.text$mn:000009C8 arg_0           = dword ptr  8
.text$mn:000009C8
.text$mn:000009C8                 push    ebp
.text$mn:000009C9                 mov     ebp, esp
.text$mn:000009CB                 mov     eax, [ebp+arg_0]
.text$mn:000009CE                 pop     ebp
.text$mn:000009CF                 retn
.text$mn:000009CF ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000009CF
.text$mn:000009CF _text$mn        ends
.text$mn:000009CF
.text$mn:000009D0 ; ===========================================================================
.text$mn:000009D0
.text$mn:000009D0 ; Segment type: Pure code
.text$mn:000009D0 ; Segment permissions: Read/Execute
.text$mn:000009D0 _text$mn        segment para public 'CODE' use32
.text$mn:000009D0                 assume cs:_text$mn
.text$mn:000009D0                 ;org 9D0h
.text$mn:000009D0 ; COMDAT (pick any)
.text$mn:000009D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009D0
.text$mn:000009D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009D0
.text$mn:000009D0 ; Attributes: bp-based frame
.text$mn:000009D0
.text$mn:000009D0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000009D0                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000009D0 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000009D0                                         ; CODE XREF: $LN19+4Bp
.text$mn:000009D0
.text$mn:000009D0 var_4           = dword ptr -4
.text$mn:000009D0 arg_0           = dword ptr  8
.text$mn:000009D0 arg_4           = dword ptr  0Ch
.text$mn:000009D0
.text$mn:000009D0                 push    ebp
.text$mn:000009D1                 mov     ebp, esp
.text$mn:000009D3                 push    ecx
.text$mn:000009D4                 mov     [ebp+var_4], ecx
.text$mn:000009D7                 mov     eax, [ebp+arg_4]
.text$mn:000009DA                 push    eax
.text$mn:000009DB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000009E0                 add     esp, 4
.text$mn:000009E3                 push    eax             ; int
.text$mn:000009E4                 mov     ecx, [ebp+arg_0]
.text$mn:000009E7                 push    ecx             ; void *
.text$mn:000009E8                 mov     edx, [ebp+var_4]
.text$mn:000009EB                 push    edx             ; int
.text$mn:000009EC                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000009F1                 add     esp, 0Ch
.text$mn:000009F4                 mov     esp, ebp
.text$mn:000009F6                 pop     ebp
.text$mn:000009F7                 retn    8
.text$mn:000009F7 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000009F7
.text$mn:000009F7 ; ---------------------------------------------------------------------------
.text$mn:000009FA                 align 4
.text$mn:000009FA _text$mn        ends
.text$mn:000009FA
.text$mn:000009FC ; ===========================================================================
.text$mn:000009FC
.text$mn:000009FC ; Segment type: Pure code
.text$mn:000009FC ; Segment permissions: Read/Execute
.text$mn:000009FC _text$mn        segment para public 'CODE' use32
.text$mn:000009FC                 assume cs:_text$mn
.text$mn:000009FC                 ;org 9FCh
.text$mn:000009FC ; COMDAT (pick any)
.text$mn:000009FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009FC
.text$mn:000009FC ; =============== S U B R O U T I N E =======================================
.text$mn:000009FC
.text$mn:000009FC ; Attributes: bp-based frame
.text$mn:000009FC
.text$mn:000009FC ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000009FC                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000009FC ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000009FC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000009FC
.text$mn:000009FC var_1C          = dword ptr -1Ch
.text$mn:000009FC var_18          = dword ptr -18h
.text$mn:000009FC var_14          = dword ptr -14h
.text$mn:000009FC var_10          = dword ptr -10h
.text$mn:000009FC var_C           = dword ptr -0Ch
.text$mn:000009FC var_4           = dword ptr -4
.text$mn:000009FC arg_0           = dword ptr  8
.text$mn:000009FC arg_4           = dword ptr  0Ch
.text$mn:000009FC
.text$mn:000009FC                 push    ebp
.text$mn:000009FD                 mov     ebp, esp
.text$mn:000009FF                 push    0FFFFFFFFh
.text$mn:00000A01                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000A06                 mov     eax, large fs:0
.text$mn:00000A0C                 push    eax
.text$mn:00000A0D                 sub     esp, 10h
.text$mn:00000A10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A15                 xor     eax, ebp
.text$mn:00000A17                 push    eax
.text$mn:00000A18                 lea     eax, [ebp+var_C]
.text$mn:00000A1B                 mov     large fs:0, eax
.text$mn:00000A21                 mov     [ebp+var_18], ecx
.text$mn:00000A24                 mov     eax, [ebp+arg_0]
.text$mn:00000A27                 push    eax             ; void *
.text$mn:00000A28                 push    4               ; unsigned int
.text$mn:00000A2A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000A2F                 add     esp, 8
.text$mn:00000A32                 mov     [ebp+var_10], eax
.text$mn:00000A35                 mov     [ebp+var_4], 0
.text$mn:00000A3C                 cmp     [ebp+var_10], 0
.text$mn:00000A40                 jz      short loc_A5D
.text$mn:00000A42                 mov     ecx, [ebp+arg_4]
.text$mn:00000A45                 push    ecx
.text$mn:00000A46                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000A4B                 add     esp, 4
.text$mn:00000A4E                 mov     edx, [ebp+var_10]
.text$mn:00000A51                 mov     eax, [eax]
.text$mn:00000A53                 mov     [edx], eax
.text$mn:00000A55                 mov     ecx, [ebp+var_10]
.text$mn:00000A58                 mov     [ebp+var_14], ecx
.text$mn:00000A5B                 jmp     short loc_A64
.text$mn:00000A5D ; ---------------------------------------------------------------------------
.text$mn:00000A5D
.text$mn:00000A5D loc_A5D:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000A5D                 mov     [ebp+var_14], 0
.text$mn:00000A64
.text$mn:00000A64 loc_A64:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000A64                 mov     edx, [ebp+var_14]
.text$mn:00000A67                 mov     [ebp+var_1C], edx
.text$mn:00000A6A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A71                 mov     ecx, [ebp+var_C]
.text$mn:00000A74                 mov     large fs:0, ecx
.text$mn:00000A7B                 pop     ecx
.text$mn:00000A7C                 mov     esp, ebp
.text$mn:00000A7E                 pop     ebp
.text$mn:00000A7F                 retn    8
.text$mn:00000A7F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000A7F
.text$mn:00000A7F ; ---------------------------------------------------------------------------
.text$mn:00000A82                 align 4
.text$mn:00000A82 _text$mn        ends
.text$mn:00000A82
.text$x:00000A84 ; ===========================================================================
.text$x:00000A84
.text$x:00000A84 ; Segment type: Pure code
.text$x:00000A84 ; Segment permissions: Read/Execute
.text$x:00000A84 _text$x         segment para public 'CODE' use32
.text$x:00000A84                 assume cs:_text$x
.text$x:00000A84                 ;org 0A84h
.text$x:00000A84 ; COMDAT (pick associative to section at 9FC)
.text$x:00000A84                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000A84
.text$x:00000A84 ; =============== S U B R O U T I N E =======================================
.text$x:00000A84
.text$x:00000A84
.text$x:00000A84 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000A84                                         ; DATA XREF: .xdata$x:00002C30o
.text$x:00000A84                 mov     eax, [ebp+8]
.text$x:00000A87                 push    eax
.text$x:00000A88                 mov     eax, [ebp-10h]
.text$x:00000A8B                 push    eax             ; void *
.text$x:00000A8C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000A91                 add     esp, 8
.text$x:00000A94                 retn
.text$x:00000A94 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000A94
.text$x:00000A95
.text$x:00000A95 ; =============== S U B R O U T I N E =======================================
.text$x:00000A95
.text$x:00000A95
.text$x:00000A95 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000A95                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000A95
.text$x:00000A95 arg_4           = dword ptr  8
.text$x:00000A95
.text$x:00000A95                 mov     edx, [esp+arg_4]
.text$x:00000A99                 lea     eax, [edx+0Ch]
.text$x:00000A9C                 mov     ecx, [edx-14h]
.text$x:00000A9F                 xor     ecx, eax
.text$x:00000AA1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AA6                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00000AAB                 jmp     ___CxxFrameHandler3
.text$x:00000AAB __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00000AAB
.text$x:00000AAB _text$x         ends
.text$x:00000AAB
.text$mn:00000AB0 ; ===========================================================================
.text$mn:00000AB0
.text$mn:00000AB0 ; Segment type: Pure code
.text$mn:00000AB0 ; Segment permissions: Read/Execute
.text$mn:00000AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00000AB0                 assume cs:_text$mn
.text$mn:00000AB0                 ;org 0AB0h
.text$mn:00000AB0 ; COMDAT (pick any)
.text$mn:00000AB0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000AB0
.text$mn:00000AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AB0
.text$mn:00000AB0 ; Attributes: bp-based frame
.text$mn:00000AB0
.text$mn:00000AB0 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000AB0                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000AB0 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000AB0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000AB0
.text$mn:00000AB0 arg_0           = dword ptr  8
.text$mn:00000AB0 arg_4           = dword ptr  0Ch
.text$mn:00000AB0 arg_8           = dword ptr  10h
.text$mn:00000AB0
.text$mn:00000AB0                 push    ebp
.text$mn:00000AB1                 mov     ebp, esp
.text$mn:00000AB3                 mov     eax, [ebp+arg_8]
.text$mn:00000AB6                 push    eax
.text$mn:00000AB7                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000ABC                 add     esp, 4
.text$mn:00000ABF                 push    eax             ; int
.text$mn:00000AC0                 mov     ecx, [ebp+arg_4]
.text$mn:00000AC3                 push    ecx             ; void *
.text$mn:00000AC4                 mov     ecx, [ebp+arg_0]
.text$mn:00000AC7                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000ACC                 pop     ebp
.text$mn:00000ACD                 retn
.text$mn:00000ACD ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000ACD
.text$mn:00000ACD ; ---------------------------------------------------------------------------
.text$mn:00000ACE                 align 10h
.text$mn:00000ACE _text$mn        ends
.text$mn:00000ACE
.text$mn:00000AD0 ; ===========================================================================
.text$mn:00000AD0
.text$mn:00000AD0 ; Segment type: Pure code
.text$mn:00000AD0 ; Segment permissions: Read/Execute
.text$mn:00000AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00000AD0                 assume cs:_text$mn
.text$mn:00000AD0                 ;org 0AD0h
.text$mn:00000AD0 ; COMDAT (pick any)
.text$mn:00000AD0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000AD0
.text$mn:00000AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AD0
.text$mn:00000AD0 ; Attributes: bp-based frame
.text$mn:00000AD0
.text$mn:00000AD0 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000AD0                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000AD0 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000AD0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000AD0
.text$mn:00000AD0 var_1C          = dword ptr -1Ch
.text$mn:00000AD0 var_18          = dword ptr -18h
.text$mn:00000AD0 var_14          = dword ptr -14h
.text$mn:00000AD0 var_10          = dword ptr -10h
.text$mn:00000AD0 var_C           = dword ptr -0Ch
.text$mn:00000AD0 var_4           = dword ptr -4
.text$mn:00000AD0 arg_0           = dword ptr  8
.text$mn:00000AD0 arg_4           = dword ptr  0Ch
.text$mn:00000AD0
.text$mn:00000AD0                 push    ebp
.text$mn:00000AD1                 mov     ebp, esp
.text$mn:00000AD3                 push    0FFFFFFFFh
.text$mn:00000AD5                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000ADA                 mov     eax, large fs:0
.text$mn:00000AE0                 push    eax
.text$mn:00000AE1                 sub     esp, 10h
.text$mn:00000AE4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AE9                 xor     eax, ebp
.text$mn:00000AEB                 push    eax
.text$mn:00000AEC                 lea     eax, [ebp+var_C]
.text$mn:00000AEF                 mov     large fs:0, eax
.text$mn:00000AF5                 mov     [ebp+var_18], ecx
.text$mn:00000AF8                 mov     eax, [ebp+arg_0]
.text$mn:00000AFB                 push    eax             ; void *
.text$mn:00000AFC                 push    8               ; unsigned int
.text$mn:00000AFE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000B03                 add     esp, 8
.text$mn:00000B06                 mov     [ebp+var_10], eax
.text$mn:00000B09                 mov     [ebp+var_4], 0
.text$mn:00000B10                 cmp     [ebp+var_10], 0
.text$mn:00000B14                 jz      short loc_B37
.text$mn:00000B16                 mov     ecx, [ebp+arg_4]
.text$mn:00000B19                 push    ecx
.text$mn:00000B1A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000B1F                 add     esp, 4
.text$mn:00000B22                 mov     edx, [eax]
.text$mn:00000B24                 mov     eax, [eax+4]
.text$mn:00000B27                 mov     ecx, [ebp+var_10]
.text$mn:00000B2A                 mov     [ecx], edx
.text$mn:00000B2C                 mov     [ecx+4], eax
.text$mn:00000B2F                 mov     edx, [ebp+var_10]
.text$mn:00000B32                 mov     [ebp+var_14], edx
.text$mn:00000B35                 jmp     short loc_B3E
.text$mn:00000B37 ; ---------------------------------------------------------------------------
.text$mn:00000B37
.text$mn:00000B37 loc_B37:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000B37                 mov     [ebp+var_14], 0
.text$mn:00000B3E
.text$mn:00000B3E loc_B3E:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000B3E                 mov     eax, [ebp+var_14]
.text$mn:00000B41                 mov     [ebp+var_1C], eax
.text$mn:00000B44                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B4B                 mov     ecx, [ebp+var_C]
.text$mn:00000B4E                 mov     large fs:0, ecx
.text$mn:00000B55                 pop     ecx
.text$mn:00000B56                 mov     esp, ebp
.text$mn:00000B58                 pop     ebp
.text$mn:00000B59                 retn    8
.text$mn:00000B59 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000B59
.text$mn:00000B59 _text$mn        ends
.text$mn:00000B59
.text$x:00000B5C ; ===========================================================================
.text$x:00000B5C
.text$x:00000B5C ; Segment type: Pure code
.text$x:00000B5C ; Segment permissions: Read/Execute
.text$x:00000B5C _text$x         segment para public 'CODE' use32
.text$x:00000B5C                 assume cs:_text$x
.text$x:00000B5C                 ;org 0B5Ch
.text$x:00000B5C ; COMDAT (pick associative to section at AD0)
.text$x:00000B5C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000B5C
.text$x:00000B5C ; =============== S U B R O U T I N E =======================================
.text$x:00000B5C
.text$x:00000B5C
.text$x:00000B5C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000B5C                                         ; DATA XREF: .xdata$x:00002C04o
.text$x:00000B5C                 mov     eax, [ebp+8]
.text$x:00000B5F                 push    eax
.text$x:00000B60                 mov     eax, [ebp-10h]
.text$x:00000B63                 push    eax             ; void *
.text$x:00000B64                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000B69                 add     esp, 8
.text$x:00000B6C                 retn
.text$x:00000B6C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000B6C
.text$x:00000B6D
.text$x:00000B6D ; =============== S U B R O U T I N E =======================================
.text$x:00000B6D
.text$x:00000B6D
.text$x:00000B6D __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000B6D                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000B6D
.text$x:00000B6D arg_4           = dword ptr  8
.text$x:00000B6D
.text$x:00000B6D                 mov     edx, [esp+arg_4]
.text$x:00000B71                 lea     eax, [edx+0Ch]
.text$x:00000B74                 mov     ecx, [edx-14h]
.text$x:00000B77                 xor     ecx, eax
.text$x:00000B79                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B7E                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000B83                 jmp     ___CxxFrameHandler3
.text$x:00000B83 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000B83
.text$x:00000B83 _text$x         ends
.text$x:00000B83
.text$mn:00000B88 ; ===========================================================================
.text$mn:00000B88
.text$mn:00000B88 ; Segment type: Pure code
.text$mn:00000B88 ; Segment permissions: Read/Execute
.text$mn:00000B88 _text$mn        segment para public 'CODE' use32
.text$mn:00000B88                 assume cs:_text$mn
.text$mn:00000B88                 ;org 0B88h
.text$mn:00000B88 ; COMDAT (pick any)
.text$mn:00000B88                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000B88
.text$mn:00000B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B88
.text$mn:00000B88 ; Attributes: bp-based frame
.text$mn:00000B88
.text$mn:00000B88 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000B88                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000B88 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000B88                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000B88
.text$mn:00000B88 var_4           = dword ptr -4
.text$mn:00000B88 arg_0           = dword ptr  8
.text$mn:00000B88
.text$mn:00000B88                 push    ebp
.text$mn:00000B89                 mov     ebp, esp
.text$mn:00000B8B                 push    ecx
.text$mn:00000B8C                 mov     [ebp+var_4], ecx
.text$mn:00000B8F                 mov     eax, [ebp+arg_0]
.text$mn:00000B92                 push    eax
.text$mn:00000B93                 mov     ecx, [ebp+var_4]
.text$mn:00000B96                 push    ecx
.text$mn:00000B97                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000B9C                 add     esp, 8
.text$mn:00000B9F                 mov     esp, ebp
.text$mn:00000BA1                 pop     ebp
.text$mn:00000BA2                 retn    4
.text$mn:00000BA2 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000BA2
.text$mn:00000BA2 ; ---------------------------------------------------------------------------
.text$mn:00000BA5                 align 4
.text$mn:00000BA5 _text$mn        ends
.text$mn:00000BA5
.text$mn:00000BA8 ; ===========================================================================
.text$mn:00000BA8
.text$mn:00000BA8 ; Segment type: Pure code
.text$mn:00000BA8 ; Segment permissions: Read/Execute
.text$mn:00000BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00000BA8                 assume cs:_text$mn
.text$mn:00000BA8                 ;org 0BA8h
.text$mn:00000BA8 ; COMDAT (pick any)
.text$mn:00000BA8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BA8
.text$mn:00000BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BA8
.text$mn:00000BA8 ; Attributes: bp-based frame
.text$mn:00000BA8
.text$mn:00000BA8 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000BA8                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000BA8 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000BA8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000BA8
.text$mn:00000BA8 var_4           = dword ptr -4
.text$mn:00000BA8
.text$mn:00000BA8                 push    ebp
.text$mn:00000BA9                 mov     ebp, esp
.text$mn:00000BAB                 push    ecx
.text$mn:00000BAC                 mov     [ebp+var_4], ecx
.text$mn:00000BAF                 mov     esp, ebp
.text$mn:00000BB1                 pop     ebp
.text$mn:00000BB2                 retn    4
.text$mn:00000BB2 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000BB2
.text$mn:00000BB2 ; ---------------------------------------------------------------------------
.text$mn:00000BB5                 align 4
.text$mn:00000BB5 _text$mn        ends
.text$mn:00000BB5
.text$mn:00000BB8 ; ===========================================================================
.text$mn:00000BB8
.text$mn:00000BB8 ; Segment type: Pure code
.text$mn:00000BB8 ; Segment permissions: Read/Execute
.text$mn:00000BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00000BB8                 assume cs:_text$mn
.text$mn:00000BB8                 ;org 0BB8h
.text$mn:00000BB8 ; COMDAT (pick any)
.text$mn:00000BB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BB8
.text$mn:00000BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BB8
.text$mn:00000BB8 ; Attributes: bp-based frame
.text$mn:00000BB8
.text$mn:00000BB8 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000BB8                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000BB8 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000BB8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000BB8
.text$mn:00000BB8 arg_0           = dword ptr  8
.text$mn:00000BB8 arg_4           = dword ptr  0Ch
.text$mn:00000BB8
.text$mn:00000BB8                 push    ebp
.text$mn:00000BB9                 mov     ebp, esp
.text$mn:00000BBB                 mov     eax, [ebp+arg_4]
.text$mn:00000BBE                 push    eax
.text$mn:00000BBF                 mov     ecx, [ebp+arg_0]
.text$mn:00000BC2                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000BC7                 pop     ebp
.text$mn:00000BC8                 retn
.text$mn:00000BC8 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000BC8
.text$mn:00000BC8 ; ---------------------------------------------------------------------------
.text$mn:00000BC9                 align 4
.text$mn:00000BC9 _text$mn        ends
.text$mn:00000BC9
.text$mn:00000BCC ; ===========================================================================
.text$mn:00000BCC
.text$mn:00000BCC ; Segment type: Pure code
.text$mn:00000BCC ; Segment permissions: Read/Execute
.text$mn:00000BCC _text$mn        segment para public 'CODE' use32
.text$mn:00000BCC                 assume cs:_text$mn
.text$mn:00000BCC                 ;org 0BCCh
.text$mn:00000BCC ; COMDAT (pick any)
.text$mn:00000BCC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BCC
.text$mn:00000BCC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BCC
.text$mn:00000BCC ; Attributes: bp-based frame
.text$mn:00000BCC
.text$mn:00000BCC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000BCC                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00000BCC ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00000BCC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00000BCC
.text$mn:00000BCC var_4           = dword ptr -4
.text$mn:00000BCC arg_0           = dword ptr  8
.text$mn:00000BCC
.text$mn:00000BCC                 push    ebp
.text$mn:00000BCD                 mov     ebp, esp
.text$mn:00000BCF                 push    ecx
.text$mn:00000BD0                 mov     [ebp+var_4], ecx
.text$mn:00000BD3                 mov     eax, [ebp+arg_0]
.text$mn:00000BD6                 push    eax
.text$mn:00000BD7                 mov     ecx, [ebp+var_4]
.text$mn:00000BDA                 push    ecx
.text$mn:00000BDB                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00000BE0                 add     esp, 8
.text$mn:00000BE3                 mov     esp, ebp
.text$mn:00000BE5                 pop     ebp
.text$mn:00000BE6                 retn    4
.text$mn:00000BE6 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00000BE6
.text$mn:00000BE6 ; ---------------------------------------------------------------------------
.text$mn:00000BE9                 align 4
.text$mn:00000BE9 _text$mn        ends
.text$mn:00000BE9
.text$mn:00000BEC ; ===========================================================================
.text$mn:00000BEC
.text$mn:00000BEC ; Segment type: Pure code
.text$mn:00000BEC ; Segment permissions: Read/Execute
.text$mn:00000BEC _text$mn        segment para public 'CODE' use32
.text$mn:00000BEC                 assume cs:_text$mn
.text$mn:00000BEC                 ;org 0BECh
.text$mn:00000BEC ; COMDAT (pick any)
.text$mn:00000BEC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BEC
.text$mn:00000BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BEC
.text$mn:00000BEC ; Attributes: bp-based frame
.text$mn:00000BEC
.text$mn:00000BEC ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000BEC                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00000BEC ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00000BEC                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00000BEC
.text$mn:00000BEC var_4           = dword ptr -4
.text$mn:00000BEC
.text$mn:00000BEC                 push    ebp
.text$mn:00000BED                 mov     ebp, esp
.text$mn:00000BEF                 push    ecx
.text$mn:00000BF0                 mov     [ebp+var_4], ecx
.text$mn:00000BF3                 mov     esp, ebp
.text$mn:00000BF5                 pop     ebp
.text$mn:00000BF6                 retn    4
.text$mn:00000BF6 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00000BF6
.text$mn:00000BF6 ; ---------------------------------------------------------------------------
.text$mn:00000BF9                 align 4
.text$mn:00000BF9 _text$mn        ends
.text$mn:00000BF9
.text$mn:00000BFC ; ===========================================================================
.text$mn:00000BFC
.text$mn:00000BFC ; Segment type: Pure code
.text$mn:00000BFC ; Segment permissions: Read/Execute
.text$mn:00000BFC _text$mn        segment para public 'CODE' use32
.text$mn:00000BFC                 assume cs:_text$mn
.text$mn:00000BFC                 ;org 0BFCh
.text$mn:00000BFC ; COMDAT (pick any)
.text$mn:00000BFC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BFC
.text$mn:00000BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BFC
.text$mn:00000BFC ; Attributes: bp-based frame
.text$mn:00000BFC
.text$mn:00000BFC ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00000BFC                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00000BFC ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00000BFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00000BFC
.text$mn:00000BFC arg_0           = dword ptr  8
.text$mn:00000BFC arg_4           = dword ptr  0Ch
.text$mn:00000BFC
.text$mn:00000BFC                 push    ebp
.text$mn:00000BFD                 mov     ebp, esp
.text$mn:00000BFF                 mov     eax, [ebp+arg_4]
.text$mn:00000C02                 push    eax
.text$mn:00000C03                 mov     ecx, [ebp+arg_0]
.text$mn:00000C06                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000C0B                 pop     ebp
.text$mn:00000C0C                 retn
.text$mn:00000C0C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00000C0C
.text$mn:00000C0C ; ---------------------------------------------------------------------------
.text$mn:00000C0D                 align 10h
.text$mn:00000C0D _text$mn        ends
.text$mn:00000C0D
.text$mn:00000C10 ; ===========================================================================
.text$mn:00000C10
.text$mn:00000C10 ; Segment type: Pure code
.text$mn:00000C10 ; Segment permissions: Read/Execute
.text$mn:00000C10 _text$mn        segment para public 'CODE' use32
.text$mn:00000C10                 assume cs:_text$mn
.text$mn:00000C10                 ;org 0C10h
.text$mn:00000C10 ; COMDAT (pick any)
.text$mn:00000C10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C10
.text$mn:00000C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C10
.text$mn:00000C10 ; Attributes: bp-based frame
.text$mn:00000C10
.text$mn:00000C10 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000C10                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000C10 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000C10                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000C10                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:00000C10
.text$mn:00000C10 var_4           = dword ptr -4
.text$mn:00000C10
.text$mn:00000C10                 push    ebp
.text$mn:00000C11                 mov     ebp, esp
.text$mn:00000C13                 push    ecx
.text$mn:00000C14                 mov     [ebp+var_4], ecx
.text$mn:00000C17                 mov     esp, ebp
.text$mn:00000C19                 pop     ebp
.text$mn:00000C1A                 retn    4
.text$mn:00000C1A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000C1A
.text$mn:00000C1A ; ---------------------------------------------------------------------------
.text$mn:00000C1D                 align 10h
.text$mn:00000C1D _text$mn        ends
.text$mn:00000C1D
.text$mn:00000C20 ; ===========================================================================
.text$mn:00000C20
.text$mn:00000C20 ; Segment type: Pure code
.text$mn:00000C20 ; Segment permissions: Read/Execute
.text$mn:00000C20 _text$mn        segment para public 'CODE' use32
.text$mn:00000C20                 assume cs:_text$mn
.text$mn:00000C20                 ;org 0C20h
.text$mn:00000C20 ; COMDAT (pick any)
.text$mn:00000C20                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C20
.text$mn:00000C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C20
.text$mn:00000C20 ; Attributes: bp-based frame
.text$mn:00000C20
.text$mn:00000C20 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000C20                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000C20 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000C20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000C20                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000C20
.text$mn:00000C20 arg_0           = dword ptr  8
.text$mn:00000C20
.text$mn:00000C20                 push    ebp
.text$mn:00000C21                 mov     ebp, esp
.text$mn:00000C23                 mov     eax, [ebp+arg_0]
.text$mn:00000C26                 pop     ebp
.text$mn:00000C27                 retn
.text$mn:00000C27 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000C27
.text$mn:00000C27 _text$mn        ends
.text$mn:00000C27
.text$mn:00000C28 ; ===========================================================================
.text$mn:00000C28
.text$mn:00000C28 ; Segment type: Pure code
.text$mn:00000C28 ; Segment permissions: Read/Execute
.text$mn:00000C28 _text$mn        segment para public 'CODE' use32
.text$mn:00000C28                 assume cs:_text$mn
.text$mn:00000C28                 ;org 0C28h
.text$mn:00000C28 ; COMDAT (pick any)
.text$mn:00000C28                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C28
.text$mn:00000C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C28
.text$mn:00000C28 ; Attributes: bp-based frame
.text$mn:00000C28
.text$mn:00000C28 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000C28                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000C28 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000C28                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000C28
.text$mn:00000C28 arg_0           = dword ptr  8
.text$mn:00000C28
.text$mn:00000C28                 push    ebp
.text$mn:00000C29                 mov     ebp, esp
.text$mn:00000C2B                 mov     eax, [ebp+arg_0]
.text$mn:00000C2E                 pop     ebp
.text$mn:00000C2F                 retn
.text$mn:00000C2F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000C2F
.text$mn:00000C2F _text$mn        ends
.text$mn:00000C2F
.text$mn:00000C30 ; ===========================================================================
.text$mn:00000C30
.text$mn:00000C30 ; Segment type: Pure code
.text$mn:00000C30 ; Segment permissions: Read/Execute
.text$mn:00000C30 _text$mn        segment para public 'CODE' use32
.text$mn:00000C30                 assume cs:_text$mn
.text$mn:00000C30                 ;org 0C30h
.text$mn:00000C30 ; COMDAT (pick any)
.text$mn:00000C30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C30
.text$mn:00000C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C30
.text$mn:00000C30 ; Attributes: bp-based frame
.text$mn:00000C30
.text$mn:00000C30 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000C30                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000C30 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000C30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000C30
.text$mn:00000C30 var_10          = dword ptr -10h
.text$mn:00000C30 var_C           = dword ptr -0Ch
.text$mn:00000C30 var_4           = dword ptr -4
.text$mn:00000C30
.text$mn:00000C30                 push    ebp
.text$mn:00000C31                 mov     ebp, esp
.text$mn:00000C33                 push    0FFFFFFFFh
.text$mn:00000C35                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000C3A                 mov     eax, large fs:0
.text$mn:00000C40                 push    eax
.text$mn:00000C41                 push    ecx
.text$mn:00000C42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C47                 xor     eax, ebp
.text$mn:00000C49                 push    eax
.text$mn:00000C4A                 lea     eax, [ebp+var_C]
.text$mn:00000C4D                 mov     large fs:0, eax
.text$mn:00000C53                 mov     [ebp+var_10], ecx
.text$mn:00000C56                 mov     ecx, [ebp+var_10]
.text$mn:00000C59                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000C5E                 mov     [ebp+var_4], 0
.text$mn:00000C65                 mov     ecx, [ebp+var_10]
.text$mn:00000C68                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000C6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C74                 mov     eax, [ebp+var_10]
.text$mn:00000C77                 mov     ecx, [ebp+var_C]
.text$mn:00000C7A                 mov     large fs:0, ecx
.text$mn:00000C81                 pop     ecx
.text$mn:00000C82                 mov     esp, ebp
.text$mn:00000C84                 pop     ebp
.text$mn:00000C85                 retn    4
.text$mn:00000C85 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000C85
.text$mn:00000C85 _text$mn        ends
.text$mn:00000C85
.text$x:00000C88 ; ===========================================================================
.text$x:00000C88
.text$x:00000C88 ; Segment type: Pure code
.text$x:00000C88 ; Segment permissions: Read/Execute
.text$x:00000C88 _text$x         segment para public 'CODE' use32
.text$x:00000C88                 assume cs:_text$x
.text$x:00000C88                 ;org 0C88h
.text$x:00000C88 ; COMDAT (pick associative to section at C30)
.text$x:00000C88                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000C88
.text$x:00000C88 ; =============== S U B R O U T I N E =======================================
.text$x:00000C88
.text$x:00000C88
.text$x:00000C88 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000C88                                         ; DATA XREF: .xdata$x:00002860o
.text$x:00000C88                 mov     ecx, [ebp-10h]
.text$x:00000C8B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000C8B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000C8B
.text$x:00000C90
.text$x:00000C90 ; =============== S U B R O U T I N E =======================================
.text$x:00000C90
.text$x:00000C90
.text$x:00000C90 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000C90                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000C90
.text$x:00000C90 arg_4           = dword ptr  8
.text$x:00000C90
.text$x:00000C90                 mov     edx, [esp+arg_4]
.text$x:00000C94                 lea     eax, [edx+0Ch]
.text$x:00000C97                 mov     ecx, [edx-8]
.text$x:00000C9A                 xor     ecx, eax
.text$x:00000C9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CA1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000CA6                 jmp     ___CxxFrameHandler3
.text$x:00000CA6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000CA6
.text$x:00000CA6 ; ---------------------------------------------------------------------------
.text$x:00000CAB                 align 4
.text$x:00000CAB _text$x         ends
.text$x:00000CAB
.text$mn:00000CAC ; ===========================================================================
.text$mn:00000CAC
.text$mn:00000CAC ; Segment type: Pure code
.text$mn:00000CAC ; Segment permissions: Read/Execute
.text$mn:00000CAC _text$mn        segment para public 'CODE' use32
.text$mn:00000CAC                 assume cs:_text$mn
.text$mn:00000CAC                 ;org 0CACh
.text$mn:00000CAC ; COMDAT (pick any)
.text$mn:00000CAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CAC
.text$mn:00000CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CAC
.text$mn:00000CAC ; Attributes: bp-based frame
.text$mn:00000CAC
.text$mn:00000CAC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000CAC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000CAC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000CAC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000CAC
.text$mn:00000CAC var_10          = dword ptr -10h
.text$mn:00000CAC var_C           = dword ptr -0Ch
.text$mn:00000CAC var_4           = dword ptr -4
.text$mn:00000CAC
.text$mn:00000CAC                 push    ebp
.text$mn:00000CAD                 mov     ebp, esp
.text$mn:00000CAF                 push    0FFFFFFFFh
.text$mn:00000CB1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000CB6                 mov     eax, large fs:0
.text$mn:00000CBC                 push    eax
.text$mn:00000CBD                 push    ecx
.text$mn:00000CBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000CC3                 xor     eax, ebp
.text$mn:00000CC5                 push    eax
.text$mn:00000CC6                 lea     eax, [ebp+var_C]
.text$mn:00000CC9                 mov     large fs:0, eax
.text$mn:00000CCF                 mov     [ebp+var_10], ecx
.text$mn:00000CD2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000CD5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000CDA                 mov     [ebp+var_4], 0
.text$mn:00000CE1                 mov     eax, [ebp+var_10]
.text$mn:00000CE4                 mov     dword ptr [eax+14h], 0
.text$mn:00000CEB                 mov     ecx, [ebp+var_10]
.text$mn:00000CEE                 mov     dword ptr [ecx+18h], 0
.text$mn:00000CF5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CFC                 mov     eax, [ebp+var_10]
.text$mn:00000CFF                 mov     ecx, [ebp+var_C]
.text$mn:00000D02                 mov     large fs:0, ecx
.text$mn:00000D09                 pop     ecx
.text$mn:00000D0A                 mov     esp, ebp
.text$mn:00000D0C                 pop     ebp
.text$mn:00000D0D                 retn
.text$mn:00000D0D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000D0D
.text$mn:00000D0D ; ---------------------------------------------------------------------------
.text$mn:00000D0E                 align 10h
.text$mn:00000D0E _text$mn        ends
.text$mn:00000D0E
.text$x:00000D10 ; ===========================================================================
.text$x:00000D10
.text$x:00000D10 ; Segment type: Pure code
.text$x:00000D10 ; Segment permissions: Read/Execute
.text$x:00000D10 _text$x         segment para public 'CODE' use32
.text$x:00000D10                 assume cs:_text$x
.text$x:00000D10                 ;org 0D10h
.text$x:00000D10 ; COMDAT (pick associative to section at CAC)
.text$x:00000D10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000D10
.text$x:00000D10 ; =============== S U B R O U T I N E =======================================
.text$x:00000D10
.text$x:00000D10
.text$x:00000D10 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000D10                                         ; DATA XREF: .xdata$x:00002808o
.text$x:00000D10                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D13                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000D13 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000D13
.text$x:00000D18
.text$x:00000D18 ; =============== S U B R O U T I N E =======================================
.text$x:00000D18
.text$x:00000D18
.text$x:00000D18 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000D18                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000D18
.text$x:00000D18 arg_4           = dword ptr  8
.text$x:00000D18
.text$x:00000D18                 mov     edx, [esp+arg_4]
.text$x:00000D1C                 lea     eax, [edx+0Ch]
.text$x:00000D1F                 mov     ecx, [edx-8]
.text$x:00000D22                 xor     ecx, eax
.text$x:00000D24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D29                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000D2E                 jmp     ___CxxFrameHandler3
.text$x:00000D2E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000D2E
.text$x:00000D2E ; ---------------------------------------------------------------------------
.text$x:00000D33                 align 4
.text$x:00000D33 _text$x         ends
.text$x:00000D33
.text$mn:00000D34 ; ===========================================================================
.text$mn:00000D34
.text$mn:00000D34 ; Segment type: Pure code
.text$mn:00000D34 ; Segment permissions: Read/Execute
.text$mn:00000D34 _text$mn        segment para public 'CODE' use32
.text$mn:00000D34                 assume cs:_text$mn
.text$mn:00000D34                 ;org 0D34h
.text$mn:00000D34 ; COMDAT (pick any)
.text$mn:00000D34                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D34
.text$mn:00000D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D34
.text$mn:00000D34 ; Attributes: bp-based frame
.text$mn:00000D34
.text$mn:00000D34 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000D34                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000D34 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000D34                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000D34
.text$mn:00000D34 var_4           = dword ptr -4
.text$mn:00000D34
.text$mn:00000D34                 push    ebp
.text$mn:00000D35                 mov     ebp, esp
.text$mn:00000D37                 push    ecx
.text$mn:00000D38                 mov     [ebp+var_4], ecx
.text$mn:00000D3B                 mov     ecx, [ebp+var_4]
.text$mn:00000D3E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000D43                 mov     eax, [ebp+var_4]
.text$mn:00000D46                 mov     esp, ebp
.text$mn:00000D48                 pop     ebp
.text$mn:00000D49                 retn
.text$mn:00000D49 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000D49
.text$mn:00000D49 ; ---------------------------------------------------------------------------
.text$mn:00000D4A                 align 4
.text$mn:00000D4A _text$mn        ends
.text$mn:00000D4A
.text$mn:00000D4C ; ===========================================================================
.text$mn:00000D4C
.text$mn:00000D4C ; Segment type: Pure code
.text$mn:00000D4C ; Segment permissions: Read/Execute
.text$mn:00000D4C _text$mn        segment para public 'CODE' use32
.text$mn:00000D4C                 assume cs:_text$mn
.text$mn:00000D4C                 ;org 0D4Ch
.text$mn:00000D4C ; COMDAT (pick any)
.text$mn:00000D4C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D4C
.text$mn:00000D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D4C
.text$mn:00000D4C ; Attributes: bp-based frame
.text$mn:00000D4C
.text$mn:00000D4C ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00000D4C                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00000D4C ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00000D4C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00000D4C
.text$mn:00000D4C var_4           = dword ptr -4
.text$mn:00000D4C
.text$mn:00000D4C                 push    ebp
.text$mn:00000D4D                 mov     ebp, esp
.text$mn:00000D4F                 push    ecx
.text$mn:00000D50                 mov     [ebp+var_4], ecx
.text$mn:00000D53                 mov     ecx, [ebp+var_4]
.text$mn:00000D56                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00000D5B                 mov     eax, [ebp+var_4]
.text$mn:00000D5E                 mov     esp, ebp
.text$mn:00000D60                 pop     ebp
.text$mn:00000D61                 retn
.text$mn:00000D61 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00000D61
.text$mn:00000D61 ; ---------------------------------------------------------------------------
.text$mn:00000D62                 align 4
.text$mn:00000D62 _text$mn        ends
.text$mn:00000D62
.text$mn:00000D64 ; ===========================================================================
.text$mn:00000D64
.text$mn:00000D64 ; Segment type: Pure code
.text$mn:00000D64 ; Segment permissions: Read/Execute
.text$mn:00000D64 _text$mn        segment para public 'CODE' use32
.text$mn:00000D64                 assume cs:_text$mn
.text$mn:00000D64                 ;org 0D64h
.text$mn:00000D64 ; COMDAT (pick any)
.text$mn:00000D64                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D64
.text$mn:00000D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D64
.text$mn:00000D64 ; Attributes: bp-based frame
.text$mn:00000D64
.text$mn:00000D64 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000D64                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000D64 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000D64                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000D64
.text$mn:00000D64 var_4           = dword ptr -4
.text$mn:00000D64
.text$mn:00000D64                 push    ebp
.text$mn:00000D65                 mov     ebp, esp
.text$mn:00000D67                 push    ecx
.text$mn:00000D68                 mov     [ebp+var_4], ecx
.text$mn:00000D6B                 mov     eax, [ebp+var_4]
.text$mn:00000D6E                 mov     esp, ebp
.text$mn:00000D70                 pop     ebp
.text$mn:00000D71                 retn
.text$mn:00000D71 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000D71
.text$mn:00000D71 ; ---------------------------------------------------------------------------
.text$mn:00000D72                 align 4
.text$mn:00000D72 _text$mn        ends
.text$mn:00000D72
.text$mn:00000D74 ; ===========================================================================
.text$mn:00000D74
.text$mn:00000D74 ; Segment type: Pure code
.text$mn:00000D74 ; Segment permissions: Read/Execute
.text$mn:00000D74 _text$mn        segment para public 'CODE' use32
.text$mn:00000D74                 assume cs:_text$mn
.text$mn:00000D74                 ;org 0D74h
.text$mn:00000D74 ; COMDAT (pick any)
.text$mn:00000D74                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D74
.text$mn:00000D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D74
.text$mn:00000D74 ; Attributes: bp-based frame
.text$mn:00000D74
.text$mn:00000D74 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000D74                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000D74 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000D74                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000D74                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp ...
.text$mn:00000D74
.text$mn:00000D74 var_4           = dword ptr -4
.text$mn:00000D74
.text$mn:00000D74                 push    ebp
.text$mn:00000D75                 mov     ebp, esp
.text$mn:00000D77                 push    ecx
.text$mn:00000D78                 mov     [ebp+var_4], ecx
.text$mn:00000D7B                 mov     eax, [ebp+var_4]
.text$mn:00000D7E                 mov     esp, ebp
.text$mn:00000D80                 pop     ebp
.text$mn:00000D81                 retn
.text$mn:00000D81 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000D81
.text$mn:00000D81 ; ---------------------------------------------------------------------------
.text$mn:00000D82                 align 4
.text$mn:00000D82 _text$mn        ends
.text$mn:00000D82
.text$mn:00000D84 ; ===========================================================================
.text$mn:00000D84
.text$mn:00000D84 ; Segment type: Pure code
.text$mn:00000D84 ; Segment permissions: Read/Execute
.text$mn:00000D84 _text$mn        segment para public 'CODE' use32
.text$mn:00000D84                 assume cs:_text$mn
.text$mn:00000D84                 ;org 0D84h
.text$mn:00000D84 ; COMDAT (pick any)
.text$mn:00000D84                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D84
.text$mn:00000D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D84
.text$mn:00000D84 ; Attributes: bp-based frame
.text$mn:00000D84
.text$mn:00000D84 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00000D84                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00000D84 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00000D84
.text$mn:00000D84 var_4           = dword ptr -4
.text$mn:00000D84
.text$mn:00000D84                 push    ebp
.text$mn:00000D85                 mov     ebp, esp
.text$mn:00000D87                 push    ecx
.text$mn:00000D88                 mov     [ebp+var_4], ecx
.text$mn:00000D8B                 mov     eax, [ebp+var_4]
.text$mn:00000D8E                 mov     esp, ebp
.text$mn:00000D90                 pop     ebp
.text$mn:00000D91                 retn
.text$mn:00000D91 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00000D91
.text$mn:00000D91 ; ---------------------------------------------------------------------------
.text$mn:00000D92                 align 4
.text$mn:00000D92 _text$mn        ends
.text$mn:00000D92
.text$mn:00000D94 ; ===========================================================================
.text$mn:00000D94
.text$mn:00000D94 ; Segment type: Pure code
.text$mn:00000D94 ; Segment permissions: Read/Execute
.text$mn:00000D94 _text$mn        segment para public 'CODE' use32
.text$mn:00000D94                 assume cs:_text$mn
.text$mn:00000D94                 ;org 0D94h
.text$mn:00000D94 ; COMDAT (pick any)
.text$mn:00000D94                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D94
.text$mn:00000D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D94
.text$mn:00000D94 ; Attributes: bp-based frame
.text$mn:00000D94
.text$mn:00000D94 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000D94                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000D94 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000D94                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000D94                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000D94
.text$mn:00000D94 var_14          = dword ptr -14h
.text$mn:00000D94 var_D           = byte ptr -0Dh
.text$mn:00000D94 var_C           = dword ptr -0Ch
.text$mn:00000D94 var_4           = dword ptr -4
.text$mn:00000D94 Str             = dword ptr  8
.text$mn:00000D94
.text$mn:00000D94                 push    ebp
.text$mn:00000D95                 mov     ebp, esp
.text$mn:00000D97                 push    0FFFFFFFFh
.text$mn:00000D99                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000D9E                 mov     eax, large fs:0
.text$mn:00000DA4                 push    eax
.text$mn:00000DA5                 sub     esp, 8
.text$mn:00000DA8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DAD                 xor     eax, ebp
.text$mn:00000DAF                 push    eax
.text$mn:00000DB0                 lea     eax, [ebp+var_C]
.text$mn:00000DB3                 mov     large fs:0, eax
.text$mn:00000DB9                 mov     [ebp+var_14], ecx
.text$mn:00000DBC                 lea     ecx, [ebp+var_D]
.text$mn:00000DBF                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000DC4                 push    eax
.text$mn:00000DC5                 mov     ecx, [ebp+var_14]
.text$mn:00000DC8                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000DCD                 mov     [ebp+var_4], 0
.text$mn:00000DD4                 push    0               ; Size
.text$mn:00000DD6                 push    0               ; char
.text$mn:00000DD8                 mov     ecx, [ebp+var_14]
.text$mn:00000DDB                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000DE0                 mov     eax, [ebp+Str]
.text$mn:00000DE3                 push    eax             ; Str
.text$mn:00000DE4                 mov     ecx, [ebp+var_14]
.text$mn:00000DE7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000DEC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000DF3                 mov     eax, [ebp+var_14]
.text$mn:00000DF6                 mov     ecx, [ebp+var_C]
.text$mn:00000DF9                 mov     large fs:0, ecx
.text$mn:00000E00                 pop     ecx
.text$mn:00000E01                 mov     esp, ebp
.text$mn:00000E03                 pop     ebp
.text$mn:00000E04                 retn    4
.text$mn:00000E04 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000E04
.text$mn:00000E04 ; ---------------------------------------------------------------------------
.text$mn:00000E07                 align 4
.text$mn:00000E07 _text$mn        ends
.text$mn:00000E07
.text$x:00000E08 ; ===========================================================================
.text$x:00000E08
.text$x:00000E08 ; Segment type: Pure code
.text$x:00000E08 ; Segment permissions: Read/Execute
.text$x:00000E08 _text$x         segment para public 'CODE' use32
.text$x:00000E08                 assume cs:_text$x
.text$x:00000E08                 ;org 0E08h
.text$x:00000E08 ; COMDAT (pick associative to section at D94)
.text$x:00000E08                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000E08
.text$x:00000E08 ; =============== S U B R O U T I N E =======================================
.text$x:00000E08
.text$x:00000E08
.text$x:00000E08 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000E08                                         ; DATA XREF: .xdata$x:000028B8o
.text$x:00000E08                 mov     ecx, [ebp-14h]
.text$x:00000E0B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000E0B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000E0B
.text$x:00000E10
.text$x:00000E10 ; =============== S U B R O U T I N E =======================================
.text$x:00000E10
.text$x:00000E10
.text$x:00000E10 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000E10                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000E10
.text$x:00000E10 arg_4           = dword ptr  8
.text$x:00000E10
.text$x:00000E10                 mov     edx, [esp+arg_4]
.text$x:00000E14                 lea     eax, [edx+0Ch]
.text$x:00000E17                 mov     ecx, [edx-0Ch]
.text$x:00000E1A                 xor     ecx, eax
.text$x:00000E1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E21                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000E26                 jmp     ___CxxFrameHandler3
.text$x:00000E26 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000E26
.text$x:00000E26 ; ---------------------------------------------------------------------------
.text$x:00000E2B                 align 4
.text$x:00000E2B _text$x         ends
.text$x:00000E2B
.text$mn:00000E2C ; ===========================================================================
.text$mn:00000E2C
.text$mn:00000E2C ; Segment type: Pure code
.text$mn:00000E2C ; Segment permissions: Read/Execute
.text$mn:00000E2C _text$mn        segment para public 'CODE' use32
.text$mn:00000E2C                 assume cs:_text$mn
.text$mn:00000E2C                 ;org 0E2Ch
.text$mn:00000E2C ; COMDAT (pick any)
.text$mn:00000E2C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E2C
.text$mn:00000E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E2C
.text$mn:00000E2C ; Attributes: bp-based frame
.text$mn:00000E2C
.text$mn:00000E2C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000E2C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000E2C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000E2C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000E2C
.text$mn:00000E2C var_4           = dword ptr -4
.text$mn:00000E2C
.text$mn:00000E2C                 push    ebp
.text$mn:00000E2D                 mov     ebp, esp
.text$mn:00000E2F                 push    ecx
.text$mn:00000E30                 mov     [ebp+var_4], ecx
.text$mn:00000E33                 mov     eax, [ebp+var_4]
.text$mn:00000E36                 mov     dword ptr [eax], 0
.text$mn:00000E3C                 mov     eax, [ebp+var_4]
.text$mn:00000E3F                 mov     esp, ebp
.text$mn:00000E41                 pop     ebp
.text$mn:00000E42                 retn
.text$mn:00000E42 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000E42
.text$mn:00000E42 ; ---------------------------------------------------------------------------
.text$mn:00000E43                 align 4
.text$mn:00000E43 _text$mn        ends
.text$mn:00000E43
.text$mn:00000E44 ; ===========================================================================
.text$mn:00000E44
.text$mn:00000E44 ; Segment type: Pure code
.text$mn:00000E44 ; Segment permissions: Read/Execute
.text$mn:00000E44 _text$mn        segment para public 'CODE' use32
.text$mn:00000E44                 assume cs:_text$mn
.text$mn:00000E44                 ;org 0E44h
.text$mn:00000E44 ; COMDAT (pick any)
.text$mn:00000E44                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E44
.text$mn:00000E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E44
.text$mn:00000E44 ; Attributes: bp-based frame
.text$mn:00000E44
.text$mn:00000E44 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000E44                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000E44 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000E44                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000E44
.text$mn:00000E44 var_4           = dword ptr -4
.text$mn:00000E44
.text$mn:00000E44                 push    ebp
.text$mn:00000E45                 mov     ebp, esp
.text$mn:00000E47                 push    ecx
.text$mn:00000E48                 mov     [ebp+var_4], ecx
.text$mn:00000E4B                 mov     eax, [ebp+var_4]
.text$mn:00000E4E                 mov     dword ptr [eax], 0
.text$mn:00000E54                 mov     ecx, [ebp+var_4]
.text$mn:00000E57                 mov     dword ptr [ecx+4], 0
.text$mn:00000E5E                 mov     eax, [ebp+var_4]
.text$mn:00000E61                 mov     esp, ebp
.text$mn:00000E63                 pop     ebp
.text$mn:00000E64                 retn
.text$mn:00000E64 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000E64
.text$mn:00000E64 ; ---------------------------------------------------------------------------
.text$mn:00000E65                 align 4
.text$mn:00000E65 _text$mn        ends
.text$mn:00000E65
.text$mn:00000E68 ; ===========================================================================
.text$mn:00000E68
.text$mn:00000E68 ; Segment type: Pure code
.text$mn:00000E68 ; Segment permissions: Read/Execute
.text$mn:00000E68 _text$mn        segment para public 'CODE' use32
.text$mn:00000E68                 assume cs:_text$mn
.text$mn:00000E68                 ;org 0E68h
.text$mn:00000E68 ; COMDAT (pick any)
.text$mn:00000E68                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E68
.text$mn:00000E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E68
.text$mn:00000E68 ; Attributes: bp-based frame
.text$mn:00000E68
.text$mn:00000E68 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000E68                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000E68 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000E68                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000E68                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000E68
.text$mn:00000E68 var_10          = dword ptr -10h
.text$mn:00000E68 var_C           = dword ptr -0Ch
.text$mn:00000E68 var_4           = dword ptr -4
.text$mn:00000E68
.text$mn:00000E68                 push    ebp
.text$mn:00000E69                 mov     ebp, esp
.text$mn:00000E6B                 push    0FFFFFFFFh
.text$mn:00000E6D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000E72                 mov     eax, large fs:0
.text$mn:00000E78                 push    eax
.text$mn:00000E79                 push    ecx
.text$mn:00000E7A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E7F                 xor     eax, ebp
.text$mn:00000E81                 push    eax
.text$mn:00000E82                 lea     eax, [ebp+var_C]
.text$mn:00000E85                 mov     large fs:0, eax
.text$mn:00000E8B                 mov     [ebp+var_10], ecx
.text$mn:00000E8E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E91                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000E96                 mov     [ebp+var_4], 0
.text$mn:00000E9D                 mov     eax, [ebp+var_10]
.text$mn:00000EA0                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000EA6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EAD                 mov     eax, [ebp+var_10]
.text$mn:00000EB0                 mov     ecx, [ebp+var_C]
.text$mn:00000EB3                 mov     large fs:0, ecx
.text$mn:00000EBA                 pop     ecx
.text$mn:00000EBB                 mov     esp, ebp
.text$mn:00000EBD                 pop     ebp
.text$mn:00000EBE                 retn
.text$mn:00000EBE ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000EBE
.text$mn:00000EBE ; ---------------------------------------------------------------------------
.text$mn:00000EBF                 align 10h
.text$mn:00000EBF _text$mn        ends
.text$mn:00000EBF
.text$x:00000EC0 ; ===========================================================================
.text$x:00000EC0
.text$x:00000EC0 ; Segment type: Pure code
.text$x:00000EC0 ; Segment permissions: Read/Execute
.text$x:00000EC0 _text$x         segment para public 'CODE' use32
.text$x:00000EC0                 assume cs:_text$x
.text$x:00000EC0                 ;org 0EC0h
.text$x:00000EC0 ; COMDAT (pick associative to section at E68)
.text$x:00000EC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000EC0
.text$x:00000EC0 ; =============== S U B R O U T I N E =======================================
.text$x:00000EC0
.text$x:00000EC0
.text$x:00000EC0 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000EC0                                         ; DATA XREF: .xdata$x:0000299Co
.text$x:00000EC0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000EC3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000EC3 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000EC3
.text$x:00000EC8
.text$x:00000EC8 ; =============== S U B R O U T I N E =======================================
.text$x:00000EC8
.text$x:00000EC8
.text$x:00000EC8 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000EC8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000EC8
.text$x:00000EC8 arg_4           = dword ptr  8
.text$x:00000EC8
.text$x:00000EC8                 mov     edx, [esp+arg_4]
.text$x:00000ECC                 lea     eax, [edx+0Ch]
.text$x:00000ECF                 mov     ecx, [edx-8]
.text$x:00000ED2                 xor     ecx, eax
.text$x:00000ED4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000ED9                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000EDE                 jmp     ___CxxFrameHandler3
.text$x:00000EDE __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000EDE
.text$x:00000EDE ; ---------------------------------------------------------------------------
.text$x:00000EE3                 align 4
.text$x:00000EE3 _text$x         ends
.text$x:00000EE3
.text$mn:00000EE4 ; ===========================================================================
.text$mn:00000EE4
.text$mn:00000EE4 ; Segment type: Pure code
.text$mn:00000EE4 ; Segment permissions: Read/Execute
.text$mn:00000EE4 _text$mn        segment para public 'CODE' use32
.text$mn:00000EE4                 assume cs:_text$mn
.text$mn:00000EE4                 ;org 0EE4h
.text$mn:00000EE4 ; COMDAT (pick any)
.text$mn:00000EE4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000EE4
.text$mn:00000EE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EE4
.text$mn:00000EE4 ; Attributes: bp-based frame
.text$mn:00000EE4
.text$mn:00000EE4 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000EE4                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000EE4 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000EE4                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000EE4
.text$mn:00000EE4 var_10          = dword ptr -10h
.text$mn:00000EE4 var_C           = dword ptr -0Ch
.text$mn:00000EE4 var_4           = dword ptr -4
.text$mn:00000EE4
.text$mn:00000EE4                 push    ebp
.text$mn:00000EE5                 mov     ebp, esp
.text$mn:00000EE7                 push    0FFFFFFFFh
.text$mn:00000EE9                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000EEE                 mov     eax, large fs:0
.text$mn:00000EF4                 push    eax
.text$mn:00000EF5                 push    ecx
.text$mn:00000EF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EFB                 xor     eax, ebp
.text$mn:00000EFD                 push    eax
.text$mn:00000EFE                 lea     eax, [ebp+var_C]
.text$mn:00000F01                 mov     large fs:0, eax
.text$mn:00000F07                 mov     [ebp+var_10], ecx
.text$mn:00000F0A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F0D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000F12                 mov     [ebp+var_4], 0
.text$mn:00000F19                 mov     eax, [ebp+var_10]
.text$mn:00000F1C                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000F22                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F29                 mov     eax, [ebp+var_10]
.text$mn:00000F2C                 mov     ecx, [ebp+var_C]
.text$mn:00000F2F                 mov     large fs:0, ecx
.text$mn:00000F36                 pop     ecx
.text$mn:00000F37                 mov     esp, ebp
.text$mn:00000F39                 pop     ebp
.text$mn:00000F3A                 retn
.text$mn:00000F3A ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000F3A
.text$mn:00000F3A ; ---------------------------------------------------------------------------
.text$mn:00000F3B                 align 4
.text$mn:00000F3B _text$mn        ends
.text$mn:00000F3B
.text$x:00000F3C ; ===========================================================================
.text$x:00000F3C
.text$x:00000F3C ; Segment type: Pure code
.text$x:00000F3C ; Segment permissions: Read/Execute
.text$x:00000F3C _text$x         segment para public 'CODE' use32
.text$x:00000F3C                 assume cs:_text$x
.text$x:00000F3C                 ;org 0F3Ch
.text$x:00000F3C ; COMDAT (pick associative to section at EE4)
.text$x:00000F3C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000F3C
.text$x:00000F3C ; =============== S U B R O U T I N E =======================================
.text$x:00000F3C
.text$x:00000F3C
.text$x:00000F3C __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000F3C                                         ; DATA XREF: .xdata$x:00002A20o
.text$x:00000F3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F3F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000F3F __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000F3F
.text$x:00000F44
.text$x:00000F44 ; =============== S U B R O U T I N E =======================================
.text$x:00000F44
.text$x:00000F44
.text$x:00000F44 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000F44                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000F44
.text$x:00000F44 arg_4           = dword ptr  8
.text$x:00000F44
.text$x:00000F44                 mov     edx, [esp+arg_4]
.text$x:00000F48                 lea     eax, [edx+0Ch]
.text$x:00000F4B                 mov     ecx, [edx-8]
.text$x:00000F4E                 xor     ecx, eax
.text$x:00000F50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F55                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000F5A                 jmp     ___CxxFrameHandler3
.text$x:00000F5A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000F5A
.text$x:00000F5A ; ---------------------------------------------------------------------------
.text$x:00000F5F                 align 10h
.text$x:00000F5F _text$x         ends
.text$x:00000F5F
.text$mn:00000F60 ; ===========================================================================
.text$mn:00000F60
.text$mn:00000F60 ; Segment type: Pure code
.text$mn:00000F60 ; Segment permissions: Read/Execute
.text$mn:00000F60 _text$mn        segment para public 'CODE' use32
.text$mn:00000F60                 assume cs:_text$mn
.text$mn:00000F60                 ;org 0F60h
.text$mn:00000F60 ; COMDAT (pick any)
.text$mn:00000F60                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F60
.text$mn:00000F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F60
.text$mn:00000F60 ; Attributes: bp-based frame
.text$mn:00000F60
.text$mn:00000F60 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000F60                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000F60 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000F60                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000F60
.text$mn:00000F60 var_10          = dword ptr -10h
.text$mn:00000F60 var_C           = dword ptr -0Ch
.text$mn:00000F60 var_4           = dword ptr -4
.text$mn:00000F60
.text$mn:00000F60                 push    ebp
.text$mn:00000F61                 mov     ebp, esp
.text$mn:00000F63                 push    0FFFFFFFFh
.text$mn:00000F65                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000F6A                 mov     eax, large fs:0
.text$mn:00000F70                 push    eax
.text$mn:00000F71                 push    ecx
.text$mn:00000F72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F77                 xor     eax, ebp
.text$mn:00000F79                 push    eax
.text$mn:00000F7A                 lea     eax, [ebp+var_C]
.text$mn:00000F7D                 mov     large fs:0, eax
.text$mn:00000F83                 mov     [ebp+var_10], ecx
.text$mn:00000F86                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F89                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000F8E                 mov     [ebp+var_4], 0
.text$mn:00000F95                 mov     eax, [ebp+var_10]
.text$mn:00000F98                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000F9E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FA5                 mov     eax, [ebp+var_10]
.text$mn:00000FA8                 mov     ecx, [ebp+var_C]
.text$mn:00000FAB                 mov     large fs:0, ecx
.text$mn:00000FB2                 pop     ecx
.text$mn:00000FB3                 mov     esp, ebp
.text$mn:00000FB5                 pop     ebp
.text$mn:00000FB6                 retn
.text$mn:00000FB6 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000FB6
.text$mn:00000FB6 ; ---------------------------------------------------------------------------
.text$mn:00000FB7                 align 4
.text$mn:00000FB7 _text$mn        ends
.text$mn:00000FB7
.text$x:00000FB8 ; ===========================================================================
.text$x:00000FB8
.text$x:00000FB8 ; Segment type: Pure code
.text$x:00000FB8 ; Segment permissions: Read/Execute
.text$x:00000FB8 _text$x         segment para public 'CODE' use32
.text$x:00000FB8                 assume cs:_text$x
.text$x:00000FB8                 ;org 0FB8h
.text$x:00000FB8 ; COMDAT (pick associative to section at F60)
.text$x:00000FB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000FB8
.text$x:00000FB8 ; =============== S U B R O U T I N E =======================================
.text$x:00000FB8
.text$x:00000FB8
.text$x:00000FB8 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000FB8                                         ; DATA XREF: .xdata$x:00002AA4o
.text$x:00000FB8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000FBB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000FBB __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000FBB
.text$x:00000FC0
.text$x:00000FC0 ; =============== S U B R O U T I N E =======================================
.text$x:00000FC0
.text$x:00000FC0
.text$x:00000FC0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000FC0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000FC0
.text$x:00000FC0 arg_4           = dword ptr  8
.text$x:00000FC0
.text$x:00000FC0                 mov     edx, [esp+arg_4]
.text$x:00000FC4                 lea     eax, [edx+0Ch]
.text$x:00000FC7                 mov     ecx, [edx-8]
.text$x:00000FCA                 xor     ecx, eax
.text$x:00000FCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FD1                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000FD6                 jmp     ___CxxFrameHandler3
.text$x:00000FD6 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000FD6
.text$x:00000FD6 ; ---------------------------------------------------------------------------
.text$x:00000FDB                 align 4
.text$x:00000FDB _text$x         ends
.text$x:00000FDB
.text$mn:00000FDC ; ===========================================================================
.text$mn:00000FDC
.text$mn:00000FDC ; Segment type: Pure code
.text$mn:00000FDC ; Segment permissions: Read/Execute
.text$mn:00000FDC _text$mn        segment para public 'CODE' use32
.text$mn:00000FDC                 assume cs:_text$mn
.text$mn:00000FDC                 ;org 0FDCh
.text$mn:00000FDC ; COMDAT (pick any)
.text$mn:00000FDC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000FDC
.text$mn:00000FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FDC
.text$mn:00000FDC ; Attributes: bp-based frame
.text$mn:00000FDC
.text$mn:00000FDC ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000FDC                 public ??0error_category@std@@QAE@XZ
.text$mn:00000FDC ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000FDC
.text$mn:00000FDC var_4           = dword ptr -4
.text$mn:00000FDC
.text$mn:00000FDC                 push    ebp
.text$mn:00000FDD                 mov     ebp, esp
.text$mn:00000FDF                 push    ecx
.text$mn:00000FE0                 mov     [ebp+var_4], ecx
.text$mn:00000FE3                 mov     eax, [ebp+var_4]
.text$mn:00000FE6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000FEC                 mov     eax, [ebp+var_4]
.text$mn:00000FEF                 mov     esp, ebp
.text$mn:00000FF1                 pop     ebp
.text$mn:00000FF2                 retn
.text$mn:00000FF2 ??0error_category@std@@QAE@XZ endp
.text$mn:00000FF2
.text$mn:00000FF2 ; ---------------------------------------------------------------------------
.text$mn:00000FF3                 align 4
.text$mn:00000FF3 _text$mn        ends
.text$mn:00000FF3
.text$mn:00000FF4 ; ===========================================================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Segment type: Pure code
.text$mn:00000FF4 ; Segment permissions: Read/Execute
.text$mn:00000FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FF4                 assume cs:_text$mn
.text$mn:00000FF4                 ;org 0FF4h
.text$mn:00000FF4 ; COMDAT (pick any)
.text$mn:00000FF4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000FF4
.text$mn:00000FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Attributes: bp-based frame
.text$mn:00000FF4
.text$mn:00000FF4 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000FF4                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000FF4 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000FF4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000FF4                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000FF4
.text$mn:00000FF4 var_4           = dword ptr -4
.text$mn:00000FF4 arg_0           = dword ptr  8
.text$mn:00000FF4 arg_4           = dword ptr  0Ch
.text$mn:00000FF4
.text$mn:00000FF4                 push    ebp
.text$mn:00000FF5                 mov     ebp, esp
.text$mn:00000FF7                 push    ecx
.text$mn:00000FF8                 mov     [ebp+var_4], ecx
.text$mn:00000FFB                 mov     eax, [ebp+var_4]
.text$mn:00000FFE                 mov     ecx, [ebp+arg_0]
.text$mn:00001001                 mov     [eax], ecx
.text$mn:00001003                 mov     edx, [ebp+var_4]
.text$mn:00001006                 mov     eax, [ebp+arg_4]
.text$mn:00001009                 mov     [edx+4], eax
.text$mn:0000100C                 mov     eax, [ebp+var_4]
.text$mn:0000100F                 mov     esp, ebp
.text$mn:00001011                 pop     ebp
.text$mn:00001012                 retn    8
.text$mn:00001012 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00001012
.text$mn:00001012 ; ---------------------------------------------------------------------------
.text$mn:00001015                 align 4
.text$mn:00001015 _text$mn        ends
.text$mn:00001015
.text$mn:00001018 ; ===========================================================================
.text$mn:00001018
.text$mn:00001018 ; Segment type: Pure code
.text$mn:00001018 ; Segment permissions: Read/Execute
.text$mn:00001018 _text$mn        segment para public 'CODE' use32
.text$mn:00001018                 assume cs:_text$mn
.text$mn:00001018                 ;org 1018h
.text$mn:00001018 ; COMDAT (pick any)
.text$mn:00001018                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001018
.text$mn:00001018 ; =============== S U B R O U T I N E =======================================
.text$mn:00001018
.text$mn:00001018 ; Attributes: bp-based frame
.text$mn:00001018
.text$mn:00001018 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001018                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001018 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001018                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001018
.text$mn:00001018 var_4           = dword ptr -4
.text$mn:00001018 arg_0           = dword ptr  8
.text$mn:00001018
.text$mn:00001018                 push    ebp
.text$mn:00001019                 mov     ebp, esp
.text$mn:0000101B                 push    ecx
.text$mn:0000101C                 mov     [ebp+var_4], ecx
.text$mn:0000101F                 mov     eax, [ebp+var_4]
.text$mn:00001022                 mov     ecx, [ebp+arg_0]
.text$mn:00001025                 mov     [eax], ecx
.text$mn:00001027                 mov     eax, [ebp+var_4]
.text$mn:0000102A                 mov     esp, ebp
.text$mn:0000102C                 pop     ebp
.text$mn:0000102D                 retn    4
.text$mn:0000102D ??0id@locale@std@@QAE@I@Z endp
.text$mn:0000102D
.text$mn:0000102D _text$mn        ends
.text$mn:0000102D
.text$mn:00001030 ; ===========================================================================
.text$mn:00001030
.text$mn:00001030 ; Segment type: Pure code
.text$mn:00001030 ; Segment permissions: Read/Execute
.text$mn:00001030 _text$mn        segment para public 'CODE' use32
.text$mn:00001030                 assume cs:_text$mn
.text$mn:00001030                 ;org 1030h
.text$mn:00001030 ; COMDAT (pick any)
.text$mn:00001030                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001030
.text$mn:00001030 ; =============== S U B R O U T I N E =======================================
.text$mn:00001030
.text$mn:00001030 ; Attributes: bp-based frame
.text$mn:00001030
.text$mn:00001030 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001030                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001030 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001030                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001030                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001030
.text$mn:00001030 var_10          = dword ptr -10h
.text$mn:00001030 var_C           = dword ptr -0Ch
.text$mn:00001030 var_4           = dword ptr -4
.text$mn:00001030
.text$mn:00001030                 push    ebp
.text$mn:00001031                 mov     ebp, esp
.text$mn:00001033                 push    0FFFFFFFFh
.text$mn:00001035                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000103A                 mov     eax, large fs:0
.text$mn:00001040                 push    eax
.text$mn:00001041                 push    ecx
.text$mn:00001042                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001047                 xor     eax, ebp
.text$mn:00001049                 push    eax
.text$mn:0000104A                 lea     eax, [ebp+var_C]
.text$mn:0000104D                 mov     large fs:0, eax
.text$mn:00001053                 mov     [ebp+var_10], ecx
.text$mn:00001056                 mov     [ebp+var_4], 0
.text$mn:0000105D                 mov     ecx, [ebp+var_10]
.text$mn:00001060                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001065                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000106C                 mov     ecx, [ebp+var_10]
.text$mn:0000106F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001074                 mov     ecx, [ebp+var_C]
.text$mn:00001077                 mov     large fs:0, ecx
.text$mn:0000107E                 pop     ecx
.text$mn:0000107F                 mov     esp, ebp
.text$mn:00001081                 pop     ebp
.text$mn:00001082                 retn
.text$mn:00001082 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001082
.text$mn:00001082 ; ---------------------------------------------------------------------------
.text$mn:00001083                 align 4
.text$mn:00001083 _text$mn        ends
.text$mn:00001083
.text$x:00001084 ; ===========================================================================
.text$x:00001084
.text$x:00001084 ; Segment type: Pure code
.text$x:00001084 ; Segment permissions: Read/Execute
.text$x:00001084 _text$x         segment para public 'CODE' use32
.text$x:00001084                 assume cs:_text$x
.text$x:00001084                 ;org 1084h
.text$x:00001084 ; COMDAT (pick associative to section at 1030)
.text$x:00001084                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001084
.text$x:00001084 ; =============== S U B R O U T I N E =======================================
.text$x:00001084
.text$x:00001084
.text$x:00001084 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001084                                         ; DATA XREF: .xdata$x:0000288Co
.text$x:00001084                 mov     ecx, [ebp-10h]
.text$x:00001087                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001087 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001087
.text$x:0000108C
.text$x:0000108C ; =============== S U B R O U T I N E =======================================
.text$x:0000108C
.text$x:0000108C
.text$x:0000108C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000108C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000108C
.text$x:0000108C arg_4           = dword ptr  8
.text$x:0000108C
.text$x:0000108C                 mov     edx, [esp+arg_4]
.text$x:00001090                 lea     eax, [edx+0Ch]
.text$x:00001093                 mov     ecx, [edx-8]
.text$x:00001096                 xor     ecx, eax
.text$x:00001098                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000109D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000010A2                 jmp     ___CxxFrameHandler3
.text$x:000010A2 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000010A2
.text$x:000010A2 ; ---------------------------------------------------------------------------
.text$x:000010A7                 align 4
.text$x:000010A7 _text$x         ends
.text$x:000010A7
.text$mn:000010A8 ; ===========================================================================
.text$mn:000010A8
.text$mn:000010A8 ; Segment type: Pure code
.text$mn:000010A8 ; Segment permissions: Read/Execute
.text$mn:000010A8 _text$mn        segment para public 'CODE' use32
.text$mn:000010A8                 assume cs:_text$mn
.text$mn:000010A8                 ;org 10A8h
.text$mn:000010A8 ; COMDAT (pick any)
.text$mn:000010A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000010A8
.text$mn:000010A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010A8
.text$mn:000010A8 ; Attributes: bp-based frame
.text$mn:000010A8
.text$mn:000010A8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:000010A8                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000010A8 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000010A8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+43p
.text$mn:000010A8                                         ; __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0+3j
.text$mn:000010A8
.text$mn:000010A8 var_10          = dword ptr -10h
.text$mn:000010A8 var_C           = dword ptr -0Ch
.text$mn:000010A8 var_4           = dword ptr -4
.text$mn:000010A8
.text$mn:000010A8                 push    ebp
.text$mn:000010A9                 mov     ebp, esp
.text$mn:000010AB                 push    0FFFFFFFFh
.text$mn:000010AD                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000010B2                 mov     eax, large fs:0
.text$mn:000010B8                 push    eax
.text$mn:000010B9                 push    ecx
.text$mn:000010BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010BF                 xor     eax, ebp
.text$mn:000010C1                 push    eax
.text$mn:000010C2                 lea     eax, [ebp+var_C]
.text$mn:000010C5                 mov     large fs:0, eax
.text$mn:000010CB                 mov     [ebp+var_10], ecx
.text$mn:000010CE                 mov     [ebp+var_4], 0
.text$mn:000010D5                 mov     ecx, [ebp+var_10]
.text$mn:000010D8                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000010DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010E4                 mov     ecx, [ebp+var_10]
.text$mn:000010E7                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000010EC                 mov     ecx, [ebp+var_C]
.text$mn:000010EF                 mov     large fs:0, ecx
.text$mn:000010F6                 pop     ecx
.text$mn:000010F7                 mov     esp, ebp
.text$mn:000010F9                 pop     ebp
.text$mn:000010FA                 retn
.text$mn:000010FA ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000010FA
.text$mn:000010FA ; ---------------------------------------------------------------------------
.text$mn:000010FB                 align 4
.text$mn:000010FB _text$mn        ends
.text$mn:000010FB
.text$x:000010FC ; ===========================================================================
.text$x:000010FC
.text$x:000010FC ; Segment type: Pure code
.text$x:000010FC ; Segment permissions: Read/Execute
.text$x:000010FC _text$x         segment para public 'CODE' use32
.text$x:000010FC                 assume cs:_text$x
.text$x:000010FC                 ;org 10FCh
.text$x:000010FC ; COMDAT (pick associative to section at 10A8)
.text$x:000010FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000010FC
.text$x:000010FC ; =============== S U B R O U T I N E =======================================
.text$x:000010FC
.text$x:000010FC
.text$x:000010FC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000010FC                                         ; DATA XREF: .xdata$x:00002B54o
.text$x:000010FC                 mov     ecx, [ebp-10h]
.text$x:000010FF                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000010FF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000010FF
.text$x:00001104
.text$x:00001104 ; =============== S U B R O U T I N E =======================================
.text$x:00001104
.text$x:00001104
.text$x:00001104 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001104                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00001104
.text$x:00001104 arg_4           = dword ptr  8
.text$x:00001104
.text$x:00001104                 mov     edx, [esp+arg_4]
.text$x:00001108                 lea     eax, [edx+0Ch]
.text$x:0000110B                 mov     ecx, [edx-8]
.text$x:0000110E                 xor     ecx, eax
.text$x:00001110                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001115                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000111A                 jmp     ___CxxFrameHandler3
.text$x:0000111A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000111A
.text$x:0000111A ; ---------------------------------------------------------------------------
.text$x:0000111F                 align 10h
.text$x:0000111F _text$x         ends
.text$x:0000111F
.text$mn:00001120 ; ===========================================================================
.text$mn:00001120
.text$mn:00001120 ; Segment type: Pure code
.text$mn:00001120 ; Segment permissions: Read/Execute
.text$mn:00001120 _text$mn        segment para public 'CODE' use32
.text$mn:00001120                 assume cs:_text$mn
.text$mn:00001120                 ;org 1120h
.text$mn:00001120 ; COMDAT (pick any)
.text$mn:00001120                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001120
.text$mn:00001120 ; =============== S U B R O U T I N E =======================================
.text$mn:00001120
.text$mn:00001120 ; Attributes: bp-based frame
.text$mn:00001120
.text$mn:00001120 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001120                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001120 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001120                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001120                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001120
.text$mn:00001120 var_10          = dword ptr -10h
.text$mn:00001120 var_C           = dword ptr -0Ch
.text$mn:00001120 var_4           = dword ptr -4
.text$mn:00001120
.text$mn:00001120                 push    ebp
.text$mn:00001121                 mov     ebp, esp
.text$mn:00001123                 push    0FFFFFFFFh
.text$mn:00001125                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000112A                 mov     eax, large fs:0
.text$mn:00001130                 push    eax
.text$mn:00001131                 push    ecx
.text$mn:00001132                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001137                 xor     eax, ebp
.text$mn:00001139                 push    eax
.text$mn:0000113A                 lea     eax, [ebp+var_C]
.text$mn:0000113D                 mov     large fs:0, eax
.text$mn:00001143                 mov     [ebp+var_10], ecx
.text$mn:00001146                 mov     [ebp+var_4], 0
.text$mn:0000114D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001154                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001157                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000115C                 mov     ecx, [ebp+var_C]
.text$mn:0000115F                 mov     large fs:0, ecx
.text$mn:00001166                 pop     ecx
.text$mn:00001167                 mov     esp, ebp
.text$mn:00001169                 pop     ebp
.text$mn:0000116A                 retn
.text$mn:0000116A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000116A
.text$mn:0000116A ; ---------------------------------------------------------------------------
.text$mn:0000116B                 align 4
.text$mn:0000116B _text$mn        ends
.text$mn:0000116B
.text$x:0000116C ; ===========================================================================
.text$x:0000116C
.text$x:0000116C ; Segment type: Pure code
.text$x:0000116C ; Segment permissions: Read/Execute
.text$x:0000116C _text$x         segment para public 'CODE' use32
.text$x:0000116C                 assume cs:_text$x
.text$x:0000116C                 ;org 116Ch
.text$x:0000116C ; COMDAT (pick associative to section at 1120)
.text$x:0000116C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000116C
.text$x:0000116C ; =============== S U B R O U T I N E =======================================
.text$x:0000116C
.text$x:0000116C
.text$x:0000116C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000116C                                         ; DATA XREF: .xdata$x:00002834o
.text$x:0000116C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000116F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000116F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000116F
.text$x:00001174
.text$x:00001174 ; =============== S U B R O U T I N E =======================================
.text$x:00001174
.text$x:00001174
.text$x:00001174 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001174                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001174
.text$x:00001174 arg_4           = dword ptr  8
.text$x:00001174
.text$x:00001174                 mov     edx, [esp+arg_4]
.text$x:00001178                 lea     eax, [edx+0Ch]
.text$x:0000117B                 mov     ecx, [edx-8]
.text$x:0000117E                 xor     ecx, eax
.text$x:00001180                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001185                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000118A                 jmp     ___CxxFrameHandler3
.text$x:0000118A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000118A
.text$x:0000118A ; ---------------------------------------------------------------------------
.text$x:0000118F                 align 10h
.text$x:0000118F _text$x         ends
.text$x:0000118F
.text$mn:00001190 ; ===========================================================================
.text$mn:00001190
.text$mn:00001190 ; Segment type: Pure code
.text$mn:00001190 ; Segment permissions: Read/Execute
.text$mn:00001190 _text$mn        segment para public 'CODE' use32
.text$mn:00001190                 assume cs:_text$mn
.text$mn:00001190                 ;org 1190h
.text$mn:00001190 ; COMDAT (pick any)
.text$mn:00001190                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001190
.text$mn:00001190 ; =============== S U B R O U T I N E =======================================
.text$mn:00001190
.text$mn:00001190 ; Attributes: bp-based frame
.text$mn:00001190
.text$mn:00001190 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00001190                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001190 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00001190                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp
.text$mn:00001190                                         ; __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00001190
.text$mn:00001190 var_10          = dword ptr -10h
.text$mn:00001190 var_C           = dword ptr -0Ch
.text$mn:00001190 var_4           = dword ptr -4
.text$mn:00001190
.text$mn:00001190                 push    ebp
.text$mn:00001191                 mov     ebp, esp
.text$mn:00001193                 push    0FFFFFFFFh
.text$mn:00001195                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000119A                 mov     eax, large fs:0
.text$mn:000011A0                 push    eax
.text$mn:000011A1                 push    ecx
.text$mn:000011A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000011A7                 xor     eax, ebp
.text$mn:000011A9                 push    eax
.text$mn:000011AA                 lea     eax, [ebp+var_C]
.text$mn:000011AD                 mov     large fs:0, eax
.text$mn:000011B3                 mov     [ebp+var_10], ecx
.text$mn:000011B6                 mov     [ebp+var_4], 0
.text$mn:000011BD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011C4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000011C7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000011CC                 mov     ecx, [ebp+var_C]
.text$mn:000011CF                 mov     large fs:0, ecx
.text$mn:000011D6                 pop     ecx
.text$mn:000011D7                 mov     esp, ebp
.text$mn:000011D9                 pop     ebp
.text$mn:000011DA                 retn
.text$mn:000011DA ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000011DA
.text$mn:000011DA ; ---------------------------------------------------------------------------
.text$mn:000011DB                 align 4
.text$mn:000011DB _text$mn        ends
.text$mn:000011DB
.text$x:000011DC ; ===========================================================================
.text$x:000011DC
.text$x:000011DC ; Segment type: Pure code
.text$x:000011DC ; Segment permissions: Read/Execute
.text$x:000011DC _text$x         segment para public 'CODE' use32
.text$x:000011DC                 assume cs:_text$x
.text$x:000011DC                 ;org 11DCh
.text$x:000011DC ; COMDAT (pick associative to section at 1190)
.text$x:000011DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000011DC
.text$x:000011DC ; =============== S U B R O U T I N E =======================================
.text$x:000011DC
.text$x:000011DC
.text$x:000011DC __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000011DC                                         ; DATA XREF: .xdata$x:00002B28o
.text$x:000011DC                 mov     ecx, [ebp-10h]  ; this
.text$x:000011DF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000011DF __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000011DF
.text$x:000011E4
.text$x:000011E4 ; =============== S U B R O U T I N E =======================================
.text$x:000011E4
.text$x:000011E4
.text$x:000011E4 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:000011E4                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:000011E4
.text$x:000011E4 arg_4           = dword ptr  8
.text$x:000011E4
.text$x:000011E4                 mov     edx, [esp+arg_4]
.text$x:000011E8                 lea     eax, [edx+0Ch]
.text$x:000011EB                 mov     ecx, [edx-8]
.text$x:000011EE                 xor     ecx, eax
.text$x:000011F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011F5                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000011FA                 jmp     ___CxxFrameHandler3
.text$x:000011FA __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000011FA
.text$x:000011FA ; ---------------------------------------------------------------------------
.text$x:000011FF                 align 10h
.text$x:000011FF _text$x         ends
.text$x:000011FF
.text$mn:00001200 ; ===========================================================================
.text$mn:00001200
.text$mn:00001200 ; Segment type: Pure code
.text$mn:00001200 ; Segment permissions: Read/Execute
.text$mn:00001200 _text$mn        segment para public 'CODE' use32
.text$mn:00001200                 assume cs:_text$mn
.text$mn:00001200                 ;org 1200h
.text$mn:00001200 ; COMDAT (pick any)
.text$mn:00001200                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001200
.text$mn:00001200 ; =============== S U B R O U T I N E =======================================
.text$mn:00001200
.text$mn:00001200 ; Attributes: bp-based frame
.text$mn:00001200
.text$mn:00001200 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001200                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001200 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001200                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001200                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001200
.text$mn:00001200 var_10          = dword ptr -10h
.text$mn:00001200 var_C           = dword ptr -0Ch
.text$mn:00001200 var_4           = dword ptr -4
.text$mn:00001200
.text$mn:00001200                 push    ebp
.text$mn:00001201                 mov     ebp, esp
.text$mn:00001203                 push    0FFFFFFFFh
.text$mn:00001205                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000120A                 mov     eax, large fs:0
.text$mn:00001210                 push    eax
.text$mn:00001211                 push    ecx
.text$mn:00001212                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001217                 xor     eax, ebp
.text$mn:00001219                 push    eax
.text$mn:0000121A                 lea     eax, [ebp+var_C]
.text$mn:0000121D                 mov     large fs:0, eax
.text$mn:00001223                 mov     [ebp+var_10], ecx
.text$mn:00001226                 mov     [ebp+var_4], 0
.text$mn:0000122D                 push    0               ; Size
.text$mn:0000122F                 push    1               ; char
.text$mn:00001231                 mov     ecx, [ebp+var_10]
.text$mn:00001234                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001239                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001240                 mov     ecx, [ebp+var_10]
.text$mn:00001243                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001248                 mov     ecx, [ebp+var_C]
.text$mn:0000124B                 mov     large fs:0, ecx
.text$mn:00001252                 pop     ecx
.text$mn:00001253                 mov     esp, ebp
.text$mn:00001255                 pop     ebp
.text$mn:00001256                 retn
.text$mn:00001256 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001256
.text$mn:00001256 ; ---------------------------------------------------------------------------
.text$mn:00001257                 align 4
.text$mn:00001257 _text$mn        ends
.text$mn:00001257
.text$x:00001258 ; ===========================================================================
.text$x:00001258
.text$x:00001258 ; Segment type: Pure code
.text$x:00001258 ; Segment permissions: Read/Execute
.text$x:00001258 _text$x         segment para public 'CODE' use32
.text$x:00001258                 assume cs:_text$x
.text$x:00001258                 ;org 1258h
.text$x:00001258 ; COMDAT (pick associative to section at 1200)
.text$x:00001258                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001258
.text$x:00001258 ; =============== S U B R O U T I N E =======================================
.text$x:00001258
.text$x:00001258
.text$x:00001258 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001258                                         ; DATA XREF: .xdata$x:000028E4o
.text$x:00001258                 mov     ecx, [ebp-10h]
.text$x:0000125B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000125B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000125B
.text$x:00001260
.text$x:00001260 ; =============== S U B R O U T I N E =======================================
.text$x:00001260
.text$x:00001260
.text$x:00001260 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001260                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001260
.text$x:00001260 arg_4           = dword ptr  8
.text$x:00001260
.text$x:00001260                 mov     edx, [esp+arg_4]
.text$x:00001264                 lea     eax, [edx+0Ch]
.text$x:00001267                 mov     ecx, [edx-8]
.text$x:0000126A                 xor     ecx, eax
.text$x:0000126C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001271                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001276                 jmp     ___CxxFrameHandler3
.text$x:00001276 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001276
.text$x:00001276 ; ---------------------------------------------------------------------------
.text$x:0000127B                 align 4
.text$x:0000127B _text$x         ends
.text$x:0000127B
.text$mn:0000127C ; ===========================================================================
.text$mn:0000127C
.text$mn:0000127C ; Segment type: Pure code
.text$mn:0000127C ; Segment permissions: Read/Execute
.text$mn:0000127C _text$mn        segment para public 'CODE' use32
.text$mn:0000127C                 assume cs:_text$mn
.text$mn:0000127C                 ;org 127Ch
.text$mn:0000127C ; COMDAT (pick any)
.text$mn:0000127C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000127C
.text$mn:0000127C ; =============== S U B R O U T I N E =======================================
.text$mn:0000127C
.text$mn:0000127C ; Attributes: bp-based frame
.text$mn:0000127C
.text$mn:0000127C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:0000127C                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000127C ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:0000127C                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+325p
.text$mn:0000127C                                         ; __unwindfunclet$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z$0+3j ...
.text$mn:0000127C
.text$mn:0000127C var_10          = dword ptr -10h
.text$mn:0000127C var_C           = dword ptr -0Ch
.text$mn:0000127C var_4           = dword ptr -4
.text$mn:0000127C
.text$mn:0000127C                 push    ebp
.text$mn:0000127D                 mov     ebp, esp
.text$mn:0000127F                 push    0FFFFFFFFh
.text$mn:00001281                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001286                 mov     eax, large fs:0
.text$mn:0000128C                 push    eax
.text$mn:0000128D                 push    ecx
.text$mn:0000128E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001293                 xor     eax, ebp
.text$mn:00001295                 push    eax
.text$mn:00001296                 lea     eax, [ebp+var_C]
.text$mn:00001299                 mov     large fs:0, eax
.text$mn:0000129F                 mov     [ebp+var_10], ecx
.text$mn:000012A2                 mov     [ebp+var_4], 0
.text$mn:000012A9                 push    0
.text$mn:000012AB                 push    1
.text$mn:000012AD                 mov     ecx, [ebp+var_10]
.text$mn:000012B0                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000012B5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012BC                 mov     ecx, [ebp+var_10]
.text$mn:000012BF                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:000012C4                 mov     ecx, [ebp+var_C]
.text$mn:000012C7                 mov     large fs:0, ecx
.text$mn:000012CE                 pop     ecx
.text$mn:000012CF                 mov     esp, ebp
.text$mn:000012D1                 pop     ebp
.text$mn:000012D2                 retn
.text$mn:000012D2 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000012D2
.text$mn:000012D2 ; ---------------------------------------------------------------------------
.text$mn:000012D3                 align 4
.text$mn:000012D3 _text$mn        ends
.text$mn:000012D3
.text$x:000012D4 ; ===========================================================================
.text$x:000012D4
.text$x:000012D4 ; Segment type: Pure code
.text$x:000012D4 ; Segment permissions: Read/Execute
.text$x:000012D4 _text$x         segment para public 'CODE' use32
.text$x:000012D4                 assume cs:_text$x
.text$x:000012D4                 ;org 12D4h
.text$x:000012D4 ; COMDAT (pick associative to section at 127C)
.text$x:000012D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000012D4
.text$x:000012D4 ; =============== S U B R O U T I N E =======================================
.text$x:000012D4
.text$x:000012D4
.text$x:000012D4 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000012D4                                         ; DATA XREF: .xdata$x:00002B80o
.text$x:000012D4                 mov     ecx, [ebp-10h]
.text$x:000012D7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000012D7 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000012D7
.text$x:000012DC
.text$x:000012DC ; =============== S U B R O U T I N E =======================================
.text$x:000012DC
.text$x:000012DC
.text$x:000012DC __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000012DC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000012DC
.text$x:000012DC arg_4           = dword ptr  8
.text$x:000012DC
.text$x:000012DC                 mov     edx, [esp+arg_4]
.text$x:000012E0                 lea     eax, [edx+0Ch]
.text$x:000012E3                 mov     ecx, [edx-8]
.text$x:000012E6                 xor     ecx, eax
.text$x:000012E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012ED                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:000012F2                 jmp     ___CxxFrameHandler3
.text$x:000012F2 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:000012F2
.text$x:000012F2 ; ---------------------------------------------------------------------------
.text$x:000012F7                 align 4
.text$x:000012F7 _text$x         ends
.text$x:000012F7
.text$mn:000012F8 ; ===========================================================================
.text$mn:000012F8
.text$mn:000012F8 ; Segment type: Pure code
.text$mn:000012F8 ; Segment permissions: Read/Execute
.text$mn:000012F8 _text$mn        segment para public 'CODE' use32
.text$mn:000012F8                 assume cs:_text$mn
.text$mn:000012F8                 ;org 12F8h
.text$mn:000012F8 ; COMDAT (pick any)
.text$mn:000012F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000012F8
.text$mn:000012F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000012F8
.text$mn:000012F8 ; Attributes: bp-based frame
.text$mn:000012F8
.text$mn:000012F8 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000012F8                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000012F8 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000012F8                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000012F8                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:000012F8
.text$mn:000012F8 var_4           = dword ptr -4
.text$mn:000012F8
.text$mn:000012F8                 push    ebp
.text$mn:000012F9                 mov     ebp, esp
.text$mn:000012FB                 push    ecx
.text$mn:000012FC                 mov     [ebp+var_4], ecx
.text$mn:000012FF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001302                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001307                 mov     esp, ebp
.text$mn:00001309                 pop     ebp
.text$mn:0000130A                 retn
.text$mn:0000130A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000130A
.text$mn:0000130A ; ---------------------------------------------------------------------------
.text$mn:0000130B                 align 4
.text$mn:0000130B _text$mn        ends
.text$mn:0000130B
.text$mn:0000130C ; ===========================================================================
.text$mn:0000130C
.text$mn:0000130C ; Segment type: Pure code
.text$mn:0000130C ; Segment permissions: Read/Execute
.text$mn:0000130C _text$mn        segment para public 'CODE' use32
.text$mn:0000130C                 assume cs:_text$mn
.text$mn:0000130C                 ;org 130Ch
.text$mn:0000130C ; COMDAT (pick any)
.text$mn:0000130C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000130C
.text$mn:0000130C ; =============== S U B R O U T I N E =======================================
.text$mn:0000130C
.text$mn:0000130C ; Attributes: bp-based frame
.text$mn:0000130C
.text$mn:0000130C ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000130C                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000130C ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:0000130C                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:0000130C                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:0000130C
.text$mn:0000130C var_10          = dword ptr -10h
.text$mn:0000130C var_C           = dword ptr -0Ch
.text$mn:0000130C var_4           = dword ptr -4
.text$mn:0000130C
.text$mn:0000130C                 push    ebp
.text$mn:0000130D                 mov     ebp, esp
.text$mn:0000130F                 push    0FFFFFFFFh
.text$mn:00001311                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001316                 mov     eax, large fs:0
.text$mn:0000131C                 push    eax
.text$mn:0000131D                 push    ecx
.text$mn:0000131E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001323                 xor     eax, ebp
.text$mn:00001325                 push    eax
.text$mn:00001326                 lea     eax, [ebp+var_C]
.text$mn:00001329                 mov     large fs:0, eax
.text$mn:0000132F                 mov     [ebp+var_10], ecx
.text$mn:00001332                 mov     [ebp+var_4], 0
.text$mn:00001339                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001340                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001343                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001348                 mov     ecx, [ebp+var_C]
.text$mn:0000134B                 mov     large fs:0, ecx
.text$mn:00001352                 pop     ecx
.text$mn:00001353                 mov     esp, ebp
.text$mn:00001355                 pop     ebp
.text$mn:00001356                 retn
.text$mn:00001356 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00001356
.text$mn:00001356 ; ---------------------------------------------------------------------------
.text$mn:00001357                 align 4
.text$mn:00001357 _text$mn        ends
.text$mn:00001357
.text$x:00001358 ; ===========================================================================
.text$x:00001358
.text$x:00001358 ; Segment type: Pure code
.text$x:00001358 ; Segment permissions: Read/Execute
.text$x:00001358 _text$x         segment para public 'CODE' use32
.text$x:00001358                 assume cs:_text$x
.text$x:00001358                 ;org 1358h
.text$x:00001358 ; COMDAT (pick associative to section at 130C)
.text$x:00001358                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001358
.text$x:00001358 ; =============== S U B R O U T I N E =======================================
.text$x:00001358
.text$x:00001358
.text$x:00001358 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001358                                         ; DATA XREF: .xdata$x:000029F4o
.text$x:00001358                 mov     ecx, [ebp-10h]  ; this
.text$x:0000135B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000135B __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000135B
.text$x:00001360
.text$x:00001360 ; =============== S U B R O U T I N E =======================================
.text$x:00001360
.text$x:00001360
.text$x:00001360 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001360                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001360
.text$x:00001360 arg_4           = dword ptr  8
.text$x:00001360
.text$x:00001360                 mov     edx, [esp+arg_4]
.text$x:00001364                 lea     eax, [edx+0Ch]
.text$x:00001367                 mov     ecx, [edx-8]
.text$x:0000136A                 xor     ecx, eax
.text$x:0000136C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001371                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00001376                 jmp     ___CxxFrameHandler3
.text$x:00001376 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00001376
.text$x:00001376 ; ---------------------------------------------------------------------------
.text$x:0000137B                 align 4
.text$x:0000137B _text$x         ends
.text$x:0000137B
.text$mn:0000137C ; ===========================================================================
.text$mn:0000137C
.text$mn:0000137C ; Segment type: Pure code
.text$mn:0000137C ; Segment permissions: Read/Execute
.text$mn:0000137C _text$mn        segment para public 'CODE' use32
.text$mn:0000137C                 assume cs:_text$mn
.text$mn:0000137C                 ;org 137Ch
.text$mn:0000137C ; COMDAT (pick any)
.text$mn:0000137C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000137C
.text$mn:0000137C ; =============== S U B R O U T I N E =======================================
.text$mn:0000137C
.text$mn:0000137C ; Attributes: bp-based frame
.text$mn:0000137C
.text$mn:0000137C ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000137C                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000137C ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:0000137C                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000137C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000137C
.text$mn:0000137C var_10          = dword ptr -10h
.text$mn:0000137C var_C           = dword ptr -0Ch
.text$mn:0000137C var_4           = dword ptr -4
.text$mn:0000137C
.text$mn:0000137C                 push    ebp
.text$mn:0000137D                 mov     ebp, esp
.text$mn:0000137F                 push    0FFFFFFFFh
.text$mn:00001381                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001386                 mov     eax, large fs:0
.text$mn:0000138C                 push    eax
.text$mn:0000138D                 push    ecx
.text$mn:0000138E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001393                 xor     eax, ebp
.text$mn:00001395                 push    eax
.text$mn:00001396                 lea     eax, [ebp+var_C]
.text$mn:00001399                 mov     large fs:0, eax
.text$mn:0000139F                 mov     [ebp+var_10], ecx
.text$mn:000013A2                 mov     [ebp+var_4], 0
.text$mn:000013A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013B0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000013B3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000013B8                 mov     ecx, [ebp+var_C]
.text$mn:000013BB                 mov     large fs:0, ecx
.text$mn:000013C2                 pop     ecx
.text$mn:000013C3                 mov     esp, ebp
.text$mn:000013C5                 pop     ebp
.text$mn:000013C6                 retn
.text$mn:000013C6 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000013C6
.text$mn:000013C6 ; ---------------------------------------------------------------------------
.text$mn:000013C7                 align 4
.text$mn:000013C7 _text$mn        ends
.text$mn:000013C7
.text$x:000013C8 ; ===========================================================================
.text$x:000013C8
.text$x:000013C8 ; Segment type: Pure code
.text$x:000013C8 ; Segment permissions: Read/Execute
.text$x:000013C8 _text$x         segment para public 'CODE' use32
.text$x:000013C8                 assume cs:_text$x
.text$x:000013C8                 ;org 13C8h
.text$x:000013C8 ; COMDAT (pick associative to section at 137C)
.text$x:000013C8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000013C8
.text$x:000013C8 ; =============== S U B R O U T I N E =======================================
.text$x:000013C8
.text$x:000013C8
.text$x:000013C8 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000013C8                                         ; DATA XREF: .xdata$x:00002A78o
.text$x:000013C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000013CB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000013CB __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000013CB
.text$x:000013D0
.text$x:000013D0 ; =============== S U B R O U T I N E =======================================
.text$x:000013D0
.text$x:000013D0
.text$x:000013D0 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000013D0                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000013D0
.text$x:000013D0 arg_4           = dword ptr  8
.text$x:000013D0
.text$x:000013D0                 mov     edx, [esp+arg_4]
.text$x:000013D4                 lea     eax, [edx+0Ch]
.text$x:000013D7                 mov     ecx, [edx-8]
.text$x:000013DA                 xor     ecx, eax
.text$x:000013DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013E1                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000013E6                 jmp     ___CxxFrameHandler3
.text$x:000013E6 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000013E6
.text$x:000013E6 ; ---------------------------------------------------------------------------
.text$x:000013EB                 align 4
.text$x:000013EB _text$x         ends
.text$x:000013EB
.text$mn:000013EC ; ===========================================================================
.text$mn:000013EC
.text$mn:000013EC ; Segment type: Pure code
.text$mn:000013EC ; Segment permissions: Read/Execute
.text$mn:000013EC _text$mn        segment para public 'CODE' use32
.text$mn:000013EC                 assume cs:_text$mn
.text$mn:000013EC                 ;org 13ECh
.text$mn:000013EC ; COMDAT (pick any)
.text$mn:000013EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000013EC
.text$mn:000013EC ; =============== S U B R O U T I N E =======================================
.text$mn:000013EC
.text$mn:000013EC ; Attributes: bp-based frame
.text$mn:000013EC
.text$mn:000013EC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000013EC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000013EC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000013EC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000013EC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000013EC
.text$mn:000013EC var_10          = dword ptr -10h
.text$mn:000013EC var_C           = dword ptr -0Ch
.text$mn:000013EC var_4           = dword ptr -4
.text$mn:000013EC
.text$mn:000013EC                 push    ebp
.text$mn:000013ED                 mov     ebp, esp
.text$mn:000013EF                 push    0FFFFFFFFh
.text$mn:000013F1                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000013F6                 mov     eax, large fs:0
.text$mn:000013FC                 push    eax
.text$mn:000013FD                 push    ecx
.text$mn:000013FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001403                 xor     eax, ebp
.text$mn:00001405                 push    eax
.text$mn:00001406                 lea     eax, [ebp+var_C]
.text$mn:00001409                 mov     large fs:0, eax
.text$mn:0000140F                 mov     [ebp+var_10], ecx
.text$mn:00001412                 mov     [ebp+var_4], 0
.text$mn:00001419                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001420                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001423                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001428                 mov     ecx, [ebp+var_C]
.text$mn:0000142B                 mov     large fs:0, ecx
.text$mn:00001432                 pop     ecx
.text$mn:00001433                 mov     esp, ebp
.text$mn:00001435                 pop     ebp
.text$mn:00001436                 retn
.text$mn:00001436 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001436
.text$mn:00001436 ; ---------------------------------------------------------------------------
.text$mn:00001437                 align 4
.text$mn:00001437 _text$mn        ends
.text$mn:00001437
.text$x:00001438 ; ===========================================================================
.text$x:00001438
.text$x:00001438 ; Segment type: Pure code
.text$x:00001438 ; Segment permissions: Read/Execute
.text$x:00001438 _text$x         segment para public 'CODE' use32
.text$x:00001438                 assume cs:_text$x
.text$x:00001438                 ;org 1438h
.text$x:00001438 ; COMDAT (pick associative to section at 13EC)
.text$x:00001438                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001438
.text$x:00001438 ; =============== S U B R O U T I N E =======================================
.text$x:00001438
.text$x:00001438
.text$x:00001438 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001438                                         ; DATA XREF: .xdata$x:00002AFCo
.text$x:00001438                 mov     ecx, [ebp-10h]  ; this
.text$x:0000143B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000143B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000143B
.text$x:00001440
.text$x:00001440 ; =============== S U B R O U T I N E =======================================
.text$x:00001440
.text$x:00001440
.text$x:00001440 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001440                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001440
.text$x:00001440 arg_4           = dword ptr  8
.text$x:00001440
.text$x:00001440                 mov     edx, [esp+arg_4]
.text$x:00001444                 lea     eax, [edx+0Ch]
.text$x:00001447                 mov     ecx, [edx-8]
.text$x:0000144A                 xor     ecx, eax
.text$x:0000144C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001451                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001456                 jmp     ___CxxFrameHandler3
.text$x:00001456 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001456
.text$x:00001456 ; ---------------------------------------------------------------------------
.text$x:0000145B                 align 4
.text$x:0000145B _text$x         ends
.text$x:0000145B
.text$mn:0000145C ; ===========================================================================
.text$mn:0000145C
.text$mn:0000145C ; Segment type: Pure code
.text$mn:0000145C ; Segment permissions: Read/Execute
.text$mn:0000145C _text$mn        segment para public 'CODE' use32
.text$mn:0000145C                 assume cs:_text$mn
.text$mn:0000145C                 ;org 145Ch
.text$mn:0000145C ; COMDAT (pick any)
.text$mn:0000145C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000145C
.text$mn:0000145C ; =============== S U B R O U T I N E =======================================
.text$mn:0000145C
.text$mn:0000145C ; Attributes: bp-based frame
.text$mn:0000145C
.text$mn:0000145C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000145C                 public ??1error_category@std@@UAE@XZ
.text$mn:0000145C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000145C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000145C
.text$mn:0000145C var_4           = dword ptr -4
.text$mn:0000145C
.text$mn:0000145C                 push    ebp
.text$mn:0000145D                 mov     ebp, esp
.text$mn:0000145F                 push    ecx
.text$mn:00001460                 mov     [ebp+var_4], ecx
.text$mn:00001463                 mov     eax, [ebp+var_4]
.text$mn:00001466                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000146C                 mov     esp, ebp
.text$mn:0000146E                 pop     ebp
.text$mn:0000146F                 retn
.text$mn:0000146F ??1error_category@std@@UAE@XZ endp
.text$mn:0000146F
.text$mn:0000146F _text$mn        ends
.text$mn:0000146F
.text$mn:00001470 ; ===========================================================================
.text$mn:00001470
.text$mn:00001470 ; Segment type: Pure code
.text$mn:00001470 ; Segment permissions: Read/Execute
.text$mn:00001470 _text$mn        segment para public 'CODE' use32
.text$mn:00001470                 assume cs:_text$mn
.text$mn:00001470                 ;org 1470h
.text$mn:00001470 ; COMDAT (pick any)
.text$mn:00001470                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001470
.text$mn:00001470 ; =============== S U B R O U T I N E =======================================
.text$mn:00001470
.text$mn:00001470 ; Attributes: bp-based frame
.text$mn:00001470
.text$mn:00001470 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001470                 public ??2@YAPAXIPAX@Z
.text$mn:00001470 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001470                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001470
.text$mn:00001470 arg_4           = dword ptr  0Ch
.text$mn:00001470
.text$mn:00001470                 push    ebp
.text$mn:00001471                 mov     ebp, esp
.text$mn:00001473                 mov     eax, [ebp+arg_4]
.text$mn:00001476                 pop     ebp
.text$mn:00001477                 retn
.text$mn:00001477 ??2@YAPAXIPAX@Z endp
.text$mn:00001477
.text$mn:00001477 _text$mn        ends
.text$mn:00001477
.text$mn:00001478 ; ===========================================================================
.text$mn:00001478
.text$mn:00001478 ; Segment type: Pure code
.text$mn:00001478 ; Segment permissions: Read/Execute
.text$mn:00001478 _text$mn        segment para public 'CODE' use32
.text$mn:00001478                 assume cs:_text$mn
.text$mn:00001478                 ;org 1478h
.text$mn:00001478 ; COMDAT (pick any)
.text$mn:00001478                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001478
.text$mn:00001478 ; =============== S U B R O U T I N E =======================================
.text$mn:00001478
.text$mn:00001478 ; Attributes: bp-based frame
.text$mn:00001478
.text$mn:00001478 ; void __cdecl operator delete(void *)
.text$mn:00001478                 public ??3@YAXPAX0@Z
.text$mn:00001478 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001478                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001478                 push    ebp
.text$mn:00001479                 mov     ebp, esp
.text$mn:0000147B                 pop     ebp
.text$mn:0000147C                 retn
.text$mn:0000147C ??3@YAXPAX0@Z   endp
.text$mn:0000147C
.text$mn:0000147C ; ---------------------------------------------------------------------------
.text$mn:0000147D                 align 10h
.text$mn:0000147D _text$mn        ends
.text$mn:0000147D
.text$mn:00001480 ; ===========================================================================
.text$mn:00001480
.text$mn:00001480 ; Segment type: Pure code
.text$mn:00001480 ; Segment permissions: Read/Execute
.text$mn:00001480 _text$mn        segment para public 'CODE' use32
.text$mn:00001480                 assume cs:_text$mn
.text$mn:00001480                 ;org 1480h
.text$mn:00001480 ; COMDAT (pick any)
.text$mn:00001480                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001480
.text$mn:00001480 ; =============== S U B R O U T I N E =======================================
.text$mn:00001480
.text$mn:00001480 ; Attributes: bp-based frame
.text$mn:00001480
.text$mn:00001480 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001480                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001480 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001480                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001480                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001480
.text$mn:00001480 var_8           = dword ptr -8
.text$mn:00001480 var_4           = dword ptr -4
.text$mn:00001480 arg_0           = dword ptr  8
.text$mn:00001480
.text$mn:00001480                 push    ebp
.text$mn:00001481                 mov     ebp, esp
.text$mn:00001483                 sub     esp, 8
.text$mn:00001486                 mov     [ebp+var_8], ecx
.text$mn:00001489                 mov     eax, [ebp+var_8]
.text$mn:0000148C                 cmp     eax, [ebp+arg_0]
.text$mn:0000148F                 jnz     short loc_149A
.text$mn:00001491                 mov     [ebp+var_4], 1
.text$mn:00001498                 jmp     short loc_14A1
.text$mn:0000149A ; ---------------------------------------------------------------------------
.text$mn:0000149A
.text$mn:0000149A loc_149A:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000149A                 mov     [ebp+var_4], 0
.text$mn:000014A1
.text$mn:000014A1 loc_14A1:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000014A1                 mov     al, byte ptr [ebp+var_4]
.text$mn:000014A4                 mov     esp, ebp
.text$mn:000014A6                 pop     ebp
.text$mn:000014A7                 retn    4
.text$mn:000014A7 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000014A7
.text$mn:000014A7 ; ---------------------------------------------------------------------------
.text$mn:000014AA                 align 4
.text$mn:000014AA _text$mn        ends
.text$mn:000014AA
.text$mn:000014AC ; ===========================================================================
.text$mn:000014AC
.text$mn:000014AC ; Segment type: Pure code
.text$mn:000014AC ; Segment permissions: Read/Execute
.text$mn:000014AC _text$mn        segment para public 'CODE' use32
.text$mn:000014AC                 assume cs:_text$mn
.text$mn:000014AC                 ;org 14ACh
.text$mn:000014AC ; COMDAT (pick any)
.text$mn:000014AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014AC
.text$mn:000014AC ; =============== S U B R O U T I N E =======================================
.text$mn:000014AC
.text$mn:000014AC ; Attributes: bp-based frame
.text$mn:000014AC
.text$mn:000014AC ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000014AC                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000014AC ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000014AC                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000014AC
.text$mn:000014AC var_8           = dword ptr -8
.text$mn:000014AC var_4           = dword ptr -4
.text$mn:000014AC arg_0           = dword ptr  8
.text$mn:000014AC
.text$mn:000014AC                 push    ebp
.text$mn:000014AD                 mov     ebp, esp
.text$mn:000014AF                 sub     esp, 8
.text$mn:000014B2                 push    esi
.text$mn:000014B3                 mov     [ebp+var_4], ecx
.text$mn:000014B6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000014B9                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000014BE                 push    eax
.text$mn:000014BF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000014C2                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000014C7                 mov     ecx, eax
.text$mn:000014C9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000014CE                 movzx   eax, al
.text$mn:000014D1                 test    eax, eax
.text$mn:000014D3                 jz      short loc_14F4
.text$mn:000014D5                 mov     ecx, [ebp+var_4] ; this
.text$mn:000014D8                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000014DD                 mov     esi, eax
.text$mn:000014DF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000014E2                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000014E7                 cmp     esi, eax
.text$mn:000014E9                 jnz     short loc_14F4
.text$mn:000014EB                 mov     [ebp+var_8], 1
.text$mn:000014F2                 jmp     short loc_14FB
.text$mn:000014F4 ; ---------------------------------------------------------------------------
.text$mn:000014F4
.text$mn:000014F4 loc_14F4:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000014F4                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000014F4                 mov     [ebp+var_8], 0
.text$mn:000014FB
.text$mn:000014FB loc_14FB:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000014FB                 mov     al, byte ptr [ebp+var_8]
.text$mn:000014FE                 pop     esi
.text$mn:000014FF                 mov     esp, ebp
.text$mn:00001501                 pop     ebp
.text$mn:00001502                 retn    4
.text$mn:00001502 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001502
.text$mn:00001502 ; ---------------------------------------------------------------------------
.text$mn:00001505                 align 4
.text$mn:00001505 _text$mn        ends
.text$mn:00001505
.text$mn:00001508 ; ===========================================================================
.text$mn:00001508
.text$mn:00001508 ; Segment type: Pure code
.text$mn:00001508 ; Segment permissions: Read/Execute
.text$mn:00001508 _text$mn        segment para public 'CODE' use32
.text$mn:00001508                 assume cs:_text$mn
.text$mn:00001508                 ;org 1508h
.text$mn:00001508 ; COMDAT (pick any)
.text$mn:00001508                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001508
.text$mn:00001508 ; =============== S U B R O U T I N E =======================================
.text$mn:00001508
.text$mn:00001508 ; Attributes: bp-based frame
.text$mn:00001508
.text$mn:00001508 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001508                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001508 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001508
.text$mn:00001508 var_4           = dword ptr -4
.text$mn:00001508 arg_0           = dword ptr  8
.text$mn:00001508
.text$mn:00001508                 push    ebp
.text$mn:00001509                 mov     ebp, esp
.text$mn:0000150B                 push    ecx
.text$mn:0000150C                 mov     [ebp+var_4], ecx
.text$mn:0000150F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001512                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001517                 mov     eax, [ebp+arg_0]
.text$mn:0000151A                 and     eax, 1
.text$mn:0000151D                 jz      short loc_152B
.text$mn:0000151F                 mov     ecx, [ebp+var_4]
.text$mn:00001522                 push    ecx             ; void *
.text$mn:00001523                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001528                 add     esp, 4
.text$mn:0000152B
.text$mn:0000152B loc_152B:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000152B                 mov     eax, [ebp+var_4]
.text$mn:0000152E                 mov     esp, ebp
.text$mn:00001530                 pop     ebp
.text$mn:00001531                 retn    4
.text$mn:00001531 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001531
.text$mn:00001531 _text$mn        ends
.text$mn:00001531
.text$mn:00001534 ; ===========================================================================
.text$mn:00001534
.text$mn:00001534 ; Segment type: Pure code
.text$mn:00001534 ; Segment permissions: Read/Execute
.text$mn:00001534 _text$mn        segment para public 'CODE' use32
.text$mn:00001534                 assume cs:_text$mn
.text$mn:00001534                 ;org 1534h
.text$mn:00001534 ; COMDAT (pick any)
.text$mn:00001534                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001534
.text$mn:00001534 ; =============== S U B R O U T I N E =======================================
.text$mn:00001534
.text$mn:00001534 ; Attributes: bp-based frame
.text$mn:00001534
.text$mn:00001534 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001534                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001534 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001534
.text$mn:00001534 var_4           = dword ptr -4
.text$mn:00001534 arg_0           = dword ptr  8
.text$mn:00001534
.text$mn:00001534                 push    ebp
.text$mn:00001535                 mov     ebp, esp
.text$mn:00001537                 push    ecx
.text$mn:00001538                 mov     [ebp+var_4], ecx
.text$mn:0000153B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000153E                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001543                 mov     eax, [ebp+arg_0]
.text$mn:00001546                 and     eax, 1
.text$mn:00001549                 jz      short loc_1557
.text$mn:0000154B                 mov     ecx, [ebp+var_4]
.text$mn:0000154E                 push    ecx             ; void *
.text$mn:0000154F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001554                 add     esp, 4
.text$mn:00001557
.text$mn:00001557 loc_1557:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001557                 mov     eax, [ebp+var_4]
.text$mn:0000155A                 mov     esp, ebp
.text$mn:0000155C                 pop     ebp
.text$mn:0000155D                 retn    4
.text$mn:0000155D ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:0000155D
.text$mn:0000155D _text$mn        ends
.text$mn:0000155D
.text$mn:00001560 ; ===========================================================================
.text$mn:00001560
.text$mn:00001560 ; Segment type: Pure code
.text$mn:00001560 ; Segment permissions: Read/Execute
.text$mn:00001560 _text$mn        segment para public 'CODE' use32
.text$mn:00001560                 assume cs:_text$mn
.text$mn:00001560                 ;org 1560h
.text$mn:00001560 ; COMDAT (pick any)
.text$mn:00001560                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001560
.text$mn:00001560 ; =============== S U B R O U T I N E =======================================
.text$mn:00001560
.text$mn:00001560 ; Attributes: bp-based frame
.text$mn:00001560
.text$mn:00001560 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001560                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001560 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001560
.text$mn:00001560 var_4           = dword ptr -4
.text$mn:00001560 arg_0           = dword ptr  8
.text$mn:00001560
.text$mn:00001560                 push    ebp
.text$mn:00001561                 mov     ebp, esp
.text$mn:00001563                 push    ecx
.text$mn:00001564                 mov     [ebp+var_4], ecx
.text$mn:00001567                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000156A                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000156F                 mov     eax, [ebp+arg_0]
.text$mn:00001572                 and     eax, 1
.text$mn:00001575                 jz      short loc_1583
.text$mn:00001577                 mov     ecx, [ebp+var_4]
.text$mn:0000157A                 push    ecx             ; void *
.text$mn:0000157B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001580                 add     esp, 4
.text$mn:00001583
.text$mn:00001583 loc_1583:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001583                 mov     eax, [ebp+var_4]
.text$mn:00001586                 mov     esp, ebp
.text$mn:00001588                 pop     ebp
.text$mn:00001589                 retn    4
.text$mn:00001589 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001589
.text$mn:00001589 _text$mn        ends
.text$mn:00001589
.text$mn:0000158C ; ===========================================================================
.text$mn:0000158C
.text$mn:0000158C ; Segment type: Pure code
.text$mn:0000158C ; Segment permissions: Read/Execute
.text$mn:0000158C _text$mn        segment para public 'CODE' use32
.text$mn:0000158C                 assume cs:_text$mn
.text$mn:0000158C                 ;org 158Ch
.text$mn:0000158C ; COMDAT (pick any)
.text$mn:0000158C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000158C
.text$mn:0000158C ; =============== S U B R O U T I N E =======================================
.text$mn:0000158C
.text$mn:0000158C ; Attributes: bp-based frame
.text$mn:0000158C
.text$mn:0000158C ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000158C                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:0000158C ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:0000158C
.text$mn:0000158C var_4           = dword ptr -4
.text$mn:0000158C arg_0           = dword ptr  8
.text$mn:0000158C
.text$mn:0000158C                 push    ebp
.text$mn:0000158D                 mov     ebp, esp
.text$mn:0000158F                 push    ecx
.text$mn:00001590                 mov     [ebp+var_4], ecx
.text$mn:00001593                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001596                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000159B                 mov     eax, [ebp+arg_0]
.text$mn:0000159E                 and     eax, 1
.text$mn:000015A1                 jz      short loc_15AF
.text$mn:000015A3                 mov     ecx, [ebp+var_4]
.text$mn:000015A6                 push    ecx             ; void *
.text$mn:000015A7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000015AC                 add     esp, 4
.text$mn:000015AF
.text$mn:000015AF loc_15AF:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000015AF                 mov     eax, [ebp+var_4]
.text$mn:000015B2                 mov     esp, ebp
.text$mn:000015B4                 pop     ebp
.text$mn:000015B5                 retn    4
.text$mn:000015B5 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000015B5
.text$mn:000015B5 _text$mn        ends
.text$mn:000015B5
.text$di:000015B8 ; ===========================================================================
.text$di:000015B8
.text$di:000015B8 ; Segment type: Pure code
.text$di:000015B8 ; Segment permissions: Read/Execute
.text$di:000015B8 _text$di        segment para public 'CODE' use32
.text$di:000015B8                 assume cs:_text$di
.text$di:000015B8                 ;org 15B8h
.text$di:000015B8 ; COMDAT (pick any)
.text$di:000015B8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:000015B8
.text$di:000015B8 ; =============== S U B R O U T I N E =======================================
.text$di:000015B8
.text$di:000015B8 ; Attributes: bp-based frame
.text$di:000015B8
.text$di:000015B8 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000015B8 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000015B8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000015B8                 push    ebp
.text$di:000015B9                 mov     ebp, esp
.text$di:000015BB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000015C0                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000015C5                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000015CA                 call    _atexit
.text$di:000015CF                 add     esp, 4
.text$di:000015D2                 pop     ebp
.text$di:000015D3                 retn
.text$di:000015D3 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000015D3
.text$di:000015D3 _text$di        ends
.text$di:000015D3
.text$di:000015D4 ; ===========================================================================
.text$di:000015D4
.text$di:000015D4 ; Segment type: Pure code
.text$di:000015D4 ; Segment permissions: Read/Execute
.text$di:000015D4 _text$di        segment para public 'CODE' use32
.text$di:000015D4                 assume cs:_text$di
.text$di:000015D4                 ;org 15D4h
.text$di:000015D4 ; COMDAT (pick any)
.text$di:000015D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:000015D4
.text$di:000015D4 ; =============== S U B R O U T I N E =======================================
.text$di:000015D4
.text$di:000015D4 ; Attributes: bp-based frame
.text$di:000015D4
.text$di:000015D4 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000015D4 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000015D4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000015D4                 push    ebp
.text$di:000015D5                 mov     ebp, esp
.text$di:000015D7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000015DC                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000015E1                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000015E6                 call    _atexit
.text$di:000015EB                 add     esp, 4
.text$di:000015EE                 pop     ebp
.text$di:000015EF                 retn
.text$di:000015EF ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000015EF
.text$di:000015EF _text$di        ends
.text$di:000015EF
.text$di:000015F0 ; ===========================================================================
.text$di:000015F0
.text$di:000015F0 ; Segment type: Pure code
.text$di:000015F0 ; Segment permissions: Read/Execute
.text$di:000015F0 _text$di        segment para public 'CODE' use32
.text$di:000015F0                 assume cs:_text$di
.text$di:000015F0                 ;org 15F0h
.text$di:000015F0 ; COMDAT (pick any)
.text$di:000015F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:000015F0
.text$di:000015F0 ; =============== S U B R O U T I N E =======================================
.text$di:000015F0
.text$di:000015F0 ; Attributes: bp-based frame
.text$di:000015F0
.text$di:000015F0 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000015F0 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000015F0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000015F0                 push    ebp
.text$di:000015F1                 mov     ebp, esp
.text$di:000015F3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000015F8                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000015FD                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001602                 call    _atexit
.text$di:00001607                 add     esp, 4
.text$di:0000160A                 pop     ebp
.text$di:0000160B                 retn
.text$di:0000160B ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000160B
.text$di:0000160B _text$di        ends
.text$di:0000160B
.text$di:0000160C ; ===========================================================================
.text$di:0000160C
.text$di:0000160C ; Segment type: Pure code
.text$di:0000160C ; Segment permissions: Read/Execute
.text$di:0000160C _text$di        segment para public 'CODE' use32
.text$di:0000160C                 assume cs:_text$di
.text$di:0000160C                 ;org 160Ch
.text$di:0000160C ; COMDAT (pick any)
.text$di:0000160C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:0000160C
.text$di:0000160C ; =============== S U B R O U T I N E =======================================
.text$di:0000160C
.text$di:0000160C ; Attributes: bp-based frame
.text$di:0000160C
.text$di:0000160C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:0000160C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000160C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:0000160C                 push    ebp
.text$di:0000160D                 mov     ebp, esp
.text$di:0000160F                 push    0               ; unsigned int
.text$di:00001611                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001616                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000161B                 pop     ebp
.text$di:0000161C                 retn
.text$di:0000161C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000161C
.text$di:0000161C ; ---------------------------------------------------------------------------
.text$di:0000161D                 align 10h
.text$di:0000161D _text$di        ends
.text$di:0000161D
.text$di:00001620 ; ===========================================================================
.text$di:00001620
.text$di:00001620 ; Segment type: Pure code
.text$di:00001620 ; Segment permissions: Read/Execute
.text$di:00001620 _text$di        segment para public 'CODE' use32
.text$di:00001620                 assume cs:_text$di
.text$di:00001620                 ;org 1620h
.text$di:00001620 ; COMDAT (pick any)
.text$di:00001620                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001620
.text$di:00001620 ; =============== S U B R O U T I N E =======================================
.text$di:00001620
.text$di:00001620 ; Attributes: bp-based frame
.text$di:00001620
.text$di:00001620 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001620 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001620                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001620                 push    ebp
.text$di:00001621                 mov     ebp, esp
.text$di:00001623                 push    0               ; unsigned int
.text$di:00001625                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000162A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000162F                 pop     ebp
.text$di:00001630                 retn
.text$di:00001630 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001630
.text$di:00001630 ; ---------------------------------------------------------------------------
.text$di:00001631                 align 4
.text$di:00001631 _text$di        ends
.text$di:00001631
.text$di:00001634 ; ===========================================================================
.text$di:00001634
.text$di:00001634 ; Segment type: Pure code
.text$di:00001634 ; Segment permissions: Read/Execute
.text$di:00001634 _text$di        segment para public 'CODE' use32
.text$di:00001634                 assume cs:_text$di
.text$di:00001634                 ;org 1634h
.text$di:00001634 ; COMDAT (pick any)
.text$di:00001634                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001634
.text$di:00001634 ; =============== S U B R O U T I N E =======================================
.text$di:00001634
.text$di:00001634 ; Attributes: bp-based frame
.text$di:00001634
.text$di:00001634 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001634 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001634                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001634                 push    ebp
.text$di:00001635                 mov     ebp, esp
.text$di:00001637                 push    0               ; unsigned int
.text$di:00001639                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000163E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001643                 pop     ebp
.text$di:00001644                 retn
.text$di:00001644 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001644
.text$di:00001644 ; ---------------------------------------------------------------------------
.text$di:00001645                 align 4
.text$di:00001645 _text$di        ends
.text$di:00001645
.text$di:00001648 ; ===========================================================================
.text$di:00001648
.text$di:00001648 ; Segment type: Pure code
.text$di:00001648 ; Segment permissions: Read/Execute
.text$di:00001648 _text$di        segment para public 'CODE' use32
.text$di:00001648                 assume cs:_text$di
.text$di:00001648                 ;org 1648h
.text$di:00001648 ; COMDAT (pick any)
.text$di:00001648                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001648
.text$di:00001648 ; =============== S U B R O U T I N E =======================================
.text$di:00001648
.text$di:00001648 ; Attributes: bp-based frame
.text$di:00001648
.text$di:00001648 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001648 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001648                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001648                 push    ebp
.text$di:00001649                 mov     ebp, esp
.text$di:0000164B                 push    0               ; unsigned int
.text$di:0000164D                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001652                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001657                 pop     ebp
.text$di:00001658                 retn
.text$di:00001658 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001658
.text$di:00001658 ; ---------------------------------------------------------------------------
.text$di:00001659                 align 4
.text$di:00001659 _text$di        ends
.text$di:00001659
.text$di:0000165C ; ===========================================================================
.text$di:0000165C
.text$di:0000165C ; Segment type: Pure code
.text$di:0000165C ; Segment permissions: Read/Execute
.text$di:0000165C _text$di        segment para public 'CODE' use32
.text$di:0000165C                 assume cs:_text$di
.text$di:0000165C                 ;org 165Ch
.text$di:0000165C ; COMDAT (pick any)
.text$di:0000165C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:0000165C
.text$di:0000165C ; =============== S U B R O U T I N E =======================================
.text$di:0000165C
.text$di:0000165C ; Attributes: bp-based frame
.text$di:0000165C
.text$di:0000165C ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:0000165C ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:0000165C
.text$di:0000165C var_1           = byte ptr -1
.text$di:0000165C
.text$di:0000165C                 push    ebp
.text$di:0000165D                 mov     ebp, esp
.text$di:0000165F                 push    ecx
.text$di:00001660                 xor     eax, eax
.text$di:00001662                 mov     [ebp+var_1], al
.text$di:00001665                 mov     esp, ebp
.text$di:00001667                 pop     ebp
.text$di:00001668                 retn
.text$di:00001668 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001668
.text$di:00001668 ; ---------------------------------------------------------------------------
.text$di:00001669                 align 4
.text$di:00001669 _text$di        ends
.text$di:00001669
.text$di:0000166C ; ===========================================================================
.text$di:0000166C
.text$di:0000166C ; Segment type: Pure code
.text$di:0000166C ; Segment permissions: Read/Execute
.text$di:0000166C _text$di        segment para public 'CODE' use32
.text$di:0000166C                 assume cs:_text$di
.text$di:0000166C                 ;org 166Ch
.text$di:0000166C ; COMDAT (pick any)
.text$di:0000166C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:0000166C
.text$di:0000166C ; =============== S U B R O U T I N E =======================================
.text$di:0000166C
.text$di:0000166C ; Attributes: bp-based frame
.text$di:0000166C
.text$di:0000166C ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:0000166C ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:0000166C                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:0000166C
.text$di:0000166C var_1           = byte ptr -1
.text$di:0000166C
.text$di:0000166C                 push    ebp
.text$di:0000166D                 mov     ebp, esp
.text$di:0000166F                 push    ecx
.text$di:00001670                 xor     eax, eax
.text$di:00001672                 mov     [ebp+var_1], al
.text$di:00001675                 mov     esp, ebp
.text$di:00001677                 pop     ebp
.text$di:00001678                 retn
.text$di:00001678 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001678
.text$di:00001678 ; ---------------------------------------------------------------------------
.text$di:00001679                 align 4
.text$di:00001679 _text$di        ends
.text$di:00001679
.text$yd:0000167C ; ===========================================================================
.text$yd:0000167C
.text$yd:0000167C ; Segment type: Pure code
.text$yd:0000167C ; Segment permissions: Read/Execute
.text$yd:0000167C _text$yd        segment para public 'CODE' use32
.text$yd:0000167C                 assume cs:_text$yd
.text$yd:0000167C                 ;org 167Ch
.text$yd:0000167C ; COMDAT (pick any)
.text$yd:0000167C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:0000167C
.text$yd:0000167C ; =============== S U B R O U T I N E =======================================
.text$yd:0000167C
.text$yd:0000167C ; Attributes: bp-based frame
.text$yd:0000167C
.text$yd:0000167C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:0000167C ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:0000167C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:0000167C                 push    ebp
.text$yd:0000167D                 mov     ebp, esp
.text$yd:0000167F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001684                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001689                 pop     ebp
.text$yd:0000168A                 retn
.text$yd:0000168A ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000168A
.text$yd:0000168A ; ---------------------------------------------------------------------------
.text$yd:0000168B                 align 4
.text$yd:0000168B _text$yd        ends
.text$yd:0000168B
.text$yd:0000168C ; ===========================================================================
.text$yd:0000168C
.text$yd:0000168C ; Segment type: Pure code
.text$yd:0000168C ; Segment permissions: Read/Execute
.text$yd:0000168C _text$yd        segment para public 'CODE' use32
.text$yd:0000168C                 assume cs:_text$yd
.text$yd:0000168C                 ;org 168Ch
.text$yd:0000168C ; COMDAT (pick any)
.text$yd:0000168C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:0000168C
.text$yd:0000168C ; =============== S U B R O U T I N E =======================================
.text$yd:0000168C
.text$yd:0000168C ; Attributes: bp-based frame
.text$yd:0000168C
.text$yd:0000168C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:0000168C ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:0000168C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:0000168C                 push    ebp
.text$yd:0000168D                 mov     ebp, esp
.text$yd:0000168F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001694                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001699                 pop     ebp
.text$yd:0000169A                 retn
.text$yd:0000169A ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000169A
.text$yd:0000169A ; ---------------------------------------------------------------------------
.text$yd:0000169B                 align 4
.text$yd:0000169B _text$yd        ends
.text$yd:0000169B
.text$yd:0000169C ; ===========================================================================
.text$yd:0000169C
.text$yd:0000169C ; Segment type: Pure code
.text$yd:0000169C ; Segment permissions: Read/Execute
.text$yd:0000169C _text$yd        segment para public 'CODE' use32
.text$yd:0000169C                 assume cs:_text$yd
.text$yd:0000169C                 ;org 169Ch
.text$yd:0000169C ; COMDAT (pick any)
.text$yd:0000169C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:0000169C
.text$yd:0000169C ; =============== S U B R O U T I N E =======================================
.text$yd:0000169C
.text$yd:0000169C ; Attributes: bp-based frame
.text$yd:0000169C
.text$yd:0000169C ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:0000169C ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:0000169C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:0000169C                 push    ebp
.text$yd:0000169D                 mov     ebp, esp
.text$yd:0000169F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000016A4                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000016A9                 pop     ebp
.text$yd:000016AA                 retn
.text$yd:000016AA ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000016AA
.text$yd:000016AA ; ---------------------------------------------------------------------------
.text$yd:000016AB                 align 4
.text$yd:000016AB _text$yd        ends
.text$yd:000016AB
.text$mn:000016AC ; ===========================================================================
.text$mn:000016AC
.text$mn:000016AC ; Segment type: Pure code
.text$mn:000016AC ; Segment permissions: Read/Execute
.text$mn:000016AC _text$mn        segment para public 'CODE' use32
.text$mn:000016AC                 assume cs:_text$mn
.text$mn:000016AC                 ;org 16ACh
.text$mn:000016AC ; COMDAT (pick any)
.text$mn:000016AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016AC
.text$mn:000016AC ; =============== S U B R O U T I N E =======================================
.text$mn:000016AC
.text$mn:000016AC ; Attributes: bp-based frame
.text$mn:000016AC
.text$mn:000016AC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000016AC                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000016AC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000016AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000016AC
.text$mn:000016AC var_10          = byte ptr -10h
.text$mn:000016AC var_8           = dword ptr -8
.text$mn:000016AC var_1           = byte ptr -1
.text$mn:000016AC
.text$mn:000016AC                 push    ebp
.text$mn:000016AD                 mov     ebp, esp
.text$mn:000016AF                 sub     esp, 10h
.text$mn:000016B2                 mov     [ebp+var_8], ecx
.text$mn:000016B5                 lea     ecx, [ebp+var_1]
.text$mn:000016B8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000016BD                 push    1
.text$mn:000016BF                 lea     ecx, [ebp+var_1]
.text$mn:000016C2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000016C7                 mov     ecx, [ebp+var_8]
.text$mn:000016CA                 mov     [ecx], eax
.text$mn:000016CC                 lea     ecx, [ebp+var_10] ; this
.text$mn:000016CF                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000016D4                 push    eax             ; int
.text$mn:000016D5                 mov     edx, [ebp+var_8]
.text$mn:000016D8                 mov     eax, [edx]
.text$mn:000016DA                 push    eax             ; void *
.text$mn:000016DB                 lea     ecx, [ebp+var_1]
.text$mn:000016DE                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000016E3                 mov     ecx, [ebp+var_8]
.text$mn:000016E6                 mov     edx, [ecx]
.text$mn:000016E8                 mov     eax, [ebp+var_8]
.text$mn:000016EB                 mov     [edx], eax
.text$mn:000016ED                 mov     esp, ebp
.text$mn:000016EF                 pop     ebp
.text$mn:000016F0                 retn
.text$mn:000016F0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000016F0
.text$mn:000016F0 ; ---------------------------------------------------------------------------
.text$mn:000016F1                 align 4
.text$mn:000016F1 _text$mn        ends
.text$mn:000016F1
.text$mn:000016F4 ; ===========================================================================
.text$mn:000016F4
.text$mn:000016F4 ; Segment type: Pure code
.text$mn:000016F4 ; Segment permissions: Read/Execute
.text$mn:000016F4 _text$mn        segment para public 'CODE' use32
.text$mn:000016F4                 assume cs:_text$mn
.text$mn:000016F4                 ;org 16F4h
.text$mn:000016F4 ; COMDAT (pick any)
.text$mn:000016F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016F4
.text$mn:000016F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F4
.text$mn:000016F4 ; Attributes: bp-based frame
.text$mn:000016F4
.text$mn:000016F4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:000016F4                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000016F4 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:000016F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:000016F4
.text$mn:000016F4 var_20          = dword ptr -20h
.text$mn:000016F4 var_1C          = dword ptr -1Ch
.text$mn:000016F4 var_18          = dword ptr -18h
.text$mn:000016F4 var_11          = byte ptr -11h
.text$mn:000016F4 var_10          = dword ptr -10h
.text$mn:000016F4 var_C           = byte ptr -0Ch
.text$mn:000016F4 var_4           = dword ptr -4
.text$mn:000016F4 arg_0           = dword ptr  8
.text$mn:000016F4
.text$mn:000016F4 ; FUNCTION CHUNK AT .text$mn:00001816 SIZE 00000009 BYTES
.text$mn:000016F4
.text$mn:000016F4                 push    ebp
.text$mn:000016F5                 mov     ebp, esp
.text$mn:000016F7                 push    0FFFFFFFFh
.text$mn:000016F9                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000016FE                 mov     eax, large fs:0
.text$mn:00001704                 push    eax
.text$mn:00001705                 push    ecx
.text$mn:00001706                 sub     esp, 10h
.text$mn:00001709                 push    ebx
.text$mn:0000170A                 push    esi
.text$mn:0000170B                 push    edi
.text$mn:0000170C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001711                 xor     eax, ebp
.text$mn:00001713                 push    eax
.text$mn:00001714                 lea     eax, [ebp+var_C]
.text$mn:00001717                 mov     large fs:0, eax
.text$mn:0000171D                 mov     [ebp+var_10], esp
.text$mn:00001720                 mov     [ebp+var_18], ecx
.text$mn:00001723                 mov     eax, [ebp+arg_0]
.text$mn:00001726                 or      eax, 0Fh
.text$mn:00001729                 mov     [ebp+var_1C], eax
.text$mn:0000172C                 mov     ecx, [ebp+var_18]
.text$mn:0000172F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001734                 cmp     eax, [ebp+var_1C]
.text$mn:00001737                 jnb     short loc_1741
.text$mn:00001739                 mov     ecx, [ebp+arg_0]
.text$mn:0000173C                 mov     [ebp+var_1C], ecx
.text$mn:0000173F                 jmp     short loc_1793
.text$mn:00001741 ; ---------------------------------------------------------------------------
.text$mn:00001741
.text$mn:00001741 loc_1741:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001741                 mov     edx, [ebp+var_18]
.text$mn:00001744                 mov     ecx, [edx+18h]
.text$mn:00001747                 shr     ecx, 1
.text$mn:00001749                 mov     eax, [ebp+var_1C]
.text$mn:0000174C                 xor     edx, edx
.text$mn:0000174E                 mov     esi, 3
.text$mn:00001753                 div     esi
.text$mn:00001755                 cmp     ecx, eax
.text$mn:00001757                 ja      short loc_175B
.text$mn:00001759                 jmp     short loc_1793
.text$mn:0000175B ; ---------------------------------------------------------------------------
.text$mn:0000175B
.text$mn:0000175B loc_175B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000175B                 mov     ecx, [ebp+var_18]
.text$mn:0000175E                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001763                 mov     edx, [ebp+var_18]
.text$mn:00001766                 mov     ecx, [edx+18h]
.text$mn:00001769                 shr     ecx, 1
.text$mn:0000176B                 sub     eax, ecx
.text$mn:0000176D                 mov     edx, [ebp+var_18]
.text$mn:00001770                 cmp     [edx+18h], eax
.text$mn:00001773                 ja      short loc_1788
.text$mn:00001775                 mov     eax, [ebp+var_18]
.text$mn:00001778                 mov     ecx, [eax+18h]
.text$mn:0000177B                 shr     ecx, 1
.text$mn:0000177D                 mov     edx, [ebp+var_18]
.text$mn:00001780                 add     ecx, [edx+18h]
.text$mn:00001783                 mov     [ebp+var_1C], ecx
.text$mn:00001786                 jmp     short loc_1793
.text$mn:00001788 ; ---------------------------------------------------------------------------
.text$mn:00001788
.text$mn:00001788 loc_1788:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001788                 mov     ecx, [ebp+var_18]
.text$mn:0000178B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001790                 mov     [ebp+var_1C], eax
.text$mn:00001793
.text$mn:00001793 loc_1793:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001793                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001793                 mov     [ebp+var_4], 0
.text$mn:0000179A                 mov     eax, [ebp+var_1C]
.text$mn:0000179D                 add     eax, 1
.text$mn:000017A0                 push    eax
.text$mn:000017A1                 lea     ecx, [ebp+var_11]
.text$mn:000017A4                 push    ecx
.text$mn:000017A5                 mov     ecx, [ebp+var_18]
.text$mn:000017A8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000017AD                 mov     ecx, eax
.text$mn:000017AF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000017B4                 mov     [ebp+var_20], eax
.text$mn:000017B7                 jmp     short loc_1816
.text$mn:000017B7 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000017B7
.text$mn:000017B9
.text$mn:000017B9 ; =============== S U B R O U T I N E =======================================
.text$mn:000017B9
.text$mn:000017B9
.text$mn:000017B9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000017B9                                         ; DATA XREF: .xdata$x:00002918o
.text$mn:000017B9
.text$mn:000017B9 ; FUNCTION CHUNK AT .text$mn:00001800 SIZE 00000009 BYTES
.text$mn:000017B9 ; FUNCTION CHUNK AT .text$mn:00001810 SIZE 00000006 BYTES
.text$mn:000017B9
.text$mn:000017B9                 mov     [ebp-10h], esp
.text$mn:000017BC                 mov     edx, [ebp+8]
.text$mn:000017BF                 mov     [ebp-1Ch], edx
.text$mn:000017C2                 mov     byte ptr [ebp-4], 2
.text$mn:000017C6                 mov     eax, [ebp-1Ch]
.text$mn:000017C9                 add     eax, 1
.text$mn:000017CC                 push    eax
.text$mn:000017CD                 lea     ecx, [ebp-12h]
.text$mn:000017D0                 push    ecx
.text$mn:000017D1                 mov     ecx, [ebp-18h]
.text$mn:000017D4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000017D9                 mov     ecx, eax
.text$mn:000017DB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000017E0                 mov     [ebp-20h], eax
.text$mn:000017E3                 jmp     short loc_1800
.text$mn:000017E3 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000017E3
.text$mn:000017E5
.text$mn:000017E5 ; =============== S U B R O U T I N E =======================================
.text$mn:000017E5
.text$mn:000017E5 ; Attributes: noreturn
.text$mn:000017E5
.text$mn:000017E5 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000017E5                                         ; DATA XREF: .xdata$x:00002928o
.text$mn:000017E5                 push    0               ; Size
.text$mn:000017E7                 push    1               ; char
.text$mn:000017E9                 mov     ecx, [ebp-18h]
.text$mn:000017EC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000017F1                 push    0
.text$mn:000017F3                 push    0
.text$mn:000017F5                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000017F5 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000017F5
.text$mn:000017FA ; ---------------------------------------------------------------------------
.text$mn:000017FA                 mov     eax, offset $LN17
.text$mn:000017FF                 retn
.text$mn:00001800 ; ---------------------------------------------------------------------------
.text$mn:00001800 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001800
.text$mn:00001800 loc_1800:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001800                 mov     dword ptr [ebp-4], 1
.text$mn:00001807                 jmp     short loc_1810
.text$mn:00001807 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001809
.text$mn:00001809 ; =============== S U B R O U T I N E =======================================
.text$mn:00001809
.text$mn:00001809
.text$mn:00001809 $LN17           proc near               ; DATA XREF: .text$mn:000017FAo
.text$mn:00001809                 mov     dword ptr [ebp-4], 1
.text$mn:00001809 $LN17           endp ; sp-analysis failed
.text$mn:00001809
.text$mn:00001810 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001810
.text$mn:00001810 loc_1810:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001810                 mov     eax, offset $LN19
.text$mn:00001815                 retn
.text$mn:00001815 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001816 ; ---------------------------------------------------------------------------
.text$mn:00001816 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001816
.text$mn:00001816 loc_1816:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001816                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000181D                 jmp     short loc_1826
.text$mn:0000181D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000181F
.text$mn:0000181F ; =============== S U B R O U T I N E =======================================
.text$mn:0000181F
.text$mn:0000181F
.text$mn:0000181F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1810o
.text$mn:0000181F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001826
.text$mn:00001826 loc_1826:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001826                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000182A                 jbe     short loc_1845
.text$mn:0000182C                 mov     edx, [ebp+0Ch]
.text$mn:0000182F                 push    edx             ; Size
.text$mn:00001830                 mov     ecx, [ebp-18h]
.text$mn:00001833                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001838                 push    eax             ; Src
.text$mn:00001839                 mov     eax, [ebp-20h]
.text$mn:0000183C                 push    eax             ; Dst
.text$mn:0000183D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001842                 add     esp, 0Ch
.text$mn:00001845
.text$mn:00001845 loc_1845:                               ; CODE XREF: $LN19+Bj
.text$mn:00001845                 push    0               ; Size
.text$mn:00001847                 push    1               ; char
.text$mn:00001849                 mov     ecx, [ebp-18h]
.text$mn:0000184C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001851                 lea     ecx, [ebp-20h]
.text$mn:00001854                 push    ecx             ; int
.text$mn:00001855                 mov     edx, [ebp-18h]
.text$mn:00001858                 add     edx, 4
.text$mn:0000185B                 push    edx             ; void *
.text$mn:0000185C                 lea     eax, [ebp-13h]
.text$mn:0000185F                 push    eax
.text$mn:00001860                 mov     ecx, [ebp-18h]
.text$mn:00001863                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001868                 mov     ecx, eax
.text$mn:0000186A                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000186F                 mov     ecx, [ebp-18h]
.text$mn:00001872                 mov     edx, [ebp-1Ch]
.text$mn:00001875                 mov     [ecx+18h], edx
.text$mn:00001878                 mov     eax, [ebp+0Ch]
.text$mn:0000187B                 push    eax
.text$mn:0000187C                 mov     ecx, [ebp-18h]
.text$mn:0000187F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001884                 mov     ecx, [ebp-0Ch]
.text$mn:00001887                 mov     large fs:0, ecx
.text$mn:0000188E                 pop     ecx
.text$mn:0000188F                 pop     edi
.text$mn:00001890                 pop     esi
.text$mn:00001891                 pop     ebx
.text$mn:00001892                 mov     esp, ebp
.text$mn:00001894                 pop     ebp
.text$mn:00001895                 retn    8
.text$mn:00001895 $LN19           endp ; sp-analysis failed
.text$mn:00001895
.text$mn:00001895 _text$mn        ends
.text$mn:00001895
.text$x:00001898 ; ===========================================================================
.text$x:00001898
.text$x:00001898 ; Segment type: Pure code
.text$x:00001898 ; Segment permissions: Read/Execute
.text$x:00001898 _text$x         segment para public 'CODE' use32
.text$x:00001898                 assume cs:_text$x
.text$x:00001898                 ;org 1898h
.text$x:00001898 ; COMDAT (pick associative to section at 16F4)
.text$x:00001898                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001898
.text$x:00001898 ; =============== S U B R O U T I N E =======================================
.text$x:00001898
.text$x:00001898
.text$x:00001898 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001898                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001898
.text$x:00001898 arg_4           = dword ptr  8
.text$x:00001898
.text$x:00001898                 mov     edx, [esp+arg_4]
.text$x:0000189C                 lea     eax, [edx+0Ch]
.text$x:0000189F                 mov     ecx, [edx-24h]
.text$x:000018A2                 xor     ecx, eax
.text$x:000018A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018A9                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000018AE                 jmp     ___CxxFrameHandler3
.text$x:000018AE __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000018AE
.text$x:000018AE ; ---------------------------------------------------------------------------
.text$x:000018B3                 align 4
.text$x:000018B3 _text$x         ends
.text$x:000018B3
.text$mn:000018B4 ; ===========================================================================
.text$mn:000018B4
.text$mn:000018B4 ; Segment type: Pure code
.text$mn:000018B4 ; Segment permissions: Read/Execute
.text$mn:000018B4 _text$mn        segment para public 'CODE' use32
.text$mn:000018B4                 assume cs:_text$mn
.text$mn:000018B4                 ;org 18B4h
.text$mn:000018B4 ; COMDAT (pick any)
.text$mn:000018B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018B4
.text$mn:000018B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B4
.text$mn:000018B4 ; Attributes: bp-based frame
.text$mn:000018B4
.text$mn:000018B4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000018B4                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000018B4 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000018B4                                         ; CODE XREF: $LN19+60p
.text$mn:000018B4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000018B4
.text$mn:000018B4 var_8           = dword ptr -8
.text$mn:000018B4 var_1           = byte ptr -1
.text$mn:000018B4 arg_0           = dword ptr  8
.text$mn:000018B4
.text$mn:000018B4                 push    ebp
.text$mn:000018B5                 mov     ebp, esp
.text$mn:000018B7                 sub     esp, 8
.text$mn:000018BA                 mov     [ebp+var_8], ecx
.text$mn:000018BD                 mov     [ebp+var_1], 0
.text$mn:000018C1                 mov     eax, [ebp+var_8]
.text$mn:000018C4                 mov     ecx, [ebp+arg_0]
.text$mn:000018C7                 mov     [eax+14h], ecx
.text$mn:000018CA                 lea     edx, [ebp+var_1]
.text$mn:000018CD                 push    edx
.text$mn:000018CE                 mov     ecx, [ebp+var_8]
.text$mn:000018D1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000018D6                 add     eax, [ebp+arg_0]
.text$mn:000018D9                 push    eax
.text$mn:000018DA                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000018DF                 add     esp, 8
.text$mn:000018E2                 mov     esp, ebp
.text$mn:000018E4                 pop     ebp
.text$mn:000018E5                 retn    4
.text$mn:000018E5 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000018E5
.text$mn:000018E5 _text$mn        ends
.text$mn:000018E5
.text$mn:000018E8 ; ===========================================================================
.text$mn:000018E8
.text$mn:000018E8 ; Segment type: Pure code
.text$mn:000018E8 ; Segment permissions: Read/Execute
.text$mn:000018E8 _text$mn        segment para public 'CODE' use32
.text$mn:000018E8                 assume cs:_text$mn
.text$mn:000018E8                 ;org 18E8h
.text$mn:000018E8 ; COMDAT (pick any)
.text$mn:000018E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018E8
.text$mn:000018E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018E8
.text$mn:000018E8 ; Attributes: bp-based frame
.text$mn:000018E8
.text$mn:000018E8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:000018E8                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:000018E8 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:000018E8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+97p
.text$mn:000018E8
.text$mn:000018E8 var_8           = dword ptr -8
.text$mn:000018E8 var_2           = word ptr -2
.text$mn:000018E8 arg_0           = dword ptr  8
.text$mn:000018E8
.text$mn:000018E8                 push    ebp
.text$mn:000018E9                 mov     ebp, esp
.text$mn:000018EB                 sub     esp, 8
.text$mn:000018EE                 mov     [ebp+var_8], ecx
.text$mn:000018F1                 xor     eax, eax
.text$mn:000018F3                 mov     [ebp+var_2], ax
.text$mn:000018F7                 mov     ecx, [ebp+var_8]
.text$mn:000018FA                 mov     edx, [ebp+arg_0]
.text$mn:000018FD                 mov     [ecx+14h], edx
.text$mn:00001900                 lea     eax, [ebp+var_2]
.text$mn:00001903                 push    eax
.text$mn:00001904                 mov     ecx, [ebp+var_8]
.text$mn:00001907                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000190C                 mov     ecx, [ebp+arg_0]
.text$mn:0000190F                 lea     edx, [eax+ecx*2]
.text$mn:00001912                 push    edx
.text$mn:00001913                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00001918                 add     esp, 8
.text$mn:0000191B                 mov     esp, ebp
.text$mn:0000191D                 pop     ebp
.text$mn:0000191E                 retn    4
.text$mn:0000191E ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:0000191E
.text$mn:0000191E ; ---------------------------------------------------------------------------
.text$mn:00001921                 align 4
.text$mn:00001921 _text$mn        ends
.text$mn:00001921
.text$mn:00001924 ; ===========================================================================
.text$mn:00001924
.text$mn:00001924 ; Segment type: Pure code
.text$mn:00001924 ; Segment permissions: Read/Execute
.text$mn:00001924 _text$mn        segment para public 'CODE' use32
.text$mn:00001924                 assume cs:_text$mn
.text$mn:00001924                 ;org 1924h
.text$mn:00001924 ; COMDAT (pick any)
.text$mn:00001924                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001924
.text$mn:00001924 ; =============== S U B R O U T I N E =======================================
.text$mn:00001924
.text$mn:00001924 ; Attributes: bp-based frame
.text$mn:00001924
.text$mn:00001924 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001924                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001924 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001924                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001924
.text$mn:00001924 var_8           = dword ptr -8
.text$mn:00001924 var_1           = byte ptr -1
.text$mn:00001924
.text$mn:00001924                 push    ebp
.text$mn:00001925                 mov     ebp, esp
.text$mn:00001927                 sub     esp, 8
.text$mn:0000192A                 mov     [ebp+var_8], ecx
.text$mn:0000192D                 lea     ecx, [ebp+var_1]
.text$mn:00001930                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001935                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001938                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000193D                 mov     eax, [ebp+var_8]
.text$mn:00001940                 mov     ecx, [eax]
.text$mn:00001942                 push    ecx
.text$mn:00001943                 lea     ecx, [ebp+var_1]
.text$mn:00001946                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000194B                 push    1               ; int
.text$mn:0000194D                 mov     edx, [ebp+var_8]
.text$mn:00001950                 mov     eax, [edx]
.text$mn:00001952                 push    eax             ; void *
.text$mn:00001953                 lea     ecx, [ebp+var_1]
.text$mn:00001956                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000195B                 mov     ecx, [ebp+var_8]
.text$mn:0000195E                 mov     dword ptr [ecx], 0
.text$mn:00001964                 mov     esp, ebp
.text$mn:00001966                 pop     ebp
.text$mn:00001967                 retn
.text$mn:00001967 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001967
.text$mn:00001967 _text$mn        ends
.text$mn:00001967
.text$mn:00001968 ; ===========================================================================
.text$mn:00001968
.text$mn:00001968 ; Segment type: Pure code
.text$mn:00001968 ; Segment permissions: Read/Execute
.text$mn:00001968 _text$mn        segment para public 'CODE' use32
.text$mn:00001968                 assume cs:_text$mn
.text$mn:00001968                 ;org 1968h
.text$mn:00001968 ; COMDAT (pick any)
.text$mn:00001968                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001968
.text$mn:00001968 ; =============== S U B R O U T I N E =======================================
.text$mn:00001968
.text$mn:00001968 ; Attributes: bp-based frame
.text$mn:00001968
.text$mn:00001968 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00001968                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00001968 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001968                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00001968
.text$mn:00001968 var_8           = dword ptr -8
.text$mn:00001968 var_1           = byte ptr -1
.text$mn:00001968
.text$mn:00001968                 push    ebp
.text$mn:00001969                 mov     ebp, esp
.text$mn:0000196B                 sub     esp, 8
.text$mn:0000196E                 mov     [ebp+var_8], ecx
.text$mn:00001971                 lea     ecx, [ebp+var_1]
.text$mn:00001974                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001979                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000197C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001981                 mov     eax, [ebp+var_8]
.text$mn:00001984                 mov     ecx, [eax]
.text$mn:00001986                 push    ecx
.text$mn:00001987                 lea     ecx, [ebp+var_1]
.text$mn:0000198A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000198F                 push    1               ; int
.text$mn:00001991                 mov     edx, [ebp+var_8]
.text$mn:00001994                 mov     eax, [edx]
.text$mn:00001996                 push    eax             ; void *
.text$mn:00001997                 lea     ecx, [ebp+var_1]
.text$mn:0000199A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000199F                 mov     ecx, [ebp+var_8]
.text$mn:000019A2                 mov     dword ptr [ecx], 0
.text$mn:000019A8                 mov     esp, ebp
.text$mn:000019AA                 pop     ebp
.text$mn:000019AB                 retn
.text$mn:000019AB ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000019AB
.text$mn:000019AB _text$mn        ends
.text$mn:000019AB
.text$mn:000019AC ; ===========================================================================
.text$mn:000019AC
.text$mn:000019AC ; Segment type: Pure code
.text$mn:000019AC ; Segment permissions: Read/Execute
.text$mn:000019AC _text$mn        segment para public 'CODE' use32
.text$mn:000019AC                 assume cs:_text$mn
.text$mn:000019AC                 ;org 19ACh
.text$mn:000019AC ; COMDAT (pick any)
.text$mn:000019AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019AC
.text$mn:000019AC ; =============== S U B R O U T I N E =======================================
.text$mn:000019AC
.text$mn:000019AC ; Attributes: bp-based frame
.text$mn:000019AC
.text$mn:000019AC ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000019AC                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000019AC ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000019AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000019AC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000019AC
.text$mn:000019AC var_4           = dword ptr -4
.text$mn:000019AC arg_0           = dword ptr  8
.text$mn:000019AC
.text$mn:000019AC                 push    ebp
.text$mn:000019AD                 mov     ebp, esp
.text$mn:000019AF                 push    ecx
.text$mn:000019B0                 mov     [ebp+var_4], ecx
.text$mn:000019B3                 mov     ecx, [ebp+arg_0]
.text$mn:000019B6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000019BB                 mov     eax, [ebp+arg_0]
.text$mn:000019BE                 mov     esp, ebp
.text$mn:000019C0                 pop     ebp
.text$mn:000019C1                 retn    4
.text$mn:000019C1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000019C1
.text$mn:000019C1 _text$mn        ends
.text$mn:000019C1
.text$mn:000019C4 ; ===========================================================================
.text$mn:000019C4
.text$mn:000019C4 ; Segment type: Pure code
.text$mn:000019C4 ; Segment permissions: Read/Execute
.text$mn:000019C4 _text$mn        segment para public 'CODE' use32
.text$mn:000019C4                 assume cs:_text$mn
.text$mn:000019C4                 ;org 19C4h
.text$mn:000019C4 ; COMDAT (pick any)
.text$mn:000019C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019C4
.text$mn:000019C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C4
.text$mn:000019C4 ; Attributes: bp-based frame
.text$mn:000019C4
.text$mn:000019C4 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:000019C4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:000019C4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:000019C4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+33p
.text$mn:000019C4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+7Ap
.text$mn:000019C4
.text$mn:000019C4 var_4           = dword ptr -4
.text$mn:000019C4 arg_0           = dword ptr  8
.text$mn:000019C4
.text$mn:000019C4                 push    ebp
.text$mn:000019C5                 mov     ebp, esp
.text$mn:000019C7                 push    ecx
.text$mn:000019C8                 mov     [ebp+var_4], ecx
.text$mn:000019CB                 mov     ecx, [ebp+arg_0]
.text$mn:000019CE                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:000019D3                 mov     eax, [ebp+arg_0]
.text$mn:000019D6                 mov     esp, ebp
.text$mn:000019D8                 pop     ebp
.text$mn:000019D9                 retn    4
.text$mn:000019D9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:000019D9
.text$mn:000019D9 _text$mn        ends
.text$mn:000019D9
.text$mn:000019DC ; ===========================================================================
.text$mn:000019DC
.text$mn:000019DC ; Segment type: Pure code
.text$mn:000019DC ; Segment permissions: Read/Execute
.text$mn:000019DC _text$mn        segment para public 'CODE' use32
.text$mn:000019DC                 assume cs:_text$mn
.text$mn:000019DC                 ;org 19DCh
.text$mn:000019DC ; COMDAT (pick any)
.text$mn:000019DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019DC
.text$mn:000019DC ; =============== S U B R O U T I N E =======================================
.text$mn:000019DC
.text$mn:000019DC ; Attributes: bp-based frame
.text$mn:000019DC
.text$mn:000019DC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000019DC                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000019DC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000019DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000019DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000019DC
.text$mn:000019DC var_C           = dword ptr -0Ch
.text$mn:000019DC Size            = dword ptr -8
.text$mn:000019DC var_4           = dword ptr -4
.text$mn:000019DC arg_0           = dword ptr  8
.text$mn:000019DC arg_4           = byte ptr  0Ch
.text$mn:000019DC
.text$mn:000019DC                 push    ebp
.text$mn:000019DD                 mov     ebp, esp
.text$mn:000019DF                 sub     esp, 0Ch
.text$mn:000019E2                 mov     [ebp+var_4], ecx
.text$mn:000019E5                 mov     ecx, [ebp+var_4]
.text$mn:000019E8                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000019ED                 cmp     eax, [ebp+arg_0]
.text$mn:000019F0                 jnb     short loc_19FA
.text$mn:000019F2                 mov     ecx, [ebp+var_4]
.text$mn:000019F5                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000019FA
.text$mn:000019FA loc_19FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000019FA                 mov     eax, [ebp+var_4]
.text$mn:000019FD                 mov     ecx, [eax+18h]
.text$mn:00001A00                 cmp     ecx, [ebp+arg_0]
.text$mn:00001A03                 jnb     short loc_1A1A
.text$mn:00001A05                 mov     edx, [ebp+var_4]
.text$mn:00001A08                 mov     eax, [edx+14h]
.text$mn:00001A0B                 push    eax
.text$mn:00001A0C                 mov     ecx, [ebp+arg_0]
.text$mn:00001A0F                 push    ecx
.text$mn:00001A10                 mov     ecx, [ebp+var_4]
.text$mn:00001A13                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001A18                 jmp     short loc_1A64
.text$mn:00001A1A ; ---------------------------------------------------------------------------
.text$mn:00001A1A
.text$mn:00001A1A loc_1A1A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001A1A                 movzx   edx, [ebp+arg_4]
.text$mn:00001A1E                 test    edx, edx
.text$mn:00001A20                 jz      short loc_1A54
.text$mn:00001A22                 cmp     [ebp+arg_0], 10h
.text$mn:00001A26                 jnb     short loc_1A54
.text$mn:00001A28                 mov     eax, [ebp+var_4]
.text$mn:00001A2B                 mov     ecx, [ebp+arg_0]
.text$mn:00001A2E                 cmp     ecx, [eax+14h]
.text$mn:00001A31                 jnb     short loc_1A3B
.text$mn:00001A33                 mov     edx, [ebp+arg_0]
.text$mn:00001A36                 mov     [ebp+Size], edx
.text$mn:00001A39                 jmp     short loc_1A44
.text$mn:00001A3B ; ---------------------------------------------------------------------------
.text$mn:00001A3B
.text$mn:00001A3B loc_1A3B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001A3B                 mov     eax, [ebp+var_4]
.text$mn:00001A3E                 mov     ecx, [eax+14h]
.text$mn:00001A41                 mov     [ebp+Size], ecx
.text$mn:00001A44
.text$mn:00001A44 loc_1A44:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001A44                 mov     edx, [ebp+Size]
.text$mn:00001A47                 push    edx             ; Size
.text$mn:00001A48                 push    1               ; char
.text$mn:00001A4A                 mov     ecx, [ebp+var_4]
.text$mn:00001A4D                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001A52                 jmp     short loc_1A64
.text$mn:00001A54 ; ---------------------------------------------------------------------------
.text$mn:00001A54
.text$mn:00001A54 loc_1A54:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001A54                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001A54                 cmp     [ebp+arg_0], 0
.text$mn:00001A58                 jnz     short loc_1A64
.text$mn:00001A5A                 push    0
.text$mn:00001A5C                 mov     ecx, [ebp+var_4]
.text$mn:00001A5F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001A64
.text$mn:00001A64 loc_1A64:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001A64                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001A64                 cmp     [ebp+arg_0], 0
.text$mn:00001A68                 jbe     short loc_1A73
.text$mn:00001A6A                 mov     [ebp+var_C], 1
.text$mn:00001A71                 jmp     short loc_1A7A
.text$mn:00001A73 ; ---------------------------------------------------------------------------
.text$mn:00001A73
.text$mn:00001A73 loc_1A73:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00001A73                 mov     [ebp+var_C], 0
.text$mn:00001A7A
.text$mn:00001A7A loc_1A7A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001A7A                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001A7D                 mov     esp, ebp
.text$mn:00001A7F                 pop     ebp
.text$mn:00001A80                 retn    8
.text$mn:00001A80 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001A80
.text$mn:00001A80 ; ---------------------------------------------------------------------------
.text$mn:00001A83                 align 4
.text$mn:00001A83 _text$mn        ends
.text$mn:00001A83
.text$mn:00001A84 ; ===========================================================================
.text$mn:00001A84
.text$mn:00001A84 ; Segment type: Pure code
.text$mn:00001A84 ; Segment permissions: Read/Execute
.text$mn:00001A84 _text$mn        segment para public 'CODE' use32
.text$mn:00001A84                 assume cs:_text$mn
.text$mn:00001A84                 ;org 1A84h
.text$mn:00001A84 ; COMDAT (pick any)
.text$mn:00001A84                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A84
.text$mn:00001A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A84
.text$mn:00001A84 ; Attributes: bp-based frame
.text$mn:00001A84
.text$mn:00001A84 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001A84                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001A84 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001A84                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001A84
.text$mn:00001A84 var_4           = dword ptr -4
.text$mn:00001A84 arg_0           = dword ptr  8
.text$mn:00001A84
.text$mn:00001A84                 push    ebp
.text$mn:00001A85                 mov     ebp, esp
.text$mn:00001A87                 push    ecx
.text$mn:00001A88                 mov     [ebp+var_4], ecx
.text$mn:00001A8B                 cmp     [ebp+arg_0], 0
.text$mn:00001A8F                 jz      short loc_1AB1
.text$mn:00001A91                 mov     ecx, [ebp+var_4]
.text$mn:00001A94                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A99                 cmp     [ebp+arg_0], eax
.text$mn:00001A9C                 jb      short loc_1AB1
.text$mn:00001A9E                 mov     ecx, [ebp+var_4]
.text$mn:00001AA1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001AA6                 mov     ecx, [ebp+var_4]
.text$mn:00001AA9                 add     eax, [ecx+14h]
.text$mn:00001AAC                 cmp     eax, [ebp+arg_0]
.text$mn:00001AAF                 ja      short loc_1AB7
.text$mn:00001AB1
.text$mn:00001AB1 loc_1AB1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001AB1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001AB1                 xor     al, al
.text$mn:00001AB3                 jmp     short loc_1AB9
.text$mn:00001AB5 ; ---------------------------------------------------------------------------
.text$mn:00001AB5                 jmp     short loc_1AB9
.text$mn:00001AB7 ; ---------------------------------------------------------------------------
.text$mn:00001AB7
.text$mn:00001AB7 loc_1AB7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00001AB7                 mov     al, 1
.text$mn:00001AB9
.text$mn:00001AB9 loc_1AB9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001AB9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001AB9                 mov     esp, ebp
.text$mn:00001ABB                 pop     ebp
.text$mn:00001ABC                 retn    4
.text$mn:00001ABC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001ABC
.text$mn:00001ABC ; ---------------------------------------------------------------------------
.text$mn:00001ABF                 align 10h
.text$mn:00001ABF _text$mn        ends
.text$mn:00001ABF
.text$mn:00001AC0 ; ===========================================================================
.text$mn:00001AC0
.text$mn:00001AC0 ; Segment type: Pure code
.text$mn:00001AC0 ; Segment permissions: Read/Execute
.text$mn:00001AC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AC0                 assume cs:_text$mn
.text$mn:00001AC0                 ;org 1AC0h
.text$mn:00001AC0 ; COMDAT (pick any)
.text$mn:00001AC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001AC0
.text$mn:00001AC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC0
.text$mn:00001AC0 ; Attributes: bp-based frame
.text$mn:00001AC0
.text$mn:00001AC0 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001AC0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001AC0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001AC0                                         ; CODE XREF: $LN19+14p
.text$mn:00001AC0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001AC0
.text$mn:00001AC0 var_8           = dword ptr -8
.text$mn:00001AC0 var_4           = dword ptr -4
.text$mn:00001AC0
.text$mn:00001AC0                 push    ebp
.text$mn:00001AC1                 mov     ebp, esp
.text$mn:00001AC3                 sub     esp, 8
.text$mn:00001AC6                 mov     [ebp+var_4], ecx
.text$mn:00001AC9                 mov     eax, [ebp+var_4]
.text$mn:00001ACC                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001AD0                 jb      short loc_1AE6
.text$mn:00001AD2                 mov     ecx, [ebp+var_4]
.text$mn:00001AD5                 mov     edx, [ecx+4]
.text$mn:00001AD8                 push    edx
.text$mn:00001AD9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001ADE                 add     esp, 4
.text$mn:00001AE1                 mov     [ebp+var_8], eax
.text$mn:00001AE4                 jmp     short loc_1AEF
.text$mn:00001AE6 ; ---------------------------------------------------------------------------
.text$mn:00001AE6
.text$mn:00001AE6 loc_1AE6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001AE6                 mov     eax, [ebp+var_4]
.text$mn:00001AE9                 add     eax, 4
.text$mn:00001AEC                 mov     [ebp+var_8], eax
.text$mn:00001AEF
.text$mn:00001AEF loc_1AEF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001AEF                 mov     eax, [ebp+var_8]
.text$mn:00001AF2                 mov     esp, ebp
.text$mn:00001AF4                 pop     ebp
.text$mn:00001AF5                 retn
.text$mn:00001AF5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001AF5
.text$mn:00001AF5 ; ---------------------------------------------------------------------------
.text$mn:00001AF6                 align 4
.text$mn:00001AF6 _text$mn        ends
.text$mn:00001AF6
.text$mn:00001AF8 ; ===========================================================================
.text$mn:00001AF8
.text$mn:00001AF8 ; Segment type: Pure code
.text$mn:00001AF8 ; Segment permissions: Read/Execute
.text$mn:00001AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AF8                 assume cs:_text$mn
.text$mn:00001AF8                 ;org 1AF8h
.text$mn:00001AF8 ; COMDAT (pick any)
.text$mn:00001AF8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001AF8
.text$mn:00001AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AF8
.text$mn:00001AF8 ; Attributes: bp-based frame
.text$mn:00001AF8
.text$mn:00001AF8 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00001AF8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00001AF8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00001AF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00001AF8
.text$mn:00001AF8 var_8           = dword ptr -8
.text$mn:00001AF8 var_4           = dword ptr -4
.text$mn:00001AF8
.text$mn:00001AF8                 push    ebp
.text$mn:00001AF9                 mov     ebp, esp
.text$mn:00001AFB                 sub     esp, 8
.text$mn:00001AFE                 mov     [ebp+var_4], ecx
.text$mn:00001B01                 mov     eax, [ebp+var_4]
.text$mn:00001B04                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001B08                 jb      short loc_1B1E
.text$mn:00001B0A                 mov     ecx, [ebp+var_4]
.text$mn:00001B0D                 mov     edx, [ecx+4]
.text$mn:00001B10                 push    edx
.text$mn:00001B11                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001B16                 add     esp, 4
.text$mn:00001B19                 mov     [ebp+var_8], eax
.text$mn:00001B1C                 jmp     short loc_1B27
.text$mn:00001B1E ; ---------------------------------------------------------------------------
.text$mn:00001B1E
.text$mn:00001B1E loc_1B1E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001B1E                 mov     eax, [ebp+var_4]
.text$mn:00001B21                 add     eax, 4
.text$mn:00001B24                 mov     [ebp+var_8], eax
.text$mn:00001B27
.text$mn:00001B27 loc_1B27:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001B27                 mov     eax, [ebp+var_8]
.text$mn:00001B2A                 mov     esp, ebp
.text$mn:00001B2C                 pop     ebp
.text$mn:00001B2D                 retn
.text$mn:00001B2D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001B2D
.text$mn:00001B2D ; ---------------------------------------------------------------------------
.text$mn:00001B2E                 align 10h
.text$mn:00001B2E _text$mn        ends
.text$mn:00001B2E
.text$mn:00001B30 ; ===========================================================================
.text$mn:00001B30
.text$mn:00001B30 ; Segment type: Pure code
.text$mn:00001B30 ; Segment permissions: Read/Execute
.text$mn:00001B30 _text$mn        segment para public 'CODE' use32
.text$mn:00001B30                 assume cs:_text$mn
.text$mn:00001B30                 ;org 1B30h
.text$mn:00001B30 ; COMDAT (pick any)
.text$mn:00001B30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B30
.text$mn:00001B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B30
.text$mn:00001B30 ; Attributes: bp-based frame
.text$mn:00001B30
.text$mn:00001B30 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001B30                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00001B30 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00001B30                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp
.text$mn:00001B30
.text$mn:00001B30 var_8           = dword ptr -8
.text$mn:00001B30 var_4           = dword ptr -4
.text$mn:00001B30
.text$mn:00001B30                 push    ebp
.text$mn:00001B31                 mov     ebp, esp
.text$mn:00001B33                 sub     esp, 8
.text$mn:00001B36                 mov     [ebp+var_4], ecx
.text$mn:00001B39                 mov     eax, [ebp+var_4]
.text$mn:00001B3C                 cmp     dword ptr [eax+18h], 8
.text$mn:00001B40                 jb      short loc_1B56
.text$mn:00001B42                 mov     ecx, [ebp+var_4]
.text$mn:00001B45                 mov     edx, [ecx+4]
.text$mn:00001B48                 push    edx
.text$mn:00001B49                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001B4E                 add     esp, 4
.text$mn:00001B51                 mov     [ebp+var_8], eax
.text$mn:00001B54                 jmp     short loc_1B5F
.text$mn:00001B56 ; ---------------------------------------------------------------------------
.text$mn:00001B56
.text$mn:00001B56 loc_1B56:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00001B56                 mov     eax, [ebp+var_4]
.text$mn:00001B59                 add     eax, 4
.text$mn:00001B5C                 mov     [ebp+var_8], eax
.text$mn:00001B5F
.text$mn:00001B5F loc_1B5F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001B5F                 mov     eax, [ebp+var_8]
.text$mn:00001B62                 mov     esp, ebp
.text$mn:00001B64                 pop     ebp
.text$mn:00001B65                 retn
.text$mn:00001B65 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00001B65
.text$mn:00001B65 ; ---------------------------------------------------------------------------
.text$mn:00001B66                 align 4
.text$mn:00001B66 _text$mn        ends
.text$mn:00001B66
.text$mn:00001B68 ; ===========================================================================
.text$mn:00001B68
.text$mn:00001B68 ; Segment type: Pure code
.text$mn:00001B68 ; Segment permissions: Read/Execute
.text$mn:00001B68 _text$mn        segment para public 'CODE' use32
.text$mn:00001B68                 assume cs:_text$mn
.text$mn:00001B68                 ;org 1B68h
.text$mn:00001B68 ; COMDAT (pick any)
.text$mn:00001B68                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B68
.text$mn:00001B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B68
.text$mn:00001B68 ; Attributes: bp-based frame
.text$mn:00001B68
.text$mn:00001B68 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00001B68                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00001B68 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00001B68                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:00001B68
.text$mn:00001B68 var_8           = dword ptr -8
.text$mn:00001B68 var_4           = dword ptr -4
.text$mn:00001B68
.text$mn:00001B68                 push    ebp
.text$mn:00001B69                 mov     ebp, esp
.text$mn:00001B6B                 sub     esp, 8
.text$mn:00001B6E                 mov     [ebp+var_4], ecx
.text$mn:00001B71                 mov     eax, [ebp+var_4]
.text$mn:00001B74                 cmp     dword ptr [eax+18h], 8
.text$mn:00001B78                 jb      short loc_1B8E
.text$mn:00001B7A                 mov     ecx, [ebp+var_4]
.text$mn:00001B7D                 mov     edx, [ecx+4]
.text$mn:00001B80                 push    edx
.text$mn:00001B81                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001B86                 add     esp, 4
.text$mn:00001B89                 mov     [ebp+var_8], eax
.text$mn:00001B8C                 jmp     short loc_1B97
.text$mn:00001B8E ; ---------------------------------------------------------------------------
.text$mn:00001B8E
.text$mn:00001B8E loc_1B8E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00001B8E                 mov     eax, [ebp+var_4]
.text$mn:00001B91                 add     eax, 4
.text$mn:00001B94                 mov     [ebp+var_8], eax
.text$mn:00001B97
.text$mn:00001B97 loc_1B97:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001B97                 mov     eax, [ebp+var_8]
.text$mn:00001B9A                 mov     esp, ebp
.text$mn:00001B9C                 pop     ebp
.text$mn:00001B9D                 retn
.text$mn:00001B9D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00001B9D
.text$mn:00001B9D ; ---------------------------------------------------------------------------
.text$mn:00001B9E                 align 10h
.text$mn:00001B9E _text$mn        ends
.text$mn:00001B9E
.text$mn:00001BA0 ; ===========================================================================
.text$mn:00001BA0
.text$mn:00001BA0 ; Segment type: Pure code
.text$mn:00001BA0 ; Segment permissions: Read/Execute
.text$mn:00001BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BA0                 assume cs:_text$mn
.text$mn:00001BA0                 ;org 1BA0h
.text$mn:00001BA0 ; COMDAT (pick any)
.text$mn:00001BA0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BA0
.text$mn:00001BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BA0
.text$mn:00001BA0 ; Attributes: bp-based frame
.text$mn:00001BA0
.text$mn:00001BA0 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001BA0                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001BA0 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001BA0                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001BA0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00001BA0
.text$mn:00001BA0 var_18          = byte ptr -18h
.text$mn:00001BA0 var_14          = dword ptr -14h
.text$mn:00001BA0 var_10          = dword ptr -10h
.text$mn:00001BA0 var_C           = dword ptr -0Ch
.text$mn:00001BA0 var_4           = dword ptr -4
.text$mn:00001BA0
.text$mn:00001BA0                 push    ebp
.text$mn:00001BA1                 mov     ebp, esp
.text$mn:00001BA3                 push    0FFFFFFFFh
.text$mn:00001BA5                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001BAA                 mov     eax, large fs:0
.text$mn:00001BB0                 push    eax
.text$mn:00001BB1                 sub     esp, 0Ch
.text$mn:00001BB4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001BB9                 xor     eax, ebp
.text$mn:00001BBB                 push    eax
.text$mn:00001BBC                 lea     eax, [ebp+var_C]
.text$mn:00001BBF                 mov     large fs:0, eax
.text$mn:00001BC5                 mov     [ebp+var_14], ecx
.text$mn:00001BC8                 mov     eax, [ebp+var_14]
.text$mn:00001BCB                 cmp     dword ptr [eax], 0
.text$mn:00001BCE                 jz      short loc_1C2B
.text$mn:00001BD0                 push    3               ; int
.text$mn:00001BD2                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001BD5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001BDA                 mov     [ebp+var_4], 0
.text$mn:00001BE1                 mov     ecx, [ebp+var_14]
.text$mn:00001BE4                 mov     edx, [ecx]
.text$mn:00001BE6                 add     edx, 4
.text$mn:00001BE9                 mov     [ebp+var_10], edx
.text$mn:00001BEC                 jmp     short loc_1BFB
.text$mn:00001BEE ; ---------------------------------------------------------------------------
.text$mn:00001BEE
.text$mn:00001BEE loc_1BEE:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00001BEE                 mov     eax, [ebp+var_10]
.text$mn:00001BF1                 mov     ecx, [eax]
.text$mn:00001BF3                 mov     edx, [ebp+var_10]
.text$mn:00001BF6                 mov     eax, [ecx+4]
.text$mn:00001BF9                 mov     [edx], eax
.text$mn:00001BFB
.text$mn:00001BFB loc_1BFB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001BFB                 mov     ecx, [ebp+var_10]
.text$mn:00001BFE                 cmp     dword ptr [ecx], 0
.text$mn:00001C01                 jz      short loc_1C10
.text$mn:00001C03                 mov     edx, [ebp+var_10]
.text$mn:00001C06                 mov     eax, [edx]
.text$mn:00001C08                 mov     dword ptr [eax], 0
.text$mn:00001C0E                 jmp     short loc_1BEE
.text$mn:00001C10 ; ---------------------------------------------------------------------------
.text$mn:00001C10
.text$mn:00001C10 loc_1C10:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001C10                 mov     ecx, [ebp+var_14]
.text$mn:00001C13                 mov     edx, [ecx]
.text$mn:00001C15                 mov     dword ptr [edx+4], 0
.text$mn:00001C1C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001C23                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001C26                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001C2B
.text$mn:00001C2B loc_1C2B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001C2B                 mov     ecx, [ebp+var_C]
.text$mn:00001C2E                 mov     large fs:0, ecx
.text$mn:00001C35                 pop     ecx
.text$mn:00001C36                 mov     esp, ebp
.text$mn:00001C38                 pop     ebp
.text$mn:00001C39                 retn
.text$mn:00001C39 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001C39
.text$mn:00001C39 ; ---------------------------------------------------------------------------
.text$mn:00001C3A                 align 4
.text$mn:00001C3A _text$mn        ends
.text$mn:00001C3A
.text$x:00001C3C ; ===========================================================================
.text$x:00001C3C
.text$x:00001C3C ; Segment type: Pure code
.text$x:00001C3C ; Segment permissions: Read/Execute
.text$x:00001C3C _text$x         segment para public 'CODE' use32
.text$x:00001C3C                 assume cs:_text$x
.text$x:00001C3C                 ;org 1C3Ch
.text$x:00001C3C ; COMDAT (pick associative to section at 1BA0)
.text$x:00001C3C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001C3C
.text$x:00001C3C ; =============== S U B R O U T I N E =======================================
.text$x:00001C3C
.text$x:00001C3C
.text$x:00001C3C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001C3C                                         ; DATA XREF: .xdata$x:000027DCo
.text$x:00001C3C                 lea     ecx, [ebp-18h]  ; this
.text$x:00001C3F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00001C3F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00001C3F
.text$x:00001C44
.text$x:00001C44 ; =============== S U B R O U T I N E =======================================
.text$x:00001C44
.text$x:00001C44
.text$x:00001C44 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001C44                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001C44
.text$x:00001C44 arg_4           = dword ptr  8
.text$x:00001C44
.text$x:00001C44                 mov     edx, [esp+arg_4]
.text$x:00001C48                 lea     eax, [edx+0Ch]
.text$x:00001C4B                 mov     ecx, [edx-10h]
.text$x:00001C4E                 xor     ecx, eax
.text$x:00001C50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C55                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001C5A                 jmp     ___CxxFrameHandler3
.text$x:00001C5A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001C5A
.text$x:00001C5A ; ---------------------------------------------------------------------------
.text$x:00001C5F                 align 10h
.text$x:00001C5F _text$x         ends
.text$x:00001C5F
.text$mn:00001C60 ; ===========================================================================
.text$mn:00001C60
.text$mn:00001C60 ; Segment type: Pure code
.text$mn:00001C60 ; Segment permissions: Read/Execute
.text$mn:00001C60 _text$mn        segment para public 'CODE' use32
.text$mn:00001C60                 assume cs:_text$mn
.text$mn:00001C60                 ;org 1C60h
.text$mn:00001C60 ; COMDAT (pick any)
.text$mn:00001C60                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C60
.text$mn:00001C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C60
.text$mn:00001C60 ; Attributes: bp-based frame
.text$mn:00001C60
.text$mn:00001C60 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001C60                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001C60 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001C60                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001C60                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001C60
.text$mn:00001C60 var_C           = dword ptr -0Ch
.text$mn:00001C60 var_8           = dword ptr -8
.text$mn:00001C60 var_2           = byte ptr -2
.text$mn:00001C60 var_1           = byte ptr -1
.text$mn:00001C60 arg_0           = byte ptr  8
.text$mn:00001C60 Size            = dword ptr  0Ch
.text$mn:00001C60
.text$mn:00001C60                 push    ebp
.text$mn:00001C61                 mov     ebp, esp
.text$mn:00001C63                 sub     esp, 0Ch
.text$mn:00001C66                 mov     [ebp+var_8], ecx
.text$mn:00001C69                 movzx   eax, [ebp+arg_0]
.text$mn:00001C6D                 test    eax, eax
.text$mn:00001C6F                 jnz     short loc_1C73
.text$mn:00001C71                 jmp     short loc_1CE6
.text$mn:00001C73 ; ---------------------------------------------------------------------------
.text$mn:00001C73
.text$mn:00001C73 loc_1C73:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001C73                 mov     ecx, [ebp+var_8]
.text$mn:00001C76                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001C7A                 jb      short loc_1CE6
.text$mn:00001C7C                 mov     edx, [ebp+var_8]
.text$mn:00001C7F                 mov     eax, [edx+4]
.text$mn:00001C82                 mov     [ebp+var_C], eax
.text$mn:00001C85                 mov     ecx, [ebp+var_8]
.text$mn:00001C88                 add     ecx, 4
.text$mn:00001C8B                 push    ecx
.text$mn:00001C8C                 lea     edx, [ebp+var_1]
.text$mn:00001C8F                 push    edx
.text$mn:00001C90                 mov     ecx, [ebp+var_8]
.text$mn:00001C93                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001C98                 mov     ecx, eax
.text$mn:00001C9A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001C9F                 cmp     [ebp+Size], 0
.text$mn:00001CA3                 jbe     short loc_1CC5
.text$mn:00001CA5                 mov     eax, [ebp+Size]
.text$mn:00001CA8                 push    eax             ; Size
.text$mn:00001CA9                 mov     ecx, [ebp+var_C]
.text$mn:00001CAC                 push    ecx
.text$mn:00001CAD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001CB2                 add     esp, 4
.text$mn:00001CB5                 push    eax             ; Src
.text$mn:00001CB6                 mov     edx, [ebp+var_8]
.text$mn:00001CB9                 add     edx, 4
.text$mn:00001CBC                 push    edx             ; Dst
.text$mn:00001CBD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001CC2                 add     esp, 0Ch
.text$mn:00001CC5
.text$mn:00001CC5 loc_1CC5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001CC5                 mov     eax, [ebp+var_8]
.text$mn:00001CC8                 mov     ecx, [eax+18h]
.text$mn:00001CCB                 add     ecx, 1
.text$mn:00001CCE                 push    ecx             ; int
.text$mn:00001CCF                 mov     edx, [ebp+var_C]
.text$mn:00001CD2                 push    edx             ; void *
.text$mn:00001CD3                 lea     eax, [ebp+var_2]
.text$mn:00001CD6                 push    eax
.text$mn:00001CD7                 mov     ecx, [ebp+var_8]
.text$mn:00001CDA                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001CDF                 mov     ecx, eax
.text$mn:00001CE1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001CE6
.text$mn:00001CE6 loc_1CE6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001CE6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001CE6                 mov     ecx, [ebp+var_8]
.text$mn:00001CE9                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001CF0                 mov     edx, [ebp+Size]
.text$mn:00001CF3                 push    edx
.text$mn:00001CF4                 mov     ecx, [ebp+var_8]
.text$mn:00001CF7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001CFC                 mov     esp, ebp
.text$mn:00001CFE                 pop     ebp
.text$mn:00001CFF                 retn    8
.text$mn:00001CFF ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001CFF
.text$mn:00001CFF ; ---------------------------------------------------------------------------
.text$mn:00001D02                 align 4
.text$mn:00001D02 _text$mn        ends
.text$mn:00001D02
.text$mn:00001D04 ; ===========================================================================
.text$mn:00001D04
.text$mn:00001D04 ; Segment type: Pure code
.text$mn:00001D04 ; Segment permissions: Read/Execute
.text$mn:00001D04 _text$mn        segment para public 'CODE' use32
.text$mn:00001D04                 assume cs:_text$mn
.text$mn:00001D04                 ;org 1D04h
.text$mn:00001D04 ; COMDAT (pick any)
.text$mn:00001D04                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D04
.text$mn:00001D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D04
.text$mn:00001D04 ; Attributes: bp-based frame
.text$mn:00001D04
.text$mn:00001D04 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00001D04                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00001D04 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00001D04                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p
.text$mn:00001D04
.text$mn:00001D04 var_C           = dword ptr -0Ch
.text$mn:00001D04 var_8           = dword ptr -8
.text$mn:00001D04 var_2           = byte ptr -2
.text$mn:00001D04 var_1           = byte ptr -1
.text$mn:00001D04 arg_0           = byte ptr  8
.text$mn:00001D04 arg_4           = dword ptr  0Ch
.text$mn:00001D04
.text$mn:00001D04                 push    ebp
.text$mn:00001D05                 mov     ebp, esp
.text$mn:00001D07                 sub     esp, 0Ch
.text$mn:00001D0A                 mov     [ebp+var_8], ecx
.text$mn:00001D0D                 movzx   eax, [ebp+arg_0]
.text$mn:00001D11                 test    eax, eax
.text$mn:00001D13                 jnz     short loc_1D17
.text$mn:00001D15                 jmp     short loc_1D8A
.text$mn:00001D17 ; ---------------------------------------------------------------------------
.text$mn:00001D17
.text$mn:00001D17 loc_1D17:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00001D17                 mov     ecx, [ebp+var_8]
.text$mn:00001D1A                 cmp     dword ptr [ecx+18h], 8
.text$mn:00001D1E                 jb      short loc_1D8A
.text$mn:00001D20                 mov     edx, [ebp+var_8]
.text$mn:00001D23                 mov     eax, [edx+4]
.text$mn:00001D26                 mov     [ebp+var_C], eax
.text$mn:00001D29                 mov     ecx, [ebp+var_8]
.text$mn:00001D2C                 add     ecx, 4
.text$mn:00001D2F                 push    ecx
.text$mn:00001D30                 lea     edx, [ebp+var_1]
.text$mn:00001D33                 push    edx
.text$mn:00001D34                 mov     ecx, [ebp+var_8]
.text$mn:00001D37                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001D3C                 mov     ecx, eax
.text$mn:00001D3E                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001D43                 cmp     [ebp+arg_4], 0
.text$mn:00001D47                 jbe     short loc_1D69
.text$mn:00001D49                 mov     eax, [ebp+arg_4]
.text$mn:00001D4C                 push    eax             ; int
.text$mn:00001D4D                 mov     ecx, [ebp+var_C]
.text$mn:00001D50                 push    ecx
.text$mn:00001D51                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001D56                 add     esp, 4
.text$mn:00001D59                 push    eax             ; Src
.text$mn:00001D5A                 mov     edx, [ebp+var_8]
.text$mn:00001D5D                 add     edx, 4
.text$mn:00001D60                 push    edx             ; Dst
.text$mn:00001D61                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001D66                 add     esp, 0Ch
.text$mn:00001D69
.text$mn:00001D69 loc_1D69:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00001D69                 mov     eax, [ebp+var_8]
.text$mn:00001D6C                 mov     ecx, [eax+18h]
.text$mn:00001D6F                 add     ecx, 1
.text$mn:00001D72                 push    ecx             ; int
.text$mn:00001D73                 mov     edx, [ebp+var_C]
.text$mn:00001D76                 push    edx             ; void *
.text$mn:00001D77                 lea     eax, [ebp+var_2]
.text$mn:00001D7A                 push    eax
.text$mn:00001D7B                 mov     ecx, [ebp+var_8]
.text$mn:00001D7E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001D83                 mov     ecx, eax
.text$mn:00001D85                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00001D8A
.text$mn:00001D8A loc_1D8A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00001D8A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00001D8A                 mov     ecx, [ebp+var_8]
.text$mn:00001D8D                 mov     dword ptr [ecx+18h], 7
.text$mn:00001D94                 mov     edx, [ebp+arg_4]
.text$mn:00001D97                 push    edx
.text$mn:00001D98                 mov     ecx, [ebp+var_8]
.text$mn:00001D9B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001DA0                 mov     esp, ebp
.text$mn:00001DA2                 pop     ebp
.text$mn:00001DA3                 retn    8
.text$mn:00001DA3 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00001DA3
.text$mn:00001DA3 ; ---------------------------------------------------------------------------
.text$mn:00001DA6                 align 4
.text$mn:00001DA6 _text$mn        ends
.text$mn:00001DA6
.text$mn:00001DA8 ; ===========================================================================
.text$mn:00001DA8
.text$mn:00001DA8 ; Segment type: Pure code
.text$mn:00001DA8 ; Segment permissions: Read/Execute
.text$mn:00001DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DA8                 assume cs:_text$mn
.text$mn:00001DA8                 ;org 1DA8h
.text$mn:00001DA8 ; COMDAT (pick any)
.text$mn:00001DA8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001DA8
.text$mn:00001DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DA8
.text$mn:00001DA8 ; Attributes: bp-based frame
.text$mn:00001DA8
.text$mn:00001DA8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001DA8                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001DA8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001DA8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001DA8
.text$mn:00001DA8 var_4           = dword ptr -4
.text$mn:00001DA8
.text$mn:00001DA8                 push    ebp
.text$mn:00001DA9                 mov     ebp, esp
.text$mn:00001DAB                 push    ecx
.text$mn:00001DAC                 mov     [ebp+var_4], ecx
.text$mn:00001DAF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001DB4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001DB9                 mov     esp, ebp
.text$mn:00001DBB                 pop     ebp
.text$mn:00001DBC                 retn
.text$mn:00001DBC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001DBC
.text$mn:00001DBC ; ---------------------------------------------------------------------------
.text$mn:00001DBD                 align 10h
.text$mn:00001DBD _text$mn        ends
.text$mn:00001DBD
.text$mn:00001DC0 ; ===========================================================================
.text$mn:00001DC0
.text$mn:00001DC0 ; Segment type: Pure code
.text$mn:00001DC0 ; Segment permissions: Read/Execute
.text$mn:00001DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DC0                 assume cs:_text$mn
.text$mn:00001DC0                 ;org 1DC0h
.text$mn:00001DC0 ; COMDAT (pick any)
.text$mn:00001DC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001DC0
.text$mn:00001DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DC0
.text$mn:00001DC0 ; Attributes: bp-based frame
.text$mn:00001DC0
.text$mn:00001DC0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001DC0                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001DC0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001DC0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001DC0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001DC0
.text$mn:00001DC0 var_4           = dword ptr -4
.text$mn:00001DC0
.text$mn:00001DC0                 push    ebp
.text$mn:00001DC1                 mov     ebp, esp
.text$mn:00001DC3                 push    ecx
.text$mn:00001DC4                 mov     [ebp+var_4], ecx
.text$mn:00001DC7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001DCC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001DD1                 mov     esp, ebp
.text$mn:00001DD3                 pop     ebp
.text$mn:00001DD4                 retn
.text$mn:00001DD4 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001DD4
.text$mn:00001DD4 ; ---------------------------------------------------------------------------
.text$mn:00001DD5                 align 4
.text$mn:00001DD5 _text$mn        ends
.text$mn:00001DD5
.text$mn:00001DD8 ; ===========================================================================
.text$mn:00001DD8
.text$mn:00001DD8 ; Segment type: Pure code
.text$mn:00001DD8 ; Segment permissions: Read/Execute
.text$mn:00001DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DD8                 assume cs:_text$mn
.text$mn:00001DD8                 ;org 1DD8h
.text$mn:00001DD8 ; COMDAT (pick any)
.text$mn:00001DD8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001DD8
.text$mn:00001DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DD8
.text$mn:00001DD8 ; Attributes: bp-based frame
.text$mn:00001DD8
.text$mn:00001DD8 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001DD8                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001DD8 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001DD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001DD8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001DD8
.text$mn:00001DD8 var_4           = dword ptr -4
.text$mn:00001DD8 arg_0           = dword ptr  8
.text$mn:00001DD8
.text$mn:00001DD8                 push    ebp
.text$mn:00001DD9                 mov     ebp, esp
.text$mn:00001DDB                 push    ecx
.text$mn:00001DDC                 mov     [ebp+var_4], ecx
.text$mn:00001DDF                 mov     eax, [ebp+arg_0]
.text$mn:00001DE2                 push    eax
.text$mn:00001DE3                 mov     ecx, [ebp+var_4]
.text$mn:00001DE6                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001DEB                 mov     esp, ebp
.text$mn:00001DED                 pop     ebp
.text$mn:00001DEE                 retn    4
.text$mn:00001DEE ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001DEE
.text$mn:00001DEE ; ---------------------------------------------------------------------------
.text$mn:00001DF1                 align 4
.text$mn:00001DF1 _text$mn        ends
.text$mn:00001DF1
.text$mn:00001DF4 ; ===========================================================================
.text$mn:00001DF4
.text$mn:00001DF4 ; Segment type: Pure code
.text$mn:00001DF4 ; Segment permissions: Read/Execute
.text$mn:00001DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF4                 assume cs:_text$mn
.text$mn:00001DF4                 ;org 1DF4h
.text$mn:00001DF4 ; COMDAT (pick any)
.text$mn:00001DF4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001DF4
.text$mn:00001DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF4
.text$mn:00001DF4 ; Attributes: bp-based frame
.text$mn:00001DF4
.text$mn:00001DF4 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001DF4                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001DF4 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001DF4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001DF4
.text$mn:00001DF4 var_4           = dword ptr -4
.text$mn:00001DF4 arg_0           = dword ptr  8
.text$mn:00001DF4
.text$mn:00001DF4                 push    ebp
.text$mn:00001DF5                 mov     ebp, esp
.text$mn:00001DF7                 push    ecx
.text$mn:00001DF8                 mov     [ebp+var_4], ecx
.text$mn:00001DFB                 push    0
.text$mn:00001DFD                 mov     eax, [ebp+arg_0]
.text$mn:00001E00                 push    eax
.text$mn:00001E01                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001E06                 add     esp, 8
.text$mn:00001E09                 mov     esp, ebp
.text$mn:00001E0B                 pop     ebp
.text$mn:00001E0C                 retn    4
.text$mn:00001E0C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001E0C
.text$mn:00001E0C ; ---------------------------------------------------------------------------
.text$mn:00001E0F                 align 10h
.text$mn:00001E0F _text$mn        ends
.text$mn:00001E0F
.text$mn:00001E10 ; ===========================================================================
.text$mn:00001E10
.text$mn:00001E10 ; Segment type: Pure code
.text$mn:00001E10 ; Segment permissions: Read/Execute
.text$mn:00001E10 _text$mn        segment para public 'CODE' use32
.text$mn:00001E10                 assume cs:_text$mn
.text$mn:00001E10                 ;org 1E10h
.text$mn:00001E10 ; COMDAT (pick any)
.text$mn:00001E10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E10
.text$mn:00001E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E10
.text$mn:00001E10 ; Attributes: bp-based frame
.text$mn:00001E10
.text$mn:00001E10 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001E10                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001E10 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001E10                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001E10
.text$mn:00001E10 var_4           = dword ptr -4
.text$mn:00001E10 arg_0           = dword ptr  8
.text$mn:00001E10
.text$mn:00001E10                 push    ebp
.text$mn:00001E11                 mov     ebp, esp
.text$mn:00001E13                 push    ecx
.text$mn:00001E14                 mov     [ebp+var_4], ecx
.text$mn:00001E17                 push    0
.text$mn:00001E19                 mov     eax, [ebp+arg_0]
.text$mn:00001E1C                 push    eax
.text$mn:00001E1D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001E22                 add     esp, 8
.text$mn:00001E25                 mov     esp, ebp
.text$mn:00001E27                 pop     ebp
.text$mn:00001E28                 retn    4
.text$mn:00001E28 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001E28
.text$mn:00001E28 ; ---------------------------------------------------------------------------
.text$mn:00001E2B                 align 4
.text$mn:00001E2B _text$mn        ends
.text$mn:00001E2B
.text$mn:00001E2C ; ===========================================================================
.text$mn:00001E2C
.text$mn:00001E2C ; Segment type: Pure code
.text$mn:00001E2C ; Segment permissions: Read/Execute
.text$mn:00001E2C _text$mn        segment para public 'CODE' use32
.text$mn:00001E2C                 assume cs:_text$mn
.text$mn:00001E2C                 ;org 1E2Ch
.text$mn:00001E2C ; COMDAT (pick any)
.text$mn:00001E2C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E2C
.text$mn:00001E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E2C
.text$mn:00001E2C ; Attributes: bp-based frame
.text$mn:00001E2C
.text$mn:00001E2C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001E2C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001E2C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001E2C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001E2C
.text$mn:00001E2C Size            = dword ptr -8
.text$mn:00001E2C var_4           = dword ptr -4
.text$mn:00001E2C arg_0           = dword ptr  8
.text$mn:00001E2C arg_4           = dword ptr  0Ch
.text$mn:00001E2C arg_8           = dword ptr  10h
.text$mn:00001E2C
.text$mn:00001E2C                 push    ebp
.text$mn:00001E2D                 mov     ebp, esp
.text$mn:00001E2F                 sub     esp, 8
.text$mn:00001E32                 mov     [ebp+var_4], ecx
.text$mn:00001E35                 mov     ecx, [ebp+arg_0]
.text$mn:00001E38                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001E3D                 cmp     eax, [ebp+arg_4]
.text$mn:00001E40                 jnb     short loc_1E4A
.text$mn:00001E42                 mov     ecx, [ebp+var_4]
.text$mn:00001E45                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001E4A
.text$mn:00001E4A loc_1E4A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001E4A                 mov     ecx, [ebp+arg_0]
.text$mn:00001E4D                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001E52                 sub     eax, [ebp+arg_4]
.text$mn:00001E55                 mov     [ebp+Size], eax
.text$mn:00001E58                 mov     eax, [ebp+arg_8]
.text$mn:00001E5B                 cmp     eax, [ebp+Size]
.text$mn:00001E5E                 jnb     short loc_1E66
.text$mn:00001E60                 mov     ecx, [ebp+arg_8]
.text$mn:00001E63                 mov     [ebp+Size], ecx
.text$mn:00001E66
.text$mn:00001E66 loc_1E66:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001E66                 mov     edx, [ebp+var_4]
.text$mn:00001E69                 cmp     edx, [ebp+arg_0]
.text$mn:00001E6C                 jnz     short loc_1E8D
.text$mn:00001E6E                 mov     eax, [ebp+arg_4]
.text$mn:00001E71                 add     eax, [ebp+Size]
.text$mn:00001E74                 push    eax
.text$mn:00001E75                 mov     ecx, [ebp+var_4]
.text$mn:00001E78                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001E7D                 mov     ecx, [ebp+arg_4]
.text$mn:00001E80                 push    ecx
.text$mn:00001E81                 push    0
.text$mn:00001E83                 mov     ecx, [ebp+var_4]
.text$mn:00001E86                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001E8B                 jmp     short loc_1ECF
.text$mn:00001E8D ; ---------------------------------------------------------------------------
.text$mn:00001E8D
.text$mn:00001E8D loc_1E8D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001E8D                 push    0
.text$mn:00001E8F                 mov     edx, [ebp+Size]
.text$mn:00001E92                 push    edx
.text$mn:00001E93                 mov     ecx, [ebp+var_4]
.text$mn:00001E96                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001E9B                 movzx   eax, al
.text$mn:00001E9E                 test    eax, eax
.text$mn:00001EA0                 jz      short loc_1ECF
.text$mn:00001EA2                 mov     ecx, [ebp+Size]
.text$mn:00001EA5                 push    ecx             ; Size
.text$mn:00001EA6                 mov     ecx, [ebp+arg_0]
.text$mn:00001EA9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001EAE                 add     eax, [ebp+arg_4]
.text$mn:00001EB1                 push    eax             ; Src
.text$mn:00001EB2                 mov     ecx, [ebp+var_4]
.text$mn:00001EB5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001EBA                 push    eax             ; Dst
.text$mn:00001EBB                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001EC0                 add     esp, 0Ch
.text$mn:00001EC3                 mov     edx, [ebp+Size]
.text$mn:00001EC6                 push    edx
.text$mn:00001EC7                 mov     ecx, [ebp+var_4]
.text$mn:00001ECA                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001ECF
.text$mn:00001ECF loc_1ECF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001ECF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001ECF                 mov     eax, [ebp+var_4]
.text$mn:00001ED2                 mov     esp, ebp
.text$mn:00001ED4                 pop     ebp
.text$mn:00001ED5                 retn    0Ch
.text$mn:00001ED5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001ED5
.text$mn:00001ED5 _text$mn        ends
.text$mn:00001ED5
.text$mn:00001ED8 ; ===========================================================================
.text$mn:00001ED8
.text$mn:00001ED8 ; Segment type: Pure code
.text$mn:00001ED8 ; Segment permissions: Read/Execute
.text$mn:00001ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00001ED8                 assume cs:_text$mn
.text$mn:00001ED8                 ;org 1ED8h
.text$mn:00001ED8 ; COMDAT (pick any)
.text$mn:00001ED8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001ED8
.text$mn:00001ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001ED8
.text$mn:00001ED8 ; Attributes: bp-based frame
.text$mn:00001ED8
.text$mn:00001ED8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001ED8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001ED8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001ED8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001ED8
.text$mn:00001ED8 var_4           = dword ptr -4
.text$mn:00001ED8 Str             = dword ptr  8
.text$mn:00001ED8
.text$mn:00001ED8                 push    ebp
.text$mn:00001ED9                 mov     ebp, esp
.text$mn:00001EDB                 push    ecx
.text$mn:00001EDC                 mov     [ebp+var_4], ecx
.text$mn:00001EDF                 push    490h            ; unsigned int
.text$mn:00001EE4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001EE9                 mov     eax, [ebp+Str]
.text$mn:00001EEC                 push    eax             ; int
.text$mn:00001EED                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001EF2                 add     esp, 0Ch
.text$mn:00001EF5                 mov     ecx, [ebp+Str]
.text$mn:00001EF8                 push    ecx             ; Str
.text$mn:00001EF9                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001EFE                 add     esp, 4
.text$mn:00001F01                 push    eax             ; Size
.text$mn:00001F02                 mov     edx, [ebp+Str]
.text$mn:00001F05                 push    edx             ; Src
.text$mn:00001F06                 mov     ecx, [ebp+var_4]
.text$mn:00001F09                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001F0E                 mov     esp, ebp
.text$mn:00001F10                 pop     ebp
.text$mn:00001F11                 retn    4
.text$mn:00001F11 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001F11
.text$mn:00001F11 _text$mn        ends
.text$mn:00001F11
.text$mn:00001F14 ; ===========================================================================
.text$mn:00001F14
.text$mn:00001F14 ; Segment type: Pure code
.text$mn:00001F14 ; Segment permissions: Read/Execute
.text$mn:00001F14 _text$mn        segment para public 'CODE' use32
.text$mn:00001F14                 assume cs:_text$mn
.text$mn:00001F14                 ;org 1F14h
.text$mn:00001F14 ; COMDAT (pick any)
.text$mn:00001F14                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F14
.text$mn:00001F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F14
.text$mn:00001F14 ; Attributes: bp-based frame
.text$mn:00001F14
.text$mn:00001F14 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001F14                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001F14 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001F14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001F14
.text$mn:00001F14 var_4           = dword ptr -4
.text$mn:00001F14 Src             = dword ptr  8
.text$mn:00001F14 Size            = dword ptr  0Ch
.text$mn:00001F14
.text$mn:00001F14                 push    ebp
.text$mn:00001F15                 mov     ebp, esp
.text$mn:00001F17                 push    ecx
.text$mn:00001F18                 mov     [ebp+var_4], ecx
.text$mn:00001F1B                 cmp     [ebp+Size], 0
.text$mn:00001F1F                 jz      short loc_1F37
.text$mn:00001F21                 push    47Fh            ; unsigned int
.text$mn:00001F26                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001F2B                 mov     eax, [ebp+Src]
.text$mn:00001F2E                 push    eax             ; int
.text$mn:00001F2F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001F34                 add     esp, 0Ch
.text$mn:00001F37
.text$mn:00001F37 loc_1F37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001F37                 mov     ecx, [ebp+Src]
.text$mn:00001F3A                 push    ecx
.text$mn:00001F3B                 mov     ecx, [ebp+var_4]
.text$mn:00001F3E                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001F43                 movzx   edx, al
.text$mn:00001F46                 test    edx, edx
.text$mn:00001F48                 jz      short loc_1F6A
.text$mn:00001F4A                 mov     eax, [ebp+Size]
.text$mn:00001F4D                 push    eax
.text$mn:00001F4E                 mov     ecx, [ebp+var_4]
.text$mn:00001F51                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001F56                 mov     ecx, [ebp+Src]
.text$mn:00001F59                 sub     ecx, eax
.text$mn:00001F5B                 push    ecx
.text$mn:00001F5C                 mov     edx, [ebp+var_4]
.text$mn:00001F5F                 push    edx
.text$mn:00001F60                 mov     ecx, [ebp+var_4]
.text$mn:00001F63                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001F68                 jmp     short loc_1FA7
.text$mn:00001F6A ; ---------------------------------------------------------------------------
.text$mn:00001F6A
.text$mn:00001F6A loc_1F6A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001F6A                 push    0
.text$mn:00001F6C                 mov     eax, [ebp+Size]
.text$mn:00001F6F                 push    eax
.text$mn:00001F70                 mov     ecx, [ebp+var_4]
.text$mn:00001F73                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001F78                 movzx   ecx, al
.text$mn:00001F7B                 test    ecx, ecx
.text$mn:00001F7D                 jz      short loc_1FA4
.text$mn:00001F7F                 mov     edx, [ebp+Size]
.text$mn:00001F82                 push    edx             ; Size
.text$mn:00001F83                 mov     eax, [ebp+Src]
.text$mn:00001F86                 push    eax             ; Src
.text$mn:00001F87                 mov     ecx, [ebp+var_4]
.text$mn:00001F8A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001F8F                 push    eax             ; Dst
.text$mn:00001F90                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001F95                 add     esp, 0Ch
.text$mn:00001F98                 mov     ecx, [ebp+Size]
.text$mn:00001F9B                 push    ecx
.text$mn:00001F9C                 mov     ecx, [ebp+var_4]
.text$mn:00001F9F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001FA4
.text$mn:00001FA4 loc_1FA4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001FA4                 mov     eax, [ebp+var_4]
.text$mn:00001FA7
.text$mn:00001FA7 loc_1FA7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00001FA7                 mov     esp, ebp
.text$mn:00001FA9                 pop     ebp
.text$mn:00001FAA                 retn    8
.text$mn:00001FAA ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001FAA
.text$mn:00001FAA ; ---------------------------------------------------------------------------
.text$mn:00001FAD                 align 10h
.text$mn:00001FAD _text$mn        ends
.text$mn:00001FAD
.text$mn:00001FB0 ; ===========================================================================
.text$mn:00001FB0
.text$mn:00001FB0 ; Segment type: Pure code
.text$mn:00001FB0 ; Segment permissions: Read/Execute
.text$mn:00001FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB0                 assume cs:_text$mn
.text$mn:00001FB0                 ;org 1FB0h
.text$mn:00001FB0 ; COMDAT (pick any)
.text$mn:00001FB0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FB0
.text$mn:00001FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB0
.text$mn:00001FB0 ; Attributes: bp-based frame
.text$mn:00001FB0
.text$mn:00001FB0 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001FB0                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001FB0 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001FB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001FB0
.text$mn:00001FB0 arg_0           = dword ptr  8
.text$mn:00001FB0 arg_4           = dword ptr  0Ch
.text$mn:00001FB0
.text$mn:00001FB0                 push    ebp
.text$mn:00001FB1                 mov     ebp, esp
.text$mn:00001FB3                 mov     eax, [ebp+arg_0]
.text$mn:00001FB6                 mov     ecx, [ebp+arg_4]
.text$mn:00001FB9                 mov     dl, [ecx]
.text$mn:00001FBB                 mov     [eax], dl
.text$mn:00001FBD                 pop     ebp
.text$mn:00001FBE                 retn
.text$mn:00001FBE ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001FBE
.text$mn:00001FBE ; ---------------------------------------------------------------------------
.text$mn:00001FBF                 align 10h
.text$mn:00001FBF _text$mn        ends
.text$mn:00001FBF
.text$mn:00001FC0 ; ===========================================================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Segment type: Pure code
.text$mn:00001FC0 ; Segment permissions: Read/Execute
.text$mn:00001FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FC0                 assume cs:_text$mn
.text$mn:00001FC0                 ;org 1FC0h
.text$mn:00001FC0 ; COMDAT (pick any)
.text$mn:00001FC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FC0
.text$mn:00001FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Attributes: bp-based frame
.text$mn:00001FC0
.text$mn:00001FC0 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00001FC0                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00001FC0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00001FC0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00001FC0
.text$mn:00001FC0 arg_0           = dword ptr  8
.text$mn:00001FC0 arg_4           = dword ptr  0Ch
.text$mn:00001FC0
.text$mn:00001FC0                 push    ebp
.text$mn:00001FC1                 mov     ebp, esp
.text$mn:00001FC3                 mov     eax, [ebp+arg_0]
.text$mn:00001FC6                 mov     ecx, [ebp+arg_4]
.text$mn:00001FC9                 mov     dx, [ecx]
.text$mn:00001FCC                 mov     [eax], dx
.text$mn:00001FCF                 pop     ebp
.text$mn:00001FD0                 retn
.text$mn:00001FD0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00001FD0
.text$mn:00001FD0 ; ---------------------------------------------------------------------------
.text$mn:00001FD1                 align 4
.text$mn:00001FD1 _text$mn        ends
.text$mn:00001FD1
.text$mn:00001FD4 ; ===========================================================================
.text$mn:00001FD4
.text$mn:00001FD4 ; Segment type: Pure code
.text$mn:00001FD4 ; Segment permissions: Read/Execute
.text$mn:00001FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FD4                 assume cs:_text$mn
.text$mn:00001FD4                 ;org 1FD4h
.text$mn:00001FD4 ; COMDAT (pick any)
.text$mn:00001FD4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FD4
.text$mn:00001FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FD4
.text$mn:00001FD4 ; Attributes: bp-based frame
.text$mn:00001FD4
.text$mn:00001FD4 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00001FD4                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00001FD4 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00001FD4                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+301p
.text$mn:00001FD4
.text$mn:00001FD4 var_4           = dword ptr -4
.text$mn:00001FD4
.text$mn:00001FD4                 push    ebp
.text$mn:00001FD5                 mov     ebp, esp
.text$mn:00001FD7                 push    ecx
.text$mn:00001FD8                 mov     [ebp+var_4], ecx
.text$mn:00001FDB                 mov     ecx, [ebp+var_4]
.text$mn:00001FDE                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001FE3                 mov     esp, ebp
.text$mn:00001FE5                 pop     ebp
.text$mn:00001FE6                 retn
.text$mn:00001FE6 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00001FE6
.text$mn:00001FE6 ; ---------------------------------------------------------------------------
.text$mn:00001FE7                 align 4
.text$mn:00001FE7 _text$mn        ends
.text$mn:00001FE7
.text$mn:00001FE8 ; ===========================================================================
.text$mn:00001FE8
.text$mn:00001FE8 ; Segment type: Pure code
.text$mn:00001FE8 ; Segment permissions: Read/Execute
.text$mn:00001FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FE8                 assume cs:_text$mn
.text$mn:00001FE8                 ;org 1FE8h
.text$mn:00001FE8 ; COMDAT (pick any)
.text$mn:00001FE8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FE8
.text$mn:00001FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FE8
.text$mn:00001FE8 ; Attributes: bp-based frame
.text$mn:00001FE8
.text$mn:00001FE8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001FE8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001FE8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001FE8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001FE8
.text$mn:00001FE8 var_4           = dword ptr -4
.text$mn:00001FE8
.text$mn:00001FE8                 push    ebp
.text$mn:00001FE9                 mov     ebp, esp
.text$mn:00001FEB                 push    ecx
.text$mn:00001FEC                 mov     [ebp+var_4], ecx
.text$mn:00001FEF                 mov     eax, [ebp+var_4]
.text$mn:00001FF2                 mov     eax, [eax+4]
.text$mn:00001FF5                 mov     esp, ebp
.text$mn:00001FF7                 pop     ebp
.text$mn:00001FF8                 retn
.text$mn:00001FF8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001FF8
.text$mn:00001FF8 ; ---------------------------------------------------------------------------
.text$mn:00001FF9                 align 4
.text$mn:00001FF9 _text$mn        ends
.text$mn:00001FF9
.text$mn:00001FFC ; ===========================================================================
.text$mn:00001FFC
.text$mn:00001FFC ; Segment type: Pure code
.text$mn:00001FFC ; Segment permissions: Read/Execute
.text$mn:00001FFC _text$mn        segment para public 'CODE' use32
.text$mn:00001FFC                 assume cs:_text$mn
.text$mn:00001FFC                 ;org 1FFCh
.text$mn:00001FFC ; COMDAT (pick any)
.text$mn:00001FFC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FFC
.text$mn:00001FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FFC
.text$mn:00001FFC ; Attributes: bp-based frame
.text$mn:00001FFC
.text$mn:00001FFC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001FFC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001FFC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001FFC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001FFC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001FFC
.text$mn:00001FFC var_4           = dword ptr -4
.text$mn:00001FFC
.text$mn:00001FFC                 push    ebp
.text$mn:00001FFD                 mov     ebp, esp
.text$mn:00001FFF                 push    ecx
.text$mn:00002000                 mov     [ebp+var_4], ecx
.text$mn:00002003                 mov     eax, [ebp+var_4]
.text$mn:00002006                 mov     eax, [eax+4]
.text$mn:00002009                 mov     esp, ebp
.text$mn:0000200B                 pop     ebp
.text$mn:0000200C                 retn
.text$mn:0000200C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000200C
.text$mn:0000200C ; ---------------------------------------------------------------------------
.text$mn:0000200D                 align 10h
.text$mn:0000200D _text$mn        ends
.text$mn:0000200D
.text$mn:00002010 ; ===========================================================================
.text$mn:00002010
.text$mn:00002010 ; Segment type: Pure code
.text$mn:00002010 ; Segment permissions: Read/Execute
.text$mn:00002010 _text$mn        segment para public 'CODE' use32
.text$mn:00002010                 assume cs:_text$mn
.text$mn:00002010                 ;org 2010h
.text$mn:00002010 ; COMDAT (pick any)
.text$mn:00002010                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002010
.text$mn:00002010 ; =============== S U B R O U T I N E =======================================
.text$mn:00002010
.text$mn:00002010 ; Attributes: bp-based frame
.text$mn:00002010
.text$mn:00002010 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002010                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002010 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002010                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002010
.text$mn:00002010 var_4           = dword ptr -4
.text$mn:00002010 Dst             = dword ptr  8
.text$mn:00002010 Src             = dword ptr  0Ch
.text$mn:00002010 Size            = dword ptr  10h
.text$mn:00002010
.text$mn:00002010                 push    ebp
.text$mn:00002011                 mov     ebp, esp
.text$mn:00002013                 push    ecx
.text$mn:00002014                 cmp     [ebp+Size], 0
.text$mn:00002018                 jnz     short loc_2022
.text$mn:0000201A                 mov     eax, [ebp+Dst]
.text$mn:0000201D                 mov     [ebp+var_4], eax
.text$mn:00002020                 jmp     short loc_2039
.text$mn:00002022 ; ---------------------------------------------------------------------------
.text$mn:00002022
.text$mn:00002022 loc_2022:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002022                 mov     ecx, [ebp+Size]
.text$mn:00002025                 push    ecx             ; Size
.text$mn:00002026                 mov     edx, [ebp+Src]
.text$mn:00002029                 push    edx             ; Src
.text$mn:0000202A                 mov     eax, [ebp+Dst]
.text$mn:0000202D                 push    eax             ; Dst
.text$mn:0000202E                 call    _memcpy
.text$mn:00002033                 add     esp, 0Ch
.text$mn:00002036                 mov     [ebp+var_4], eax
.text$mn:00002039
.text$mn:00002039 loc_2039:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00002039                 mov     eax, [ebp+var_4]
.text$mn:0000203C                 mov     esp, ebp
.text$mn:0000203E                 pop     ebp
.text$mn:0000203F                 retn
.text$mn:0000203F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000203F
.text$mn:0000203F _text$mn        ends
.text$mn:0000203F
.text$mn:00002040 ; ===========================================================================
.text$mn:00002040
.text$mn:00002040 ; Segment type: Pure code
.text$mn:00002040 ; Segment permissions: Read/Execute
.text$mn:00002040 _text$mn        segment para public 'CODE' use32
.text$mn:00002040                 assume cs:_text$mn
.text$mn:00002040                 ;org 2040h
.text$mn:00002040 ; COMDAT (pick any)
.text$mn:00002040                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002040
.text$mn:00002040 ; =============== S U B R O U T I N E =======================================
.text$mn:00002040
.text$mn:00002040 ; Attributes: bp-based frame
.text$mn:00002040
.text$mn:00002040 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00002040                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00002040 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00002040                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp
.text$mn:00002040
.text$mn:00002040 var_4           = dword ptr -4
.text$mn:00002040 Dst             = dword ptr  8
.text$mn:00002040 Src             = dword ptr  0Ch
.text$mn:00002040 arg_8           = dword ptr  10h
.text$mn:00002040
.text$mn:00002040                 push    ebp
.text$mn:00002041                 mov     ebp, esp
.text$mn:00002043                 push    ecx
.text$mn:00002044                 cmp     [ebp+arg_8], 0
.text$mn:00002048                 jnz     short loc_2052
.text$mn:0000204A                 mov     eax, [ebp+Dst]
.text$mn:0000204D                 mov     [ebp+var_4], eax
.text$mn:00002050                 jmp     short loc_2069
.text$mn:00002052 ; ---------------------------------------------------------------------------
.text$mn:00002052
.text$mn:00002052 loc_2052:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00002052                 mov     ecx, [ebp+arg_8]
.text$mn:00002055                 push    ecx             ; int
.text$mn:00002056                 mov     edx, [ebp+Src]
.text$mn:00002059                 push    edx             ; Src
.text$mn:0000205A                 mov     eax, [ebp+Dst]
.text$mn:0000205D                 push    eax             ; Dst
.text$mn:0000205E                 call    _wmemcpy
.text$mn:00002063                 add     esp, 0Ch
.text$mn:00002066                 mov     [ebp+var_4], eax
.text$mn:00002069
.text$mn:00002069 loc_2069:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00002069                 mov     eax, [ebp+var_4]
.text$mn:0000206C                 mov     esp, ebp
.text$mn:0000206E                 pop     ebp
.text$mn:0000206F                 retn
.text$mn:0000206F ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000206F
.text$mn:0000206F _text$mn        ends
.text$mn:0000206F
.text$mn:00002070 ; ===========================================================================
.text$mn:00002070
.text$mn:00002070 ; Segment type: Pure code
.text$mn:00002070 ; Segment permissions: Read/Execute
.text$mn:00002070 _text$mn        segment para public 'CODE' use32
.text$mn:00002070                 assume cs:_text$mn
.text$mn:00002070                 ;org 2070h
.text$mn:00002070 ; COMDAT (pick any)
.text$mn:00002070                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002070
.text$mn:00002070 ; =============== S U B R O U T I N E =======================================
.text$mn:00002070
.text$mn:00002070 ; Attributes: bp-based frame
.text$mn:00002070
.text$mn:00002070 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002070                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002070 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002070                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002070
.text$mn:00002070 var_4           = dword ptr -4
.text$mn:00002070 arg_0           = dword ptr  8
.text$mn:00002070 arg_4           = dword ptr  0Ch
.text$mn:00002070
.text$mn:00002070                 push    ebp
.text$mn:00002071                 mov     ebp, esp
.text$mn:00002073                 push    ecx
.text$mn:00002074                 mov     [ebp+var_4], ecx
.text$mn:00002077                 mov     eax, [ebp+arg_4]
.text$mn:0000207A                 push    eax             ; int
.text$mn:0000207B                 mov     ecx, [ebp+arg_0]
.text$mn:0000207E                 push    ecx             ; void *
.text$mn:0000207F                 mov     ecx, [ebp+var_4]
.text$mn:00002082                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002087                 mov     esp, ebp
.text$mn:00002089                 pop     ebp
.text$mn:0000208A                 retn    8
.text$mn:0000208A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000208A
.text$mn:0000208A ; ---------------------------------------------------------------------------
.text$mn:0000208D                 align 10h
.text$mn:0000208D _text$mn        ends
.text$mn:0000208D
.text$mn:00002090 ; ===========================================================================
.text$mn:00002090
.text$mn:00002090 ; Segment type: Pure code
.text$mn:00002090 ; Segment permissions: Read/Execute
.text$mn:00002090 _text$mn        segment para public 'CODE' use32
.text$mn:00002090                 assume cs:_text$mn
.text$mn:00002090                 ;org 2090h
.text$mn:00002090 ; COMDAT (pick any)
.text$mn:00002090                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002090
.text$mn:00002090 ; =============== S U B R O U T I N E =======================================
.text$mn:00002090
.text$mn:00002090 ; Attributes: bp-based frame
.text$mn:00002090
.text$mn:00002090 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00002090                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00002090 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00002090                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00002090
.text$mn:00002090 var_4           = dword ptr -4
.text$mn:00002090 arg_0           = dword ptr  8
.text$mn:00002090 arg_4           = dword ptr  0Ch
.text$mn:00002090
.text$mn:00002090                 push    ebp
.text$mn:00002091                 mov     ebp, esp
.text$mn:00002093                 push    ecx
.text$mn:00002094                 mov     [ebp+var_4], ecx
.text$mn:00002097                 mov     eax, [ebp+arg_4]
.text$mn:0000209A                 push    eax             ; int
.text$mn:0000209B                 mov     ecx, [ebp+arg_0]
.text$mn:0000209E                 push    ecx             ; void *
.text$mn:0000209F                 mov     ecx, [ebp+var_4]
.text$mn:000020A2                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:000020A7                 mov     esp, ebp
.text$mn:000020A9                 pop     ebp
.text$mn:000020AA                 retn    8
.text$mn:000020AA ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:000020AA
.text$mn:000020AA ; ---------------------------------------------------------------------------
.text$mn:000020AD                 align 10h
.text$mn:000020AD _text$mn        ends
.text$mn:000020AD
.text$mn:000020B0 ; ===========================================================================
.text$mn:000020B0
.text$mn:000020B0 ; Segment type: Pure code
.text$mn:000020B0 ; Segment permissions: Read/Execute
.text$mn:000020B0 _text$mn        segment para public 'CODE' use32
.text$mn:000020B0                 assume cs:_text$mn
.text$mn:000020B0                 ;org 20B0h
.text$mn:000020B0 ; COMDAT (pick any)
.text$mn:000020B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000020B0
.text$mn:000020B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020B0
.text$mn:000020B0 ; Attributes: bp-based frame
.text$mn:000020B0
.text$mn:000020B0 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000020B0                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000020B0 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000020B0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000020B0
.text$mn:000020B0 var_4           = dword ptr -4
.text$mn:000020B0 arg_0           = dword ptr  8
.text$mn:000020B0
.text$mn:000020B0                 push    ebp
.text$mn:000020B1                 mov     ebp, esp
.text$mn:000020B3                 push    ecx
.text$mn:000020B4                 mov     [ebp+var_4], ecx
.text$mn:000020B7                 mov     eax, [ebp+arg_0]
.text$mn:000020BA                 push    eax             ; void *
.text$mn:000020BB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020C0                 add     esp, 4
.text$mn:000020C3                 mov     esp, ebp
.text$mn:000020C5                 pop     ebp
.text$mn:000020C6                 retn    8
.text$mn:000020C6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000020C6
.text$mn:000020C6 ; ---------------------------------------------------------------------------
.text$mn:000020C9                 align 4
.text$mn:000020C9 _text$mn        ends
.text$mn:000020C9
.text$mn:000020CC ; ===========================================================================
.text$mn:000020CC
.text$mn:000020CC ; Segment type: Pure code
.text$mn:000020CC ; Segment permissions: Read/Execute
.text$mn:000020CC _text$mn        segment para public 'CODE' use32
.text$mn:000020CC                 assume cs:_text$mn
.text$mn:000020CC                 ;org 20CCh
.text$mn:000020CC ; COMDAT (pick any)
.text$mn:000020CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000020CC
.text$mn:000020CC ; =============== S U B R O U T I N E =======================================
.text$mn:000020CC
.text$mn:000020CC ; Attributes: bp-based frame
.text$mn:000020CC
.text$mn:000020CC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000020CC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000020CC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000020CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000020CC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:000020CC
.text$mn:000020CC var_4           = dword ptr -4
.text$mn:000020CC arg_0           = dword ptr  8
.text$mn:000020CC
.text$mn:000020CC                 push    ebp
.text$mn:000020CD                 mov     ebp, esp
.text$mn:000020CF                 push    ecx
.text$mn:000020D0                 mov     [ebp+var_4], ecx
.text$mn:000020D3                 mov     eax, [ebp+arg_0]
.text$mn:000020D6                 push    eax             ; void *
.text$mn:000020D7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020DC                 add     esp, 4
.text$mn:000020DF                 mov     esp, ebp
.text$mn:000020E1                 pop     ebp
.text$mn:000020E2                 retn    8
.text$mn:000020E2 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000020E2
.text$mn:000020E2 ; ---------------------------------------------------------------------------
.text$mn:000020E5                 align 4
.text$mn:000020E5 _text$mn        ends
.text$mn:000020E5
.text$mn:000020E8 ; ===========================================================================
.text$mn:000020E8
.text$mn:000020E8 ; Segment type: Pure code
.text$mn:000020E8 ; Segment permissions: Read/Execute
.text$mn:000020E8 _text$mn        segment para public 'CODE' use32
.text$mn:000020E8                 assume cs:_text$mn
.text$mn:000020E8                 ;org 20E8h
.text$mn:000020E8 ; COMDAT (pick any)
.text$mn:000020E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000020E8
.text$mn:000020E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000020E8
.text$mn:000020E8 ; Attributes: bp-based frame
.text$mn:000020E8
.text$mn:000020E8 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:000020E8                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:000020E8 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:000020E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:000020E8
.text$mn:000020E8 var_4           = dword ptr -4
.text$mn:000020E8 arg_0           = dword ptr  8
.text$mn:000020E8
.text$mn:000020E8                 push    ebp
.text$mn:000020E9                 mov     ebp, esp
.text$mn:000020EB                 push    ecx
.text$mn:000020EC                 mov     [ebp+var_4], ecx
.text$mn:000020EF                 mov     eax, [ebp+arg_0]
.text$mn:000020F2                 push    eax             ; void *
.text$mn:000020F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000020F8                 add     esp, 4
.text$mn:000020FB                 mov     esp, ebp
.text$mn:000020FD                 pop     ebp
.text$mn:000020FE                 retn    8
.text$mn:000020FE ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:000020FE
.text$mn:000020FE ; ---------------------------------------------------------------------------
.text$mn:00002101                 align 4
.text$mn:00002101 _text$mn        ends
.text$mn:00002101
.text$mn:00002104 ; ===========================================================================
.text$mn:00002104
.text$mn:00002104 ; Segment type: Pure code
.text$mn:00002104 ; Segment permissions: Read/Execute
.text$mn:00002104 _text$mn        segment para public 'CODE' use32
.text$mn:00002104                 assume cs:_text$mn
.text$mn:00002104                 ;org 2104h
.text$mn:00002104 ; COMDAT (pick any)
.text$mn:00002104                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002104
.text$mn:00002104 ; =============== S U B R O U T I N E =======================================
.text$mn:00002104
.text$mn:00002104 ; Attributes: bp-based frame
.text$mn:00002104
.text$mn:00002104 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002104                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002104 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002104                                         ; DATA XREF: .rdata:00002CF8o
.text$mn:00002104
.text$mn:00002104 var_4           = dword ptr -4
.text$mn:00002104 arg_0           = dword ptr  8
.text$mn:00002104 arg_4           = dword ptr  0Ch
.text$mn:00002104
.text$mn:00002104                 push    ebp
.text$mn:00002105                 mov     ebp, esp
.text$mn:00002107                 push    ecx
.text$mn:00002108                 mov     [ebp+var_4], ecx
.text$mn:0000210B                 mov     eax, [ebp+arg_4]
.text$mn:0000210E                 push    eax             ; int
.text$mn:0000210F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002114                 add     esp, 4
.text$mn:00002117                 test    eax, eax
.text$mn:00002119                 jz      short loc_2134
.text$mn:0000211B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002120                 push    eax             ; struct std::error_category *
.text$mn:00002121                 mov     ecx, [ebp+arg_4]
.text$mn:00002124                 push    ecx             ; int
.text$mn:00002125                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002128                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000212D                 mov     eax, [ebp+arg_0]
.text$mn:00002130                 jmp     short loc_2149
.text$mn:00002132 ; ---------------------------------------------------------------------------
.text$mn:00002132                 jmp     short loc_2149
.text$mn:00002134 ; ---------------------------------------------------------------------------
.text$mn:00002134
.text$mn:00002134 loc_2134:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002134                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00002139                 push    eax             ; struct std::error_category *
.text$mn:0000213A                 mov     edx, [ebp+arg_4]
.text$mn:0000213D                 push    edx             ; int
.text$mn:0000213E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002141                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002146                 mov     eax, [ebp+arg_0]
.text$mn:00002149
.text$mn:00002149 loc_2149:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002149                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002149                 mov     esp, ebp
.text$mn:0000214B                 pop     ebp
.text$mn:0000214C                 retn    8
.text$mn:0000214C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000214C
.text$mn:0000214C ; ---------------------------------------------------------------------------
.text$mn:0000214F                 align 10h
.text$mn:0000214F _text$mn        ends
.text$mn:0000214F
.text$mn:00002150 ; ===========================================================================
.text$mn:00002150
.text$mn:00002150 ; Segment type: Pure code
.text$mn:00002150 ; Segment permissions: Read/Execute
.text$mn:00002150 _text$mn        segment para public 'CODE' use32
.text$mn:00002150                 assume cs:_text$mn
.text$mn:00002150                 ;org 2150h
.text$mn:00002150 ; COMDAT (pick any)
.text$mn:00002150                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002150
.text$mn:00002150 ; =============== S U B R O U T I N E =======================================
.text$mn:00002150
.text$mn:00002150 ; Attributes: bp-based frame
.text$mn:00002150
.text$mn:00002150 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002150                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002150 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002150                                         ; DATA XREF: .rdata:00002C68o
.text$mn:00002150                                         ; .rdata:00002C84o ...
.text$mn:00002150
.text$mn:00002150 var_4           = dword ptr -4
.text$mn:00002150 arg_0           = dword ptr  8
.text$mn:00002150 arg_4           = dword ptr  0Ch
.text$mn:00002150
.text$mn:00002150                 push    ebp
.text$mn:00002151                 mov     ebp, esp
.text$mn:00002153                 push    ecx
.text$mn:00002154                 mov     [ebp+var_4], ecx
.text$mn:00002157                 mov     eax, [ebp+var_4]
.text$mn:0000215A                 push    eax             ; struct std::error_category *
.text$mn:0000215B                 mov     ecx, [ebp+arg_4]
.text$mn:0000215E                 push    ecx             ; int
.text$mn:0000215F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002162                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002167                 mov     eax, [ebp+arg_0]
.text$mn:0000216A                 mov     esp, ebp
.text$mn:0000216C                 pop     ebp
.text$mn:0000216D                 retn    8
.text$mn:0000216D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000216D
.text$mn:0000216D _text$mn        ends
.text$mn:0000216D
.text$mn:00002170 ; ===========================================================================
.text$mn:00002170
.text$mn:00002170 ; Segment type: Pure code
.text$mn:00002170 ; Segment permissions: Read/Execute
.text$mn:00002170 _text$mn        segment para public 'CODE' use32
.text$mn:00002170                 assume cs:_text$mn
.text$mn:00002170                 ;org 2170h
.text$mn:00002170 ; COMDAT (pick any)
.text$mn:00002170                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002170
.text$mn:00002170 ; =============== S U B R O U T I N E =======================================
.text$mn:00002170
.text$mn:00002170 ; Attributes: bp-based frame
.text$mn:00002170
.text$mn:00002170 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002170                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002170 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002170                                         ; DATA XREF: .rdata:00002C6Co
.text$mn:00002170                                         ; .rdata:00002C88o ...
.text$mn:00002170
.text$mn:00002170 var_8           = dword ptr -8
.text$mn:00002170 var_4           = dword ptr -4
.text$mn:00002170 arg_0           = dword ptr  8
.text$mn:00002170 arg_4           = dword ptr  0Ch
.text$mn:00002170
.text$mn:00002170                 push    ebp
.text$mn:00002171                 mov     ebp, esp
.text$mn:00002173                 sub     esp, 8
.text$mn:00002176                 mov     [ebp+var_8], ecx
.text$mn:00002179                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000217C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002181                 push    eax
.text$mn:00002182                 mov     ecx, [ebp+var_8]
.text$mn:00002185                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000218A                 movzx   eax, al
.text$mn:0000218D                 test    eax, eax
.text$mn:0000218F                 jz      short loc_21A7
.text$mn:00002191                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002194                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00002199                 cmp     eax, [ebp+arg_4]
.text$mn:0000219C                 jnz     short loc_21A7
.text$mn:0000219E                 mov     [ebp+var_4], 1
.text$mn:000021A5                 jmp     short loc_21AE
.text$mn:000021A7 ; ---------------------------------------------------------------------------
.text$mn:000021A7
.text$mn:000021A7 loc_21A7:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000021A7                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000021A7                 mov     [ebp+var_4], 0
.text$mn:000021AE
.text$mn:000021AE loc_21AE:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000021AE                 mov     al, byte ptr [ebp+var_4]
.text$mn:000021B1                 mov     esp, ebp
.text$mn:000021B3                 pop     ebp
.text$mn:000021B4                 retn    8
.text$mn:000021B4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000021B4
.text$mn:000021B4 ; ---------------------------------------------------------------------------
.text$mn:000021B7                 align 4
.text$mn:000021B7 _text$mn        ends
.text$mn:000021B7
.text$mn:000021B8 ; ===========================================================================
.text$mn:000021B8
.text$mn:000021B8 ; Segment type: Pure code
.text$mn:000021B8 ; Segment permissions: Read/Execute
.text$mn:000021B8 _text$mn        segment para public 'CODE' use32
.text$mn:000021B8                 assume cs:_text$mn
.text$mn:000021B8                 ;org 21B8h
.text$mn:000021B8 ; COMDAT (pick any)
.text$mn:000021B8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000021B8
.text$mn:000021B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021B8
.text$mn:000021B8 ; Attributes: bp-based frame
.text$mn:000021B8
.text$mn:000021B8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000021B8                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000021B8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000021B8                                         ; DATA XREF: .rdata:00002C70o
.text$mn:000021B8                                         ; .rdata:00002C8Co ...
.text$mn:000021B8
.text$mn:000021B8 var_C           = byte ptr -0Ch
.text$mn:000021B8 var_4           = dword ptr -4
.text$mn:000021B8 arg_0           = dword ptr  8
.text$mn:000021B8 arg_4           = dword ptr  0Ch
.text$mn:000021B8
.text$mn:000021B8                 push    ebp
.text$mn:000021B9                 mov     ebp, esp
.text$mn:000021BB                 sub     esp, 0Ch
.text$mn:000021BE                 mov     [ebp+var_4], ecx
.text$mn:000021C1                 mov     eax, [ebp+arg_4]
.text$mn:000021C4                 push    eax             ; std::error_condition *
.text$mn:000021C5                 mov     ecx, [ebp+arg_0]
.text$mn:000021C8                 push    ecx
.text$mn:000021C9                 lea     edx, [ebp+var_C]
.text$mn:000021CC                 push    edx
.text$mn:000021CD                 mov     eax, [ebp+var_4]
.text$mn:000021D0                 mov     edx, [eax]
.text$mn:000021D2                 mov     ecx, [ebp+var_4]
.text$mn:000021D5                 mov     eax, [edx+0Ch]
.text$mn:000021D8                 call    eax
.text$mn:000021DA                 mov     ecx, eax
.text$mn:000021DC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000021E1                 mov     esp, ebp
.text$mn:000021E3                 pop     ebp
.text$mn:000021E4                 retn    8
.text$mn:000021E4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000021E4
.text$mn:000021E4 ; ---------------------------------------------------------------------------
.text$mn:000021E7                 align 4
.text$mn:000021E7 _text$mn        ends
.text$mn:000021E7
.text$mn:000021E8 ; ===========================================================================
.text$mn:000021E8
.text$mn:000021E8 ; Segment type: Pure code
.text$mn:000021E8 ; Segment permissions: Read/Execute
.text$mn:000021E8 _text$mn        segment para public 'CODE' use32
.text$mn:000021E8                 assume cs:_text$mn
.text$mn:000021E8                 ;org 21E8h
.text$mn:000021E8 ; COMDAT (pick any)
.text$mn:000021E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000021E8
.text$mn:000021E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021E8
.text$mn:000021E8 ; Attributes: bp-based frame
.text$mn:000021E8
.text$mn:000021E8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000021E8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000021E8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000021E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000021E8
.text$mn:000021E8 var_4           = dword ptr -4
.text$mn:000021E8 arg_0           = dword ptr  8
.text$mn:000021E8
.text$mn:000021E8                 push    ebp
.text$mn:000021E9                 mov     ebp, esp
.text$mn:000021EB                 push    ecx
.text$mn:000021EC                 mov     [ebp+var_4], ecx
.text$mn:000021EF                 mov     eax, [ebp+var_4]
.text$mn:000021F2                 mov     ecx, [eax+14h]
.text$mn:000021F5                 cmp     ecx, [ebp+arg_0]
.text$mn:000021F8                 jnb     short loc_2202
.text$mn:000021FA                 mov     ecx, [ebp+var_4]
.text$mn:000021FD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002202
.text$mn:00002202 loc_2202:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002202                 mov     edx, [ebp+arg_0]
.text$mn:00002205                 push    edx
.text$mn:00002206                 mov     ecx, [ebp+var_4]
.text$mn:00002209                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000220E                 mov     eax, [ebp+var_4]
.text$mn:00002211                 mov     esp, ebp
.text$mn:00002213                 pop     ebp
.text$mn:00002214                 retn    4
.text$mn:00002214 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002214
.text$mn:00002214 ; ---------------------------------------------------------------------------
.text$mn:00002217                 align 4
.text$mn:00002217 _text$mn        ends
.text$mn:00002217
.text$mn:00002218 ; ===========================================================================
.text$mn:00002218
.text$mn:00002218 ; Segment type: Pure code
.text$mn:00002218 ; Segment permissions: Read/Execute
.text$mn:00002218 _text$mn        segment para public 'CODE' use32
.text$mn:00002218                 assume cs:_text$mn
.text$mn:00002218                 ;org 2218h
.text$mn:00002218 ; COMDAT (pick any)
.text$mn:00002218                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002218
.text$mn:00002218 ; =============== S U B R O U T I N E =======================================
.text$mn:00002218
.text$mn:00002218 ; Attributes: bp-based frame
.text$mn:00002218
.text$mn:00002218 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00002218                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00002218 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00002218                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00002218
.text$mn:00002218 var_C           = dword ptr -0Ch
.text$mn:00002218 Dst             = dword ptr -8
.text$mn:00002218 var_4           = dword ptr -4
.text$mn:00002218 arg_0           = dword ptr  8
.text$mn:00002218 arg_4           = dword ptr  0Ch
.text$mn:00002218
.text$mn:00002218                 push    ebp
.text$mn:00002219                 mov     ebp, esp
.text$mn:0000221B                 sub     esp, 0Ch
.text$mn:0000221E                 mov     [ebp+var_4], ecx
.text$mn:00002221                 mov     eax, [ebp+var_4]
.text$mn:00002224                 mov     ecx, [eax+14h]
.text$mn:00002227                 cmp     ecx, [ebp+arg_0]
.text$mn:0000222A                 jnb     short loc_2234
.text$mn:0000222C                 mov     ecx, [ebp+var_4]
.text$mn:0000222F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002234
.text$mn:00002234 loc_2234:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002234                 mov     edx, [ebp+var_4]
.text$mn:00002237                 mov     eax, [edx+14h]
.text$mn:0000223A                 sub     eax, [ebp+arg_0]
.text$mn:0000223D                 cmp     eax, [ebp+arg_4]
.text$mn:00002240                 ja      short loc_2250
.text$mn:00002242                 mov     ecx, [ebp+arg_0]
.text$mn:00002245                 push    ecx
.text$mn:00002246                 mov     ecx, [ebp+var_4]
.text$mn:00002249                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000224E                 jmp     short loc_2296
.text$mn:00002250 ; ---------------------------------------------------------------------------
.text$mn:00002250
.text$mn:00002250 loc_2250:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002250                 cmp     [ebp+arg_4], 0
.text$mn:00002254                 jbe     short loc_2296
.text$mn:00002256                 mov     ecx, [ebp+var_4]
.text$mn:00002259                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000225E                 add     eax, [ebp+arg_0]
.text$mn:00002261                 mov     [ebp+Dst], eax
.text$mn:00002264                 mov     edx, [ebp+var_4]
.text$mn:00002267                 mov     eax, [edx+14h]
.text$mn:0000226A                 sub     eax, [ebp+arg_4]
.text$mn:0000226D                 mov     [ebp+var_C], eax
.text$mn:00002270                 mov     ecx, [ebp+var_C]
.text$mn:00002273                 sub     ecx, [ebp+arg_0]
.text$mn:00002276                 push    ecx             ; Size
.text$mn:00002277                 mov     edx, [ebp+Dst]
.text$mn:0000227A                 add     edx, [ebp+arg_4]
.text$mn:0000227D                 push    edx             ; Src
.text$mn:0000227E                 mov     eax, [ebp+Dst]
.text$mn:00002281                 push    eax             ; Dst
.text$mn:00002282                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00002287                 add     esp, 0Ch
.text$mn:0000228A                 mov     ecx, [ebp+var_C]
.text$mn:0000228D                 push    ecx
.text$mn:0000228E                 mov     ecx, [ebp+var_4]
.text$mn:00002291                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002296
.text$mn:00002296 loc_2296:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00002296                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00002296                 mov     eax, [ebp+var_4]
.text$mn:00002299                 mov     esp, ebp
.text$mn:0000229B                 pop     ebp
.text$mn:0000229C                 retn    8
.text$mn:0000229C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000229C
.text$mn:0000229C ; ---------------------------------------------------------------------------
.text$mn:0000229F                 align 10h
.text$mn:0000229F _text$mn        ends
.text$mn:0000229F
.text$mn:000022A0 ; ===========================================================================
.text$mn:000022A0
.text$mn:000022A0 ; Segment type: Pure code
.text$mn:000022A0 ; Segment permissions: Read/Execute
.text$mn:000022A0 _text$mn        segment para public 'CODE' use32
.text$mn:000022A0                 assume cs:_text$mn
.text$mn:000022A0                 ;org 22A0h
.text$mn:000022A0 ; COMDAT (pick any)
.text$mn:000022A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000022A0
.text$mn:000022A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022A0
.text$mn:000022A0 ; Attributes: bp-based frame
.text$mn:000022A0
.text$mn:000022A0 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000022A0                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000022A0 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000022A0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000022A0                 push    ebp
.text$mn:000022A1                 mov     ebp, esp
.text$mn:000022A3                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000022A8                 pop     ebp
.text$mn:000022A9                 retn
.text$mn:000022A9 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000022A9
.text$mn:000022A9 ; ---------------------------------------------------------------------------
.text$mn:000022AA                 align 4
.text$mn:000022AA _text$mn        ends
.text$mn:000022AA
.text$mn:000022AC ; ===========================================================================
.text$mn:000022AC
.text$mn:000022AC ; Segment type: Pure code
.text$mn:000022AC ; Segment permissions: Read/Execute
.text$mn:000022AC _text$mn        segment para public 'CODE' use32
.text$mn:000022AC                 assume cs:_text$mn
.text$mn:000022AC                 ;org 22ACh
.text$mn:000022AC ; COMDAT (pick any)
.text$mn:000022AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000022AC
.text$mn:000022AC ; =============== S U B R O U T I N E =======================================
.text$mn:000022AC
.text$mn:000022AC ; Attributes: bp-based frame
.text$mn:000022AC
.text$mn:000022AC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall VerticalFileSwitcher::getFullFilePath(unsigned int)const
.text$mn:000022AC                 public ?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$mn:000022AC ?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z proc near
.text$mn:000022AC                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+2EBp
.text$mn:000022AC
.text$mn:000022AC var_14          = dword ptr -14h
.text$mn:000022AC var_10          = dword ptr -10h
.text$mn:000022AC var_C           = dword ptr -0Ch
.text$mn:000022AC var_4           = dword ptr -4
.text$mn:000022AC arg_0           = dword ptr  8
.text$mn:000022AC arg_4           = dword ptr  0Ch
.text$mn:000022AC
.text$mn:000022AC                 push    ebp
.text$mn:000022AD                 mov     ebp, esp
.text$mn:000022AF                 push    0FFFFFFFFh
.text$mn:000022B1                 push    offset __ehhandler$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$mn:000022B6                 mov     eax, large fs:0
.text$mn:000022BC                 push    eax
.text$mn:000022BD                 sub     esp, 8
.text$mn:000022C0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022C5                 xor     eax, ebp
.text$mn:000022C7                 push    eax
.text$mn:000022C8                 lea     eax, [ebp+var_C]
.text$mn:000022CB                 mov     large fs:0, eax
.text$mn:000022D1                 mov     [ebp+var_14], ecx
.text$mn:000022D4                 mov     [ebp+var_10], 0
.text$mn:000022DB                 mov     eax, [ebp+arg_4]
.text$mn:000022DE                 push    eax
.text$mn:000022DF                 mov     ecx, [ebp+arg_0]
.text$mn:000022E2                 push    ecx
.text$mn:000022E3                 mov     ecx, [ebp+var_14]
.text$mn:000022E6                 add     ecx, 6Ch ; 'l'
.text$mn:000022E9                 call    ?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; VerticalFileSwitcherListView::getFullFilePath(uint)
.text$mn:000022EE                 mov     [ebp+var_4], 0
.text$mn:000022F5                 mov     edx, [ebp+var_10]
.text$mn:000022F8                 or      edx, 1
.text$mn:000022FB                 mov     [ebp+var_10], edx
.text$mn:000022FE                 mov     eax, [ebp+arg_0]
.text$mn:00002301                 mov     ecx, [ebp+var_C]
.text$mn:00002304                 mov     large fs:0, ecx
.text$mn:0000230B                 pop     ecx
.text$mn:0000230C                 mov     esp, ebp
.text$mn:0000230E                 pop     ebp
.text$mn:0000230F                 retn    8
.text$mn:0000230F ?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z endp
.text$mn:0000230F
.text$mn:0000230F ; ---------------------------------------------------------------------------
.text$mn:00002312                 align 4
.text$mn:00002312 _text$mn        ends
.text$mn:00002312
.text$x:00002314 ; ===========================================================================
.text$x:00002314
.text$x:00002314 ; Segment type: Pure code
.text$x:00002314 ; Segment permissions: Read/Execute
.text$x:00002314 _text$x         segment para public 'CODE' use32
.text$x:00002314                 assume cs:_text$x
.text$x:00002314                 ;org 2314h
.text$x:00002314 ; COMDAT (pick associative to section at 22AC)
.text$x:00002314                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00002314
.text$x:00002314 ; =============== S U B R O U T I N E =======================================
.text$x:00002314
.text$x:00002314
.text$x:00002314 __unwindfunclet$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0 proc near
.text$x:00002314                                         ; DATA XREF: .xdata$x:00002BACo
.text$x:00002314                 mov     eax, [ebp-10h]
.text$x:00002317                 and     eax, 1
.text$x:0000231A                 jz      $LN4
.text$x:00002320                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002324                 mov     ecx, [ebp+8]
.text$x:00002327                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000232C ; ---------------------------------------------------------------------------
.text$x:0000232C
.text$x:0000232C $LN4:                                   ; CODE XREF: __unwindfunclet$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0+6j
.text$x:0000232C                 retn
.text$x:0000232C __unwindfunclet$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0 endp
.text$x:0000232C
.text$x:0000232D
.text$x:0000232D ; =============== S U B R O U T I N E =======================================
.text$x:0000232D
.text$x:0000232D
.text$x:0000232D __ehhandler$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z proc near
.text$x:0000232D                                         ; DATA XREF: VerticalFileSwitcher::getFullFilePath(uint)+5o
.text$x:0000232D
.text$x:0000232D arg_4           = dword ptr  8
.text$x:0000232D
.text$x:0000232D                 mov     edx, [esp+arg_4]
.text$x:00002331                 lea     eax, [edx+0Ch]
.text$x:00002334                 mov     ecx, [edx-0Ch]
.text$x:00002337                 xor     ecx, eax
.text$x:00002339                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000233E                 mov     eax, offset __ehfuncinfo$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.text$x:00002343                 jmp     ___CxxFrameHandler3
.text$x:00002343 __ehhandler$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z endp
.text$x:00002343
.text$x:00002343 _text$x         ends
.text$x:00002343
.text$mn:00002348 ; ===========================================================================
.text$mn:00002348
.text$mn:00002348 ; Segment type: Pure code
.text$mn:00002348 ; Segment permissions: Read/Execute
.text$mn:00002348 _text$mn        segment para public 'CODE' use32
.text$mn:00002348                 assume cs:_text$mn
.text$mn:00002348                 ;org 2348h
.text$mn:00002348 ; COMDAT (pick any)
.text$mn:00002348                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002348
.text$mn:00002348 ; =============== S U B R O U T I N E =======================================
.text$mn:00002348
.text$mn:00002348 ; Attributes: bp-based frame
.text$mn:00002348
.text$mn:00002348 ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00002348                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00002348 ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00002348                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+167p
.text$mn:00002348                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+1FBp ...
.text$mn:00002348
.text$mn:00002348 var_4           = dword ptr -4
.text$mn:00002348
.text$mn:00002348                 push    ebp
.text$mn:00002349                 mov     ebp, esp
.text$mn:0000234B                 push    ecx
.text$mn:0000234C                 mov     [ebp+var_4], ecx
.text$mn:0000234F                 mov     eax, [ebp+var_4]
.text$mn:00002352                 mov     eax, [eax+0Ch]
.text$mn:00002355                 mov     esp, ebp
.text$mn:00002357                 pop     ebp
.text$mn:00002358                 retn
.text$mn:00002358 ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00002358
.text$mn:00002358 ; ---------------------------------------------------------------------------
.text$mn:00002359                 align 4
.text$mn:00002359 _text$mn        ends
.text$mn:00002359
.text$mn:0000235C ; ===========================================================================
.text$mn:0000235C
.text$mn:0000235C ; Segment type: Pure code
.text$mn:0000235C ; Segment permissions: Read/Execute
.text$mn:0000235C _text$mn        segment para public 'CODE' use32
.text$mn:0000235C                 assume cs:_text$mn
.text$mn:0000235C                 ;org 235Ch
.text$mn:0000235C ; COMDAT (pick any)
.text$mn:0000235C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000235C
.text$mn:0000235C ; =============== S U B R O U T I N E =======================================
.text$mn:0000235C
.text$mn:0000235C ; Attributes: bp-based frame
.text$mn:0000235C
.text$mn:0000235C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000235C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000235C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000235C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000235C
.text$mn:0000235C var_4           = dword ptr -4
.text$mn:0000235C Str             = dword ptr  8
.text$mn:0000235C
.text$mn:0000235C                 push    ebp
.text$mn:0000235D                 mov     ebp, esp
.text$mn:0000235F                 push    ecx
.text$mn:00002360                 mov     eax, [ebp+Str]
.text$mn:00002363                 movsx   ecx, byte ptr [eax]
.text$mn:00002366                 test    ecx, ecx
.text$mn:00002368                 jnz     short loc_2373
.text$mn:0000236A                 mov     [ebp+var_4], 0
.text$mn:00002371                 jmp     short loc_2382
.text$mn:00002373 ; ---------------------------------------------------------------------------
.text$mn:00002373
.text$mn:00002373 loc_2373:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00002373                 mov     edx, [ebp+Str]
.text$mn:00002376                 push    edx             ; Str
.text$mn:00002377                 call    _strlen
.text$mn:0000237C                 add     esp, 4
.text$mn:0000237F                 mov     [ebp+var_4], eax
.text$mn:00002382
.text$mn:00002382 loc_2382:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00002382                 mov     eax, [ebp+var_4]
.text$mn:00002385                 mov     esp, ebp
.text$mn:00002387                 pop     ebp
.text$mn:00002388                 retn
.text$mn:00002388 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002388
.text$mn:00002388 ; ---------------------------------------------------------------------------
.text$mn:00002389                 align 4
.text$mn:00002389 _text$mn        ends
.text$mn:00002389
.text$mn:0000238C ; ===========================================================================
.text$mn:0000238C
.text$mn:0000238C ; Segment type: Pure code
.text$mn:0000238C ; Segment permissions: Read/Execute
.text$mn:0000238C _text$mn        segment para public 'CODE' use32
.text$mn:0000238C                 assume cs:_text$mn
.text$mn:0000238C                 ;org 238Ch
.text$mn:0000238C ; COMDAT (pick any)
.text$mn:0000238C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000238C
.text$mn:0000238C ; =============== S U B R O U T I N E =======================================
.text$mn:0000238C
.text$mn:0000238C ; Attributes: bp-based frame
.text$mn:0000238C
.text$mn:0000238C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000238C                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000238C ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000238C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000238C
.text$mn:0000238C var_4           = dword ptr -4
.text$mn:0000238C
.text$mn:0000238C                 push    ebp
.text$mn:0000238D                 mov     ebp, esp
.text$mn:0000238F                 push    ecx
.text$mn:00002390                 mov     [ebp+var_4], ecx
.text$mn:00002393                 mov     eax, [ebp+var_4]
.text$mn:00002396                 push    eax
.text$mn:00002397                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000239C                 add     esp, 4
.text$mn:0000239F                 mov     esp, ebp
.text$mn:000023A1                 pop     ebp
.text$mn:000023A2                 retn
.text$mn:000023A2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000023A2
.text$mn:000023A2 ; ---------------------------------------------------------------------------
.text$mn:000023A3                 align 4
.text$mn:000023A3 _text$mn        ends
.text$mn:000023A3
.text$mn:000023A4 ; ===========================================================================
.text$mn:000023A4
.text$mn:000023A4 ; Segment type: Pure code
.text$mn:000023A4 ; Segment permissions: Read/Execute
.text$mn:000023A4 _text$mn        segment para public 'CODE' use32
.text$mn:000023A4                 assume cs:_text$mn
.text$mn:000023A4                 ;org 23A4h
.text$mn:000023A4 ; COMDAT (pick any)
.text$mn:000023A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023A4
.text$mn:000023A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023A4
.text$mn:000023A4 ; Attributes: bp-based frame
.text$mn:000023A4
.text$mn:000023A4 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000023A4                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000023A4 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000023A4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000023A4
.text$mn:000023A4 var_4           = dword ptr -4
.text$mn:000023A4
.text$mn:000023A4                 push    ebp
.text$mn:000023A5                 mov     ebp, esp
.text$mn:000023A7                 push    ecx
.text$mn:000023A8                 mov     [ebp+var_4], ecx
.text$mn:000023AB                 or      eax, 0FFFFFFFFh
.text$mn:000023AE                 mov     esp, ebp
.text$mn:000023B0                 pop     ebp
.text$mn:000023B1                 retn
.text$mn:000023B1 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000023B1
.text$mn:000023B1 ; ---------------------------------------------------------------------------
.text$mn:000023B2                 align 4
.text$mn:000023B2 _text$mn        ends
.text$mn:000023B2
.text$mn:000023B4 ; ===========================================================================
.text$mn:000023B4
.text$mn:000023B4 ; Segment type: Pure code
.text$mn:000023B4 ; Segment permissions: Read/Execute
.text$mn:000023B4 _text$mn        segment para public 'CODE' use32
.text$mn:000023B4                 assume cs:_text$mn
.text$mn:000023B4                 ;org 23B4h
.text$mn:000023B4 ; COMDAT (pick any)
.text$mn:000023B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023B4
.text$mn:000023B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B4
.text$mn:000023B4 ; Attributes: bp-based frame
.text$mn:000023B4
.text$mn:000023B4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000023B4                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000023B4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000023B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000023B4
.text$mn:000023B4 arg_0           = dword ptr  8
.text$mn:000023B4
.text$mn:000023B4                 push    ebp
.text$mn:000023B5                 mov     ebp, esp
.text$mn:000023B7                 mov     ecx, [ebp+arg_0]
.text$mn:000023BA                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000023BF                 pop     ebp
.text$mn:000023C0                 retn
.text$mn:000023C0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000023C0
.text$mn:000023C0 ; ---------------------------------------------------------------------------
.text$mn:000023C1                 align 4
.text$mn:000023C1 _text$mn        ends
.text$mn:000023C1
.text$mn:000023C4 ; ===========================================================================
.text$mn:000023C4
.text$mn:000023C4 ; Segment type: Pure code
.text$mn:000023C4 ; Segment permissions: Read/Execute
.text$mn:000023C4 _text$mn        segment para public 'CODE' use32
.text$mn:000023C4                 assume cs:_text$mn
.text$mn:000023C4                 ;org 23C4h
.text$mn:000023C4 ; COMDAT (pick any)
.text$mn:000023C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000023C4
.text$mn:000023C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C4
.text$mn:000023C4 ; Attributes: bp-based frame
.text$mn:000023C4
.text$mn:000023C4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000023C4                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000023C4 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000023C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000023C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000023C4
.text$mn:000023C4 var_10          = dword ptr -10h
.text$mn:000023C4 var_C           = dword ptr -0Ch
.text$mn:000023C4 var_8           = dword ptr -8
.text$mn:000023C4 var_1           = byte ptr -1
.text$mn:000023C4
.text$mn:000023C4                 push    ebp
.text$mn:000023C5                 mov     ebp, esp
.text$mn:000023C7                 sub     esp, 10h
.text$mn:000023CA                 mov     [ebp+var_10], ecx
.text$mn:000023CD                 lea     eax, [ebp+var_1]
.text$mn:000023D0                 push    eax
.text$mn:000023D1                 mov     ecx, [ebp+var_10]
.text$mn:000023D4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000023D9                 mov     ecx, eax
.text$mn:000023DB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000023E0                 mov     [ebp+var_8], eax
.text$mn:000023E3                 cmp     [ebp+var_8], 1
.text$mn:000023E7                 ja      short loc_23F2
.text$mn:000023E9                 mov     [ebp+var_C], 1
.text$mn:000023F0                 jmp     short loc_23FB
.text$mn:000023F2 ; ---------------------------------------------------------------------------
.text$mn:000023F2
.text$mn:000023F2 loc_23F2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000023F2                 mov     ecx, [ebp+var_8]
.text$mn:000023F5                 sub     ecx, 1
.text$mn:000023F8                 mov     [ebp+var_C], ecx
.text$mn:000023FB
.text$mn:000023FB loc_23FB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000023FB                 mov     eax, [ebp+var_C]
.text$mn:000023FE                 mov     esp, ebp
.text$mn:00002400                 pop     ebp
.text$mn:00002401                 retn
.text$mn:00002401 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002401
.text$mn:00002401 ; ---------------------------------------------------------------------------
.text$mn:00002402                 align 4
.text$mn:00002402 _text$mn        ends
.text$mn:00002402
.text$mn:00002404 ; ===========================================================================
.text$mn:00002404
.text$mn:00002404 ; Segment type: Pure code
.text$mn:00002404 ; Segment permissions: Read/Execute
.text$mn:00002404 _text$mn        segment para public 'CODE' use32
.text$mn:00002404                 assume cs:_text$mn
.text$mn:00002404                 ;org 2404h
.text$mn:00002404 ; COMDAT (pick any)
.text$mn:00002404                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002404
.text$mn:00002404 ; =============== S U B R O U T I N E =======================================
.text$mn:00002404
.text$mn:00002404 ; Attributes: bp-based frame
.text$mn:00002404
.text$mn:00002404 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00002404                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002404 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002404                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00002404                                         ; DATA XREF: .rdata:00002C80o
.text$mn:00002404
.text$mn:00002404 var_1C          = dword ptr -1Ch
.text$mn:00002404 var_18          = dword ptr -18h
.text$mn:00002404 Str             = dword ptr -14h
.text$mn:00002404 var_10          = dword ptr -10h
.text$mn:00002404 var_C           = dword ptr -0Ch
.text$mn:00002404 var_4           = dword ptr -4
.text$mn:00002404 arg_0           = dword ptr  8
.text$mn:00002404 arg_4           = dword ptr  0Ch
.text$mn:00002404
.text$mn:00002404                 push    ebp
.text$mn:00002405                 mov     ebp, esp
.text$mn:00002407                 push    0FFFFFFFFh
.text$mn:00002409                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000240E                 mov     eax, large fs:0
.text$mn:00002414                 push    eax
.text$mn:00002415                 sub     esp, 10h
.text$mn:00002418                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000241D                 xor     eax, ebp
.text$mn:0000241F                 push    eax
.text$mn:00002420                 lea     eax, [ebp+var_C]
.text$mn:00002423                 mov     large fs:0, eax
.text$mn:00002429                 mov     [ebp+var_1C], ecx
.text$mn:0000242C                 mov     [ebp+var_18], 0
.text$mn:00002433                 mov     eax, [ebp+arg_4]
.text$mn:00002436                 push    eax             ; int
.text$mn:00002437                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000243C                 add     esp, 4
.text$mn:0000243F                 mov     [ebp+var_10], eax
.text$mn:00002442                 cmp     [ebp+var_10], 0
.text$mn:00002446                 jz      short loc_2450
.text$mn:00002448                 mov     ecx, [ebp+var_10]
.text$mn:0000244B                 mov     [ebp+Str], ecx
.text$mn:0000244E                 jmp     short loc_2457
.text$mn:00002450 ; ---------------------------------------------------------------------------
.text$mn:00002450
.text$mn:00002450 loc_2450:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002450                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002457
.text$mn:00002457 loc_2457:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00002457                 mov     edx, [ebp+Str]
.text$mn:0000245A                 push    edx             ; Str
.text$mn:0000245B                 mov     ecx, [ebp+arg_0]
.text$mn:0000245E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002463                 mov     [ebp+var_4], 0
.text$mn:0000246A                 mov     eax, [ebp+var_18]
.text$mn:0000246D                 or      eax, 1
.text$mn:00002470                 mov     [ebp+var_18], eax
.text$mn:00002473                 mov     eax, [ebp+arg_0]
.text$mn:00002476                 mov     ecx, [ebp+var_C]
.text$mn:00002479                 mov     large fs:0, ecx
.text$mn:00002480                 pop     ecx
.text$mn:00002481                 mov     esp, ebp
.text$mn:00002483                 pop     ebp
.text$mn:00002484                 retn    8
.text$mn:00002484 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002484
.text$mn:00002484 ; ---------------------------------------------------------------------------
.text$mn:00002487                 align 4
.text$mn:00002487 _text$mn        ends
.text$mn:00002487
.text$x:00002488 ; ===========================================================================
.text$x:00002488
.text$x:00002488 ; Segment type: Pure code
.text$x:00002488 ; Segment permissions: Read/Execute
.text$x:00002488 _text$x         segment para public 'CODE' use32
.text$x:00002488                 assume cs:_text$x
.text$x:00002488                 ;org 2488h
.text$x:00002488 ; COMDAT (pick associative to section at 2404)
.text$x:00002488                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00002488
.text$x:00002488 ; =============== S U B R O U T I N E =======================================
.text$x:00002488
.text$x:00002488
.text$x:00002488 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002488                                         ; DATA XREF: .xdata$x:000029C8o
.text$x:00002488                 mov     eax, [ebp-18h]
.text$x:0000248B                 and     eax, 1
.text$x:0000248E                 jz      $LN6
.text$x:00002494                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002498                 mov     ecx, [ebp+8]
.text$x:0000249B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000024A0 ; ---------------------------------------------------------------------------
.text$x:000024A0
.text$x:000024A0 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000024A0                 retn
.text$x:000024A0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000024A0
.text$x:000024A1
.text$x:000024A1 ; =============== S U B R O U T I N E =======================================
.text$x:000024A1
.text$x:000024A1
.text$x:000024A1 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000024A1                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:000024A1
.text$x:000024A1 arg_4           = dword ptr  8
.text$x:000024A1
.text$x:000024A1                 mov     edx, [esp+arg_4]
.text$x:000024A5                 lea     eax, [edx+0Ch]
.text$x:000024A8                 mov     ecx, [edx-14h]
.text$x:000024AB                 xor     ecx, eax
.text$x:000024AD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000024B2                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000024B7                 jmp     ___CxxFrameHandler3
.text$x:000024B7 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000024B7
.text$x:000024B7 _text$x         ends
.text$x:000024B7
.text$mn:000024BC ; ===========================================================================
.text$mn:000024BC
.text$mn:000024BC ; Segment type: Pure code
.text$mn:000024BC ; Segment permissions: Read/Execute
.text$mn:000024BC _text$mn        segment para public 'CODE' use32
.text$mn:000024BC                 assume cs:_text$mn
.text$mn:000024BC                 ;org 24BCh
.text$mn:000024BC ; COMDAT (pick any)
.text$mn:000024BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000024BC
.text$mn:000024BC ; =============== S U B R O U T I N E =======================================
.text$mn:000024BC
.text$mn:000024BC ; Attributes: bp-based frame
.text$mn:000024BC
.text$mn:000024BC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000024BC                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000024BC ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000024BC                                         ; DATA XREF: .rdata:00002CB4o
.text$mn:000024BC
.text$mn:000024BC var_14          = dword ptr -14h
.text$mn:000024BC var_10          = dword ptr -10h
.text$mn:000024BC var_C           = dword ptr -0Ch
.text$mn:000024BC var_4           = dword ptr -4
.text$mn:000024BC arg_0           = dword ptr  8
.text$mn:000024BC arg_4           = dword ptr  0Ch
.text$mn:000024BC
.text$mn:000024BC                 push    ebp
.text$mn:000024BD                 mov     ebp, esp
.text$mn:000024BF                 push    0FFFFFFFFh
.text$mn:000024C1                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000024C6                 mov     eax, large fs:0
.text$mn:000024CC                 push    eax
.text$mn:000024CD                 sub     esp, 8
.text$mn:000024D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000024D5                 xor     eax, ebp
.text$mn:000024D7                 push    eax
.text$mn:000024D8                 lea     eax, [ebp+var_C]
.text$mn:000024DB                 mov     large fs:0, eax
.text$mn:000024E1                 mov     [ebp+var_14], ecx
.text$mn:000024E4                 mov     [ebp+var_10], 0
.text$mn:000024EB                 cmp     [ebp+arg_4], 1
.text$mn:000024EF                 jnz     short loc_2515
.text$mn:000024F1                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000024F6                 mov     ecx, [ebp+arg_0]
.text$mn:000024F9                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000024FE                 mov     [ebp+var_4], 0
.text$mn:00002505                 mov     eax, [ebp+var_10]
.text$mn:00002508                 or      eax, 1
.text$mn:0000250B                 mov     [ebp+var_10], eax
.text$mn:0000250E                 mov     eax, [ebp+arg_0]
.text$mn:00002511                 jmp     short loc_2538
.text$mn:00002513 ; ---------------------------------------------------------------------------
.text$mn:00002513                 jmp     short loc_2538
.text$mn:00002515 ; ---------------------------------------------------------------------------
.text$mn:00002515
.text$mn:00002515 loc_2515:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002515                 mov     ecx, [ebp+arg_4]
.text$mn:00002518                 push    ecx
.text$mn:00002519                 mov     edx, [ebp+arg_0]
.text$mn:0000251C                 push    edx
.text$mn:0000251D                 mov     ecx, [ebp+var_14]
.text$mn:00002520                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002525                 mov     [ebp+var_4], 0
.text$mn:0000252C                 mov     eax, [ebp+var_10]
.text$mn:0000252F                 or      eax, 1
.text$mn:00002532                 mov     [ebp+var_10], eax
.text$mn:00002535                 mov     eax, [ebp+arg_0]
.text$mn:00002538
.text$mn:00002538 loc_2538:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002538                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002538                 mov     ecx, [ebp+var_C]
.text$mn:0000253B                 mov     large fs:0, ecx
.text$mn:00002542                 pop     ecx
.text$mn:00002543                 mov     esp, ebp
.text$mn:00002545                 pop     ebp
.text$mn:00002546                 retn    8
.text$mn:00002546 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002546
.text$mn:00002546 ; ---------------------------------------------------------------------------
.text$mn:00002549                 align 4
.text$mn:00002549 _text$mn        ends
.text$mn:00002549
.text$x:0000254C ; ===========================================================================
.text$x:0000254C
.text$x:0000254C ; Segment type: Pure code
.text$x:0000254C ; Segment permissions: Read/Execute
.text$x:0000254C _text$x         segment para public 'CODE' use32
.text$x:0000254C                 assume cs:_text$x
.text$x:0000254C                 ;org 254Ch
.text$x:0000254C ; COMDAT (pick associative to section at 24BC)
.text$x:0000254C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000254C
.text$x:0000254C ; =============== S U B R O U T I N E =======================================
.text$x:0000254C
.text$x:0000254C
.text$x:0000254C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000254C                                         ; DATA XREF: .xdata$x:00002A4Co
.text$x:0000254C                 mov     eax, [ebp-10h]
.text$x:0000254F                 and     eax, 1
.text$x:00002552                 jz      $LN6_0
.text$x:00002558                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000255C                 mov     ecx, [ebp+8]
.text$x:0000255F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002564 ; ---------------------------------------------------------------------------
.text$x:00002564
.text$x:00002564 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002564                 retn
.text$x:00002564 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002564
.text$x:00002565
.text$x:00002565 ; =============== S U B R O U T I N E =======================================
.text$x:00002565
.text$x:00002565
.text$x:00002565 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002565                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002565
.text$x:00002565 arg_4           = dword ptr  8
.text$x:00002565
.text$x:00002565                 mov     edx, [esp+arg_4]
.text$x:00002569                 lea     eax, [edx+0Ch]
.text$x:0000256C                 mov     ecx, [edx-0Ch]
.text$x:0000256F                 xor     ecx, eax
.text$x:00002571                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002576                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000257B                 jmp     ___CxxFrameHandler3
.text$x:0000257B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000257B
.text$x:0000257B _text$x         ends
.text$x:0000257B
.text$mn:00002580 ; ===========================================================================
.text$mn:00002580
.text$mn:00002580 ; Segment type: Pure code
.text$mn:00002580 ; Segment permissions: Read/Execute
.text$mn:00002580 _text$mn        segment para public 'CODE' use32
.text$mn:00002580                 assume cs:_text$mn
.text$mn:00002580                 ;org 2580h
.text$mn:00002580 ; COMDAT (pick any)
.text$mn:00002580                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002580
.text$mn:00002580 ; =============== S U B R O U T I N E =======================================
.text$mn:00002580
.text$mn:00002580 ; Attributes: bp-based frame
.text$mn:00002580
.text$mn:00002580 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002580                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002580 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002580                                         ; DATA XREF: .rdata:00002CF4o
.text$mn:00002580
.text$mn:00002580 var_1C          = dword ptr -1Ch
.text$mn:00002580 var_18          = dword ptr -18h
.text$mn:00002580 Str             = dword ptr -14h
.text$mn:00002580 var_10          = dword ptr -10h
.text$mn:00002580 var_C           = dword ptr -0Ch
.text$mn:00002580 var_4           = dword ptr -4
.text$mn:00002580 arg_0           = dword ptr  8
.text$mn:00002580 arg_4           = dword ptr  0Ch
.text$mn:00002580
.text$mn:00002580                 push    ebp
.text$mn:00002581                 mov     ebp, esp
.text$mn:00002583                 push    0FFFFFFFFh
.text$mn:00002585                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000258A                 mov     eax, large fs:0
.text$mn:00002590                 push    eax
.text$mn:00002591                 sub     esp, 10h
.text$mn:00002594                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002599                 xor     eax, ebp
.text$mn:0000259B                 push    eax
.text$mn:0000259C                 lea     eax, [ebp+var_C]
.text$mn:0000259F                 mov     large fs:0, eax
.text$mn:000025A5                 mov     [ebp+var_1C], ecx
.text$mn:000025A8                 mov     [ebp+var_18], 0
.text$mn:000025AF                 mov     eax, [ebp+arg_4]
.text$mn:000025B2                 push    eax             ; int
.text$mn:000025B3                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:000025B8                 add     esp, 4
.text$mn:000025BB                 mov     [ebp+var_10], eax
.text$mn:000025BE                 cmp     [ebp+var_10], 0
.text$mn:000025C2                 jz      short loc_25CC
.text$mn:000025C4                 mov     ecx, [ebp+var_10]
.text$mn:000025C7                 mov     [ebp+Str], ecx
.text$mn:000025CA                 jmp     short loc_25D3
.text$mn:000025CC ; ---------------------------------------------------------------------------
.text$mn:000025CC
.text$mn:000025CC loc_25CC:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000025CC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000025D3
.text$mn:000025D3 loc_25D3:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000025D3                 mov     edx, [ebp+Str]
.text$mn:000025D6                 push    edx             ; Str
.text$mn:000025D7                 mov     ecx, [ebp+arg_0]
.text$mn:000025DA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000025DF                 mov     [ebp+var_4], 0
.text$mn:000025E6                 mov     eax, [ebp+var_18]
.text$mn:000025E9                 or      eax, 1
.text$mn:000025EC                 mov     [ebp+var_18], eax
.text$mn:000025EF                 mov     eax, [ebp+arg_0]
.text$mn:000025F2                 mov     ecx, [ebp+var_C]
.text$mn:000025F5                 mov     large fs:0, ecx
.text$mn:000025FC                 pop     ecx
.text$mn:000025FD                 mov     esp, ebp
.text$mn:000025FF                 pop     ebp
.text$mn:00002600                 retn    8
.text$mn:00002600 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002600
.text$mn:00002600 ; ---------------------------------------------------------------------------
.text$mn:00002603                 align 4
.text$mn:00002603 _text$mn        ends
.text$mn:00002603
.text$x:00002604 ; ===========================================================================
.text$x:00002604
.text$x:00002604 ; Segment type: Pure code
.text$x:00002604 ; Segment permissions: Read/Execute
.text$x:00002604 _text$x         segment para public 'CODE' use32
.text$x:00002604                 assume cs:_text$x
.text$x:00002604                 ;org 2604h
.text$x:00002604 ; COMDAT (pick associative to section at 2580)
.text$x:00002604                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00002604
.text$x:00002604 ; =============== S U B R O U T I N E =======================================
.text$x:00002604
.text$x:00002604
.text$x:00002604 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002604                                         ; DATA XREF: .xdata$x:00002AD0o
.text$x:00002604                 mov     eax, [ebp-18h]
.text$x:00002607                 and     eax, 1
.text$x:0000260A                 jz      $LN6_1
.text$x:00002610                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002614                 mov     ecx, [ebp+8]
.text$x:00002617                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000261C ; ---------------------------------------------------------------------------
.text$x:0000261C
.text$x:0000261C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000261C                 retn
.text$x:0000261C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000261C
.text$x:0000261D
.text$x:0000261D ; =============== S U B R O U T I N E =======================================
.text$x:0000261D
.text$x:0000261D
.text$x:0000261D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000261D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000261D
.text$x:0000261D arg_4           = dword ptr  8
.text$x:0000261D
.text$x:0000261D                 mov     edx, [esp+arg_4]
.text$x:00002621                 lea     eax, [edx+0Ch]
.text$x:00002624                 mov     ecx, [edx-14h]
.text$x:00002627                 xor     ecx, eax
.text$x:00002629                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000262E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002633                 jmp     ___CxxFrameHandler3
.text$x:00002633 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002633
.text$x:00002633 _text$x         ends
.text$x:00002633
.text$mn:00002638 ; ===========================================================================
.text$mn:00002638
.text$mn:00002638 ; Segment type: Pure code
.text$mn:00002638 ; Segment permissions: Read/Execute
.text$mn:00002638 _text$mn        segment para public 'CODE' use32
.text$mn:00002638                 assume cs:_text$mn
.text$mn:00002638                 ;org 2638h
.text$mn:00002638 ; COMDAT (pick any)
.text$mn:00002638                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002638
.text$mn:00002638 ; =============== S U B R O U T I N E =======================================
.text$mn:00002638
.text$mn:00002638 ; Attributes: bp-based frame
.text$mn:00002638
.text$mn:00002638 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002638                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002638 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002638                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002638
.text$mn:00002638 var_4           = dword ptr -4
.text$mn:00002638 Dst             = dword ptr  8
.text$mn:00002638 Src             = dword ptr  0Ch
.text$mn:00002638 Size            = dword ptr  10h
.text$mn:00002638
.text$mn:00002638                 push    ebp
.text$mn:00002639                 mov     ebp, esp
.text$mn:0000263B                 push    ecx
.text$mn:0000263C                 cmp     [ebp+Size], 0
.text$mn:00002640                 jnz     short loc_264A
.text$mn:00002642                 mov     eax, [ebp+Dst]
.text$mn:00002645                 mov     [ebp+var_4], eax
.text$mn:00002648                 jmp     short loc_2661
.text$mn:0000264A ; ---------------------------------------------------------------------------
.text$mn:0000264A
.text$mn:0000264A loc_264A:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000264A                 mov     ecx, [ebp+Size]
.text$mn:0000264D                 push    ecx             ; Size
.text$mn:0000264E                 mov     edx, [ebp+Src]
.text$mn:00002651                 push    edx             ; Src
.text$mn:00002652                 mov     eax, [ebp+Dst]
.text$mn:00002655                 push    eax             ; Dst
.text$mn:00002656                 call    _memmove
.text$mn:0000265B                 add     esp, 0Ch
.text$mn:0000265E                 mov     [ebp+var_4], eax
.text$mn:00002661
.text$mn:00002661 loc_2661:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002661                 mov     eax, [ebp+var_4]
.text$mn:00002664                 mov     esp, ebp
.text$mn:00002666                 pop     ebp
.text$mn:00002667                 retn
.text$mn:00002667 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002667
.text$mn:00002667 _text$mn        ends
.text$mn:00002667
.text$mn:00002668 ; ===========================================================================
.text$mn:00002668
.text$mn:00002668 ; Segment type: Pure code
.text$mn:00002668 ; Segment permissions: Read/Execute
.text$mn:00002668 _text$mn        segment para public 'CODE' use32
.text$mn:00002668                 assume cs:_text$mn
.text$mn:00002668                 ;org 2668h
.text$mn:00002668 ; COMDAT (pick any)
.text$mn:00002668                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002668
.text$mn:00002668 ; =============== S U B R O U T I N E =======================================
.text$mn:00002668
.text$mn:00002668 ; Attributes: bp-based frame
.text$mn:00002668
.text$mn:00002668 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002668                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002668 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002668                                         ; DATA XREF: .rdata:00002C7Co
.text$mn:00002668
.text$mn:00002668 var_4           = dword ptr -4
.text$mn:00002668
.text$mn:00002668                 push    ebp
.text$mn:00002669                 mov     ebp, esp
.text$mn:0000266B                 push    ecx
.text$mn:0000266C                 mov     [ebp+var_4], ecx
.text$mn:0000266F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002674                 mov     esp, ebp
.text$mn:00002676                 pop     ebp
.text$mn:00002677                 retn
.text$mn:00002677 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002677
.text$mn:00002677 _text$mn        ends
.text$mn:00002677
.text$mn:00002678 ; ===========================================================================
.text$mn:00002678
.text$mn:00002678 ; Segment type: Pure code
.text$mn:00002678 ; Segment permissions: Read/Execute
.text$mn:00002678 _text$mn        segment para public 'CODE' use32
.text$mn:00002678                 assume cs:_text$mn
.text$mn:00002678                 ;org 2678h
.text$mn:00002678 ; COMDAT (pick any)
.text$mn:00002678                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002678
.text$mn:00002678 ; =============== S U B R O U T I N E =======================================
.text$mn:00002678
.text$mn:00002678 ; Attributes: bp-based frame
.text$mn:00002678
.text$mn:00002678 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002678                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002678 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002678                                         ; DATA XREF: .rdata:00002CB0o
.text$mn:00002678
.text$mn:00002678 var_4           = dword ptr -4
.text$mn:00002678
.text$mn:00002678                 push    ebp
.text$mn:00002679                 mov     ebp, esp
.text$mn:0000267B                 push    ecx
.text$mn:0000267C                 mov     [ebp+var_4], ecx
.text$mn:0000267F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002684                 mov     esp, ebp
.text$mn:00002686                 pop     ebp
.text$mn:00002687                 retn
.text$mn:00002687 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002687
.text$mn:00002687 _text$mn        ends
.text$mn:00002687
.text$mn:00002688 ; ===========================================================================
.text$mn:00002688
.text$mn:00002688 ; Segment type: Pure code
.text$mn:00002688 ; Segment permissions: Read/Execute
.text$mn:00002688 _text$mn        segment para public 'CODE' use32
.text$mn:00002688                 assume cs:_text$mn
.text$mn:00002688                 ;org 2688h
.text$mn:00002688 ; COMDAT (pick any)
.text$mn:00002688                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002688
.text$mn:00002688 ; =============== S U B R O U T I N E =======================================
.text$mn:00002688
.text$mn:00002688 ; Attributes: bp-based frame
.text$mn:00002688
.text$mn:00002688 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002688                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002688 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002688                                         ; DATA XREF: .rdata:00002CF0o
.text$mn:00002688
.text$mn:00002688 var_4           = dword ptr -4
.text$mn:00002688
.text$mn:00002688                 push    ebp
.text$mn:00002689                 mov     ebp, esp
.text$mn:0000268B                 push    ecx
.text$mn:0000268C                 mov     [ebp+var_4], ecx
.text$mn:0000268F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002694                 mov     esp, ebp
.text$mn:00002696                 pop     ebp
.text$mn:00002697                 retn
.text$mn:00002697 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002697
.text$mn:00002697 _text$mn        ends
.text$mn:00002697
.text$mn:00002698 ; ===========================================================================
.text$mn:00002698
.text$mn:00002698 ; Segment type: Pure code
.text$mn:00002698 ; Segment permissions: Read/Execute
.text$mn:00002698 _text$mn        segment para public 'CODE' use32
.text$mn:00002698                 assume cs:_text$mn
.text$mn:00002698                 ;org 2698h
.text$mn:00002698 ; COMDAT (pick any)
.text$mn:00002698                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002698
.text$mn:00002698 ; =============== S U B R O U T I N E =======================================
.text$mn:00002698
.text$mn:00002698 ; Attributes: bp-based frame
.text$mn:00002698
.text$mn:00002698 ; int __thiscall VerticalFileSwitcher::nbSelectedFiles(VerticalFileSwitcher *__hidden this)
.text$mn:00002698                 public ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ
.text$mn:00002698 ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ proc near
.text$mn:00002698                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+20Dp
.text$mn:00002698
.text$mn:00002698 var_4           = dword ptr -4
.text$mn:00002698
.text$mn:00002698                 push    ebp
.text$mn:00002699                 mov     ebp, esp
.text$mn:0000269B                 push    ecx
.text$mn:0000269C                 mov     [ebp+var_4], ecx
.text$mn:0000269F                 mov     ecx, [ebp+var_4]
.text$mn:000026A2                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:000026A5                 call    ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ ; VerticalFileSwitcherListView::nbSelectedFiles(void)
.text$mn:000026AA                 mov     esp, ebp
.text$mn:000026AC                 pop     ebp
.text$mn:000026AD                 retn
.text$mn:000026AD ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ endp
.text$mn:000026AD
.text$mn:000026AD ; ---------------------------------------------------------------------------
.text$mn:000026AE                 align 10h
.text$mn:000026AE _text$mn        ends
.text$mn:000026AE
.text$mn:000026B0 ; ===========================================================================
.text$mn:000026B0
.text$mn:000026B0 ; Segment type: Pure code
.text$mn:000026B0 ; Segment permissions: Read/Execute
.text$mn:000026B0 _text$mn        segment para public 'CODE' use32
.text$mn:000026B0                 assume cs:_text$mn
.text$mn:000026B0                 ;org 26B0h
.text$mn:000026B0 ; COMDAT (pick any)
.text$mn:000026B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000026B0
.text$mn:000026B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026B0
.text$mn:000026B0 ; Attributes: bp-based frame
.text$mn:000026B0
.text$mn:000026B0 ; int __thiscall VerticalFileSwitcherListView::nbSelectedFiles(VerticalFileSwitcherListView *__hidden this)
.text$mn:000026B0                 public ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ
.text$mn:000026B0 ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ proc near
.text$mn:000026B0                                         ; CODE XREF: VerticalFileSwitcher::nbSelectedFiles(void)+Dp
.text$mn:000026B0
.text$mn:000026B0 var_4           = dword ptr -4
.text$mn:000026B0
.text$mn:000026B0                 push    ebp
.text$mn:000026B1                 mov     ebp, esp
.text$mn:000026B3                 push    ecx
.text$mn:000026B4                 mov     [ebp+var_4], ecx
.text$mn:000026B7                 push    0               ; lParam
.text$mn:000026B9                 push    0               ; wParam
.text$mn:000026BB                 push    1032h           ; Msg
.text$mn:000026C0                 mov     eax, [ebp+var_4]
.text$mn:000026C3                 mov     ecx, [eax+0Ch]
.text$mn:000026C6                 push    ecx             ; hWnd
.text$mn:000026C7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000026CD                 mov     esp, ebp
.text$mn:000026CF                 pop     ebp
.text$mn:000026D0                 retn
.text$mn:000026D0 ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ endp
.text$mn:000026D0
.text$mn:000026D0 ; ---------------------------------------------------------------------------
.text$mn:000026D1                 align 4
.text$mn:000026D1 _text$mn        ends
.text$mn:000026D1
.text$mn:000026D4 ; ===========================================================================
.text$mn:000026D4
.text$mn:000026D4 ; Segment type: Pure code
.text$mn:000026D4 ; Segment permissions: Read/Execute
.text$mn:000026D4 _text$mn        segment para public 'CODE' use32
.text$mn:000026D4                 assume cs:_text$mn
.text$mn:000026D4                 ;org 26D4h
.text$mn:000026D4 ; COMDAT (pick any)
.text$mn:000026D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000026D4
.text$mn:000026D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D4
.text$mn:000026D4 ; Attributes: bp-based frame
.text$mn:000026D4
.text$mn:000026D4 ; int __stdcall DockingDlgInterface::run_dlgProc(DockingDlgInterface *this, unsigned int, unsigned int, __int32)
.text$mn:000026D4                 public ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z
.text$mn:000026D4 ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z proc near
.text$mn:000026D4                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+473p
.text$mn:000026D4                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+48Ap
.text$mn:000026D4
.text$mn:000026D4 var_C           = dword ptr -0Ch
.text$mn:000026D4 var_8           = dword ptr -8
.text$mn:000026D4 var_4           = dword ptr -4
.text$mn:000026D4 this            = dword ptr  8
.text$mn:000026D4 arg_4           = dword ptr  0Ch
.text$mn:000026D4 arg_C           = dword ptr  14h
.text$mn:000026D4
.text$mn:000026D4                 push    ebp
.text$mn:000026D5                 mov     ebp, esp
.text$mn:000026D7                 sub     esp, 0Ch
.text$mn:000026DA                 mov     eax, [ebp+arg_4]
.text$mn:000026DD                 mov     [ebp+var_C], eax
.text$mn:000026E0                 cmp     [ebp+var_C], 4Eh ; 'N'
.text$mn:000026E4                 jz      short loc_26E8
.text$mn:000026E6                 jmp     short loc_274A
.text$mn:000026E8 ; ---------------------------------------------------------------------------
.text$mn:000026E8
.text$mn:000026E8 loc_26E8:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+10j
.text$mn:000026E8                 mov     ecx, [ebp+arg_C]
.text$mn:000026EB                 mov     [ebp+var_4], ecx
.text$mn:000026EE                 mov     edx, [ebp+var_4]
.text$mn:000026F1                 mov     eax, [ebp+this]
.text$mn:000026F4                 mov     ecx, [edx]
.text$mn:000026F6                 cmp     ecx, [eax+8]
.text$mn:000026F9                 jnz     short loc_274A
.text$mn:000026FB                 mov     edx, [ebp+var_4]
.text$mn:000026FE                 mov     eax, [edx+8]
.text$mn:00002701                 and     eax, 0FFFFh
.text$mn:00002706                 movzx   ecx, ax
.text$mn:00002709                 mov     [ebp+var_8], ecx
.text$mn:0000270C                 cmp     [ebp+var_8], 41Ch
.text$mn:00002713                 jz      short loc_272B
.text$mn:00002715                 cmp     [ebp+var_8], 41Dh
.text$mn:0000271C                 jz      short loc_2722
.text$mn:0000271E                 jmp     short loc_274A
.text$mn:00002720 ; ---------------------------------------------------------------------------
.text$mn:00002720                 jmp     short loc_274A
.text$mn:00002722 ; ---------------------------------------------------------------------------
.text$mn:00002722
.text$mn:00002722 loc_2722:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+48j
.text$mn:00002722                 mov     edx, [ebp+this]
.text$mn:00002725                 mov     byte ptr [edx+28h], 1
.text$mn:00002729                 jmp     short loc_274A
.text$mn:0000272B ; ---------------------------------------------------------------------------
.text$mn:0000272B
.text$mn:0000272B loc_272B:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+3Fj
.text$mn:0000272B                 mov     eax, [ebp+var_4]
.text$mn:0000272E                 mov     ecx, [eax+8]
.text$mn:00002731                 shr     ecx, 10h
.text$mn:00002734                 and     ecx, 0FFFFh
.text$mn:0000273A                 movzx   edx, cx
.text$mn:0000273D                 mov     eax, [ebp+this]
.text$mn:00002740                 mov     [eax+2Ch], edx
.text$mn:00002743                 mov     ecx, [ebp+this]
.text$mn:00002746                 mov     byte ptr [ecx+28h], 0
.text$mn:0000274A
.text$mn:0000274A loc_274A:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+12j
.text$mn:0000274A                                         ; DockingDlgInterface::run_dlgProc(uint,uint,long)+25j ...
.text$mn:0000274A                 xor     eax, eax
.text$mn:0000274C                 mov     esp, ebp
.text$mn:0000274E                 pop     ebp
.text$mn:0000274F                 retn    10h
.text$mn:0000274F ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z endp
.text$mn:0000274F
.text$mn:0000274F ; ---------------------------------------------------------------------------
.text$mn:00002752                 align 4
.text$mn:00002752 _text$mn        ends
.text$mn:00002752
.text$mn:00002754 ; ===========================================================================
.text$mn:00002754
.text$mn:00002754 ; Segment type: Pure code
.text$mn:00002754 ; Segment permissions: Read/Execute
.text$mn:00002754 _text$mn        segment para public 'CODE' use32
.text$mn:00002754                 assume cs:_text$mn
.text$mn:00002754                 ;org 2754h
.text$mn:00002754 ; COMDAT (pick any)
.text$mn:00002754                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002754
.text$mn:00002754 ; =============== S U B R O U T I N E =======================================
.text$mn:00002754
.text$mn:00002754 ; Attributes: bp-based frame
.text$mn:00002754
.text$mn:00002754 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002754                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002754 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002754                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002754                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002754
.text$mn:00002754 var_4           = dword ptr -4
.text$mn:00002754
.text$mn:00002754                 push    ebp
.text$mn:00002755                 mov     ebp, esp
.text$mn:00002757                 push    ecx
.text$mn:00002758                 mov     [ebp+var_4], ecx
.text$mn:0000275B                 mov     eax, [ebp+var_4]
.text$mn:0000275E                 mov     eax, [eax+14h]
.text$mn:00002761                 mov     esp, ebp
.text$mn:00002763                 pop     ebp
.text$mn:00002764                 retn
.text$mn:00002764 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002764
.text$mn:00002764 ; ---------------------------------------------------------------------------
.text$mn:00002765                 align 4
.text$mn:00002765 _text$mn        ends
.text$mn:00002765
.text$mn:00002768 ; ===========================================================================
.text$mn:00002768
.text$mn:00002768 ; Segment type: Pure code
.text$mn:00002768 ; Segment permissions: Read/Execute
.text$mn:00002768 _text$mn        segment para public 'CODE' use32
.text$mn:00002768                 assume cs:_text$mn
.text$mn:00002768                 ;org 2768h
.text$mn:00002768 ; COMDAT (pick any)
.text$mn:00002768                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002768
.text$mn:00002768 ; =============== S U B R O U T I N E =======================================
.text$mn:00002768
.text$mn:00002768 ; Attributes: bp-based frame
.text$mn:00002768
.text$mn:00002768 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002768                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002768 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002768                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2134p
.text$mn:00002768                 push    ebp
.text$mn:00002769                 mov     ebp, esp
.text$mn:0000276B                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002770                 pop     ebp
.text$mn:00002771                 retn
.text$mn:00002771 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002771
.text$mn:00002771 ; ---------------------------------------------------------------------------
.text$mn:00002772                 align 4
.text$mn:00002772 _text$mn        ends
.text$mn:00002772
.text$mn:00002774 ; ===========================================================================
.text$mn:00002774
.text$mn:00002774 ; Segment type: Pure code
.text$mn:00002774 ; Segment permissions: Read/Execute
.text$mn:00002774 _text$mn        segment para public 'CODE' use32
.text$mn:00002774                 assume cs:_text$mn
.text$mn:00002774                 ;org 2774h
.text$mn:00002774 ; COMDAT (pick any)
.text$mn:00002774                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002774
.text$mn:00002774 ; =============== S U B R O U T I N E =======================================
.text$mn:00002774
.text$mn:00002774 ; Attributes: bp-based frame
.text$mn:00002774
.text$mn:00002774 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002774                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002774 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002774
.text$mn:00002774 var_4           = dword ptr -4
.text$mn:00002774
.text$mn:00002774                 push    ebp
.text$mn:00002775                 mov     ebp, esp
.text$mn:00002777                 push    ecx
.text$mn:00002778                 mov     [ebp+var_4], ecx
.text$mn:0000277B                 mov     eax, [ebp+var_4]
.text$mn:0000277E                 mov     eax, [eax]
.text$mn:00002780                 mov     esp, ebp
.text$mn:00002782                 pop     ebp
.text$mn:00002783                 retn
.text$mn:00002783 ?value@error_code@std@@QBEHXZ endp
.text$mn:00002783
.text$mn:00002783 _text$mn        ends
.text$mn:00002783
.text$mn:00002784 ; ===========================================================================
.text$mn:00002784
.text$mn:00002784 ; Segment type: Pure code
.text$mn:00002784 ; Segment permissions: Read/Execute
.text$mn:00002784 _text$mn        segment para public 'CODE' use32
.text$mn:00002784                 assume cs:_text$mn
.text$mn:00002784                 ;org 2784h
.text$mn:00002784 ; COMDAT (pick any)
.text$mn:00002784                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002784
.text$mn:00002784 ; =============== S U B R O U T I N E =======================================
.text$mn:00002784
.text$mn:00002784 ; Attributes: bp-based frame
.text$mn:00002784
.text$mn:00002784 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002784                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002784 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002784                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002784                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002784
.text$mn:00002784 var_4           = dword ptr -4
.text$mn:00002784
.text$mn:00002784                 push    ebp
.text$mn:00002785                 mov     ebp, esp
.text$mn:00002787                 push    ecx
.text$mn:00002788                 mov     [ebp+var_4], ecx
.text$mn:0000278B                 mov     eax, [ebp+var_4]
.text$mn:0000278E                 mov     eax, [eax]
.text$mn:00002790                 mov     esp, ebp
.text$mn:00002792                 pop     ebp
.text$mn:00002793                 retn
.text$mn:00002793 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002793
.text$mn:00002793 _text$mn        ends
.text$mn:00002793
.text$mn:00002794 ; ===========================================================================
.text$mn:00002794
.text$mn:00002794 ; Segment type: Pure code
.text$mn:00002794 ; Segment permissions: Read/Execute
.text$mn:00002794 _text$mn        segment para public 'CODE' use32
.text$mn:00002794                 assume cs:_text$mn
.text$mn:00002794                 ;org 2794h
.text$mn:00002794 ; COMDAT (pick any)
.text$mn:00002794                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002794
.text$mn:00002794 ; =============== S U B R O U T I N E =======================================
.text$mn:00002794
.text$mn:00002794 ; Attributes: bp-based frame
.text$mn:00002794
.text$mn:00002794                 public _hypot
.text$mn:00002794 _hypot          proc near
.text$mn:00002794
.text$mn:00002794 var_10          = qword ptr -10h
.text$mn:00002794 var_8           = qword ptr -8
.text$mn:00002794 arg_0           = qword ptr  8
.text$mn:00002794 arg_8           = qword ptr  10h
.text$mn:00002794
.text$mn:00002794                 push    ebp
.text$mn:00002795                 mov     ebp, esp
.text$mn:00002797                 sub     esp, 8
.text$mn:0000279A                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000279F                 movsd   [esp+8+var_8], xmm0
.text$mn:000027A4                 sub     esp, 8
.text$mn:000027A7                 movsd   xmm0, [ebp+arg_0]
.text$mn:000027AC                 movsd   [esp+10h+var_10], xmm0
.text$mn:000027B1                 call    __hypot
.text$mn:000027B6                 add     esp, 10h
.text$mn:000027B9                 pop     ebp
.text$mn:000027BA                 retn
.text$mn:000027BA _hypot          endp
.text$mn:000027BA
.text$mn:000027BA ; ---------------------------------------------------------------------------
.text$mn:000027BB                 align 4
.text$mn:000027BB _text$mn        ends
.text$mn:000027BB
.text$mn:000027BC ; ===========================================================================
.text$mn:000027BC
.text$mn:000027BC ; Segment type: Pure code
.text$mn:000027BC ; Segment permissions: Read/Execute
.text$mn:000027BC _text$mn        segment para public 'CODE' use32
.text$mn:000027BC                 assume cs:_text$mn
.text$mn:000027BC                 ;org 27BCh
.text$mn:000027BC ; COMDAT (pick any)
.text$mn:000027BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000027BC
.text$mn:000027BC ; =============== S U B R O U T I N E =======================================
.text$mn:000027BC
.text$mn:000027BC ; Attributes: bp-based frame
.text$mn:000027BC
.text$mn:000027BC ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:000027BC                 public _wmemcpy
.text$mn:000027BC _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:000027BC
.text$mn:000027BC Dst             = dword ptr  8
.text$mn:000027BC Src             = dword ptr  0Ch
.text$mn:000027BC arg_8           = dword ptr  10h
.text$mn:000027BC
.text$mn:000027BC                 push    ebp
.text$mn:000027BD                 mov     ebp, esp
.text$mn:000027BF                 mov     eax, [ebp+arg_8]
.text$mn:000027C2                 shl     eax, 1
.text$mn:000027C4                 push    eax             ; Size
.text$mn:000027C5                 mov     ecx, [ebp+Src]
.text$mn:000027C8                 push    ecx             ; Src
.text$mn:000027C9                 mov     edx, [ebp+Dst]
.text$mn:000027CC                 push    edx             ; Dst
.text$mn:000027CD                 call    _memcpy
.text$mn:000027D2                 add     esp, 0Ch
.text$mn:000027D5                 pop     ebp
.text$mn:000027D6                 retn
.text$mn:000027D6 _wmemcpy        endp
.text$mn:000027D6
.text$mn:000027D6 ; ---------------------------------------------------------------------------
.text$mn:000027D7                 align 4
.text$mn:000027D7 _text$mn        ends
.text$mn:000027D7
.xdata$x:000027D8 ; ===========================================================================
.xdata$x:000027D8
.xdata$x:000027D8 ; Segment type: Pure data
.xdata$x:000027D8 ; Segment permissions: Read
.xdata$x:000027D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000027D8                 assume cs:_xdata$x
.xdata$x:000027D8                 ;org 27D8h
.xdata$x:000027D8 ; COMDAT (pick associative to section at 1BA0)
.xdata$x:000027D8 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:000027D8                                         ; DATA XREF: .xdata$x:000027E8o
.xdata$x:000027D9                 db 0FFh
.xdata$x:000027DA                 db 0FFh
.xdata$x:000027DB                 db 0FFh
.xdata$x:000027DC                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:000027E0 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:000027E0                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:000027E1                 db    5
.xdata$x:000027E2                 db  93h ; ô
.xdata$x:000027E3                 db  19h
.xdata$x:000027E4                 db    1
.xdata$x:000027E5                 db    0
.xdata$x:000027E6                 db    0
.xdata$x:000027E7                 db    0
.xdata$x:000027E8                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:000027EC                 db    0
.xdata$x:000027ED                 db    0
.xdata$x:000027EE                 db    0
.xdata$x:000027EF                 db    0
.xdata$x:000027F0                 db    0
.xdata$x:000027F1                 db    0
.xdata$x:000027F2                 db    0
.xdata$x:000027F3                 db    0
.xdata$x:000027F4                 db    0
.xdata$x:000027F5                 db    0
.xdata$x:000027F6                 db    0
.xdata$x:000027F7                 db    0
.xdata$x:000027F8                 db    0
.xdata$x:000027F9                 db    0
.xdata$x:000027FA                 db    0
.xdata$x:000027FB                 db    0
.xdata$x:000027FC                 db    0
.xdata$x:000027FD                 db    0
.xdata$x:000027FE                 db    0
.xdata$x:000027FF                 db    0
.xdata$x:00002800                 db    0
.xdata$x:00002801                 db    0
.xdata$x:00002802                 db    0
.xdata$x:00002803                 db    0
.xdata$x:00002803 _xdata$x        ends
.xdata$x:00002803
.xdata$x:00002804 ; ===========================================================================
.xdata$x:00002804
.xdata$x:00002804 ; Segment type: Pure data
.xdata$x:00002804 ; Segment permissions: Read
.xdata$x:00002804 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002804                 assume cs:_xdata$x
.xdata$x:00002804                 ;org 2804h
.xdata$x:00002804 ; COMDAT (pick associative to section at CAC)
.xdata$x:00002804 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002804                                         ; DATA XREF: .xdata$x:00002814o
.xdata$x:00002805                 db 0FFh
.xdata$x:00002806                 db 0FFh
.xdata$x:00002807                 db 0FFh
.xdata$x:00002808                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000280C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000280C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000280D                 db    5
.xdata$x:0000280E                 db  93h ; ô
.xdata$x:0000280F                 db  19h
.xdata$x:00002810                 db    1
.xdata$x:00002811                 db    0
.xdata$x:00002812                 db    0
.xdata$x:00002813                 db    0
.xdata$x:00002814                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002818                 db    0
.xdata$x:00002819                 db    0
.xdata$x:0000281A                 db    0
.xdata$x:0000281B                 db    0
.xdata$x:0000281C                 db    0
.xdata$x:0000281D                 db    0
.xdata$x:0000281E                 db    0
.xdata$x:0000281F                 db    0
.xdata$x:00002820                 db    0
.xdata$x:00002821                 db    0
.xdata$x:00002822                 db    0
.xdata$x:00002823                 db    0
.xdata$x:00002824                 db    0
.xdata$x:00002825                 db    0
.xdata$x:00002826                 db    0
.xdata$x:00002827                 db    0
.xdata$x:00002828                 db    0
.xdata$x:00002829                 db    0
.xdata$x:0000282A                 db    0
.xdata$x:0000282B                 db    0
.xdata$x:0000282C                 db    0
.xdata$x:0000282D                 db    0
.xdata$x:0000282E                 db    0
.xdata$x:0000282F                 db    0
.xdata$x:0000282F _xdata$x        ends
.xdata$x:0000282F
.xdata$x:00002830 ; ===========================================================================
.xdata$x:00002830
.xdata$x:00002830 ; Segment type: Pure data
.xdata$x:00002830 ; Segment permissions: Read
.xdata$x:00002830 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002830                 assume cs:_xdata$x
.xdata$x:00002830                 ;org 2830h
.xdata$x:00002830 ; COMDAT (pick associative to section at 1120)
.xdata$x:00002830 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002830                                         ; DATA XREF: .xdata$x:00002840o
.xdata$x:00002831                 db 0FFh
.xdata$x:00002832                 db 0FFh
.xdata$x:00002833                 db 0FFh
.xdata$x:00002834                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002838 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002838                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002839                 db    5
.xdata$x:0000283A                 db  93h ; ô
.xdata$x:0000283B                 db  19h
.xdata$x:0000283C                 db    1
.xdata$x:0000283D                 db    0
.xdata$x:0000283E                 db    0
.xdata$x:0000283F                 db    0
.xdata$x:00002840                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002844                 db    0
.xdata$x:00002845                 db    0
.xdata$x:00002846                 db    0
.xdata$x:00002847                 db    0
.xdata$x:00002848                 db    0
.xdata$x:00002849                 db    0
.xdata$x:0000284A                 db    0
.xdata$x:0000284B                 db    0
.xdata$x:0000284C                 db    0
.xdata$x:0000284D                 db    0
.xdata$x:0000284E                 db    0
.xdata$x:0000284F                 db    0
.xdata$x:00002850                 db    0
.xdata$x:00002851                 db    0
.xdata$x:00002852                 db    0
.xdata$x:00002853                 db    0
.xdata$x:00002854                 db    0
.xdata$x:00002855                 db    0
.xdata$x:00002856                 db    0
.xdata$x:00002857                 db    0
.xdata$x:00002858                 db    0
.xdata$x:00002859                 db    0
.xdata$x:0000285A                 db    0
.xdata$x:0000285B                 db    0
.xdata$x:0000285B _xdata$x        ends
.xdata$x:0000285B
.xdata$x:0000285C ; ===========================================================================
.xdata$x:0000285C
.xdata$x:0000285C ; Segment type: Pure data
.xdata$x:0000285C ; Segment permissions: Read
.xdata$x:0000285C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000285C                 assume cs:_xdata$x
.xdata$x:0000285C                 ;org 285Ch
.xdata$x:0000285C ; COMDAT (pick associative to section at C30)
.xdata$x:0000285C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000285C                                         ; DATA XREF: .xdata$x:0000286Co
.xdata$x:0000285D                 db 0FFh
.xdata$x:0000285E                 db 0FFh
.xdata$x:0000285F                 db 0FFh
.xdata$x:00002860                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002864 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002864                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002865                 db    5
.xdata$x:00002866                 db  93h ; ô
.xdata$x:00002867                 db  19h
.xdata$x:00002868                 db    1
.xdata$x:00002869                 db    0
.xdata$x:0000286A                 db    0
.xdata$x:0000286B                 db    0
.xdata$x:0000286C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002870                 db    0
.xdata$x:00002871                 db    0
.xdata$x:00002872                 db    0
.xdata$x:00002873                 db    0
.xdata$x:00002874                 db    0
.xdata$x:00002875                 db    0
.xdata$x:00002876                 db    0
.xdata$x:00002877                 db    0
.xdata$x:00002878                 db    0
.xdata$x:00002879                 db    0
.xdata$x:0000287A                 db    0
.xdata$x:0000287B                 db    0
.xdata$x:0000287C                 db    0
.xdata$x:0000287D                 db    0
.xdata$x:0000287E                 db    0
.xdata$x:0000287F                 db    0
.xdata$x:00002880                 db    0
.xdata$x:00002881                 db    0
.xdata$x:00002882                 db    0
.xdata$x:00002883                 db    0
.xdata$x:00002884                 db    0
.xdata$x:00002885                 db    0
.xdata$x:00002886                 db    0
.xdata$x:00002887                 db    0
.xdata$x:00002887 _xdata$x        ends
.xdata$x:00002887
.xdata$x:00002888 ; ===========================================================================
.xdata$x:00002888
.xdata$x:00002888 ; Segment type: Pure data
.xdata$x:00002888 ; Segment permissions: Read
.xdata$x:00002888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002888                 assume cs:_xdata$x
.xdata$x:00002888                 ;org 2888h
.xdata$x:00002888 ; COMDAT (pick associative to section at 1030)
.xdata$x:00002888 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002888                                         ; DATA XREF: .xdata$x:00002898o
.xdata$x:00002889                 db 0FFh
.xdata$x:0000288A                 db 0FFh
.xdata$x:0000288B                 db 0FFh
.xdata$x:0000288C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002890 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002890                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002891                 db    5
.xdata$x:00002892                 db  93h ; ô
.xdata$x:00002893                 db  19h
.xdata$x:00002894                 db    1
.xdata$x:00002895                 db    0
.xdata$x:00002896                 db    0
.xdata$x:00002897                 db    0
.xdata$x:00002898                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000289C                 db    0
.xdata$x:0000289D                 db    0
.xdata$x:0000289E                 db    0
.xdata$x:0000289F                 db    0
.xdata$x:000028A0                 db    0
.xdata$x:000028A1                 db    0
.xdata$x:000028A2                 db    0
.xdata$x:000028A3                 db    0
.xdata$x:000028A4                 db    0
.xdata$x:000028A5                 db    0
.xdata$x:000028A6                 db    0
.xdata$x:000028A7                 db    0
.xdata$x:000028A8                 db    0
.xdata$x:000028A9                 db    0
.xdata$x:000028AA                 db    0
.xdata$x:000028AB                 db    0
.xdata$x:000028AC                 db    0
.xdata$x:000028AD                 db    0
.xdata$x:000028AE                 db    0
.xdata$x:000028AF                 db    0
.xdata$x:000028B0                 db    0
.xdata$x:000028B1                 db    0
.xdata$x:000028B2                 db    0
.xdata$x:000028B3                 db    0
.xdata$x:000028B3 _xdata$x        ends
.xdata$x:000028B3
.xdata$x:000028B4 ; ===========================================================================
.xdata$x:000028B4
.xdata$x:000028B4 ; Segment type: Pure data
.xdata$x:000028B4 ; Segment permissions: Read
.xdata$x:000028B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028B4                 assume cs:_xdata$x
.xdata$x:000028B4                 ;org 28B4h
.xdata$x:000028B4 ; COMDAT (pick associative to section at D94)
.xdata$x:000028B4 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000028B4                                         ; DATA XREF: .xdata$x:000028C4o
.xdata$x:000028B5                 db 0FFh
.xdata$x:000028B6                 db 0FFh
.xdata$x:000028B7                 db 0FFh
.xdata$x:000028B8                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000028BC __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000028BC                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000028BD                 db    5
.xdata$x:000028BE                 db  93h ; ô
.xdata$x:000028BF                 db  19h
.xdata$x:000028C0                 db    1
.xdata$x:000028C1                 db    0
.xdata$x:000028C2                 db    0
.xdata$x:000028C3                 db    0
.xdata$x:000028C4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000028C8                 align 20h
.xdata$x:000028C8 _xdata$x        ends
.xdata$x:000028C8
.xdata$x:000028E0 ; ===========================================================================
.xdata$x:000028E0
.xdata$x:000028E0 ; Segment type: Pure data
.xdata$x:000028E0 ; Segment permissions: Read
.xdata$x:000028E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000028E0                 assume cs:_xdata$x
.xdata$x:000028E0                 ;org 28E0h
.xdata$x:000028E0 ; COMDAT (pick associative to section at 1200)
.xdata$x:000028E0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000028E0                                         ; DATA XREF: .xdata$x:000028F0o
.xdata$x:000028E1                 db 0FFh
.xdata$x:000028E2                 db 0FFh
.xdata$x:000028E3                 db 0FFh
.xdata$x:000028E4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000028E8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000028E8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000028E9                 db    5
.xdata$x:000028EA                 db  93h ; ô
.xdata$x:000028EB                 db  19h
.xdata$x:000028EC                 db    1
.xdata$x:000028ED                 db    0
.xdata$x:000028EE                 db    0
.xdata$x:000028EF                 db    0
.xdata$x:000028F0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000028F4                 db    0
.xdata$x:000028F5                 db    0
.xdata$x:000028F6                 db    0
.xdata$x:000028F7                 db    0
.xdata$x:000028F8                 db    0
.xdata$x:000028F9                 db    0
.xdata$x:000028FA                 db    0
.xdata$x:000028FB                 db    0
.xdata$x:000028FC                 db    0
.xdata$x:000028FD                 db    0
.xdata$x:000028FE                 db    0
.xdata$x:000028FF                 db    0
.xdata$x:00002900                 db    0
.xdata$x:00002901                 db    0
.xdata$x:00002902                 db    0
.xdata$x:00002903                 db    0
.xdata$x:00002904                 db    0
.xdata$x:00002905                 db    0
.xdata$x:00002906                 db    0
.xdata$x:00002907                 db    0
.xdata$x:00002908                 db    0
.xdata$x:00002909                 db    0
.xdata$x:0000290A                 db    0
.xdata$x:0000290B                 db    0
.xdata$x:0000290B _xdata$x        ends
.xdata$x:0000290B
.xdata$x:0000290C ; ===========================================================================
.xdata$x:0000290C
.xdata$x:0000290C ; Segment type: Pure data
.xdata$x:0000290C ; Segment permissions: Read
.xdata$x:0000290C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000290C                 assume cs:_xdata$x
.xdata$x:0000290C                 ;org 290Ch
.xdata$x:0000290C ; COMDAT (pick associative to section at 16F4)
.xdata$x:0000290C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000290C                                         ; DATA XREF: .xdata$x:00002994o
.xdata$x:0000290D                 db    0
.xdata$x:0000290E                 db    0
.xdata$x:0000290F                 db    0
.xdata$x:00002910                 db    0
.xdata$x:00002911                 db    0
.xdata$x:00002912                 db    0
.xdata$x:00002913                 db    0
.xdata$x:00002914                 db    0
.xdata$x:00002915                 db    0
.xdata$x:00002916                 db    0
.xdata$x:00002917                 db    0
.xdata$x:00002918                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000291C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000291C                                         ; DATA XREF: .xdata$x:00002980o
.xdata$x:0000291D                 db    0
.xdata$x:0000291E                 db    0
.xdata$x:0000291F                 db    0
.xdata$x:00002920                 db    0
.xdata$x:00002921                 db    0
.xdata$x:00002922                 db    0
.xdata$x:00002923                 db    0
.xdata$x:00002924                 db    0
.xdata$x:00002925                 db    0
.xdata$x:00002926                 db    0
.xdata$x:00002927                 db    0
.xdata$x:00002928                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000292C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000292C                                         ; DATA XREF: .xdata$x:00002954o
.xdata$x:0000292D                 db 0FFh
.xdata$x:0000292E                 db 0FFh
.xdata$x:0000292F                 db 0FFh
.xdata$x:00002930                 db    0
.xdata$x:00002931                 db    0
.xdata$x:00002932                 db    0
.xdata$x:00002933                 db    0
.xdata$x:00002934                 db 0FFh
.xdata$x:00002935                 db 0FFh
.xdata$x:00002936                 db 0FFh
.xdata$x:00002937                 db 0FFh
.xdata$x:00002938                 db    0
.xdata$x:00002939                 db    0
.xdata$x:0000293A                 db    0
.xdata$x:0000293B                 db    0
.xdata$x:0000293C                 db    1
.xdata$x:0000293D                 db    0
.xdata$x:0000293E                 db    0
.xdata$x:0000293F                 db    0
.xdata$x:00002940                 db    0
.xdata$x:00002941                 db    0
.xdata$x:00002942                 db    0
.xdata$x:00002943                 db    0
.xdata$x:00002944                 db    1
.xdata$x:00002945                 db    0
.xdata$x:00002946                 db    0
.xdata$x:00002947                 db    0
.xdata$x:00002948                 db    0
.xdata$x:00002949                 db    0
.xdata$x:0000294A                 db    0
.xdata$x:0000294B                 db    0
.xdata$x:0000294C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000294C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000294D                 db    5
.xdata$x:0000294E                 db  93h ; ô
.xdata$x:0000294F                 db  19h
.xdata$x:00002950                 db    4
.xdata$x:00002951                 db    0
.xdata$x:00002952                 db    0
.xdata$x:00002953                 db    0
.xdata$x:00002954                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002958                 db    2
.xdata$x:00002959                 db    0
.xdata$x:0000295A                 db    0
.xdata$x:0000295B                 db    0
.xdata$x:0000295C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002960                 db    0
.xdata$x:00002961                 db    0
.xdata$x:00002962                 db    0
.xdata$x:00002963                 db    0
.xdata$x:00002964                 db    0
.xdata$x:00002965                 db    0
.xdata$x:00002966                 db    0
.xdata$x:00002967                 db    0
.xdata$x:00002968                 db    0
.xdata$x:00002969                 db    0
.xdata$x:0000296A                 db    0
.xdata$x:0000296B                 db    0
.xdata$x:0000296C                 db    0
.xdata$x:0000296D                 db    0
.xdata$x:0000296E                 db    0
.xdata$x:0000296F                 db    0
.xdata$x:00002970 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002970                                         ; DATA XREF: .xdata$x:0000295Co
.xdata$x:00002971                 db    0
.xdata$x:00002972                 db    0
.xdata$x:00002973                 db    0
.xdata$x:00002974                 db    2
.xdata$x:00002975                 db    0
.xdata$x:00002976                 db    0
.xdata$x:00002977                 db    0
.xdata$x:00002978                 db    3
.xdata$x:00002979                 db    0
.xdata$x:0000297A                 db    0
.xdata$x:0000297B                 db    0
.xdata$x:0000297C                 db    1
.xdata$x:0000297D                 db    0
.xdata$x:0000297E                 db    0
.xdata$x:0000297F                 db    0
.xdata$x:00002980                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002984                 db    0
.xdata$x:00002985                 db    0
.xdata$x:00002986                 db    0
.xdata$x:00002987                 db    0
.xdata$x:00002988                 db    0
.xdata$x:00002989                 db    0
.xdata$x:0000298A                 db    0
.xdata$x:0000298B                 db    0
.xdata$x:0000298C                 db    3
.xdata$x:0000298D                 db    0
.xdata$x:0000298E                 db    0
.xdata$x:0000298F                 db    0
.xdata$x:00002990                 db    1
.xdata$x:00002991                 db    0
.xdata$x:00002992                 db    0
.xdata$x:00002993                 db    0
.xdata$x:00002994                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002994 _xdata$x        ends
.xdata$x:00002994
.xdata$x:00002998 ; ===========================================================================
.xdata$x:00002998
.xdata$x:00002998 ; Segment type: Pure data
.xdata$x:00002998 ; Segment permissions: Read
.xdata$x:00002998 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002998                 assume cs:_xdata$x
.xdata$x:00002998                 ;org 2998h
.xdata$x:00002998 ; COMDAT (pick associative to section at E68)
.xdata$x:00002998 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002998                                         ; DATA XREF: .xdata$x:000029A8o
.xdata$x:00002999                 db 0FFh
.xdata$x:0000299A                 db 0FFh
.xdata$x:0000299B                 db 0FFh
.xdata$x:0000299C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000029A0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000029A0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000029A1                 db    5
.xdata$x:000029A2                 db  93h ; ô
.xdata$x:000029A3                 db  19h
.xdata$x:000029A4                 db    1
.xdata$x:000029A5                 db    0
.xdata$x:000029A6                 db    0
.xdata$x:000029A7                 db    0
.xdata$x:000029A8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000029AC                 db    0
.xdata$x:000029AD                 db    0
.xdata$x:000029AE                 db    0
.xdata$x:000029AF                 db    0
.xdata$x:000029B0                 db    0
.xdata$x:000029B1                 db    0
.xdata$x:000029B2                 db    0
.xdata$x:000029B3                 db    0
.xdata$x:000029B4                 db    0
.xdata$x:000029B5                 db    0
.xdata$x:000029B6                 db    0
.xdata$x:000029B7                 db    0
.xdata$x:000029B8                 db    0
.xdata$x:000029B9                 db    0
.xdata$x:000029BA                 db    0
.xdata$x:000029BB                 db    0
.xdata$x:000029BC                 db    0
.xdata$x:000029BD                 db    0
.xdata$x:000029BE                 db    0
.xdata$x:000029BF                 db    0
.xdata$x:000029C0                 db    0
.xdata$x:000029C1                 db    0
.xdata$x:000029C2                 db    0
.xdata$x:000029C3                 db    0
.xdata$x:000029C3 _xdata$x        ends
.xdata$x:000029C3
.xdata$x:000029C4 ; ===========================================================================
.xdata$x:000029C4
.xdata$x:000029C4 ; Segment type: Pure data
.xdata$x:000029C4 ; Segment permissions: Read
.xdata$x:000029C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029C4                 assume cs:_xdata$x
.xdata$x:000029C4                 ;org 29C4h
.xdata$x:000029C4 ; COMDAT (pick associative to section at 2404)
.xdata$x:000029C4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000029C4                                         ; DATA XREF: .xdata$x:000029D4o
.xdata$x:000029C5                 db 0FFh
.xdata$x:000029C6                 db 0FFh
.xdata$x:000029C7                 db 0FFh
.xdata$x:000029C8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000029CC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000029CC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000029CD                 db    5
.xdata$x:000029CE                 db  93h ; ô
.xdata$x:000029CF                 db  19h
.xdata$x:000029D0                 db    1
.xdata$x:000029D1                 db    0
.xdata$x:000029D2                 db    0
.xdata$x:000029D3                 db    0
.xdata$x:000029D4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000029D8                 db    0
.xdata$x:000029D9                 db    0
.xdata$x:000029DA                 db    0
.xdata$x:000029DB                 db    0
.xdata$x:000029DC                 db    0
.xdata$x:000029DD                 db    0
.xdata$x:000029DE                 db    0
.xdata$x:000029DF                 db    0
.xdata$x:000029E0                 db    0
.xdata$x:000029E1                 db    0
.xdata$x:000029E2                 db    0
.xdata$x:000029E3                 db    0
.xdata$x:000029E4                 db    0
.xdata$x:000029E5                 db    0
.xdata$x:000029E6                 db    0
.xdata$x:000029E7                 db    0
.xdata$x:000029E8                 db    0
.xdata$x:000029E9                 db    0
.xdata$x:000029EA                 db    0
.xdata$x:000029EB                 db    0
.xdata$x:000029EC                 db    0
.xdata$x:000029ED                 db    0
.xdata$x:000029EE                 db    0
.xdata$x:000029EF                 db    0
.xdata$x:000029EF _xdata$x        ends
.xdata$x:000029EF
.xdata$x:000029F0 ; ===========================================================================
.xdata$x:000029F0
.xdata$x:000029F0 ; Segment type: Pure data
.xdata$x:000029F0 ; Segment permissions: Read
.xdata$x:000029F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029F0                 assume cs:_xdata$x
.xdata$x:000029F0                 ;org 29F0h
.xdata$x:000029F0 ; COMDAT (pick associative to section at 130C)
.xdata$x:000029F0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000029F0                                         ; DATA XREF: .xdata$x:00002A00o
.xdata$x:000029F1                 db 0FFh
.xdata$x:000029F2                 db 0FFh
.xdata$x:000029F3                 db 0FFh
.xdata$x:000029F4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:000029F8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000029F8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:000029F9                 db    5
.xdata$x:000029FA                 db  93h ; ô
.xdata$x:000029FB                 db  19h
.xdata$x:000029FC                 db    1
.xdata$x:000029FD                 db    0
.xdata$x:000029FE                 db    0
.xdata$x:000029FF                 db    0
.xdata$x:00002A00                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002A04                 db    0
.xdata$x:00002A05                 db    0
.xdata$x:00002A06                 db    0
.xdata$x:00002A07                 db    0
.xdata$x:00002A08                 db    0
.xdata$x:00002A09                 db    0
.xdata$x:00002A0A                 db    0
.xdata$x:00002A0B                 db    0
.xdata$x:00002A0C                 db    0
.xdata$x:00002A0D                 db    0
.xdata$x:00002A0E                 db    0
.xdata$x:00002A0F                 db    0
.xdata$x:00002A10                 db    0
.xdata$x:00002A11                 db    0
.xdata$x:00002A12                 db    0
.xdata$x:00002A13                 db    0
.xdata$x:00002A14                 db    0
.xdata$x:00002A15                 db    0
.xdata$x:00002A16                 db    0
.xdata$x:00002A17                 db    0
.xdata$x:00002A18                 db    0
.xdata$x:00002A19                 db    0
.xdata$x:00002A1A                 db    0
.xdata$x:00002A1B                 db    0
.xdata$x:00002A1B _xdata$x        ends
.xdata$x:00002A1B
.xdata$x:00002A1C ; ===========================================================================
.xdata$x:00002A1C
.xdata$x:00002A1C ; Segment type: Pure data
.xdata$x:00002A1C ; Segment permissions: Read
.xdata$x:00002A1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A1C                 assume cs:_xdata$x
.xdata$x:00002A1C                 ;org 2A1Ch
.xdata$x:00002A1C ; COMDAT (pick associative to section at EE4)
.xdata$x:00002A1C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002A1C                                         ; DATA XREF: .xdata$x:00002A2Co
.xdata$x:00002A1D                 db 0FFh
.xdata$x:00002A1E                 db 0FFh
.xdata$x:00002A1F                 db 0FFh
.xdata$x:00002A20                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002A24 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002A24                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002A25                 db    5
.xdata$x:00002A26                 db  93h ; ô
.xdata$x:00002A27                 db  19h
.xdata$x:00002A28                 db    1
.xdata$x:00002A29                 db    0
.xdata$x:00002A2A                 db    0
.xdata$x:00002A2B                 db    0
.xdata$x:00002A2C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002A30                 db    0
.xdata$x:00002A31                 db    0
.xdata$x:00002A32                 db    0
.xdata$x:00002A33                 db    0
.xdata$x:00002A34                 db    0
.xdata$x:00002A35                 db    0
.xdata$x:00002A36                 db    0
.xdata$x:00002A37                 db    0
.xdata$x:00002A38                 db    0
.xdata$x:00002A39                 db    0
.xdata$x:00002A3A                 db    0
.xdata$x:00002A3B                 db    0
.xdata$x:00002A3C                 db    0
.xdata$x:00002A3D                 db    0
.xdata$x:00002A3E                 db    0
.xdata$x:00002A3F                 db    0
.xdata$x:00002A40                 db    0
.xdata$x:00002A41                 db    0
.xdata$x:00002A42                 db    0
.xdata$x:00002A43                 db    0
.xdata$x:00002A44                 db    0
.xdata$x:00002A45                 db    0
.xdata$x:00002A46                 db    0
.xdata$x:00002A47                 db    0
.xdata$x:00002A47 _xdata$x        ends
.xdata$x:00002A47
.xdata$x:00002A48 ; ===========================================================================
.xdata$x:00002A48
.xdata$x:00002A48 ; Segment type: Pure data
.xdata$x:00002A48 ; Segment permissions: Read
.xdata$x:00002A48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A48                 assume cs:_xdata$x
.xdata$x:00002A48                 ;org 2A48h
.xdata$x:00002A48 ; COMDAT (pick associative to section at 24BC)
.xdata$x:00002A48 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002A48                                         ; DATA XREF: .xdata$x:00002A58o
.xdata$x:00002A49                 db 0FFh
.xdata$x:00002A4A                 db 0FFh
.xdata$x:00002A4B                 db 0FFh
.xdata$x:00002A4C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002A50 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002A50                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002A51                 db    5
.xdata$x:00002A52                 db  93h ; ô
.xdata$x:00002A53                 db  19h
.xdata$x:00002A54                 db    1
.xdata$x:00002A55                 db    0
.xdata$x:00002A56                 db    0
.xdata$x:00002A57                 db    0
.xdata$x:00002A58                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002A5C                 db    0
.xdata$x:00002A5D                 db    0
.xdata$x:00002A5E                 db    0
.xdata$x:00002A5F                 db    0
.xdata$x:00002A60                 db    0
.xdata$x:00002A61                 db    0
.xdata$x:00002A62                 db    0
.xdata$x:00002A63                 db    0
.xdata$x:00002A64                 db    0
.xdata$x:00002A65                 db    0
.xdata$x:00002A66                 db    0
.xdata$x:00002A67                 db    0
.xdata$x:00002A68                 db    0
.xdata$x:00002A69                 db    0
.xdata$x:00002A6A                 db    0
.xdata$x:00002A6B                 db    0
.xdata$x:00002A6C                 db    0
.xdata$x:00002A6D                 db    0
.xdata$x:00002A6E                 db    0
.xdata$x:00002A6F                 db    0
.xdata$x:00002A70                 db    0
.xdata$x:00002A71                 db    0
.xdata$x:00002A72                 db    0
.xdata$x:00002A73                 db    0
.xdata$x:00002A73 _xdata$x        ends
.xdata$x:00002A73
.xdata$x:00002A74 ; ===========================================================================
.xdata$x:00002A74
.xdata$x:00002A74 ; Segment type: Pure data
.xdata$x:00002A74 ; Segment permissions: Read
.xdata$x:00002A74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A74                 assume cs:_xdata$x
.xdata$x:00002A74                 ;org 2A74h
.xdata$x:00002A74 ; COMDAT (pick associative to section at 137C)
.xdata$x:00002A74 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002A74                                         ; DATA XREF: .xdata$x:00002A84o
.xdata$x:00002A75                 db 0FFh
.xdata$x:00002A76                 db 0FFh
.xdata$x:00002A77                 db 0FFh
.xdata$x:00002A78                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002A7C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002A7C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002A7D                 db    5
.xdata$x:00002A7E                 db  93h ; ô
.xdata$x:00002A7F                 db  19h
.xdata$x:00002A80                 db    1
.xdata$x:00002A81                 db    0
.xdata$x:00002A82                 db    0
.xdata$x:00002A83                 db    0
.xdata$x:00002A84                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002A88                 align 20h
.xdata$x:00002A88 _xdata$x        ends
.xdata$x:00002A88
.xdata$x:00002AA0 ; ===========================================================================
.xdata$x:00002AA0
.xdata$x:00002AA0 ; Segment type: Pure data
.xdata$x:00002AA0 ; Segment permissions: Read
.xdata$x:00002AA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AA0                 assume cs:_xdata$x
.xdata$x:00002AA0                 ;org 2AA0h
.xdata$x:00002AA0 ; COMDAT (pick associative to section at F60)
.xdata$x:00002AA0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002AA0                                         ; DATA XREF: .xdata$x:00002AB0o
.xdata$x:00002AA1                 db 0FFh
.xdata$x:00002AA2                 db 0FFh
.xdata$x:00002AA3                 db 0FFh
.xdata$x:00002AA4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002AA8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002AA8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002AA9                 db    5
.xdata$x:00002AAA                 db  93h ; ô
.xdata$x:00002AAB                 db  19h
.xdata$x:00002AAC                 db    1
.xdata$x:00002AAD                 db    0
.xdata$x:00002AAE                 db    0
.xdata$x:00002AAF                 db    0
.xdata$x:00002AB0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002AB4                 db    0
.xdata$x:00002AB5                 db    0
.xdata$x:00002AB6                 db    0
.xdata$x:00002AB7                 db    0
.xdata$x:00002AB8                 db    0
.xdata$x:00002AB9                 db    0
.xdata$x:00002ABA                 db    0
.xdata$x:00002ABB                 db    0
.xdata$x:00002ABC                 db    0
.xdata$x:00002ABD                 db    0
.xdata$x:00002ABE                 db    0
.xdata$x:00002ABF                 db    0
.xdata$x:00002AC0                 db    0
.xdata$x:00002AC1                 db    0
.xdata$x:00002AC2                 db    0
.xdata$x:00002AC3                 db    0
.xdata$x:00002AC4                 db    0
.xdata$x:00002AC5                 db    0
.xdata$x:00002AC6                 db    0
.xdata$x:00002AC7                 db    0
.xdata$x:00002AC8                 db    0
.xdata$x:00002AC9                 db    0
.xdata$x:00002ACA                 db    0
.xdata$x:00002ACB                 db    0
.xdata$x:00002ACB _xdata$x        ends
.xdata$x:00002ACB
.xdata$x:00002ACC ; ===========================================================================
.xdata$x:00002ACC
.xdata$x:00002ACC ; Segment type: Pure data
.xdata$x:00002ACC ; Segment permissions: Read
.xdata$x:00002ACC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002ACC                 assume cs:_xdata$x
.xdata$x:00002ACC                 ;org 2ACCh
.xdata$x:00002ACC ; COMDAT (pick associative to section at 2580)
.xdata$x:00002ACC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002ACC                                         ; DATA XREF: .xdata$x:00002ADCo
.xdata$x:00002ACD                 db 0FFh
.xdata$x:00002ACE                 db 0FFh
.xdata$x:00002ACF                 db 0FFh
.xdata$x:00002AD0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002AD4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002AD4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002AD5                 db    5
.xdata$x:00002AD6                 db  93h ; ô
.xdata$x:00002AD7                 db  19h
.xdata$x:00002AD8                 db    1
.xdata$x:00002AD9                 db    0
.xdata$x:00002ADA                 db    0
.xdata$x:00002ADB                 db    0
.xdata$x:00002ADC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002AE0                 db    0
.xdata$x:00002AE1                 db    0
.xdata$x:00002AE2                 db    0
.xdata$x:00002AE3                 db    0
.xdata$x:00002AE4                 db    0
.xdata$x:00002AE5                 db    0
.xdata$x:00002AE6                 db    0
.xdata$x:00002AE7                 db    0
.xdata$x:00002AE8                 db    0
.xdata$x:00002AE9                 db    0
.xdata$x:00002AEA                 db    0
.xdata$x:00002AEB                 db    0
.xdata$x:00002AEC                 db    0
.xdata$x:00002AED                 db    0
.xdata$x:00002AEE                 db    0
.xdata$x:00002AEF                 db    0
.xdata$x:00002AF0                 db    0
.xdata$x:00002AF1                 db    0
.xdata$x:00002AF2                 db    0
.xdata$x:00002AF3                 db    0
.xdata$x:00002AF4                 db    0
.xdata$x:00002AF5                 db    0
.xdata$x:00002AF6                 db    0
.xdata$x:00002AF7                 db    0
.xdata$x:00002AF7 _xdata$x        ends
.xdata$x:00002AF7
.xdata$x:00002AF8 ; ===========================================================================
.xdata$x:00002AF8
.xdata$x:00002AF8 ; Segment type: Pure data
.xdata$x:00002AF8 ; Segment permissions: Read
.xdata$x:00002AF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002AF8                 assume cs:_xdata$x
.xdata$x:00002AF8                 ;org 2AF8h
.xdata$x:00002AF8 ; COMDAT (pick associative to section at 13EC)
.xdata$x:00002AF8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002AF8                                         ; DATA XREF: .xdata$x:00002B08o
.xdata$x:00002AF9                 db 0FFh
.xdata$x:00002AFA                 db 0FFh
.xdata$x:00002AFB                 db 0FFh
.xdata$x:00002AFC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002B00 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002B00                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002B01                 db    5
.xdata$x:00002B02                 db  93h ; ô
.xdata$x:00002B03                 db  19h
.xdata$x:00002B04                 db    1
.xdata$x:00002B05                 db    0
.xdata$x:00002B06                 db    0
.xdata$x:00002B07                 db    0
.xdata$x:00002B08                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002B0C                 db    0
.xdata$x:00002B0D                 db    0
.xdata$x:00002B0E                 db    0
.xdata$x:00002B0F                 db    0
.xdata$x:00002B10                 db    0
.xdata$x:00002B11                 db    0
.xdata$x:00002B12                 db    0
.xdata$x:00002B13                 db    0
.xdata$x:00002B14                 db    0
.xdata$x:00002B15                 db    0
.xdata$x:00002B16                 db    0
.xdata$x:00002B17                 db    0
.xdata$x:00002B18                 db    0
.xdata$x:00002B19                 db    0
.xdata$x:00002B1A                 db    0
.xdata$x:00002B1B                 db    0
.xdata$x:00002B1C                 db    0
.xdata$x:00002B1D                 db    0
.xdata$x:00002B1E                 db    0
.xdata$x:00002B1F                 db    0
.xdata$x:00002B20                 db    0
.xdata$x:00002B21                 db    0
.xdata$x:00002B22                 db    0
.xdata$x:00002B23                 db    0
.xdata$x:00002B23 _xdata$x        ends
.xdata$x:00002B23
.xdata$x:00002B24 ; ===========================================================================
.xdata$x:00002B24
.xdata$x:00002B24 ; Segment type: Pure data
.xdata$x:00002B24 ; Segment permissions: Read
.xdata$x:00002B24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B24                 assume cs:_xdata$x
.xdata$x:00002B24                 ;org 2B24h
.xdata$x:00002B24 ; COMDAT (pick associative to section at 1190)
.xdata$x:00002B24 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002B24                                         ; DATA XREF: .xdata$x:00002B34o
.xdata$x:00002B25                 db 0FFh
.xdata$x:00002B26                 db 0FFh
.xdata$x:00002B27                 db 0FFh
.xdata$x:00002B28                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00002B2C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002B2C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00002B2D                 db    5
.xdata$x:00002B2E                 db  93h ; ô
.xdata$x:00002B2F                 db  19h
.xdata$x:00002B30                 db    1
.xdata$x:00002B31                 db    0
.xdata$x:00002B32                 db    0
.xdata$x:00002B33                 db    0
.xdata$x:00002B34                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00002B38                 db    0
.xdata$x:00002B39                 db    0
.xdata$x:00002B3A                 db    0
.xdata$x:00002B3B                 db    0
.xdata$x:00002B3C                 db    0
.xdata$x:00002B3D                 db    0
.xdata$x:00002B3E                 db    0
.xdata$x:00002B3F                 db    0
.xdata$x:00002B40                 db    0
.xdata$x:00002B41                 db    0
.xdata$x:00002B42                 db    0
.xdata$x:00002B43                 db    0
.xdata$x:00002B44                 db    0
.xdata$x:00002B45                 db    0
.xdata$x:00002B46                 db    0
.xdata$x:00002B47                 db    0
.xdata$x:00002B48                 db    0
.xdata$x:00002B49                 db    0
.xdata$x:00002B4A                 db    0
.xdata$x:00002B4B                 db    0
.xdata$x:00002B4C                 db    0
.xdata$x:00002B4D                 db    0
.xdata$x:00002B4E                 db    0
.xdata$x:00002B4F                 db    0
.xdata$x:00002B4F _xdata$x        ends
.xdata$x:00002B4F
.xdata$x:00002B50 ; ===========================================================================
.xdata$x:00002B50
.xdata$x:00002B50 ; Segment type: Pure data
.xdata$x:00002B50 ; Segment permissions: Read
.xdata$x:00002B50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B50                 assume cs:_xdata$x
.xdata$x:00002B50                 ;org 2B50h
.xdata$x:00002B50 ; COMDAT (pick associative to section at 10A8)
.xdata$x:00002B50 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002B50                                         ; DATA XREF: .xdata$x:00002B60o
.xdata$x:00002B51                 db 0FFh
.xdata$x:00002B52                 db 0FFh
.xdata$x:00002B53                 db 0FFh
.xdata$x:00002B54                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002B58 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002B58                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002B59                 db    5
.xdata$x:00002B5A                 db  93h ; ô
.xdata$x:00002B5B                 db  19h
.xdata$x:00002B5C                 db    1
.xdata$x:00002B5D                 db    0
.xdata$x:00002B5E                 db    0
.xdata$x:00002B5F                 db    0
.xdata$x:00002B60                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00002B64                 db    0
.xdata$x:00002B65                 db    0
.xdata$x:00002B66                 db    0
.xdata$x:00002B67                 db    0
.xdata$x:00002B68                 db    0
.xdata$x:00002B69                 db    0
.xdata$x:00002B6A                 db    0
.xdata$x:00002B6B                 db    0
.xdata$x:00002B6C                 db    0
.xdata$x:00002B6D                 db    0
.xdata$x:00002B6E                 db    0
.xdata$x:00002B6F                 db    0
.xdata$x:00002B70                 db    0
.xdata$x:00002B71                 db    0
.xdata$x:00002B72                 db    0
.xdata$x:00002B73                 db    0
.xdata$x:00002B74                 db    0
.xdata$x:00002B75                 db    0
.xdata$x:00002B76                 db    0
.xdata$x:00002B77                 db    0
.xdata$x:00002B78                 db    0
.xdata$x:00002B79                 db    0
.xdata$x:00002B7A                 db    0
.xdata$x:00002B7B                 db    0
.xdata$x:00002B7B _xdata$x        ends
.xdata$x:00002B7B
.xdata$x:00002B7C ; ===========================================================================
.xdata$x:00002B7C
.xdata$x:00002B7C ; Segment type: Pure data
.xdata$x:00002B7C ; Segment permissions: Read
.xdata$x:00002B7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B7C                 assume cs:_xdata$x
.xdata$x:00002B7C                 ;org 2B7Ch
.xdata$x:00002B7C ; COMDAT (pick associative to section at 127C)
.xdata$x:00002B7C __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002B7C                                         ; DATA XREF: .xdata$x:00002B8Co
.xdata$x:00002B7D                 db 0FFh
.xdata$x:00002B7E                 db 0FFh
.xdata$x:00002B7F                 db 0FFh
.xdata$x:00002B80                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00002B84 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002B84                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00002B85                 db    5
.xdata$x:00002B86                 db  93h ; ô
.xdata$x:00002B87                 db  19h
.xdata$x:00002B88                 db    1
.xdata$x:00002B89                 db    0
.xdata$x:00002B8A                 db    0
.xdata$x:00002B8B                 db    0
.xdata$x:00002B8C                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00002B90                 db    0
.xdata$x:00002B91                 db    0
.xdata$x:00002B92                 db    0
.xdata$x:00002B93                 db    0
.xdata$x:00002B94                 db    0
.xdata$x:00002B95                 db    0
.xdata$x:00002B96                 db    0
.xdata$x:00002B97                 db    0
.xdata$x:00002B98                 db    0
.xdata$x:00002B99                 db    0
.xdata$x:00002B9A                 db    0
.xdata$x:00002B9B                 db    0
.xdata$x:00002B9C                 db    0
.xdata$x:00002B9D                 db    0
.xdata$x:00002B9E                 db    0
.xdata$x:00002B9F                 db    0
.xdata$x:00002BA0                 db    0
.xdata$x:00002BA1                 db    0
.xdata$x:00002BA2                 db    0
.xdata$x:00002BA3                 db    0
.xdata$x:00002BA4                 db    0
.xdata$x:00002BA5                 db    0
.xdata$x:00002BA6                 db    0
.xdata$x:00002BA7                 db    0
.xdata$x:00002BA7 _xdata$x        ends
.xdata$x:00002BA7
.xdata$x:00002BA8 ; ===========================================================================
.xdata$x:00002BA8
.xdata$x:00002BA8 ; Segment type: Pure data
.xdata$x:00002BA8 ; Segment permissions: Read
.xdata$x:00002BA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BA8                 assume cs:_xdata$x
.xdata$x:00002BA8                 ;org 2BA8h
.xdata$x:00002BA8 ; COMDAT (pick associative to section at 22AC)
.xdata$x:00002BA8 __unwindtable$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z db 0FFh
.xdata$x:00002BA8                                         ; DATA XREF: .xdata$x:00002BB8o
.xdata$x:00002BA9                 db 0FFh
.xdata$x:00002BAA                 db 0FFh
.xdata$x:00002BAB                 db 0FFh
.xdata$x:00002BAC                 dd offset __unwindfunclet$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0
.xdata$x:00002BB0 __ehfuncinfo$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z db  22h ; "
.xdata$x:00002BB0                                         ; DATA XREF: __ehhandler$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z+11o
.xdata$x:00002BB1                 db    5
.xdata$x:00002BB2                 db  93h ; ô
.xdata$x:00002BB3                 db  19h
.xdata$x:00002BB4                 db    1
.xdata$x:00002BB5                 db    0
.xdata$x:00002BB6                 db    0
.xdata$x:00002BB7                 db    0
.xdata$x:00002BB8                 dd offset __unwindtable$?getFullFilePath@VerticalFileSwitcher@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
.xdata$x:00002BBC                 db    0
.xdata$x:00002BBD                 db    0
.xdata$x:00002BBE                 db    0
.xdata$x:00002BBF                 db    0
.xdata$x:00002BC0                 db    0
.xdata$x:00002BC1                 db    0
.xdata$x:00002BC2                 db    0
.xdata$x:00002BC3                 db    0
.xdata$x:00002BC4                 db    0
.xdata$x:00002BC5                 db    0
.xdata$x:00002BC6                 db    0
.xdata$x:00002BC7                 db    0
.xdata$x:00002BC8                 db    0
.xdata$x:00002BC9                 db    0
.xdata$x:00002BCA                 db    0
.xdata$x:00002BCB                 db    0
.xdata$x:00002BCC                 db    0
.xdata$x:00002BCD                 db    0
.xdata$x:00002BCE                 db    0
.xdata$x:00002BCF                 db    0
.xdata$x:00002BD0                 db    0
.xdata$x:00002BD1                 db    0
.xdata$x:00002BD2                 db    0
.xdata$x:00002BD3                 db    0
.xdata$x:00002BD3 _xdata$x        ends
.xdata$x:00002BD3
.xdata$x:00002BD4 ; ===========================================================================
.xdata$x:00002BD4
.xdata$x:00002BD4 ; Segment type: Pure data
.xdata$x:00002BD4 ; Segment permissions: Read
.xdata$x:00002BD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002BD4                 assume cs:_xdata$x
.xdata$x:00002BD4                 ;org 2BD4h
.xdata$x:00002BD4 __unwindtable$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z db 0FFh
.xdata$x:00002BD4                                         ; DATA XREF: .xdata$x:00002BE4o
.xdata$x:00002BD5                 db 0FFh
.xdata$x:00002BD6                 db 0FFh
.xdata$x:00002BD7                 db 0FFh
.xdata$x:00002BD8                 dd offset __unwindfunclet$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z$0
.xdata$x:00002BDC __ehfuncinfo$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z db  22h ; "
.xdata$x:00002BDC                                         ; DATA XREF: __ehhandler$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z+1Eo
.xdata$x:00002BDD                 db    5
.xdata$x:00002BDE                 db  93h ; ô
.xdata$x:00002BDF                 db  19h
.xdata$x:00002BE0                 db    1
.xdata$x:00002BE1                 db    0
.xdata$x:00002BE2                 db    0
.xdata$x:00002BE3                 db    0
.xdata$x:00002BE4                 dd offset __unwindtable$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z
.xdata$x:00002BE8                 align 20h
.xdata$x:00002BE8 _xdata$x        ends
.xdata$x:00002BE8
.xdata$x:00002C00 ; ===========================================================================
.xdata$x:00002C00
.xdata$x:00002C00 ; Segment type: Pure data
.xdata$x:00002C00 ; Segment permissions: Read
.xdata$x:00002C00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C00                 assume cs:_xdata$x
.xdata$x:00002C00                 ;org 2C00h
.xdata$x:00002C00 ; COMDAT (pick associative to section at AD0)
.xdata$x:00002C00 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002C00                                         ; DATA XREF: .xdata$x:00002C10o
.xdata$x:00002C01                 db 0FFh
.xdata$x:00002C02                 db 0FFh
.xdata$x:00002C03                 db 0FFh
.xdata$x:00002C04                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002C08 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002C08                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002C09                 db    5
.xdata$x:00002C0A                 db  93h ; ô
.xdata$x:00002C0B                 db  19h
.xdata$x:00002C0C                 db    1
.xdata$x:00002C0D                 db    0
.xdata$x:00002C0E                 db    0
.xdata$x:00002C0F                 db    0
.xdata$x:00002C10                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002C14                 db    0
.xdata$x:00002C15                 db    0
.xdata$x:00002C16                 db    0
.xdata$x:00002C17                 db    0
.xdata$x:00002C18                 db    0
.xdata$x:00002C19                 db    0
.xdata$x:00002C1A                 db    0
.xdata$x:00002C1B                 db    0
.xdata$x:00002C1C                 db    0
.xdata$x:00002C1D                 db    0
.xdata$x:00002C1E                 db    0
.xdata$x:00002C1F                 db    0
.xdata$x:00002C20                 db    0
.xdata$x:00002C21                 db    0
.xdata$x:00002C22                 db    0
.xdata$x:00002C23                 db    0
.xdata$x:00002C24                 db    0
.xdata$x:00002C25                 db    0
.xdata$x:00002C26                 db    0
.xdata$x:00002C27                 db    0
.xdata$x:00002C28                 db    0
.xdata$x:00002C29                 db    0
.xdata$x:00002C2A                 db    0
.xdata$x:00002C2B                 db    0
.xdata$x:00002C2B _xdata$x        ends
.xdata$x:00002C2B
.xdata$x:00002C2C ; ===========================================================================
.xdata$x:00002C2C
.xdata$x:00002C2C ; Segment type: Pure data
.xdata$x:00002C2C ; Segment permissions: Read
.xdata$x:00002C2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C2C                 assume cs:_xdata$x
.xdata$x:00002C2C                 ;org 2C2Ch
.xdata$x:00002C2C ; COMDAT (pick associative to section at 9FC)
.xdata$x:00002C2C __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002C2C                                         ; DATA XREF: .xdata$x:00002C3Co
.xdata$x:00002C2D                 db 0FFh
.xdata$x:00002C2E                 db 0FFh
.xdata$x:00002C2F                 db 0FFh
.xdata$x:00002C30                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002C34 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002C34                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002C35                 db    5
.xdata$x:00002C36                 db  93h ; ô
.xdata$x:00002C37                 db  19h
.xdata$x:00002C38                 db    1
.xdata$x:00002C39                 db    0
.xdata$x:00002C3A                 db    0
.xdata$x:00002C3B                 db    0
.xdata$x:00002C3C                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002C40                 db    0
.xdata$x:00002C41                 db    0
.xdata$x:00002C42                 db    0
.xdata$x:00002C43                 db    0
.xdata$x:00002C44                 db    0
.xdata$x:00002C45                 db    0
.xdata$x:00002C46                 db    0
.xdata$x:00002C47                 db    0
.xdata$x:00002C48                 db    0
.xdata$x:00002C49                 db    0
.xdata$x:00002C4A                 db    0
.xdata$x:00002C4B                 db    0
.xdata$x:00002C4C                 db    0
.xdata$x:00002C4D                 db    0
.xdata$x:00002C4E                 db    0
.xdata$x:00002C4F                 db    0
.xdata$x:00002C50                 db    0
.xdata$x:00002C51                 db    0
.xdata$x:00002C52                 db    0
.xdata$x:00002C53                 db    0
.xdata$x:00002C54                 db    0
.xdata$x:00002C55                 db    0
.xdata$x:00002C56                 db    0
.xdata$x:00002C57                 db    0
.xdata$x:00002C57 _xdata$x        ends
.xdata$x:00002C57
.rdata:00002C58 ; ===========================================================================
.rdata:00002C58
.rdata:00002C58 ; Segment type: Pure data
.rdata:00002C58 ; Segment permissions: Read
.rdata:00002C58 _rdata          segment dword public 'DATA' use32
.rdata:00002C58                 assume cs:_rdata
.rdata:00002C58                 ;org 2C58h
.rdata:00002C58 ; COMDAT (pick largest)
.rdata:00002C58                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002C5C                 public ??_7error_category@std@@6B@
.rdata:00002C5C ; const std::error_category::`vftable'
.rdata:00002C5C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002C5C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002C5C                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002C5C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002C60                 dd offset __purecall
.rdata:00002C64                 dd offset __purecall
.rdata:00002C68                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002C6C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002C70                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002C70 _rdata          ends
.rdata:00002C70
.rdata:00002C74 ; ===========================================================================
.rdata:00002C74
.rdata:00002C74 ; Segment type: Pure data
.rdata:00002C74 ; Segment permissions: Read
.rdata:00002C74 _rdata          segment dword public 'DATA' use32
.rdata:00002C74                 assume cs:_rdata
.rdata:00002C74                 ;org 2C74h
.rdata:00002C74 ; COMDAT (pick largest)
.rdata:00002C74                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002C78                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002C78 ; const std::_Generic_error_category::`vftable'
.rdata:00002C78 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002C78                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002C78                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002C7C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002C80                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002C84                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002C88                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002C8C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002C8C _rdata          ends
.rdata:00002C8C
.rdata:00002C90 ; ===========================================================================
.rdata:00002C90
.rdata:00002C90 ; Segment type: Pure data
.rdata:00002C90 ; Segment permissions: Read
.rdata:00002C90 _rdata          segment dword public 'DATA' use32
.rdata:00002C90                 assume cs:_rdata
.rdata:00002C90                 ;org 2C90h
.rdata:00002C90 ; COMDAT (pick any)
.rdata:00002C90                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002C90 ; `string'
.rdata:00002C90 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002C90                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002C90 _rdata          ends
.rdata:00002C90
.rdata:00002C98 ; ===========================================================================
.rdata:00002C98
.rdata:00002C98 ; Segment type: Pure data
.rdata:00002C98 ; Segment permissions: Read
.rdata:00002C98 _rdata          segment dword public 'DATA' use32
.rdata:00002C98                 assume cs:_rdata
.rdata:00002C98                 ;org 2C98h
.rdata:00002C98 ; COMDAT (pick any)
.rdata:00002C98                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00002C98 ; `string'
.rdata:00002C98 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00002C98                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2450o
.rdata:00002C98                                         ; std::_System_error_category::message(int):loc_25CCo
.rdata:00002CA6                 align 4
.rdata:00002CA6 _rdata          ends
.rdata:00002CA6
.rdata:00002CA8 ; ===========================================================================
.rdata:00002CA8
.rdata:00002CA8 ; Segment type: Pure data
.rdata:00002CA8 ; Segment permissions: Read
.rdata:00002CA8 _rdata          segment dword public 'DATA' use32
.rdata:00002CA8                 assume cs:_rdata
.rdata:00002CA8                 ;org 2CA8h
.rdata:00002CA8 ; COMDAT (pick largest)
.rdata:00002CA8                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00002CAC                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00002CAC ; const std::_Iostream_error_category::`vftable'
.rdata:00002CAC ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00002CAC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00002CAC                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002CB0                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002CB4                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002CB8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002CBC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002CC0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002CC0 _rdata          ends
.rdata:00002CC0
.rdata:00002CC4 ; ===========================================================================
.rdata:00002CC4
.rdata:00002CC4 ; Segment type: Pure data
.rdata:00002CC4 ; Segment permissions: Read
.rdata:00002CC4 _rdata          segment dword public 'DATA' use32
.rdata:00002CC4                 assume cs:_rdata
.rdata:00002CC4                 ;org 2CC4h
.rdata:00002CC4 ; COMDAT (pick any)
.rdata:00002CC4                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002CC4 ; `string'
.rdata:00002CC4 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002CC4                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00002CCD                 align 10h
.rdata:00002CCD _rdata          ends
.rdata:00002CCD
.rdata:00002CD0 ; ===========================================================================
.rdata:00002CD0
.rdata:00002CD0 ; Segment type: Pure data
.rdata:00002CD0 ; Segment permissions: Read
.rdata:00002CD0 _rdata          segment dword public 'DATA' use32
.rdata:00002CD0                 assume cs:_rdata
.rdata:00002CD0                 ;org 2CD0h
.rdata:00002CD0 ; COMDAT (pick any)
.rdata:00002CD0                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002CD0 ; char `string'[]
.rdata:00002CD0 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002CD0                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002CE6                 align 4
.rdata:00002CE6 _rdata          ends
.rdata:00002CE6
.rdata:00002CE8 ; ===========================================================================
.rdata:00002CE8
.rdata:00002CE8 ; Segment type: Pure data
.rdata:00002CE8 ; Segment permissions: Read
.rdata:00002CE8 _rdata          segment dword public 'DATA' use32
.rdata:00002CE8                 assume cs:_rdata
.rdata:00002CE8                 ;org 2CE8h
.rdata:00002CE8 ; COMDAT (pick largest)
.rdata:00002CE8                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002CEC                 public ??_7_System_error_category@std@@6B@
.rdata:00002CEC ; const std::_System_error_category::`vftable'
.rdata:00002CEC ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002CEC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002CEC                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002CF0                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002CF4                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002CF8                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002CFC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002D00                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002D00 _rdata          ends
.rdata:00002D00
.rdata:00002D04 ; ===========================================================================
.rdata:00002D04
.rdata:00002D04 ; Segment type: Pure data
.rdata:00002D04 ; Segment permissions: Read
.rdata:00002D04 _rdata          segment dword public 'DATA' use32
.rdata:00002D04                 assume cs:_rdata
.rdata:00002D04                 ;org 2D04h
.rdata:00002D04 ; COMDAT (pick any)
.rdata:00002D04                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002D04 ; `string'
.rdata:00002D04 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002D04                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002D0B                 align 4
.rdata:00002D0B _rdata          ends
.rdata:00002D0B
.bss:00002D0C ; ===========================================================================
.bss:00002D0C
.bss:00002D0C ; Segment type: Uninitialized
.bss:00002D0C ; Segment permissions: Read/Write
.bss:00002D0C _bss            segment dword public 'BSS' use32
.bss:00002D0C                 assume cs:_bss
.bss:00002D0C                 ;org 2D0Ch
.bss:00002D0C ; COMDAT (pick any)
.bss:00002D0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D0C                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002D0C ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002D0C ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002D0C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002D0C                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002D0D                 db    ? ;
.bss:00002D0E                 db    ? ;
.bss:00002D0F                 db    ? ;
.bss:00002D0F _bss            ends
.bss:00002D0F
.bss:00002D10 ; ===========================================================================
.bss:00002D10
.bss:00002D10 ; Segment type: Uninitialized
.bss:00002D10 ; Segment permissions: Read/Write
.bss:00002D10 _bss            segment dword public 'BSS' use32
.bss:00002D10                 assume cs:_bss
.bss:00002D10                 ;org 2D10h
.bss:00002D10 ; COMDAT (pick any)
.bss:00002D10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D10                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002D10 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002D10 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002D10                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002D10                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002D11                 db    ? ;
.bss:00002D12                 db    ? ;
.bss:00002D13                 db    ? ;
.bss:00002D13 _bss            ends
.bss:00002D13
.bss:00002D14 ; ===========================================================================
.bss:00002D14
.bss:00002D14 ; Segment type: Uninitialized
.bss:00002D14 ; Segment permissions: Read/Write
.bss:00002D14 _bss            segment dword public 'BSS' use32
.bss:00002D14                 assume cs:_bss
.bss:00002D14                 ;org 2D14h
.bss:00002D14 ; COMDAT (pick any)
.bss:00002D14                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D14                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002D14 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002D14 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002D14                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002D14                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002D15                 db    ? ;
.bss:00002D16                 db    ? ;
.bss:00002D17                 db    ? ;
.bss:00002D17 _bss            ends
.bss:00002D17
.bss:00002D18 ; ===========================================================================
.bss:00002D18
.bss:00002D18 ; Segment type: Uninitialized
.bss:00002D18 ; Segment permissions: Read/Write
.bss:00002D18 _bss            segment dword public 'BSS' use32
.bss:00002D18                 assume cs:_bss
.bss:00002D18                 ;org 2D18h
.bss:00002D18 ; COMDAT (pick any)
.bss:00002D18                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D18                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002D18 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002D18 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002D18                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002D19                 db    ? ;
.bss:00002D1A                 db    ? ;
.bss:00002D1B                 db    ? ;
.bss:00002D1B _bss            ends
.bss:00002D1B
.bss:00002D1C ; ===========================================================================
.bss:00002D1C
.bss:00002D1C ; Segment type: Uninitialized
.bss:00002D1C ; Segment permissions: Read/Write
.bss:00002D1C _bss            segment dword public 'BSS' use32
.bss:00002D1C                 assume cs:_bss
.bss:00002D1C                 ;org 2D1Ch
.bss:00002D1C ; COMDAT (pick any)
.bss:00002D1C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002D1C                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002D1C ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002D1C ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002D1C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002D1D                 db    ? ;
.bss:00002D1E                 db    ? ;
.bss:00002D1F                 db    ? ;
.bss:00002D1F _bss            ends
.bss:00002D1F
.rdata:00002D20 ; ===========================================================================
.rdata:00002D20
.rdata:00002D20 ; Segment type: Pure data
.rdata:00002D20 ; Segment permissions: Read
.rdata:00002D20 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002D20 _rdata          segment para public 'DATA' use32
.rdata:00002D20                 assume cs:_rdata
.rdata:00002D20                 ;org 2D20h
.rdata:00002D20 ; COMDAT (pick any)
.rdata:00002D20                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002D20 ; wchar_t `string'
.rdata:00002D20 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002D20                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002D20                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002D20                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002D20                 unicode 0, <clude\xstring>,0
.rdata:00002DAE                 align 10h
.rdata:00002DAE _rdata          ends
.rdata:00002DAE
.bss:00002DB0 ; ===========================================================================
.bss:00002DB0
.bss:00002DB0 ; Segment type: Uninitialized
.bss:00002DB0 ; Segment permissions: Read/Write
.bss:00002DB0 _bss            segment dword public 'BSS' use32
.bss:00002DB0                 assume cs:_bss
.bss:00002DB0                 ;org 2DB0h
.bss:00002DB0 ; COMDAT (pick any)
.bss:00002DB0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002DB0                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00002DB0 ; std::locale::id std::numpunct<char>::id
.bss:00002DB0 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00002DB0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00002DB1                 db    ? ;
.bss:00002DB2                 db    ? ;
.bss:00002DB3                 db    ? ;
.bss:00002DB3 _bss            ends
.bss:00002DB3
.bss:00002DB4 ; ===========================================================================
.bss:00002DB4
.bss:00002DB4 ; Segment type: Uninitialized
.bss:00002DB4 ; Segment permissions: Read/Write
.bss:00002DB4 _bss            segment dword public 'BSS' use32
.bss:00002DB4                 assume cs:_bss
.bss:00002DB4                 ;org 2DB4h
.bss:00002DB4 ; COMDAT (pick any)
.bss:00002DB4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002DB4                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002DB4 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002DB4 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002DB4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002DB5                 db    ? ;
.bss:00002DB6                 db    ? ;
.bss:00002DB7                 db    ? ;
.bss:00002DB7 _bss            ends
.bss:00002DB7
.rdata:00002DB8 ; ===========================================================================
.rdata:00002DB8
.rdata:00002DB8 ; Segment type: Pure data
.rdata:00002DB8 ; Segment permissions: Read
.rdata:00002DB8 _rdata          segment dword public 'DATA' use32
.rdata:00002DB8                 assume cs:_rdata
.rdata:00002DB8                 ;org 2DB8h
.rdata:00002DB8 ; COMDAT (pick any)
.rdata:00002DB8                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002DB8 ; char `string'[]
.rdata:00002DB8 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002DB8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002DB8 _rdata          ends
.rdata:00002DB8
.rdata:00002DC8 ; ===========================================================================
.rdata:00002DC8
.rdata:00002DC8 ; Segment type: Pure data
.rdata:00002DC8 ; Segment permissions: Read
.rdata:00002DC8 _rdata          segment dword public 'DATA' use32
.rdata:00002DC8                 assume cs:_rdata
.rdata:00002DC8                 ;org 2DC8h
.rdata:00002DC8 ; COMDAT (pick any)
.rdata:00002DC8                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002DC8 ; char `string'[]
.rdata:00002DC8 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002DC8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002DC8 _rdata          ends
.rdata:00002DC8
.rdata:00002DE0 ; ===========================================================================
.rdata:00002DE0
.rdata:00002DE0 ; Segment type: Pure data
.rdata:00002DE0 ; Segment permissions: Read
.rdata:00002DE0 _rdata          segment dword public 'DATA' use32
.rdata:00002DE0                 assume cs:_rdata
.rdata:00002DE0                 ;org 2DE0h
.rdata:00002DE0 ; COMDAT (pick any)
.rdata:00002DE0                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002DE0 ; wchar_t `string'
.rdata:00002DE0 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002DE0                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002DE0                 unicode 0, <invalid null pointer>,0
.rdata:00002E0A                 align 4
.rdata:00002E0A _rdata          ends
.rdata:00002E0A
.rdata$r:00002E0C ; ===========================================================================
.rdata$r:00002E0C
.rdata$r:00002E0C ; Segment type: Pure data
.rdata$r:00002E0C ; Segment permissions: Read
.rdata$r:00002E0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E0C                 assume cs:_rdata$r
.rdata$r:00002E0C                 ;org 2E0Ch
.rdata$r:00002E0C ; COMDAT (pick any)
.rdata$r:00002E0C                 public ??_R4error_category@std@@6B@
.rdata$r:00002E0C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002E0C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002C58o
.rdata$r:00002E0D                 db    0
.rdata$r:00002E0E                 db    0
.rdata$r:00002E0F                 db    0
.rdata$r:00002E10                 db    0
.rdata$r:00002E11                 db    0
.rdata$r:00002E12                 db    0
.rdata$r:00002E13                 db    0
.rdata$r:00002E14                 db    0
.rdata$r:00002E15                 db    0
.rdata$r:00002E16                 db    0
.rdata$r:00002E17                 db    0
.rdata$r:00002E18                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002E1C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E1C _rdata$r        ends
.rdata$r:00002E1C
.data$r:00002E20 ; ===========================================================================
.data$r:00002E20
.data$r:00002E20 ; Segment type: Pure data
.data$r:00002E20 ; Segment permissions: Read/Write
.data$r:00002E20 _data$r         segment dword public 'DATA' use32
.data$r:00002E20                 assume cs:_data$r
.data$r:00002E20                 ;org 2E20h
.data$r:00002E20 ; COMDAT (pick any)
.data$r:00002E20                 public ??_R0?AVerror_category@std@@@8
.data$r:00002E20 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002E20 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002E20                                         ; DATA XREF: .rdata$r:00002E18o
.data$r:00002E20                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002E20                                         ; const type_info::`vftable'
.data$r:00002E24                 align 8
.data$r:00002E28 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00002E41                 align 4
.data$r:00002E41 _data$r         ends
.data$r:00002E41
.rdata$r:00002E44 ; ===========================================================================
.rdata$r:00002E44
.rdata$r:00002E44 ; Segment type: Pure data
.rdata$r:00002E44 ; Segment permissions: Read
.rdata$r:00002E44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E44                 assume cs:_rdata$r
.rdata$r:00002E44                 ;org 2E44h
.rdata$r:00002E44 ; COMDAT (pick any)
.rdata$r:00002E44                 public ??_R3error_category@std@@8
.rdata$r:00002E44 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E44 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002E1Co
.rdata$r:00002E44                                         ; .rdata$r:00002E74o
.rdata$r:00002E45                 db    0
.rdata$r:00002E46                 db    0
.rdata$r:00002E47                 db    0
.rdata$r:00002E48                 db    0
.rdata$r:00002E49                 db    0
.rdata$r:00002E4A                 db    0
.rdata$r:00002E4B                 db    0
.rdata$r:00002E4C                 db    1
.rdata$r:00002E4D                 db    0
.rdata$r:00002E4E                 db    0
.rdata$r:00002E4F                 db    0
.rdata$r:00002E50                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002E50 _rdata$r        ends
.rdata$r:00002E50
.rdata$r:00002E54 ; ===========================================================================
.rdata$r:00002E54
.rdata$r:00002E54 ; Segment type: Pure data
.rdata$r:00002E54 ; Segment permissions: Read
.rdata$r:00002E54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E54                 assume cs:_rdata$r
.rdata$r:00002E54                 ;org 2E54h
.rdata$r:00002E54 ; COMDAT (pick any)
.rdata$r:00002E54                 public ??_R2error_category@std@@8
.rdata$r:00002E54 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002E54 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002E54                                         ; DATA XREF: .rdata$r:00002E50o
.rdata$r:00002E54                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002E58                 db    0
.rdata$r:00002E59                 align 4
.rdata$r:00002E59 _rdata$r        ends
.rdata$r:00002E59
.rdata$r:00002E5C ; ===========================================================================
.rdata$r:00002E5C
.rdata$r:00002E5C ; Segment type: Pure data
.rdata$r:00002E5C ; Segment permissions: Read
.rdata$r:00002E5C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E5C                 assume cs:_rdata$r
.rdata$r:00002E5C                 ;org 2E5Ch
.rdata$r:00002E5C ; COMDAT (pick any)
.rdata$r:00002E5C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002E5C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002E5C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002E5C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002E5C                                         ; .rdata$r:00002ECCo ...
.rdata$r:00002E5C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002E60                 db    0
.rdata$r:00002E61                 db    0
.rdata$r:00002E62                 db    0
.rdata$r:00002E63                 db    0
.rdata$r:00002E64                 db    0
.rdata$r:00002E65                 db    0
.rdata$r:00002E66                 db    0
.rdata$r:00002E67                 db    0
.rdata$r:00002E68                 db 0FFh
.rdata$r:00002E69                 db 0FFh
.rdata$r:00002E6A                 db 0FFh
.rdata$r:00002E6B                 db 0FFh
.rdata$r:00002E6C                 db    0
.rdata$r:00002E6D                 db    0
.rdata$r:00002E6E                 db    0
.rdata$r:00002E6F                 db    0
.rdata$r:00002E70                 db  40h ; @
.rdata$r:00002E71                 db    0
.rdata$r:00002E72                 db    0
.rdata$r:00002E73                 db    0
.rdata$r:00002E74                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E74 _rdata$r        ends
.rdata$r:00002E74
.rdata$r:00002E78 ; ===========================================================================
.rdata$r:00002E78
.rdata$r:00002E78 ; Segment type: Pure data
.rdata$r:00002E78 ; Segment permissions: Read
.rdata$r:00002E78 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002E78                 assume cs:_rdata$r
.rdata$r:00002E78                 ;org 2E78h
.rdata$r:00002E78 ; COMDAT (pick any)
.rdata$r:00002E78                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002E78 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002E78 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002E78                                         ; DATA XREF: .rdata:00002C74o
.rdata$r:00002E79                 db    0
.rdata$r:00002E7A                 db    0
.rdata$r:00002E7B                 db    0
.rdata$r:00002E7C                 db    0
.rdata$r:00002E7D                 db    0
.rdata$r:00002E7E                 db    0
.rdata$r:00002E7F                 db    0
.rdata$r:00002E80                 db    0
.rdata$r:00002E81                 db    0
.rdata$r:00002E82                 db    0
.rdata$r:00002E83                 db    0
.rdata$r:00002E84                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002E88                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002E88 _rdata$r        ends
.rdata$r:00002E88
.data$r:00002E8C ; ===========================================================================
.data$r:00002E8C
.data$r:00002E8C ; Segment type: Pure data
.data$r:00002E8C ; Segment permissions: Read/Write
.data$r:00002E8C _data$r         segment dword public 'DATA' use32
.data$r:00002E8C                 assume cs:_data$r
.data$r:00002E8C                 ;org 2E8Ch
.data$r:00002E8C ; COMDAT (pick any)
.data$r:00002E8C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002E8C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002E8C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002E8C                                         ; DATA XREF: .rdata$r:00002E84o
.data$r:00002E8C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002E8C                                         ; const type_info::`vftable'
.data$r:00002E90                 db    0
.data$r:00002E91                 db    0
.data$r:00002E92                 db    0
.data$r:00002E93                 db    0
.data$r:00002E94                 db  2Eh ; .
.data$r:00002E95                 db  3Fh ; ?
.data$r:00002E96                 db  41h ; A
.data$r:00002E97                 db  56h ; V
.data$r:00002E98                 db  5Fh ; _
.data$r:00002E99                 db  47h ; G
.data$r:00002E9A                 db  65h ; e
.data$r:00002E9B                 db  6Eh ; n
.data$r:00002E9C                 db  65h ; e
.data$r:00002E9D                 db  72h ; r
.data$r:00002E9E                 db  69h ; i
.data$r:00002E9F                 db  63h ; c
.data$r:00002EA0                 db  5Fh ; _
.data$r:00002EA1                 db  65h ; e
.data$r:00002EA2                 db  72h ; r
.data$r:00002EA3                 db  72h ; r
.data$r:00002EA4                 db  6Fh ; o
.data$r:00002EA5                 db  72h ; r
.data$r:00002EA6                 db  5Fh ; _
.data$r:00002EA7                 db  63h ; c
.data$r:00002EA8                 db  61h ; a
.data$r:00002EA9                 db  74h ; t
.data$r:00002EAA                 db  65h ; e
.data$r:00002EAB                 db  67h ; g
.data$r:00002EAC                 db  6Fh ; o
.data$r:00002EAD                 db  72h ; r
.data$r:00002EAE                 db  79h ; y
.data$r:00002EAF                 db  40h ; @
.data$r:00002EB0                 db  73h ; s
.data$r:00002EB1                 db  74h ; t
.data$r:00002EB2                 db  64h ; d
.data$r:00002EB3                 db  40h ; @
.data$r:00002EB4                 db  40h ; @
.data$r:00002EB5                 db    0
.data$r:00002EB6                 align 4
.data$r:00002EB6 _data$r         ends
.data$r:00002EB6
.rdata$r:00002EB8 ; ===========================================================================
.rdata$r:00002EB8
.rdata$r:00002EB8 ; Segment type: Pure data
.rdata$r:00002EB8 ; Segment permissions: Read
.rdata$r:00002EB8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EB8                 assume cs:_rdata$r
.rdata$r:00002EB8                 ;org 2EB8h
.rdata$r:00002EB8 ; COMDAT (pick any)
.rdata$r:00002EB8                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002EB8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EB8 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002EB8                                         ; DATA XREF: .rdata$r:00002E88o
.rdata$r:00002EB8                                         ; .rdata$r:00002EECo
.rdata$r:00002EB9                 db    0
.rdata$r:00002EBA                 db    0
.rdata$r:00002EBB                 db    0
.rdata$r:00002EBC                 db    0
.rdata$r:00002EBD                 db    0
.rdata$r:00002EBE                 db    0
.rdata$r:00002EBF                 db    0
.rdata$r:00002EC0                 db    2
.rdata$r:00002EC1                 db    0
.rdata$r:00002EC2                 db    0
.rdata$r:00002EC3                 db    0
.rdata$r:00002EC4                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002EC4 _rdata$r        ends
.rdata$r:00002EC4
.rdata$r:00002EC8 ; ===========================================================================
.rdata$r:00002EC8
.rdata$r:00002EC8 ; Segment type: Pure data
.rdata$r:00002EC8 ; Segment permissions: Read
.rdata$r:00002EC8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EC8                 assume cs:_rdata$r
.rdata$r:00002EC8                 ;org 2EC8h
.rdata$r:00002EC8 ; COMDAT (pick any)
.rdata$r:00002EC8                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002EC8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002EC8 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002EC8                                         ; DATA XREF: .rdata$r:00002EC4o
.rdata$r:00002EC8                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002ECC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002ED0                 db    0
.rdata$r:00002ED1                 align 4
.rdata$r:00002ED1 _rdata$r        ends
.rdata$r:00002ED1
.rdata$r:00002ED4 ; ===========================================================================
.rdata$r:00002ED4
.rdata$r:00002ED4 ; Segment type: Pure data
.rdata$r:00002ED4 ; Segment permissions: Read
.rdata$r:00002ED4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002ED4                 assume cs:_rdata$r
.rdata$r:00002ED4                 ;org 2ED4h
.rdata$r:00002ED4 ; COMDAT (pick any)
.rdata$r:00002ED4                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002ED4 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002ED4 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002ED4                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002ED4                                         ; .rdata$r:00002F44o ...
.rdata$r:00002ED4                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002ED8                 db    1
.rdata$r:00002ED9                 db    0
.rdata$r:00002EDA                 db    0
.rdata$r:00002EDB                 db    0
.rdata$r:00002EDC                 db    0
.rdata$r:00002EDD                 db    0
.rdata$r:00002EDE                 db    0
.rdata$r:00002EDF                 db    0
.rdata$r:00002EE0                 db 0FFh
.rdata$r:00002EE1                 db 0FFh
.rdata$r:00002EE2                 db 0FFh
.rdata$r:00002EE3                 db 0FFh
.rdata$r:00002EE4                 db    0
.rdata$r:00002EE5                 db    0
.rdata$r:00002EE6                 db    0
.rdata$r:00002EE7                 db    0
.rdata$r:00002EE8                 db  40h ; @
.rdata$r:00002EE9                 db    0
.rdata$r:00002EEA                 db    0
.rdata$r:00002EEB                 db    0
.rdata$r:00002EEC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EEC _rdata$r        ends
.rdata$r:00002EEC
.rdata$r:00002EF0 ; ===========================================================================
.rdata$r:00002EF0
.rdata$r:00002EF0 ; Segment type: Pure data
.rdata$r:00002EF0 ; Segment permissions: Read
.rdata$r:00002EF0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EF0                 assume cs:_rdata$r
.rdata$r:00002EF0                 ;org 2EF0h
.rdata$r:00002EF0 ; COMDAT (pick any)
.rdata$r:00002EF0                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002EF0 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002EF0 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002EF0                                         ; DATA XREF: .rdata:00002CA8o
.rdata$r:00002EF1                 db    0
.rdata$r:00002EF2                 db    0
.rdata$r:00002EF3                 db    0
.rdata$r:00002EF4                 db    0
.rdata$r:00002EF5                 db    0
.rdata$r:00002EF6                 db    0
.rdata$r:00002EF7                 db    0
.rdata$r:00002EF8                 db    0
.rdata$r:00002EF9                 db    0
.rdata$r:00002EFA                 db    0
.rdata$r:00002EFB                 db    0
.rdata$r:00002EFC                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002F00                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F00 _rdata$r        ends
.rdata$r:00002F00
.data$r:00002F04 ; ===========================================================================
.data$r:00002F04
.data$r:00002F04 ; Segment type: Pure data
.data$r:00002F04 ; Segment permissions: Read/Write
.data$r:00002F04 _data$r         segment dword public 'DATA' use32
.data$r:00002F04                 assume cs:_data$r
.data$r:00002F04                 ;org 2F04h
.data$r:00002F04 ; COMDAT (pick any)
.data$r:00002F04                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002F04 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002F04 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002F04                                         ; DATA XREF: .rdata$r:00002EFCo
.data$r:00002F04                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002F04                                         ; const type_info::`vftable'
.data$r:00002F08                 db    0
.data$r:00002F09                 db    0
.data$r:00002F0A                 db    0
.data$r:00002F0B                 db    0
.data$r:00002F0C                 db  2Eh ; .
.data$r:00002F0D                 db  3Fh ; ?
.data$r:00002F0E                 db  41h ; A
.data$r:00002F0F                 db  56h ; V
.data$r:00002F10                 db  5Fh ; _
.data$r:00002F11                 db  49h ; I
.data$r:00002F12                 db  6Fh ; o
.data$r:00002F13                 db  73h ; s
.data$r:00002F14                 db  74h ; t
.data$r:00002F15                 db  72h ; r
.data$r:00002F16                 db  65h ; e
.data$r:00002F17                 db  61h ; a
.data$r:00002F18                 db  6Dh ; m
.data$r:00002F19                 db  5Fh ; _
.data$r:00002F1A                 db  65h ; e
.data$r:00002F1B                 db  72h ; r
.data$r:00002F1C                 db  72h ; r
.data$r:00002F1D                 db  6Fh ; o
.data$r:00002F1E                 db  72h ; r
.data$r:00002F1F                 db  5Fh ; _
.data$r:00002F20                 db  63h ; c
.data$r:00002F21                 db  61h ; a
.data$r:00002F22                 db  74h ; t
.data$r:00002F23                 db  65h ; e
.data$r:00002F24                 db  67h ; g
.data$r:00002F25                 db  6Fh ; o
.data$r:00002F26                 db  72h ; r
.data$r:00002F27                 db  79h ; y
.data$r:00002F28                 db  40h ; @
.data$r:00002F29                 db  73h ; s
.data$r:00002F2A                 db  74h ; t
.data$r:00002F2B                 db  64h ; d
.data$r:00002F2C                 db  40h ; @
.data$r:00002F2D                 db  40h ; @
.data$r:00002F2E                 db    0
.data$r:00002F2F                 align 10h
.data$r:00002F2F _data$r         ends
.data$r:00002F2F
.rdata$r:00002F30 ; ===========================================================================
.rdata$r:00002F30
.rdata$r:00002F30 ; Segment type: Pure data
.rdata$r:00002F30 ; Segment permissions: Read
.rdata$r:00002F30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F30                 assume cs:_rdata$r
.rdata$r:00002F30                 ;org 2F30h
.rdata$r:00002F30 ; COMDAT (pick any)
.rdata$r:00002F30                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002F30 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F30 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002F30                                         ; DATA XREF: .rdata$r:00002F00o
.rdata$r:00002F30                                         ; .rdata$r:00002F68o
.rdata$r:00002F31                 db    0
.rdata$r:00002F32                 db    0
.rdata$r:00002F33                 db    0
.rdata$r:00002F34                 db    0
.rdata$r:00002F35                 db    0
.rdata$r:00002F36                 db    0
.rdata$r:00002F37                 db    0
.rdata$r:00002F38                 db    3
.rdata$r:00002F39                 db    0
.rdata$r:00002F3A                 db    0
.rdata$r:00002F3B                 db    0
.rdata$r:00002F3C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002F3C _rdata$r        ends
.rdata$r:00002F3C
.rdata$r:00002F40 ; ===========================================================================
.rdata$r:00002F40
.rdata$r:00002F40 ; Segment type: Pure data
.rdata$r:00002F40 ; Segment permissions: Read
.rdata$r:00002F40 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F40                 assume cs:_rdata$r
.rdata$r:00002F40                 ;org 2F40h
.rdata$r:00002F40 ; COMDAT (pick any)
.rdata$r:00002F40                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002F40 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002F40 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002F40                                         ; DATA XREF: .rdata$r:00002F3Co
.rdata$r:00002F40                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F44                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F48                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F4C                 db    0
.rdata$r:00002F4D                 align 10h
.rdata$r:00002F4D _rdata$r        ends
.rdata$r:00002F4D
.rdata$r:00002F50 ; ===========================================================================
.rdata$r:00002F50
.rdata$r:00002F50 ; Segment type: Pure data
.rdata$r:00002F50 ; Segment permissions: Read
.rdata$r:00002F50 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F50                 assume cs:_rdata$r
.rdata$r:00002F50                 ;org 2F50h
.rdata$r:00002F50 ; COMDAT (pick any)
.rdata$r:00002F50                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002F50 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002F50 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002F50                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002F50                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002F54                 db    2
.rdata$r:00002F55                 db    0
.rdata$r:00002F56                 db    0
.rdata$r:00002F57                 db    0
.rdata$r:00002F58                 db    0
.rdata$r:00002F59                 db    0
.rdata$r:00002F5A                 db    0
.rdata$r:00002F5B                 db    0
.rdata$r:00002F5C                 db 0FFh
.rdata$r:00002F5D                 db 0FFh
.rdata$r:00002F5E                 db 0FFh
.rdata$r:00002F5F                 db 0FFh
.rdata$r:00002F60                 db    0
.rdata$r:00002F61                 db    0
.rdata$r:00002F62                 db    0
.rdata$r:00002F63                 db    0
.rdata$r:00002F64                 db  40h ; @
.rdata$r:00002F65                 db    0
.rdata$r:00002F66                 db    0
.rdata$r:00002F67                 db    0
.rdata$r:00002F68                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F68 _rdata$r        ends
.rdata$r:00002F68
.rdata$r:00002F6C ; ===========================================================================
.rdata$r:00002F6C
.rdata$r:00002F6C ; Segment type: Pure data
.rdata$r:00002F6C ; Segment permissions: Read
.rdata$r:00002F6C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F6C                 assume cs:_rdata$r
.rdata$r:00002F6C                 ;org 2F6Ch
.rdata$r:00002F6C ; COMDAT (pick any)
.rdata$r:00002F6C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002F6C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002F6C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002CE8o
.rdata$r:00002F6D                 db    0
.rdata$r:00002F6E                 db    0
.rdata$r:00002F6F                 db    0
.rdata$r:00002F70                 db    0
.rdata$r:00002F71                 db    0
.rdata$r:00002F72                 db    0
.rdata$r:00002F73                 db    0
.rdata$r:00002F74                 db    0
.rdata$r:00002F75                 db    0
.rdata$r:00002F76                 db    0
.rdata$r:00002F77                 db    0
.rdata$r:00002F78                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002F7C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F7C _rdata$r        ends
.rdata$r:00002F7C
.data$r:00002F80 ; ===========================================================================
.data$r:00002F80
.data$r:00002F80 ; Segment type: Pure data
.data$r:00002F80 ; Segment permissions: Read/Write
.data$r:00002F80 _data$r         segment dword public 'DATA' use32
.data$r:00002F80                 assume cs:_data$r
.data$r:00002F80                 ;org 2F80h
.data$r:00002F80 ; COMDAT (pick any)
.data$r:00002F80                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002F80 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002F80 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002F80                                         ; DATA XREF: .rdata$r:00002F78o
.data$r:00002F80                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002F80                                         ; const type_info::`vftable'
.data$r:00002F84                 align 8
.data$r:00002F88 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00002FA9                 align 4
.data$r:00002FA9 _data$r         ends
.data$r:00002FA9
.rdata$r:00002FAC ; ===========================================================================
.rdata$r:00002FAC
.rdata$r:00002FAC ; Segment type: Pure data
.rdata$r:00002FAC ; Segment permissions: Read
.rdata$r:00002FAC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FAC                 assume cs:_rdata$r
.rdata$r:00002FAC                 ;org 2FACh
.rdata$r:00002FAC ; COMDAT (pick any)
.rdata$r:00002FAC                 public ??_R3_System_error_category@std@@8
.rdata$r:00002FAC ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FAC ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002F7Co
.rdata$r:00002FAC                                         ; .rdata$r:00002FE4o
.rdata$r:00002FAD                 db    0
.rdata$r:00002FAE                 db    0
.rdata$r:00002FAF                 db    0
.rdata$r:00002FB0                 db    0
.rdata$r:00002FB1                 db    0
.rdata$r:00002FB2                 db    0
.rdata$r:00002FB3                 db    0
.rdata$r:00002FB4                 db    3
.rdata$r:00002FB5                 db    0
.rdata$r:00002FB6                 db    0
.rdata$r:00002FB7                 db    0
.rdata$r:00002FB8                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002FB8 _rdata$r        ends
.rdata$r:00002FB8
.rdata$r:00002FBC ; ===========================================================================
.rdata$r:00002FBC
.rdata$r:00002FBC ; Segment type: Pure data
.rdata$r:00002FBC ; Segment permissions: Read
.rdata$r:00002FBC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FBC                 assume cs:_rdata$r
.rdata$r:00002FBC                 ;org 2FBCh
.rdata$r:00002FBC ; COMDAT (pick any)
.rdata$r:00002FBC                 public ??_R2_System_error_category@std@@8
.rdata$r:00002FBC ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002FBC ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002FBC                                         ; DATA XREF: .rdata$r:00002FB8o
.rdata$r:00002FBC                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FC0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FC4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002FC8                 db    0
.rdata$r:00002FC9                 align 4
.rdata$r:00002FC9 _rdata$r        ends
.rdata$r:00002FC9
.rdata$r:00002FCC ; ===========================================================================
.rdata$r:00002FCC
.rdata$r:00002FCC ; Segment type: Pure data
.rdata$r:00002FCC ; Segment permissions: Read
.rdata$r:00002FCC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002FCC                 assume cs:_rdata$r
.rdata$r:00002FCC                 ;org 2FCCh
.rdata$r:00002FCC ; COMDAT (pick any)
.rdata$r:00002FCC                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002FCC ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002FCC ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002FCC                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002FCC                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002FD0                 db    2
.rdata$r:00002FD1                 db    0
.rdata$r:00002FD2                 db    0
.rdata$r:00002FD3                 db    0
.rdata$r:00002FD4                 db    0
.rdata$r:00002FD5                 db    0
.rdata$r:00002FD6                 db    0
.rdata$r:00002FD7                 db    0
.rdata$r:00002FD8                 db 0FFh
.rdata$r:00002FD9                 db 0FFh
.rdata$r:00002FDA                 db 0FFh
.rdata$r:00002FDB                 db 0FFh
.rdata$r:00002FDC                 db    0
.rdata$r:00002FDD                 db    0
.rdata$r:00002FDE                 db    0
.rdata$r:00002FDF                 db    0
.rdata$r:00002FE0                 db  40h ; @
.rdata$r:00002FE1                 db    0
.rdata$r:00002FE2                 db    0
.rdata$r:00002FE3                 db    0
.rdata$r:00002FE4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002FE4 _rdata$r        ends
.rdata$r:00002FE4
.CRT$XCU:00002FE8 ; ===========================================================================
.CRT$XCU:00002FE8
.CRT$XCU:00002FE8 ; Segment type: Pure data
.CRT$XCU:00002FE8 ; Segment permissions: Read
.CRT$XCU:00002FE8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FE8                 assume cs:_CRT$XCU
.CRT$XCU:00002FE8                 ;org 2FE8h
.CRT$XCU:00002FE8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002FEC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002FEC _CRT$XCU        ends
.CRT$XCU:00002FEC
.CRT$XCU:00002FF0 ; ===========================================================================
.CRT$XCU:00002FF0
.CRT$XCU:00002FF0 ; Segment type: Pure data
.CRT$XCU:00002FF0 ; Segment permissions: Read
.CRT$XCU:00002FF0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FF0                 assume cs:_CRT$XCU
.CRT$XCU:00002FF0                 ;org 2FF0h
.CRT$XCU:00002FF0 ; COMDAT (pick associative to section at 2D0C)
.CRT$XCU:00002FF0 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002FF0 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002FF0 _CRT$XCU        ends
.CRT$XCU:00002FF0
.CRT$XCU:00002FF4 ; ===========================================================================
.CRT$XCU:00002FF4
.CRT$XCU:00002FF4 ; Segment type: Pure data
.CRT$XCU:00002FF4 ; Segment permissions: Read
.CRT$XCU:00002FF4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FF4                 assume cs:_CRT$XCU
.CRT$XCU:00002FF4                 ;org 2FF4h
.CRT$XCU:00002FF4 ; COMDAT (pick associative to section at 2D10)
.CRT$XCU:00002FF4 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002FF4 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002FF4 _CRT$XCU        ends
.CRT$XCU:00002FF4
.CRT$XCU:00002FF8 ; ===========================================================================
.CRT$XCU:00002FF8
.CRT$XCU:00002FF8 ; Segment type: Pure data
.CRT$XCU:00002FF8 ; Segment permissions: Read
.CRT$XCU:00002FF8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FF8                 assume cs:_CRT$XCU
.CRT$XCU:00002FF8                 ;org 2FF8h
.CRT$XCU:00002FF8 ; COMDAT (pick associative to section at 2D14)
.CRT$XCU:00002FF8 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002FF8 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002FF8 _CRT$XCU        ends
.CRT$XCU:00002FF8
.CRT$XCU:00002FFC ; ===========================================================================
.CRT$XCU:00002FFC
.CRT$XCU:00002FFC ; Segment type: Pure data
.CRT$XCU:00002FFC ; Segment permissions: Read
.CRT$XCU:00002FFC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002FFC                 assume cs:_CRT$XCU
.CRT$XCU:00002FFC                 ;org 2FFCh
.CRT$XCU:00002FFC ; COMDAT (pick associative to section at 2D18)
.CRT$XCU:00002FFC ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002FFC ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002FFC _CRT$XCU        ends
.CRT$XCU:00002FFC
.CRT$XCU:00003000 ; ===========================================================================
.CRT$XCU:00003000
.CRT$XCU:00003000 ; Segment type: Pure data
.CRT$XCU:00003000 ; Segment permissions: Read
.CRT$XCU:00003000 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003000                 assume cs:_CRT$XCU
.CRT$XCU:00003000                 ;org 3000h
.CRT$XCU:00003000 ; COMDAT (pick associative to section at 2D1C)
.CRT$XCU:00003000 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00003000 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00003000 _CRT$XCU        ends
.CRT$XCU:00003000
.CRT$XCU:00003004 ; ===========================================================================
.CRT$XCU:00003004
.CRT$XCU:00003004 ; Segment type: Pure data
.CRT$XCU:00003004 ; Segment permissions: Read
.CRT$XCU:00003004 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003004                 assume cs:_CRT$XCU
.CRT$XCU:00003004                 ;org 3004h
.CRT$XCU:00003004 ; COMDAT (pick associative to section at 2DB0)
.CRT$XCU:00003004 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00003004 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00003004 _CRT$XCU        ends
.CRT$XCU:00003004
.CRT$XCU:00003008 ; ===========================================================================
.CRT$XCU:00003008
.CRT$XCU:00003008 ; Segment type: Pure data
.CRT$XCU:00003008 ; Segment permissions: Read
.CRT$XCU:00003008 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003008                 assume cs:_CRT$XCU
.CRT$XCU:00003008                 ;org 3008h
.CRT$XCU:00003008 ; COMDAT (pick associative to section at 2DB4)
.CRT$XCU:00003008 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00003008 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00003008 _CRT$XCU        ends
.CRT$XCU:00003008
UNDEF:00003010 ; ===========================================================================
UNDEF:00003010
UNDEF:00003010 ; Segment type: Externs
UNDEF:00003010 ; UNDEF
UNDEF:00003010                 extrn __purecall:near   ; DATA XREF: .rdata:00002C60o
UNDEF:00003010                                         ; .rdata:00002C64o
UNDEF:00003014 ; void *__cdecl operator new(unsigned int)
UNDEF:00003014                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00003014                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00003018 ; void __cdecl operator delete(void *)
UNDEF:00003018                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00003018                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000301C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000301C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000301C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00003020 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00003020                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00003020                                         ; _wmemcpy+11p
UNDEF:00003024 ; size_t __cdecl strlen(const char *Str)
UNDEF:00003024                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00003028 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00003028                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000302C ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000302C                 extrn __imp__lstrcmpW@8:near
UNDEF:0000302C                                         ; CODE XREF: ListViewCompareProc(long,long,long)+111p
UNDEF:0000302C                                         ; DATA XREF: ListViewCompareProc(long,long,long)+111r
UNDEF:00003030 ; LPWSTR __stdcall lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
UNDEF:00003030                 extrn __imp__lstrcpynW@12:near
UNDEF:00003030                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+30Ep
UNDEF:00003030                                         ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+30Er
UNDEF:00003034 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00003034                 extrn __imp__SendMessageW@16:near
UNDEF:00003034                                         ; CODE XREF: VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)+2Ap
UNDEF:00003034                                         ; VerticalFileSwitcher::activateDoc(TaskLstFnStatus *)+43p ...
UNDEF:00003038 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:00003038                 extrn __imp__MoveWindow@24:near
UNDEF:00003038                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+439p
UNDEF:00003038                                         ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+439r
UNDEF:0000303C ; int __stdcall GetDlgCtrlID(HWND hWnd)
UNDEF:0000303C                 extrn __imp__GetDlgCtrlID@4:near
UNDEF:0000303C                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+297p
UNDEF:0000303C                                         ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+297r
UNDEF:00003040 ; SHORT __stdcall GetKeyState(int nVirtKey)
UNDEF:00003040                 extrn __imp__GetKeyState@4:near
UNDEF:00003040                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+127p
UNDEF:00003040                                         ; VerticalFileSwitcher::run_dlgProc(uint,uint,long)+13Ap
UNDEF:00003040                                         ; DATA XREF: ...
UNDEF:00003044 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003044                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003044                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003048 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003048                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003048                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003048                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:0000304C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00003050 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003050                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003050                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003054 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003054                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003054                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_952p
UNDEF:00003054                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_994p
UNDEF:00003058 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003058                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003058                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000305C ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000305C                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000305C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003060 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003060                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003060                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003064 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003064                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003064                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003064                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003068 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003068                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003068                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000306C ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000306C                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000306C                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00003070 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003070                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003070                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003074 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003074                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003074                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003078 ; void __thiscall VerticalFileSwitcherListView::initList(VerticalFileSwitcherListView *__hidden this)
UNDEF:00003078                 extrn ?initList@VerticalFileSwitcherListView@@QAEXXZ:near
UNDEF:00003078                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+93p
UNDEF:0000307C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall VerticalFileSwitcherListView::getFullFilePath(unsigned int)const
UNDEF:0000307C                 extrn ?getFullFilePath@VerticalFileSwitcherListView@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z:near
UNDEF:0000307C                                         ; CODE XREF: VerticalFileSwitcher::getFullFilePath(uint)+3Dp
UNDEF:00003080 ; void __thiscall VerticalFileSwitcherListView::resizeColumns(VerticalFileSwitcherListView *__hidden this, int)
UNDEF:00003080                 extrn ?resizeColumns@VerticalFileSwitcherListView@@QAEXH@Z:near
UNDEF:00003080                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+449p
UNDEF:00003084 ; __fastcall __security_check_cookie(x)
UNDEF:00003084                 extrn @__security_check_cookie@4:near
UNDEF:00003084                                         ; CODE XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+49Fp
UNDEF:00003084                                         ; ListViewCompareProc(long,long,long)+13Dp ...
UNDEF:00003088 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003088                 extrn __CxxThrowException@8:near
UNDEF:00003088                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:0000308C                 extrn ___CxxFrameHandler3:near
UNDEF:0000308C                                         ; CODE XREF: __ehhandler$?run_dlgProc@VerticalFileSwitcher@@MAGHIIJ@Z+23j
UNDEF:0000308C                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j ...
UNDEF:00003090 ; const type_info::`vftable'
UNDEF:00003090                 extrn ??_7type_info@@6B@:near
UNDEF:00003090                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00003090                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00003094                 extrn ___security_cookie:near
UNDEF:00003094                                         ; DATA XREF: VerticalFileSwitcher::run_dlgProc(uint,uint,long)+17r
UNDEF:00003094                                         ; ListViewCompareProc(long,long,long)+9r ...
UNDEF:00003098                 extrn __fltused:near
UNDEF:00003098
UNDEF:00003098
UNDEF:00003098                 end