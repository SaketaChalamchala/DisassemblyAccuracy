.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 453F1E945F6BA174AB9A84C2E3412852
.rdata:00000000 ; Input CRC32 : 55B420D9
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ContextMenu.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; wchar_t _SG95322
.rdata:00000000 $SG95322        dw 0                    ; DATA XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+55o
.rdata:00000002                 db    0
.rdata:00000003                 db    0
.rdata:00000004 ; wchar_t _SG95325
.rdata:00000004 $SG95325        dw 0                    ; DATA XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+7Co
.rdata:00000006                 db    0
.rdata:00000007                 db    0
.rdata:00000008 ; wchar_t _SG95349
.rdata:00000008 $SG95349        dw 0                    ; DATA XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+4Ao
.rdata:0000000A                 db    0
.rdata:0000000B                 db    0
.rdata:0000000C ; wchar_t _SG96138
.rdata:0000000C $SG96138        dw 0                    ; DATA XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+9Do
.rdata:0000000E                 db    0
.rdata:0000000F                 db    0
.rdata:00000010 ; wchar_t _SG96139
.rdata:00000010 $SG96139        dw 0                    ; DATA XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+B8o
.rdata:00000012                 align 4
.rdata:00000012 _rdata          ends
.rdata:00000012
.text$mn:00000014 ; ===========================================================================
.text$mn:00000014
.text$mn:00000014 ; Segment type: Pure code
.text$mn:00000014 ; Segment permissions: Read/Execute
.text$mn:00000014 _text$mn        segment para public 'CODE' use32
.text$mn:00000014                 assume cs:_text$mn
.text$mn:00000014                 ;org 14h
.text$mn:00000014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000014
.text$mn:00000014 ; =============== S U B R O U T I N E =======================================
.text$mn:00000014
.text$mn:00000014 ; Attributes: bp-based frame
.text$mn:00000014
.text$mn:00000014 ; _DWORD __thiscall MenuItemUnit::MenuItemUnit(MenuItemUnit *this, unsigned __int32, const wchar_t *Str, const wchar_t *)
.text$mn:00000014                 public ??0MenuItemUnit@@QAE@KPB_W0@Z
.text$mn:00000014 ??0MenuItemUnit@@QAE@KPB_W0@Z proc near
.text$mn:00000014
.text$mn:00000014 var_10          = dword ptr -10h
.text$mn:00000014 var_C           = dword ptr -0Ch
.text$mn:00000014 var_4           = dword ptr -4
.text$mn:00000014 arg_0           = dword ptr  8
.text$mn:00000014 Str             = dword ptr  0Ch
.text$mn:00000014 arg_8           = dword ptr  10h
.text$mn:00000014
.text$mn:00000014                 push    ebp
.text$mn:00000015                 mov     ebp, esp
.text$mn:00000017                 push    0FFFFFFFFh
.text$mn:00000019                 push    offset __ehhandler$??0MenuItemUnit@@QAE@KPB_W0@Z
.text$mn:0000001E                 mov     eax, large fs:0
.text$mn:00000024                 push    eax
.text$mn:00000025                 push    ecx
.text$mn:00000026                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000002B                 xor     eax, ebp
.text$mn:0000002D                 push    eax
.text$mn:0000002E                 lea     eax, [ebp+var_C]
.text$mn:00000031                 mov     large fs:0, eax
.text$mn:00000037                 mov     [ebp+var_10], ecx
.text$mn:0000003A                 mov     eax, [ebp+var_10]
.text$mn:0000003D                 mov     ecx, [ebp+arg_0]
.text$mn:00000040                 mov     [eax], ecx
.text$mn:00000042                 mov     ecx, [ebp+var_10]
.text$mn:00000045                 add     ecx, 4
.text$mn:00000048                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000004D                 mov     [ebp+var_4], 0
.text$mn:00000054                 mov     ecx, [ebp+var_10]
.text$mn:00000057                 add     ecx, 20h ; ' '
.text$mn:0000005A                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000005F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000063                 cmp     [ebp+Str], 0
.text$mn:00000067                 jnz     short loc_7B
.text$mn:00000069                 push    offset $SG95322 ; Str
.text$mn:0000006E                 mov     ecx, [ebp+var_10]
.text$mn:00000071                 add     ecx, 4
.text$mn:00000074                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00000079                 jmp     short loc_8A
.text$mn:0000007B ; ---------------------------------------------------------------------------
.text$mn:0000007B
.text$mn:0000007B loc_7B:                                 ; CODE XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+53j
.text$mn:0000007B                 mov     edx, [ebp+Str]
.text$mn:0000007E                 push    edx             ; Str
.text$mn:0000007F                 mov     ecx, [ebp+var_10]
.text$mn:00000082                 add     ecx, 4
.text$mn:00000085                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:0000008A
.text$mn:0000008A loc_8A:                                 ; CODE XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+65j
.text$mn:0000008A                 cmp     [ebp+arg_8], 0
.text$mn:0000008E                 jnz     short loc_A2
.text$mn:00000090                 push    offset $SG95325 ; Str
.text$mn:00000095                 mov     ecx, [ebp+var_10]
.text$mn:00000098                 add     ecx, 20h ; ' '
.text$mn:0000009B                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000000A0                 jmp     short loc_B1
.text$mn:000000A2 ; ---------------------------------------------------------------------------
.text$mn:000000A2
.text$mn:000000A2 loc_A2:                                 ; CODE XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+7Aj
.text$mn:000000A2                 mov     eax, [ebp+arg_8]
.text$mn:000000A5                 push    eax             ; Str
.text$mn:000000A6                 mov     ecx, [ebp+var_10]
.text$mn:000000A9                 add     ecx, 20h ; ' '
.text$mn:000000AC                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000000B1
.text$mn:000000B1 loc_B1:                                 ; CODE XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+8Cj
.text$mn:000000B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000000B8                 mov     eax, [ebp+var_10]
.text$mn:000000BB                 mov     ecx, [ebp+var_C]
.text$mn:000000BE                 mov     large fs:0, ecx
.text$mn:000000C5                 pop     ecx
.text$mn:000000C6                 mov     esp, ebp
.text$mn:000000C8                 pop     ebp
.text$mn:000000C9                 retn    0Ch
.text$mn:000000C9 ??0MenuItemUnit@@QAE@KPB_W0@Z endp
.text$mn:000000C9
.text$mn:000000C9 ; ---------------------------------------------------------------------------
.text$mn:000000CC                 db 8 dup(0CCh)
.text$mn:000000D4
.text$mn:000000D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000000D4
.text$mn:000000D4 ; Attributes: bp-based frame
.text$mn:000000D4
.text$mn:000000D4 ; _DWORD __thiscall ContextMenu::~ContextMenu(ContextMenu *__hidden this)
.text$mn:000000D4                 public ??1ContextMenu@@QAE@XZ
.text$mn:000000D4 ??1ContextMenu@@QAE@XZ proc near
.text$mn:000000D4
.text$mn:000000D4 var_18          = dword ptr -18h
.text$mn:000000D4 var_14          = dword ptr -14h
.text$mn:000000D4 var_10          = dword ptr -10h
.text$mn:000000D4 var_C           = dword ptr -0Ch
.text$mn:000000D4 var_4           = dword ptr -4
.text$mn:000000D4
.text$mn:000000D4                 push    ebp
.text$mn:000000D5                 mov     ebp, esp
.text$mn:000000D7                 push    0FFFFFFFFh
.text$mn:000000D9                 push    offset __ehhandler$??1ContextMenu@@QAE@XZ
.text$mn:000000DE                 mov     eax, large fs:0
.text$mn:000000E4                 push    eax
.text$mn:000000E5                 sub     esp, 0Ch
.text$mn:000000E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000000ED                 xor     eax, ebp
.text$mn:000000EF                 push    eax
.text$mn:000000F0                 lea     eax, [ebp+var_C]
.text$mn:000000F3                 mov     large fs:0, eax
.text$mn:000000F9                 mov     [ebp+var_10], ecx
.text$mn:000000FC                 mov     [ebp+var_4], 0
.text$mn:00000103                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000106                 call    ?isCreated@ContextMenu@@QBE_NXZ ; ContextMenu::isCreated(void)
.text$mn:0000010B                 movzx   eax, al
.text$mn:0000010E                 test    eax, eax
.text$mn:00000110                 jz      short loc_161
.text$mn:00000112                 mov     [ebp+var_14], 0
.text$mn:00000119                 mov     ecx, [ebp+var_10]
.text$mn:0000011C                 add     ecx, 8
.text$mn:0000011F                 call    ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::size(void)
.text$mn:00000124                 mov     [ebp+var_18], eax
.text$mn:00000127                 jmp     short loc_132
.text$mn:00000129 ; ---------------------------------------------------------------------------
.text$mn:00000129
.text$mn:00000129 loc_129:                                ; CODE XREF: ContextMenu::~ContextMenu(void)+7Ej
.text$mn:00000129                 mov     ecx, [ebp+var_14]
.text$mn:0000012C                 add     ecx, 1
.text$mn:0000012F                 mov     [ebp+var_14], ecx
.text$mn:00000132
.text$mn:00000132 loc_132:                                ; CODE XREF: ContextMenu::~ContextMenu(void)+53j
.text$mn:00000132                 mov     edx, [ebp+var_14]
.text$mn:00000135                 cmp     edx, [ebp+var_18]
.text$mn:00000138                 jnb     short loc_154
.text$mn:0000013A                 mov     eax, [ebp+var_14]
.text$mn:0000013D                 push    eax
.text$mn:0000013E                 mov     ecx, [ebp+var_10]
.text$mn:00000141                 add     ecx, 8
.text$mn:00000144                 call    ??A?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEAAPAUHMENU__@@I@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)
.text$mn:00000149                 mov     ecx, [eax]
.text$mn:0000014B                 push    ecx             ; hMenu
.text$mn:0000014C                 call    dword ptr ds:__imp__DestroyMenu@4 ; DestroyMenu(x)
.text$mn:00000152                 jmp     short loc_129
.text$mn:00000154 ; ---------------------------------------------------------------------------
.text$mn:00000154
.text$mn:00000154 loc_154:                                ; CODE XREF: ContextMenu::~ContextMenu(void)+64j
.text$mn:00000154                 mov     edx, [ebp+var_10]
.text$mn:00000157                 mov     eax, [edx+4]
.text$mn:0000015A                 push    eax             ; hMenu
.text$mn:0000015B                 call    dword ptr ds:__imp__DestroyMenu@4 ; DestroyMenu(x)
.text$mn:00000161
.text$mn:00000161 loc_161:                                ; CODE XREF: ContextMenu::~ContextMenu(void)+3Cj
.text$mn:00000161                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000168                 mov     ecx, [ebp+var_10]
.text$mn:0000016B                 add     ecx, 8
.text$mn:0000016E                 call    ??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::~vector<HMENU__ *,std::allocator<HMENU__ *>>(void)
.text$mn:00000173                 mov     ecx, [ebp+var_C]
.text$mn:00000176                 mov     large fs:0, ecx
.text$mn:0000017D                 pop     ecx
.text$mn:0000017E                 mov     esp, ebp
.text$mn:00000180                 pop     ebp
.text$mn:00000181                 retn
.text$mn:00000181 ??1ContextMenu@@QAE@XZ endp
.text$mn:00000181
.text$mn:00000181 ; ---------------------------------------------------------------------------
.text$mn:00000182                 align 4
.text$mn:00000184
.text$mn:00000184 ; =============== S U B R O U T I N E =======================================
.text$mn:00000184
.text$mn:00000184 ; Attributes: bp-based frame
.text$mn:00000184
.text$mn:00000184 ; int __stdcall ContextMenu::create(int, int, HMENU hMenu)
.text$mn:00000184                 public ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z
.text$mn:00000184 ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z proc near
.text$mn:00000184
.text$mn:00000184 var_60          = dword ptr -60h
.text$mn:00000184 var_5C          = dword ptr -5Ch
.text$mn:00000184 var_58          = dword ptr -58h
.text$mn:00000184 var_54          = dword ptr -54h
.text$mn:00000184 var_50          = dword ptr -50h
.text$mn:00000184 uFlags          = dword ptr -4Ch
.text$mn:00000184 var_48          = dword ptr -48h
.text$mn:00000184 uIDNewItem      = dword ptr -44h
.text$mn:00000184 var_40          = dword ptr -40h
.text$mn:00000184 uPosition       = dword ptr -3Ch
.text$mn:00000184 var_36          = byte ptr -36h
.text$mn:00000184 var_35          = byte ptr -35h
.text$mn:00000184 var_34          = dword ptr -34h
.text$mn:00000184 var_2D          = byte ptr -2Dh
.text$mn:00000184 var_2C          = byte ptr -2Ch
.text$mn:00000184 var_10          = dword ptr -10h
.text$mn:00000184 var_C           = dword ptr -0Ch
.text$mn:00000184 var_4           = dword ptr -4
.text$mn:00000184 arg_0           = dword ptr  8
.text$mn:00000184 arg_4           = dword ptr  0Ch
.text$mn:00000184 hMenu           = dword ptr  10h
.text$mn:00000184
.text$mn:00000184                 push    ebp
.text$mn:00000185                 mov     ebp, esp
.text$mn:00000187                 push    0FFFFFFFFh
.text$mn:00000189                 push    offset __ehhandler$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z
.text$mn:0000018E                 mov     eax, large fs:0
.text$mn:00000194                 push    eax
.text$mn:00000195                 sub     esp, 54h
.text$mn:00000198                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000019D                 xor     eax, ebp
.text$mn:0000019F                 mov     [ebp+var_10], eax
.text$mn:000001A2                 push    eax
.text$mn:000001A3                 lea     eax, [ebp+var_C]
.text$mn:000001A6                 mov     large fs:0, eax
.text$mn:000001AC                 mov     [ebp+var_40], ecx
.text$mn:000001AF                 mov     eax, [ebp+var_40]
.text$mn:000001B2                 mov     ecx, [ebp+arg_0]
.text$mn:000001B5                 mov     [eax], ecx
.text$mn:000001B7                 call    dword ptr ds:__imp__CreatePopupMenu@0 ; CreatePopupMenu()
.text$mn:000001BD                 mov     edx, [ebp+var_40]
.text$mn:000001C0                 mov     [edx+4], eax
.text$mn:000001C3                 mov     [ebp+var_2D], 0
.text$mn:000001C7                 mov     [ebp+uIDNewItem], 0
.text$mn:000001CE                 push    offset $SG95349 ; Str
.text$mn:000001D3                 lea     ecx, [ebp+var_2C]
.text$mn:000001D6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000001DB                 mov     [ebp+var_4], 0
.text$mn:000001E2                 mov     [ebp+var_48], 0
.text$mn:000001E9                 mov     [ebp+uPosition], 0
.text$mn:000001F0                 mov     ecx, [ebp+arg_4]
.text$mn:000001F3                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:000001F8                 mov     [ebp+var_5C], eax
.text$mn:000001FB                 jmp     short loc_206
.text$mn:000001FD ; ---------------------------------------------------------------------------
.text$mn:000001FD
.text$mn:000001FD loc_1FD:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const):loc_45Dj
.text$mn:000001FD                 mov     eax, [ebp+uPosition]
.text$mn:00000200                 add     eax, 1
.text$mn:00000203                 mov     [ebp+uPosition], eax
.text$mn:00000206
.text$mn:00000206 loc_206:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+77j
.text$mn:00000206                 mov     ecx, [ebp+uPosition]
.text$mn:00000209                 cmp     ecx, [ebp+var_5C]
.text$mn:0000020C                 jnb     loc_462
.text$mn:00000212                 mov     edx, [ebp+uPosition]
.text$mn:00000215                 push    edx
.text$mn:00000216                 mov     ecx, [ebp+arg_4]
.text$mn:00000219                 call    ??A?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEABUMenuItemUnit@@I@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)
.text$mn:0000021E                 mov     [ebp+var_34], eax
.text$mn:00000221                 push    offset $SG96138 ; Str
.text$mn:00000226                 mov     eax, [ebp+var_34]
.text$mn:00000229                 add     eax, 20h ; ' '
.text$mn:0000022C                 push    eax             ; int
.text$mn:0000022D                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00000232                 add     esp, 8
.text$mn:00000235                 movzx   ecx, al
.text$mn:00000238                 test    ecx, ecx
.text$mn:0000023A                 jz      short loc_259
.text$mn:0000023C                 push    offset $SG96139 ; Str
.text$mn:00000241                 lea     ecx, [ebp+var_2C]
.text$mn:00000244                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00000249                 mov     [ebp+uIDNewItem], 0
.text$mn:00000250                 mov     [ebp+var_48], 0
.text$mn:00000257                 jmp     short loc_2C4
.text$mn:00000259 ; ---------------------------------------------------------------------------
.text$mn:00000259
.text$mn:00000259 loc_259:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+B6j
.text$mn:00000259                 lea     edx, [ebp+var_2C]
.text$mn:0000025C                 push    edx
.text$mn:0000025D                 mov     eax, [ebp+var_34]
.text$mn:00000260                 add     eax, 20h ; ' '
.text$mn:00000263                 push    eax
.text$mn:00000264                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000269                 add     esp, 8
.text$mn:0000026C                 movzx   ecx, al
.text$mn:0000026F                 test    ecx, ecx
.text$mn:00000271                 jz      short loc_2C4
.text$mn:00000273                 mov     edx, [ebp+var_34]
.text$mn:00000276                 add     edx, 20h ; ' '
.text$mn:00000279                 push    edx
.text$mn:0000027A                 lea     ecx, [ebp+var_2C]
.text$mn:0000027D                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000282                 call    dword ptr ds:__imp__CreateMenu@0 ; CreateMenu()
.text$mn:00000288                 mov     [ebp+uIDNewItem], eax
.text$mn:0000028B                 mov     [ebp+var_48], 0
.text$mn:00000292                 lea     eax, [ebp+uIDNewItem]
.text$mn:00000295                 push    eax
.text$mn:00000296                 mov     ecx, [ebp+var_40]
.text$mn:00000299                 add     ecx, 8
.text$mn:0000029C                 call    ?push_back@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXABQAUHMENU__@@@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)
.text$mn:000002A1                 lea     ecx, [ebp+var_2C]
.text$mn:000002A4                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000002A9                 push    eax             ; lpNewItem
.text$mn:000002AA                 mov     ecx, [ebp+uIDNewItem]
.text$mn:000002AD                 push    ecx             ; uIDNewItem
.text$mn:000002AE                 push    410h            ; uFlags
.text$mn:000002B3                 mov     edx, [ebp+uPosition]
.text$mn:000002B6                 push    edx             ; uPosition
.text$mn:000002B7                 mov     eax, [ebp+var_40]
.text$mn:000002BA                 mov     ecx, [eax+4]
.text$mn:000002BD                 push    ecx             ; hMenu
.text$mn:000002BE                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000002C4
.text$mn:000002C4 loc_2C4:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+D3j
.text$mn:000002C4                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+EDj
.text$mn:000002C4                 mov     edx, [ebp+var_34]
.text$mn:000002C7                 cmp     dword ptr [edx], 0
.text$mn:000002CA                 jnz     short loc_2D5
.text$mn:000002CC                 mov     [ebp+var_58], 800h
.text$mn:000002D3                 jmp     short loc_2DC
.text$mn:000002D5 ; ---------------------------------------------------------------------------
.text$mn:000002D5
.text$mn:000002D5 loc_2D5:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+146j
.text$mn:000002D5                 mov     [ebp+var_58], 0
.text$mn:000002DC
.text$mn:000002DC loc_2DC:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+14Fj
.text$mn:000002DC                 mov     eax, [ebp+var_58]
.text$mn:000002DF                 or      eax, 400h
.text$mn:000002E4                 mov     [ebp+uFlags], eax
.text$mn:000002E7                 cmp     [ebp+uIDNewItem], 0
.text$mn:000002EB                 jz      short loc_329
.text$mn:000002ED                 mov     ecx, [ebp+var_48]
.text$mn:000002F0                 mov     [ebp+var_60], ecx
.text$mn:000002F3                 mov     ecx, [ebp+var_34]
.text$mn:000002F6                 add     ecx, 4
.text$mn:000002F9                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000002FE                 push    eax             ; lpNewItem
.text$mn:000002FF                 mov     edx, [ebp+var_34]
.text$mn:00000302                 mov     eax, [edx]
.text$mn:00000304                 push    eax             ; uIDNewItem
.text$mn:00000305                 mov     ecx, [ebp+uFlags]
.text$mn:00000308                 push    ecx             ; uFlags
.text$mn:00000309                 mov     edx, [ebp+var_60]
.text$mn:0000030C                 push    edx             ; uPosition
.text$mn:0000030D                 mov     eax, [ebp+uIDNewItem]
.text$mn:00000310                 push    eax             ; hMenu
.text$mn:00000311                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00000317                 mov     ecx, [ebp+var_48]
.text$mn:0000031A                 add     ecx, 1
.text$mn:0000031D                 mov     [ebp+var_48], ecx
.text$mn:00000320                 mov     [ebp+var_2D], 0
.text$mn:00000324                 jmp     loc_3C3
.text$mn:00000329 ; ---------------------------------------------------------------------------
.text$mn:00000329
.text$mn:00000329 loc_329:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+167j
.text$mn:00000329                 cmp     [ebp+uPosition], 0
.text$mn:0000032D                 jz      short loc_33F
.text$mn:0000032F                 mov     ecx, [ebp+arg_4]
.text$mn:00000332                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:00000337                 sub     eax, 1
.text$mn:0000033A                 cmp     [ebp+uPosition], eax
.text$mn:0000033D                 jnz     short loc_34D
.text$mn:0000033F
.text$mn:0000033F loc_33F:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+1A9j
.text$mn:0000033F                 mov     edx, [ebp+var_34]
.text$mn:00000342                 cmp     dword ptr [edx], 0
.text$mn:00000345                 jnz     short loc_34D
.text$mn:00000347                 mov     [ebp+var_2D], 1
.text$mn:0000034B                 jmp     short loc_3C3
.text$mn:0000034D ; ---------------------------------------------------------------------------
.text$mn:0000034D
.text$mn:0000034D loc_34D:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+1B9j
.text$mn:0000034D                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+1C1j
.text$mn:0000034D                 mov     eax, [ebp+var_34]
.text$mn:00000350                 cmp     dword ptr [eax], 0
.text$mn:00000353                 jz      short loc_382
.text$mn:00000355                 mov     ecx, [ebp+var_34]
.text$mn:00000358                 add     ecx, 4
.text$mn:0000035B                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000360                 push    eax             ; lpNewItem
.text$mn:00000361                 mov     ecx, [ebp+var_34]
.text$mn:00000364                 mov     edx, [ecx]
.text$mn:00000366                 push    edx             ; uIDNewItem
.text$mn:00000367                 mov     eax, [ebp+uFlags]
.text$mn:0000036A                 push    eax             ; uFlags
.text$mn:0000036B                 mov     ecx, [ebp+uPosition]
.text$mn:0000036E                 push    ecx             ; uPosition
.text$mn:0000036F                 mov     edx, [ebp+var_40]
.text$mn:00000372                 mov     eax, [edx+4]
.text$mn:00000375                 push    eax             ; hMenu
.text$mn:00000376                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:0000037C                 mov     [ebp+var_2D], 0
.text$mn:00000380                 jmp     short loc_3C3
.text$mn:00000382 ; ---------------------------------------------------------------------------
.text$mn:00000382
.text$mn:00000382 loc_382:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+1CFj
.text$mn:00000382                 mov     ecx, [ebp+var_34]
.text$mn:00000385                 cmp     dword ptr [ecx], 0
.text$mn:00000388                 jnz     short loc_3BF
.text$mn:0000038A                 movzx   edx, [ebp+var_2D]
.text$mn:0000038E                 test    edx, edx
.text$mn:00000390                 jnz     short loc_3BF
.text$mn:00000392                 mov     ecx, [ebp+var_34]
.text$mn:00000395                 add     ecx, 4
.text$mn:00000398                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000039D                 push    eax             ; lpNewItem
.text$mn:0000039E                 mov     eax, [ebp+var_34]
.text$mn:000003A1                 mov     ecx, [eax]
.text$mn:000003A3                 push    ecx             ; uIDNewItem
.text$mn:000003A4                 mov     edx, [ebp+uFlags]
.text$mn:000003A7                 push    edx             ; uFlags
.text$mn:000003A8                 mov     eax, [ebp+uPosition]
.text$mn:000003AB                 push    eax             ; uPosition
.text$mn:000003AC                 mov     ecx, [ebp+var_40]
.text$mn:000003AF                 mov     edx, [ecx+4]
.text$mn:000003B2                 push    edx             ; hMenu
.text$mn:000003B3                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000003B9                 mov     [ebp+var_2D], 1
.text$mn:000003BD                 jmp     short loc_3C3
.text$mn:000003BF ; ---------------------------------------------------------------------------
.text$mn:000003BF
.text$mn:000003BF loc_3BF:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+204j
.text$mn:000003BF                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+20Cj
.text$mn:000003BF                 mov     [ebp+var_2D], 1
.text$mn:000003C3
.text$mn:000003C3 loc_3C3:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+1A0j
.text$mn:000003C3                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+1C7j ...
.text$mn:000003C3                 cmp     [ebp+hMenu], 0
.text$mn:000003C7                 jz      loc_45D
.text$mn:000003CD                 push    0               ; uFlags
.text$mn:000003CF                 mov     eax, [ebp+var_34]
.text$mn:000003D2                 mov     ecx, [eax]
.text$mn:000003D4                 push    ecx             ; uId
.text$mn:000003D5                 mov     edx, [ebp+hMenu]
.text$mn:000003D8                 push    edx             ; hMenu
.text$mn:000003D9                 call    dword ptr ds:__imp__GetMenuState@12 ; GetMenuState(x,x,x)
.text$mn:000003DF                 and     eax, 3
.text$mn:000003E2                 jnz     short loc_3ED
.text$mn:000003E4                 mov     [ebp+var_54], 1
.text$mn:000003EB                 jmp     short loc_3F4
.text$mn:000003ED ; ---------------------------------------------------------------------------
.text$mn:000003ED
.text$mn:000003ED loc_3ED:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+25Ej
.text$mn:000003ED                 mov     [ebp+var_54], 0
.text$mn:000003F4
.text$mn:000003F4 loc_3F4:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+267j
.text$mn:000003F4                 mov     al, byte ptr [ebp+var_54]
.text$mn:000003F7                 mov     [ebp+var_35], al
.text$mn:000003FA                 push    0               ; uFlags
.text$mn:000003FC                 mov     ecx, [ebp+var_34]
.text$mn:000003FF                 mov     edx, [ecx]
.text$mn:00000401                 push    edx             ; uId
.text$mn:00000402                 mov     eax, [ebp+hMenu]
.text$mn:00000405                 push    eax             ; hMenu
.text$mn:00000406                 call    dword ptr ds:__imp__GetMenuState@12 ; GetMenuState(x,x,x)
.text$mn:0000040C                 and     eax, 8
.text$mn:0000040F                 jz      short loc_41A
.text$mn:00000411                 mov     [ebp+var_50], 1
.text$mn:00000418                 jmp     short loc_421
.text$mn:0000041A ; ---------------------------------------------------------------------------
.text$mn:0000041A
.text$mn:0000041A loc_41A:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+28Bj
.text$mn:0000041A                 mov     [ebp+var_50], 0
.text$mn:00000421
.text$mn:00000421 loc_421:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+294j
.text$mn:00000421                 mov     cl, byte ptr [ebp+var_50]
.text$mn:00000424                 mov     [ebp+var_36], cl
.text$mn:00000427                 movzx   edx, [ebp+var_35]
.text$mn:0000042B                 test    edx, edx
.text$mn:0000042D                 jnz     short loc_442
.text$mn:0000042F                 movzx   eax, [ebp+var_35]
.text$mn:00000433                 push    eax             ; bool
.text$mn:00000434                 mov     ecx, [ebp+var_34]
.text$mn:00000437                 mov     edx, [ecx]
.text$mn:00000439                 push    edx             ; uIDEnableItem
.text$mn:0000043A                 mov     ecx, [ebp+var_40] ; this
.text$mn:0000043D                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:00000442
.text$mn:00000442 loc_442:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+2A9j
.text$mn:00000442                 movzx   eax, [ebp+var_36]
.text$mn:00000446                 test    eax, eax
.text$mn:00000448                 jz      short loc_45D
.text$mn:0000044A                 movzx   ecx, [ebp+var_36]
.text$mn:0000044E                 push    ecx             ; bool
.text$mn:0000044F                 mov     edx, [ebp+var_34]
.text$mn:00000452                 mov     eax, [edx]
.text$mn:00000454                 push    eax             ; uIDCheckItem
.text$mn:00000455                 mov     ecx, [ebp+var_40] ; this
.text$mn:00000458                 call    ?checkItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::checkItem(int,bool)
.text$mn:0000045D
.text$mn:0000045D loc_45D:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+243j
.text$mn:0000045D                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+2C4j
.text$mn:0000045D                 jmp     loc_1FD
.text$mn:00000462 ; ---------------------------------------------------------------------------
.text$mn:00000462
.text$mn:00000462 loc_462:                                ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+88j
.text$mn:00000462                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000469                 lea     ecx, [ebp+var_2C]
.text$mn:0000046C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000471                 mov     ecx, [ebp+var_C]
.text$mn:00000474                 mov     large fs:0, ecx
.text$mn:0000047B                 pop     ecx
.text$mn:0000047C                 mov     ecx, [ebp+var_10]
.text$mn:0000047F                 xor     ecx, ebp
.text$mn:00000481                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000486                 mov     esp, ebp
.text$mn:00000488                 pop     ebp
.text$mn:00000489                 retn    0Ch
.text$mn:00000489 ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z endp
.text$mn:00000489
.text$mn:00000489 _text$mn        ends
.text$mn:00000489
.text$x:0000048C ; ===========================================================================
.text$x:0000048C
.text$x:0000048C ; Segment type: Pure code
.text$x:0000048C ; Segment permissions: Read/Execute
.text$x:0000048C _text$x         segment para public 'CODE' use32
.text$x:0000048C                 assume cs:_text$x
.text$x:0000048C                 ;org 48Ch
.text$x:0000048C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000048C
.text$x:0000048C ; =============== S U B R O U T I N E =======================================
.text$x:0000048C
.text$x:0000048C
.text$x:0000048C __unwindfunclet$??0MenuItemUnit@@QAE@KPB_W0@Z$0 proc near
.text$x:0000048C                                         ; DATA XREF: .xdata$x:00004430o
.text$x:0000048C                 mov     ecx, [ebp-10h]
.text$x:0000048F                 add     ecx, 4
.text$x:00000492                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000492 __unwindfunclet$??0MenuItemUnit@@QAE@KPB_W0@Z$0 endp
.text$x:00000492
.text$x:00000497
.text$x:00000497 ; =============== S U B R O U T I N E =======================================
.text$x:00000497
.text$x:00000497
.text$x:00000497 __unwindfunclet$??0MenuItemUnit@@QAE@KPB_W0@Z$1 proc near
.text$x:00000497                                         ; DATA XREF: .xdata$x:00004438o
.text$x:00000497                 mov     ecx, [ebp-10h]
.text$x:0000049A                 add     ecx, 20h ; ' '
.text$x:0000049D                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000049D __unwindfunclet$??0MenuItemUnit@@QAE@KPB_W0@Z$1 endp
.text$x:0000049D
.text$x:000004A2
.text$x:000004A2 ; =============== S U B R O U T I N E =======================================
.text$x:000004A2
.text$x:000004A2
.text$x:000004A2 __ehhandler$??0MenuItemUnit@@QAE@KPB_W0@Z proc near
.text$x:000004A2                                         ; DATA XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+5o
.text$x:000004A2
.text$x:000004A2 arg_4           = dword ptr  8
.text$x:000004A2
.text$x:000004A2                 mov     edx, [esp+arg_4]
.text$x:000004A6                 lea     eax, [edx+0Ch]
.text$x:000004A9                 mov     ecx, [edx-8]
.text$x:000004AC                 xor     ecx, eax
.text$x:000004AE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004B3                 mov     eax, offset __ehfuncinfo$??0MenuItemUnit@@QAE@KPB_W0@Z
.text$x:000004B8                 jmp     ___CxxFrameHandler3
.text$x:000004B8 __ehhandler$??0MenuItemUnit@@QAE@KPB_W0@Z endp
.text$x:000004B8
.text$x:000004BD
.text$x:000004BD ; =============== S U B R O U T I N E =======================================
.text$x:000004BD
.text$x:000004BD
.text$x:000004BD __unwindfunclet$??1ContextMenu@@QAE@XZ$0 proc near
.text$x:000004BD                                         ; DATA XREF: .xdata$x:00004428o
.text$x:000004BD                 mov     ecx, [ebp-10h]
.text$x:000004C0                 add     ecx, 8
.text$x:000004C3                 jmp     ??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::~vector<HMENU__ *,std::allocator<HMENU__ *>>(void)
.text$x:000004C3 __unwindfunclet$??1ContextMenu@@QAE@XZ$0 endp
.text$x:000004C3
.text$x:000004C8
.text$x:000004C8 ; =============== S U B R O U T I N E =======================================
.text$x:000004C8
.text$x:000004C8
.text$x:000004C8 __ehhandler$??1ContextMenu@@QAE@XZ proc near
.text$x:000004C8                                         ; DATA XREF: ContextMenu::~ContextMenu(void)+5o
.text$x:000004C8
.text$x:000004C8 arg_4           = dword ptr  8
.text$x:000004C8
.text$x:000004C8                 mov     edx, [esp+arg_4]
.text$x:000004CC                 lea     eax, [edx+0Ch]
.text$x:000004CF                 mov     ecx, [edx-10h]
.text$x:000004D2                 xor     ecx, eax
.text$x:000004D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004D9                 mov     eax, offset __ehfuncinfo$??1ContextMenu@@QAE@XZ
.text$x:000004DE                 jmp     ___CxxFrameHandler3
.text$x:000004DE __ehhandler$??1ContextMenu@@QAE@XZ endp
.text$x:000004DE
.text$x:000004E3
.text$x:000004E3 ; =============== S U B R O U T I N E =======================================
.text$x:000004E3
.text$x:000004E3
.text$x:000004E3 __unwindfunclet$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z$0 proc near
.text$x:000004E3                                         ; DATA XREF: .xdata$x:00004420o
.text$x:000004E3                 lea     ecx, [ebp-2Ch]
.text$x:000004E6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000004E6 __unwindfunclet$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z$0 endp
.text$x:000004E6
.text$x:000004EB
.text$x:000004EB ; =============== S U B R O U T I N E =======================================
.text$x:000004EB
.text$x:000004EB
.text$x:000004EB __ehhandler$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z proc near
.text$x:000004EB                                         ; DATA XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+5o
.text$x:000004EB
.text$x:000004EB arg_4           = dword ptr  8
.text$x:000004EB
.text$x:000004EB                 mov     edx, [esp+arg_4]
.text$x:000004EF                 lea     eax, [edx+0Ch]
.text$x:000004F2                 mov     ecx, [edx-58h]
.text$x:000004F5                 xor     ecx, eax
.text$x:000004F7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004FC                 mov     ecx, [edx-4]
.text$x:000004FF                 xor     ecx, eax
.text$x:00000501                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000506                 mov     eax, offset __ehfuncinfo$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z
.text$x:0000050B                 jmp     ___CxxFrameHandler3
.text$x:0000050B __ehhandler$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z endp
.text$x:0000050B
.text$x:0000050B _text$x         ends
.text$x:0000050B
.text$mn:00000510 ; ===========================================================================
.text$mn:00000510
.text$mn:00000510 ; Segment type: Pure code
.text$mn:00000510 ; Segment permissions: Read/Execute
.text$mn:00000510 _text$mn        segment para public 'CODE' use32
.text$mn:00000510                 assume cs:_text$mn
.text$mn:00000510                 ;org 510h
.text$mn:00000510 ; COMDAT (pick any)
.text$mn:00000510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000510
.text$mn:00000510 ; =============== S U B R O U T I N E =======================================
.text$mn:00000510
.text$mn:00000510 ; Attributes: bp-based frame
.text$mn:00000510
.text$mn:00000510 ; bool __cdecl std::operator==<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00000510                 public ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00000510 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00000510                                         ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Cp
.text$mn:00000510
.text$mn:00000510 var_2           = byte ptr -2
.text$mn:00000510 var_1           = byte ptr -1
.text$mn:00000510 arg_0           = dword ptr  8
.text$mn:00000510 arg_4           = dword ptr  0Ch
.text$mn:00000510
.text$mn:00000510                 push    ebp
.text$mn:00000511                 mov     ebp, esp
.text$mn:00000513                 push    ecx
.text$mn:00000514                 mov     eax, [ebp+arg_4]
.text$mn:00000517                 push    eax
.text$mn:00000518                 lea     ecx, [ebp+var_1]
.text$mn:0000051B                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00000520                 push    eax
.text$mn:00000521                 mov     ecx, [ebp+arg_0]
.text$mn:00000524                 push    ecx
.text$mn:00000525                 lea     ecx, [ebp+var_2]
.text$mn:00000528                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000052D                 push    eax
.text$mn:0000052E                 call    ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>(std::allocator<wchar_t> const &,std::allocator<wchar_t> const &)
.text$mn:00000533                 add     esp, 8
.text$mn:00000536                 mov     esp, ebp
.text$mn:00000538                 pop     ebp
.text$mn:00000539                 retn
.text$mn:00000539 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00000539
.text$mn:00000539 ; ---------------------------------------------------------------------------
.text$mn:0000053A                 align 4
.text$mn:0000053A _text$mn        ends
.text$mn:0000053A
.text$mn:0000053C ; ===========================================================================
.text$mn:0000053C
.text$mn:0000053C ; Segment type: Pure code
.text$mn:0000053C ; Segment permissions: Read/Execute
.text$mn:0000053C _text$mn        segment para public 'CODE' use32
.text$mn:0000053C                 assume cs:_text$mn
.text$mn:0000053C                 ;org 53Ch
.text$mn:0000053C ; COMDAT (pick any)
.text$mn:0000053C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000053C
.text$mn:0000053C ; =============== S U B R O U T I N E =======================================
.text$mn:0000053C
.text$mn:0000053C ; Attributes: bp-based frame
.text$mn:0000053C
.text$mn:0000053C ; bool __cdecl std::operator==<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000053C                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
.text$mn:0000053C ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z proc near
.text$mn:0000053C                                         ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Cp
.text$mn:0000053C
.text$mn:0000053C var_4           = dword ptr -4
.text$mn:0000053C arg_0           = dword ptr  8
.text$mn:0000053C arg_4           = dword ptr  0Ch
.text$mn:0000053C
.text$mn:0000053C                 push    ebp
.text$mn:0000053D                 mov     ebp, esp
.text$mn:0000053F                 push    ecx
.text$mn:00000540                 mov     eax, [ebp+arg_4]
.text$mn:00000543                 push    eax
.text$mn:00000544                 mov     ecx, [ebp+arg_0]
.text$mn:00000547                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000054C                 test    eax, eax
.text$mn:0000054E                 jnz     short loc_559
.text$mn:00000550                 mov     [ebp+var_4], 1
.text$mn:00000557                 jmp     short loc_560
.text$mn:00000559 ; ---------------------------------------------------------------------------
.text$mn:00000559
.text$mn:00000559 loc_559:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+12j
.text$mn:00000559                 mov     [ebp+var_4], 0
.text$mn:00000560
.text$mn:00000560 loc_560:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1Bj
.text$mn:00000560                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000563                 mov     esp, ebp
.text$mn:00000565                 pop     ebp
.text$mn:00000566                 retn
.text$mn:00000566 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z endp
.text$mn:00000566
.text$mn:00000566 ; ---------------------------------------------------------------------------
.text$mn:00000567                 align 4
.text$mn:00000567 _text$mn        ends
.text$mn:00000567
.text$mn:00000568 ; ===========================================================================
.text$mn:00000568
.text$mn:00000568 ; Segment type: Pure code
.text$mn:00000568 ; Segment permissions: Read/Execute
.text$mn:00000568 _text$mn        segment para public 'CODE' use32
.text$mn:00000568                 assume cs:_text$mn
.text$mn:00000568                 ;org 568h
.text$mn:00000568 ; COMDAT (pick any)
.text$mn:00000568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000568
.text$mn:00000568 ; =============== S U B R O U T I N E =======================================
.text$mn:00000568
.text$mn:00000568 ; Attributes: bp-based frame
.text$mn:00000568
.text$mn:00000568 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00000568                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00000568 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00000568                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+A9p
.text$mn:00000568
.text$mn:00000568 var_4           = dword ptr -4
.text$mn:00000568 arg_0           = dword ptr  8
.text$mn:00000568 Str             = dword ptr  0Ch
.text$mn:00000568
.text$mn:00000568                 push    ebp
.text$mn:00000569                 mov     ebp, esp
.text$mn:0000056B                 push    ecx
.text$mn:0000056C                 mov     eax, [ebp+Str]
.text$mn:0000056F                 push    eax             ; Str
.text$mn:00000570                 mov     ecx, [ebp+arg_0]
.text$mn:00000573                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:00000578                 test    eax, eax
.text$mn:0000057A                 jnz     short loc_585
.text$mn:0000057C                 mov     [ebp+var_4], 1
.text$mn:00000583                 jmp     short loc_58C
.text$mn:00000585 ; ---------------------------------------------------------------------------
.text$mn:00000585
.text$mn:00000585 loc_585:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:00000585                 mov     [ebp+var_4], 0
.text$mn:0000058C
.text$mn:0000058C loc_58C:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:0000058C                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000058F                 mov     esp, ebp
.text$mn:00000591                 pop     ebp
.text$mn:00000592                 retn
.text$mn:00000592 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00000592
.text$mn:00000592 ; ---------------------------------------------------------------------------
.text$mn:00000593                 align 4
.text$mn:00000593 _text$mn        ends
.text$mn:00000593
.text$mn:00000594 ; ===========================================================================
.text$mn:00000594
.text$mn:00000594 ; Segment type: Pure code
.text$mn:00000594 ; Segment permissions: Read/Execute
.text$mn:00000594 _text$mn        segment para public 'CODE' use32
.text$mn:00000594                 assume cs:_text$mn
.text$mn:00000594                 ;org 594h
.text$mn:00000594 ; COMDAT (pick any)
.text$mn:00000594                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000594
.text$mn:00000594 ; =============== S U B R O U T I N E =======================================
.text$mn:00000594
.text$mn:00000594 ; Attributes: bp-based frame
.text$mn:00000594
.text$mn:00000594 ; bool __cdecl std::operator==<wchar_t, wchar_t>(class std::allocator<wchar_t> const &, class std::allocator<wchar_t> const &)
.text$mn:00000594                 public ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
.text$mn:00000594 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z proc near
.text$mn:00000594                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+1Ep
.text$mn:00000594                 push    ebp
.text$mn:00000595                 mov     ebp, esp
.text$mn:00000597                 mov     al, 1
.text$mn:00000599                 pop     ebp
.text$mn:0000059A                 retn
.text$mn:0000059A ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z endp
.text$mn:0000059A
.text$mn:0000059A ; ---------------------------------------------------------------------------
.text$mn:0000059B                 align 4
.text$mn:0000059B _text$mn        ends
.text$mn:0000059B
.text$mn:0000059C ; ===========================================================================
.text$mn:0000059C
.text$mn:0000059C ; Segment type: Pure code
.text$mn:0000059C ; Segment permissions: Read/Execute
.text$mn:0000059C _text$mn        segment para public 'CODE' use32
.text$mn:0000059C                 assume cs:_text$mn
.text$mn:0000059C                 ;org 59Ch
.text$mn:0000059C ; COMDAT (pick any)
.text$mn:0000059C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000059C
.text$mn:0000059C ; =============== S U B R O U T I N E =======================================
.text$mn:0000059C
.text$mn:0000059C ; Attributes: bp-based frame
.text$mn:0000059C
.text$mn:0000059C ; bool __cdecl std::operator!=<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:0000059C                 public ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:0000059C ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:0000059C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Bp
.text$mn:0000059C
.text$mn:0000059C var_4           = dword ptr -4
.text$mn:0000059C arg_0           = dword ptr  8
.text$mn:0000059C arg_4           = dword ptr  0Ch
.text$mn:0000059C
.text$mn:0000059C                 push    ebp
.text$mn:0000059D                 mov     ebp, esp
.text$mn:0000059F                 push    ecx
.text$mn:000005A0                 mov     eax, [ebp+arg_4]
.text$mn:000005A3                 push    eax
.text$mn:000005A4                 mov     ecx, [ebp+arg_0]
.text$mn:000005A7                 push    ecx
.text$mn:000005A8                 call    ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:000005AD                 add     esp, 8
.text$mn:000005B0                 movzx   edx, al
.text$mn:000005B3                 test    edx, edx
.text$mn:000005B5                 jnz     short loc_5C0
.text$mn:000005B7                 mov     [ebp+var_4], 1
.text$mn:000005BE                 jmp     short loc_5C7
.text$mn:000005C0 ; ---------------------------------------------------------------------------
.text$mn:000005C0
.text$mn:000005C0 loc_5C0:                                ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+19j
.text$mn:000005C0                 mov     [ebp+var_4], 0
.text$mn:000005C7
.text$mn:000005C7 loc_5C7:                                ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+22j
.text$mn:000005C7                 mov     al, byte ptr [ebp+var_4]
.text$mn:000005CA                 mov     esp, ebp
.text$mn:000005CC                 pop     ebp
.text$mn:000005CD                 retn
.text$mn:000005CD ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:000005CD
.text$mn:000005CD ; ---------------------------------------------------------------------------
.text$mn:000005CE                 align 10h
.text$mn:000005CE _text$mn        ends
.text$mn:000005CE
.text$mn:000005D0 ; ===========================================================================
.text$mn:000005D0
.text$mn:000005D0 ; Segment type: Pure code
.text$mn:000005D0 ; Segment permissions: Read/Execute
.text$mn:000005D0 _text$mn        segment para public 'CODE' use32
.text$mn:000005D0                 assume cs:_text$mn
.text$mn:000005D0                 ;org 5D0h
.text$mn:000005D0 ; COMDAT (pick any)
.text$mn:000005D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005D0
.text$mn:000005D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000005D0
.text$mn:000005D0 ; Attributes: bp-based frame
.text$mn:000005D0
.text$mn:000005D0 ; bool __cdecl std::operator!=<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:000005D0                 public ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
.text$mn:000005D0 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z proc near
.text$mn:000005D0                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+E0p
.text$mn:000005D0
.text$mn:000005D0 var_4           = dword ptr -4
.text$mn:000005D0 arg_0           = dword ptr  8
.text$mn:000005D0 arg_4           = dword ptr  0Ch
.text$mn:000005D0
.text$mn:000005D0                 push    ebp
.text$mn:000005D1                 mov     ebp, esp
.text$mn:000005D3                 push    ecx
.text$mn:000005D4                 mov     eax, [ebp+arg_4]
.text$mn:000005D7                 push    eax
.text$mn:000005D8                 mov     ecx, [ebp+arg_0]
.text$mn:000005DB                 push    ecx
.text$mn:000005DC                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000005E1                 add     esp, 8
.text$mn:000005E4                 movzx   edx, al
.text$mn:000005E7                 test    edx, edx
.text$mn:000005E9                 jnz     short loc_5F4
.text$mn:000005EB                 mov     [ebp+var_4], 1
.text$mn:000005F2                 jmp     short loc_5FB
.text$mn:000005F4 ; ---------------------------------------------------------------------------
.text$mn:000005F4
.text$mn:000005F4 loc_5F4:                                ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+19j
.text$mn:000005F4                 mov     [ebp+var_4], 0
.text$mn:000005FB
.text$mn:000005FB loc_5FB:                                ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+22j
.text$mn:000005FB                 mov     al, byte ptr [ebp+var_4]
.text$mn:000005FE                 mov     esp, ebp
.text$mn:00000600                 pop     ebp
.text$mn:00000601                 retn
.text$mn:00000601 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z endp
.text$mn:00000601
.text$mn:00000601 ; ---------------------------------------------------------------------------
.text$mn:00000602                 align 4
.text$mn:00000602 _text$mn        ends
.text$mn:00000602
.text$mn:00000604 ; ===========================================================================
.text$mn:00000604
.text$mn:00000604 ; Segment type: Pure code
.text$mn:00000604 ; Segment permissions: Read/Execute
.text$mn:00000604 _text$mn        segment para public 'CODE' use32
.text$mn:00000604                 assume cs:_text$mn
.text$mn:00000604                 ;org 604h
.text$mn:00000604 ; COMDAT (pick any)
.text$mn:00000604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000604
.text$mn:00000604 ; =============== S U B R O U T I N E =======================================
.text$mn:00000604
.text$mn:00000604 ; Attributes: bp-based frame
.text$mn:00000604
.text$mn:00000604 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000604                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000604 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000604                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000604
.text$mn:00000604 var_4           = dword ptr -4
.text$mn:00000604 arg_0           = dword ptr  8
.text$mn:00000604
.text$mn:00000604                 push    ebp
.text$mn:00000605                 mov     ebp, esp
.text$mn:00000607                 push    ecx
.text$mn:00000608                 mov     [ebp+var_4], 0
.text$mn:0000060F                 cmp     [ebp+arg_0], 0
.text$mn:00000613                 jnz     short loc_617
.text$mn:00000615                 jmp     short loc_637
.text$mn:00000617 ; ---------------------------------------------------------------------------
.text$mn:00000617
.text$mn:00000617 loc_617:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000617                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000061B                 ja      short loc_632
.text$mn:0000061D                 mov     eax, [ebp+arg_0]
.text$mn:00000620                 push    eax             ; unsigned int
.text$mn:00000621                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000626                 add     esp, 4
.text$mn:00000629                 mov     [ebp+var_4], eax
.text$mn:0000062C                 cmp     [ebp+var_4], 0
.text$mn:00000630                 jnz     short loc_637
.text$mn:00000632
.text$mn:00000632 loc_632:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00000632                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000637
.text$mn:00000637 loc_637:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000637                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000637                 mov     eax, [ebp+var_4]
.text$mn:0000063A                 mov     esp, ebp
.text$mn:0000063C                 pop     ebp
.text$mn:0000063D                 retn
.text$mn:0000063D ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:0000063D
.text$mn:0000063D ; ---------------------------------------------------------------------------
.text$mn:0000063E                 align 10h
.text$mn:0000063E _text$mn        ends
.text$mn:0000063E
.text$mn:00000640 ; ===========================================================================
.text$mn:00000640
.text$mn:00000640 ; Segment type: Pure code
.text$mn:00000640 ; Segment permissions: Read/Execute
.text$mn:00000640 _text$mn        segment para public 'CODE' use32
.text$mn:00000640                 assume cs:_text$mn
.text$mn:00000640                 ;org 640h
.text$mn:00000640 ; COMDAT (pick any)
.text$mn:00000640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000640
.text$mn:00000640 ; =============== S U B R O U T I N E =======================================
.text$mn:00000640
.text$mn:00000640 ; Attributes: bp-based frame
.text$mn:00000640
.text$mn:00000640 ; struct HMENU__ * * __cdecl std::_Allocate<struct HMENU__ *>(unsigned int, struct HMENU__ * *)
.text$mn:00000640                 public ??$_Allocate@PAUHMENU__@@@std@@YAPAPAUHMENU__@@IPAPAU1@@Z
.text$mn:00000640 ??$_Allocate@PAUHMENU__@@@std@@YAPAPAUHMENU__@@IPAPAU1@@Z proc near
.text$mn:00000640                                         ; CODE XREF: std::allocator<HMENU__ *>::allocate(uint)+Dp
.text$mn:00000640
.text$mn:00000640 var_4           = dword ptr -4
.text$mn:00000640 arg_0           = dword ptr  8
.text$mn:00000640
.text$mn:00000640                 push    ebp
.text$mn:00000641                 mov     ebp, esp
.text$mn:00000643                 push    ecx
.text$mn:00000644                 mov     [ebp+var_4], 0
.text$mn:0000064B                 cmp     [ebp+arg_0], 0
.text$mn:0000064F                 jnz     short loc_653
.text$mn:00000651                 jmp     short loc_679
.text$mn:00000653 ; ---------------------------------------------------------------------------
.text$mn:00000653
.text$mn:00000653 loc_653:                                ; CODE XREF: std::_Allocate<HMENU__ *>(uint,HMENU__ * *)+Fj
.text$mn:00000653                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:0000065A                 ja      short loc_674
.text$mn:0000065C                 mov     eax, [ebp+arg_0]
.text$mn:0000065F                 shl     eax, 2
.text$mn:00000662                 push    eax             ; unsigned int
.text$mn:00000663                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000668                 add     esp, 4
.text$mn:0000066B                 mov     [ebp+var_4], eax
.text$mn:0000066E                 cmp     [ebp+var_4], 0
.text$mn:00000672                 jnz     short loc_679
.text$mn:00000674
.text$mn:00000674 loc_674:                                ; CODE XREF: std::_Allocate<HMENU__ *>(uint,HMENU__ * *)+1Aj
.text$mn:00000674                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000679
.text$mn:00000679 loc_679:                                ; CODE XREF: std::_Allocate<HMENU__ *>(uint,HMENU__ * *)+11j
.text$mn:00000679                                         ; std::_Allocate<HMENU__ *>(uint,HMENU__ * *)+32j
.text$mn:00000679                 mov     eax, [ebp+var_4]
.text$mn:0000067C                 mov     esp, ebp
.text$mn:0000067E                 pop     ebp
.text$mn:0000067F                 retn
.text$mn:0000067F ??$_Allocate@PAUHMENU__@@@std@@YAPAPAUHMENU__@@IPAPAU1@@Z endp
.text$mn:0000067F
.text$mn:0000067F _text$mn        ends
.text$mn:0000067F
.text$mn:00000680 ; ===========================================================================
.text$mn:00000680
.text$mn:00000680 ; Segment type: Pure code
.text$mn:00000680 ; Segment permissions: Read/Execute
.text$mn:00000680 _text$mn        segment para public 'CODE' use32
.text$mn:00000680                 assume cs:_text$mn
.text$mn:00000680                 ;org 680h
.text$mn:00000680 ; COMDAT (pick any)
.text$mn:00000680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000680
.text$mn:00000680 ; =============== S U B R O U T I N E =======================================
.text$mn:00000680
.text$mn:00000680 ; Attributes: bp-based frame
.text$mn:00000680
.text$mn:00000680 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000680                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000680 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000680                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000680
.text$mn:00000680 var_4           = dword ptr -4
.text$mn:00000680 arg_0           = dword ptr  8
.text$mn:00000680
.text$mn:00000680                 push    ebp
.text$mn:00000681                 mov     ebp, esp
.text$mn:00000683                 push    ecx
.text$mn:00000684                 mov     [ebp+var_4], 0
.text$mn:0000068B                 cmp     [ebp+arg_0], 0
.text$mn:0000068F                 jnz     short loc_693
.text$mn:00000691                 jmp     short loc_6B9
.text$mn:00000693 ; ---------------------------------------------------------------------------
.text$mn:00000693
.text$mn:00000693 loc_693:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000693                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000069A                 ja      short loc_6B4
.text$mn:0000069C                 mov     eax, [ebp+arg_0]
.text$mn:0000069F                 shl     eax, 3
.text$mn:000006A2                 push    eax             ; unsigned int
.text$mn:000006A3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000006A8                 add     esp, 4
.text$mn:000006AB                 mov     [ebp+var_4], eax
.text$mn:000006AE                 cmp     [ebp+var_4], 0
.text$mn:000006B2                 jnz     short loc_6B9
.text$mn:000006B4
.text$mn:000006B4 loc_6B4:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000006B4                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000006B9
.text$mn:000006B9 loc_6B9:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000006B9                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000006B9                 mov     eax, [ebp+var_4]
.text$mn:000006BC                 mov     esp, ebp
.text$mn:000006BE                 pop     ebp
.text$mn:000006BF                 retn
.text$mn:000006BF ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000006BF
.text$mn:000006BF _text$mn        ends
.text$mn:000006BF
.text$mn:000006C0 ; ===========================================================================
.text$mn:000006C0
.text$mn:000006C0 ; Segment type: Pure code
.text$mn:000006C0 ; Segment permissions: Read/Execute
.text$mn:000006C0 _text$mn        segment para public 'CODE' use32
.text$mn:000006C0                 assume cs:_text$mn
.text$mn:000006C0                 ;org 6C0h
.text$mn:000006C0 ; COMDAT (pick any)
.text$mn:000006C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006C0
.text$mn:000006C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006C0
.text$mn:000006C0 ; Attributes: bp-based frame
.text$mn:000006C0
.text$mn:000006C0 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:000006C0                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:000006C0 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:000006C0                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:000006C0
.text$mn:000006C0 var_4           = dword ptr -4
.text$mn:000006C0 arg_0           = dword ptr  8
.text$mn:000006C0
.text$mn:000006C0                 push    ebp
.text$mn:000006C1                 mov     ebp, esp
.text$mn:000006C3                 push    ecx
.text$mn:000006C4                 mov     [ebp+var_4], 0
.text$mn:000006CB                 cmp     [ebp+arg_0], 0
.text$mn:000006CF                 jnz     short loc_6D3
.text$mn:000006D1                 jmp     short loc_6F8
.text$mn:000006D3 ; ---------------------------------------------------------------------------
.text$mn:000006D3
.text$mn:000006D3 loc_6D3:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:000006D3                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:000006DA                 ja      short loc_6F3
.text$mn:000006DC                 mov     eax, [ebp+arg_0]
.text$mn:000006DF                 shl     eax, 1
.text$mn:000006E1                 push    eax             ; unsigned int
.text$mn:000006E2                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000006E7                 add     esp, 4
.text$mn:000006EA                 mov     [ebp+var_4], eax
.text$mn:000006ED                 cmp     [ebp+var_4], 0
.text$mn:000006F1                 jnz     short loc_6F8
.text$mn:000006F3
.text$mn:000006F3 loc_6F3:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:000006F3                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000006F8
.text$mn:000006F8 loc_6F8:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:000006F8                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:000006F8                 mov     eax, [ebp+var_4]
.text$mn:000006FB                 mov     esp, ebp
.text$mn:000006FD                 pop     ebp
.text$mn:000006FE                 retn
.text$mn:000006FE ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:000006FE
.text$mn:000006FE ; ---------------------------------------------------------------------------
.text$mn:000006FF                 align 10h
.text$mn:000006FF _text$mn        ends
.text$mn:000006FF
.text$mn:00000700 ; ===========================================================================
.text$mn:00000700
.text$mn:00000700 ; Segment type: Pure code
.text$mn:00000700 ; Segment permissions: Read/Execute
.text$mn:00000700 _text$mn        segment para public 'CODE' use32
.text$mn:00000700                 assume cs:_text$mn
.text$mn:00000700                 ;org 700h
.text$mn:00000700 ; COMDAT (pick any)
.text$mn:00000700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000700
.text$mn:00000700 ; =============== S U B R O U T I N E =======================================
.text$mn:00000700
.text$mn:00000700 ; Attributes: bp-based frame
.text$mn:00000700
.text$mn:00000700 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000700                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000700 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000700                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000700                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000700
.text$mn:00000700 arg_0           = dword ptr  8
.text$mn:00000700 arg_4           = dword ptr  0Ch
.text$mn:00000700 arg_8           = dword ptr  10h
.text$mn:00000700
.text$mn:00000700                 push    ebp
.text$mn:00000701                 mov     ebp, esp
.text$mn:00000703                 cmp     [ebp+arg_0], 0
.text$mn:00000707                 jnz     short loc_71E
.text$mn:00000709                 mov     eax, [ebp+arg_8]
.text$mn:0000070C                 push    eax             ; unsigned int
.text$mn:0000070D                 mov     ecx, [ebp+arg_4]
.text$mn:00000710                 push    ecx             ; wchar_t *
.text$mn:00000711                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000716                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000071B                 add     esp, 0Ch
.text$mn:0000071E
.text$mn:0000071E loc_71E:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000071E                 pop     ebp
.text$mn:0000071F                 retn
.text$mn:0000071F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000071F
.text$mn:0000071F _text$mn        ends
.text$mn:0000071F
.text$mn:00000720 ; ===========================================================================
.text$mn:00000720
.text$mn:00000720 ; Segment type: Pure code
.text$mn:00000720 ; Segment permissions: Read/Execute
.text$mn:00000720 _text$mn        segment para public 'CODE' use32
.text$mn:00000720                 assume cs:_text$mn
.text$mn:00000720                 ;org 720h
.text$mn:00000720 ; COMDAT (pick any)
.text$mn:00000720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000720
.text$mn:00000720 ; =============== S U B R O U T I N E =======================================
.text$mn:00000720
.text$mn:00000720 ; Attributes: bp-based frame
.text$mn:00000720
.text$mn:00000720 ; int __cdecl std::_Debug_pointer<HMENU__ *>(int, wchar_t *, unsigned int)
.text$mn:00000720                 public ??$_Debug_pointer@PAUHMENU__@@@std@@YAXPAPAUHMENU__@@PB_WI@Z
.text$mn:00000720 ??$_Debug_pointer@PAUHMENU__@@@std@@YAXPAPAUHMENU__@@PB_WI@Z proc near
.text$mn:00000720                                         ; CODE XREF: std::_Debug_range2<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00000720                                         ; std::_Debug_range2<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00000720
.text$mn:00000720 arg_0           = dword ptr  8
.text$mn:00000720 arg_4           = dword ptr  0Ch
.text$mn:00000720 arg_8           = dword ptr  10h
.text$mn:00000720
.text$mn:00000720                 push    ebp
.text$mn:00000721                 mov     ebp, esp
.text$mn:00000723                 cmp     [ebp+arg_0], 0
.text$mn:00000727                 jnz     short loc_73E
.text$mn:00000729                 mov     eax, [ebp+arg_8]
.text$mn:0000072C                 push    eax             ; unsigned int
.text$mn:0000072D                 mov     ecx, [ebp+arg_4]
.text$mn:00000730                 push    ecx             ; wchar_t *
.text$mn:00000731                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000736                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000073B                 add     esp, 0Ch
.text$mn:0000073E
.text$mn:0000073E loc_73E:                                ; CODE XREF: std::_Debug_pointer<HMENU__ *>(HMENU__ * *,wchar_t const *,uint)+7j
.text$mn:0000073E                 pop     ebp
.text$mn:0000073F                 retn
.text$mn:0000073F ??$_Debug_pointer@PAUHMENU__@@@std@@YAXPAPAUHMENU__@@PB_WI@Z endp
.text$mn:0000073F
.text$mn:0000073F _text$mn        ends
.text$mn:0000073F
.text$mn:00000740 ; ===========================================================================
.text$mn:00000740
.text$mn:00000740 ; Segment type: Pure code
.text$mn:00000740 ; Segment permissions: Read/Execute
.text$mn:00000740 _text$mn        segment para public 'CODE' use32
.text$mn:00000740                 assume cs:_text$mn
.text$mn:00000740                 ;org 740h
.text$mn:00000740 ; COMDAT (pick any)
.text$mn:00000740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000740
.text$mn:00000740 ; =============== S U B R O U T I N E =======================================
.text$mn:00000740
.text$mn:00000740 ; Attributes: bp-based frame
.text$mn:00000740
.text$mn:00000740 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00000740                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00000740 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00000740                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:00000740                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp ...
.text$mn:00000740
.text$mn:00000740 arg_0           = dword ptr  8
.text$mn:00000740 arg_4           = dword ptr  0Ch
.text$mn:00000740 arg_8           = dword ptr  10h
.text$mn:00000740
.text$mn:00000740                 push    ebp
.text$mn:00000741                 mov     ebp, esp
.text$mn:00000743                 cmp     [ebp+arg_0], 0
.text$mn:00000747                 jnz     short loc_75E
.text$mn:00000749                 mov     eax, [ebp+arg_8]
.text$mn:0000074C                 push    eax             ; unsigned int
.text$mn:0000074D                 mov     ecx, [ebp+arg_4]
.text$mn:00000750                 push    ecx             ; wchar_t *
.text$mn:00000751                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000756                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000075B                 add     esp, 0Ch
.text$mn:0000075E
.text$mn:0000075E loc_75E:                                ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:0000075E                 pop     ebp
.text$mn:0000075F                 retn
.text$mn:0000075F ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:0000075F
.text$mn:0000075F _text$mn        ends
.text$mn:0000075F
.text$mn:00000760 ; ===========================================================================
.text$mn:00000760
.text$mn:00000760 ; Segment type: Pure code
.text$mn:00000760 ; Segment permissions: Read/Execute
.text$mn:00000760 _text$mn        segment para public 'CODE' use32
.text$mn:00000760                 assume cs:_text$mn
.text$mn:00000760                 ;org 760h
.text$mn:00000760 ; COMDAT (pick any)
.text$mn:00000760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000760
.text$mn:00000760 ; =============== S U B R O U T I N E =======================================
.text$mn:00000760
.text$mn:00000760 ; Attributes: bp-based frame
.text$mn:00000760
.text$mn:00000760 ; int __cdecl std::_Debug_range2<HMENU__ * *>(int, int, wchar_t *, unsigned int)
.text$mn:00000760                 public ??$_Debug_range2@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00000760 ??$_Debug_range2@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00000760                                         ; CODE XREF: std::_Debug_range<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint)+2Ap
.text$mn:00000760
.text$mn:00000760 arg_0           = dword ptr  8
.text$mn:00000760 arg_4           = dword ptr  0Ch
.text$mn:00000760 arg_8           = dword ptr  10h
.text$mn:00000760 arg_C           = dword ptr  14h
.text$mn:00000760
.text$mn:00000760                 push    ebp
.text$mn:00000761                 mov     ebp, esp
.text$mn:00000763                 mov     eax, [ebp+arg_0]
.text$mn:00000766                 cmp     eax, [ebp+arg_4]
.text$mn:00000769                 jz      short loc_7B0
.text$mn:0000076B                 mov     ecx, [ebp+arg_C]
.text$mn:0000076E                 push    ecx             ; unsigned int
.text$mn:0000076F                 mov     edx, [ebp+arg_8]
.text$mn:00000772                 push    edx             ; wchar_t *
.text$mn:00000773                 mov     eax, [ebp+arg_0]
.text$mn:00000776                 push    eax             ; int
.text$mn:00000777                 call    ??$_Debug_pointer@PAUHMENU__@@@std@@YAXPAPAUHMENU__@@PB_WI@Z ; std::_Debug_pointer<HMENU__ *>(HMENU__ * *,wchar_t const *,uint)
.text$mn:0000077C                 add     esp, 0Ch
.text$mn:0000077F                 mov     ecx, [ebp+arg_C]
.text$mn:00000782                 push    ecx             ; unsigned int
.text$mn:00000783                 mov     edx, [ebp+arg_8]
.text$mn:00000786                 push    edx             ; wchar_t *
.text$mn:00000787                 mov     eax, [ebp+arg_4]
.text$mn:0000078A                 push    eax             ; int
.text$mn:0000078B                 call    ??$_Debug_pointer@PAUHMENU__@@@std@@YAXPAPAUHMENU__@@PB_WI@Z ; std::_Debug_pointer<HMENU__ *>(HMENU__ * *,wchar_t const *,uint)
.text$mn:00000790                 add     esp, 0Ch
.text$mn:00000793                 mov     ecx, [ebp+arg_4]
.text$mn:00000796                 cmp     ecx, [ebp+arg_0]
.text$mn:00000799                 jnb     short loc_7B0
.text$mn:0000079B                 mov     edx, [ebp+arg_C]
.text$mn:0000079E                 push    edx             ; unsigned int
.text$mn:0000079F                 mov     eax, [ebp+arg_8]
.text$mn:000007A2                 push    eax             ; wchar_t *
.text$mn:000007A3                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000007A8                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000007AD                 add     esp, 0Ch
.text$mn:000007B0
.text$mn:000007B0 loc_7B0:                                ; CODE XREF: std::_Debug_range2<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000007B0                                         ; std::_Debug_range2<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000007B0                 pop     ebp
.text$mn:000007B1                 retn
.text$mn:000007B1 ??$_Debug_range2@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000007B1
.text$mn:000007B1 ; ---------------------------------------------------------------------------
.text$mn:000007B2                 align 4
.text$mn:000007B2 _text$mn        ends
.text$mn:000007B2
.text$mn:000007B4 ; ===========================================================================
.text$mn:000007B4
.text$mn:000007B4 ; Segment type: Pure code
.text$mn:000007B4 ; Segment permissions: Read/Execute
.text$mn:000007B4 _text$mn        segment para public 'CODE' use32
.text$mn:000007B4                 assume cs:_text$mn
.text$mn:000007B4                 ;org 7B4h
.text$mn:000007B4 ; COMDAT (pick any)
.text$mn:000007B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007B4
.text$mn:000007B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000007B4
.text$mn:000007B4 ; Attributes: bp-based frame
.text$mn:000007B4
.text$mn:000007B4 ; int __cdecl std::_Debug_range<HMENU__ * *>(int, int, wchar_t *, unsigned int)
.text$mn:000007B4                 public ??$_Debug_range@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WI@Z
.text$mn:000007B4 ??$_Debug_range@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WI@Z proc near
.text$mn:000007B4                                         ; CODE XREF: std::_Uninit_move<HMENU__ *,HMENU__ *,HMENU__ *>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &,HMENU__ * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000007B4
.text$mn:000007B4 var_1           = byte ptr -1
.text$mn:000007B4 arg_0           = dword ptr  8
.text$mn:000007B4 arg_4           = dword ptr  0Ch
.text$mn:000007B4 arg_8           = dword ptr  10h
.text$mn:000007B4 arg_C           = dword ptr  14h
.text$mn:000007B4
.text$mn:000007B4                 push    ebp
.text$mn:000007B5                 mov     ebp, esp
.text$mn:000007B7                 push    ecx
.text$mn:000007B8                 lea     eax, [ebp+arg_0]
.text$mn:000007BB                 push    eax
.text$mn:000007BC                 lea     ecx, [ebp+var_1]
.text$mn:000007BF                 push    ecx
.text$mn:000007C0                 call    ??$_Iter_cat@PAPAUHMENU__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHMENU__@@@Z ; std::_Iter_cat<HMENU__ * *>(HMENU__ * * const &)
.text$mn:000007C5                 add     esp, 8
.text$mn:000007C8                 mov     dl, [eax]
.text$mn:000007CA                 movzx   eax, dl
.text$mn:000007CD                 push    eax
.text$mn:000007CE                 mov     ecx, [ebp+arg_C]
.text$mn:000007D1                 push    ecx             ; unsigned int
.text$mn:000007D2                 mov     edx, [ebp+arg_8]
.text$mn:000007D5                 push    edx             ; wchar_t *
.text$mn:000007D6                 mov     eax, [ebp+arg_4]
.text$mn:000007D9                 push    eax             ; int
.text$mn:000007DA                 mov     ecx, [ebp+arg_0]
.text$mn:000007DD                 push    ecx             ; int
.text$mn:000007DE                 call    ??$_Debug_range2@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000007E3                 add     esp, 14h
.text$mn:000007E6                 mov     esp, ebp
.text$mn:000007E8                 pop     ebp
.text$mn:000007E9                 retn
.text$mn:000007E9 ??$_Debug_range@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WI@Z endp
.text$mn:000007E9
.text$mn:000007E9 ; ---------------------------------------------------------------------------
.text$mn:000007EA                 align 4
.text$mn:000007EA _text$mn        ends
.text$mn:000007EA
.text$mn:000007EC ; ===========================================================================
.text$mn:000007EC
.text$mn:000007EC ; Segment type: Pure code
.text$mn:000007EC ; Segment permissions: Read/Execute
.text$mn:000007EC _text$mn        segment para public 'CODE' use32
.text$mn:000007EC                 assume cs:_text$mn
.text$mn:000007EC                 ;org 7ECh
.text$mn:000007EC ; COMDAT (pick any)
.text$mn:000007EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007EC
.text$mn:000007EC ; =============== S U B R O U T I N E =======================================
.text$mn:000007EC
.text$mn:000007EC ; Attributes: bp-based frame
.text$mn:000007EC
.text$mn:000007EC ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct HMENU__ *>>>(struct HMENU__ * *, struct HMENU__ * *, struct std::_Wrap_alloc<class std::allocator<struct HMENU__ *>> &)
.text$mn:000007EC                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z
.text$mn:000007EC ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z proc near
.text$mn:000007EC                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Destroy(HMENU__ * *,HMENU__ * *)+21p
.text$mn:000007EC
.text$mn:000007EC var_1           = byte ptr -1
.text$mn:000007EC arg_0           = dword ptr  8
.text$mn:000007EC arg_4           = dword ptr  0Ch
.text$mn:000007EC arg_8           = dword ptr  10h
.text$mn:000007EC
.text$mn:000007EC                 push    ebp
.text$mn:000007ED                 mov     ebp, esp
.text$mn:000007EF                 push    ecx
.text$mn:000007F0                 mov     eax, [ebp+arg_4]
.text$mn:000007F3                 push    eax
.text$mn:000007F4                 mov     ecx, [ebp+arg_0]
.text$mn:000007F7                 push    ecx
.text$mn:000007F8                 call    ??$_Ptr_cat@PAUHMENU__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHMENU__@@0@Z ; std::_Ptr_cat<HMENU__ *,HMENU__ *>(HMENU__ * *,HMENU__ * *)
.text$mn:000007FD                 add     esp, 8
.text$mn:00000800                 mov     [ebp+var_1], al
.text$mn:00000803                 movzx   edx, [ebp+var_1]
.text$mn:00000807                 push    edx
.text$mn:00000808                 mov     eax, [ebp+arg_8]
.text$mn:0000080B                 push    eax
.text$mn:0000080C                 mov     ecx, [ebp+arg_4]
.text$mn:0000080F                 push    ecx
.text$mn:00000810                 mov     edx, [ebp+arg_0]
.text$mn:00000813                 push    edx
.text$mn:00000814                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00000819                 add     esp, 10h
.text$mn:0000081C                 mov     esp, ebp
.text$mn:0000081E                 pop     ebp
.text$mn:0000081F                 retn
.text$mn:0000081F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z endp
.text$mn:0000081F
.text$mn:0000081F _text$mn        ends
.text$mn:0000081F
.text$mn:00000820 ; ===========================================================================
.text$mn:00000820
.text$mn:00000820 ; Segment type: Pure code
.text$mn:00000820 ; Segment permissions: Read/Execute
.text$mn:00000820 _text$mn        segment para public 'CODE' use32
.text$mn:00000820                 assume cs:_text$mn
.text$mn:00000820                 ;org 820h
.text$mn:00000820 ; COMDAT (pick any)
.text$mn:00000820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000820
.text$mn:00000820 ; =============== S U B R O U T I N E =======================================
.text$mn:00000820
.text$mn:00000820 ; Attributes: bp-based frame
.text$mn:00000820
.text$mn:00000820 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct HMENU__ *>>>(struct HMENU__ * *, struct HMENU__ * *, struct std::_Wrap_alloc<class std::allocator<struct HMENU__ *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00000820                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00000820 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00000820                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+28p
.text$mn:00000820                 push    ebp
.text$mn:00000821                 mov     ebp, esp
.text$mn:00000823                 pop     ebp
.text$mn:00000824                 retn
.text$mn:00000824 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00000824
.text$mn:00000824 ; ---------------------------------------------------------------------------
.text$mn:00000825                 align 4
.text$mn:00000825 _text$mn        ends
.text$mn:00000825
.text$mn:00000828 ; ===========================================================================
.text$mn:00000828
.text$mn:00000828 ; Segment type: Pure code
.text$mn:00000828 ; Segment permissions: Read/Execute
.text$mn:00000828 _text$mn        segment para public 'CODE' use32
.text$mn:00000828                 assume cs:_text$mn
.text$mn:00000828                 ;org 828h
.text$mn:00000828 ; COMDAT (pick any)
.text$mn:00000828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000828
.text$mn:00000828 ; =============== S U B R O U T I N E =======================================
.text$mn:00000828
.text$mn:00000828 ; Attributes: bp-based frame
.text$mn:00000828
.text$mn:00000828 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct HMENU__ * *>(struct HMENU__ * * const &)
.text$mn:00000828                 public ??$_Iter_cat@PAPAUHMENU__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHMENU__@@@Z
.text$mn:00000828 ??$_Iter_cat@PAPAUHMENU__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHMENU__@@@Z proc near
.text$mn:00000828                                         ; CODE XREF: std::_Debug_range<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint)+Cp
.text$mn:00000828
.text$mn:00000828 var_1           = byte ptr -1
.text$mn:00000828 arg_0           = dword ptr  8
.text$mn:00000828
.text$mn:00000828                 push    ebp
.text$mn:00000829                 mov     ebp, esp
.text$mn:0000082B                 push    ecx
.text$mn:0000082C                 mov     eax, [ebp+arg_0]
.text$mn:0000082F                 mov     cl, [ebp+var_1]
.text$mn:00000832                 mov     [eax], cl
.text$mn:00000834                 mov     eax, [ebp+arg_0]
.text$mn:00000837                 mov     esp, ebp
.text$mn:00000839                 pop     ebp
.text$mn:0000083A                 retn
.text$mn:0000083A ??$_Iter_cat@PAPAUHMENU__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHMENU__@@@Z endp
.text$mn:0000083A
.text$mn:0000083A ; ---------------------------------------------------------------------------
.text$mn:0000083B                 align 4
.text$mn:0000083B _text$mn        ends
.text$mn:0000083B
.text$mn:0000083C ; ===========================================================================
.text$mn:0000083C
.text$mn:0000083C ; Segment type: Pure code
.text$mn:0000083C ; Segment permissions: Read/Execute
.text$mn:0000083C _text$mn        segment para public 'CODE' use32
.text$mn:0000083C                 assume cs:_text$mn
.text$mn:0000083C                 ;org 83Ch
.text$mn:0000083C ; COMDAT (pick any)
.text$mn:0000083C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000083C
.text$mn:0000083C ; =============== S U B R O U T I N E =======================================
.text$mn:0000083C
.text$mn:0000083C ; Attributes: bp-based frame
.text$mn:0000083C
.text$mn:0000083C ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct HMENU__ *, struct HMENU__ *>(struct HMENU__ * *, struct HMENU__ * *)
.text$mn:0000083C                 public ??$_Ptr_cat@PAUHMENU__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHMENU__@@0@Z
.text$mn:0000083C ??$_Ptr_cat@PAUHMENU__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHMENU__@@0@Z proc near
.text$mn:0000083C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+Cp
.text$mn:0000083C                                         ; std::_Uninit_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+Cp
.text$mn:0000083C
.text$mn:0000083C var_1           = byte ptr -1
.text$mn:0000083C
.text$mn:0000083C                 push    ebp
.text$mn:0000083D                 mov     ebp, esp
.text$mn:0000083F                 push    ecx
.text$mn:00000840                 mov     al, [ebp+var_1]
.text$mn:00000843                 mov     esp, ebp
.text$mn:00000845                 pop     ebp
.text$mn:00000846                 retn
.text$mn:00000846 ??$_Ptr_cat@PAUHMENU__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHMENU__@@0@Z endp
.text$mn:00000846
.text$mn:00000846 ; ---------------------------------------------------------------------------
.text$mn:00000847                 align 4
.text$mn:00000847 _text$mn        ends
.text$mn:00000847
.text$mn:00000848 ; ===========================================================================
.text$mn:00000848
.text$mn:00000848 ; Segment type: Pure code
.text$mn:00000848 ; Segment permissions: Read/Execute
.text$mn:00000848 _text$mn        segment para public 'CODE' use32
.text$mn:00000848                 assume cs:_text$mn
.text$mn:00000848                 ;org 848h
.text$mn:00000848 ; COMDAT (pick any)
.text$mn:00000848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000848
.text$mn:00000848 ; =============== S U B R O U T I N E =======================================
.text$mn:00000848
.text$mn:00000848 ; Attributes: bp-based frame
.text$mn:00000848
.text$mn:00000848 ; struct HMENU__ * * & __cdecl std::_Rechecked<struct HMENU__ * *, struct HMENU__ * *>(struct HMENU__ * * &, struct HMENU__ * *)
.text$mn:00000848                 public ??$_Rechecked@PAPAUHMENU__@@PAPAU1@@std@@YAAAPAPAUHMENU__@@AAPAPAU1@PAPAU1@@Z
.text$mn:00000848 ??$_Rechecked@PAPAUHMENU__@@PAPAU1@@std@@YAAAPAPAUHMENU__@@AAPAPAU1@PAPAU1@@Z proc near
.text$mn:00000848                                         ; CODE XREF: std::_Uninitialized_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+3Bp
.text$mn:00000848
.text$mn:00000848 arg_0           = dword ptr  8
.text$mn:00000848 arg_4           = dword ptr  0Ch
.text$mn:00000848
.text$mn:00000848                 push    ebp
.text$mn:00000849                 mov     ebp, esp
.text$mn:0000084B                 mov     eax, [ebp+arg_0]
.text$mn:0000084E                 mov     ecx, [ebp+arg_4]
.text$mn:00000851                 mov     [eax], ecx
.text$mn:00000853                 mov     eax, [ebp+arg_0]
.text$mn:00000856                 pop     ebp
.text$mn:00000857                 retn
.text$mn:00000857 ??$_Rechecked@PAPAUHMENU__@@PAPAU1@@std@@YAAAPAPAUHMENU__@@AAPAPAU1@PAPAU1@@Z endp
.text$mn:00000857
.text$mn:00000857 _text$mn        ends
.text$mn:00000857
.text$mn:00000858 ; ===========================================================================
.text$mn:00000858
.text$mn:00000858 ; Segment type: Pure code
.text$mn:00000858 ; Segment permissions: Read/Execute
.text$mn:00000858 _text$mn        segment para public 'CODE' use32
.text$mn:00000858                 assume cs:_text$mn
.text$mn:00000858                 ;org 858h
.text$mn:00000858 ; COMDAT (pick any)
.text$mn:00000858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000858
.text$mn:00000858 ; =============== S U B R O U T I N E =======================================
.text$mn:00000858
.text$mn:00000858 ; Attributes: bp-based frame
.text$mn:00000858
.text$mn:00000858 ; protected: struct HMENU__ * * __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Umove<struct HMENU__ * *>(struct HMENU__ * *, struct HMENU__ * *, struct HMENU__ * *)
.text$mn:00000858                 public ??$_Umove@PAPAUHMENU__@@@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEPAPAUHMENU__@@PAPAU2@00@Z
.text$mn:00000858 ??$_Umove@PAPAUHMENU__@@@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEPAPAUHMENU__@@PAPAU2@00@Z proc near
.text$mn:00000858                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+65p
.text$mn:00000858
.text$mn:00000858 var_8           = dword ptr -8
.text$mn:00000858 var_1           = byte ptr -1
.text$mn:00000858 arg_0           = dword ptr  8
.text$mn:00000858 arg_4           = dword ptr  0Ch
.text$mn:00000858 arg_8           = dword ptr  10h
.text$mn:00000858
.text$mn:00000858                 push    ebp
.text$mn:00000859                 mov     ebp, esp
.text$mn:0000085B                 sub     esp, 8
.text$mn:0000085E                 mov     [ebp+var_8], ecx
.text$mn:00000861                 lea     eax, [ebp+var_1]
.text$mn:00000864                 push    eax
.text$mn:00000865                 mov     ecx, [ebp+var_8]
.text$mn:00000868                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:0000086D                 lea     ecx, [ebp+var_1]
.text$mn:00000870                 push    ecx
.text$mn:00000871                 mov     edx, [ebp+arg_8]
.text$mn:00000874                 push    edx
.text$mn:00000875                 mov     eax, [ebp+arg_4]
.text$mn:00000878                 push    eax
.text$mn:00000879                 mov     ecx, [ebp+arg_0]
.text$mn:0000087C                 push    ecx
.text$mn:0000087D                 call    ??$_Uninitialized_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z ; std::_Uninitialized_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)
.text$mn:00000882                 add     esp, 10h
.text$mn:00000885                 mov     esp, ebp
.text$mn:00000887                 pop     ebp
.text$mn:00000888                 retn    0Ch
.text$mn:00000888 ??$_Umove@PAPAUHMENU__@@@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEPAPAUHMENU__@@PAPAU2@00@Z endp
.text$mn:00000888
.text$mn:00000888 ; ---------------------------------------------------------------------------
.text$mn:0000088B                 align 4
.text$mn:0000088B _text$mn        ends
.text$mn:0000088B
.text$mn:0000088C ; ===========================================================================
.text$mn:0000088C
.text$mn:0000088C ; Segment type: Pure code
.text$mn:0000088C ; Segment permissions: Read/Execute
.text$mn:0000088C _text$mn        segment para public 'CODE' use32
.text$mn:0000088C                 assume cs:_text$mn
.text$mn:0000088C                 ;org 88Ch
.text$mn:0000088C ; COMDAT (pick any)
.text$mn:0000088C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000088C
.text$mn:0000088C ; =============== S U B R O U T I N E =======================================
.text$mn:0000088C
.text$mn:0000088C ; Attributes: bp-based frame
.text$mn:0000088C
.text$mn:0000088C ; struct HMENU__ * * __cdecl std::_Unchecked<struct HMENU__ * *>(struct HMENU__ * *)
.text$mn:0000088C                 public ??$_Unchecked@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z
.text$mn:0000088C ??$_Unchecked@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z proc near
.text$mn:0000088C                                         ; CODE XREF: std::_Uninitialized_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+Bp
.text$mn:0000088C                                         ; std::_Uninitialized_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+18p ...
.text$mn:0000088C
.text$mn:0000088C arg_0           = dword ptr  8
.text$mn:0000088C
.text$mn:0000088C                 push    ebp
.text$mn:0000088D                 mov     ebp, esp
.text$mn:0000088F                 mov     eax, [ebp+arg_0]
.text$mn:00000892                 pop     ebp
.text$mn:00000893                 retn
.text$mn:00000893 ??$_Unchecked@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z endp
.text$mn:00000893
.text$mn:00000893 _text$mn        ends
.text$mn:00000893
.text$mn:00000894 ; ===========================================================================
.text$mn:00000894
.text$mn:00000894 ; Segment type: Pure code
.text$mn:00000894 ; Segment permissions: Read/Execute
.text$mn:00000894 _text$mn        segment para public 'CODE' use32
.text$mn:00000894                 assume cs:_text$mn
.text$mn:00000894                 ;org 894h
.text$mn:00000894 ; COMDAT (pick any)
.text$mn:00000894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000894
.text$mn:00000894 ; =============== S U B R O U T I N E =======================================
.text$mn:00000894
.text$mn:00000894 ; Attributes: bp-based frame
.text$mn:00000894
.text$mn:00000894 ; int __cdecl std::_Uninit_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(void *Src, int, void *Dst, int)
.text$mn:00000894                 public ??$_Uninit_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z
.text$mn:00000894 ??$_Uninit_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z proc near
.text$mn:00000894                                         ; CODE XREF: std::_Uninitialized_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+2Ep
.text$mn:00000894
.text$mn:00000894 var_1           = byte ptr -1
.text$mn:00000894 Src             = dword ptr  8
.text$mn:00000894 arg_4           = dword ptr  0Ch
.text$mn:00000894 Dst             = dword ptr  10h
.text$mn:00000894 arg_C           = dword ptr  14h
.text$mn:00000894
.text$mn:00000894                 push    ebp
.text$mn:00000895                 mov     ebp, esp
.text$mn:00000897                 push    ecx
.text$mn:00000898                 mov     eax, [ebp+Dst]
.text$mn:0000089B                 push    eax
.text$mn:0000089C                 mov     ecx, [ebp+Src]
.text$mn:0000089F                 push    ecx
.text$mn:000008A0                 call    ??$_Ptr_cat@PAUHMENU__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHMENU__@@0@Z ; std::_Ptr_cat<HMENU__ *,HMENU__ *>(HMENU__ * *,HMENU__ * *)
.text$mn:000008A5                 add     esp, 8
.text$mn:000008A8                 mov     [ebp+var_1], al
.text$mn:000008AB                 movzx   edx, [ebp+var_1]
.text$mn:000008AF                 push    edx
.text$mn:000008B0                 mov     eax, [ebp+Src]
.text$mn:000008B3                 push    eax
.text$mn:000008B4                 call    ??$_Val_type@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z ; std::_Val_type<HMENU__ * *>(HMENU__ * *)
.text$mn:000008B9                 add     esp, 4
.text$mn:000008BC                 push    eax
.text$mn:000008BD                 mov     ecx, [ebp+arg_C]
.text$mn:000008C0                 push    ecx
.text$mn:000008C1                 mov     edx, [ebp+Dst]
.text$mn:000008C4                 push    edx             ; Dst
.text$mn:000008C5                 mov     eax, [ebp+arg_4]
.text$mn:000008C8                 push    eax             ; int
.text$mn:000008C9                 mov     ecx, [ebp+Src]
.text$mn:000008CC                 push    ecx             ; Src
.text$mn:000008CD                 call    ??$_Uninit_move@PAUHMENU__@@PAU1@PAU1@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<HMENU__ *,HMENU__ *,HMENU__ *>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &,HMENU__ * *,std::_Scalar_ptr_iterator_tag)
.text$mn:000008D2                 add     esp, 18h
.text$mn:000008D5                 mov     esp, ebp
.text$mn:000008D7                 pop     ebp
.text$mn:000008D8                 retn
.text$mn:000008D8 ??$_Uninit_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z endp
.text$mn:000008D8
.text$mn:000008D8 ; ---------------------------------------------------------------------------
.text$mn:000008D9                 align 4
.text$mn:000008D9 _text$mn        ends
.text$mn:000008D9
.text$mn:000008DC ; ===========================================================================
.text$mn:000008DC
.text$mn:000008DC ; Segment type: Pure code
.text$mn:000008DC ; Segment permissions: Read/Execute
.text$mn:000008DC _text$mn        segment para public 'CODE' use32
.text$mn:000008DC                 assume cs:_text$mn
.text$mn:000008DC                 ;org 8DCh
.text$mn:000008DC ; COMDAT (pick any)
.text$mn:000008DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008DC
.text$mn:000008DC ; =============== S U B R O U T I N E =======================================
.text$mn:000008DC
.text$mn:000008DC ; Attributes: bp-based frame
.text$mn:000008DC
.text$mn:000008DC ; int __cdecl std::_Uninit_move<HMENU__ *,HMENU__ *,HMENU__ *>(void *Src, int, void *Dst)
.text$mn:000008DC                 public ??$_Uninit_move@PAUHMENU__@@PAU1@PAU1@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000008DC ??$_Uninit_move@PAUHMENU__@@PAU1@PAU1@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000008DC                                         ; CODE XREF: std::_Uninit_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+39p
.text$mn:000008DC
.text$mn:000008DC var_4           = dword ptr -4
.text$mn:000008DC Src             = dword ptr  8
.text$mn:000008DC arg_4           = dword ptr  0Ch
.text$mn:000008DC Dst             = dword ptr  10h
.text$mn:000008DC
.text$mn:000008DC                 push    ebp
.text$mn:000008DD                 mov     ebp, esp
.text$mn:000008DF                 push    ecx
.text$mn:000008E0                 push    1D6h            ; unsigned int
.text$mn:000008E5                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000008EA                 mov     eax, [ebp+arg_4]
.text$mn:000008ED                 push    eax             ; int
.text$mn:000008EE                 mov     ecx, [ebp+Src]
.text$mn:000008F1                 push    ecx             ; int
.text$mn:000008F2                 call    ??$_Debug_range@PAPAUHMENU__@@@std@@YAXPAPAUHMENU__@@0PB_WI@Z ; std::_Debug_range<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint)
.text$mn:000008F7                 add     esp, 10h
.text$mn:000008FA                 push    1D7h            ; unsigned int
.text$mn:000008FF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00000904                 mov     edx, [ebp+Dst]
.text$mn:00000907                 push    edx             ; int
.text$mn:00000908                 call    ??$_Debug_pointer@PAUHMENU__@@@std@@YAXPAPAUHMENU__@@PB_WI@Z ; std::_Debug_pointer<HMENU__ *>(HMENU__ * *,wchar_t const *,uint)
.text$mn:0000090D                 add     esp, 0Ch
.text$mn:00000910                 mov     eax, [ebp+arg_4]
.text$mn:00000913                 sub     eax, [ebp+Src]
.text$mn:00000916                 sar     eax, 2
.text$mn:00000919                 mov     [ebp+var_4], eax
.text$mn:0000091C                 mov     ecx, [ebp+var_4]
.text$mn:0000091F                 shl     ecx, 2
.text$mn:00000922                 push    ecx             ; Size
.text$mn:00000923                 mov     edx, [ebp+Src]
.text$mn:00000926                 push    edx             ; Src
.text$mn:00000927                 mov     eax, [ebp+Dst]
.text$mn:0000092A                 push    eax             ; Dst
.text$mn:0000092B                 call    _memmove
.text$mn:00000930                 add     esp, 0Ch
.text$mn:00000933                 mov     ecx, [ebp+var_4]
.text$mn:00000936                 lea     eax, [eax+ecx*4]
.text$mn:00000939                 mov     esp, ebp
.text$mn:0000093B                 pop     ebp
.text$mn:0000093C                 retn
.text$mn:0000093C ??$_Uninit_move@PAUHMENU__@@PAU1@PAU1@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000093C
.text$mn:0000093C ; ---------------------------------------------------------------------------
.text$mn:0000093D                 align 10h
.text$mn:0000093D _text$mn        ends
.text$mn:0000093D
.text$mn:00000940 ; ===========================================================================
.text$mn:00000940
.text$mn:00000940 ; Segment type: Pure code
.text$mn:00000940 ; Segment permissions: Read/Execute
.text$mn:00000940 _text$mn        segment para public 'CODE' use32
.text$mn:00000940                 assume cs:_text$mn
.text$mn:00000940                 ;org 940h
.text$mn:00000940 ; COMDAT (pick any)
.text$mn:00000940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000940
.text$mn:00000940 ; =============== S U B R O U T I N E =======================================
.text$mn:00000940
.text$mn:00000940 ; Attributes: bp-based frame
.text$mn:00000940
.text$mn:00000940 ; struct HMENU__ * * __cdecl std::_Uninitialized_move<struct HMENU__ * *, struct HMENU__ * *, struct std::_Wrap_alloc<class std::allocator<struct HMENU__ *>>>(struct HMENU__ * *, struct HMENU__ * *, struct HMENU__ * *, struct std::_Wrap_alloc<class std::allocator<struct HMENU__ *>> &)
.text$mn:00000940                 public ??$_Uninitialized_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z
.text$mn:00000940 ??$_Uninitialized_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z proc near
.text$mn:00000940                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Umove<HMENU__ * *>(HMENU__ * *,HMENU__ * *,HMENU__ * *)+25p
.text$mn:00000940
.text$mn:00000940 arg_0           = dword ptr  8
.text$mn:00000940 arg_4           = dword ptr  0Ch
.text$mn:00000940 arg_8           = dword ptr  10h
.text$mn:00000940 arg_C           = dword ptr  14h
.text$mn:00000940
.text$mn:00000940                 push    ebp
.text$mn:00000941                 mov     ebp, esp
.text$mn:00000943                 mov     eax, [ebp+arg_C]
.text$mn:00000946                 push    eax             ; int
.text$mn:00000947                 mov     ecx, [ebp+arg_8]
.text$mn:0000094A                 push    ecx
.text$mn:0000094B                 call    ??$_Unchecked@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z ; std::_Unchecked<HMENU__ * *>(HMENU__ * *)
.text$mn:00000950                 add     esp, 4
.text$mn:00000953                 push    eax             ; Dst
.text$mn:00000954                 mov     edx, [ebp+arg_4]
.text$mn:00000957                 push    edx
.text$mn:00000958                 call    ??$_Unchecked@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z ; std::_Unchecked<HMENU__ * *>(HMENU__ * *)
.text$mn:0000095D                 add     esp, 4
.text$mn:00000960                 push    eax             ; int
.text$mn:00000961                 mov     eax, [ebp+arg_0]
.text$mn:00000964                 push    eax
.text$mn:00000965                 call    ??$_Unchecked@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z ; std::_Unchecked<HMENU__ * *>(HMENU__ * *)
.text$mn:0000096A                 add     esp, 4
.text$mn:0000096D                 push    eax             ; Src
.text$mn:0000096E                 call    ??$_Uninit_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z ; std::_Uninit_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)
.text$mn:00000973                 add     esp, 10h
.text$mn:00000976                 push    eax
.text$mn:00000977                 lea     ecx, [ebp+arg_8]
.text$mn:0000097A                 push    ecx
.text$mn:0000097B                 call    ??$_Rechecked@PAPAUHMENU__@@PAPAU1@@std@@YAAAPAPAUHMENU__@@AAPAPAU1@PAPAU1@@Z ; std::_Rechecked<HMENU__ * *,HMENU__ * *>(HMENU__ * * &,HMENU__ * *)
.text$mn:00000980                 add     esp, 8
.text$mn:00000983                 mov     eax, [eax]
.text$mn:00000985                 pop     ebp
.text$mn:00000986                 retn
.text$mn:00000986 ??$_Uninitialized_move@PAPAUHMENU__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAPAPAUHMENU__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z endp
.text$mn:00000986
.text$mn:00000986 ; ---------------------------------------------------------------------------
.text$mn:00000987                 align 4
.text$mn:00000987 _text$mn        ends
.text$mn:00000987
.text$mn:00000988 ; ===========================================================================
.text$mn:00000988
.text$mn:00000988 ; Segment type: Pure code
.text$mn:00000988 ; Segment permissions: Read/Execute
.text$mn:00000988 _text$mn        segment para public 'CODE' use32
.text$mn:00000988                 assume cs:_text$mn
.text$mn:00000988                 ;org 988h
.text$mn:00000988 ; COMDAT (pick any)
.text$mn:00000988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000988
.text$mn:00000988 ; =============== S U B R O U T I N E =======================================
.text$mn:00000988
.text$mn:00000988 ; Attributes: bp-based frame
.text$mn:00000988
.text$mn:00000988 ; struct HMENU__ * * __cdecl std::_Val_type<struct HMENU__ * *>(struct HMENU__ * *)
.text$mn:00000988                 public ??$_Val_type@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z
.text$mn:00000988 ??$_Val_type@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z proc near
.text$mn:00000988                                         ; CODE XREF: std::_Uninit_move<HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)+20p
.text$mn:00000988                 push    ebp
.text$mn:00000989                 mov     ebp, esp
.text$mn:0000098B                 xor     eax, eax
.text$mn:0000098D                 pop     ebp
.text$mn:0000098E                 retn
.text$mn:0000098E ??$_Val_type@PAPAUHMENU__@@@std@@YAPAPAUHMENU__@@PAPAU1@@Z endp
.text$mn:0000098E
.text$mn:0000098E ; ---------------------------------------------------------------------------
.text$mn:0000098F                 align 10h
.text$mn:0000098F _text$mn        ends
.text$mn:0000098F
.text$mn:00000990 ; ===========================================================================
.text$mn:00000990
.text$mn:00000990 ; Segment type: Pure code
.text$mn:00000990 ; Segment permissions: Read/Execute
.text$mn:00000990 _text$mn        segment para public 'CODE' use32
.text$mn:00000990                 assume cs:_text$mn
.text$mn:00000990                 ;org 990h
.text$mn:00000990 ; COMDAT (pick any)
.text$mn:00000990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000990
.text$mn:00000990 ; =============== S U B R O U T I N E =======================================
.text$mn:00000990
.text$mn:00000990 ; Attributes: bp-based frame
.text$mn:00000990
.text$mn:00000990 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000990                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000990 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000990                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000990                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000990
.text$mn:00000990 arg_0           = dword ptr  8
.text$mn:00000990
.text$mn:00000990                 push    ebp
.text$mn:00000991                 mov     ebp, esp
.text$mn:00000993                 mov     eax, [ebp+arg_0]
.text$mn:00000996                 pop     ebp
.text$mn:00000997                 retn
.text$mn:00000997 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000997
.text$mn:00000997 _text$mn        ends
.text$mn:00000997
.text$mn:00000998 ; ===========================================================================
.text$mn:00000998
.text$mn:00000998 ; Segment type: Pure code
.text$mn:00000998 ; Segment permissions: Read/Execute
.text$mn:00000998 _text$mn        segment para public 'CODE' use32
.text$mn:00000998                 assume cs:_text$mn
.text$mn:00000998                 ;org 998h
.text$mn:00000998 ; COMDAT (pick any)
.text$mn:00000998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000998
.text$mn:00000998 ; =============== S U B R O U T I N E =======================================
.text$mn:00000998
.text$mn:00000998 ; Attributes: bp-based frame
.text$mn:00000998
.text$mn:00000998 ; struct HMENU__ * const * __cdecl std::addressof<struct HMENU__ * const>(struct HMENU__ * const &)
.text$mn:00000998                 public ??$addressof@QAUHMENU__@@@std@@YAPBQAUHMENU__@@ABQAU1@@Z
.text$mn:00000998 ??$addressof@QAUHMENU__@@@std@@YAPBQAUHMENU__@@ABQAU1@@Z proc near
.text$mn:00000998                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+Dp
.text$mn:00000998                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+29p
.text$mn:00000998
.text$mn:00000998 arg_0           = dword ptr  8
.text$mn:00000998
.text$mn:00000998                 push    ebp
.text$mn:00000999                 mov     ebp, esp
.text$mn:0000099B                 mov     eax, [ebp+arg_0]
.text$mn:0000099E                 pop     ebp
.text$mn:0000099F                 retn
.text$mn:0000099F ??$addressof@QAUHMENU__@@@std@@YAPBQAUHMENU__@@ABQAU1@@Z endp
.text$mn:0000099F
.text$mn:0000099F _text$mn        ends
.text$mn:0000099F
.text$mn:000009A0 ; ===========================================================================
.text$mn:000009A0
.text$mn:000009A0 ; Segment type: Pure code
.text$mn:000009A0 ; Segment permissions: Read/Execute
.text$mn:000009A0 _text$mn        segment para public 'CODE' use32
.text$mn:000009A0                 assume cs:_text$mn
.text$mn:000009A0                 ;org 9A0h
.text$mn:000009A0 ; COMDAT (pick any)
.text$mn:000009A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009A0
.text$mn:000009A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009A0
.text$mn:000009A0 ; Attributes: bp-based frame
.text$mn:000009A0
.text$mn:000009A0 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000009A0                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000009A0 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000009A0                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000009A0                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000009A0
.text$mn:000009A0 arg_0           = dword ptr  8
.text$mn:000009A0
.text$mn:000009A0                 push    ebp
.text$mn:000009A1                 mov     ebp, esp
.text$mn:000009A3                 mov     eax, [ebp+arg_0]
.text$mn:000009A6                 pop     ebp
.text$mn:000009A7                 retn
.text$mn:000009A7 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000009A7
.text$mn:000009A7 _text$mn        ends
.text$mn:000009A7
.text$mn:000009A8 ; ===========================================================================
.text$mn:000009A8
.text$mn:000009A8 ; Segment type: Pure code
.text$mn:000009A8 ; Segment permissions: Read/Execute
.text$mn:000009A8 _text$mn        segment para public 'CODE' use32
.text$mn:000009A8                 assume cs:_text$mn
.text$mn:000009A8                 ;org 9A8h
.text$mn:000009A8 ; COMDAT (pick any)
.text$mn:000009A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009A8
.text$mn:000009A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009A8
.text$mn:000009A8 ; Attributes: bp-based frame
.text$mn:000009A8
.text$mn:000009A8 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000009A8                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000009A8 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000009A8                                         ; CODE XREF: $LN19+4Bp
.text$mn:000009A8
.text$mn:000009A8 var_4           = dword ptr -4
.text$mn:000009A8 arg_0           = dword ptr  8
.text$mn:000009A8 arg_4           = dword ptr  0Ch
.text$mn:000009A8
.text$mn:000009A8                 push    ebp
.text$mn:000009A9                 mov     ebp, esp
.text$mn:000009AB                 push    ecx
.text$mn:000009AC                 mov     [ebp+var_4], ecx
.text$mn:000009AF                 mov     eax, [ebp+arg_4]
.text$mn:000009B2                 push    eax
.text$mn:000009B3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000009B8                 add     esp, 4
.text$mn:000009BB                 push    eax             ; int
.text$mn:000009BC                 mov     ecx, [ebp+arg_0]
.text$mn:000009BF                 push    ecx             ; void *
.text$mn:000009C0                 mov     edx, [ebp+var_4]
.text$mn:000009C3                 push    edx             ; int
.text$mn:000009C4                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000009C9                 add     esp, 0Ch
.text$mn:000009CC                 mov     esp, ebp
.text$mn:000009CE                 pop     ebp
.text$mn:000009CF                 retn    8
.text$mn:000009CF ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000009CF
.text$mn:000009CF ; ---------------------------------------------------------------------------
.text$mn:000009D2                 align 4
.text$mn:000009D2 _text$mn        ends
.text$mn:000009D2
.text$mn:000009D4 ; ===========================================================================
.text$mn:000009D4
.text$mn:000009D4 ; Segment type: Pure code
.text$mn:000009D4 ; Segment permissions: Read/Execute
.text$mn:000009D4 _text$mn        segment para public 'CODE' use32
.text$mn:000009D4                 assume cs:_text$mn
.text$mn:000009D4                 ;org 9D4h
.text$mn:000009D4 ; COMDAT (pick any)
.text$mn:000009D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009D4
.text$mn:000009D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009D4
.text$mn:000009D4 ; Attributes: bp-based frame
.text$mn:000009D4
.text$mn:000009D4 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000009D4                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000009D4 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000009D4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000009D4
.text$mn:000009D4 var_1C          = dword ptr -1Ch
.text$mn:000009D4 var_18          = dword ptr -18h
.text$mn:000009D4 var_14          = dword ptr -14h
.text$mn:000009D4 var_10          = dword ptr -10h
.text$mn:000009D4 var_C           = dword ptr -0Ch
.text$mn:000009D4 var_4           = dword ptr -4
.text$mn:000009D4 arg_0           = dword ptr  8
.text$mn:000009D4 arg_4           = dword ptr  0Ch
.text$mn:000009D4
.text$mn:000009D4                 push    ebp
.text$mn:000009D5                 mov     ebp, esp
.text$mn:000009D7                 push    0FFFFFFFFh
.text$mn:000009D9                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000009DE                 mov     eax, large fs:0
.text$mn:000009E4                 push    eax
.text$mn:000009E5                 sub     esp, 10h
.text$mn:000009E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009ED                 xor     eax, ebp
.text$mn:000009EF                 push    eax
.text$mn:000009F0                 lea     eax, [ebp+var_C]
.text$mn:000009F3                 mov     large fs:0, eax
.text$mn:000009F9                 mov     [ebp+var_18], ecx
.text$mn:000009FC                 mov     eax, [ebp+arg_0]
.text$mn:000009FF                 push    eax             ; void *
.text$mn:00000A00                 push    4               ; unsigned int
.text$mn:00000A02                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000A07                 add     esp, 8
.text$mn:00000A0A                 mov     [ebp+var_10], eax
.text$mn:00000A0D                 mov     [ebp+var_4], 0
.text$mn:00000A14                 cmp     [ebp+var_10], 0
.text$mn:00000A18                 jz      short loc_A35
.text$mn:00000A1A                 mov     ecx, [ebp+arg_4]
.text$mn:00000A1D                 push    ecx
.text$mn:00000A1E                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000A23                 add     esp, 4
.text$mn:00000A26                 mov     edx, [ebp+var_10]
.text$mn:00000A29                 mov     eax, [eax]
.text$mn:00000A2B                 mov     [edx], eax
.text$mn:00000A2D                 mov     ecx, [ebp+var_10]
.text$mn:00000A30                 mov     [ebp+var_14], ecx
.text$mn:00000A33                 jmp     short loc_A3C
.text$mn:00000A35 ; ---------------------------------------------------------------------------
.text$mn:00000A35
.text$mn:00000A35 loc_A35:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000A35                 mov     [ebp+var_14], 0
.text$mn:00000A3C
.text$mn:00000A3C loc_A3C:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000A3C                 mov     edx, [ebp+var_14]
.text$mn:00000A3F                 mov     [ebp+var_1C], edx
.text$mn:00000A42                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A49                 mov     ecx, [ebp+var_C]
.text$mn:00000A4C                 mov     large fs:0, ecx
.text$mn:00000A53                 pop     ecx
.text$mn:00000A54                 mov     esp, ebp
.text$mn:00000A56                 pop     ebp
.text$mn:00000A57                 retn    8
.text$mn:00000A57 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000A57
.text$mn:00000A57 ; ---------------------------------------------------------------------------
.text$mn:00000A5A                 align 4
.text$mn:00000A5A _text$mn        ends
.text$mn:00000A5A
.text$x:00000A5C ; ===========================================================================
.text$x:00000A5C
.text$x:00000A5C ; Segment type: Pure code
.text$x:00000A5C ; Segment permissions: Read/Execute
.text$x:00000A5C _text$x         segment para public 'CODE' use32
.text$x:00000A5C                 assume cs:_text$x
.text$x:00000A5C                 ;org 0A5Ch
.text$x:00000A5C ; COMDAT (pick associative to section at 9D4)
.text$x:00000A5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A5C
.text$x:00000A5C ; =============== S U B R O U T I N E =======================================
.text$x:00000A5C
.text$x:00000A5C
.text$x:00000A5C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000A5C                                         ; DATA XREF: .xdata$x:0000460Co
.text$x:00000A5C                 mov     eax, [ebp+8]
.text$x:00000A5F                 push    eax
.text$x:00000A60                 mov     eax, [ebp-10h]
.text$x:00000A63                 push    eax             ; void *
.text$x:00000A64                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000A69                 add     esp, 8
.text$x:00000A6C                 retn
.text$x:00000A6C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000A6C
.text$x:00000A6D
.text$x:00000A6D ; =============== S U B R O U T I N E =======================================
.text$x:00000A6D
.text$x:00000A6D
.text$x:00000A6D __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000A6D                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000A6D
.text$x:00000A6D arg_4           = dword ptr  8
.text$x:00000A6D
.text$x:00000A6D                 mov     edx, [esp+arg_4]
.text$x:00000A71                 lea     eax, [edx+0Ch]
.text$x:00000A74                 mov     ecx, [edx-14h]
.text$x:00000A77                 xor     ecx, eax
.text$x:00000A79                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A7E                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00000A83                 jmp     ___CxxFrameHandler3
.text$x:00000A83 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00000A83
.text$x:00000A83 _text$x         ends
.text$x:00000A83
.text$mn:00000A88 ; ===========================================================================
.text$mn:00000A88
.text$mn:00000A88 ; Segment type: Pure code
.text$mn:00000A88 ; Segment permissions: Read/Execute
.text$mn:00000A88 _text$mn        segment para public 'CODE' use32
.text$mn:00000A88                 assume cs:_text$mn
.text$mn:00000A88                 ;org 0A88h
.text$mn:00000A88 ; COMDAT (pick any)
.text$mn:00000A88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A88
.text$mn:00000A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A88
.text$mn:00000A88 ; Attributes: bp-based frame
.text$mn:00000A88
.text$mn:00000A88 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000A88                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000A88 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000A88                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000A88
.text$mn:00000A88 arg_0           = dword ptr  8
.text$mn:00000A88 arg_4           = dword ptr  0Ch
.text$mn:00000A88 arg_8           = dword ptr  10h
.text$mn:00000A88
.text$mn:00000A88                 push    ebp
.text$mn:00000A89                 mov     ebp, esp
.text$mn:00000A8B                 mov     eax, [ebp+arg_8]
.text$mn:00000A8E                 push    eax
.text$mn:00000A8F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000A94                 add     esp, 4
.text$mn:00000A97                 push    eax             ; int
.text$mn:00000A98                 mov     ecx, [ebp+arg_4]
.text$mn:00000A9B                 push    ecx             ; void *
.text$mn:00000A9C                 mov     ecx, [ebp+arg_0]
.text$mn:00000A9F                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000AA4                 pop     ebp
.text$mn:00000AA5                 retn
.text$mn:00000AA5 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000AA5
.text$mn:00000AA5 ; ---------------------------------------------------------------------------
.text$mn:00000AA6                 align 4
.text$mn:00000AA6 _text$mn        ends
.text$mn:00000AA6
.text$mn:00000AA8 ; ===========================================================================
.text$mn:00000AA8
.text$mn:00000AA8 ; Segment type: Pure code
.text$mn:00000AA8 ; Segment permissions: Read/Execute
.text$mn:00000AA8 _text$mn        segment para public 'CODE' use32
.text$mn:00000AA8                 assume cs:_text$mn
.text$mn:00000AA8                 ;org 0AA8h
.text$mn:00000AA8 ; COMDAT (pick any)
.text$mn:00000AA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AA8
.text$mn:00000AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AA8
.text$mn:00000AA8 ; Attributes: bp-based frame
.text$mn:00000AA8
.text$mn:00000AA8 ; int __stdcall std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * &>(void *, int)
.text$mn:00000AA8                 public ??$construct@PAUHMENU__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z
.text$mn:00000AA8 ??$construct@PAUHMENU__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z proc near
.text$mn:00000AA8                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+8Dp
.text$mn:00000AA8
.text$mn:00000AA8 var_4           = dword ptr -4
.text$mn:00000AA8 arg_0           = dword ptr  8
.text$mn:00000AA8 arg_4           = dword ptr  0Ch
.text$mn:00000AA8
.text$mn:00000AA8                 push    ebp
.text$mn:00000AA9                 mov     ebp, esp
.text$mn:00000AAB                 push    ecx
.text$mn:00000AAC                 mov     [ebp+var_4], ecx
.text$mn:00000AAF                 mov     eax, [ebp+arg_4]
.text$mn:00000AB2                 push    eax
.text$mn:00000AB3                 call    ??$forward@AAPAUHMENU__@@@std@@YAAAPAUHMENU__@@AAPAU1@@Z ; std::forward<HMENU__ * &>(HMENU__ * &)
.text$mn:00000AB8                 add     esp, 4
.text$mn:00000ABB                 push    eax             ; int
.text$mn:00000ABC                 mov     ecx, [ebp+arg_0]
.text$mn:00000ABF                 push    ecx             ; void *
.text$mn:00000AC0                 mov     edx, [ebp+var_4]
.text$mn:00000AC3                 push    edx             ; int
.text$mn:00000AC4                 call    ??$construct@PAUHMENU__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@AAPAU3@@Z ; std::allocator_traits<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * &>(std::allocator<HMENU__ *> &,HMENU__ * *,HMENU__ * &)
.text$mn:00000AC9                 add     esp, 0Ch
.text$mn:00000ACC                 mov     esp, ebp
.text$mn:00000ACE                 pop     ebp
.text$mn:00000ACF                 retn    8
.text$mn:00000ACF ??$construct@PAUHMENU__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z endp
.text$mn:00000ACF
.text$mn:00000ACF ; ---------------------------------------------------------------------------
.text$mn:00000AD2                 align 4
.text$mn:00000AD2 _text$mn        ends
.text$mn:00000AD2
.text$mn:00000AD4 ; ===========================================================================
.text$mn:00000AD4
.text$mn:00000AD4 ; Segment type: Pure code
.text$mn:00000AD4 ; Segment permissions: Read/Execute
.text$mn:00000AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00000AD4                 assume cs:_text$mn
.text$mn:00000AD4                 ;org 0AD4h
.text$mn:00000AD4 ; COMDAT (pick any)
.text$mn:00000AD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AD4
.text$mn:00000AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AD4
.text$mn:00000AD4 ; Attributes: bp-based frame
.text$mn:00000AD4
.text$mn:00000AD4 ; int __stdcall std::allocator<HMENU__ *>::construct<HMENU__ *,HMENU__ * &>(void *, int)
.text$mn:00000AD4                 public ??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z
.text$mn:00000AD4 ??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z proc near
.text$mn:00000AD4                                         ; CODE XREF: std::allocator_traits<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * &>(std::allocator<HMENU__ *> &,HMENU__ * *,HMENU__ * &)+17p
.text$mn:00000AD4
.text$mn:00000AD4 var_1C          = dword ptr -1Ch
.text$mn:00000AD4 var_18          = dword ptr -18h
.text$mn:00000AD4 var_14          = dword ptr -14h
.text$mn:00000AD4 var_10          = dword ptr -10h
.text$mn:00000AD4 var_C           = dword ptr -0Ch
.text$mn:00000AD4 var_4           = dword ptr -4
.text$mn:00000AD4 arg_0           = dword ptr  8
.text$mn:00000AD4 arg_4           = dword ptr  0Ch
.text$mn:00000AD4
.text$mn:00000AD4                 push    ebp
.text$mn:00000AD5                 mov     ebp, esp
.text$mn:00000AD7                 push    0FFFFFFFFh
.text$mn:00000AD9                 push    offset __ehhandler$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z
.text$mn:00000ADE                 mov     eax, large fs:0
.text$mn:00000AE4                 push    eax
.text$mn:00000AE5                 sub     esp, 10h
.text$mn:00000AE8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AED                 xor     eax, ebp
.text$mn:00000AEF                 push    eax
.text$mn:00000AF0                 lea     eax, [ebp+var_C]
.text$mn:00000AF3                 mov     large fs:0, eax
.text$mn:00000AF9                 mov     [ebp+var_18], ecx
.text$mn:00000AFC                 mov     eax, [ebp+arg_0]
.text$mn:00000AFF                 push    eax             ; void *
.text$mn:00000B00                 push    4               ; unsigned int
.text$mn:00000B02                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000B07                 add     esp, 8
.text$mn:00000B0A                 mov     [ebp+var_10], eax
.text$mn:00000B0D                 mov     [ebp+var_4], 0
.text$mn:00000B14                 cmp     [ebp+var_10], 0
.text$mn:00000B18                 jz      short loc_B35
.text$mn:00000B1A                 mov     ecx, [ebp+arg_4]
.text$mn:00000B1D                 push    ecx
.text$mn:00000B1E                 call    ??$forward@AAPAUHMENU__@@@std@@YAAAPAUHMENU__@@AAPAU1@@Z ; std::forward<HMENU__ * &>(HMENU__ * &)
.text$mn:00000B23                 add     esp, 4
.text$mn:00000B26                 mov     edx, [ebp+var_10]
.text$mn:00000B29                 mov     eax, [eax]
.text$mn:00000B2B                 mov     [edx], eax
.text$mn:00000B2D                 mov     ecx, [ebp+var_10]
.text$mn:00000B30                 mov     [ebp+var_14], ecx
.text$mn:00000B33                 jmp     short loc_B3C
.text$mn:00000B35 ; ---------------------------------------------------------------------------
.text$mn:00000B35
.text$mn:00000B35 loc_B35:                                ; CODE XREF: std::allocator<HMENU__ *>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)+44j
.text$mn:00000B35                 mov     [ebp+var_14], 0
.text$mn:00000B3C
.text$mn:00000B3C loc_B3C:                                ; CODE XREF: std::allocator<HMENU__ *>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)+5Fj
.text$mn:00000B3C                 mov     edx, [ebp+var_14]
.text$mn:00000B3F                 mov     [ebp+var_1C], edx
.text$mn:00000B42                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B49                 mov     ecx, [ebp+var_C]
.text$mn:00000B4C                 mov     large fs:0, ecx
.text$mn:00000B53                 pop     ecx
.text$mn:00000B54                 mov     esp, ebp
.text$mn:00000B56                 pop     ebp
.text$mn:00000B57                 retn    8
.text$mn:00000B57 ??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z endp
.text$mn:00000B57
.text$mn:00000B57 ; ---------------------------------------------------------------------------
.text$mn:00000B5A                 align 4
.text$mn:00000B5A _text$mn        ends
.text$mn:00000B5A
.text$x:00000B5C ; ===========================================================================
.text$x:00000B5C
.text$x:00000B5C ; Segment type: Pure code
.text$x:00000B5C ; Segment permissions: Read/Execute
.text$x:00000B5C _text$x         segment para public 'CODE' use32
.text$x:00000B5C                 assume cs:_text$x
.text$x:00000B5C                 ;org 0B5Ch
.text$x:00000B5C ; COMDAT (pick associative to section at AD4)
.text$x:00000B5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000B5C
.text$x:00000B5C ; =============== S U B R O U T I N E =======================================
.text$x:00000B5C
.text$x:00000B5C
.text$x:00000B5C __unwindfunclet$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z$0 proc near
.text$x:00000B5C                                         ; DATA XREF: .xdata$x:000045E0o
.text$x:00000B5C                 mov     eax, [ebp+8]
.text$x:00000B5F                 push    eax
.text$x:00000B60                 mov     eax, [ebp-10h]
.text$x:00000B63                 push    eax             ; void *
.text$x:00000B64                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000B69                 add     esp, 8
.text$x:00000B6C                 retn
.text$x:00000B6C __unwindfunclet$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z$0 endp
.text$x:00000B6C
.text$x:00000B6D
.text$x:00000B6D ; =============== S U B R O U T I N E =======================================
.text$x:00000B6D
.text$x:00000B6D
.text$x:00000B6D __ehhandler$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z proc near
.text$x:00000B6D                                         ; DATA XREF: std::allocator<HMENU__ *>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)+5o
.text$x:00000B6D
.text$x:00000B6D arg_4           = dword ptr  8
.text$x:00000B6D
.text$x:00000B6D                 mov     edx, [esp+arg_4]
.text$x:00000B71                 lea     eax, [edx+0Ch]
.text$x:00000B74                 mov     ecx, [edx-14h]
.text$x:00000B77                 xor     ecx, eax
.text$x:00000B79                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B7E                 mov     eax, offset __ehfuncinfo$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z
.text$x:00000B83                 jmp     ___CxxFrameHandler3
.text$x:00000B83 __ehhandler$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z endp
.text$x:00000B83
.text$x:00000B83 _text$x         ends
.text$x:00000B83
.text$mn:00000B88 ; ===========================================================================
.text$mn:00000B88
.text$mn:00000B88 ; Segment type: Pure code
.text$mn:00000B88 ; Segment permissions: Read/Execute
.text$mn:00000B88 _text$mn        segment para public 'CODE' use32
.text$mn:00000B88                 assume cs:_text$mn
.text$mn:00000B88                 ;org 0B88h
.text$mn:00000B88 ; COMDAT (pick any)
.text$mn:00000B88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B88
.text$mn:00000B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B88
.text$mn:00000B88 ; Attributes: bp-based frame
.text$mn:00000B88
.text$mn:00000B88 ; int __cdecl std::allocator_traits<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * &>(int, void *, int)
.text$mn:00000B88                 public ??$construct@PAUHMENU__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@AAPAU3@@Z
.text$mn:00000B88 ??$construct@PAUHMENU__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@AAPAU3@@Z proc near
.text$mn:00000B88                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)+1Cp
.text$mn:00000B88
.text$mn:00000B88 arg_0           = dword ptr  8
.text$mn:00000B88 arg_4           = dword ptr  0Ch
.text$mn:00000B88 arg_8           = dword ptr  10h
.text$mn:00000B88
.text$mn:00000B88                 push    ebp
.text$mn:00000B89                 mov     ebp, esp
.text$mn:00000B8B                 mov     eax, [ebp+arg_8]
.text$mn:00000B8E                 push    eax
.text$mn:00000B8F                 call    ??$forward@AAPAUHMENU__@@@std@@YAAAPAUHMENU__@@AAPAU1@@Z ; std::forward<HMENU__ * &>(HMENU__ * &)
.text$mn:00000B94                 add     esp, 4
.text$mn:00000B97                 push    eax             ; int
.text$mn:00000B98                 mov     ecx, [ebp+arg_4]
.text$mn:00000B9B                 push    ecx             ; void *
.text$mn:00000B9C                 mov     ecx, [ebp+arg_0]
.text$mn:00000B9F                 call    ??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z ; std::allocator<HMENU__ *>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)
.text$mn:00000BA4                 pop     ebp
.text$mn:00000BA5                 retn
.text$mn:00000BA5 ??$construct@PAUHMENU__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@AAPAU3@@Z endp
.text$mn:00000BA5
.text$mn:00000BA5 ; ---------------------------------------------------------------------------
.text$mn:00000BA6                 align 4
.text$mn:00000BA6 _text$mn        ends
.text$mn:00000BA6
.text$mn:00000BA8 ; ===========================================================================
.text$mn:00000BA8
.text$mn:00000BA8 ; Segment type: Pure code
.text$mn:00000BA8 ; Segment permissions: Read/Execute
.text$mn:00000BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00000BA8                 assume cs:_text$mn
.text$mn:00000BA8                 ;org 0BA8h
.text$mn:00000BA8 ; COMDAT (pick any)
.text$mn:00000BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BA8
.text$mn:00000BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BA8
.text$mn:00000BA8 ; Attributes: bp-based frame
.text$mn:00000BA8
.text$mn:00000BA8 ; int __stdcall std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(void *, int)
.text$mn:00000BA8                 public ??$construct@PAUHMENU__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@ABQAU2@@Z
.text$mn:00000BA8 ??$construct@PAUHMENU__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@ABQAU2@@Z proc near
.text$mn:00000BA8                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+EAp
.text$mn:00000BA8
.text$mn:00000BA8 var_4           = dword ptr -4
.text$mn:00000BA8 arg_0           = dword ptr  8
.text$mn:00000BA8 arg_4           = dword ptr  0Ch
.text$mn:00000BA8
.text$mn:00000BA8                 push    ebp
.text$mn:00000BA9                 mov     ebp, esp
.text$mn:00000BAB                 push    ecx
.text$mn:00000BAC                 mov     [ebp+var_4], ecx
.text$mn:00000BAF                 mov     eax, [ebp+arg_4]
.text$mn:00000BB2                 push    eax
.text$mn:00000BB3                 call    ??$forward@ABQAUHMENU__@@@std@@YAABQAUHMENU__@@ABQAU1@@Z ; std::forward<HMENU__ * const &>(HMENU__ * const &)
.text$mn:00000BB8                 add     esp, 4
.text$mn:00000BBB                 push    eax             ; int
.text$mn:00000BBC                 mov     ecx, [ebp+arg_0]
.text$mn:00000BBF                 push    ecx             ; void *
.text$mn:00000BC0                 mov     edx, [ebp+var_4]
.text$mn:00000BC3                 push    edx             ; int
.text$mn:00000BC4                 call    ??$construct@PAUHMENU__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@ABQAU3@@Z ; std::allocator_traits<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(std::allocator<HMENU__ *> &,HMENU__ * *,HMENU__ * const &)
.text$mn:00000BC9                 add     esp, 0Ch
.text$mn:00000BCC                 mov     esp, ebp
.text$mn:00000BCE                 pop     ebp
.text$mn:00000BCF                 retn    8
.text$mn:00000BCF ??$construct@PAUHMENU__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@ABQAU2@@Z endp
.text$mn:00000BCF
.text$mn:00000BCF ; ---------------------------------------------------------------------------
.text$mn:00000BD2                 align 4
.text$mn:00000BD2 _text$mn        ends
.text$mn:00000BD2
.text$mn:00000BD4 ; ===========================================================================
.text$mn:00000BD4
.text$mn:00000BD4 ; Segment type: Pure code
.text$mn:00000BD4 ; Segment permissions: Read/Execute
.text$mn:00000BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00000BD4                 assume cs:_text$mn
.text$mn:00000BD4                 ;org 0BD4h
.text$mn:00000BD4 ; COMDAT (pick any)
.text$mn:00000BD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BD4
.text$mn:00000BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BD4
.text$mn:00000BD4 ; Attributes: bp-based frame
.text$mn:00000BD4
.text$mn:00000BD4 ; int __cdecl std::allocator_traits<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(int, void *, int)
.text$mn:00000BD4                 public ??$construct@PAUHMENU__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@ABQAU3@@Z
.text$mn:00000BD4 ??$construct@PAUHMENU__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@ABQAU3@@Z proc near
.text$mn:00000BD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(HMENU__ * *,HMENU__ * const &)+1Cp
.text$mn:00000BD4
.text$mn:00000BD4 arg_0           = dword ptr  8
.text$mn:00000BD4 arg_4           = dword ptr  0Ch
.text$mn:00000BD4 arg_8           = dword ptr  10h
.text$mn:00000BD4
.text$mn:00000BD4                 push    ebp
.text$mn:00000BD5                 mov     ebp, esp
.text$mn:00000BD7                 mov     eax, [ebp+arg_8]
.text$mn:00000BDA                 push    eax
.text$mn:00000BDB                 call    ??$forward@ABQAUHMENU__@@@std@@YAABQAUHMENU__@@ABQAU1@@Z ; std::forward<HMENU__ * const &>(HMENU__ * const &)
.text$mn:00000BE0                 add     esp, 4
.text$mn:00000BE3                 push    eax             ; int
.text$mn:00000BE4                 mov     ecx, [ebp+arg_4]
.text$mn:00000BE7                 push    ecx             ; void *
.text$mn:00000BE8                 mov     ecx, [ebp+arg_0]
.text$mn:00000BEB                 call    ?construct@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@ABQAU3@@Z ; std::allocator<HMENU__ *>::construct(HMENU__ * *,HMENU__ * const &)
.text$mn:00000BF0                 pop     ebp
.text$mn:00000BF1                 retn
.text$mn:00000BF1 ??$construct@PAUHMENU__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAXAAV?$allocator@PAUHMENU__@@@1@PAPAUHMENU__@@ABQAU3@@Z endp
.text$mn:00000BF1
.text$mn:00000BF1 ; ---------------------------------------------------------------------------
.text$mn:00000BF2                 align 4
.text$mn:00000BF2 _text$mn        ends
.text$mn:00000BF2
.text$mn:00000BF4 ; ===========================================================================
.text$mn:00000BF4
.text$mn:00000BF4 ; Segment type: Pure code
.text$mn:00000BF4 ; Segment permissions: Read/Execute
.text$mn:00000BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000BF4                 assume cs:_text$mn
.text$mn:00000BF4                 ;org 0BF4h
.text$mn:00000BF4 ; COMDAT (pick any)
.text$mn:00000BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BF4
.text$mn:00000BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BF4
.text$mn:00000BF4 ; Attributes: bp-based frame
.text$mn:00000BF4
.text$mn:00000BF4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000BF4                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000BF4 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000BF4                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00000BF4
.text$mn:00000BF4 var_4           = dword ptr -4
.text$mn:00000BF4 arg_0           = dword ptr  8
.text$mn:00000BF4 arg_4           = dword ptr  0Ch
.text$mn:00000BF4
.text$mn:00000BF4                 push    ebp
.text$mn:00000BF5                 mov     ebp, esp
.text$mn:00000BF7                 push    ecx
.text$mn:00000BF8                 mov     [ebp+var_4], ecx
.text$mn:00000BFB                 mov     eax, [ebp+arg_4]
.text$mn:00000BFE                 push    eax
.text$mn:00000BFF                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000C04                 add     esp, 4
.text$mn:00000C07                 push    eax             ; int
.text$mn:00000C08                 mov     ecx, [ebp+arg_0]
.text$mn:00000C0B                 push    ecx             ; void *
.text$mn:00000C0C                 mov     edx, [ebp+var_4]
.text$mn:00000C0F                 push    edx             ; int
.text$mn:00000C10                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00000C15                 add     esp, 0Ch
.text$mn:00000C18                 mov     esp, ebp
.text$mn:00000C1A                 pop     ebp
.text$mn:00000C1B                 retn    8
.text$mn:00000C1B ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00000C1B
.text$mn:00000C1B ; ---------------------------------------------------------------------------
.text$mn:00000C1E                 align 10h
.text$mn:00000C1E _text$mn        ends
.text$mn:00000C1E
.text$mn:00000C20 ; ===========================================================================
.text$mn:00000C20
.text$mn:00000C20 ; Segment type: Pure code
.text$mn:00000C20 ; Segment permissions: Read/Execute
.text$mn:00000C20 _text$mn        segment para public 'CODE' use32
.text$mn:00000C20                 assume cs:_text$mn
.text$mn:00000C20                 ;org 0C20h
.text$mn:00000C20 ; COMDAT (pick any)
.text$mn:00000C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C20
.text$mn:00000C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C20
.text$mn:00000C20 ; Attributes: bp-based frame
.text$mn:00000C20
.text$mn:00000C20 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000C20                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000C20 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000C20                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00000C20
.text$mn:00000C20 var_1C          = dword ptr -1Ch
.text$mn:00000C20 var_18          = dword ptr -18h
.text$mn:00000C20 var_14          = dword ptr -14h
.text$mn:00000C20 var_10          = dword ptr -10h
.text$mn:00000C20 var_C           = dword ptr -0Ch
.text$mn:00000C20 var_4           = dword ptr -4
.text$mn:00000C20 arg_0           = dword ptr  8
.text$mn:00000C20 arg_4           = dword ptr  0Ch
.text$mn:00000C20
.text$mn:00000C20                 push    ebp
.text$mn:00000C21                 mov     ebp, esp
.text$mn:00000C23                 push    0FFFFFFFFh
.text$mn:00000C25                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000C2A                 mov     eax, large fs:0
.text$mn:00000C30                 push    eax
.text$mn:00000C31                 sub     esp, 10h
.text$mn:00000C34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C39                 xor     eax, ebp
.text$mn:00000C3B                 push    eax
.text$mn:00000C3C                 lea     eax, [ebp+var_C]
.text$mn:00000C3F                 mov     large fs:0, eax
.text$mn:00000C45                 mov     [ebp+var_18], ecx
.text$mn:00000C48                 mov     eax, [ebp+arg_0]
.text$mn:00000C4B                 push    eax             ; void *
.text$mn:00000C4C                 push    4               ; unsigned int
.text$mn:00000C4E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000C53                 add     esp, 8
.text$mn:00000C56                 mov     [ebp+var_10], eax
.text$mn:00000C59                 mov     [ebp+var_4], 0
.text$mn:00000C60                 cmp     [ebp+var_10], 0
.text$mn:00000C64                 jz      short loc_C81
.text$mn:00000C66                 mov     ecx, [ebp+arg_4]
.text$mn:00000C69                 push    ecx
.text$mn:00000C6A                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000C6F                 add     esp, 4
.text$mn:00000C72                 mov     edx, [ebp+var_10]
.text$mn:00000C75                 mov     eax, [eax]
.text$mn:00000C77                 mov     [edx], eax
.text$mn:00000C79                 mov     ecx, [ebp+var_10]
.text$mn:00000C7C                 mov     [ebp+var_14], ecx
.text$mn:00000C7F                 jmp     short loc_C88
.text$mn:00000C81 ; ---------------------------------------------------------------------------
.text$mn:00000C81
.text$mn:00000C81 loc_C81:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00000C81                 mov     [ebp+var_14], 0
.text$mn:00000C88
.text$mn:00000C88 loc_C88:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00000C88                 mov     edx, [ebp+var_14]
.text$mn:00000C8B                 mov     [ebp+var_1C], edx
.text$mn:00000C8E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C95                 mov     ecx, [ebp+var_C]
.text$mn:00000C98                 mov     large fs:0, ecx
.text$mn:00000C9F                 pop     ecx
.text$mn:00000CA0                 mov     esp, ebp
.text$mn:00000CA2                 pop     ebp
.text$mn:00000CA3                 retn    8
.text$mn:00000CA3 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00000CA3
.text$mn:00000CA3 ; ---------------------------------------------------------------------------
.text$mn:00000CA6                 align 4
.text$mn:00000CA6 _text$mn        ends
.text$mn:00000CA6
.text$x:00000CA8 ; ===========================================================================
.text$x:00000CA8
.text$x:00000CA8 ; Segment type: Pure code
.text$x:00000CA8 ; Segment permissions: Read/Execute
.text$x:00000CA8 _text$x         segment para public 'CODE' use32
.text$x:00000CA8                 assume cs:_text$x
.text$x:00000CA8                 ;org 0CA8h
.text$x:00000CA8 ; COMDAT (pick associative to section at C20)
.text$x:00000CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CA8
.text$x:00000CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CA8
.text$x:00000CA8
.text$x:00000CA8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00000CA8                                         ; DATA XREF: .xdata$x:00004638o
.text$x:00000CA8                 mov     eax, [ebp+8]
.text$x:00000CAB                 push    eax
.text$x:00000CAC                 mov     eax, [ebp-10h]
.text$x:00000CAF                 push    eax             ; void *
.text$x:00000CB0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000CB5                 add     esp, 8
.text$x:00000CB8                 retn
.text$x:00000CB8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00000CB8
.text$x:00000CB9
.text$x:00000CB9 ; =============== S U B R O U T I N E =======================================
.text$x:00000CB9
.text$x:00000CB9
.text$x:00000CB9 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00000CB9                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00000CB9
.text$x:00000CB9 arg_4           = dword ptr  8
.text$x:00000CB9
.text$x:00000CB9                 mov     edx, [esp+arg_4]
.text$x:00000CBD                 lea     eax, [edx+0Ch]
.text$x:00000CC0                 mov     ecx, [edx-14h]
.text$x:00000CC3                 xor     ecx, eax
.text$x:00000CC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CCA                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00000CCF                 jmp     ___CxxFrameHandler3
.text$x:00000CCF __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00000CCF
.text$x:00000CCF _text$x         ends
.text$x:00000CCF
.text$mn:00000CD4 ; ===========================================================================
.text$mn:00000CD4
.text$mn:00000CD4 ; Segment type: Pure code
.text$mn:00000CD4 ; Segment permissions: Read/Execute
.text$mn:00000CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00000CD4                 assume cs:_text$mn
.text$mn:00000CD4                 ;org 0CD4h
.text$mn:00000CD4 ; COMDAT (pick any)
.text$mn:00000CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CD4
.text$mn:00000CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CD4
.text$mn:00000CD4 ; Attributes: bp-based frame
.text$mn:00000CD4
.text$mn:00000CD4 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00000CD4                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00000CD4 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00000CD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00000CD4
.text$mn:00000CD4 arg_0           = dword ptr  8
.text$mn:00000CD4 arg_4           = dword ptr  0Ch
.text$mn:00000CD4 arg_8           = dword ptr  10h
.text$mn:00000CD4
.text$mn:00000CD4                 push    ebp
.text$mn:00000CD5                 mov     ebp, esp
.text$mn:00000CD7                 mov     eax, [ebp+arg_8]
.text$mn:00000CDA                 push    eax
.text$mn:00000CDB                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000CE0                 add     esp, 4
.text$mn:00000CE3                 push    eax             ; int
.text$mn:00000CE4                 mov     ecx, [ebp+arg_4]
.text$mn:00000CE7                 push    ecx             ; void *
.text$mn:00000CE8                 mov     ecx, [ebp+arg_0]
.text$mn:00000CEB                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00000CF0                 pop     ebp
.text$mn:00000CF1                 retn
.text$mn:00000CF1 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00000CF1
.text$mn:00000CF1 ; ---------------------------------------------------------------------------
.text$mn:00000CF2                 align 4
.text$mn:00000CF2 _text$mn        ends
.text$mn:00000CF2
.text$mn:00000CF4 ; ===========================================================================
.text$mn:00000CF4
.text$mn:00000CF4 ; Segment type: Pure code
.text$mn:00000CF4 ; Segment permissions: Read/Execute
.text$mn:00000CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000CF4                 assume cs:_text$mn
.text$mn:00000CF4                 ;org 0CF4h
.text$mn:00000CF4 ; COMDAT (pick any)
.text$mn:00000CF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CF4
.text$mn:00000CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CF4
.text$mn:00000CF4 ; Attributes: bp-based frame
.text$mn:00000CF4
.text$mn:00000CF4 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000CF4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000CF4 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000CF4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000CF4                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:00000CF4
.text$mn:00000CF4 var_1C          = dword ptr -1Ch
.text$mn:00000CF4 var_18          = dword ptr -18h
.text$mn:00000CF4 var_14          = dword ptr -14h
.text$mn:00000CF4 var_10          = dword ptr -10h
.text$mn:00000CF4 var_C           = dword ptr -0Ch
.text$mn:00000CF4 var_4           = dword ptr -4
.text$mn:00000CF4 arg_0           = dword ptr  8
.text$mn:00000CF4 arg_4           = dword ptr  0Ch
.text$mn:00000CF4
.text$mn:00000CF4                 push    ebp
.text$mn:00000CF5                 mov     ebp, esp
.text$mn:00000CF7                 push    0FFFFFFFFh
.text$mn:00000CF9                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000CFE                 mov     eax, large fs:0
.text$mn:00000D04                 push    eax
.text$mn:00000D05                 sub     esp, 10h
.text$mn:00000D08                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D0D                 xor     eax, ebp
.text$mn:00000D0F                 push    eax
.text$mn:00000D10                 lea     eax, [ebp+var_C]
.text$mn:00000D13                 mov     large fs:0, eax
.text$mn:00000D19                 mov     [ebp+var_18], ecx
.text$mn:00000D1C                 mov     eax, [ebp+arg_0]
.text$mn:00000D1F                 push    eax             ; void *
.text$mn:00000D20                 push    8               ; unsigned int
.text$mn:00000D22                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000D27                 add     esp, 8
.text$mn:00000D2A                 mov     [ebp+var_10], eax
.text$mn:00000D2D                 mov     [ebp+var_4], 0
.text$mn:00000D34                 cmp     [ebp+var_10], 0
.text$mn:00000D38                 jz      short loc_D5B
.text$mn:00000D3A                 mov     ecx, [ebp+arg_4]
.text$mn:00000D3D                 push    ecx
.text$mn:00000D3E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000D43                 add     esp, 4
.text$mn:00000D46                 mov     edx, [eax]
.text$mn:00000D48                 mov     eax, [eax+4]
.text$mn:00000D4B                 mov     ecx, [ebp+var_10]
.text$mn:00000D4E                 mov     [ecx], edx
.text$mn:00000D50                 mov     [ecx+4], eax
.text$mn:00000D53                 mov     edx, [ebp+var_10]
.text$mn:00000D56                 mov     [ebp+var_14], edx
.text$mn:00000D59                 jmp     short loc_D62
.text$mn:00000D5B ; ---------------------------------------------------------------------------
.text$mn:00000D5B
.text$mn:00000D5B loc_D5B:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000D5B                 mov     [ebp+var_14], 0
.text$mn:00000D62
.text$mn:00000D62 loc_D62:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000D62                 mov     eax, [ebp+var_14]
.text$mn:00000D65                 mov     [ebp+var_1C], eax
.text$mn:00000D68                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D6F                 mov     ecx, [ebp+var_C]
.text$mn:00000D72                 mov     large fs:0, ecx
.text$mn:00000D79                 pop     ecx
.text$mn:00000D7A                 mov     esp, ebp
.text$mn:00000D7C                 pop     ebp
.text$mn:00000D7D                 retn    8
.text$mn:00000D7D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000D7D
.text$mn:00000D7D _text$mn        ends
.text$mn:00000D7D
.text$x:00000D80 ; ===========================================================================
.text$x:00000D80
.text$x:00000D80 ; Segment type: Pure code
.text$x:00000D80 ; Segment permissions: Read/Execute
.text$x:00000D80 _text$x         segment para public 'CODE' use32
.text$x:00000D80                 assume cs:_text$x
.text$x:00000D80                 ;org 0D80h
.text$x:00000D80 ; COMDAT (pick associative to section at CF4)
.text$x:00000D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D80
.text$x:00000D80 ; =============== S U B R O U T I N E =======================================
.text$x:00000D80
.text$x:00000D80
.text$x:00000D80 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000D80                                         ; DATA XREF: .xdata$x:000045B4o
.text$x:00000D80                 mov     eax, [ebp+8]
.text$x:00000D83                 push    eax
.text$x:00000D84                 mov     eax, [ebp-10h]
.text$x:00000D87                 push    eax             ; void *
.text$x:00000D88                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000D8D                 add     esp, 8
.text$x:00000D90                 retn
.text$x:00000D90 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000D90
.text$x:00000D91
.text$x:00000D91 ; =============== S U B R O U T I N E =======================================
.text$x:00000D91
.text$x:00000D91
.text$x:00000D91 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000D91                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000D91
.text$x:00000D91 arg_4           = dword ptr  8
.text$x:00000D91
.text$x:00000D91                 mov     edx, [esp+arg_4]
.text$x:00000D95                 lea     eax, [edx+0Ch]
.text$x:00000D98                 mov     ecx, [edx-14h]
.text$x:00000D9B                 xor     ecx, eax
.text$x:00000D9D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DA2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000DA7                 jmp     ___CxxFrameHandler3
.text$x:00000DA7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000DA7
.text$x:00000DA7 _text$x         ends
.text$x:00000DA7
.text$mn:00000DAC ; ===========================================================================
.text$mn:00000DAC
.text$mn:00000DAC ; Segment type: Pure code
.text$mn:00000DAC ; Segment permissions: Read/Execute
.text$mn:00000DAC _text$mn        segment para public 'CODE' use32
.text$mn:00000DAC                 assume cs:_text$mn
.text$mn:00000DAC                 ;org 0DACh
.text$mn:00000DAC ; COMDAT (pick any)
.text$mn:00000DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DAC
.text$mn:00000DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DAC
.text$mn:00000DAC ; Attributes: bp-based frame
.text$mn:00000DAC
.text$mn:00000DAC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000DAC                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000DAC ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000DAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000DAC
.text$mn:00000DAC var_4           = dword ptr -4
.text$mn:00000DAC arg_0           = dword ptr  8
.text$mn:00000DAC
.text$mn:00000DAC                 push    ebp
.text$mn:00000DAD                 mov     ebp, esp
.text$mn:00000DAF                 push    ecx
.text$mn:00000DB0                 mov     [ebp+var_4], ecx
.text$mn:00000DB3                 mov     eax, [ebp+arg_0]
.text$mn:00000DB6                 push    eax
.text$mn:00000DB7                 mov     ecx, [ebp+var_4]
.text$mn:00000DBA                 push    ecx
.text$mn:00000DBB                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000DC0                 add     esp, 8
.text$mn:00000DC3                 mov     esp, ebp
.text$mn:00000DC5                 pop     ebp
.text$mn:00000DC6                 retn    4
.text$mn:00000DC6 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000DC6
.text$mn:00000DC6 ; ---------------------------------------------------------------------------
.text$mn:00000DC9                 align 4
.text$mn:00000DC9 _text$mn        ends
.text$mn:00000DC9
.text$mn:00000DCC ; ===========================================================================
.text$mn:00000DCC
.text$mn:00000DCC ; Segment type: Pure code
.text$mn:00000DCC ; Segment permissions: Read/Execute
.text$mn:00000DCC _text$mn        segment para public 'CODE' use32
.text$mn:00000DCC                 assume cs:_text$mn
.text$mn:00000DCC                 ;org 0DCCh
.text$mn:00000DCC ; COMDAT (pick any)
.text$mn:00000DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DCC
.text$mn:00000DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DCC
.text$mn:00000DCC ; Attributes: bp-based frame
.text$mn:00000DCC
.text$mn:00000DCC ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000DCC                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000DCC ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000DCC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000DCC
.text$mn:00000DCC var_4           = dword ptr -4
.text$mn:00000DCC
.text$mn:00000DCC                 push    ebp
.text$mn:00000DCD                 mov     ebp, esp
.text$mn:00000DCF                 push    ecx
.text$mn:00000DD0                 mov     [ebp+var_4], ecx
.text$mn:00000DD3                 mov     esp, ebp
.text$mn:00000DD5                 pop     ebp
.text$mn:00000DD6                 retn    4
.text$mn:00000DD6 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000DD6
.text$mn:00000DD6 ; ---------------------------------------------------------------------------
.text$mn:00000DD9                 align 4
.text$mn:00000DD9 _text$mn        ends
.text$mn:00000DD9
.text$mn:00000DDC ; ===========================================================================
.text$mn:00000DDC
.text$mn:00000DDC ; Segment type: Pure code
.text$mn:00000DDC ; Segment permissions: Read/Execute
.text$mn:00000DDC _text$mn        segment para public 'CODE' use32
.text$mn:00000DDC                 assume cs:_text$mn
.text$mn:00000DDC                 ;org 0DDCh
.text$mn:00000DDC ; COMDAT (pick any)
.text$mn:00000DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DDC
.text$mn:00000DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DDC
.text$mn:00000DDC ; Attributes: bp-based frame
.text$mn:00000DDC
.text$mn:00000DDC ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000DDC                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000DDC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000DDC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000DDC
.text$mn:00000DDC arg_0           = dword ptr  8
.text$mn:00000DDC arg_4           = dword ptr  0Ch
.text$mn:00000DDC
.text$mn:00000DDC                 push    ebp
.text$mn:00000DDD                 mov     ebp, esp
.text$mn:00000DDF                 mov     eax, [ebp+arg_4]
.text$mn:00000DE2                 push    eax
.text$mn:00000DE3                 mov     ecx, [ebp+arg_0]
.text$mn:00000DE6                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000DEB                 pop     ebp
.text$mn:00000DEC                 retn
.text$mn:00000DEC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000DEC
.text$mn:00000DEC ; ---------------------------------------------------------------------------
.text$mn:00000DED                 align 10h
.text$mn:00000DED _text$mn        ends
.text$mn:00000DED
.text$mn:00000DF0 ; ===========================================================================
.text$mn:00000DF0
.text$mn:00000DF0 ; Segment type: Pure code
.text$mn:00000DF0 ; Segment permissions: Read/Execute
.text$mn:00000DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00000DF0                 assume cs:_text$mn
.text$mn:00000DF0                 ;org 0DF0h
.text$mn:00000DF0 ; COMDAT (pick any)
.text$mn:00000DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DF0
.text$mn:00000DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DF0
.text$mn:00000DF0 ; Attributes: bp-based frame
.text$mn:00000DF0
.text$mn:00000DF0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000DF0                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00000DF0 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00000DF0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00000DF0
.text$mn:00000DF0 var_4           = dword ptr -4
.text$mn:00000DF0 arg_0           = dword ptr  8
.text$mn:00000DF0
.text$mn:00000DF0                 push    ebp
.text$mn:00000DF1                 mov     ebp, esp
.text$mn:00000DF3                 push    ecx
.text$mn:00000DF4                 mov     [ebp+var_4], ecx
.text$mn:00000DF7                 mov     eax, [ebp+arg_0]
.text$mn:00000DFA                 push    eax
.text$mn:00000DFB                 mov     ecx, [ebp+var_4]
.text$mn:00000DFE                 push    ecx
.text$mn:00000DFF                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00000E04                 add     esp, 8
.text$mn:00000E07                 mov     esp, ebp
.text$mn:00000E09                 pop     ebp
.text$mn:00000E0A                 retn    4
.text$mn:00000E0A ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00000E0A
.text$mn:00000E0A ; ---------------------------------------------------------------------------
.text$mn:00000E0D                 align 10h
.text$mn:00000E0D _text$mn        ends
.text$mn:00000E0D
.text$mn:00000E10 ; ===========================================================================
.text$mn:00000E10
.text$mn:00000E10 ; Segment type: Pure code
.text$mn:00000E10 ; Segment permissions: Read/Execute
.text$mn:00000E10 _text$mn        segment para public 'CODE' use32
.text$mn:00000E10                 assume cs:_text$mn
.text$mn:00000E10                 ;org 0E10h
.text$mn:00000E10 ; COMDAT (pick any)
.text$mn:00000E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E10
.text$mn:00000E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E10
.text$mn:00000E10 ; Attributes: bp-based frame
.text$mn:00000E10
.text$mn:00000E10 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000E10                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00000E10 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00000E10                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00000E10
.text$mn:00000E10 var_4           = dword ptr -4
.text$mn:00000E10
.text$mn:00000E10                 push    ebp
.text$mn:00000E11                 mov     ebp, esp
.text$mn:00000E13                 push    ecx
.text$mn:00000E14                 mov     [ebp+var_4], ecx
.text$mn:00000E17                 mov     esp, ebp
.text$mn:00000E19                 pop     ebp
.text$mn:00000E1A                 retn    4
.text$mn:00000E1A ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00000E1A
.text$mn:00000E1A ; ---------------------------------------------------------------------------
.text$mn:00000E1D                 align 10h
.text$mn:00000E1D _text$mn        ends
.text$mn:00000E1D
.text$mn:00000E20 ; ===========================================================================
.text$mn:00000E20
.text$mn:00000E20 ; Segment type: Pure code
.text$mn:00000E20 ; Segment permissions: Read/Execute
.text$mn:00000E20 _text$mn        segment para public 'CODE' use32
.text$mn:00000E20                 assume cs:_text$mn
.text$mn:00000E20                 ;org 0E20h
.text$mn:00000E20 ; COMDAT (pick any)
.text$mn:00000E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E20
.text$mn:00000E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E20
.text$mn:00000E20 ; Attributes: bp-based frame
.text$mn:00000E20
.text$mn:00000E20 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00000E20                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00000E20 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00000E20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00000E20
.text$mn:00000E20 arg_0           = dword ptr  8
.text$mn:00000E20 arg_4           = dword ptr  0Ch
.text$mn:00000E20
.text$mn:00000E20                 push    ebp
.text$mn:00000E21                 mov     ebp, esp
.text$mn:00000E23                 mov     eax, [ebp+arg_4]
.text$mn:00000E26                 push    eax
.text$mn:00000E27                 mov     ecx, [ebp+arg_0]
.text$mn:00000E2A                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000E2F                 pop     ebp
.text$mn:00000E30                 retn
.text$mn:00000E30 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00000E30
.text$mn:00000E30 ; ---------------------------------------------------------------------------
.text$mn:00000E31                 align 4
.text$mn:00000E31 _text$mn        ends
.text$mn:00000E31
.text$mn:00000E34 ; ===========================================================================
.text$mn:00000E34
.text$mn:00000E34 ; Segment type: Pure code
.text$mn:00000E34 ; Segment permissions: Read/Execute
.text$mn:00000E34 _text$mn        segment para public 'CODE' use32
.text$mn:00000E34                 assume cs:_text$mn
.text$mn:00000E34                 ;org 0E34h
.text$mn:00000E34 ; COMDAT (pick any)
.text$mn:00000E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E34
.text$mn:00000E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E34
.text$mn:00000E34 ; Attributes: bp-based frame
.text$mn:00000E34
.text$mn:00000E34 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000E34                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000E34 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000E34                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Free_proxy(void)+22p
.text$mn:00000E34
.text$mn:00000E34 var_4           = dword ptr -4
.text$mn:00000E34 arg_0           = dword ptr  8
.text$mn:00000E34
.text$mn:00000E34                 push    ebp
.text$mn:00000E35                 mov     ebp, esp
.text$mn:00000E37                 push    ecx
.text$mn:00000E38                 mov     [ebp+var_4], ecx
.text$mn:00000E3B                 mov     eax, [ebp+arg_0]
.text$mn:00000E3E                 push    eax
.text$mn:00000E3F                 mov     ecx, [ebp+var_4]
.text$mn:00000E42                 push    ecx
.text$mn:00000E43                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00000E48                 add     esp, 8
.text$mn:00000E4B                 mov     esp, ebp
.text$mn:00000E4D                 pop     ebp
.text$mn:00000E4E                 retn    4
.text$mn:00000E4E ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000E4E
.text$mn:00000E4E ; ---------------------------------------------------------------------------
.text$mn:00000E51                 align 4
.text$mn:00000E51 _text$mn        ends
.text$mn:00000E51
.text$mn:00000E54 ; ===========================================================================
.text$mn:00000E54
.text$mn:00000E54 ; Segment type: Pure code
.text$mn:00000E54 ; Segment permissions: Read/Execute
.text$mn:00000E54 _text$mn        segment para public 'CODE' use32
.text$mn:00000E54                 assume cs:_text$mn
.text$mn:00000E54                 ;org 0E54h
.text$mn:00000E54 ; COMDAT (pick any)
.text$mn:00000E54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E54
.text$mn:00000E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E54
.text$mn:00000E54 ; Attributes: bp-based frame
.text$mn:00000E54
.text$mn:00000E54 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000E54                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000E54 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000E54                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00000E54                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00000E54
.text$mn:00000E54 var_4           = dword ptr -4
.text$mn:00000E54
.text$mn:00000E54                 push    ebp
.text$mn:00000E55                 mov     ebp, esp
.text$mn:00000E57                 push    ecx
.text$mn:00000E58                 mov     [ebp+var_4], ecx
.text$mn:00000E5B                 mov     esp, ebp
.text$mn:00000E5D                 pop     ebp
.text$mn:00000E5E                 retn    4
.text$mn:00000E5E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000E5E
.text$mn:00000E5E ; ---------------------------------------------------------------------------
.text$mn:00000E61                 align 4
.text$mn:00000E61 _text$mn        ends
.text$mn:00000E61
.text$mn:00000E64 ; ===========================================================================
.text$mn:00000E64
.text$mn:00000E64 ; Segment type: Pure code
.text$mn:00000E64 ; Segment permissions: Read/Execute
.text$mn:00000E64 _text$mn        segment para public 'CODE' use32
.text$mn:00000E64                 assume cs:_text$mn
.text$mn:00000E64                 ;org 0E64h
.text$mn:00000E64 ; COMDAT (pick any)
.text$mn:00000E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E64
.text$mn:00000E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E64
.text$mn:00000E64 ; Attributes: bp-based frame
.text$mn:00000E64
.text$mn:00000E64 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00000E64                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00000E64 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00000E64                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00000E64
.text$mn:00000E64 arg_0           = dword ptr  8
.text$mn:00000E64 arg_4           = dword ptr  0Ch
.text$mn:00000E64
.text$mn:00000E64                 push    ebp
.text$mn:00000E65                 mov     ebp, esp
.text$mn:00000E67                 mov     eax, [ebp+arg_4]
.text$mn:00000E6A                 push    eax
.text$mn:00000E6B                 mov     ecx, [ebp+arg_0]
.text$mn:00000E6E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00000E73                 pop     ebp
.text$mn:00000E74                 retn
.text$mn:00000E74 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00000E74
.text$mn:00000E74 ; ---------------------------------------------------------------------------
.text$mn:00000E75                 align 4
.text$mn:00000E75 _text$mn        ends
.text$mn:00000E75
.text$mn:00000E78 ; ===========================================================================
.text$mn:00000E78
.text$mn:00000E78 ; Segment type: Pure code
.text$mn:00000E78 ; Segment permissions: Read/Execute
.text$mn:00000E78 _text$mn        segment para public 'CODE' use32
.text$mn:00000E78                 assume cs:_text$mn
.text$mn:00000E78                 ;org 0E78h
.text$mn:00000E78 ; COMDAT (pick any)
.text$mn:00000E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E78
.text$mn:00000E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E78
.text$mn:00000E78 ; Attributes: bp-based frame
.text$mn:00000E78
.text$mn:00000E78 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000E78                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000E78 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000E78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000E78                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000E78
.text$mn:00000E78 arg_0           = dword ptr  8
.text$mn:00000E78
.text$mn:00000E78                 push    ebp
.text$mn:00000E79                 mov     ebp, esp
.text$mn:00000E7B                 mov     eax, [ebp+arg_0]
.text$mn:00000E7E                 pop     ebp
.text$mn:00000E7F                 retn
.text$mn:00000E7F ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000E7F
.text$mn:00000E7F _text$mn        ends
.text$mn:00000E7F
.text$mn:00000E80 ; ===========================================================================
.text$mn:00000E80
.text$mn:00000E80 ; Segment type: Pure code
.text$mn:00000E80 ; Segment permissions: Read/Execute
.text$mn:00000E80 _text$mn        segment para public 'CODE' use32
.text$mn:00000E80                 assume cs:_text$mn
.text$mn:00000E80                 ;org 0E80h
.text$mn:00000E80 ; COMDAT (pick any)
.text$mn:00000E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E80
.text$mn:00000E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E80
.text$mn:00000E80 ; Attributes: bp-based frame
.text$mn:00000E80
.text$mn:00000E80 ; struct HMENU__ * & __cdecl std::forward<struct HMENU__ * &>(struct HMENU__ * &)
.text$mn:00000E80                 public ??$forward@AAPAUHMENU__@@@std@@YAAAPAUHMENU__@@AAPAU1@@Z
.text$mn:00000E80 ??$forward@AAPAUHMENU__@@@std@@YAAAPAUHMENU__@@AAPAU1@@Z proc near
.text$mn:00000E80                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)+Bp
.text$mn:00000E80                                         ; std::allocator<HMENU__ *>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)+4Ap ...
.text$mn:00000E80
.text$mn:00000E80 arg_0           = dword ptr  8
.text$mn:00000E80
.text$mn:00000E80                 push    ebp
.text$mn:00000E81                 mov     ebp, esp
.text$mn:00000E83                 mov     eax, [ebp+arg_0]
.text$mn:00000E86                 pop     ebp
.text$mn:00000E87                 retn
.text$mn:00000E87 ??$forward@AAPAUHMENU__@@@std@@YAAAPAUHMENU__@@AAPAU1@@Z endp
.text$mn:00000E87
.text$mn:00000E87 _text$mn        ends
.text$mn:00000E87
.text$mn:00000E88 ; ===========================================================================
.text$mn:00000E88
.text$mn:00000E88 ; Segment type: Pure code
.text$mn:00000E88 ; Segment permissions: Read/Execute
.text$mn:00000E88 _text$mn        segment para public 'CODE' use32
.text$mn:00000E88                 assume cs:_text$mn
.text$mn:00000E88                 ;org 0E88h
.text$mn:00000E88 ; COMDAT (pick any)
.text$mn:00000E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E88
.text$mn:00000E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E88
.text$mn:00000E88 ; Attributes: bp-based frame
.text$mn:00000E88
.text$mn:00000E88 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000E88                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00000E88 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00000E88                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00000E88                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00000E88
.text$mn:00000E88 arg_0           = dword ptr  8
.text$mn:00000E88
.text$mn:00000E88                 push    ebp
.text$mn:00000E89                 mov     ebp, esp
.text$mn:00000E8B                 mov     eax, [ebp+arg_0]
.text$mn:00000E8E                 pop     ebp
.text$mn:00000E8F                 retn
.text$mn:00000E8F ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00000E8F
.text$mn:00000E8F _text$mn        ends
.text$mn:00000E8F
.text$mn:00000E90 ; ===========================================================================
.text$mn:00000E90
.text$mn:00000E90 ; Segment type: Pure code
.text$mn:00000E90 ; Segment permissions: Read/Execute
.text$mn:00000E90 _text$mn        segment para public 'CODE' use32
.text$mn:00000E90                 assume cs:_text$mn
.text$mn:00000E90                 ;org 0E90h
.text$mn:00000E90 ; COMDAT (pick any)
.text$mn:00000E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E90
.text$mn:00000E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E90
.text$mn:00000E90 ; Attributes: bp-based frame
.text$mn:00000E90
.text$mn:00000E90 ; struct HMENU__ * const & __cdecl std::forward<struct HMENU__ * const &>(struct HMENU__ * const &)
.text$mn:00000E90                 public ??$forward@ABQAUHMENU__@@@std@@YAABQAUHMENU__@@ABQAU1@@Z
.text$mn:00000E90 ??$forward@ABQAUHMENU__@@@std@@YAABQAUHMENU__@@ABQAU1@@Z proc near
.text$mn:00000E90                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(HMENU__ * *,HMENU__ * const &)+Bp
.text$mn:00000E90                                         ; std::allocator_traits<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(std::allocator<HMENU__ *> &,HMENU__ * *,HMENU__ * const &)+7p
.text$mn:00000E90
.text$mn:00000E90 arg_0           = dword ptr  8
.text$mn:00000E90
.text$mn:00000E90                 push    ebp
.text$mn:00000E91                 mov     ebp, esp
.text$mn:00000E93                 mov     eax, [ebp+arg_0]
.text$mn:00000E96                 pop     ebp
.text$mn:00000E97                 retn
.text$mn:00000E97 ??$forward@ABQAUHMENU__@@@std@@YAABQAUHMENU__@@ABQAU1@@Z endp
.text$mn:00000E97
.text$mn:00000E97 _text$mn        ends
.text$mn:00000E97
.text$mn:00000E98 ; ===========================================================================
.text$mn:00000E98
.text$mn:00000E98 ; Segment type: Pure code
.text$mn:00000E98 ; Segment permissions: Read/Execute
.text$mn:00000E98 _text$mn        segment para public 'CODE' use32
.text$mn:00000E98                 assume cs:_text$mn
.text$mn:00000E98                 ;org 0E98h
.text$mn:00000E98 ; COMDAT (pick any)
.text$mn:00000E98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E98
.text$mn:00000E98 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E98
.text$mn:00000E98 ; Attributes: bp-based frame
.text$mn:00000E98
.text$mn:00000E98 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000E98                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000E98 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000E98                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000E98
.text$mn:00000E98 arg_0           = dword ptr  8
.text$mn:00000E98
.text$mn:00000E98                 push    ebp
.text$mn:00000E99                 mov     ebp, esp
.text$mn:00000E9B                 mov     eax, [ebp+arg_0]
.text$mn:00000E9E                 pop     ebp
.text$mn:00000E9F                 retn
.text$mn:00000E9F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000E9F
.text$mn:00000E9F _text$mn        ends
.text$mn:00000E9F
.text$mn:00000EA0 ; ===========================================================================
.text$mn:00000EA0
.text$mn:00000EA0 ; Segment type: Pure code
.text$mn:00000EA0 ; Segment permissions: Read/Execute
.text$mn:00000EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00000EA0                 assume cs:_text$mn
.text$mn:00000EA0                 ;org 0EA0h
.text$mn:00000EA0 ; COMDAT (pick any)
.text$mn:00000EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EA0
.text$mn:00000EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EA0
.text$mn:00000EA0 ; Attributes: bp-based frame
.text$mn:00000EA0
.text$mn:00000EA0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000EA0                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000EA0 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000EA0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000EA0
.text$mn:00000EA0 var_10          = dword ptr -10h
.text$mn:00000EA0 var_C           = dword ptr -0Ch
.text$mn:00000EA0 var_4           = dword ptr -4
.text$mn:00000EA0
.text$mn:00000EA0                 push    ebp
.text$mn:00000EA1                 mov     ebp, esp
.text$mn:00000EA3                 push    0FFFFFFFFh
.text$mn:00000EA5                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000EAA                 mov     eax, large fs:0
.text$mn:00000EB0                 push    eax
.text$mn:00000EB1                 push    ecx
.text$mn:00000EB2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EB7                 xor     eax, ebp
.text$mn:00000EB9                 push    eax
.text$mn:00000EBA                 lea     eax, [ebp+var_C]
.text$mn:00000EBD                 mov     large fs:0, eax
.text$mn:00000EC3                 mov     [ebp+var_10], ecx
.text$mn:00000EC6                 mov     ecx, [ebp+var_10]
.text$mn:00000EC9                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000ECE                 mov     [ebp+var_4], 0
.text$mn:00000ED5                 mov     ecx, [ebp+var_10]
.text$mn:00000ED8                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000EDD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EE4                 mov     eax, [ebp+var_10]
.text$mn:00000EE7                 mov     ecx, [ebp+var_C]
.text$mn:00000EEA                 mov     large fs:0, ecx
.text$mn:00000EF1                 pop     ecx
.text$mn:00000EF2                 mov     esp, ebp
.text$mn:00000EF4                 pop     ebp
.text$mn:00000EF5                 retn    4
.text$mn:00000EF5 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000EF5
.text$mn:00000EF5 _text$mn        ends
.text$mn:00000EF5
.text$x:00000EF8 ; ===========================================================================
.text$x:00000EF8
.text$x:00000EF8 ; Segment type: Pure code
.text$x:00000EF8 ; Segment permissions: Read/Execute
.text$x:00000EF8 _text$x         segment para public 'CODE' use32
.text$x:00000EF8                 assume cs:_text$x
.text$x:00000EF8                 ;org 0EF8h
.text$x:00000EF8 ; COMDAT (pick associative to section at EA0)
.text$x:00000EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000EF8
.text$x:00000EF8 ; =============== S U B R O U T I N E =======================================
.text$x:00000EF8
.text$x:00000EF8
.text$x:00000EF8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000EF8                                         ; DATA XREF: .xdata$x:00003F98o
.text$x:00000EF8                 mov     ecx, [ebp-10h]
.text$x:00000EFB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000EFB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000EFB
.text$x:00000F00
.text$x:00000F00 ; =============== S U B R O U T I N E =======================================
.text$x:00000F00
.text$x:00000F00
.text$x:00000F00 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000F00                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000F00
.text$x:00000F00 arg_4           = dword ptr  8
.text$x:00000F00
.text$x:00000F00                 mov     edx, [esp+arg_4]
.text$x:00000F04                 lea     eax, [edx+0Ch]
.text$x:00000F07                 mov     ecx, [edx-8]
.text$x:00000F0A                 xor     ecx, eax
.text$x:00000F0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F11                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000F16                 jmp     ___CxxFrameHandler3
.text$x:00000F16 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000F16
.text$x:00000F16 ; ---------------------------------------------------------------------------
.text$x:00000F1B                 align 4
.text$x:00000F1B _text$x         ends
.text$x:00000F1B
.text$mn:00000F1C ; ===========================================================================
.text$mn:00000F1C
.text$mn:00000F1C ; Segment type: Pure code
.text$mn:00000F1C ; Segment permissions: Read/Execute
.text$mn:00000F1C _text$mn        segment para public 'CODE' use32
.text$mn:00000F1C                 assume cs:_text$mn
.text$mn:00000F1C                 ;org 0F1Ch
.text$mn:00000F1C ; COMDAT (pick any)
.text$mn:00000F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F1C
.text$mn:00000F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F1C
.text$mn:00000F1C ; Attributes: bp-based frame
.text$mn:00000F1C
.text$mn:00000F1C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00000F1C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00000F1C ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00000F1C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:00000F1C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p
.text$mn:00000F1C
.text$mn:00000F1C var_10          = dword ptr -10h
.text$mn:00000F1C var_C           = dword ptr -0Ch
.text$mn:00000F1C var_4           = dword ptr -4
.text$mn:00000F1C
.text$mn:00000F1C                 push    ebp
.text$mn:00000F1D                 mov     ebp, esp
.text$mn:00000F1F                 push    0FFFFFFFFh
.text$mn:00000F21                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00000F26                 mov     eax, large fs:0
.text$mn:00000F2C                 push    eax
.text$mn:00000F2D                 push    ecx
.text$mn:00000F2E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F33                 xor     eax, ebp
.text$mn:00000F35                 push    eax
.text$mn:00000F36                 lea     eax, [ebp+var_C]
.text$mn:00000F39                 mov     large fs:0, eax
.text$mn:00000F3F                 mov     [ebp+var_10], ecx
.text$mn:00000F42                 mov     ecx, [ebp+var_10]
.text$mn:00000F45                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00000F4A                 mov     [ebp+var_4], 0
.text$mn:00000F51                 mov     ecx, [ebp+var_10]
.text$mn:00000F54                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00000F59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F60                 mov     eax, [ebp+var_10]
.text$mn:00000F63                 mov     ecx, [ebp+var_C]
.text$mn:00000F66                 mov     large fs:0, ecx
.text$mn:00000F6D                 pop     ecx
.text$mn:00000F6E                 mov     esp, ebp
.text$mn:00000F70                 pop     ebp
.text$mn:00000F71                 retn    4
.text$mn:00000F71 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00000F71
.text$mn:00000F71 _text$mn        ends
.text$mn:00000F71
.text$x:00000F74 ; ===========================================================================
.text$x:00000F74
.text$x:00000F74 ; Segment type: Pure code
.text$x:00000F74 ; Segment permissions: Read/Execute
.text$x:00000F74 _text$x         segment para public 'CODE' use32
.text$x:00000F74                 assume cs:_text$x
.text$x:00000F74                 ;org 0F74h
.text$x:00000F74 ; COMDAT (pick associative to section at F1C)
.text$x:00000F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F74
.text$x:00000F74 ; =============== S U B R O U T I N E =======================================
.text$x:00000F74
.text$x:00000F74
.text$x:00000F74 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00000F74                                         ; DATA XREF: .xdata$x:000042B8o
.text$x:00000F74                 mov     ecx, [ebp-10h]
.text$x:00000F77                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00000F77 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00000F77
.text$x:00000F7C
.text$x:00000F7C ; =============== S U B R O U T I N E =======================================
.text$x:00000F7C
.text$x:00000F7C
.text$x:00000F7C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00000F7C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00000F7C
.text$x:00000F7C arg_4           = dword ptr  8
.text$x:00000F7C
.text$x:00000F7C                 mov     edx, [esp+arg_4]
.text$x:00000F80                 lea     eax, [edx+0Ch]
.text$x:00000F83                 mov     ecx, [edx-8]
.text$x:00000F86                 xor     ecx, eax
.text$x:00000F88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F8D                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00000F92                 jmp     ___CxxFrameHandler3
.text$x:00000F92 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00000F92
.text$x:00000F92 ; ---------------------------------------------------------------------------
.text$x:00000F97                 align 4
.text$x:00000F97 _text$x         ends
.text$x:00000F97
.text$mn:00000F98 ; ===========================================================================
.text$mn:00000F98
.text$mn:00000F98 ; Segment type: Pure code
.text$mn:00000F98 ; Segment permissions: Read/Execute
.text$mn:00000F98 _text$mn        segment para public 'CODE' use32
.text$mn:00000F98                 assume cs:_text$mn
.text$mn:00000F98                 ;org 0F98h
.text$mn:00000F98 ; COMDAT (pick any)
.text$mn:00000F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F98
.text$mn:00000F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F98
.text$mn:00000F98 ; Attributes: bp-based frame
.text$mn:00000F98
.text$mn:00000F98 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000F98                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000F98 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000F98                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000F98
.text$mn:00000F98 var_10          = dword ptr -10h
.text$mn:00000F98 var_C           = dword ptr -0Ch
.text$mn:00000F98 var_4           = dword ptr -4
.text$mn:00000F98
.text$mn:00000F98                 push    ebp
.text$mn:00000F99                 mov     ebp, esp
.text$mn:00000F9B                 push    0FFFFFFFFh
.text$mn:00000F9D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000FA2                 mov     eax, large fs:0
.text$mn:00000FA8                 push    eax
.text$mn:00000FA9                 push    ecx
.text$mn:00000FAA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FAF                 xor     eax, ebp
.text$mn:00000FB1                 push    eax
.text$mn:00000FB2                 lea     eax, [ebp+var_C]
.text$mn:00000FB5                 mov     large fs:0, eax
.text$mn:00000FBB                 mov     [ebp+var_10], ecx
.text$mn:00000FBE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000FC1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000FC6                 mov     [ebp+var_4], 0
.text$mn:00000FCD                 mov     eax, [ebp+var_10]
.text$mn:00000FD0                 mov     dword ptr [eax+14h], 0
.text$mn:00000FD7                 mov     ecx, [ebp+var_10]
.text$mn:00000FDA                 mov     dword ptr [ecx+18h], 0
.text$mn:00000FE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FE8                 mov     eax, [ebp+var_10]
.text$mn:00000FEB                 mov     ecx, [ebp+var_C]
.text$mn:00000FEE                 mov     large fs:0, ecx
.text$mn:00000FF5                 pop     ecx
.text$mn:00000FF6                 mov     esp, ebp
.text$mn:00000FF8                 pop     ebp
.text$mn:00000FF9                 retn
.text$mn:00000FF9 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000FF9
.text$mn:00000FF9 ; ---------------------------------------------------------------------------
.text$mn:00000FFA                 align 4
.text$mn:00000FFA _text$mn        ends
.text$mn:00000FFA
.text$x:00000FFC ; ===========================================================================
.text$x:00000FFC
.text$x:00000FFC ; Segment type: Pure code
.text$x:00000FFC ; Segment permissions: Read/Execute
.text$x:00000FFC _text$x         segment para public 'CODE' use32
.text$x:00000FFC                 assume cs:_text$x
.text$x:00000FFC                 ;org 0FFCh
.text$x:00000FFC ; COMDAT (pick associative to section at F98)
.text$x:00000FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000FFC
.text$x:00000FFC ; =============== S U B R O U T I N E =======================================
.text$x:00000FFC
.text$x:00000FFC
.text$x:00000FFC __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000FFC                                         ; DATA XREF: .xdata$x:00003F40o
.text$x:00000FFC                 mov     ecx, [ebp-10h]  ; this
.text$x:00000FFF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000FFF __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000FFF
.text$x:00001004
.text$x:00001004 ; =============== S U B R O U T I N E =======================================
.text$x:00001004
.text$x:00001004
.text$x:00001004 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001004                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001004
.text$x:00001004 arg_4           = dword ptr  8
.text$x:00001004
.text$x:00001004                 mov     edx, [esp+arg_4]
.text$x:00001008                 lea     eax, [edx+0Ch]
.text$x:0000100B                 mov     ecx, [edx-8]
.text$x:0000100E                 xor     ecx, eax
.text$x:00001010                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001015                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000101A                 jmp     ___CxxFrameHandler3
.text$x:0000101A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000101A
.text$x:0000101A ; ---------------------------------------------------------------------------
.text$x:0000101F                 align 10h
.text$x:0000101F _text$x         ends
.text$x:0000101F
.text$mn:00001020 ; ===========================================================================
.text$mn:00001020
.text$mn:00001020 ; Segment type: Pure code
.text$mn:00001020 ; Segment permissions: Read/Execute
.text$mn:00001020 _text$mn        segment para public 'CODE' use32
.text$mn:00001020                 assume cs:_text$mn
.text$mn:00001020                 ;org 1020h
.text$mn:00001020 ; COMDAT (pick any)
.text$mn:00001020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001020
.text$mn:00001020 ; =============== S U B R O U T I N E =======================================
.text$mn:00001020
.text$mn:00001020 ; Attributes: bp-based frame
.text$mn:00001020
.text$mn:00001020 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00001020                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001020 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00001020                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00001020
.text$mn:00001020 var_10          = dword ptr -10h
.text$mn:00001020 var_C           = dword ptr -0Ch
.text$mn:00001020 var_4           = dword ptr -4
.text$mn:00001020
.text$mn:00001020                 push    ebp
.text$mn:00001021                 mov     ebp, esp
.text$mn:00001023                 push    0FFFFFFFFh
.text$mn:00001025                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000102A                 mov     eax, large fs:0
.text$mn:00001030                 push    eax
.text$mn:00001031                 push    ecx
.text$mn:00001032                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001037                 xor     eax, ebp
.text$mn:00001039                 push    eax
.text$mn:0000103A                 lea     eax, [ebp+var_C]
.text$mn:0000103D                 mov     large fs:0, eax
.text$mn:00001043                 mov     [ebp+var_10], ecx
.text$mn:00001046                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001049                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000104E                 mov     [ebp+var_4], 0
.text$mn:00001055                 mov     eax, [ebp+var_10]
.text$mn:00001058                 mov     dword ptr [eax+14h], 0
.text$mn:0000105F                 mov     ecx, [ebp+var_10]
.text$mn:00001062                 mov     dword ptr [ecx+18h], 0
.text$mn:00001069                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001070                 mov     eax, [ebp+var_10]
.text$mn:00001073                 mov     ecx, [ebp+var_C]
.text$mn:00001076                 mov     large fs:0, ecx
.text$mn:0000107D                 pop     ecx
.text$mn:0000107E                 mov     esp, ebp
.text$mn:00001080                 pop     ebp
.text$mn:00001081                 retn
.text$mn:00001081 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00001081
.text$mn:00001081 ; ---------------------------------------------------------------------------
.text$mn:00001082                 align 4
.text$mn:00001082 _text$mn        ends
.text$mn:00001082
.text$x:00001084 ; ===========================================================================
.text$x:00001084
.text$x:00001084 ; Segment type: Pure code
.text$x:00001084 ; Segment permissions: Read/Execute
.text$x:00001084 _text$x         segment para public 'CODE' use32
.text$x:00001084                 assume cs:_text$x
.text$x:00001084                 ;org 1084h
.text$x:00001084 ; COMDAT (pick associative to section at 1020)
.text$x:00001084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001084
.text$x:00001084 ; =============== S U B R O U T I N E =======================================
.text$x:00001084
.text$x:00001084
.text$x:00001084 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00001084                                         ; DATA XREF: .xdata$x:00004260o
.text$x:00001084                 mov     ecx, [ebp-10h]  ; this
.text$x:00001087                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001087 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00001087
.text$x:0000108C
.text$x:0000108C ; =============== S U B R O U T I N E =======================================
.text$x:0000108C
.text$x:0000108C
.text$x:0000108C __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:0000108C                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:0000108C
.text$x:0000108C arg_4           = dword ptr  8
.text$x:0000108C
.text$x:0000108C                 mov     edx, [esp+arg_4]
.text$x:00001090                 lea     eax, [edx+0Ch]
.text$x:00001093                 mov     ecx, [edx-8]
.text$x:00001096                 xor     ecx, eax
.text$x:00001098                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000109D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000010A2                 jmp     ___CxxFrameHandler3
.text$x:000010A2 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000010A2
.text$x:000010A2 ; ---------------------------------------------------------------------------
.text$x:000010A7                 align 4
.text$x:000010A7 _text$x         ends
.text$x:000010A7
.text$mn:000010A8 ; ===========================================================================
.text$mn:000010A8
.text$mn:000010A8 ; Segment type: Pure code
.text$mn:000010A8 ; Segment permissions: Read/Execute
.text$mn:000010A8 _text$mn        segment para public 'CODE' use32
.text$mn:000010A8                 assume cs:_text$mn
.text$mn:000010A8                 ;org 10A8h
.text$mn:000010A8 ; COMDAT (pick any)
.text$mn:000010A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010A8
.text$mn:000010A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010A8
.text$mn:000010A8 ; Attributes: bp-based frame
.text$mn:000010A8
.text$mn:000010A8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000010A8                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000010A8 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000010A8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000010A8
.text$mn:000010A8 var_4           = dword ptr -4
.text$mn:000010A8
.text$mn:000010A8                 push    ebp
.text$mn:000010A9                 mov     ebp, esp
.text$mn:000010AB                 push    ecx
.text$mn:000010AC                 mov     [ebp+var_4], ecx
.text$mn:000010AF                 mov     ecx, [ebp+var_4]
.text$mn:000010B2                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000010B7                 mov     eax, [ebp+var_4]
.text$mn:000010BA                 mov     esp, ebp
.text$mn:000010BC                 pop     ebp
.text$mn:000010BD                 retn
.text$mn:000010BD ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000010BD
.text$mn:000010BD ; ---------------------------------------------------------------------------
.text$mn:000010BE                 align 10h
.text$mn:000010BE _text$mn        ends
.text$mn:000010BE
.text$mn:000010C0 ; ===========================================================================
.text$mn:000010C0
.text$mn:000010C0 ; Segment type: Pure code
.text$mn:000010C0 ; Segment permissions: Read/Execute
.text$mn:000010C0 _text$mn        segment para public 'CODE' use32
.text$mn:000010C0                 assume cs:_text$mn
.text$mn:000010C0                 ;org 10C0h
.text$mn:000010C0 ; COMDAT (pick any)
.text$mn:000010C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010C0
.text$mn:000010C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010C0
.text$mn:000010C0 ; Attributes: bp-based frame
.text$mn:000010C0
.text$mn:000010C0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct HMENU__ *>>::_Wrap_alloc<class std::allocator<struct HMENU__ *>>(void)
.text$mn:000010C0                 public ??0?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ
.text$mn:000010C0 ??0?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ proc near
.text$mn:000010C0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)+Ap
.text$mn:000010C0
.text$mn:000010C0 var_4           = dword ptr -4
.text$mn:000010C0
.text$mn:000010C0                 push    ebp
.text$mn:000010C1                 mov     ebp, esp
.text$mn:000010C3                 push    ecx
.text$mn:000010C4                 mov     [ebp+var_4], ecx
.text$mn:000010C7                 mov     ecx, [ebp+var_4]
.text$mn:000010CA                 call    ??0?$allocator@PAUHMENU__@@@std@@QAE@XZ ; std::allocator<HMENU__ *>::allocator<HMENU__ *>(void)
.text$mn:000010CF                 mov     eax, [ebp+var_4]
.text$mn:000010D2                 mov     esp, ebp
.text$mn:000010D4                 pop     ebp
.text$mn:000010D5                 retn
.text$mn:000010D5 ??0?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ endp
.text$mn:000010D5
.text$mn:000010D5 ; ---------------------------------------------------------------------------
.text$mn:000010D6                 align 4
.text$mn:000010D6 _text$mn        ends
.text$mn:000010D6
.text$mn:000010D8 ; ===========================================================================
.text$mn:000010D8
.text$mn:000010D8 ; Segment type: Pure code
.text$mn:000010D8 ; Segment permissions: Read/Execute
.text$mn:000010D8 _text$mn        segment para public 'CODE' use32
.text$mn:000010D8                 assume cs:_text$mn
.text$mn:000010D8                 ;org 10D8h
.text$mn:000010D8 ; COMDAT (pick any)
.text$mn:000010D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010D8
.text$mn:000010D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010D8
.text$mn:000010D8 ; Attributes: bp-based frame
.text$mn:000010D8
.text$mn:000010D8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000010D8                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000010D8 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000010D8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Free_proxy(void)+Cp
.text$mn:000010D8
.text$mn:000010D8 var_4           = dword ptr -4
.text$mn:000010D8
.text$mn:000010D8                 push    ebp
.text$mn:000010D9                 mov     ebp, esp
.text$mn:000010DB                 push    ecx
.text$mn:000010DC                 mov     [ebp+var_4], ecx
.text$mn:000010DF                 mov     ecx, [ebp+var_4]
.text$mn:000010E2                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000010E7                 mov     eax, [ebp+var_4]
.text$mn:000010EA                 mov     esp, ebp
.text$mn:000010EC                 pop     ebp
.text$mn:000010ED                 retn
.text$mn:000010ED ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:000010ED
.text$mn:000010ED ; ---------------------------------------------------------------------------
.text$mn:000010EE                 align 10h
.text$mn:000010EE _text$mn        ends
.text$mn:000010EE
.text$mn:000010F0 ; ===========================================================================
.text$mn:000010F0
.text$mn:000010F0 ; Segment type: Pure code
.text$mn:000010F0 ; Segment permissions: Read/Execute
.text$mn:000010F0 _text$mn        segment para public 'CODE' use32
.text$mn:000010F0                 assume cs:_text$mn
.text$mn:000010F0                 ;org 10F0h
.text$mn:000010F0 ; COMDAT (pick any)
.text$mn:000010F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010F0
.text$mn:000010F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010F0
.text$mn:000010F0 ; Attributes: bp-based frame
.text$mn:000010F0
.text$mn:000010F0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:000010F0                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:000010F0 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:000010F0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:000010F0
.text$mn:000010F0 var_4           = dword ptr -4
.text$mn:000010F0
.text$mn:000010F0                 push    ebp
.text$mn:000010F1                 mov     ebp, esp
.text$mn:000010F3                 push    ecx
.text$mn:000010F4                 mov     [ebp+var_4], ecx
.text$mn:000010F7                 mov     ecx, [ebp+var_4]
.text$mn:000010FA                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000010FF                 mov     eax, [ebp+var_4]
.text$mn:00001102                 mov     esp, ebp
.text$mn:00001104                 pop     ebp
.text$mn:00001105                 retn
.text$mn:00001105 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00001105
.text$mn:00001105 ; ---------------------------------------------------------------------------
.text$mn:00001106                 align 4
.text$mn:00001106 _text$mn        ends
.text$mn:00001106
.text$mn:00001108 ; ===========================================================================
.text$mn:00001108
.text$mn:00001108 ; Segment type: Pure code
.text$mn:00001108 ; Segment permissions: Read/Execute
.text$mn:00001108 _text$mn        segment para public 'CODE' use32
.text$mn:00001108                 assume cs:_text$mn
.text$mn:00001108                 ;org 1108h
.text$mn:00001108 ; COMDAT (pick any)
.text$mn:00001108                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001108
.text$mn:00001108 ; =============== S U B R O U T I N E =======================================
.text$mn:00001108
.text$mn:00001108 ; Attributes: bp-based frame
.text$mn:00001108
.text$mn:00001108 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00001108                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00001108 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00001108                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00001108
.text$mn:00001108 var_4           = dword ptr -4
.text$mn:00001108
.text$mn:00001108                 push    ebp
.text$mn:00001109                 mov     ebp, esp
.text$mn:0000110B                 push    ecx
.text$mn:0000110C                 mov     [ebp+var_4], ecx
.text$mn:0000110F                 mov     eax, [ebp+var_4]
.text$mn:00001112                 mov     esp, ebp
.text$mn:00001114                 pop     ebp
.text$mn:00001115                 retn
.text$mn:00001115 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00001115
.text$mn:00001115 ; ---------------------------------------------------------------------------
.text$mn:00001116                 align 4
.text$mn:00001116 _text$mn        ends
.text$mn:00001116
.text$mn:00001118 ; ===========================================================================
.text$mn:00001118
.text$mn:00001118 ; Segment type: Pure code
.text$mn:00001118 ; Segment permissions: Read/Execute
.text$mn:00001118 _text$mn        segment para public 'CODE' use32
.text$mn:00001118                 assume cs:_text$mn
.text$mn:00001118                 ;org 1118h
.text$mn:00001118 ; COMDAT (pick any)
.text$mn:00001118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001118
.text$mn:00001118 ; =============== S U B R O U T I N E =======================================
.text$mn:00001118
.text$mn:00001118 ; Attributes: bp-based frame
.text$mn:00001118
.text$mn:00001118 ; public: __thiscall std::allocator<struct HMENU__ *>::allocator<struct HMENU__ *>(void)
.text$mn:00001118                 public ??0?$allocator@PAUHMENU__@@@std@@QAE@XZ
.text$mn:00001118 ??0?$allocator@PAUHMENU__@@@std@@QAE@XZ proc near
.text$mn:00001118                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::_Wrap_alloc<std::allocator<HMENU__ *>>(void)+Ap
.text$mn:00001118
.text$mn:00001118 var_4           = dword ptr -4
.text$mn:00001118
.text$mn:00001118                 push    ebp
.text$mn:00001119                 mov     ebp, esp
.text$mn:0000111B                 push    ecx
.text$mn:0000111C                 mov     [ebp+var_4], ecx
.text$mn:0000111F                 mov     eax, [ebp+var_4]
.text$mn:00001122                 mov     esp, ebp
.text$mn:00001124                 pop     ebp
.text$mn:00001125                 retn
.text$mn:00001125 ??0?$allocator@PAUHMENU__@@@std@@QAE@XZ endp
.text$mn:00001125
.text$mn:00001125 ; ---------------------------------------------------------------------------
.text$mn:00001126                 align 4
.text$mn:00001126 _text$mn        ends
.text$mn:00001126
.text$mn:00001128 ; ===========================================================================
.text$mn:00001128
.text$mn:00001128 ; Segment type: Pure code
.text$mn:00001128 ; Segment permissions: Read/Execute
.text$mn:00001128 _text$mn        segment para public 'CODE' use32
.text$mn:00001128                 assume cs:_text$mn
.text$mn:00001128                 ;org 1128h
.text$mn:00001128 ; COMDAT (pick any)
.text$mn:00001128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001128
.text$mn:00001128 ; =============== S U B R O U T I N E =======================================
.text$mn:00001128
.text$mn:00001128 ; Attributes: bp-based frame
.text$mn:00001128
.text$mn:00001128 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00001128                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00001128 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00001128                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00001128                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00001128
.text$mn:00001128 var_4           = dword ptr -4
.text$mn:00001128
.text$mn:00001128                 push    ebp
.text$mn:00001129                 mov     ebp, esp
.text$mn:0000112B                 push    ecx
.text$mn:0000112C                 mov     [ebp+var_4], ecx
.text$mn:0000112F                 mov     eax, [ebp+var_4]
.text$mn:00001132                 mov     esp, ebp
.text$mn:00001134                 pop     ebp
.text$mn:00001135                 retn
.text$mn:00001135 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00001135
.text$mn:00001135 ; ---------------------------------------------------------------------------
.text$mn:00001136                 align 4
.text$mn:00001136 _text$mn        ends
.text$mn:00001136
.text$mn:00001138 ; ===========================================================================
.text$mn:00001138
.text$mn:00001138 ; Segment type: Pure code
.text$mn:00001138 ; Segment permissions: Read/Execute
.text$mn:00001138 _text$mn        segment para public 'CODE' use32
.text$mn:00001138                 assume cs:_text$mn
.text$mn:00001138                 ;org 1138h
.text$mn:00001138 ; COMDAT (pick any)
.text$mn:00001138                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001138
.text$mn:00001138 ; =============== S U B R O U T I N E =======================================
.text$mn:00001138
.text$mn:00001138 ; Attributes: bp-based frame
.text$mn:00001138
.text$mn:00001138 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00001138                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00001138 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00001138                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Bp
.text$mn:00001138                                         ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+18p
.text$mn:00001138
.text$mn:00001138 var_4           = dword ptr -4
.text$mn:00001138
.text$mn:00001138                 push    ebp
.text$mn:00001139                 mov     ebp, esp
.text$mn:0000113B                 push    ecx
.text$mn:0000113C                 mov     [ebp+var_4], ecx
.text$mn:0000113F                 mov     eax, [ebp+var_4]
.text$mn:00001142                 mov     esp, ebp
.text$mn:00001144                 pop     ebp
.text$mn:00001145                 retn    4
.text$mn:00001145 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00001145
.text$mn:00001145 _text$mn        ends
.text$mn:00001145
.text$mn:00001148 ; ===========================================================================
.text$mn:00001148
.text$mn:00001148 ; Segment type: Pure code
.text$mn:00001148 ; Segment permissions: Read/Execute
.text$mn:00001148 _text$mn        segment para public 'CODE' use32
.text$mn:00001148                 assume cs:_text$mn
.text$mn:00001148                 ;org 1148h
.text$mn:00001148 ; COMDAT (pick any)
.text$mn:00001148                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001148
.text$mn:00001148 ; =============== S U B R O U T I N E =======================================
.text$mn:00001148
.text$mn:00001148 ; Attributes: bp-based frame
.text$mn:00001148
.text$mn:00001148 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00001148                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00001148 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00001148                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:00001148
.text$mn:00001148 var_4           = dword ptr -4
.text$mn:00001148
.text$mn:00001148                 push    ebp
.text$mn:00001149                 mov     ebp, esp
.text$mn:0000114B                 push    ecx
.text$mn:0000114C                 mov     [ebp+var_4], ecx
.text$mn:0000114F                 mov     eax, [ebp+var_4]
.text$mn:00001152                 mov     esp, ebp
.text$mn:00001154                 pop     ebp
.text$mn:00001155                 retn
.text$mn:00001155 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00001155
.text$mn:00001155 ; ---------------------------------------------------------------------------
.text$mn:00001156                 align 4
.text$mn:00001156 _text$mn        ends
.text$mn:00001156
.text$mn:00001158 ; ===========================================================================
.text$mn:00001158
.text$mn:00001158 ; Segment type: Pure code
.text$mn:00001158 ; Segment permissions: Read/Execute
.text$mn:00001158 _text$mn        segment para public 'CODE' use32
.text$mn:00001158                 assume cs:_text$mn
.text$mn:00001158                 ;org 1158h
.text$mn:00001158 ; COMDAT (pick any)
.text$mn:00001158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001158
.text$mn:00001158 ; =============== S U B R O U T I N E =======================================
.text$mn:00001158
.text$mn:00001158 ; Attributes: bp-based frame
.text$mn:00001158
.text$mn:00001158 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00001158                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001158 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00001158                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00001158                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00001158
.text$mn:00001158 var_14          = dword ptr -14h
.text$mn:00001158 var_D           = byte ptr -0Dh
.text$mn:00001158 var_C           = dword ptr -0Ch
.text$mn:00001158 var_4           = dword ptr -4
.text$mn:00001158 Str             = dword ptr  8
.text$mn:00001158
.text$mn:00001158                 push    ebp
.text$mn:00001159                 mov     ebp, esp
.text$mn:0000115B                 push    0FFFFFFFFh
.text$mn:0000115D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001162                 mov     eax, large fs:0
.text$mn:00001168                 push    eax
.text$mn:00001169                 sub     esp, 8
.text$mn:0000116C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001171                 xor     eax, ebp
.text$mn:00001173                 push    eax
.text$mn:00001174                 lea     eax, [ebp+var_C]
.text$mn:00001177                 mov     large fs:0, eax
.text$mn:0000117D                 mov     [ebp+var_14], ecx
.text$mn:00001180                 lea     ecx, [ebp+var_D]
.text$mn:00001183                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001188                 push    eax
.text$mn:00001189                 mov     ecx, [ebp+var_14]
.text$mn:0000118C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00001191                 mov     [ebp+var_4], 0
.text$mn:00001198                 push    0               ; Size
.text$mn:0000119A                 push    0               ; char
.text$mn:0000119C                 mov     ecx, [ebp+var_14]
.text$mn:0000119F                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000011A4                 mov     eax, [ebp+Str]
.text$mn:000011A7                 push    eax             ; Str
.text$mn:000011A8                 mov     ecx, [ebp+var_14]
.text$mn:000011AB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000011B0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011B7                 mov     eax, [ebp+var_14]
.text$mn:000011BA                 mov     ecx, [ebp+var_C]
.text$mn:000011BD                 mov     large fs:0, ecx
.text$mn:000011C4                 pop     ecx
.text$mn:000011C5                 mov     esp, ebp
.text$mn:000011C7                 pop     ebp
.text$mn:000011C8                 retn    4
.text$mn:000011C8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000011C8
.text$mn:000011C8 ; ---------------------------------------------------------------------------
.text$mn:000011CB                 align 4
.text$mn:000011CB _text$mn        ends
.text$mn:000011CB
.text$x:000011CC ; ===========================================================================
.text$x:000011CC
.text$x:000011CC ; Segment type: Pure code
.text$x:000011CC ; Segment permissions: Read/Execute
.text$x:000011CC _text$x         segment para public 'CODE' use32
.text$x:000011CC                 assume cs:_text$x
.text$x:000011CC                 ;org 11CCh
.text$x:000011CC ; COMDAT (pick associative to section at 1158)
.text$x:000011CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000011CC
.text$x:000011CC ; =============== S U B R O U T I N E =======================================
.text$x:000011CC
.text$x:000011CC
.text$x:000011CC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000011CC                                         ; DATA XREF: .xdata$x:00003FF0o
.text$x:000011CC                 mov     ecx, [ebp-14h]
.text$x:000011CF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000011CF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000011CF
.text$x:000011D4
.text$x:000011D4 ; =============== S U B R O U T I N E =======================================
.text$x:000011D4
.text$x:000011D4
.text$x:000011D4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000011D4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000011D4
.text$x:000011D4 arg_4           = dword ptr  8
.text$x:000011D4
.text$x:000011D4                 mov     edx, [esp+arg_4]
.text$x:000011D8                 lea     eax, [edx+0Ch]
.text$x:000011DB                 mov     ecx, [edx-0Ch]
.text$x:000011DE                 xor     ecx, eax
.text$x:000011E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011E5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000011EA                 jmp     ___CxxFrameHandler3
.text$x:000011EA __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000011EA
.text$x:000011EA ; ---------------------------------------------------------------------------
.text$x:000011EF                 align 10h
.text$x:000011EF _text$x         ends
.text$x:000011EF
.text$mn:000011F0 ; ===========================================================================
.text$mn:000011F0
.text$mn:000011F0 ; Segment type: Pure code
.text$mn:000011F0 ; Segment permissions: Read/Execute
.text$mn:000011F0 _text$mn        segment para public 'CODE' use32
.text$mn:000011F0                 assume cs:_text$mn
.text$mn:000011F0                 ;org 11F0h
.text$mn:000011F0 ; COMDAT (pick any)
.text$mn:000011F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011F0
.text$mn:000011F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011F0
.text$mn:000011F0 ; Attributes: bp-based frame
.text$mn:000011F0
.text$mn:000011F0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:000011F0                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000011F0 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:000011F0                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+52p
.text$mn:000011F0
.text$mn:000011F0 var_14          = dword ptr -14h
.text$mn:000011F0 var_D           = byte ptr -0Dh
.text$mn:000011F0 var_C           = dword ptr -0Ch
.text$mn:000011F0 var_4           = dword ptr -4
.text$mn:000011F0 Str             = dword ptr  8
.text$mn:000011F0
.text$mn:000011F0                 push    ebp
.text$mn:000011F1                 mov     ebp, esp
.text$mn:000011F3                 push    0FFFFFFFFh
.text$mn:000011F5                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000011FA                 mov     eax, large fs:0
.text$mn:00001200                 push    eax
.text$mn:00001201                 sub     esp, 8
.text$mn:00001204                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001209                 xor     eax, ebp
.text$mn:0000120B                 push    eax
.text$mn:0000120C                 lea     eax, [ebp+var_C]
.text$mn:0000120F                 mov     large fs:0, eax
.text$mn:00001215                 mov     [ebp+var_14], ecx
.text$mn:00001218                 lea     ecx, [ebp+var_D]
.text$mn:0000121B                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00001220                 push    eax
.text$mn:00001221                 mov     ecx, [ebp+var_14]
.text$mn:00001224                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00001229                 mov     [ebp+var_4], 0
.text$mn:00001230                 push    0
.text$mn:00001232                 push    0
.text$mn:00001234                 mov     ecx, [ebp+var_14]
.text$mn:00001237                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000123C                 mov     eax, [ebp+Str]
.text$mn:0000123F                 push    eax             ; Str
.text$mn:00001240                 mov     ecx, [ebp+var_14]
.text$mn:00001243                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00001248                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000124F                 mov     eax, [ebp+var_14]
.text$mn:00001252                 mov     ecx, [ebp+var_C]
.text$mn:00001255                 mov     large fs:0, ecx
.text$mn:0000125C                 pop     ecx
.text$mn:0000125D                 mov     esp, ebp
.text$mn:0000125F                 pop     ebp
.text$mn:00001260                 retn    4
.text$mn:00001260 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00001260
.text$mn:00001260 ; ---------------------------------------------------------------------------
.text$mn:00001263                 align 4
.text$mn:00001263 _text$mn        ends
.text$mn:00001263
.text$x:00001264 ; ===========================================================================
.text$x:00001264
.text$x:00001264 ; Segment type: Pure code
.text$x:00001264 ; Segment permissions: Read/Execute
.text$x:00001264 _text$x         segment para public 'CODE' use32
.text$x:00001264                 assume cs:_text$x
.text$x:00001264                 ;org 1264h
.text$x:00001264 ; COMDAT (pick associative to section at 11F0)
.text$x:00001264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001264
.text$x:00001264 ; =============== S U B R O U T I N E =======================================
.text$x:00001264
.text$x:00001264
.text$x:00001264 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00001264                                         ; DATA XREF: .xdata$x:0000433Co
.text$x:00001264                 mov     ecx, [ebp-14h]
.text$x:00001267                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00001267 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00001267
.text$x:0000126C
.text$x:0000126C ; =============== S U B R O U T I N E =======================================
.text$x:0000126C
.text$x:0000126C
.text$x:0000126C __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:0000126C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:0000126C
.text$x:0000126C arg_4           = dword ptr  8
.text$x:0000126C
.text$x:0000126C                 mov     edx, [esp+arg_4]
.text$x:00001270                 lea     eax, [edx+0Ch]
.text$x:00001273                 mov     ecx, [edx-0Ch]
.text$x:00001276                 xor     ecx, eax
.text$x:00001278                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000127D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00001282                 jmp     ___CxxFrameHandler3
.text$x:00001282 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00001282
.text$x:00001282 ; ---------------------------------------------------------------------------
.text$x:00001287                 align 4
.text$x:00001287 _text$x         ends
.text$x:00001287
.text$mn:00001288 ; ===========================================================================
.text$mn:00001288
.text$mn:00001288 ; Segment type: Pure code
.text$mn:00001288 ; Segment permissions: Read/Execute
.text$mn:00001288 _text$mn        segment para public 'CODE' use32
.text$mn:00001288                 assume cs:_text$mn
.text$mn:00001288                 ;org 1288h
.text$mn:00001288 ; COMDAT (pick any)
.text$mn:00001288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001288
.text$mn:00001288 ; =============== S U B R O U T I N E =======================================
.text$mn:00001288
.text$mn:00001288 ; Attributes: bp-based frame
.text$mn:00001288
.text$mn:00001288 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00001288                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001288 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00001288                                         ; CODE XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+34p
.text$mn:00001288                                         ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+46p
.text$mn:00001288
.text$mn:00001288 var_14          = dword ptr -14h
.text$mn:00001288 var_D           = byte ptr -0Dh
.text$mn:00001288 var_C           = dword ptr -0Ch
.text$mn:00001288 var_4           = dword ptr -4
.text$mn:00001288
.text$mn:00001288                 push    ebp
.text$mn:00001289                 mov     ebp, esp
.text$mn:0000128B                 push    0FFFFFFFFh
.text$mn:0000128D                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001292                 mov     eax, large fs:0
.text$mn:00001298                 push    eax
.text$mn:00001299                 sub     esp, 8
.text$mn:0000129C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012A1                 xor     eax, ebp
.text$mn:000012A3                 push    eax
.text$mn:000012A4                 lea     eax, [ebp+var_C]
.text$mn:000012A7                 mov     large fs:0, eax
.text$mn:000012AD                 mov     [ebp+var_14], ecx
.text$mn:000012B0                 lea     ecx, [ebp+var_D]
.text$mn:000012B3                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000012B8                 push    eax
.text$mn:000012B9                 mov     ecx, [ebp+var_14]
.text$mn:000012BC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000012C1                 mov     [ebp+var_4], 0
.text$mn:000012C8                 push    0
.text$mn:000012CA                 push    0
.text$mn:000012CC                 mov     ecx, [ebp+var_14]
.text$mn:000012CF                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000012D4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012DB                 mov     eax, [ebp+var_14]
.text$mn:000012DE                 mov     ecx, [ebp+var_C]
.text$mn:000012E1                 mov     large fs:0, ecx
.text$mn:000012E8                 pop     ecx
.text$mn:000012E9                 mov     esp, ebp
.text$mn:000012EB                 pop     ebp
.text$mn:000012EC                 retn
.text$mn:000012EC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000012EC
.text$mn:000012EC ; ---------------------------------------------------------------------------
.text$mn:000012ED                 align 10h
.text$mn:000012ED _text$mn        ends
.text$mn:000012ED
.text$x:000012F0 ; ===========================================================================
.text$x:000012F0
.text$x:000012F0 ; Segment type: Pure code
.text$x:000012F0 ; Segment permissions: Read/Execute
.text$x:000012F0 _text$x         segment para public 'CODE' use32
.text$x:000012F0                 assume cs:_text$x
.text$x:000012F0                 ;org 12F0h
.text$x:000012F0 ; COMDAT (pick associative to section at 1288)
.text$x:000012F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012F0
.text$x:000012F0 ; =============== S U B R O U T I N E =======================================
.text$x:000012F0
.text$x:000012F0
.text$x:000012F0 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000012F0                                         ; DATA XREF: .xdata$x:00004310o
.text$x:000012F0                 mov     ecx, [ebp-14h]
.text$x:000012F3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000012F3 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000012F3
.text$x:000012F8
.text$x:000012F8 ; =============== S U B R O U T I N E =======================================
.text$x:000012F8
.text$x:000012F8
.text$x:000012F8 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000012F8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000012F8
.text$x:000012F8 arg_4           = dword ptr  8
.text$x:000012F8
.text$x:000012F8                 mov     edx, [esp+arg_4]
.text$x:000012FC                 lea     eax, [edx+0Ch]
.text$x:000012FF                 mov     ecx, [edx-0Ch]
.text$x:00001302                 xor     ecx, eax
.text$x:00001304                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001309                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:0000130E                 jmp     ___CxxFrameHandler3
.text$x:0000130E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:0000130E
.text$x:0000130E ; ---------------------------------------------------------------------------
.text$x:00001313                 align 4
.text$x:00001313 _text$x         ends
.text$x:00001313
.text$mn:00001314 ; ===========================================================================
.text$mn:00001314
.text$mn:00001314 ; Segment type: Pure code
.text$mn:00001314 ; Segment permissions: Read/Execute
.text$mn:00001314 _text$mn        segment para public 'CODE' use32
.text$mn:00001314                 assume cs:_text$mn
.text$mn:00001314                 ;org 1314h
.text$mn:00001314 ; COMDAT (pick any)
.text$mn:00001314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001314
.text$mn:00001314 ; =============== S U B R O U T I N E =======================================
.text$mn:00001314
.text$mn:00001314 ; Attributes: bp-based frame
.text$mn:00001314
.text$mn:00001314 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001314                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001314 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001314                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001314                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p
.text$mn:00001314
.text$mn:00001314 var_4           = dword ptr -4
.text$mn:00001314
.text$mn:00001314                 push    ebp
.text$mn:00001315                 mov     ebp, esp
.text$mn:00001317                 push    ecx
.text$mn:00001318                 mov     [ebp+var_4], ecx
.text$mn:0000131B                 mov     eax, [ebp+var_4]
.text$mn:0000131E                 mov     dword ptr [eax], 0
.text$mn:00001324                 mov     eax, [ebp+var_4]
.text$mn:00001327                 mov     esp, ebp
.text$mn:00001329                 pop     ebp
.text$mn:0000132A                 retn
.text$mn:0000132A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000132A
.text$mn:0000132A ; ---------------------------------------------------------------------------
.text$mn:0000132B                 align 4
.text$mn:0000132B _text$mn        ends
.text$mn:0000132B
.text$mn:0000132C ; ===========================================================================
.text$mn:0000132C
.text$mn:0000132C ; Segment type: Pure code
.text$mn:0000132C ; Segment permissions: Read/Execute
.text$mn:0000132C _text$mn        segment para public 'CODE' use32
.text$mn:0000132C                 assume cs:_text$mn
.text$mn:0000132C                 ;org 132Ch
.text$mn:0000132C ; COMDAT (pick any)
.text$mn:0000132C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000132C
.text$mn:0000132C ; =============== S U B R O U T I N E =======================================
.text$mn:0000132C
.text$mn:0000132C ; Attributes: bp-based frame
.text$mn:0000132C
.text$mn:0000132C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000132C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000132C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000132C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000132C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p
.text$mn:0000132C
.text$mn:0000132C var_4           = dword ptr -4
.text$mn:0000132C
.text$mn:0000132C                 push    ebp
.text$mn:0000132D                 mov     ebp, esp
.text$mn:0000132F                 push    ecx
.text$mn:00001330                 mov     [ebp+var_4], ecx
.text$mn:00001333                 mov     eax, [ebp+var_4]
.text$mn:00001336                 mov     dword ptr [eax], 0
.text$mn:0000133C                 mov     ecx, [ebp+var_4]
.text$mn:0000133F                 mov     dword ptr [ecx+4], 0
.text$mn:00001346                 mov     eax, [ebp+var_4]
.text$mn:00001349                 mov     esp, ebp
.text$mn:0000134B                 pop     ebp
.text$mn:0000134C                 retn
.text$mn:0000134C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000134C
.text$mn:0000134C ; ---------------------------------------------------------------------------
.text$mn:0000134D                 align 10h
.text$mn:0000134D _text$mn        ends
.text$mn:0000134D
.text$mn:00001350 ; ===========================================================================
.text$mn:00001350
.text$mn:00001350 ; Segment type: Pure code
.text$mn:00001350 ; Segment permissions: Read/Execute
.text$mn:00001350 _text$mn        segment para public 'CODE' use32
.text$mn:00001350                 assume cs:_text$mn
.text$mn:00001350                 ;org 1350h
.text$mn:00001350 ; COMDAT (pick any)
.text$mn:00001350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001350
.text$mn:00001350 ; =============== S U B R O U T I N E =======================================
.text$mn:00001350
.text$mn:00001350 ; Attributes: bp-based frame
.text$mn:00001350
.text$mn:00001350 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001350                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001350 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001350                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001350                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001350
.text$mn:00001350 var_10          = dword ptr -10h
.text$mn:00001350 var_C           = dword ptr -0Ch
.text$mn:00001350 var_4           = dword ptr -4
.text$mn:00001350
.text$mn:00001350                 push    ebp
.text$mn:00001351                 mov     ebp, esp
.text$mn:00001353                 push    0FFFFFFFFh
.text$mn:00001355                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000135A                 mov     eax, large fs:0
.text$mn:00001360                 push    eax
.text$mn:00001361                 push    ecx
.text$mn:00001362                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001367                 xor     eax, ebp
.text$mn:00001369                 push    eax
.text$mn:0000136A                 lea     eax, [ebp+var_C]
.text$mn:0000136D                 mov     large fs:0, eax
.text$mn:00001373                 mov     [ebp+var_10], ecx
.text$mn:00001376                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001379                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000137E                 mov     [ebp+var_4], 0
.text$mn:00001385                 mov     eax, [ebp+var_10]
.text$mn:00001388                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000138E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001395                 mov     eax, [ebp+var_10]
.text$mn:00001398                 mov     ecx, [ebp+var_C]
.text$mn:0000139B                 mov     large fs:0, ecx
.text$mn:000013A2                 pop     ecx
.text$mn:000013A3                 mov     esp, ebp
.text$mn:000013A5                 pop     ebp
.text$mn:000013A6                 retn
.text$mn:000013A6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000013A6
.text$mn:000013A6 ; ---------------------------------------------------------------------------
.text$mn:000013A7                 align 4
.text$mn:000013A7 _text$mn        ends
.text$mn:000013A7
.text$x:000013A8 ; ===========================================================================
.text$x:000013A8
.text$x:000013A8 ; Segment type: Pure code
.text$x:000013A8 ; Segment permissions: Read/Execute
.text$x:000013A8 _text$x         segment para public 'CODE' use32
.text$x:000013A8                 assume cs:_text$x
.text$x:000013A8                 ;org 13A8h
.text$x:000013A8 ; COMDAT (pick associative to section at 1350)
.text$x:000013A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000013A8
.text$x:000013A8 ; =============== S U B R O U T I N E =======================================
.text$x:000013A8
.text$x:000013A8
.text$x:000013A8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000013A8                                         ; DATA XREF: .xdata$x:000040D4o
.text$x:000013A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000013AB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000013AB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000013AB
.text$x:000013B0
.text$x:000013B0 ; =============== S U B R O U T I N E =======================================
.text$x:000013B0
.text$x:000013B0
.text$x:000013B0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000013B0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000013B0
.text$x:000013B0 arg_4           = dword ptr  8
.text$x:000013B0
.text$x:000013B0                 mov     edx, [esp+arg_4]
.text$x:000013B4                 lea     eax, [edx+0Ch]
.text$x:000013B7                 mov     ecx, [edx-8]
.text$x:000013BA                 xor     ecx, eax
.text$x:000013BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013C1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000013C6                 jmp     ___CxxFrameHandler3
.text$x:000013C6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000013C6
.text$x:000013C6 ; ---------------------------------------------------------------------------
.text$x:000013CB                 align 4
.text$x:000013CB _text$x         ends
.text$x:000013CB
.text$mn:000013CC ; ===========================================================================
.text$mn:000013CC
.text$mn:000013CC ; Segment type: Pure code
.text$mn:000013CC ; Segment permissions: Read/Execute
.text$mn:000013CC _text$mn        segment para public 'CODE' use32
.text$mn:000013CC                 assume cs:_text$mn
.text$mn:000013CC                 ;org 13CCh
.text$mn:000013CC ; COMDAT (pick any)
.text$mn:000013CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013CC
.text$mn:000013CC ; =============== S U B R O U T I N E =======================================
.text$mn:000013CC
.text$mn:000013CC ; Attributes: bp-based frame
.text$mn:000013CC
.text$mn:000013CC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000013CC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000013CC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000013CC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000013CC
.text$mn:000013CC var_10          = dword ptr -10h
.text$mn:000013CC var_C           = dword ptr -0Ch
.text$mn:000013CC var_4           = dword ptr -4
.text$mn:000013CC
.text$mn:000013CC                 push    ebp
.text$mn:000013CD                 mov     ebp, esp
.text$mn:000013CF                 push    0FFFFFFFFh
.text$mn:000013D1                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000013D6                 mov     eax, large fs:0
.text$mn:000013DC                 push    eax
.text$mn:000013DD                 push    ecx
.text$mn:000013DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000013E3                 xor     eax, ebp
.text$mn:000013E5                 push    eax
.text$mn:000013E6                 lea     eax, [ebp+var_C]
.text$mn:000013E9                 mov     large fs:0, eax
.text$mn:000013EF                 mov     [ebp+var_10], ecx
.text$mn:000013F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000013F5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000013FA                 mov     [ebp+var_4], 0
.text$mn:00001401                 mov     eax, [ebp+var_10]
.text$mn:00001404                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000140A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001411                 mov     eax, [ebp+var_10]
.text$mn:00001414                 mov     ecx, [ebp+var_C]
.text$mn:00001417                 mov     large fs:0, ecx
.text$mn:0000141E                 pop     ecx
.text$mn:0000141F                 mov     esp, ebp
.text$mn:00001421                 pop     ebp
.text$mn:00001422                 retn
.text$mn:00001422 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001422
.text$mn:00001422 ; ---------------------------------------------------------------------------
.text$mn:00001423                 align 4
.text$mn:00001423 _text$mn        ends
.text$mn:00001423
.text$x:00001424 ; ===========================================================================
.text$x:00001424
.text$x:00001424 ; Segment type: Pure code
.text$x:00001424 ; Segment permissions: Read/Execute
.text$x:00001424 _text$x         segment para public 'CODE' use32
.text$x:00001424                 assume cs:_text$x
.text$x:00001424                 ;org 1424h
.text$x:00001424 ; COMDAT (pick associative to section at 13CC)
.text$x:00001424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001424
.text$x:00001424 ; =============== S U B R O U T I N E =======================================
.text$x:00001424
.text$x:00001424
.text$x:00001424 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001424                                         ; DATA XREF: .xdata$x:00004158o
.text$x:00001424                 mov     ecx, [ebp-10h]  ; this
.text$x:00001427                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001427 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001427
.text$x:0000142C
.text$x:0000142C ; =============== S U B R O U T I N E =======================================
.text$x:0000142C
.text$x:0000142C
.text$x:0000142C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000142C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000142C
.text$x:0000142C arg_4           = dword ptr  8
.text$x:0000142C
.text$x:0000142C                 mov     edx, [esp+arg_4]
.text$x:00001430                 lea     eax, [edx+0Ch]
.text$x:00001433                 mov     ecx, [edx-8]
.text$x:00001436                 xor     ecx, eax
.text$x:00001438                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000143D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001442                 jmp     ___CxxFrameHandler3
.text$x:00001442 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001442
.text$x:00001442 ; ---------------------------------------------------------------------------
.text$x:00001447                 align 4
.text$x:00001447 _text$x         ends
.text$x:00001447
.text$mn:00001448 ; ===========================================================================
.text$mn:00001448
.text$mn:00001448 ; Segment type: Pure code
.text$mn:00001448 ; Segment permissions: Read/Execute
.text$mn:00001448 _text$mn        segment para public 'CODE' use32
.text$mn:00001448                 assume cs:_text$mn
.text$mn:00001448                 ;org 1448h
.text$mn:00001448 ; COMDAT (pick any)
.text$mn:00001448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001448
.text$mn:00001448 ; =============== S U B R O U T I N E =======================================
.text$mn:00001448
.text$mn:00001448 ; Attributes: bp-based frame
.text$mn:00001448
.text$mn:00001448 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001448                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001448 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001448                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001448
.text$mn:00001448 var_10          = dword ptr -10h
.text$mn:00001448 var_C           = dword ptr -0Ch
.text$mn:00001448 var_4           = dword ptr -4
.text$mn:00001448
.text$mn:00001448                 push    ebp
.text$mn:00001449                 mov     ebp, esp
.text$mn:0000144B                 push    0FFFFFFFFh
.text$mn:0000144D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001452                 mov     eax, large fs:0
.text$mn:00001458                 push    eax
.text$mn:00001459                 push    ecx
.text$mn:0000145A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000145F                 xor     eax, ebp
.text$mn:00001461                 push    eax
.text$mn:00001462                 lea     eax, [ebp+var_C]
.text$mn:00001465                 mov     large fs:0, eax
.text$mn:0000146B                 mov     [ebp+var_10], ecx
.text$mn:0000146E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001471                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001476                 mov     [ebp+var_4], 0
.text$mn:0000147D                 mov     eax, [ebp+var_10]
.text$mn:00001480                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00001486                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000148D                 mov     eax, [ebp+var_10]
.text$mn:00001490                 mov     ecx, [ebp+var_C]
.text$mn:00001493                 mov     large fs:0, ecx
.text$mn:0000149A                 pop     ecx
.text$mn:0000149B                 mov     esp, ebp
.text$mn:0000149D                 pop     ebp
.text$mn:0000149E                 retn
.text$mn:0000149E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000149E
.text$mn:0000149E ; ---------------------------------------------------------------------------
.text$mn:0000149F                 align 10h
.text$mn:0000149F _text$mn        ends
.text$mn:0000149F
.text$x:000014A0 ; ===========================================================================
.text$x:000014A0
.text$x:000014A0 ; Segment type: Pure code
.text$x:000014A0 ; Segment permissions: Read/Execute
.text$x:000014A0 _text$x         segment para public 'CODE' use32
.text$x:000014A0                 assume cs:_text$x
.text$x:000014A0                 ;org 14A0h
.text$x:000014A0 ; COMDAT (pick associative to section at 1448)
.text$x:000014A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000014A0
.text$x:000014A0 ; =============== S U B R O U T I N E =======================================
.text$x:000014A0
.text$x:000014A0
.text$x:000014A0 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000014A0                                         ; DATA XREF: .xdata$x:000041DCo
.text$x:000014A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000014A3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000014A3 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000014A3
.text$x:000014A8
.text$x:000014A8 ; =============== S U B R O U T I N E =======================================
.text$x:000014A8
.text$x:000014A8
.text$x:000014A8 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000014A8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000014A8
.text$x:000014A8 arg_4           = dword ptr  8
.text$x:000014A8
.text$x:000014A8                 mov     edx, [esp+arg_4]
.text$x:000014AC                 lea     eax, [edx+0Ch]
.text$x:000014AF                 mov     ecx, [edx-8]
.text$x:000014B2                 xor     ecx, eax
.text$x:000014B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000014B9                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000014BE                 jmp     ___CxxFrameHandler3
.text$x:000014BE __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000014BE
.text$x:000014BE ; ---------------------------------------------------------------------------
.text$x:000014C3                 align 4
.text$x:000014C3 _text$x         ends
.text$x:000014C3
.text$mn:000014C4 ; ===========================================================================
.text$mn:000014C4
.text$mn:000014C4 ; Segment type: Pure code
.text$mn:000014C4 ; Segment permissions: Read/Execute
.text$mn:000014C4 _text$mn        segment para public 'CODE' use32
.text$mn:000014C4                 assume cs:_text$mn
.text$mn:000014C4                 ;org 14C4h
.text$mn:000014C4 ; COMDAT (pick any)
.text$mn:000014C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014C4
.text$mn:000014C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014C4
.text$mn:000014C4 ; Attributes: bp-based frame
.text$mn:000014C4
.text$mn:000014C4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000014C4                 public ??0error_category@std@@QAE@XZ
.text$mn:000014C4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000014C4
.text$mn:000014C4 var_4           = dword ptr -4
.text$mn:000014C4
.text$mn:000014C4                 push    ebp
.text$mn:000014C5                 mov     ebp, esp
.text$mn:000014C7                 push    ecx
.text$mn:000014C8                 mov     [ebp+var_4], ecx
.text$mn:000014CB                 mov     eax, [ebp+var_4]
.text$mn:000014CE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000014D4                 mov     eax, [ebp+var_4]
.text$mn:000014D7                 mov     esp, ebp
.text$mn:000014D9                 pop     ebp
.text$mn:000014DA                 retn
.text$mn:000014DA ??0error_category@std@@QAE@XZ endp
.text$mn:000014DA
.text$mn:000014DA ; ---------------------------------------------------------------------------
.text$mn:000014DB                 align 4
.text$mn:000014DB _text$mn        ends
.text$mn:000014DB
.text$mn:000014DC ; ===========================================================================
.text$mn:000014DC
.text$mn:000014DC ; Segment type: Pure code
.text$mn:000014DC ; Segment permissions: Read/Execute
.text$mn:000014DC _text$mn        segment para public 'CODE' use32
.text$mn:000014DC                 assume cs:_text$mn
.text$mn:000014DC                 ;org 14DCh
.text$mn:000014DC ; COMDAT (pick any)
.text$mn:000014DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014DC
.text$mn:000014DC ; =============== S U B R O U T I N E =======================================
.text$mn:000014DC
.text$mn:000014DC ; Attributes: bp-based frame
.text$mn:000014DC
.text$mn:000014DC ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000014DC                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000014DC ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000014DC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000014DC                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000014DC
.text$mn:000014DC var_4           = dword ptr -4
.text$mn:000014DC arg_0           = dword ptr  8
.text$mn:000014DC arg_4           = dword ptr  0Ch
.text$mn:000014DC
.text$mn:000014DC                 push    ebp
.text$mn:000014DD                 mov     ebp, esp
.text$mn:000014DF                 push    ecx
.text$mn:000014E0                 mov     [ebp+var_4], ecx
.text$mn:000014E3                 mov     eax, [ebp+var_4]
.text$mn:000014E6                 mov     ecx, [ebp+arg_0]
.text$mn:000014E9                 mov     [eax], ecx
.text$mn:000014EB                 mov     edx, [ebp+var_4]
.text$mn:000014EE                 mov     eax, [ebp+arg_4]
.text$mn:000014F1                 mov     [edx+4], eax
.text$mn:000014F4                 mov     eax, [ebp+var_4]
.text$mn:000014F7                 mov     esp, ebp
.text$mn:000014F9                 pop     ebp
.text$mn:000014FA                 retn    8
.text$mn:000014FA ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000014FA
.text$mn:000014FA ; ---------------------------------------------------------------------------
.text$mn:000014FD                 align 10h
.text$mn:000014FD _text$mn        ends
.text$mn:000014FD
.text$mn:00001500 ; ===========================================================================
.text$mn:00001500
.text$mn:00001500 ; Segment type: Pure code
.text$mn:00001500 ; Segment permissions: Read/Execute
.text$mn:00001500 _text$mn        segment para public 'CODE' use32
.text$mn:00001500                 assume cs:_text$mn
.text$mn:00001500                 ;org 1500h
.text$mn:00001500 ; COMDAT (pick any)
.text$mn:00001500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001500
.text$mn:00001500 ; =============== S U B R O U T I N E =======================================
.text$mn:00001500
.text$mn:00001500 ; Attributes: bp-based frame
.text$mn:00001500
.text$mn:00001500 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001500                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001500 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001500                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001500
.text$mn:00001500 var_4           = dword ptr -4
.text$mn:00001500 arg_0           = dword ptr  8
.text$mn:00001500
.text$mn:00001500                 push    ebp
.text$mn:00001501                 mov     ebp, esp
.text$mn:00001503                 push    ecx
.text$mn:00001504                 mov     [ebp+var_4], ecx
.text$mn:00001507                 mov     eax, [ebp+var_4]
.text$mn:0000150A                 mov     ecx, [ebp+arg_0]
.text$mn:0000150D                 mov     [eax], ecx
.text$mn:0000150F                 mov     eax, [ebp+var_4]
.text$mn:00001512                 mov     esp, ebp
.text$mn:00001514                 pop     ebp
.text$mn:00001515                 retn    4
.text$mn:00001515 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001515
.text$mn:00001515 _text$mn        ends
.text$mn:00001515
.text$mn:00001518 ; ===========================================================================
.text$mn:00001518
.text$mn:00001518 ; Segment type: Pure code
.text$mn:00001518 ; Segment permissions: Read/Execute
.text$mn:00001518 _text$mn        segment para public 'CODE' use32
.text$mn:00001518                 assume cs:_text$mn
.text$mn:00001518                 ;org 1518h
.text$mn:00001518 ; COMDAT (pick any)
.text$mn:00001518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001518
.text$mn:00001518 ; =============== S U B R O U T I N E =======================================
.text$mn:00001518
.text$mn:00001518 ; Attributes: bp-based frame
.text$mn:00001518
.text$mn:00001518 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001518                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001518 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001518                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001518                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001518
.text$mn:00001518 var_10          = dword ptr -10h
.text$mn:00001518 var_C           = dword ptr -0Ch
.text$mn:00001518 var_4           = dword ptr -4
.text$mn:00001518
.text$mn:00001518                 push    ebp
.text$mn:00001519                 mov     ebp, esp
.text$mn:0000151B                 push    0FFFFFFFFh
.text$mn:0000151D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001522                 mov     eax, large fs:0
.text$mn:00001528                 push    eax
.text$mn:00001529                 push    ecx
.text$mn:0000152A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000152F                 xor     eax, ebp
.text$mn:00001531                 push    eax
.text$mn:00001532                 lea     eax, [ebp+var_C]
.text$mn:00001535                 mov     large fs:0, eax
.text$mn:0000153B                 mov     [ebp+var_10], ecx
.text$mn:0000153E                 mov     [ebp+var_4], 0
.text$mn:00001545                 mov     ecx, [ebp+var_10]
.text$mn:00001548                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000154D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001554                 mov     ecx, [ebp+var_10]
.text$mn:00001557                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:0000155C                 mov     ecx, [ebp+var_C]
.text$mn:0000155F                 mov     large fs:0, ecx
.text$mn:00001566                 pop     ecx
.text$mn:00001567                 mov     esp, ebp
.text$mn:00001569                 pop     ebp
.text$mn:0000156A                 retn
.text$mn:0000156A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000156A
.text$mn:0000156A ; ---------------------------------------------------------------------------
.text$mn:0000156B                 align 4
.text$mn:0000156B _text$mn        ends
.text$mn:0000156B
.text$x:0000156C ; ===========================================================================
.text$x:0000156C
.text$x:0000156C ; Segment type: Pure code
.text$x:0000156C ; Segment permissions: Read/Execute
.text$x:0000156C _text$x         segment para public 'CODE' use32
.text$x:0000156C                 assume cs:_text$x
.text$x:0000156C                 ;org 156Ch
.text$x:0000156C ; COMDAT (pick associative to section at 1518)
.text$x:0000156C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000156C
.text$x:0000156C ; =============== S U B R O U T I N E =======================================
.text$x:0000156C
.text$x:0000156C
.text$x:0000156C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000156C                                         ; DATA XREF: .xdata$x:00003FC4o
.text$x:0000156C                 mov     ecx, [ebp-10h]
.text$x:0000156F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000156F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000156F
.text$x:00001574
.text$x:00001574 ; =============== S U B R O U T I N E =======================================
.text$x:00001574
.text$x:00001574
.text$x:00001574 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001574                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001574
.text$x:00001574 arg_4           = dword ptr  8
.text$x:00001574
.text$x:00001574                 mov     edx, [esp+arg_4]
.text$x:00001578                 lea     eax, [edx+0Ch]
.text$x:0000157B                 mov     ecx, [edx-8]
.text$x:0000157E                 xor     ecx, eax
.text$x:00001580                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001585                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000158A                 jmp     ___CxxFrameHandler3
.text$x:0000158A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000158A
.text$x:0000158A ; ---------------------------------------------------------------------------
.text$x:0000158F                 align 10h
.text$x:0000158F _text$x         ends
.text$x:0000158F
.text$mn:00001590 ; ===========================================================================
.text$mn:00001590
.text$mn:00001590 ; Segment type: Pure code
.text$mn:00001590 ; Segment permissions: Read/Execute
.text$mn:00001590 _text$mn        segment para public 'CODE' use32
.text$mn:00001590                 assume cs:_text$mn
.text$mn:00001590                 ;org 1590h
.text$mn:00001590 ; COMDAT (pick any)
.text$mn:00001590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001590
.text$mn:00001590 ; =============== S U B R O U T I N E =======================================
.text$mn:00001590
.text$mn:00001590 ; Attributes: bp-based frame
.text$mn:00001590
.text$mn:00001590 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00001590                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00001590 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001590                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j
.text$mn:00001590                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0+3j ...
.text$mn:00001590
.text$mn:00001590 var_10          = dword ptr -10h
.text$mn:00001590 var_C           = dword ptr -0Ch
.text$mn:00001590 var_4           = dword ptr -4
.text$mn:00001590
.text$mn:00001590                 push    ebp
.text$mn:00001591                 mov     ebp, esp
.text$mn:00001593                 push    0FFFFFFFFh
.text$mn:00001595                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000159A                 mov     eax, large fs:0
.text$mn:000015A0                 push    eax
.text$mn:000015A1                 push    ecx
.text$mn:000015A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015A7                 xor     eax, ebp
.text$mn:000015A9                 push    eax
.text$mn:000015AA                 lea     eax, [ebp+var_C]
.text$mn:000015AD                 mov     large fs:0, eax
.text$mn:000015B3                 mov     [ebp+var_10], ecx
.text$mn:000015B6                 mov     [ebp+var_4], 0
.text$mn:000015BD                 mov     ecx, [ebp+var_10]
.text$mn:000015C0                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000015C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000015CC                 mov     ecx, [ebp+var_10]
.text$mn:000015CF                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000015D4                 mov     ecx, [ebp+var_C]
.text$mn:000015D7                 mov     large fs:0, ecx
.text$mn:000015DE                 pop     ecx
.text$mn:000015DF                 mov     esp, ebp
.text$mn:000015E1                 pop     ebp
.text$mn:000015E2                 retn
.text$mn:000015E2 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000015E2
.text$mn:000015E2 ; ---------------------------------------------------------------------------
.text$mn:000015E3                 align 4
.text$mn:000015E3 _text$mn        ends
.text$mn:000015E3
.text$x:000015E4 ; ===========================================================================
.text$x:000015E4
.text$x:000015E4 ; Segment type: Pure code
.text$x:000015E4 ; Segment permissions: Read/Execute
.text$x:000015E4 _text$x         segment para public 'CODE' use32
.text$x:000015E4                 assume cs:_text$x
.text$x:000015E4                 ;org 15E4h
.text$x:000015E4 ; COMDAT (pick associative to section at 1590)
.text$x:000015E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000015E4
.text$x:000015E4 ; =============== S U B R O U T I N E =======================================
.text$x:000015E4
.text$x:000015E4
.text$x:000015E4 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000015E4                                         ; DATA XREF: .xdata$x:000042E4o
.text$x:000015E4                 mov     ecx, [ebp-10h]
.text$x:000015E7                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000015E7 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000015E7
.text$x:000015EC
.text$x:000015EC ; =============== S U B R O U T I N E =======================================
.text$x:000015EC
.text$x:000015EC
.text$x:000015EC __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000015EC                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:000015EC
.text$x:000015EC arg_4           = dword ptr  8
.text$x:000015EC
.text$x:000015EC                 mov     edx, [esp+arg_4]
.text$x:000015F0                 lea     eax, [edx+0Ch]
.text$x:000015F3                 mov     ecx, [edx-8]
.text$x:000015F6                 xor     ecx, eax
.text$x:000015F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015FD                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00001602                 jmp     ___CxxFrameHandler3
.text$x:00001602 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00001602
.text$x:00001602 ; ---------------------------------------------------------------------------
.text$x:00001607                 align 4
.text$x:00001607 _text$x         ends
.text$x:00001607
.text$mn:00001608 ; ===========================================================================
.text$mn:00001608
.text$mn:00001608 ; Segment type: Pure code
.text$mn:00001608 ; Segment permissions: Read/Execute
.text$mn:00001608 _text$mn        segment para public 'CODE' use32
.text$mn:00001608                 assume cs:_text$mn
.text$mn:00001608                 ;org 1608h
.text$mn:00001608 ; COMDAT (pick any)
.text$mn:00001608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001608
.text$mn:00001608 ; =============== S U B R O U T I N E =======================================
.text$mn:00001608
.text$mn:00001608 ; Attributes: bp-based frame
.text$mn:00001608
.text$mn:00001608 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001608                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001608 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001608                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001608                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001608
.text$mn:00001608 var_10          = dword ptr -10h
.text$mn:00001608 var_C           = dword ptr -0Ch
.text$mn:00001608 var_4           = dword ptr -4
.text$mn:00001608
.text$mn:00001608                 push    ebp
.text$mn:00001609                 mov     ebp, esp
.text$mn:0000160B                 push    0FFFFFFFFh
.text$mn:0000160D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001612                 mov     eax, large fs:0
.text$mn:00001618                 push    eax
.text$mn:00001619                 push    ecx
.text$mn:0000161A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000161F                 xor     eax, ebp
.text$mn:00001621                 push    eax
.text$mn:00001622                 lea     eax, [ebp+var_C]
.text$mn:00001625                 mov     large fs:0, eax
.text$mn:0000162B                 mov     [ebp+var_10], ecx
.text$mn:0000162E                 mov     [ebp+var_4], 0
.text$mn:00001635                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000163C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000163F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001644                 mov     ecx, [ebp+var_C]
.text$mn:00001647                 mov     large fs:0, ecx
.text$mn:0000164E                 pop     ecx
.text$mn:0000164F                 mov     esp, ebp
.text$mn:00001651                 pop     ebp
.text$mn:00001652                 retn
.text$mn:00001652 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001652
.text$mn:00001652 ; ---------------------------------------------------------------------------
.text$mn:00001653                 align 4
.text$mn:00001653 _text$mn        ends
.text$mn:00001653
.text$x:00001654 ; ===========================================================================
.text$x:00001654
.text$x:00001654 ; Segment type: Pure code
.text$x:00001654 ; Segment permissions: Read/Execute
.text$x:00001654 _text$x         segment para public 'CODE' use32
.text$x:00001654                 assume cs:_text$x
.text$x:00001654                 ;org 1654h
.text$x:00001654 ; COMDAT (pick associative to section at 1608)
.text$x:00001654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001654
.text$x:00001654 ; =============== S U B R O U T I N E =======================================
.text$x:00001654
.text$x:00001654
.text$x:00001654 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001654                                         ; DATA XREF: .xdata$x:00003F6Co
.text$x:00001654                 mov     ecx, [ebp-10h]  ; this
.text$x:00001657                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001657 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001657
.text$x:0000165C
.text$x:0000165C ; =============== S U B R O U T I N E =======================================
.text$x:0000165C
.text$x:0000165C
.text$x:0000165C __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000165C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000165C
.text$x:0000165C arg_4           = dword ptr  8
.text$x:0000165C
.text$x:0000165C                 mov     edx, [esp+arg_4]
.text$x:00001660                 lea     eax, [edx+0Ch]
.text$x:00001663                 mov     ecx, [edx-8]
.text$x:00001666                 xor     ecx, eax
.text$x:00001668                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000166D                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001672                 jmp     ___CxxFrameHandler3
.text$x:00001672 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001672
.text$x:00001672 ; ---------------------------------------------------------------------------
.text$x:00001677                 align 4
.text$x:00001677 _text$x         ends
.text$x:00001677
.text$mn:00001678 ; ===========================================================================
.text$mn:00001678
.text$mn:00001678 ; Segment type: Pure code
.text$mn:00001678 ; Segment permissions: Read/Execute
.text$mn:00001678 _text$mn        segment para public 'CODE' use32
.text$mn:00001678                 assume cs:_text$mn
.text$mn:00001678                 ;org 1678h
.text$mn:00001678 ; COMDAT (pick any)
.text$mn:00001678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001678
.text$mn:00001678 ; =============== S U B R O U T I N E =======================================
.text$mn:00001678
.text$mn:00001678 ; Attributes: bp-based frame
.text$mn:00001678
.text$mn:00001678 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00001678                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001678 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00001678                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00001678                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00001678
.text$mn:00001678 var_10          = dword ptr -10h
.text$mn:00001678 var_C           = dword ptr -0Ch
.text$mn:00001678 var_4           = dword ptr -4
.text$mn:00001678
.text$mn:00001678                 push    ebp
.text$mn:00001679                 mov     ebp, esp
.text$mn:0000167B                 push    0FFFFFFFFh
.text$mn:0000167D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001682                 mov     eax, large fs:0
.text$mn:00001688                 push    eax
.text$mn:00001689                 push    ecx
.text$mn:0000168A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000168F                 xor     eax, ebp
.text$mn:00001691                 push    eax
.text$mn:00001692                 lea     eax, [ebp+var_C]
.text$mn:00001695                 mov     large fs:0, eax
.text$mn:0000169B                 mov     [ebp+var_10], ecx
.text$mn:0000169E                 mov     [ebp+var_4], 0
.text$mn:000016A5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016AC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000016AF                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000016B4                 mov     ecx, [ebp+var_C]
.text$mn:000016B7                 mov     large fs:0, ecx
.text$mn:000016BE                 pop     ecx
.text$mn:000016BF                 mov     esp, ebp
.text$mn:000016C1                 pop     ebp
.text$mn:000016C2                 retn
.text$mn:000016C2 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000016C2
.text$mn:000016C2 ; ---------------------------------------------------------------------------
.text$mn:000016C3                 align 4
.text$mn:000016C3 _text$mn        ends
.text$mn:000016C3
.text$x:000016C4 ; ===========================================================================
.text$x:000016C4
.text$x:000016C4 ; Segment type: Pure code
.text$x:000016C4 ; Segment permissions: Read/Execute
.text$x:000016C4 _text$x         segment para public 'CODE' use32
.text$x:000016C4                 assume cs:_text$x
.text$x:000016C4                 ;org 16C4h
.text$x:000016C4 ; COMDAT (pick associative to section at 1678)
.text$x:000016C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000016C4
.text$x:000016C4 ; =============== S U B R O U T I N E =======================================
.text$x:000016C4
.text$x:000016C4
.text$x:000016C4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000016C4                                         ; DATA XREF: .xdata$x:0000428Co
.text$x:000016C4                 mov     ecx, [ebp-10h]  ; this
.text$x:000016C7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000016C7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000016C7
.text$x:000016CC
.text$x:000016CC ; =============== S U B R O U T I N E =======================================
.text$x:000016CC
.text$x:000016CC
.text$x:000016CC __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:000016CC                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:000016CC
.text$x:000016CC arg_4           = dword ptr  8
.text$x:000016CC
.text$x:000016CC                 mov     edx, [esp+arg_4]
.text$x:000016D0                 lea     eax, [edx+0Ch]
.text$x:000016D3                 mov     ecx, [edx-8]
.text$x:000016D6                 xor     ecx, eax
.text$x:000016D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016DD                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000016E2                 jmp     ___CxxFrameHandler3
.text$x:000016E2 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000016E2
.text$x:000016E2 ; ---------------------------------------------------------------------------
.text$x:000016E7                 align 4
.text$x:000016E7 _text$x         ends
.text$x:000016E7
.text$mn:000016E8 ; ===========================================================================
.text$mn:000016E8
.text$mn:000016E8 ; Segment type: Pure code
.text$mn:000016E8 ; Segment permissions: Read/Execute
.text$mn:000016E8 _text$mn        segment para public 'CODE' use32
.text$mn:000016E8                 assume cs:_text$mn
.text$mn:000016E8                 ;org 16E8h
.text$mn:000016E8 ; COMDAT (pick any)
.text$mn:000016E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016E8
.text$mn:000016E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E8
.text$mn:000016E8 ; Attributes: bp-based frame
.text$mn:000016E8
.text$mn:000016E8 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HMENU__ *, class std::allocator<struct HMENU__ *>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct HMENU__ *, class std::allocator<struct HMENU__ *>>>(void)
.text$mn:000016E8                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ
.text$mn:000016E8 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000016E8                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::~vector<HMENU__ *,std::allocator<HMENU__ *>>(void)+3Fp
.text$mn:000016E8                                         ; __unwindfunclet$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ$0+3j
.text$mn:000016E8
.text$mn:000016E8 var_10          = dword ptr -10h
.text$mn:000016E8 var_C           = dword ptr -0Ch
.text$mn:000016E8 var_4           = dword ptr -4
.text$mn:000016E8
.text$mn:000016E8                 push    ebp
.text$mn:000016E9                 mov     ebp, esp
.text$mn:000016EB                 push    0FFFFFFFFh
.text$mn:000016ED                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ
.text$mn:000016F2                 mov     eax, large fs:0
.text$mn:000016F8                 push    eax
.text$mn:000016F9                 push    ecx
.text$mn:000016FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016FF                 xor     eax, ebp
.text$mn:00001701                 push    eax
.text$mn:00001702                 lea     eax, [ebp+var_C]
.text$mn:00001705                 mov     large fs:0, eax
.text$mn:0000170B                 mov     [ebp+var_10], ecx
.text$mn:0000170E                 mov     [ebp+var_4], 0
.text$mn:00001715                 mov     ecx, [ebp+var_10]
.text$mn:00001718                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Free_proxy(void)
.text$mn:0000171D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001724                 mov     ecx, [ebp+var_10]
.text$mn:00001727                 call    ??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HMENU__ *>>::~_Vector_val<std::_Simple_types<HMENU__ *>>(void)
.text$mn:0000172C                 mov     ecx, [ebp+var_C]
.text$mn:0000172F                 mov     large fs:0, ecx
.text$mn:00001736                 pop     ecx
.text$mn:00001737                 mov     esp, ebp
.text$mn:00001739                 pop     ebp
.text$mn:0000173A                 retn
.text$mn:0000173A ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000173A
.text$mn:0000173A ; ---------------------------------------------------------------------------
.text$mn:0000173B                 align 4
.text$mn:0000173B _text$mn        ends
.text$mn:0000173B
.text$x:0000173C ; ===========================================================================
.text$x:0000173C
.text$x:0000173C ; Segment type: Pure code
.text$x:0000173C ; Segment permissions: Read/Execute
.text$x:0000173C _text$x         segment para public 'CODE' use32
.text$x:0000173C                 assume cs:_text$x
.text$x:0000173C                 ;org 173Ch
.text$x:0000173C ; COMDAT (pick associative to section at 16E8)
.text$x:0000173C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000173C
.text$x:0000173C ; =============== S U B R O U T I N E =======================================
.text$x:0000173C
.text$x:0000173C
.text$x:0000173C __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000173C                                         ; DATA XREF: .xdata$x:000044D8o
.text$x:0000173C                 mov     ecx, [ebp-10h]
.text$x:0000173F                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HMENU__ *>>::~_Vector_val<std::_Simple_types<HMENU__ *>>(void)
.text$x:0000173F __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000173F
.text$x:00001744
.text$x:00001744 ; =============== S U B R O U T I N E =======================================
.text$x:00001744
.text$x:00001744
.text$x:00001744 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001744                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>(void)+5o
.text$x:00001744
.text$x:00001744 arg_4           = dword ptr  8
.text$x:00001744
.text$x:00001744                 mov     edx, [esp+arg_4]
.text$x:00001748                 lea     eax, [edx+0Ch]
.text$x:0000174B                 mov     ecx, [edx-8]
.text$x:0000174E                 xor     ecx, eax
.text$x:00001750                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001755                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ
.text$x:0000175A                 jmp     ___CxxFrameHandler3
.text$x:0000175A __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000175A
.text$x:0000175A ; ---------------------------------------------------------------------------
.text$x:0000175F                 align 10h
.text$x:0000175F _text$x         ends
.text$x:0000175F
.text$mn:00001760 ; ===========================================================================
.text$mn:00001760
.text$mn:00001760 ; Segment type: Pure code
.text$mn:00001760 ; Segment permissions: Read/Execute
.text$mn:00001760 _text$mn        segment para public 'CODE' use32
.text$mn:00001760                 assume cs:_text$mn
.text$mn:00001760                 ;org 1760h
.text$mn:00001760 ; COMDAT (pick any)
.text$mn:00001760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001760
.text$mn:00001760 ; =============== S U B R O U T I N E =======================================
.text$mn:00001760
.text$mn:00001760 ; Attributes: bp-based frame
.text$mn:00001760
.text$mn:00001760 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct HMENU__ *>>::~_Vector_val<struct std::_Simple_types<struct HMENU__ *>>(void)
.text$mn:00001760                 public ??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ
.text$mn:00001760 ??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ proc near
.text$mn:00001760                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>(void)+3Fp
.text$mn:00001760                                         ; __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00001760
.text$mn:00001760 var_10          = dword ptr -10h
.text$mn:00001760 var_C           = dword ptr -0Ch
.text$mn:00001760 var_4           = dword ptr -4
.text$mn:00001760
.text$mn:00001760                 push    ebp
.text$mn:00001761                 mov     ebp, esp
.text$mn:00001763                 push    0FFFFFFFFh
.text$mn:00001765                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ
.text$mn:0000176A                 mov     eax, large fs:0
.text$mn:00001770                 push    eax
.text$mn:00001771                 push    ecx
.text$mn:00001772                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001777                 xor     eax, ebp
.text$mn:00001779                 push    eax
.text$mn:0000177A                 lea     eax, [ebp+var_C]
.text$mn:0000177D                 mov     large fs:0, eax
.text$mn:00001783                 mov     [ebp+var_10], ecx
.text$mn:00001786                 mov     [ebp+var_4], 0
.text$mn:0000178D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001794                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001797                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000179C                 mov     ecx, [ebp+var_C]
.text$mn:0000179F                 mov     large fs:0, ecx
.text$mn:000017A6                 pop     ecx
.text$mn:000017A7                 mov     esp, ebp
.text$mn:000017A9                 pop     ebp
.text$mn:000017AA                 retn
.text$mn:000017AA ??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ endp
.text$mn:000017AA
.text$mn:000017AA ; ---------------------------------------------------------------------------
.text$mn:000017AB                 align 4
.text$mn:000017AB _text$mn        ends
.text$mn:000017AB
.text$x:000017AC ; ===========================================================================
.text$x:000017AC
.text$x:000017AC ; Segment type: Pure code
.text$x:000017AC ; Segment permissions: Read/Execute
.text$x:000017AC _text$x         segment para public 'CODE' use32
.text$x:000017AC                 assume cs:_text$x
.text$x:000017AC                 ;org 17ACh
.text$x:000017AC ; COMDAT (pick associative to section at 1760)
.text$x:000017AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000017AC
.text$x:000017AC ; =============== S U B R O U T I N E =======================================
.text$x:000017AC
.text$x:000017AC
.text$x:000017AC __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000017AC                                         ; DATA XREF: .xdata$x:000044ACo
.text$x:000017AC                 mov     ecx, [ebp-10h]  ; this
.text$x:000017AF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000017AF __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ$0 endp
.text$x:000017AF
.text$x:000017B4
.text$x:000017B4 ; =============== S U B R O U T I N E =======================================
.text$x:000017B4
.text$x:000017B4
.text$x:000017B4 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ proc near
.text$x:000017B4                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<HMENU__ *>>::~_Vector_val<std::_Simple_types<HMENU__ *>>(void)+5o
.text$x:000017B4
.text$x:000017B4 arg_4           = dword ptr  8
.text$x:000017B4
.text$x:000017B4                 mov     edx, [esp+arg_4]
.text$x:000017B8                 lea     eax, [edx+0Ch]
.text$x:000017BB                 mov     ecx, [edx-8]
.text$x:000017BE                 xor     ecx, eax
.text$x:000017C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000017C5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ
.text$x:000017CA                 jmp     ___CxxFrameHandler3
.text$x:000017CA __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ endp
.text$x:000017CA
.text$x:000017CA ; ---------------------------------------------------------------------------
.text$x:000017CF                 align 10h
.text$x:000017CF _text$x         ends
.text$x:000017CF
.text$mn:000017D0 ; ===========================================================================
.text$mn:000017D0
.text$mn:000017D0 ; Segment type: Pure code
.text$mn:000017D0 ; Segment permissions: Read/Execute
.text$mn:000017D0 _text$mn        segment para public 'CODE' use32
.text$mn:000017D0                 assume cs:_text$mn
.text$mn:000017D0                 ;org 17D0h
.text$mn:000017D0 ; COMDAT (pick any)
.text$mn:000017D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017D0
.text$mn:000017D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017D0
.text$mn:000017D0 ; Attributes: bp-based frame
.text$mn:000017D0
.text$mn:000017D0 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000017D0                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000017D0 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000017D0                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000017D0                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000017D0
.text$mn:000017D0 var_10          = dword ptr -10h
.text$mn:000017D0 var_C           = dword ptr -0Ch
.text$mn:000017D0 var_4           = dword ptr -4
.text$mn:000017D0
.text$mn:000017D0                 push    ebp
.text$mn:000017D1                 mov     ebp, esp
.text$mn:000017D3                 push    0FFFFFFFFh
.text$mn:000017D5                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000017DA                 mov     eax, large fs:0
.text$mn:000017E0                 push    eax
.text$mn:000017E1                 push    ecx
.text$mn:000017E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017E7                 xor     eax, ebp
.text$mn:000017E9                 push    eax
.text$mn:000017EA                 lea     eax, [ebp+var_C]
.text$mn:000017ED                 mov     large fs:0, eax
.text$mn:000017F3                 mov     [ebp+var_10], ecx
.text$mn:000017F6                 mov     [ebp+var_4], 0
.text$mn:000017FD                 push    0               ; Size
.text$mn:000017FF                 push    1               ; char
.text$mn:00001801                 mov     ecx, [ebp+var_10]
.text$mn:00001804                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001809                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001810                 mov     ecx, [ebp+var_10]
.text$mn:00001813                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001818                 mov     ecx, [ebp+var_C]
.text$mn:0000181B                 mov     large fs:0, ecx
.text$mn:00001822                 pop     ecx
.text$mn:00001823                 mov     esp, ebp
.text$mn:00001825                 pop     ebp
.text$mn:00001826                 retn
.text$mn:00001826 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001826
.text$mn:00001826 ; ---------------------------------------------------------------------------
.text$mn:00001827                 align 4
.text$mn:00001827 _text$mn        ends
.text$mn:00001827
.text$x:00001828 ; ===========================================================================
.text$x:00001828
.text$x:00001828 ; Segment type: Pure code
.text$x:00001828 ; Segment permissions: Read/Execute
.text$x:00001828 _text$x         segment para public 'CODE' use32
.text$x:00001828                 assume cs:_text$x
.text$x:00001828                 ;org 1828h
.text$x:00001828 ; COMDAT (pick associative to section at 17D0)
.text$x:00001828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001828
.text$x:00001828 ; =============== S U B R O U T I N E =======================================
.text$x:00001828
.text$x:00001828
.text$x:00001828 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001828                                         ; DATA XREF: .xdata$x:0000401Co
.text$x:00001828                 mov     ecx, [ebp-10h]
.text$x:0000182B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000182B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000182B
.text$x:00001830
.text$x:00001830 ; =============== S U B R O U T I N E =======================================
.text$x:00001830
.text$x:00001830
.text$x:00001830 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001830                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001830
.text$x:00001830 arg_4           = dword ptr  8
.text$x:00001830
.text$x:00001830                 mov     edx, [esp+arg_4]
.text$x:00001834                 lea     eax, [edx+0Ch]
.text$x:00001837                 mov     ecx, [edx-8]
.text$x:0000183A                 xor     ecx, eax
.text$x:0000183C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001841                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001846                 jmp     ___CxxFrameHandler3
.text$x:00001846 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001846
.text$x:00001846 ; ---------------------------------------------------------------------------
.text$x:0000184B                 align 4
.text$x:0000184B _text$x         ends
.text$x:0000184B
.text$mn:0000184C ; ===========================================================================
.text$mn:0000184C
.text$mn:0000184C ; Segment type: Pure code
.text$mn:0000184C ; Segment permissions: Read/Execute
.text$mn:0000184C _text$mn        segment para public 'CODE' use32
.text$mn:0000184C                 assume cs:_text$mn
.text$mn:0000184C                 ;org 184Ch
.text$mn:0000184C ; COMDAT (pick any)
.text$mn:0000184C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000184C
.text$mn:0000184C ; =============== S U B R O U T I N E =======================================
.text$mn:0000184C
.text$mn:0000184C ; Attributes: bp-based frame
.text$mn:0000184C
.text$mn:0000184C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:0000184C                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000184C ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:0000184C                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+2E8p
.text$mn:0000184C                                         ; __unwindfunclet$??0MenuItemUnit@@QAE@KPB_W0@Z$0+6j ...
.text$mn:0000184C
.text$mn:0000184C var_10          = dword ptr -10h
.text$mn:0000184C var_C           = dword ptr -0Ch
.text$mn:0000184C var_4           = dword ptr -4
.text$mn:0000184C
.text$mn:0000184C                 push    ebp
.text$mn:0000184D                 mov     ebp, esp
.text$mn:0000184F                 push    0FFFFFFFFh
.text$mn:00001851                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001856                 mov     eax, large fs:0
.text$mn:0000185C                 push    eax
.text$mn:0000185D                 push    ecx
.text$mn:0000185E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001863                 xor     eax, ebp
.text$mn:00001865                 push    eax
.text$mn:00001866                 lea     eax, [ebp+var_C]
.text$mn:00001869                 mov     large fs:0, eax
.text$mn:0000186F                 mov     [ebp+var_10], ecx
.text$mn:00001872                 mov     [ebp+var_4], 0
.text$mn:00001879                 push    0
.text$mn:0000187B                 push    1
.text$mn:0000187D                 mov     ecx, [ebp+var_10]
.text$mn:00001880                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001885                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000188C                 mov     ecx, [ebp+var_10]
.text$mn:0000188F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00001894                 mov     ecx, [ebp+var_C]
.text$mn:00001897                 mov     large fs:0, ecx
.text$mn:0000189E                 pop     ecx
.text$mn:0000189F                 mov     esp, ebp
.text$mn:000018A1                 pop     ebp
.text$mn:000018A2                 retn
.text$mn:000018A2 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000018A2
.text$mn:000018A2 ; ---------------------------------------------------------------------------
.text$mn:000018A3                 align 4
.text$mn:000018A3 _text$mn        ends
.text$mn:000018A3
.text$x:000018A4 ; ===========================================================================
.text$x:000018A4
.text$x:000018A4 ; Segment type: Pure code
.text$x:000018A4 ; Segment permissions: Read/Execute
.text$x:000018A4 _text$x         segment para public 'CODE' use32
.text$x:000018A4                 assume cs:_text$x
.text$x:000018A4                 ;org 18A4h
.text$x:000018A4 ; COMDAT (pick associative to section at 184C)
.text$x:000018A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000018A4
.text$x:000018A4 ; =============== S U B R O U T I N E =======================================
.text$x:000018A4
.text$x:000018A4
.text$x:000018A4 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000018A4                                         ; DATA XREF: .xdata$x:00004368o
.text$x:000018A4                 mov     ecx, [ebp-10h]
.text$x:000018A7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000018A7 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000018A7
.text$x:000018AC
.text$x:000018AC ; =============== S U B R O U T I N E =======================================
.text$x:000018AC
.text$x:000018AC
.text$x:000018AC __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000018AC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000018AC
.text$x:000018AC arg_4           = dword ptr  8
.text$x:000018AC
.text$x:000018AC                 mov     edx, [esp+arg_4]
.text$x:000018B0                 lea     eax, [edx+0Ch]
.text$x:000018B3                 mov     ecx, [edx-8]
.text$x:000018B6                 xor     ecx, eax
.text$x:000018B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018BD                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:000018C2                 jmp     ___CxxFrameHandler3
.text$x:000018C2 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:000018C2
.text$x:000018C2 ; ---------------------------------------------------------------------------
.text$x:000018C7                 align 4
.text$x:000018C7 _text$x         ends
.text$x:000018C7
.text$mn:000018C8 ; ===========================================================================
.text$mn:000018C8
.text$mn:000018C8 ; Segment type: Pure code
.text$mn:000018C8 ; Segment permissions: Read/Execute
.text$mn:000018C8 _text$mn        segment para public 'CODE' use32
.text$mn:000018C8                 assume cs:_text$mn
.text$mn:000018C8                 ;org 18C8h
.text$mn:000018C8 ; COMDAT (pick any)
.text$mn:000018C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018C8
.text$mn:000018C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C8
.text$mn:000018C8 ; Attributes: bp-based frame
.text$mn:000018C8
.text$mn:000018C8 ; public: __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::~vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>(void)
.text$mn:000018C8                 public ??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ
.text$mn:000018C8 ??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ proc near
.text$mn:000018C8                                         ; CODE XREF: ContextMenu::~ContextMenu(void)+9Ap
.text$mn:000018C8                                         ; __unwindfunclet$??1ContextMenu@@QAE@XZ$0+6j
.text$mn:000018C8
.text$mn:000018C8 var_10          = dword ptr -10h
.text$mn:000018C8 var_C           = dword ptr -0Ch
.text$mn:000018C8 var_4           = dword ptr -4
.text$mn:000018C8
.text$mn:000018C8                 push    ebp
.text$mn:000018C9                 mov     ebp, esp
.text$mn:000018CB                 push    0FFFFFFFFh
.text$mn:000018CD                 push    offset __ehhandler$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ
.text$mn:000018D2                 mov     eax, large fs:0
.text$mn:000018D8                 push    eax
.text$mn:000018D9                 push    ecx
.text$mn:000018DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018DF                 xor     eax, ebp
.text$mn:000018E1                 push    eax
.text$mn:000018E2                 lea     eax, [ebp+var_C]
.text$mn:000018E5                 mov     large fs:0, eax
.text$mn:000018EB                 mov     [ebp+var_10], ecx
.text$mn:000018EE                 mov     [ebp+var_4], 0
.text$mn:000018F5                 mov     ecx, [ebp+var_10]
.text$mn:000018F8                 call    ?_Tidy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Tidy(void)
.text$mn:000018FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001904                 mov     ecx, [ebp+var_10]
.text$mn:00001907                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>(void)
.text$mn:0000190C                 mov     ecx, [ebp+var_C]
.text$mn:0000190F                 mov     large fs:0, ecx
.text$mn:00001916                 pop     ecx
.text$mn:00001917                 mov     esp, ebp
.text$mn:00001919                 pop     ebp
.text$mn:0000191A                 retn
.text$mn:0000191A ??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ endp
.text$mn:0000191A
.text$mn:0000191A ; ---------------------------------------------------------------------------
.text$mn:0000191B                 align 4
.text$mn:0000191B _text$mn        ends
.text$mn:0000191B
.text$x:0000191C ; ===========================================================================
.text$x:0000191C
.text$x:0000191C ; Segment type: Pure code
.text$x:0000191C ; Segment permissions: Read/Execute
.text$x:0000191C _text$x         segment para public 'CODE' use32
.text$x:0000191C                 assume cs:_text$x
.text$x:0000191C                 ;org 191Ch
.text$x:0000191C ; COMDAT (pick associative to section at 18C8)
.text$x:0000191C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000191C
.text$x:0000191C ; =============== S U B R O U T I N E =======================================
.text$x:0000191C
.text$x:0000191C
.text$x:0000191C __unwindfunclet$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000191C                                         ; DATA XREF: .xdata$x:00004504o
.text$x:0000191C                 mov     ecx, [ebp-10h]
.text$x:0000191F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>(void)
.text$x:0000191F __unwindfunclet$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000191F
.text$x:00001924
.text$x:00001924 ; =============== S U B R O U T I N E =======================================
.text$x:00001924
.text$x:00001924
.text$x:00001924 __ehhandler$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ proc near
.text$x:00001924                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::~vector<HMENU__ *,std::allocator<HMENU__ *>>(void)+5o
.text$x:00001924
.text$x:00001924 arg_4           = dword ptr  8
.text$x:00001924
.text$x:00001924                 mov     edx, [esp+arg_4]
.text$x:00001928                 lea     eax, [edx+0Ch]
.text$x:0000192B                 mov     ecx, [edx-8]
.text$x:0000192E                 xor     ecx, eax
.text$x:00001930                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001935                 mov     eax, offset __ehfuncinfo$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ
.text$x:0000193A                 jmp     ___CxxFrameHandler3
.text$x:0000193A __ehhandler$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ endp
.text$x:0000193A
.text$x:0000193A ; ---------------------------------------------------------------------------
.text$x:0000193F                 align 10h
.text$x:0000193F _text$x         ends
.text$x:0000193F
.text$mn:00001940 ; ===========================================================================
.text$mn:00001940
.text$mn:00001940 ; Segment type: Pure code
.text$mn:00001940 ; Segment permissions: Read/Execute
.text$mn:00001940 _text$mn        segment para public 'CODE' use32
.text$mn:00001940                 assume cs:_text$mn
.text$mn:00001940                 ;org 1940h
.text$mn:00001940 ; COMDAT (pick any)
.text$mn:00001940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001940
.text$mn:00001940 ; =============== S U B R O U T I N E =======================================
.text$mn:00001940
.text$mn:00001940 ; Attributes: bp-based frame
.text$mn:00001940
.text$mn:00001940 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001940                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001940 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001940                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001940                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00001940
.text$mn:00001940 var_4           = dword ptr -4
.text$mn:00001940
.text$mn:00001940                 push    ebp
.text$mn:00001941                 mov     ebp, esp
.text$mn:00001943                 push    ecx
.text$mn:00001944                 mov     [ebp+var_4], ecx
.text$mn:00001947                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000194A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000194F                 mov     esp, ebp
.text$mn:00001951                 pop     ebp
.text$mn:00001952                 retn
.text$mn:00001952 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001952
.text$mn:00001952 ; ---------------------------------------------------------------------------
.text$mn:00001953                 align 4
.text$mn:00001953 _text$mn        ends
.text$mn:00001953
.text$mn:00001954 ; ===========================================================================
.text$mn:00001954
.text$mn:00001954 ; Segment type: Pure code
.text$mn:00001954 ; Segment permissions: Read/Execute
.text$mn:00001954 _text$mn        segment para public 'CODE' use32
.text$mn:00001954                 assume cs:_text$mn
.text$mn:00001954                 ;org 1954h
.text$mn:00001954 ; COMDAT (pick any)
.text$mn:00001954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001954
.text$mn:00001954 ; =============== S U B R O U T I N E =======================================
.text$mn:00001954
.text$mn:00001954 ; Attributes: bp-based frame
.text$mn:00001954
.text$mn:00001954 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001954                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001954 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001954                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001954                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001954
.text$mn:00001954 var_10          = dword ptr -10h
.text$mn:00001954 var_C           = dword ptr -0Ch
.text$mn:00001954 var_4           = dword ptr -4
.text$mn:00001954
.text$mn:00001954                 push    ebp
.text$mn:00001955                 mov     ebp, esp
.text$mn:00001957                 push    0FFFFFFFFh
.text$mn:00001959                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000195E                 mov     eax, large fs:0
.text$mn:00001964                 push    eax
.text$mn:00001965                 push    ecx
.text$mn:00001966                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000196B                 xor     eax, ebp
.text$mn:0000196D                 push    eax
.text$mn:0000196E                 lea     eax, [ebp+var_C]
.text$mn:00001971                 mov     large fs:0, eax
.text$mn:00001977                 mov     [ebp+var_10], ecx
.text$mn:0000197A                 mov     [ebp+var_4], 0
.text$mn:00001981                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001988                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000198B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001990                 mov     ecx, [ebp+var_C]
.text$mn:00001993                 mov     large fs:0, ecx
.text$mn:0000199A                 pop     ecx
.text$mn:0000199B                 mov     esp, ebp
.text$mn:0000199D                 pop     ebp
.text$mn:0000199E                 retn
.text$mn:0000199E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000199E
.text$mn:0000199E ; ---------------------------------------------------------------------------
.text$mn:0000199F                 align 10h
.text$mn:0000199F _text$mn        ends
.text$mn:0000199F
.text$x:000019A0 ; ===========================================================================
.text$x:000019A0
.text$x:000019A0 ; Segment type: Pure code
.text$x:000019A0 ; Segment permissions: Read/Execute
.text$x:000019A0 _text$x         segment para public 'CODE' use32
.text$x:000019A0                 assume cs:_text$x
.text$x:000019A0                 ;org 19A0h
.text$x:000019A0 ; COMDAT (pick associative to section at 1954)
.text$x:000019A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000019A0
.text$x:000019A0 ; =============== S U B R O U T I N E =======================================
.text$x:000019A0
.text$x:000019A0
.text$x:000019A0 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000019A0                                         ; DATA XREF: .xdata$x:0000412Co
.text$x:000019A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000019A3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000019A3 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000019A3
.text$x:000019A8
.text$x:000019A8 ; =============== S U B R O U T I N E =======================================
.text$x:000019A8
.text$x:000019A8
.text$x:000019A8 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000019A8                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000019A8
.text$x:000019A8 arg_4           = dword ptr  8
.text$x:000019A8
.text$x:000019A8                 mov     edx, [esp+arg_4]
.text$x:000019AC                 lea     eax, [edx+0Ch]
.text$x:000019AF                 mov     ecx, [edx-8]
.text$x:000019B2                 xor     ecx, eax
.text$x:000019B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019B9                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000019BE                 jmp     ___CxxFrameHandler3
.text$x:000019BE __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000019BE
.text$x:000019BE ; ---------------------------------------------------------------------------
.text$x:000019C3                 align 4
.text$x:000019C3 _text$x         ends
.text$x:000019C3
.text$mn:000019C4 ; ===========================================================================
.text$mn:000019C4
.text$mn:000019C4 ; Segment type: Pure code
.text$mn:000019C4 ; Segment permissions: Read/Execute
.text$mn:000019C4 _text$mn        segment para public 'CODE' use32
.text$mn:000019C4                 assume cs:_text$mn
.text$mn:000019C4                 ;org 19C4h
.text$mn:000019C4 ; COMDAT (pick any)
.text$mn:000019C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019C4
.text$mn:000019C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C4
.text$mn:000019C4 ; Attributes: bp-based frame
.text$mn:000019C4
.text$mn:000019C4 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000019C4                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000019C4 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000019C4                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000019C4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000019C4
.text$mn:000019C4 var_10          = dword ptr -10h
.text$mn:000019C4 var_C           = dword ptr -0Ch
.text$mn:000019C4 var_4           = dword ptr -4
.text$mn:000019C4
.text$mn:000019C4                 push    ebp
.text$mn:000019C5                 mov     ebp, esp
.text$mn:000019C7                 push    0FFFFFFFFh
.text$mn:000019C9                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000019CE                 mov     eax, large fs:0
.text$mn:000019D4                 push    eax
.text$mn:000019D5                 push    ecx
.text$mn:000019D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019DB                 xor     eax, ebp
.text$mn:000019DD                 push    eax
.text$mn:000019DE                 lea     eax, [ebp+var_C]
.text$mn:000019E1                 mov     large fs:0, eax
.text$mn:000019E7                 mov     [ebp+var_10], ecx
.text$mn:000019EA                 mov     [ebp+var_4], 0
.text$mn:000019F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019F8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000019FB                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001A00                 mov     ecx, [ebp+var_C]
.text$mn:00001A03                 mov     large fs:0, ecx
.text$mn:00001A0A                 pop     ecx
.text$mn:00001A0B                 mov     esp, ebp
.text$mn:00001A0D                 pop     ebp
.text$mn:00001A0E                 retn
.text$mn:00001A0E ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001A0E
.text$mn:00001A0E ; ---------------------------------------------------------------------------
.text$mn:00001A0F                 align 10h
.text$mn:00001A0F _text$mn        ends
.text$mn:00001A0F
.text$x:00001A10 ; ===========================================================================
.text$x:00001A10
.text$x:00001A10 ; Segment type: Pure code
.text$x:00001A10 ; Segment permissions: Read/Execute
.text$x:00001A10 _text$x         segment para public 'CODE' use32
.text$x:00001A10                 assume cs:_text$x
.text$x:00001A10                 ;org 1A10h
.text$x:00001A10 ; COMDAT (pick associative to section at 19C4)
.text$x:00001A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A10
.text$x:00001A10 ; =============== S U B R O U T I N E =======================================
.text$x:00001A10
.text$x:00001A10
.text$x:00001A10 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001A10                                         ; DATA XREF: .xdata$x:000041B0o
.text$x:00001A10                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A13                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001A13 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001A13
.text$x:00001A18
.text$x:00001A18 ; =============== S U B R O U T I N E =======================================
.text$x:00001A18
.text$x:00001A18
.text$x:00001A18 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001A18                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001A18
.text$x:00001A18 arg_4           = dword ptr  8
.text$x:00001A18
.text$x:00001A18                 mov     edx, [esp+arg_4]
.text$x:00001A1C                 lea     eax, [edx+0Ch]
.text$x:00001A1F                 mov     ecx, [edx-8]
.text$x:00001A22                 xor     ecx, eax
.text$x:00001A24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A29                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001A2E                 jmp     ___CxxFrameHandler3
.text$x:00001A2E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001A2E
.text$x:00001A2E ; ---------------------------------------------------------------------------
.text$x:00001A33                 align 4
.text$x:00001A33 _text$x         ends
.text$x:00001A33
.text$mn:00001A34 ; ===========================================================================
.text$mn:00001A34
.text$mn:00001A34 ; Segment type: Pure code
.text$mn:00001A34 ; Segment permissions: Read/Execute
.text$mn:00001A34 _text$mn        segment para public 'CODE' use32
.text$mn:00001A34                 assume cs:_text$mn
.text$mn:00001A34                 ;org 1A34h
.text$mn:00001A34 ; COMDAT (pick any)
.text$mn:00001A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A34
.text$mn:00001A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A34
.text$mn:00001A34 ; Attributes: bp-based frame
.text$mn:00001A34
.text$mn:00001A34 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001A34                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001A34 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001A34                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001A34                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001A34
.text$mn:00001A34 var_10          = dword ptr -10h
.text$mn:00001A34 var_C           = dword ptr -0Ch
.text$mn:00001A34 var_4           = dword ptr -4
.text$mn:00001A34
.text$mn:00001A34                 push    ebp
.text$mn:00001A35                 mov     ebp, esp
.text$mn:00001A37                 push    0FFFFFFFFh
.text$mn:00001A39                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001A3E                 mov     eax, large fs:0
.text$mn:00001A44                 push    eax
.text$mn:00001A45                 push    ecx
.text$mn:00001A46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A4B                 xor     eax, ebp
.text$mn:00001A4D                 push    eax
.text$mn:00001A4E                 lea     eax, [ebp+var_C]
.text$mn:00001A51                 mov     large fs:0, eax
.text$mn:00001A57                 mov     [ebp+var_10], ecx
.text$mn:00001A5A                 mov     [ebp+var_4], 0
.text$mn:00001A61                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A68                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001A6B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001A70                 mov     ecx, [ebp+var_C]
.text$mn:00001A73                 mov     large fs:0, ecx
.text$mn:00001A7A                 pop     ecx
.text$mn:00001A7B                 mov     esp, ebp
.text$mn:00001A7D                 pop     ebp
.text$mn:00001A7E                 retn
.text$mn:00001A7E ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001A7E
.text$mn:00001A7E ; ---------------------------------------------------------------------------
.text$mn:00001A7F                 align 10h
.text$mn:00001A7F _text$mn        ends
.text$mn:00001A7F
.text$x:00001A80 ; ===========================================================================
.text$x:00001A80
.text$x:00001A80 ; Segment type: Pure code
.text$x:00001A80 ; Segment permissions: Read/Execute
.text$x:00001A80 _text$x         segment para public 'CODE' use32
.text$x:00001A80                 assume cs:_text$x
.text$x:00001A80                 ;org 1A80h
.text$x:00001A80 ; COMDAT (pick associative to section at 1A34)
.text$x:00001A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A80
.text$x:00001A80 ; =============== S U B R O U T I N E =======================================
.text$x:00001A80
.text$x:00001A80
.text$x:00001A80 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001A80                                         ; DATA XREF: .xdata$x:00004234o
.text$x:00001A80                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A83                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001A83 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001A83
.text$x:00001A88
.text$x:00001A88 ; =============== S U B R O U T I N E =======================================
.text$x:00001A88
.text$x:00001A88
.text$x:00001A88 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001A88                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001A88
.text$x:00001A88 arg_4           = dword ptr  8
.text$x:00001A88
.text$x:00001A88                 mov     edx, [esp+arg_4]
.text$x:00001A8C                 lea     eax, [edx+0Ch]
.text$x:00001A8F                 mov     ecx, [edx-8]
.text$x:00001A92                 xor     ecx, eax
.text$x:00001A94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A99                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001A9E                 jmp     ___CxxFrameHandler3
.text$x:00001A9E __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001A9E
.text$x:00001A9E ; ---------------------------------------------------------------------------
.text$x:00001AA3                 align 4
.text$x:00001AA3 _text$x         ends
.text$x:00001AA3
.text$mn:00001AA4 ; ===========================================================================
.text$mn:00001AA4
.text$mn:00001AA4 ; Segment type: Pure code
.text$mn:00001AA4 ; Segment permissions: Read/Execute
.text$mn:00001AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AA4                 assume cs:_text$mn
.text$mn:00001AA4                 ;org 1AA4h
.text$mn:00001AA4 ; COMDAT (pick any)
.text$mn:00001AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AA4
.text$mn:00001AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AA4
.text$mn:00001AA4 ; Attributes: bp-based frame
.text$mn:00001AA4
.text$mn:00001AA4 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001AA4                 public ??1error_category@std@@UAE@XZ
.text$mn:00001AA4 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001AA4                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001AA4
.text$mn:00001AA4 var_4           = dword ptr -4
.text$mn:00001AA4
.text$mn:00001AA4                 push    ebp
.text$mn:00001AA5                 mov     ebp, esp
.text$mn:00001AA7                 push    ecx
.text$mn:00001AA8                 mov     [ebp+var_4], ecx
.text$mn:00001AAB                 mov     eax, [ebp+var_4]
.text$mn:00001AAE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001AB4                 mov     esp, ebp
.text$mn:00001AB6                 pop     ebp
.text$mn:00001AB7                 retn
.text$mn:00001AB7 ??1error_category@std@@UAE@XZ endp
.text$mn:00001AB7
.text$mn:00001AB7 _text$mn        ends
.text$mn:00001AB7
.text$mn:00001AB8 ; ===========================================================================
.text$mn:00001AB8
.text$mn:00001AB8 ; Segment type: Pure code
.text$mn:00001AB8 ; Segment permissions: Read/Execute
.text$mn:00001AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB8                 assume cs:_text$mn
.text$mn:00001AB8                 ;org 1AB8h
.text$mn:00001AB8 ; COMDAT (pick any)
.text$mn:00001AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AB8
.text$mn:00001AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB8
.text$mn:00001AB8 ; Attributes: bp-based frame
.text$mn:00001AB8
.text$mn:00001AB8 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001AB8                 public ??2@YAPAXIPAX@Z
.text$mn:00001AB8 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001AB8                                         ; std::allocator<HMENU__ *>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)+2Ep ...
.text$mn:00001AB8
.text$mn:00001AB8 arg_4           = dword ptr  0Ch
.text$mn:00001AB8
.text$mn:00001AB8                 push    ebp
.text$mn:00001AB9                 mov     ebp, esp
.text$mn:00001ABB                 mov     eax, [ebp+arg_4]
.text$mn:00001ABE                 pop     ebp
.text$mn:00001ABF                 retn
.text$mn:00001ABF ??2@YAPAXIPAX@Z endp
.text$mn:00001ABF
.text$mn:00001ABF _text$mn        ends
.text$mn:00001ABF
.text$mn:00001AC0 ; ===========================================================================
.text$mn:00001AC0
.text$mn:00001AC0 ; Segment type: Pure code
.text$mn:00001AC0 ; Segment permissions: Read/Execute
.text$mn:00001AC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AC0                 assume cs:_text$mn
.text$mn:00001AC0                 ;org 1AC0h
.text$mn:00001AC0 ; COMDAT (pick any)
.text$mn:00001AC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AC0
.text$mn:00001AC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC0
.text$mn:00001AC0 ; Attributes: bp-based frame
.text$mn:00001AC0
.text$mn:00001AC0 ; void __cdecl operator delete(void *)
.text$mn:00001AC0                 public ??3@YAXPAX0@Z
.text$mn:00001AC0 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001AC0                                         ; __unwindfunclet$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z$0+8p ...
.text$mn:00001AC0                 push    ebp
.text$mn:00001AC1                 mov     ebp, esp
.text$mn:00001AC3                 pop     ebp
.text$mn:00001AC4                 retn
.text$mn:00001AC4 ??3@YAXPAX0@Z   endp
.text$mn:00001AC4
.text$mn:00001AC4 ; ---------------------------------------------------------------------------
.text$mn:00001AC5                 align 4
.text$mn:00001AC5 _text$mn        ends
.text$mn:00001AC5
.text$mn:00001AC8 ; ===========================================================================
.text$mn:00001AC8
.text$mn:00001AC8 ; Segment type: Pure code
.text$mn:00001AC8 ; Segment permissions: Read/Execute
.text$mn:00001AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AC8                 assume cs:_text$mn
.text$mn:00001AC8                 ;org 1AC8h
.text$mn:00001AC8 ; COMDAT (pick any)
.text$mn:00001AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AC8
.text$mn:00001AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC8
.text$mn:00001AC8 ; Attributes: bp-based frame
.text$mn:00001AC8
.text$mn:00001AC8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00001AC8                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:00001AC8 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00001AC8                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+F9p
.text$mn:00001AC8
.text$mn:00001AC8 var_8           = dword ptr -8
.text$mn:00001AC8 var_3           = byte ptr -3
.text$mn:00001AC8 var_2           = byte ptr -2
.text$mn:00001AC8 var_1           = byte ptr -1
.text$mn:00001AC8 arg_0           = dword ptr  8
.text$mn:00001AC8
.text$mn:00001AC8                 push    ebp
.text$mn:00001AC9                 mov     ebp, esp
.text$mn:00001ACB                 sub     esp, 8
.text$mn:00001ACE                 mov     [ebp+var_8], ecx
.text$mn:00001AD1                 mov     eax, [ebp+var_8]
.text$mn:00001AD4                 cmp     eax, [ebp+arg_0]
.text$mn:00001AD7                 jz      short loc_1B33
.text$mn:00001AD9                 lea     ecx, [ebp+var_1]
.text$mn:00001ADC                 push    ecx
.text$mn:00001ADD                 mov     ecx, [ebp+arg_0]
.text$mn:00001AE0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001AE5                 push    eax
.text$mn:00001AE6                 lea     edx, [ebp+var_2]
.text$mn:00001AE9                 push    edx
.text$mn:00001AEA                 mov     ecx, [ebp+var_8]
.text$mn:00001AED                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001AF2                 push    eax
.text$mn:00001AF3                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00001AF8                 add     esp, 8
.text$mn:00001AFB                 movzx   eax, al
.text$mn:00001AFE                 test    eax, eax
.text$mn:00001B00                 jz      short loc_1B27
.text$mn:00001B02                 xor     ecx, ecx
.text$mn:00001B04                 jz      short loc_1B27
.text$mn:00001B06                 push    0
.text$mn:00001B08                 push    1
.text$mn:00001B0A                 mov     ecx, [ebp+var_8]
.text$mn:00001B0D                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001B12                 lea     edx, [ebp+var_3]
.text$mn:00001B15                 push    edx
.text$mn:00001B16                 mov     ecx, [ebp+arg_0]
.text$mn:00001B19                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001B1E                 push    eax
.text$mn:00001B1F                 mov     ecx, [ebp+var_8]
.text$mn:00001B22                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00001B27
.text$mn:00001B27 loc_1B27:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+38j
.text$mn:00001B27                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Cj
.text$mn:00001B27                 mov     eax, [ebp+arg_0]
.text$mn:00001B2A                 push    eax
.text$mn:00001B2B                 mov     ecx, [ebp+var_8]
.text$mn:00001B2E                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001B33
.text$mn:00001B33 loc_1B33:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Fj
.text$mn:00001B33                 mov     eax, [ebp+var_8]
.text$mn:00001B36                 mov     esp, ebp
.text$mn:00001B38                 pop     ebp
.text$mn:00001B39                 retn    4
.text$mn:00001B39 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00001B39
.text$mn:00001B39 _text$mn        ends
.text$mn:00001B39
.text$mn:00001B3C ; ===========================================================================
.text$mn:00001B3C
.text$mn:00001B3C ; Segment type: Pure code
.text$mn:00001B3C ; Segment permissions: Read/Execute
.text$mn:00001B3C _text$mn        segment para public 'CODE' use32
.text$mn:00001B3C                 assume cs:_text$mn
.text$mn:00001B3C                 ;org 1B3Ch
.text$mn:00001B3C ; COMDAT (pick any)
.text$mn:00001B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B3C
.text$mn:00001B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B3C
.text$mn:00001B3C ; Attributes: bp-based frame
.text$mn:00001B3C
.text$mn:00001B3C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:00001B3C                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00001B3C ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00001B3C                                         ; CODE XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+60p
.text$mn:00001B3C                                         ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+71p ...
.text$mn:00001B3C
.text$mn:00001B3C var_4           = dword ptr -4
.text$mn:00001B3C Str             = dword ptr  8
.text$mn:00001B3C
.text$mn:00001B3C                 push    ebp
.text$mn:00001B3D                 mov     ebp, esp
.text$mn:00001B3F                 push    ecx
.text$mn:00001B40                 mov     [ebp+var_4], ecx
.text$mn:00001B43                 mov     eax, [ebp+Str]
.text$mn:00001B46                 push    eax             ; Str
.text$mn:00001B47                 mov     ecx, [ebp+var_4]
.text$mn:00001B4A                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00001B4F                 mov     esp, ebp
.text$mn:00001B51                 pop     ebp
.text$mn:00001B52                 retn    4
.text$mn:00001B52 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00001B52
.text$mn:00001B52 ; ---------------------------------------------------------------------------
.text$mn:00001B55                 align 4
.text$mn:00001B55 _text$mn        ends
.text$mn:00001B55
.text$mn:00001B58 ; ===========================================================================
.text$mn:00001B58
.text$mn:00001B58 ; Segment type: Pure code
.text$mn:00001B58 ; Segment permissions: Read/Execute
.text$mn:00001B58 _text$mn        segment para public 'CODE' use32
.text$mn:00001B58                 assume cs:_text$mn
.text$mn:00001B58                 ;org 1B58h
.text$mn:00001B58 ; COMDAT (pick any)
.text$mn:00001B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B58
.text$mn:00001B58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B58
.text$mn:00001B58 ; Attributes: bp-based frame
.text$mn:00001B58
.text$mn:00001B58 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001B58                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001B58 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001B58                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001B58                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001B58
.text$mn:00001B58 var_8           = dword ptr -8
.text$mn:00001B58 var_4           = dword ptr -4
.text$mn:00001B58 arg_0           = dword ptr  8
.text$mn:00001B58
.text$mn:00001B58                 push    ebp
.text$mn:00001B59                 mov     ebp, esp
.text$mn:00001B5B                 sub     esp, 8
.text$mn:00001B5E                 mov     [ebp+var_8], ecx
.text$mn:00001B61                 mov     eax, [ebp+var_8]
.text$mn:00001B64                 cmp     eax, [ebp+arg_0]
.text$mn:00001B67                 jnz     short loc_1B72
.text$mn:00001B69                 mov     [ebp+var_4], 1
.text$mn:00001B70                 jmp     short loc_1B79
.text$mn:00001B72 ; ---------------------------------------------------------------------------
.text$mn:00001B72
.text$mn:00001B72 loc_1B72:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001B72                 mov     [ebp+var_4], 0
.text$mn:00001B79
.text$mn:00001B79 loc_1B79:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001B79                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001B7C                 mov     esp, ebp
.text$mn:00001B7E                 pop     ebp
.text$mn:00001B7F                 retn    4
.text$mn:00001B7F ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001B7F
.text$mn:00001B7F ; ---------------------------------------------------------------------------
.text$mn:00001B82                 align 4
.text$mn:00001B82 _text$mn        ends
.text$mn:00001B82
.text$mn:00001B84 ; ===========================================================================
.text$mn:00001B84
.text$mn:00001B84 ; Segment type: Pure code
.text$mn:00001B84 ; Segment permissions: Read/Execute
.text$mn:00001B84 _text$mn        segment para public 'CODE' use32
.text$mn:00001B84                 assume cs:_text$mn
.text$mn:00001B84                 ;org 1B84h
.text$mn:00001B84 ; COMDAT (pick any)
.text$mn:00001B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B84
.text$mn:00001B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B84
.text$mn:00001B84 ; Attributes: bp-based frame
.text$mn:00001B84
.text$mn:00001B84 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001B84                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001B84 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001B84                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001B84
.text$mn:00001B84 var_8           = dword ptr -8
.text$mn:00001B84 var_4           = dword ptr -4
.text$mn:00001B84 arg_0           = dword ptr  8
.text$mn:00001B84
.text$mn:00001B84                 push    ebp
.text$mn:00001B85                 mov     ebp, esp
.text$mn:00001B87                 sub     esp, 8
.text$mn:00001B8A                 push    esi
.text$mn:00001B8B                 mov     [ebp+var_4], ecx
.text$mn:00001B8E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001B91                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001B96                 push    eax
.text$mn:00001B97                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001B9A                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001B9F                 mov     ecx, eax
.text$mn:00001BA1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001BA6                 movzx   eax, al
.text$mn:00001BA9                 test    eax, eax
.text$mn:00001BAB                 jz      short loc_1BCC
.text$mn:00001BAD                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001BB0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001BB5                 mov     esi, eax
.text$mn:00001BB7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001BBA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001BBF                 cmp     esi, eax
.text$mn:00001BC1                 jnz     short loc_1BCC
.text$mn:00001BC3                 mov     [ebp+var_8], 1
.text$mn:00001BCA                 jmp     short loc_1BD3
.text$mn:00001BCC ; ---------------------------------------------------------------------------
.text$mn:00001BCC
.text$mn:00001BCC loc_1BCC:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001BCC                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001BCC                 mov     [ebp+var_8], 0
.text$mn:00001BD3
.text$mn:00001BD3 loc_1BD3:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001BD3                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001BD6                 pop     esi
.text$mn:00001BD7                 mov     esp, ebp
.text$mn:00001BD9                 pop     ebp
.text$mn:00001BDA                 retn    4
.text$mn:00001BDA ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001BDA
.text$mn:00001BDA ; ---------------------------------------------------------------------------
.text$mn:00001BDD                 align 10h
.text$mn:00001BDD _text$mn        ends
.text$mn:00001BDD
.text$mn:00001BE0 ; ===========================================================================
.text$mn:00001BE0
.text$mn:00001BE0 ; Segment type: Pure code
.text$mn:00001BE0 ; Segment permissions: Read/Execute
.text$mn:00001BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BE0                 assume cs:_text$mn
.text$mn:00001BE0                 ;org 1BE0h
.text$mn:00001BE0 ; COMDAT (pick any)
.text$mn:00001BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BE0
.text$mn:00001BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BE0
.text$mn:00001BE0 ; Attributes: bp-based frame
.text$mn:00001BE0
.text$mn:00001BE0 ; public: struct HMENU__ * & __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::operator[](unsigned int)
.text$mn:00001BE0                 public ??A?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEAAPAUHMENU__@@I@Z
.text$mn:00001BE0 ??A?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEAAPAUHMENU__@@I@Z proc near
.text$mn:00001BE0                                         ; CODE XREF: ContextMenu::~ContextMenu(void)+70p
.text$mn:00001BE0
.text$mn:00001BE0 var_4           = dword ptr -4
.text$mn:00001BE0 arg_0           = dword ptr  8
.text$mn:00001BE0
.text$mn:00001BE0                 push    ebp
.text$mn:00001BE1                 mov     ebp, esp
.text$mn:00001BE3                 push    ecx
.text$mn:00001BE4                 mov     [ebp+var_4], ecx
.text$mn:00001BE7                 mov     ecx, [ebp+var_4]
.text$mn:00001BEA                 call    ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::size(void)
.text$mn:00001BEF                 cmp     eax, [ebp+arg_0]
.text$mn:00001BF2                 ja      short loc_1C5C
.text$mn:00001BF4                 push    4B1h            ; unsigned int
.text$mn:00001BF9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001BFE                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00001C03                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001C08                 add     esp, 0Ch
.text$mn:00001C0B                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00001C10                 test    eax, eax
.text$mn:00001C12                 jz      short loc_1C18
.text$mn:00001C14                 xor     ecx, ecx
.text$mn:00001C16                 jnz     short loc_1C3E
.text$mn:00001C18
.text$mn:00001C18 loc_1C18:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+32j
.text$mn:00001C18                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00001C1D                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00001C22                 push    0
.text$mn:00001C24                 push    4B2h
.text$mn:00001C29                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001C2E                 push    2
.text$mn:00001C30                 call    __CrtDbgReportW
.text$mn:00001C35                 add     esp, 18h
.text$mn:00001C38                 cmp     eax, 1
.text$mn:00001C3B                 jnz     short loc_1C3E
.text$mn:00001C3D                 int     3               ; Trap to Debugger
.text$mn:00001C3E
.text$mn:00001C3E loc_1C3E:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+36j
.text$mn:00001C3E                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+5Bj
.text$mn:00001C3E                 push    0
.text$mn:00001C40                 push    4B2h
.text$mn:00001C45                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001C4A                 push    offset ??_C@_1KG@BGKNHFHH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAH?$AAM?$AAE?$AAN?$AAU?$AA_?$AA_?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa@ ; "std::vector<struct HMENU__ *,class std:"...
.text$mn:00001C4F                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00001C54                 call    __invalid_parameter
.text$mn:00001C59                 add     esp, 14h
.text$mn:00001C5C
.text$mn:00001C5C loc_1C5C:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+12j
.text$mn:00001C5C                 mov     eax, [ebp+var_4]
.text$mn:00001C5F                 mov     ecx, [eax+4]
.text$mn:00001C62                 mov     edx, [ebp+arg_0]
.text$mn:00001C65                 lea     eax, [ecx+edx*4]
.text$mn:00001C68                 mov     esp, ebp
.text$mn:00001C6A                 pop     ebp
.text$mn:00001C6B                 retn    4
.text$mn:00001C6B ??A?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEAAPAUHMENU__@@I@Z endp
.text$mn:00001C6B
.text$mn:00001C6B ; ---------------------------------------------------------------------------
.text$mn:00001C6E                 align 10h
.text$mn:00001C6E _text$mn        ends
.text$mn:00001C6E
.text$mn:00001C70 ; ===========================================================================
.text$mn:00001C70
.text$mn:00001C70 ; Segment type: Pure code
.text$mn:00001C70 ; Segment permissions: Read/Execute
.text$mn:00001C70 _text$mn        segment para public 'CODE' use32
.text$mn:00001C70                 assume cs:_text$mn
.text$mn:00001C70                 ;org 1C70h
.text$mn:00001C70 ; COMDAT (pick any)
.text$mn:00001C70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C70
.text$mn:00001C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C70
.text$mn:00001C70 ; Attributes: bp-based frame
.text$mn:00001C70
.text$mn:00001C70 ; public: struct MenuItemUnit const & __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::operator[](unsigned int)const
.text$mn:00001C70                 public ??A?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEABUMenuItemUnit@@I@Z
.text$mn:00001C70 ??A?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEABUMenuItemUnit@@I@Z proc near
.text$mn:00001C70                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+95p
.text$mn:00001C70
.text$mn:00001C70 var_4           = dword ptr -4
.text$mn:00001C70 arg_0           = dword ptr  8
.text$mn:00001C70
.text$mn:00001C70                 push    ebp
.text$mn:00001C71                 mov     ebp, esp
.text$mn:00001C73                 push    ecx
.text$mn:00001C74                 mov     [ebp+var_4], ecx
.text$mn:00001C77                 mov     ecx, [ebp+var_4]
.text$mn:00001C7A                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:00001C7F                 cmp     eax, [ebp+arg_0]
.text$mn:00001C82                 ja      short loc_1CEC
.text$mn:00001C84                 push    4A1h            ; unsigned int
.text$mn:00001C89                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001C8E                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00001C93                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001C98                 add     esp, 0Ch
.text$mn:00001C9B                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00001CA0                 test    eax, eax
.text$mn:00001CA2                 jz      short loc_1CA8
.text$mn:00001CA4                 xor     ecx, ecx
.text$mn:00001CA6                 jnz     short loc_1CCE
.text$mn:00001CA8
.text$mn:00001CA8 loc_1CA8:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+32j
.text$mn:00001CA8                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00001CAD                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00001CB2                 push    0
.text$mn:00001CB4                 push    4A2h
.text$mn:00001CB9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001CBE                 push    2
.text$mn:00001CC0                 call    __CrtDbgReportW
.text$mn:00001CC5                 add     esp, 18h
.text$mn:00001CC8                 cmp     eax, 1
.text$mn:00001CCB                 jnz     short loc_1CCE
.text$mn:00001CCD                 int     3               ; Trap to Debugger
.text$mn:00001CCE
.text$mn:00001CCE loc_1CCE:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+36j
.text$mn:00001CCE                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+5Bj
.text$mn:00001CCE                 push    0
.text$mn:00001CD0                 push    4A2h
.text$mn:00001CD5                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001CDA                 push    offset ??_C@_1LC@CAPJOKNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAM?$AAe?$AAn?$AAu?$AAI?$AAt?$AAe?$AAm?$AAU?$AAn?$AAi?$AAt?$AA?0@ ; "std::vector<struct MenuItemUnit,class s"...
.text$mn:00001CDF                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00001CE4                 call    __invalid_parameter
.text$mn:00001CE9                 add     esp, 14h
.text$mn:00001CEC
.text$mn:00001CEC loc_1CEC:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+12j
.text$mn:00001CEC                 imul    eax, [ebp+arg_0], 3Ch
.text$mn:00001CF0                 mov     ecx, [ebp+var_4]
.text$mn:00001CF3                 add     eax, [ecx+4]
.text$mn:00001CF6                 mov     esp, ebp
.text$mn:00001CF8                 pop     ebp
.text$mn:00001CF9                 retn    4
.text$mn:00001CF9 ??A?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEABUMenuItemUnit@@I@Z endp
.text$mn:00001CF9
.text$mn:00001CF9 _text$mn        ends
.text$mn:00001CF9
.text$mn:00001CFC ; ===========================================================================
.text$mn:00001CFC
.text$mn:00001CFC ; Segment type: Pure code
.text$mn:00001CFC ; Segment permissions: Read/Execute
.text$mn:00001CFC _text$mn        segment para public 'CODE' use32
.text$mn:00001CFC                 assume cs:_text$mn
.text$mn:00001CFC                 ;org 1CFCh
.text$mn:00001CFC ; COMDAT (pick any)
.text$mn:00001CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CFC
.text$mn:00001CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CFC
.text$mn:00001CFC ; Attributes: bp-based frame
.text$mn:00001CFC
.text$mn:00001CFC ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001CFC                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001CFC ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001CFC
.text$mn:00001CFC var_4           = dword ptr -4
.text$mn:00001CFC arg_0           = dword ptr  8
.text$mn:00001CFC
.text$mn:00001CFC                 push    ebp
.text$mn:00001CFD                 mov     ebp, esp
.text$mn:00001CFF                 push    ecx
.text$mn:00001D00                 mov     [ebp+var_4], ecx
.text$mn:00001D03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D06                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001D0B                 mov     eax, [ebp+arg_0]
.text$mn:00001D0E                 and     eax, 1
.text$mn:00001D11                 jz      short loc_1D1F
.text$mn:00001D13                 mov     ecx, [ebp+var_4]
.text$mn:00001D16                 push    ecx             ; void *
.text$mn:00001D17                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001D1C                 add     esp, 4
.text$mn:00001D1F
.text$mn:00001D1F loc_1D1F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001D1F                 mov     eax, [ebp+var_4]
.text$mn:00001D22                 mov     esp, ebp
.text$mn:00001D24                 pop     ebp
.text$mn:00001D25                 retn    4
.text$mn:00001D25 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001D25
.text$mn:00001D25 _text$mn        ends
.text$mn:00001D25
.text$mn:00001D28 ; ===========================================================================
.text$mn:00001D28
.text$mn:00001D28 ; Segment type: Pure code
.text$mn:00001D28 ; Segment permissions: Read/Execute
.text$mn:00001D28 _text$mn        segment para public 'CODE' use32
.text$mn:00001D28                 assume cs:_text$mn
.text$mn:00001D28                 ;org 1D28h
.text$mn:00001D28 ; COMDAT (pick any)
.text$mn:00001D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D28
.text$mn:00001D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D28
.text$mn:00001D28 ; Attributes: bp-based frame
.text$mn:00001D28
.text$mn:00001D28 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001D28                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001D28 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001D28
.text$mn:00001D28 var_4           = dword ptr -4
.text$mn:00001D28 arg_0           = dword ptr  8
.text$mn:00001D28
.text$mn:00001D28                 push    ebp
.text$mn:00001D29                 mov     ebp, esp
.text$mn:00001D2B                 push    ecx
.text$mn:00001D2C                 mov     [ebp+var_4], ecx
.text$mn:00001D2F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D32                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001D37                 mov     eax, [ebp+arg_0]
.text$mn:00001D3A                 and     eax, 1
.text$mn:00001D3D                 jz      short loc_1D4B
.text$mn:00001D3F                 mov     ecx, [ebp+var_4]
.text$mn:00001D42                 push    ecx             ; void *
.text$mn:00001D43                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001D48                 add     esp, 4
.text$mn:00001D4B
.text$mn:00001D4B loc_1D4B:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001D4B                 mov     eax, [ebp+var_4]
.text$mn:00001D4E                 mov     esp, ebp
.text$mn:00001D50                 pop     ebp
.text$mn:00001D51                 retn    4
.text$mn:00001D51 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001D51
.text$mn:00001D51 _text$mn        ends
.text$mn:00001D51
.text$mn:00001D54 ; ===========================================================================
.text$mn:00001D54
.text$mn:00001D54 ; Segment type: Pure code
.text$mn:00001D54 ; Segment permissions: Read/Execute
.text$mn:00001D54 _text$mn        segment para public 'CODE' use32
.text$mn:00001D54                 assume cs:_text$mn
.text$mn:00001D54                 ;org 1D54h
.text$mn:00001D54 ; COMDAT (pick any)
.text$mn:00001D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D54
.text$mn:00001D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D54
.text$mn:00001D54 ; Attributes: bp-based frame
.text$mn:00001D54
.text$mn:00001D54 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001D54                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001D54 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001D54
.text$mn:00001D54 var_4           = dword ptr -4
.text$mn:00001D54 arg_0           = dword ptr  8
.text$mn:00001D54
.text$mn:00001D54                 push    ebp
.text$mn:00001D55                 mov     ebp, esp
.text$mn:00001D57                 push    ecx
.text$mn:00001D58                 mov     [ebp+var_4], ecx
.text$mn:00001D5B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D5E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001D63                 mov     eax, [ebp+arg_0]
.text$mn:00001D66                 and     eax, 1
.text$mn:00001D69                 jz      short loc_1D77
.text$mn:00001D6B                 mov     ecx, [ebp+var_4]
.text$mn:00001D6E                 push    ecx             ; void *
.text$mn:00001D6F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001D74                 add     esp, 4
.text$mn:00001D77
.text$mn:00001D77 loc_1D77:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001D77                 mov     eax, [ebp+var_4]
.text$mn:00001D7A                 mov     esp, ebp
.text$mn:00001D7C                 pop     ebp
.text$mn:00001D7D                 retn    4
.text$mn:00001D7D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001D7D
.text$mn:00001D7D _text$mn        ends
.text$mn:00001D7D
.text$mn:00001D80 ; ===========================================================================
.text$mn:00001D80
.text$mn:00001D80 ; Segment type: Pure code
.text$mn:00001D80 ; Segment permissions: Read/Execute
.text$mn:00001D80 _text$mn        segment para public 'CODE' use32
.text$mn:00001D80                 assume cs:_text$mn
.text$mn:00001D80                 ;org 1D80h
.text$mn:00001D80 ; COMDAT (pick any)
.text$mn:00001D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D80
.text$mn:00001D80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D80
.text$mn:00001D80 ; Attributes: bp-based frame
.text$mn:00001D80
.text$mn:00001D80 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001D80                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001D80 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001D80
.text$mn:00001D80 var_4           = dword ptr -4
.text$mn:00001D80 arg_0           = dword ptr  8
.text$mn:00001D80
.text$mn:00001D80                 push    ebp
.text$mn:00001D81                 mov     ebp, esp
.text$mn:00001D83                 push    ecx
.text$mn:00001D84                 mov     [ebp+var_4], ecx
.text$mn:00001D87                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D8A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001D8F                 mov     eax, [ebp+arg_0]
.text$mn:00001D92                 and     eax, 1
.text$mn:00001D95                 jz      short loc_1DA3
.text$mn:00001D97                 mov     ecx, [ebp+var_4]
.text$mn:00001D9A                 push    ecx             ; void *
.text$mn:00001D9B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001DA0                 add     esp, 4
.text$mn:00001DA3
.text$mn:00001DA3 loc_1DA3:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001DA3                 mov     eax, [ebp+var_4]
.text$mn:00001DA6                 mov     esp, ebp
.text$mn:00001DA8                 pop     ebp
.text$mn:00001DA9                 retn    4
.text$mn:00001DA9 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001DA9
.text$mn:00001DA9 _text$mn        ends
.text$mn:00001DA9
.text$di:00001DAC ; ===========================================================================
.text$di:00001DAC
.text$di:00001DAC ; Segment type: Pure code
.text$di:00001DAC ; Segment permissions: Read/Execute
.text$di:00001DAC _text$di        segment para public 'CODE' use32
.text$di:00001DAC                 assume cs:_text$di
.text$di:00001DAC                 ;org 1DACh
.text$di:00001DAC ; COMDAT (pick any)
.text$di:00001DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DAC
.text$di:00001DAC ; =============== S U B R O U T I N E =======================================
.text$di:00001DAC
.text$di:00001DAC ; Attributes: bp-based frame
.text$di:00001DAC
.text$di:00001DAC ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001DAC ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001DAC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001DAC                 push    ebp
.text$di:00001DAD                 mov     ebp, esp
.text$di:00001DAF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001DB4                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001DB9                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001DBE                 call    _atexit
.text$di:00001DC3                 add     esp, 4
.text$di:00001DC6                 pop     ebp
.text$di:00001DC7                 retn
.text$di:00001DC7 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001DC7
.text$di:00001DC7 _text$di        ends
.text$di:00001DC7
.text$di:00001DC8 ; ===========================================================================
.text$di:00001DC8
.text$di:00001DC8 ; Segment type: Pure code
.text$di:00001DC8 ; Segment permissions: Read/Execute
.text$di:00001DC8 _text$di        segment para public 'CODE' use32
.text$di:00001DC8                 assume cs:_text$di
.text$di:00001DC8                 ;org 1DC8h
.text$di:00001DC8 ; COMDAT (pick any)
.text$di:00001DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DC8
.text$di:00001DC8 ; =============== S U B R O U T I N E =======================================
.text$di:00001DC8
.text$di:00001DC8 ; Attributes: bp-based frame
.text$di:00001DC8
.text$di:00001DC8 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001DC8 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001DC8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001DC8                 push    ebp
.text$di:00001DC9                 mov     ebp, esp
.text$di:00001DCB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001DD0                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001DD5                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001DDA                 call    _atexit
.text$di:00001DDF                 add     esp, 4
.text$di:00001DE2                 pop     ebp
.text$di:00001DE3                 retn
.text$di:00001DE3 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001DE3
.text$di:00001DE3 _text$di        ends
.text$di:00001DE3
.text$di:00001DE4 ; ===========================================================================
.text$di:00001DE4
.text$di:00001DE4 ; Segment type: Pure code
.text$di:00001DE4 ; Segment permissions: Read/Execute
.text$di:00001DE4 _text$di        segment para public 'CODE' use32
.text$di:00001DE4                 assume cs:_text$di
.text$di:00001DE4                 ;org 1DE4h
.text$di:00001DE4 ; COMDAT (pick any)
.text$di:00001DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DE4
.text$di:00001DE4 ; =============== S U B R O U T I N E =======================================
.text$di:00001DE4
.text$di:00001DE4 ; Attributes: bp-based frame
.text$di:00001DE4
.text$di:00001DE4 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001DE4 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001DE4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001DE4                 push    ebp
.text$di:00001DE5                 mov     ebp, esp
.text$di:00001DE7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001DEC                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001DF1                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001DF6                 call    _atexit
.text$di:00001DFB                 add     esp, 4
.text$di:00001DFE                 pop     ebp
.text$di:00001DFF                 retn
.text$di:00001DFF ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001DFF
.text$di:00001DFF _text$di        ends
.text$di:00001DFF
.text$di:00001E00 ; ===========================================================================
.text$di:00001E00
.text$di:00001E00 ; Segment type: Pure code
.text$di:00001E00 ; Segment permissions: Read/Execute
.text$di:00001E00 _text$di        segment para public 'CODE' use32
.text$di:00001E00                 assume cs:_text$di
.text$di:00001E00                 ;org 1E00h
.text$di:00001E00 ; COMDAT (pick any)
.text$di:00001E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001E00
.text$di:00001E00 ; =============== S U B R O U T I N E =======================================
.text$di:00001E00
.text$di:00001E00 ; Attributes: bp-based frame
.text$di:00001E00
.text$di:00001E00 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001E00 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001E00                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001E00                 push    ebp
.text$di:00001E01                 mov     ebp, esp
.text$di:00001E03                 push    0               ; unsigned int
.text$di:00001E05                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001E0A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001E0F                 pop     ebp
.text$di:00001E10                 retn
.text$di:00001E10 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001E10
.text$di:00001E10 ; ---------------------------------------------------------------------------
.text$di:00001E11                 align 4
.text$di:00001E11 _text$di        ends
.text$di:00001E11
.text$di:00001E14 ; ===========================================================================
.text$di:00001E14
.text$di:00001E14 ; Segment type: Pure code
.text$di:00001E14 ; Segment permissions: Read/Execute
.text$di:00001E14 _text$di        segment para public 'CODE' use32
.text$di:00001E14                 assume cs:_text$di
.text$di:00001E14                 ;org 1E14h
.text$di:00001E14 ; COMDAT (pick any)
.text$di:00001E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001E14
.text$di:00001E14 ; =============== S U B R O U T I N E =======================================
.text$di:00001E14
.text$di:00001E14 ; Attributes: bp-based frame
.text$di:00001E14
.text$di:00001E14 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001E14 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001E14                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001E14                 push    ebp
.text$di:00001E15                 mov     ebp, esp
.text$di:00001E17                 push    0               ; unsigned int
.text$di:00001E19                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001E1E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001E23                 pop     ebp
.text$di:00001E24                 retn
.text$di:00001E24 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001E24
.text$di:00001E24 ; ---------------------------------------------------------------------------
.text$di:00001E25                 align 4
.text$di:00001E25 _text$di        ends
.text$di:00001E25
.text$di:00001E28 ; ===========================================================================
.text$di:00001E28
.text$di:00001E28 ; Segment type: Pure code
.text$di:00001E28 ; Segment permissions: Read/Execute
.text$di:00001E28 _text$di        segment para public 'CODE' use32
.text$di:00001E28                 assume cs:_text$di
.text$di:00001E28                 ;org 1E28h
.text$di:00001E28 ; COMDAT (pick any)
.text$di:00001E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001E28
.text$di:00001E28 ; =============== S U B R O U T I N E =======================================
.text$di:00001E28
.text$di:00001E28 ; Attributes: bp-based frame
.text$di:00001E28
.text$di:00001E28 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001E28 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001E28                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001E28                 push    ebp
.text$di:00001E29                 mov     ebp, esp
.text$di:00001E2B                 push    0               ; unsigned int
.text$di:00001E2D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001E32                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001E37                 pop     ebp
.text$di:00001E38                 retn
.text$di:00001E38 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001E38
.text$di:00001E38 ; ---------------------------------------------------------------------------
.text$di:00001E39                 align 4
.text$di:00001E39 _text$di        ends
.text$di:00001E39
.text$di:00001E3C ; ===========================================================================
.text$di:00001E3C
.text$di:00001E3C ; Segment type: Pure code
.text$di:00001E3C ; Segment permissions: Read/Execute
.text$di:00001E3C _text$di        segment para public 'CODE' use32
.text$di:00001E3C                 assume cs:_text$di
.text$di:00001E3C                 ;org 1E3Ch
.text$di:00001E3C ; COMDAT (pick any)
.text$di:00001E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001E3C
.text$di:00001E3C ; =============== S U B R O U T I N E =======================================
.text$di:00001E3C
.text$di:00001E3C ; Attributes: bp-based frame
.text$di:00001E3C
.text$di:00001E3C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001E3C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001E3C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001E3C                 push    ebp
.text$di:00001E3D                 mov     ebp, esp
.text$di:00001E3F                 push    0               ; unsigned int
.text$di:00001E41                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001E46                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001E4B                 pop     ebp
.text$di:00001E4C                 retn
.text$di:00001E4C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001E4C
.text$di:00001E4C ; ---------------------------------------------------------------------------
.text$di:00001E4D                 align 10h
.text$di:00001E4D _text$di        ends
.text$di:00001E4D
.text$di:00001E50 ; ===========================================================================
.text$di:00001E50
.text$di:00001E50 ; Segment type: Pure code
.text$di:00001E50 ; Segment permissions: Read/Execute
.text$di:00001E50 _text$di        segment para public 'CODE' use32
.text$di:00001E50                 assume cs:_text$di
.text$di:00001E50                 ;org 1E50h
.text$di:00001E50 ; COMDAT (pick any)
.text$di:00001E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001E50
.text$di:00001E50 ; =============== S U B R O U T I N E =======================================
.text$di:00001E50
.text$di:00001E50 ; Attributes: bp-based frame
.text$di:00001E50
.text$di:00001E50 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001E50 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001E50
.text$di:00001E50 var_1           = byte ptr -1
.text$di:00001E50
.text$di:00001E50                 push    ebp
.text$di:00001E51                 mov     ebp, esp
.text$di:00001E53                 push    ecx
.text$di:00001E54                 xor     eax, eax
.text$di:00001E56                 mov     [ebp+var_1], al
.text$di:00001E59                 mov     esp, ebp
.text$di:00001E5B                 pop     ebp
.text$di:00001E5C                 retn
.text$di:00001E5C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001E5C
.text$di:00001E5C ; ---------------------------------------------------------------------------
.text$di:00001E5D                 align 10h
.text$di:00001E5D _text$di        ends
.text$di:00001E5D
.text$di:00001E60 ; ===========================================================================
.text$di:00001E60
.text$di:00001E60 ; Segment type: Pure code
.text$di:00001E60 ; Segment permissions: Read/Execute
.text$di:00001E60 _text$di        segment para public 'CODE' use32
.text$di:00001E60                 assume cs:_text$di
.text$di:00001E60                 ;org 1E60h
.text$di:00001E60 ; COMDAT (pick any)
.text$di:00001E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001E60
.text$di:00001E60 ; =============== S U B R O U T I N E =======================================
.text$di:00001E60
.text$di:00001E60 ; Attributes: bp-based frame
.text$di:00001E60
.text$di:00001E60 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001E60 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001E60                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001E60
.text$di:00001E60 var_1           = byte ptr -1
.text$di:00001E60
.text$di:00001E60                 push    ebp
.text$di:00001E61                 mov     ebp, esp
.text$di:00001E63                 push    ecx
.text$di:00001E64                 xor     eax, eax
.text$di:00001E66                 mov     [ebp+var_1], al
.text$di:00001E69                 mov     esp, ebp
.text$di:00001E6B                 pop     ebp
.text$di:00001E6C                 retn
.text$di:00001E6C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001E6C
.text$di:00001E6C ; ---------------------------------------------------------------------------
.text$di:00001E6D                 align 10h
.text$di:00001E6D _text$di        ends
.text$di:00001E6D
.text$yd:00001E70 ; ===========================================================================
.text$yd:00001E70
.text$yd:00001E70 ; Segment type: Pure code
.text$yd:00001E70 ; Segment permissions: Read/Execute
.text$yd:00001E70 _text$yd        segment para public 'CODE' use32
.text$yd:00001E70                 assume cs:_text$yd
.text$yd:00001E70                 ;org 1E70h
.text$yd:00001E70 ; COMDAT (pick any)
.text$yd:00001E70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001E70
.text$yd:00001E70 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E70
.text$yd:00001E70 ; Attributes: bp-based frame
.text$yd:00001E70
.text$yd:00001E70 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001E70 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001E70                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001E70                 push    ebp
.text$yd:00001E71                 mov     ebp, esp
.text$yd:00001E73                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001E78                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001E7D                 pop     ebp
.text$yd:00001E7E                 retn
.text$yd:00001E7E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001E7E
.text$yd:00001E7E ; ---------------------------------------------------------------------------
.text$yd:00001E7F                 align 10h
.text$yd:00001E7F _text$yd        ends
.text$yd:00001E7F
.text$yd:00001E80 ; ===========================================================================
.text$yd:00001E80
.text$yd:00001E80 ; Segment type: Pure code
.text$yd:00001E80 ; Segment permissions: Read/Execute
.text$yd:00001E80 _text$yd        segment para public 'CODE' use32
.text$yd:00001E80                 assume cs:_text$yd
.text$yd:00001E80                 ;org 1E80h
.text$yd:00001E80 ; COMDAT (pick any)
.text$yd:00001E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001E80
.text$yd:00001E80 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E80
.text$yd:00001E80 ; Attributes: bp-based frame
.text$yd:00001E80
.text$yd:00001E80 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001E80 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001E80                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001E80                 push    ebp
.text$yd:00001E81                 mov     ebp, esp
.text$yd:00001E83                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001E88                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001E8D                 pop     ebp
.text$yd:00001E8E                 retn
.text$yd:00001E8E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001E8E
.text$yd:00001E8E ; ---------------------------------------------------------------------------
.text$yd:00001E8F                 align 10h
.text$yd:00001E8F _text$yd        ends
.text$yd:00001E8F
.text$yd:00001E90 ; ===========================================================================
.text$yd:00001E90
.text$yd:00001E90 ; Segment type: Pure code
.text$yd:00001E90 ; Segment permissions: Read/Execute
.text$yd:00001E90 _text$yd        segment para public 'CODE' use32
.text$yd:00001E90                 assume cs:_text$yd
.text$yd:00001E90                 ;org 1E90h
.text$yd:00001E90 ; COMDAT (pick any)
.text$yd:00001E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001E90
.text$yd:00001E90 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E90
.text$yd:00001E90 ; Attributes: bp-based frame
.text$yd:00001E90
.text$yd:00001E90 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001E90 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001E90                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001E90                 push    ebp
.text$yd:00001E91                 mov     ebp, esp
.text$yd:00001E93                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001E98                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001E9D                 pop     ebp
.text$yd:00001E9E                 retn
.text$yd:00001E9E ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001E9E
.text$yd:00001E9E ; ---------------------------------------------------------------------------
.text$yd:00001E9F                 align 10h
.text$yd:00001E9F _text$yd        ends
.text$yd:00001E9F
.text$mn:00001EA0 ; ===========================================================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Segment type: Pure code
.text$mn:00001EA0 ; Segment permissions: Read/Execute
.text$mn:00001EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA0                 assume cs:_text$mn
.text$mn:00001EA0                 ;org 1EA0h
.text$mn:00001EA0 ; COMDAT (pick any)
.text$mn:00001EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EA0
.text$mn:00001EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Attributes: bp-based frame
.text$mn:00001EA0
.text$mn:00001EA0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001EA0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001EA0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001EA0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001EA0
.text$mn:00001EA0 var_10          = byte ptr -10h
.text$mn:00001EA0 var_8           = dword ptr -8
.text$mn:00001EA0 var_1           = byte ptr -1
.text$mn:00001EA0
.text$mn:00001EA0                 push    ebp
.text$mn:00001EA1                 mov     ebp, esp
.text$mn:00001EA3                 sub     esp, 10h
.text$mn:00001EA6                 mov     [ebp+var_8], ecx
.text$mn:00001EA9                 lea     ecx, [ebp+var_1]
.text$mn:00001EAC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001EB1                 push    1
.text$mn:00001EB3                 lea     ecx, [ebp+var_1]
.text$mn:00001EB6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001EBB                 mov     ecx, [ebp+var_8]
.text$mn:00001EBE                 mov     [ecx], eax
.text$mn:00001EC0                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001EC3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001EC8                 push    eax             ; int
.text$mn:00001EC9                 mov     edx, [ebp+var_8]
.text$mn:00001ECC                 mov     eax, [edx]
.text$mn:00001ECE                 push    eax             ; void *
.text$mn:00001ECF                 lea     ecx, [ebp+var_1]
.text$mn:00001ED2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001ED7                 mov     ecx, [ebp+var_8]
.text$mn:00001EDA                 mov     edx, [ecx]
.text$mn:00001EDC                 mov     eax, [ebp+var_8]
.text$mn:00001EDF                 mov     [edx], eax
.text$mn:00001EE1                 mov     esp, ebp
.text$mn:00001EE3                 pop     ebp
.text$mn:00001EE4                 retn
.text$mn:00001EE4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001EE4
.text$mn:00001EE4 ; ---------------------------------------------------------------------------
.text$mn:00001EE5                 align 4
.text$mn:00001EE5 _text$mn        ends
.text$mn:00001EE5
.text$mn:00001EE8 ; ===========================================================================
.text$mn:00001EE8
.text$mn:00001EE8 ; Segment type: Pure code
.text$mn:00001EE8 ; Segment permissions: Read/Execute
.text$mn:00001EE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EE8                 assume cs:_text$mn
.text$mn:00001EE8                 ;org 1EE8h
.text$mn:00001EE8 ; COMDAT (pick any)
.text$mn:00001EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EE8
.text$mn:00001EE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EE8
.text$mn:00001EE8 ; Attributes: bp-based frame
.text$mn:00001EE8
.text$mn:00001EE8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00001EE8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00001EE8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001EE8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00001EE8
.text$mn:00001EE8 var_10          = byte ptr -10h
.text$mn:00001EE8 var_8           = dword ptr -8
.text$mn:00001EE8 var_1           = byte ptr -1
.text$mn:00001EE8
.text$mn:00001EE8                 push    ebp
.text$mn:00001EE9                 mov     ebp, esp
.text$mn:00001EEB                 sub     esp, 10h
.text$mn:00001EEE                 mov     [ebp+var_8], ecx
.text$mn:00001EF1                 lea     ecx, [ebp+var_1]
.text$mn:00001EF4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001EF9                 push    1
.text$mn:00001EFB                 lea     ecx, [ebp+var_1]
.text$mn:00001EFE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001F03                 mov     ecx, [ebp+var_8]
.text$mn:00001F06                 mov     [ecx], eax
.text$mn:00001F08                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001F0B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001F10                 push    eax             ; int
.text$mn:00001F11                 mov     edx, [ebp+var_8]
.text$mn:00001F14                 mov     eax, [edx]
.text$mn:00001F16                 push    eax             ; void *
.text$mn:00001F17                 lea     ecx, [ebp+var_1]
.text$mn:00001F1A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001F1F                 mov     ecx, [ebp+var_8]
.text$mn:00001F22                 mov     edx, [ecx]
.text$mn:00001F24                 mov     eax, [ebp+var_8]
.text$mn:00001F27                 mov     [edx], eax
.text$mn:00001F29                 mov     esp, ebp
.text$mn:00001F2B                 pop     ebp
.text$mn:00001F2C                 retn
.text$mn:00001F2C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001F2C
.text$mn:00001F2C ; ---------------------------------------------------------------------------
.text$mn:00001F2D                 align 10h
.text$mn:00001F2D _text$mn        ends
.text$mn:00001F2D
.text$mn:00001F30 ; ===========================================================================
.text$mn:00001F30
.text$mn:00001F30 ; Segment type: Pure code
.text$mn:00001F30 ; Segment permissions: Read/Execute
.text$mn:00001F30 _text$mn        segment para public 'CODE' use32
.text$mn:00001F30                 assume cs:_text$mn
.text$mn:00001F30                 ;org 1F30h
.text$mn:00001F30 ; COMDAT (pick any)
.text$mn:00001F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F30
.text$mn:00001F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F30
.text$mn:00001F30 ; Attributes: bp-based frame
.text$mn:00001F30
.text$mn:00001F30 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00001F30                 public ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
.text$mn:00001F30 ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z proc near
.text$mn:00001F30                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Ap
.text$mn:00001F30
.text$mn:00001F30 var_4           = dword ptr -4
.text$mn:00001F30
.text$mn:00001F30                 push    ebp
.text$mn:00001F31                 mov     ebp, esp
.text$mn:00001F33                 push    ecx
.text$mn:00001F34                 mov     [ebp+var_4], ecx
.text$mn:00001F37                 mov     esp, ebp
.text$mn:00001F39                 pop     ebp
.text$mn:00001F3A                 retn    4
.text$mn:00001F3A ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z endp
.text$mn:00001F3A
.text$mn:00001F3A ; ---------------------------------------------------------------------------
.text$mn:00001F3D                 align 10h
.text$mn:00001F3D _text$mn        ends
.text$mn:00001F3D
.text$mn:00001F40 ; ===========================================================================
.text$mn:00001F40
.text$mn:00001F40 ; Segment type: Pure code
.text$mn:00001F40 ; Segment permissions: Read/Execute
.text$mn:00001F40 _text$mn        segment para public 'CODE' use32
.text$mn:00001F40                 assume cs:_text$mn
.text$mn:00001F40                 ;org 1F40h
.text$mn:00001F40 ; COMDAT (pick any)
.text$mn:00001F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F40
.text$mn:00001F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F40
.text$mn:00001F40 ; Attributes: bp-based frame
.text$mn:00001F40
.text$mn:00001F40 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00001F40                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00001F40 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00001F40                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+80p
.text$mn:00001F40
.text$mn:00001F40 var_4           = dword ptr -4
.text$mn:00001F40
.text$mn:00001F40                 push    ebp
.text$mn:00001F41                 mov     ebp, esp
.text$mn:00001F43                 push    ecx
.text$mn:00001F44                 mov     [ebp+var_4], ecx
.text$mn:00001F47                 mov     eax, [ebp+var_4]
.text$mn:00001F4A                 mov     dword ptr [eax], 0
.text$mn:00001F50                 mov     esp, ebp
.text$mn:00001F52                 pop     ebp
.text$mn:00001F53                 retn
.text$mn:00001F53 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00001F53
.text$mn:00001F53 _text$mn        ends
.text$mn:00001F53
.text$mn:00001F54 ; ===========================================================================
.text$mn:00001F54
.text$mn:00001F54 ; Segment type: Pure code
.text$mn:00001F54 ; Segment permissions: Read/Execute
.text$mn:00001F54 _text$mn        segment para public 'CODE' use32
.text$mn:00001F54                 assume cs:_text$mn
.text$mn:00001F54                 ;org 1F54h
.text$mn:00001F54 ; COMDAT (pick any)
.text$mn:00001F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F54
.text$mn:00001F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F54
.text$mn:00001F54 ; Attributes: bp-based frame
.text$mn:00001F54
.text$mn:00001F54 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001F54                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001F54 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001F54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001F54
.text$mn:00001F54 var_20          = dword ptr -20h
.text$mn:00001F54 var_1C          = dword ptr -1Ch
.text$mn:00001F54 var_18          = dword ptr -18h
.text$mn:00001F54 var_11          = byte ptr -11h
.text$mn:00001F54 var_10          = dword ptr -10h
.text$mn:00001F54 var_C           = byte ptr -0Ch
.text$mn:00001F54 var_4           = dword ptr -4
.text$mn:00001F54 arg_0           = dword ptr  8
.text$mn:00001F54
.text$mn:00001F54 ; FUNCTION CHUNK AT .text$mn:00002076 SIZE 00000009 BYTES
.text$mn:00001F54
.text$mn:00001F54                 push    ebp
.text$mn:00001F55                 mov     ebp, esp
.text$mn:00001F57                 push    0FFFFFFFFh
.text$mn:00001F59                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001F5E                 mov     eax, large fs:0
.text$mn:00001F64                 push    eax
.text$mn:00001F65                 push    ecx
.text$mn:00001F66                 sub     esp, 10h
.text$mn:00001F69                 push    ebx
.text$mn:00001F6A                 push    esi
.text$mn:00001F6B                 push    edi
.text$mn:00001F6C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F71                 xor     eax, ebp
.text$mn:00001F73                 push    eax
.text$mn:00001F74                 lea     eax, [ebp+var_C]
.text$mn:00001F77                 mov     large fs:0, eax
.text$mn:00001F7D                 mov     [ebp+var_10], esp
.text$mn:00001F80                 mov     [ebp+var_18], ecx
.text$mn:00001F83                 mov     eax, [ebp+arg_0]
.text$mn:00001F86                 or      eax, 0Fh
.text$mn:00001F89                 mov     [ebp+var_1C], eax
.text$mn:00001F8C                 mov     ecx, [ebp+var_18]
.text$mn:00001F8F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001F94                 cmp     eax, [ebp+var_1C]
.text$mn:00001F97                 jnb     short loc_1FA1
.text$mn:00001F99                 mov     ecx, [ebp+arg_0]
.text$mn:00001F9C                 mov     [ebp+var_1C], ecx
.text$mn:00001F9F                 jmp     short loc_1FF3
.text$mn:00001FA1 ; ---------------------------------------------------------------------------
.text$mn:00001FA1
.text$mn:00001FA1 loc_1FA1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001FA1                 mov     edx, [ebp+var_18]
.text$mn:00001FA4                 mov     ecx, [edx+18h]
.text$mn:00001FA7                 shr     ecx, 1
.text$mn:00001FA9                 mov     eax, [ebp+var_1C]
.text$mn:00001FAC                 xor     edx, edx
.text$mn:00001FAE                 mov     esi, 3
.text$mn:00001FB3                 div     esi
.text$mn:00001FB5                 cmp     ecx, eax
.text$mn:00001FB7                 ja      short loc_1FBB
.text$mn:00001FB9                 jmp     short loc_1FF3
.text$mn:00001FBB ; ---------------------------------------------------------------------------
.text$mn:00001FBB
.text$mn:00001FBB loc_1FBB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001FBB                 mov     ecx, [ebp+var_18]
.text$mn:00001FBE                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001FC3                 mov     edx, [ebp+var_18]
.text$mn:00001FC6                 mov     ecx, [edx+18h]
.text$mn:00001FC9                 shr     ecx, 1
.text$mn:00001FCB                 sub     eax, ecx
.text$mn:00001FCD                 mov     edx, [ebp+var_18]
.text$mn:00001FD0                 cmp     [edx+18h], eax
.text$mn:00001FD3                 ja      short loc_1FE8
.text$mn:00001FD5                 mov     eax, [ebp+var_18]
.text$mn:00001FD8                 mov     ecx, [eax+18h]
.text$mn:00001FDB                 shr     ecx, 1
.text$mn:00001FDD                 mov     edx, [ebp+var_18]
.text$mn:00001FE0                 add     ecx, [edx+18h]
.text$mn:00001FE3                 mov     [ebp+var_1C], ecx
.text$mn:00001FE6                 jmp     short loc_1FF3
.text$mn:00001FE8 ; ---------------------------------------------------------------------------
.text$mn:00001FE8
.text$mn:00001FE8 loc_1FE8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001FE8                 mov     ecx, [ebp+var_18]
.text$mn:00001FEB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001FF0                 mov     [ebp+var_1C], eax
.text$mn:00001FF3
.text$mn:00001FF3 loc_1FF3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001FF3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001FF3                 mov     [ebp+var_4], 0
.text$mn:00001FFA                 mov     eax, [ebp+var_1C]
.text$mn:00001FFD                 add     eax, 1
.text$mn:00002000                 push    eax
.text$mn:00002001                 lea     ecx, [ebp+var_11]
.text$mn:00002004                 push    ecx
.text$mn:00002005                 mov     ecx, [ebp+var_18]
.text$mn:00002008                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000200D                 mov     ecx, eax
.text$mn:0000200F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00002014                 mov     [ebp+var_20], eax
.text$mn:00002017                 jmp     short loc_2076
.text$mn:00002017 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00002017
.text$mn:00002019
.text$mn:00002019 ; =============== S U B R O U T I N E =======================================
.text$mn:00002019
.text$mn:00002019
.text$mn:00002019 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00002019                                         ; DATA XREF: .xdata$x:00004050o
.text$mn:00002019
.text$mn:00002019 ; FUNCTION CHUNK AT .text$mn:00002060 SIZE 00000009 BYTES
.text$mn:00002019 ; FUNCTION CHUNK AT .text$mn:00002070 SIZE 00000006 BYTES
.text$mn:00002019
.text$mn:00002019                 mov     [ebp-10h], esp
.text$mn:0000201C                 mov     edx, [ebp+8]
.text$mn:0000201F                 mov     [ebp-1Ch], edx
.text$mn:00002022                 mov     byte ptr [ebp-4], 2
.text$mn:00002026                 mov     eax, [ebp-1Ch]
.text$mn:00002029                 add     eax, 1
.text$mn:0000202C                 push    eax
.text$mn:0000202D                 lea     ecx, [ebp-12h]
.text$mn:00002030                 push    ecx
.text$mn:00002031                 mov     ecx, [ebp-18h]
.text$mn:00002034                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002039                 mov     ecx, eax
.text$mn:0000203B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00002040                 mov     [ebp-20h], eax
.text$mn:00002043                 jmp     short loc_2060
.text$mn:00002043 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00002043
.text$mn:00002045
.text$mn:00002045 ; =============== S U B R O U T I N E =======================================
.text$mn:00002045
.text$mn:00002045 ; Attributes: noreturn
.text$mn:00002045
.text$mn:00002045 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00002045                                         ; DATA XREF: .xdata$x:00004060o
.text$mn:00002045                 push    0               ; Size
.text$mn:00002047                 push    1               ; char
.text$mn:00002049                 mov     ecx, [ebp-18h]
.text$mn:0000204C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002051                 push    0
.text$mn:00002053                 push    0
.text$mn:00002055                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002055 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00002055
.text$mn:0000205A ; ---------------------------------------------------------------------------
.text$mn:0000205A                 mov     eax, offset $LN17
.text$mn:0000205F                 retn
.text$mn:00002060 ; ---------------------------------------------------------------------------
.text$mn:00002060 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002060
.text$mn:00002060 loc_2060:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00002060                 mov     dword ptr [ebp-4], 1
.text$mn:00002067                 jmp     short loc_2070
.text$mn:00002067 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002069
.text$mn:00002069 ; =============== S U B R O U T I N E =======================================
.text$mn:00002069
.text$mn:00002069
.text$mn:00002069 $LN17           proc near               ; DATA XREF: .text$mn:0000205Ao
.text$mn:00002069                 mov     dword ptr [ebp-4], 1
.text$mn:00002069 $LN17           endp ; sp-analysis failed
.text$mn:00002069
.text$mn:00002070 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002070
.text$mn:00002070 loc_2070:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00002070                 mov     eax, offset $LN19
.text$mn:00002075                 retn
.text$mn:00002075 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002076 ; ---------------------------------------------------------------------------
.text$mn:00002076 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00002076
.text$mn:00002076 loc_2076:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00002076                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000207D                 jmp     short loc_2086
.text$mn:0000207D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000207F
.text$mn:0000207F ; =============== S U B R O U T I N E =======================================
.text$mn:0000207F
.text$mn:0000207F
.text$mn:0000207F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_2070o
.text$mn:0000207F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002086
.text$mn:00002086 loc_2086:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00002086                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000208A                 jbe     short loc_20A5
.text$mn:0000208C                 mov     edx, [ebp+0Ch]
.text$mn:0000208F                 push    edx             ; Size
.text$mn:00002090                 mov     ecx, [ebp-18h]
.text$mn:00002093                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002098                 push    eax             ; Src
.text$mn:00002099                 mov     eax, [ebp-20h]
.text$mn:0000209C                 push    eax             ; Dst
.text$mn:0000209D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000020A2                 add     esp, 0Ch
.text$mn:000020A5
.text$mn:000020A5 loc_20A5:                               ; CODE XREF: $LN19+Bj
.text$mn:000020A5                 push    0               ; Size
.text$mn:000020A7                 push    1               ; char
.text$mn:000020A9                 mov     ecx, [ebp-18h]
.text$mn:000020AC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000020B1                 lea     ecx, [ebp-20h]
.text$mn:000020B4                 push    ecx             ; int
.text$mn:000020B5                 mov     edx, [ebp-18h]
.text$mn:000020B8                 add     edx, 4
.text$mn:000020BB                 push    edx             ; void *
.text$mn:000020BC                 lea     eax, [ebp-13h]
.text$mn:000020BF                 push    eax
.text$mn:000020C0                 mov     ecx, [ebp-18h]
.text$mn:000020C3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000020C8                 mov     ecx, eax
.text$mn:000020CA                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000020CF                 mov     ecx, [ebp-18h]
.text$mn:000020D2                 mov     edx, [ebp-1Ch]
.text$mn:000020D5                 mov     [ecx+18h], edx
.text$mn:000020D8                 mov     eax, [ebp+0Ch]
.text$mn:000020DB                 push    eax
.text$mn:000020DC                 mov     ecx, [ebp-18h]
.text$mn:000020DF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000020E4                 mov     ecx, [ebp-0Ch]
.text$mn:000020E7                 mov     large fs:0, ecx
.text$mn:000020EE                 pop     ecx
.text$mn:000020EF                 pop     edi
.text$mn:000020F0                 pop     esi
.text$mn:000020F1                 pop     ebx
.text$mn:000020F2                 mov     esp, ebp
.text$mn:000020F4                 pop     ebp
.text$mn:000020F5                 retn    8
.text$mn:000020F5 $LN19           endp ; sp-analysis failed
.text$mn:000020F5
.text$mn:000020F5 _text$mn        ends
.text$mn:000020F5
.text$x:000020F8 ; ===========================================================================
.text$x:000020F8
.text$x:000020F8 ; Segment type: Pure code
.text$x:000020F8 ; Segment permissions: Read/Execute
.text$x:000020F8 _text$x         segment para public 'CODE' use32
.text$x:000020F8                 assume cs:_text$x
.text$x:000020F8                 ;org 20F8h
.text$x:000020F8 ; COMDAT (pick associative to section at 1F54)
.text$x:000020F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000020F8
.text$x:000020F8 ; =============== S U B R O U T I N E =======================================
.text$x:000020F8
.text$x:000020F8
.text$x:000020F8 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000020F8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000020F8
.text$x:000020F8 arg_4           = dword ptr  8
.text$x:000020F8
.text$x:000020F8                 mov     edx, [esp+arg_4]
.text$x:000020FC                 lea     eax, [edx+0Ch]
.text$x:000020FF                 mov     ecx, [edx-24h]
.text$x:00002102                 xor     ecx, eax
.text$x:00002104                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002109                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000210E                 jmp     ___CxxFrameHandler3
.text$x:0000210E __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000210E
.text$x:0000210E ; ---------------------------------------------------------------------------
.text$x:00002113                 align 4
.text$x:00002113 _text$x         ends
.text$x:00002113
.text$mn:00002114 ; ===========================================================================
.text$mn:00002114
.text$mn:00002114 ; Segment type: Pure code
.text$mn:00002114 ; Segment permissions: Read/Execute
.text$mn:00002114 _text$mn        segment para public 'CODE' use32
.text$mn:00002114                 assume cs:_text$mn
.text$mn:00002114                 ;org 2114h
.text$mn:00002114 ; COMDAT (pick any)
.text$mn:00002114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002114
.text$mn:00002114 ; =============== S U B R O U T I N E =======================================
.text$mn:00002114
.text$mn:00002114 ; Attributes: bp-based frame
.text$mn:00002114
.text$mn:00002114 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00002114                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00002114 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00002114                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00002114
.text$mn:00002114 var_20          = dword ptr -20h
.text$mn:00002114 var_1C          = dword ptr -1Ch
.text$mn:00002114 var_18          = dword ptr -18h
.text$mn:00002114 var_11          = byte ptr -11h
.text$mn:00002114 var_10          = dword ptr -10h
.text$mn:00002114 var_C           = byte ptr -0Ch
.text$mn:00002114 var_4           = dword ptr -4
.text$mn:00002114 arg_0           = dword ptr  8
.text$mn:00002114
.text$mn:00002114 ; FUNCTION CHUNK AT .text$mn:00002236 SIZE 00000009 BYTES
.text$mn:00002114
.text$mn:00002114                 push    ebp
.text$mn:00002115                 mov     ebp, esp
.text$mn:00002117                 push    0FFFFFFFFh
.text$mn:00002119                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000211E                 mov     eax, large fs:0
.text$mn:00002124                 push    eax
.text$mn:00002125                 push    ecx
.text$mn:00002126                 sub     esp, 10h
.text$mn:00002129                 push    ebx
.text$mn:0000212A                 push    esi
.text$mn:0000212B                 push    edi
.text$mn:0000212C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002131                 xor     eax, ebp
.text$mn:00002133                 push    eax
.text$mn:00002134                 lea     eax, [ebp+var_C]
.text$mn:00002137                 mov     large fs:0, eax
.text$mn:0000213D                 mov     [ebp+var_10], esp
.text$mn:00002140                 mov     [ebp+var_18], ecx
.text$mn:00002143                 mov     eax, [ebp+arg_0]
.text$mn:00002146                 or      eax, 7
.text$mn:00002149                 mov     [ebp+var_1C], eax
.text$mn:0000214C                 mov     ecx, [ebp+var_18]
.text$mn:0000214F                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00002154                 cmp     eax, [ebp+var_1C]
.text$mn:00002157                 jnb     short loc_2161
.text$mn:00002159                 mov     ecx, [ebp+arg_0]
.text$mn:0000215C                 mov     [ebp+var_1C], ecx
.text$mn:0000215F                 jmp     short loc_21B3
.text$mn:00002161 ; ---------------------------------------------------------------------------
.text$mn:00002161
.text$mn:00002161 loc_2161:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00002161                 mov     edx, [ebp+var_18]
.text$mn:00002164                 mov     ecx, [edx+18h]
.text$mn:00002167                 shr     ecx, 1
.text$mn:00002169                 mov     eax, [ebp+var_1C]
.text$mn:0000216C                 xor     edx, edx
.text$mn:0000216E                 mov     esi, 3
.text$mn:00002173                 div     esi
.text$mn:00002175                 cmp     ecx, eax
.text$mn:00002177                 ja      short loc_217B
.text$mn:00002179                 jmp     short loc_21B3
.text$mn:0000217B ; ---------------------------------------------------------------------------
.text$mn:0000217B
.text$mn:0000217B loc_217B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:0000217B                 mov     ecx, [ebp+var_18]
.text$mn:0000217E                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00002183                 mov     edx, [ebp+var_18]
.text$mn:00002186                 mov     ecx, [edx+18h]
.text$mn:00002189                 shr     ecx, 1
.text$mn:0000218B                 sub     eax, ecx
.text$mn:0000218D                 mov     edx, [ebp+var_18]
.text$mn:00002190                 cmp     [edx+18h], eax
.text$mn:00002193                 ja      short loc_21A8
.text$mn:00002195                 mov     eax, [ebp+var_18]
.text$mn:00002198                 mov     ecx, [eax+18h]
.text$mn:0000219B                 shr     ecx, 1
.text$mn:0000219D                 mov     edx, [ebp+var_18]
.text$mn:000021A0                 add     ecx, [edx+18h]
.text$mn:000021A3                 mov     [ebp+var_1C], ecx
.text$mn:000021A6                 jmp     short loc_21B3
.text$mn:000021A8 ; ---------------------------------------------------------------------------
.text$mn:000021A8
.text$mn:000021A8 loc_21A8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:000021A8                 mov     ecx, [ebp+var_18]
.text$mn:000021AB                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000021B0                 mov     [ebp+var_1C], eax
.text$mn:000021B3
.text$mn:000021B3 loc_21B3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:000021B3                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:000021B3                 mov     [ebp+var_4], 0
.text$mn:000021BA                 mov     eax, [ebp+var_1C]
.text$mn:000021BD                 add     eax, 1
.text$mn:000021C0                 push    eax
.text$mn:000021C1                 lea     ecx, [ebp+var_11]
.text$mn:000021C4                 push    ecx
.text$mn:000021C5                 mov     ecx, [ebp+var_18]
.text$mn:000021C8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000021CD                 mov     ecx, eax
.text$mn:000021CF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000021D4                 mov     [ebp+var_20], eax
.text$mn:000021D7                 jmp     short loc_2236
.text$mn:000021D7 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:000021D7
.text$mn:000021D9
.text$mn:000021D9 ; =============== S U B R O U T I N E =======================================
.text$mn:000021D9
.text$mn:000021D9
.text$mn:000021D9 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:000021D9                                         ; DATA XREF: .xdata$x:0000439Co
.text$mn:000021D9
.text$mn:000021D9 ; FUNCTION CHUNK AT .text$mn:00002220 SIZE 00000009 BYTES
.text$mn:000021D9 ; FUNCTION CHUNK AT .text$mn:00002230 SIZE 00000006 BYTES
.text$mn:000021D9
.text$mn:000021D9                 mov     [ebp-10h], esp
.text$mn:000021DC                 mov     edx, [ebp+8]
.text$mn:000021DF                 mov     [ebp-1Ch], edx
.text$mn:000021E2                 mov     byte ptr [ebp-4], 2
.text$mn:000021E6                 mov     eax, [ebp-1Ch]
.text$mn:000021E9                 add     eax, 1
.text$mn:000021EC                 push    eax
.text$mn:000021ED                 lea     ecx, [ebp-12h]
.text$mn:000021F0                 push    ecx
.text$mn:000021F1                 mov     ecx, [ebp-18h]
.text$mn:000021F4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000021F9                 mov     ecx, eax
.text$mn:000021FB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00002200                 mov     [ebp-20h], eax
.text$mn:00002203                 jmp     short loc_2220
.text$mn:00002203 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00002203
.text$mn:00002205
.text$mn:00002205 ; =============== S U B R O U T I N E =======================================
.text$mn:00002205
.text$mn:00002205 ; Attributes: noreturn
.text$mn:00002205
.text$mn:00002205 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00002205                                         ; DATA XREF: .xdata$x:000043ACo
.text$mn:00002205                 push    0
.text$mn:00002207                 push    1
.text$mn:00002209                 mov     ecx, [ebp-18h]
.text$mn:0000220C                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002211                 push    0
.text$mn:00002213                 push    0
.text$mn:00002215                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002215 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00002215
.text$mn:0000221A ; ---------------------------------------------------------------------------
.text$mn:0000221A                 mov     eax, offset $LN17_0
.text$mn:0000221F                 retn
.text$mn:00002220 ; ---------------------------------------------------------------------------
.text$mn:00002220 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00002220
.text$mn:00002220 loc_2220:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00002220                 mov     dword ptr [ebp-4], 1
.text$mn:00002227                 jmp     short loc_2230
.text$mn:00002227 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00002229
.text$mn:00002229 ; =============== S U B R O U T I N E =======================================
.text$mn:00002229
.text$mn:00002229
.text$mn:00002229 $LN17_0         proc near               ; DATA XREF: .text$mn:0000221Ao
.text$mn:00002229                 mov     dword ptr [ebp-4], 1
.text$mn:00002229 $LN17_0         endp ; sp-analysis failed
.text$mn:00002229
.text$mn:00002230 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00002230
.text$mn:00002230 loc_2230:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00002230                 mov     eax, offset $LN19_0
.text$mn:00002235                 retn
.text$mn:00002235 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00002236 ; ---------------------------------------------------------------------------
.text$mn:00002236 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00002236
.text$mn:00002236 loc_2236:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00002236                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000223D                 jmp     short loc_2246
.text$mn:0000223D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000223F
.text$mn:0000223F ; =============== S U B R O U T I N E =======================================
.text$mn:0000223F
.text$mn:0000223F
.text$mn:0000223F $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_2230o
.text$mn:0000223F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002246
.text$mn:00002246 loc_2246:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00002246                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000224A                 jbe     short loc_2265
.text$mn:0000224C                 mov     edx, [ebp+0Ch]
.text$mn:0000224F                 push    edx             ; int
.text$mn:00002250                 mov     ecx, [ebp-18h]
.text$mn:00002253                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002258                 push    eax             ; Src
.text$mn:00002259                 mov     eax, [ebp-20h]
.text$mn:0000225C                 push    eax             ; Dst
.text$mn:0000225D                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002262                 add     esp, 0Ch
.text$mn:00002265
.text$mn:00002265 loc_2265:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00002265                 push    0
.text$mn:00002267                 push    1
.text$mn:00002269                 mov     ecx, [ebp-18h]
.text$mn:0000226C                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002271                 lea     ecx, [ebp-20h]
.text$mn:00002274                 push    ecx             ; int
.text$mn:00002275                 mov     edx, [ebp-18h]
.text$mn:00002278                 add     edx, 4
.text$mn:0000227B                 push    edx             ; void *
.text$mn:0000227C                 lea     eax, [ebp-13h]
.text$mn:0000227F                 push    eax
.text$mn:00002280                 mov     ecx, [ebp-18h]
.text$mn:00002283                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002288                 mov     ecx, eax
.text$mn:0000228A                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000228F                 mov     ecx, [ebp-18h]
.text$mn:00002292                 mov     edx, [ebp-1Ch]
.text$mn:00002295                 mov     [ecx+18h], edx
.text$mn:00002298                 mov     eax, [ebp+0Ch]
.text$mn:0000229B                 push    eax
.text$mn:0000229C                 mov     ecx, [ebp-18h]
.text$mn:0000229F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000022A4                 mov     ecx, [ebp-0Ch]
.text$mn:000022A7                 mov     large fs:0, ecx
.text$mn:000022AE                 pop     ecx
.text$mn:000022AF                 pop     edi
.text$mn:000022B0                 pop     esi
.text$mn:000022B1                 pop     ebx
.text$mn:000022B2                 mov     esp, ebp
.text$mn:000022B4                 pop     ebp
.text$mn:000022B5                 retn    8
.text$mn:000022B5 $LN19_0         endp ; sp-analysis failed
.text$mn:000022B5
.text$mn:000022B5 _text$mn        ends
.text$mn:000022B5
.text$x:000022B8 ; ===========================================================================
.text$x:000022B8
.text$x:000022B8 ; Segment type: Pure code
.text$x:000022B8 ; Segment permissions: Read/Execute
.text$x:000022B8 _text$x         segment para public 'CODE' use32
.text$x:000022B8                 assume cs:_text$x
.text$x:000022B8                 ;org 22B8h
.text$x:000022B8 ; COMDAT (pick associative to section at 2114)
.text$x:000022B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000022B8
.text$x:000022B8 ; =============== S U B R O U T I N E =======================================
.text$x:000022B8
.text$x:000022B8
.text$x:000022B8 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:000022B8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:000022B8
.text$x:000022B8 arg_4           = dword ptr  8
.text$x:000022B8
.text$x:000022B8                 mov     edx, [esp+arg_4]
.text$x:000022BC                 lea     eax, [edx+0Ch]
.text$x:000022BF                 mov     ecx, [edx-24h]
.text$x:000022C2                 xor     ecx, eax
.text$x:000022C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022C9                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:000022CE                 jmp     ___CxxFrameHandler3
.text$x:000022CE __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:000022CE
.text$x:000022CE ; ---------------------------------------------------------------------------
.text$x:000022D3                 align 4
.text$x:000022D3 _text$x         ends
.text$x:000022D3
.text$mn:000022D4 ; ===========================================================================
.text$mn:000022D4
.text$mn:000022D4 ; Segment type: Pure code
.text$mn:000022D4 ; Segment permissions: Read/Execute
.text$mn:000022D4 _text$mn        segment para public 'CODE' use32
.text$mn:000022D4                 assume cs:_text$mn
.text$mn:000022D4                 ;org 22D4h
.text$mn:000022D4 ; COMDAT (pick any)
.text$mn:000022D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022D4
.text$mn:000022D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022D4
.text$mn:000022D4 ; Attributes: bp-based frame
.text$mn:000022D4
.text$mn:000022D4 ; protected: void __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Destroy(struct HMENU__ * *, struct HMENU__ * *)
.text$mn:000022D4                 public ?_Destroy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXPAPAUHMENU__@@0@Z
.text$mn:000022D4 ?_Destroy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXPAPAUHMENU__@@0@Z proc near
.text$mn:000022D4                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+CBp
.text$mn:000022D4                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Tidy(void)+2Bp
.text$mn:000022D4
.text$mn:000022D4 var_8           = dword ptr -8
.text$mn:000022D4 var_1           = byte ptr -1
.text$mn:000022D4 arg_0           = dword ptr  8
.text$mn:000022D4 arg_4           = dword ptr  0Ch
.text$mn:000022D4
.text$mn:000022D4                 push    ebp
.text$mn:000022D5                 mov     ebp, esp
.text$mn:000022D7                 sub     esp, 8
.text$mn:000022DA                 mov     [ebp+var_8], ecx
.text$mn:000022DD                 lea     eax, [ebp+var_1]
.text$mn:000022E0                 push    eax
.text$mn:000022E1                 mov     ecx, [ebp+var_8]
.text$mn:000022E4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:000022E9                 lea     ecx, [ebp+var_1]
.text$mn:000022EC                 push    ecx
.text$mn:000022ED                 mov     edx, [ebp+arg_4]
.text$mn:000022F0                 push    edx
.text$mn:000022F1                 mov     eax, [ebp+arg_0]
.text$mn:000022F4                 push    eax
.text$mn:000022F5                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@YAXPAPAUHMENU__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HMENU__ *>>>(HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &)
.text$mn:000022FA                 add     esp, 0Ch
.text$mn:000022FD                 mov     esp, ebp
.text$mn:000022FF                 pop     ebp
.text$mn:00002300                 retn    8
.text$mn:00002300 ?_Destroy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXPAPAUHMENU__@@0@Z endp
.text$mn:00002300
.text$mn:00002300 ; ---------------------------------------------------------------------------
.text$mn:00002303                 align 4
.text$mn:00002303 _text$mn        ends
.text$mn:00002303
.text$mn:00002304 ; ===========================================================================
.text$mn:00002304
.text$mn:00002304 ; Segment type: Pure code
.text$mn:00002304 ; Segment permissions: Read/Execute
.text$mn:00002304 _text$mn        segment para public 'CODE' use32
.text$mn:00002304                 assume cs:_text$mn
.text$mn:00002304                 ;org 2304h
.text$mn:00002304 ; COMDAT (pick any)
.text$mn:00002304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002304
.text$mn:00002304 ; =============== S U B R O U T I N E =======================================
.text$mn:00002304
.text$mn:00002304 ; Attributes: bp-based frame
.text$mn:00002304
.text$mn:00002304 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00002304                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00002304 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00002304                                         ; CODE XREF: $LN19+60p
.text$mn:00002304                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00002304
.text$mn:00002304 var_8           = dword ptr -8
.text$mn:00002304 var_1           = byte ptr -1
.text$mn:00002304 arg_0           = dword ptr  8
.text$mn:00002304
.text$mn:00002304                 push    ebp
.text$mn:00002305                 mov     ebp, esp
.text$mn:00002307                 sub     esp, 8
.text$mn:0000230A                 mov     [ebp+var_8], ecx
.text$mn:0000230D                 mov     [ebp+var_1], 0
.text$mn:00002311                 mov     eax, [ebp+var_8]
.text$mn:00002314                 mov     ecx, [ebp+arg_0]
.text$mn:00002317                 mov     [eax+14h], ecx
.text$mn:0000231A                 lea     edx, [ebp+var_1]
.text$mn:0000231D                 push    edx
.text$mn:0000231E                 mov     ecx, [ebp+var_8]
.text$mn:00002321                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002326                 add     eax, [ebp+arg_0]
.text$mn:00002329                 push    eax
.text$mn:0000232A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000232F                 add     esp, 8
.text$mn:00002332                 mov     esp, ebp
.text$mn:00002334                 pop     ebp
.text$mn:00002335                 retn    4
.text$mn:00002335 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00002335
.text$mn:00002335 _text$mn        ends
.text$mn:00002335
.text$mn:00002338 ; ===========================================================================
.text$mn:00002338
.text$mn:00002338 ; Segment type: Pure code
.text$mn:00002338 ; Segment permissions: Read/Execute
.text$mn:00002338 _text$mn        segment para public 'CODE' use32
.text$mn:00002338                 assume cs:_text$mn
.text$mn:00002338                 ;org 2338h
.text$mn:00002338 ; COMDAT (pick any)
.text$mn:00002338                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002338
.text$mn:00002338 ; =============== S U B R O U T I N E =======================================
.text$mn:00002338
.text$mn:00002338 ; Attributes: bp-based frame
.text$mn:00002338
.text$mn:00002338 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00002338                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00002338 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00002338                                         ; CODE XREF: $LN19_0+60p
.text$mn:00002338                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00002338
.text$mn:00002338 var_8           = dword ptr -8
.text$mn:00002338 var_2           = word ptr -2
.text$mn:00002338 arg_0           = dword ptr  8
.text$mn:00002338
.text$mn:00002338                 push    ebp
.text$mn:00002339                 mov     ebp, esp
.text$mn:0000233B                 sub     esp, 8
.text$mn:0000233E                 mov     [ebp+var_8], ecx
.text$mn:00002341                 xor     eax, eax
.text$mn:00002343                 mov     [ebp+var_2], ax
.text$mn:00002347                 mov     ecx, [ebp+var_8]
.text$mn:0000234A                 mov     edx, [ebp+arg_0]
.text$mn:0000234D                 mov     [ecx+14h], edx
.text$mn:00002350                 lea     eax, [ebp+var_2]
.text$mn:00002353                 push    eax
.text$mn:00002354                 mov     ecx, [ebp+var_8]
.text$mn:00002357                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000235C                 mov     ecx, [ebp+arg_0]
.text$mn:0000235F                 lea     edx, [eax+ecx*2]
.text$mn:00002362                 push    edx
.text$mn:00002363                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00002368                 add     esp, 8
.text$mn:0000236B                 mov     esp, ebp
.text$mn:0000236D                 pop     ebp
.text$mn:0000236E                 retn    4
.text$mn:0000236E ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:0000236E
.text$mn:0000236E ; ---------------------------------------------------------------------------
.text$mn:00002371                 align 4
.text$mn:00002371 _text$mn        ends
.text$mn:00002371
.text$mn:00002374 ; ===========================================================================
.text$mn:00002374
.text$mn:00002374 ; Segment type: Pure code
.text$mn:00002374 ; Segment permissions: Read/Execute
.text$mn:00002374 _text$mn        segment para public 'CODE' use32
.text$mn:00002374                 assume cs:_text$mn
.text$mn:00002374                 ;org 2374h
.text$mn:00002374 ; COMDAT (pick any)
.text$mn:00002374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002374
.text$mn:00002374 ; =============== S U B R O U T I N E =======================================
.text$mn:00002374
.text$mn:00002374 ; Attributes: bp-based frame
.text$mn:00002374
.text$mn:00002374 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00002374                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00002374 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00002374                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00002374
.text$mn:00002374 var_8           = dword ptr -8
.text$mn:00002374 var_1           = byte ptr -1
.text$mn:00002374
.text$mn:00002374                 push    ebp
.text$mn:00002375                 mov     ebp, esp
.text$mn:00002377                 sub     esp, 8
.text$mn:0000237A                 mov     [ebp+var_8], ecx
.text$mn:0000237D                 lea     ecx, [ebp+var_1]
.text$mn:00002380                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002385                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002388                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000238D                 mov     eax, [ebp+var_8]
.text$mn:00002390                 mov     ecx, [eax]
.text$mn:00002392                 push    ecx
.text$mn:00002393                 lea     ecx, [ebp+var_1]
.text$mn:00002396                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000239B                 push    1               ; int
.text$mn:0000239D                 mov     edx, [ebp+var_8]
.text$mn:000023A0                 mov     eax, [edx]
.text$mn:000023A2                 push    eax             ; void *
.text$mn:000023A3                 lea     ecx, [ebp+var_1]
.text$mn:000023A6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000023AB                 mov     ecx, [ebp+var_8]
.text$mn:000023AE                 mov     dword ptr [ecx], 0
.text$mn:000023B4                 mov     esp, ebp
.text$mn:000023B6                 pop     ebp
.text$mn:000023B7                 retn
.text$mn:000023B7 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000023B7
.text$mn:000023B7 _text$mn        ends
.text$mn:000023B7
.text$mn:000023B8 ; ===========================================================================
.text$mn:000023B8
.text$mn:000023B8 ; Segment type: Pure code
.text$mn:000023B8 ; Segment permissions: Read/Execute
.text$mn:000023B8 _text$mn        segment para public 'CODE' use32
.text$mn:000023B8                 assume cs:_text$mn
.text$mn:000023B8                 ;org 23B8h
.text$mn:000023B8 ; COMDAT (pick any)
.text$mn:000023B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023B8
.text$mn:000023B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B8
.text$mn:000023B8 ; Attributes: bp-based frame
.text$mn:000023B8
.text$mn:000023B8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000023B8                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000023B8 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000023B8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:000023B8
.text$mn:000023B8 var_8           = dword ptr -8
.text$mn:000023B8 var_1           = byte ptr -1
.text$mn:000023B8
.text$mn:000023B8                 push    ebp
.text$mn:000023B9                 mov     ebp, esp
.text$mn:000023BB                 sub     esp, 8
.text$mn:000023BE                 mov     [ebp+var_8], ecx
.text$mn:000023C1                 lea     ecx, [ebp+var_1]
.text$mn:000023C4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000023C9                 mov     ecx, [ebp+var_8] ; this
.text$mn:000023CC                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000023D1                 mov     eax, [ebp+var_8]
.text$mn:000023D4                 mov     ecx, [eax]
.text$mn:000023D6                 push    ecx
.text$mn:000023D7                 lea     ecx, [ebp+var_1]
.text$mn:000023DA                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000023DF                 push    1               ; int
.text$mn:000023E1                 mov     edx, [ebp+var_8]
.text$mn:000023E4                 mov     eax, [edx]
.text$mn:000023E6                 push    eax             ; void *
.text$mn:000023E7                 lea     ecx, [ebp+var_1]
.text$mn:000023EA                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000023EF                 mov     ecx, [ebp+var_8]
.text$mn:000023F2                 mov     dword ptr [ecx], 0
.text$mn:000023F8                 mov     esp, ebp
.text$mn:000023FA                 pop     ebp
.text$mn:000023FB                 retn
.text$mn:000023FB ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000023FB
.text$mn:000023FB _text$mn        ends
.text$mn:000023FB
.text$mn:000023FC ; ===========================================================================
.text$mn:000023FC
.text$mn:000023FC ; Segment type: Pure code
.text$mn:000023FC ; Segment permissions: Read/Execute
.text$mn:000023FC _text$mn        segment para public 'CODE' use32
.text$mn:000023FC                 assume cs:_text$mn
.text$mn:000023FC                 ;org 23FCh
.text$mn:000023FC ; COMDAT (pick any)
.text$mn:000023FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023FC
.text$mn:000023FC ; =============== S U B R O U T I N E =======================================
.text$mn:000023FC
.text$mn:000023FC ; Attributes: bp-based frame
.text$mn:000023FC
.text$mn:000023FC ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HMENU__ *, class std::allocator<struct HMENU__ *>>>::_Free_proxy(void)
.text$mn:000023FC                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAEXXZ
.text$mn:000023FC ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000023FC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>(void)+30p
.text$mn:000023FC
.text$mn:000023FC var_8           = dword ptr -8
.text$mn:000023FC var_1           = byte ptr -1
.text$mn:000023FC
.text$mn:000023FC                 push    ebp
.text$mn:000023FD                 mov     ebp, esp
.text$mn:000023FF                 sub     esp, 8
.text$mn:00002402                 mov     [ebp+var_8], ecx
.text$mn:00002405                 lea     ecx, [ebp+var_1]
.text$mn:00002408                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000240D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002410                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002415                 mov     eax, [ebp+var_8]
.text$mn:00002418                 mov     ecx, [eax]
.text$mn:0000241A                 push    ecx
.text$mn:0000241B                 lea     ecx, [ebp+var_1]
.text$mn:0000241E                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002423                 push    1               ; int
.text$mn:00002425                 mov     edx, [ebp+var_8]
.text$mn:00002428                 mov     eax, [edx]
.text$mn:0000242A                 push    eax             ; void *
.text$mn:0000242B                 lea     ecx, [ebp+var_1]
.text$mn:0000242E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00002433                 mov     ecx, [ebp+var_8]
.text$mn:00002436                 mov     dword ptr [ecx], 0
.text$mn:0000243C                 mov     esp, ebp
.text$mn:0000243E                 pop     ebp
.text$mn:0000243F                 retn
.text$mn:0000243F ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000243F
.text$mn:0000243F _text$mn        ends
.text$mn:0000243F
.text$mn:00002440 ; ===========================================================================
.text$mn:00002440
.text$mn:00002440 ; Segment type: Pure code
.text$mn:00002440 ; Segment permissions: Read/Execute
.text$mn:00002440 _text$mn        segment para public 'CODE' use32
.text$mn:00002440                 assume cs:_text$mn
.text$mn:00002440                 ;org 2440h
.text$mn:00002440 ; COMDAT (pick any)
.text$mn:00002440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002440
.text$mn:00002440 ; =============== S U B R O U T I N E =======================================
.text$mn:00002440
.text$mn:00002440 ; Attributes: bp-based frame
.text$mn:00002440
.text$mn:00002440 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00002440                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00002440 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00002440                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00002440                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00002440
.text$mn:00002440 var_4           = dword ptr -4
.text$mn:00002440 arg_0           = dword ptr  8
.text$mn:00002440
.text$mn:00002440                 push    ebp
.text$mn:00002441                 mov     ebp, esp
.text$mn:00002443                 push    ecx
.text$mn:00002444                 mov     [ebp+var_4], ecx
.text$mn:00002447                 mov     ecx, [ebp+arg_0]
.text$mn:0000244A                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000244F                 mov     eax, [ebp+arg_0]
.text$mn:00002452                 mov     esp, ebp
.text$mn:00002454                 pop     ebp
.text$mn:00002455                 retn    4
.text$mn:00002455 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00002455
.text$mn:00002455 _text$mn        ends
.text$mn:00002455
.text$mn:00002458 ; ===========================================================================
.text$mn:00002458
.text$mn:00002458 ; Segment type: Pure code
.text$mn:00002458 ; Segment permissions: Read/Execute
.text$mn:00002458 _text$mn        segment para public 'CODE' use32
.text$mn:00002458                 assume cs:_text$mn
.text$mn:00002458                 ;org 2458h
.text$mn:00002458 ; COMDAT (pick any)
.text$mn:00002458                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002458
.text$mn:00002458 ; =============== S U B R O U T I N E =======================================
.text$mn:00002458
.text$mn:00002458 ; Attributes: bp-based frame
.text$mn:00002458
.text$mn:00002458 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00002458                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00002458 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00002458                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+18p
.text$mn:00002458                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+25p ...
.text$mn:00002458
.text$mn:00002458 var_4           = dword ptr -4
.text$mn:00002458 arg_0           = dword ptr  8
.text$mn:00002458
.text$mn:00002458                 push    ebp
.text$mn:00002459                 mov     ebp, esp
.text$mn:0000245B                 push    ecx
.text$mn:0000245C                 mov     [ebp+var_4], ecx
.text$mn:0000245F                 mov     ecx, [ebp+arg_0]
.text$mn:00002462                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00002467                 mov     eax, [ebp+arg_0]
.text$mn:0000246A                 mov     esp, ebp
.text$mn:0000246C                 pop     ebp
.text$mn:0000246D                 retn    4
.text$mn:0000246D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:0000246D
.text$mn:0000246D _text$mn        ends
.text$mn:0000246D
.text$mn:00002470 ; ===========================================================================
.text$mn:00002470
.text$mn:00002470 ; Segment type: Pure code
.text$mn:00002470 ; Segment permissions: Read/Execute
.text$mn:00002470 _text$mn        segment para public 'CODE' use32
.text$mn:00002470                 assume cs:_text$mn
.text$mn:00002470                 ;org 2470h
.text$mn:00002470 ; COMDAT (pick any)
.text$mn:00002470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002470
.text$mn:00002470 ; =============== S U B R O U T I N E =======================================
.text$mn:00002470
.text$mn:00002470 ; Attributes: bp-based frame
.text$mn:00002470
.text$mn:00002470 ; public: struct std::_Wrap_alloc<class std::allocator<struct HMENU__ *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HMENU__ *, class std::allocator<struct HMENU__ *>>>::_Getal(void)const
.text$mn:00002470                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ
.text$mn:00002470 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ proc near
.text$mn:00002470                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Umove<HMENU__ * *>(HMENU__ * *,HMENU__ * *,HMENU__ * *)+10p
.text$mn:00002470                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Destroy(HMENU__ * *,HMENU__ * *)+10p ...
.text$mn:00002470
.text$mn:00002470 var_4           = dword ptr -4
.text$mn:00002470 arg_0           = dword ptr  8
.text$mn:00002470
.text$mn:00002470                 push    ebp
.text$mn:00002471                 mov     ebp, esp
.text$mn:00002473                 push    ecx
.text$mn:00002474                 mov     [ebp+var_4], ecx
.text$mn:00002477                 mov     ecx, [ebp+arg_0]
.text$mn:0000247A                 call    ??0?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::_Wrap_alloc<std::allocator<HMENU__ *>>(void)
.text$mn:0000247F                 mov     eax, [ebp+arg_0]
.text$mn:00002482                 mov     esp, ebp
.text$mn:00002484                 pop     ebp
.text$mn:00002485                 retn    4
.text$mn:00002485 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ endp
.text$mn:00002485
.text$mn:00002485 _text$mn        ends
.text$mn:00002485
.text$mn:00002488 ; ===========================================================================
.text$mn:00002488
.text$mn:00002488 ; Segment type: Pure code
.text$mn:00002488 ; Segment permissions: Read/Execute
.text$mn:00002488 _text$mn        segment para public 'CODE' use32
.text$mn:00002488                 assume cs:_text$mn
.text$mn:00002488                 ;org 2488h
.text$mn:00002488 ; COMDAT (pick any)
.text$mn:00002488                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002488
.text$mn:00002488 ; =============== S U B R O U T I N E =======================================
.text$mn:00002488
.text$mn:00002488 ; Attributes: bp-based frame
.text$mn:00002488
.text$mn:00002488 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00002488                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00002488 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00002488                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+3Cp
.text$mn:00002488
.text$mn:00002488 var_8           = dword ptr -8
.text$mn:00002488 var_4           = dword ptr -4
.text$mn:00002488
.text$mn:00002488                 push    ebp
.text$mn:00002489                 mov     ebp, esp
.text$mn:0000248B                 sub     esp, 8
.text$mn:0000248E                 mov     [ebp+var_4], ecx
.text$mn:00002491                 mov     eax, [ebp+var_4]
.text$mn:00002494                 cmp     dword ptr [eax], 0
.text$mn:00002497                 jnz     short loc_24A2
.text$mn:00002499                 mov     [ebp+var_8], 0
.text$mn:000024A0                 jmp     short loc_24AD
.text$mn:000024A2 ; ---------------------------------------------------------------------------
.text$mn:000024A2
.text$mn:000024A2 loc_24A2:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:000024A2                 mov     ecx, [ebp+var_4]
.text$mn:000024A5                 mov     edx, [ecx]
.text$mn:000024A7                 add     edx, 4
.text$mn:000024AA                 mov     [ebp+var_8], edx
.text$mn:000024AD
.text$mn:000024AD loc_24AD:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:000024AD                 mov     eax, [ebp+var_8]
.text$mn:000024B0                 mov     esp, ebp
.text$mn:000024B2                 pop     ebp
.text$mn:000024B3                 retn
.text$mn:000024B3 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:000024B3
.text$mn:000024B3 _text$mn        ends
.text$mn:000024B3
.text$mn:000024B4 ; ===========================================================================
.text$mn:000024B4
.text$mn:000024B4 ; Segment type: Pure code
.text$mn:000024B4 ; Segment permissions: Read/Execute
.text$mn:000024B4 _text$mn        segment para public 'CODE' use32
.text$mn:000024B4                 assume cs:_text$mn
.text$mn:000024B4                 ;org 24B4h
.text$mn:000024B4 ; COMDAT (pick any)
.text$mn:000024B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024B4
.text$mn:000024B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000024B4
.text$mn:000024B4 ; Attributes: bp-based frame
.text$mn:000024B4
.text$mn:000024B4 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:000024B4                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:000024B4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:000024B4                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+71p
.text$mn:000024B4                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+8Ap
.text$mn:000024B4
.text$mn:000024B4 var_4           = dword ptr -4
.text$mn:000024B4
.text$mn:000024B4                 push    ebp
.text$mn:000024B5                 mov     ebp, esp
.text$mn:000024B7                 push    ecx
.text$mn:000024B8                 mov     [ebp+var_4], ecx
.text$mn:000024BB                 mov     eax, [ebp+var_4]
.text$mn:000024BE                 add     eax, 4
.text$mn:000024C1                 mov     esp, ebp
.text$mn:000024C3                 pop     ebp
.text$mn:000024C4                 retn
.text$mn:000024C4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:000024C4
.text$mn:000024C4 ; ---------------------------------------------------------------------------
.text$mn:000024C5                 align 4
.text$mn:000024C5 _text$mn        ends
.text$mn:000024C5
.text$mn:000024C8 ; ===========================================================================
.text$mn:000024C8
.text$mn:000024C8 ; Segment type: Pure code
.text$mn:000024C8 ; Segment permissions: Read/Execute
.text$mn:000024C8 _text$mn        segment para public 'CODE' use32
.text$mn:000024C8                 assume cs:_text$mn
.text$mn:000024C8                 ;org 24C8h
.text$mn:000024C8 ; COMDAT (pick any)
.text$mn:000024C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024C8
.text$mn:000024C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024C8
.text$mn:000024C8 ; Attributes: bp-based frame
.text$mn:000024C8
.text$mn:000024C8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000024C8                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000024C8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000024C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000024C8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000024C8
.text$mn:000024C8 var_C           = dword ptr -0Ch
.text$mn:000024C8 Size            = dword ptr -8
.text$mn:000024C8 var_4           = dword ptr -4
.text$mn:000024C8 arg_0           = dword ptr  8
.text$mn:000024C8 arg_4           = byte ptr  0Ch
.text$mn:000024C8
.text$mn:000024C8                 push    ebp
.text$mn:000024C9                 mov     ebp, esp
.text$mn:000024CB                 sub     esp, 0Ch
.text$mn:000024CE                 mov     [ebp+var_4], ecx
.text$mn:000024D1                 mov     ecx, [ebp+var_4]
.text$mn:000024D4                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000024D9                 cmp     eax, [ebp+arg_0]
.text$mn:000024DC                 jnb     short loc_24E6
.text$mn:000024DE                 mov     ecx, [ebp+var_4]
.text$mn:000024E1                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000024E6
.text$mn:000024E6 loc_24E6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000024E6                 mov     eax, [ebp+var_4]
.text$mn:000024E9                 mov     ecx, [eax+18h]
.text$mn:000024EC                 cmp     ecx, [ebp+arg_0]
.text$mn:000024EF                 jnb     short loc_2506
.text$mn:000024F1                 mov     edx, [ebp+var_4]
.text$mn:000024F4                 mov     eax, [edx+14h]
.text$mn:000024F7                 push    eax
.text$mn:000024F8                 mov     ecx, [ebp+arg_0]
.text$mn:000024FB                 push    ecx
.text$mn:000024FC                 mov     ecx, [ebp+var_4]
.text$mn:000024FF                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00002504                 jmp     short loc_2550
.text$mn:00002506 ; ---------------------------------------------------------------------------
.text$mn:00002506
.text$mn:00002506 loc_2506:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00002506                 movzx   edx, [ebp+arg_4]
.text$mn:0000250A                 test    edx, edx
.text$mn:0000250C                 jz      short loc_2540
.text$mn:0000250E                 cmp     [ebp+arg_0], 10h
.text$mn:00002512                 jnb     short loc_2540
.text$mn:00002514                 mov     eax, [ebp+var_4]
.text$mn:00002517                 mov     ecx, [ebp+arg_0]
.text$mn:0000251A                 cmp     ecx, [eax+14h]
.text$mn:0000251D                 jnb     short loc_2527
.text$mn:0000251F                 mov     edx, [ebp+arg_0]
.text$mn:00002522                 mov     [ebp+Size], edx
.text$mn:00002525                 jmp     short loc_2530
.text$mn:00002527 ; ---------------------------------------------------------------------------
.text$mn:00002527
.text$mn:00002527 loc_2527:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00002527                 mov     eax, [ebp+var_4]
.text$mn:0000252A                 mov     ecx, [eax+14h]
.text$mn:0000252D                 mov     [ebp+Size], ecx
.text$mn:00002530
.text$mn:00002530 loc_2530:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00002530                 mov     edx, [ebp+Size]
.text$mn:00002533                 push    edx             ; Size
.text$mn:00002534                 push    1               ; char
.text$mn:00002536                 mov     ecx, [ebp+var_4]
.text$mn:00002539                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000253E                 jmp     short loc_2550
.text$mn:00002540 ; ---------------------------------------------------------------------------
.text$mn:00002540
.text$mn:00002540 loc_2540:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00002540                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00002540                 cmp     [ebp+arg_0], 0
.text$mn:00002544                 jnz     short loc_2550
.text$mn:00002546                 push    0
.text$mn:00002548                 mov     ecx, [ebp+var_4]
.text$mn:0000254B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002550
.text$mn:00002550 loc_2550:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00002550                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00002550                 cmp     [ebp+arg_0], 0
.text$mn:00002554                 jbe     short loc_255F
.text$mn:00002556                 mov     [ebp+var_C], 1
.text$mn:0000255D                 jmp     short loc_2566
.text$mn:0000255F ; ---------------------------------------------------------------------------
.text$mn:0000255F
.text$mn:0000255F loc_255F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000255F                 mov     [ebp+var_C], 0
.text$mn:00002566
.text$mn:00002566 loc_2566:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00002566                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002569                 mov     esp, ebp
.text$mn:0000256B                 pop     ebp
.text$mn:0000256C                 retn    8
.text$mn:0000256C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:0000256C
.text$mn:0000256C ; ---------------------------------------------------------------------------
.text$mn:0000256F                 align 10h
.text$mn:0000256F _text$mn        ends
.text$mn:0000256F
.text$mn:00002570 ; ===========================================================================
.text$mn:00002570
.text$mn:00002570 ; Segment type: Pure code
.text$mn:00002570 ; Segment permissions: Read/Execute
.text$mn:00002570 _text$mn        segment para public 'CODE' use32
.text$mn:00002570                 assume cs:_text$mn
.text$mn:00002570                 ;org 2570h
.text$mn:00002570 ; COMDAT (pick any)
.text$mn:00002570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002570
.text$mn:00002570 ; =============== S U B R O U T I N E =======================================
.text$mn:00002570
.text$mn:00002570 ; Attributes: bp-based frame
.text$mn:00002570
.text$mn:00002570 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00002570                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00002570 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00002570                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00002570                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:00002570
.text$mn:00002570 var_C           = dword ptr -0Ch
.text$mn:00002570 var_8           = dword ptr -8
.text$mn:00002570 var_4           = dword ptr -4
.text$mn:00002570 arg_0           = dword ptr  8
.text$mn:00002570 arg_4           = byte ptr  0Ch
.text$mn:00002570
.text$mn:00002570                 push    ebp
.text$mn:00002571                 mov     ebp, esp
.text$mn:00002573                 sub     esp, 0Ch
.text$mn:00002576                 mov     [ebp+var_4], ecx
.text$mn:00002579                 mov     ecx, [ebp+var_4]
.text$mn:0000257C                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00002581                 cmp     eax, [ebp+arg_0]
.text$mn:00002584                 jnb     short loc_258E
.text$mn:00002586                 mov     ecx, [ebp+var_4]
.text$mn:00002589                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000258E
.text$mn:0000258E loc_258E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:0000258E                 mov     eax, [ebp+var_4]
.text$mn:00002591                 mov     ecx, [eax+18h]
.text$mn:00002594                 cmp     ecx, [ebp+arg_0]
.text$mn:00002597                 jnb     short loc_25AE
.text$mn:00002599                 mov     edx, [ebp+var_4]
.text$mn:0000259C                 mov     eax, [edx+14h]
.text$mn:0000259F                 push    eax
.text$mn:000025A0                 mov     ecx, [ebp+arg_0]
.text$mn:000025A3                 push    ecx
.text$mn:000025A4                 mov     ecx, [ebp+var_4]
.text$mn:000025A7                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:000025AC                 jmp     short loc_25F8
.text$mn:000025AE ; ---------------------------------------------------------------------------
.text$mn:000025AE
.text$mn:000025AE loc_25AE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:000025AE                 movzx   edx, [ebp+arg_4]
.text$mn:000025B2                 test    edx, edx
.text$mn:000025B4                 jz      short loc_25E8
.text$mn:000025B6                 cmp     [ebp+arg_0], 8
.text$mn:000025BA                 jnb     short loc_25E8
.text$mn:000025BC                 mov     eax, [ebp+var_4]
.text$mn:000025BF                 mov     ecx, [ebp+arg_0]
.text$mn:000025C2                 cmp     ecx, [eax+14h]
.text$mn:000025C5                 jnb     short loc_25CF
.text$mn:000025C7                 mov     edx, [ebp+arg_0]
.text$mn:000025CA                 mov     [ebp+var_8], edx
.text$mn:000025CD                 jmp     short loc_25D8
.text$mn:000025CF ; ---------------------------------------------------------------------------
.text$mn:000025CF
.text$mn:000025CF loc_25CF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:000025CF                 mov     eax, [ebp+var_4]
.text$mn:000025D2                 mov     ecx, [eax+14h]
.text$mn:000025D5                 mov     [ebp+var_8], ecx
.text$mn:000025D8
.text$mn:000025D8 loc_25D8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:000025D8                 mov     edx, [ebp+var_8]
.text$mn:000025DB                 push    edx
.text$mn:000025DC                 push    1
.text$mn:000025DE                 mov     ecx, [ebp+var_4]
.text$mn:000025E1                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000025E6                 jmp     short loc_25F8
.text$mn:000025E8 ; ---------------------------------------------------------------------------
.text$mn:000025E8
.text$mn:000025E8 loc_25E8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:000025E8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:000025E8                 cmp     [ebp+arg_0], 0
.text$mn:000025EC                 jnz     short loc_25F8
.text$mn:000025EE                 push    0
.text$mn:000025F0                 mov     ecx, [ebp+var_4]
.text$mn:000025F3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000025F8
.text$mn:000025F8 loc_25F8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:000025F8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:000025F8                 cmp     [ebp+arg_0], 0
.text$mn:000025FC                 jbe     short loc_2607
.text$mn:000025FE                 mov     [ebp+var_C], 1
.text$mn:00002605                 jmp     short loc_260E
.text$mn:00002607 ; ---------------------------------------------------------------------------
.text$mn:00002607
.text$mn:00002607 loc_2607:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00002607                 mov     [ebp+var_C], 0
.text$mn:0000260E
.text$mn:0000260E loc_260E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:0000260E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002611                 mov     esp, ebp
.text$mn:00002613                 pop     ebp
.text$mn:00002614                 retn    8
.text$mn:00002614 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00002614
.text$mn:00002614 ; ---------------------------------------------------------------------------
.text$mn:00002617                 align 4
.text$mn:00002617 _text$mn        ends
.text$mn:00002617
.text$mn:00002618 ; ===========================================================================
.text$mn:00002618
.text$mn:00002618 ; Segment type: Pure code
.text$mn:00002618 ; Segment permissions: Read/Execute
.text$mn:00002618 _text$mn        segment para public 'CODE' use32
.text$mn:00002618                 assume cs:_text$mn
.text$mn:00002618                 ;org 2618h
.text$mn:00002618 ; COMDAT (pick any)
.text$mn:00002618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002618
.text$mn:00002618 ; =============== S U B R O U T I N E =======================================
.text$mn:00002618
.text$mn:00002618 ; Attributes: bp-based frame
.text$mn:00002618
.text$mn:00002618 ; protected: unsigned int __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Grow_to(unsigned int)const
.text$mn:00002618                 public ?_Grow_to@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEII@Z
.text$mn:00002618 ?_Grow_to@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEII@Z proc near
.text$mn:00002618                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)+45p
.text$mn:00002618
.text$mn:00002618 var_C           = dword ptr -0Ch
.text$mn:00002618 var_8           = dword ptr -8
.text$mn:00002618 var_4           = dword ptr -4
.text$mn:00002618 arg_0           = dword ptr  8
.text$mn:00002618
.text$mn:00002618                 push    ebp
.text$mn:00002619                 mov     ebp, esp
.text$mn:0000261B                 sub     esp, 0Ch
.text$mn:0000261E                 mov     [ebp+var_8], ecx
.text$mn:00002621                 mov     ecx, [ebp+var_8]
.text$mn:00002624                 call    ?capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::capacity(void)
.text$mn:00002629                 mov     [ebp+var_4], eax
.text$mn:0000262C                 mov     ecx, [ebp+var_8]
.text$mn:0000262F                 call    ?max_size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::max_size(void)
.text$mn:00002634                 mov     ecx, [ebp+var_4]
.text$mn:00002637                 shr     ecx, 1
.text$mn:00002639                 sub     eax, ecx
.text$mn:0000263B                 cmp     eax, [ebp+var_4]
.text$mn:0000263E                 jnb     short loc_2649
.text$mn:00002640                 mov     [ebp+var_C], 0
.text$mn:00002647                 jmp     short loc_2654
.text$mn:00002649 ; ---------------------------------------------------------------------------
.text$mn:00002649
.text$mn:00002649 loc_2649:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Grow_to(uint)+26j
.text$mn:00002649                 mov     edx, [ebp+var_4]
.text$mn:0000264C                 shr     edx, 1
.text$mn:0000264E                 add     edx, [ebp+var_4]
.text$mn:00002651                 mov     [ebp+var_C], edx
.text$mn:00002654
.text$mn:00002654 loc_2654:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Grow_to(uint)+2Fj
.text$mn:00002654                 mov     eax, [ebp+var_C]
.text$mn:00002657                 mov     [ebp+var_4], eax
.text$mn:0000265A                 mov     ecx, [ebp+var_4]
.text$mn:0000265D                 cmp     ecx, [ebp+arg_0]
.text$mn:00002660                 jnb     short loc_2668
.text$mn:00002662                 mov     edx, [ebp+arg_0]
.text$mn:00002665                 mov     [ebp+var_4], edx
.text$mn:00002668
.text$mn:00002668 loc_2668:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Grow_to(uint)+48j
.text$mn:00002668                 mov     eax, [ebp+var_4]
.text$mn:0000266B                 mov     esp, ebp
.text$mn:0000266D                 pop     ebp
.text$mn:0000266E                 retn    4
.text$mn:0000266E ?_Grow_to@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEII@Z endp
.text$mn:0000266E
.text$mn:0000266E ; ---------------------------------------------------------------------------
.text$mn:00002671                 align 4
.text$mn:00002671 _text$mn        ends
.text$mn:00002671
.text$mn:00002674 ; ===========================================================================
.text$mn:00002674
.text$mn:00002674 ; Segment type: Pure code
.text$mn:00002674 ; Segment permissions: Read/Execute
.text$mn:00002674 _text$mn        segment para public 'CODE' use32
.text$mn:00002674                 assume cs:_text$mn
.text$mn:00002674                 ;org 2674h
.text$mn:00002674 ; COMDAT (pick any)
.text$mn:00002674                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002674
.text$mn:00002674 ; =============== S U B R O U T I N E =======================================
.text$mn:00002674
.text$mn:00002674 ; Attributes: bp-based frame
.text$mn:00002674
.text$mn:00002674 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00002674                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00002674 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00002674                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00002674
.text$mn:00002674 var_4           = dword ptr -4
.text$mn:00002674 arg_0           = dword ptr  8
.text$mn:00002674
.text$mn:00002674                 push    ebp
.text$mn:00002675                 mov     ebp, esp
.text$mn:00002677                 push    ecx
.text$mn:00002678                 mov     [ebp+var_4], ecx
.text$mn:0000267B                 cmp     [ebp+arg_0], 0
.text$mn:0000267F                 jz      short loc_26A1
.text$mn:00002681                 mov     ecx, [ebp+var_4]
.text$mn:00002684                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002689                 cmp     [ebp+arg_0], eax
.text$mn:0000268C                 jb      short loc_26A1
.text$mn:0000268E                 mov     ecx, [ebp+var_4]
.text$mn:00002691                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002696                 mov     ecx, [ebp+var_4]
.text$mn:00002699                 add     eax, [ecx+14h]
.text$mn:0000269C                 cmp     eax, [ebp+arg_0]
.text$mn:0000269F                 ja      short loc_26A7
.text$mn:000026A1
.text$mn:000026A1 loc_26A1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000026A1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000026A1                 xor     al, al
.text$mn:000026A3                 jmp     short loc_26A9
.text$mn:000026A5 ; ---------------------------------------------------------------------------
.text$mn:000026A5                 jmp     short loc_26A9
.text$mn:000026A7 ; ---------------------------------------------------------------------------
.text$mn:000026A7
.text$mn:000026A7 loc_26A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000026A7                 mov     al, 1
.text$mn:000026A9
.text$mn:000026A9 loc_26A9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000026A9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000026A9                 mov     esp, ebp
.text$mn:000026AB                 pop     ebp
.text$mn:000026AC                 retn    4
.text$mn:000026AC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000026AC
.text$mn:000026AC ; ---------------------------------------------------------------------------
.text$mn:000026AF                 align 10h
.text$mn:000026AF _text$mn        ends
.text$mn:000026AF
.text$mn:000026B0 ; ===========================================================================
.text$mn:000026B0
.text$mn:000026B0 ; Segment type: Pure code
.text$mn:000026B0 ; Segment permissions: Read/Execute
.text$mn:000026B0 _text$mn        segment para public 'CODE' use32
.text$mn:000026B0                 assume cs:_text$mn
.text$mn:000026B0                 ;org 26B0h
.text$mn:000026B0 ; COMDAT (pick any)
.text$mn:000026B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026B0
.text$mn:000026B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026B0
.text$mn:000026B0 ; Attributes: bp-based frame
.text$mn:000026B0
.text$mn:000026B0 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000026B0                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:000026B0 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:000026B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:000026B0
.text$mn:000026B0 var_4           = dword ptr -4
.text$mn:000026B0 arg_0           = dword ptr  8
.text$mn:000026B0
.text$mn:000026B0                 push    ebp
.text$mn:000026B1                 mov     ebp, esp
.text$mn:000026B3                 push    ecx
.text$mn:000026B4                 mov     [ebp+var_4], ecx
.text$mn:000026B7                 cmp     [ebp+arg_0], 0
.text$mn:000026BB                 jz      short loc_26E0
.text$mn:000026BD                 mov     ecx, [ebp+var_4]
.text$mn:000026C0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000026C5                 cmp     [ebp+arg_0], eax
.text$mn:000026C8                 jb      short loc_26E0
.text$mn:000026CA                 mov     ecx, [ebp+var_4]
.text$mn:000026CD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000026D2                 mov     ecx, [ebp+var_4]
.text$mn:000026D5                 mov     edx, [ecx+14h]
.text$mn:000026D8                 lea     eax, [eax+edx*2]
.text$mn:000026DB                 cmp     eax, [ebp+arg_0]
.text$mn:000026DE                 ja      short loc_26E6
.text$mn:000026E0
.text$mn:000026E0 loc_26E0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:000026E0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:000026E0                 xor     al, al
.text$mn:000026E2                 jmp     short loc_26E8
.text$mn:000026E4 ; ---------------------------------------------------------------------------
.text$mn:000026E4                 jmp     short loc_26E8
.text$mn:000026E6 ; ---------------------------------------------------------------------------
.text$mn:000026E6
.text$mn:000026E6 loc_26E6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:000026E6                 mov     al, 1
.text$mn:000026E8
.text$mn:000026E8 loc_26E8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:000026E8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:000026E8                 mov     esp, ebp
.text$mn:000026EA                 pop     ebp
.text$mn:000026EB                 retn    4
.text$mn:000026EB ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:000026EB
.text$mn:000026EB ; ---------------------------------------------------------------------------
.text$mn:000026EE                 align 10h
.text$mn:000026EE _text$mn        ends
.text$mn:000026EE
.text$mn:000026F0 ; ===========================================================================
.text$mn:000026F0
.text$mn:000026F0 ; Segment type: Pure code
.text$mn:000026F0 ; Segment permissions: Read/Execute
.text$mn:000026F0 _text$mn        segment para public 'CODE' use32
.text$mn:000026F0                 assume cs:_text$mn
.text$mn:000026F0                 ;org 26F0h
.text$mn:000026F0 ; COMDAT (pick any)
.text$mn:000026F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026F0
.text$mn:000026F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F0
.text$mn:000026F0 ; Attributes: bp-based frame
.text$mn:000026F0
.text$mn:000026F0 ; protected: bool __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Inside(struct HMENU__ * const *)const
.text$mn:000026F0                 public ?_Inside@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBE_NPBQAUHMENU__@@@Z
.text$mn:000026F0 ?_Inside@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBE_NPBQAUHMENU__@@@Z proc near
.text$mn:000026F0                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+19p
.text$mn:000026F0
.text$mn:000026F0 var_8           = dword ptr -8
.text$mn:000026F0 var_4           = dword ptr -4
.text$mn:000026F0 arg_0           = dword ptr  8
.text$mn:000026F0
.text$mn:000026F0                 push    ebp
.text$mn:000026F1                 mov     ebp, esp
.text$mn:000026F3                 sub     esp, 8
.text$mn:000026F6                 mov     [ebp+var_4], ecx
.text$mn:000026F9                 mov     eax, [ebp+var_4]
.text$mn:000026FC                 mov     ecx, [ebp+arg_0]
.text$mn:000026FF                 cmp     ecx, [eax+8]
.text$mn:00002702                 jnb     short loc_2718
.text$mn:00002704                 mov     edx, [ebp+var_4]
.text$mn:00002707                 mov     eax, [edx+4]
.text$mn:0000270A                 cmp     eax, [ebp+arg_0]
.text$mn:0000270D                 ja      short loc_2718
.text$mn:0000270F                 mov     [ebp+var_8], 1
.text$mn:00002716                 jmp     short loc_271F
.text$mn:00002718 ; ---------------------------------------------------------------------------
.text$mn:00002718
.text$mn:00002718 loc_2718:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Inside(HMENU__ * const *)+12j
.text$mn:00002718                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Inside(HMENU__ * const *)+1Dj
.text$mn:00002718                 mov     [ebp+var_8], 0
.text$mn:0000271F
.text$mn:0000271F loc_271F:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Inside(HMENU__ * const *)+26j
.text$mn:0000271F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00002722                 mov     esp, ebp
.text$mn:00002724                 pop     ebp
.text$mn:00002725                 retn    4
.text$mn:00002725 ?_Inside@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBE_NPBQAUHMENU__@@@Z endp
.text$mn:00002725
.text$mn:00002725 _text$mn        ends
.text$mn:00002725
.text$mn:00002728 ; ===========================================================================
.text$mn:00002728
.text$mn:00002728 ; Segment type: Pure code
.text$mn:00002728 ; Segment permissions: Read/Execute
.text$mn:00002728 _text$mn        segment para public 'CODE' use32
.text$mn:00002728                 assume cs:_text$mn
.text$mn:00002728                 ;org 2728h
.text$mn:00002728 ; COMDAT (pick any)
.text$mn:00002728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002728
.text$mn:00002728 ; =============== S U B R O U T I N E =======================================
.text$mn:00002728
.text$mn:00002728 ; Attributes: bp-based frame
.text$mn:00002728
.text$mn:00002728 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002728                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00002728 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00002728                                         ; CODE XREF: $LN19+14p
.text$mn:00002728                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00002728
.text$mn:00002728 var_8           = dword ptr -8
.text$mn:00002728 var_4           = dword ptr -4
.text$mn:00002728
.text$mn:00002728                 push    ebp
.text$mn:00002729                 mov     ebp, esp
.text$mn:0000272B                 sub     esp, 8
.text$mn:0000272E                 mov     [ebp+var_4], ecx
.text$mn:00002731                 mov     eax, [ebp+var_4]
.text$mn:00002734                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002738                 jb      short loc_274E
.text$mn:0000273A                 mov     ecx, [ebp+var_4]
.text$mn:0000273D                 mov     edx, [ecx+4]
.text$mn:00002740                 push    edx
.text$mn:00002741                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002746                 add     esp, 4
.text$mn:00002749                 mov     [ebp+var_8], eax
.text$mn:0000274C                 jmp     short loc_2757
.text$mn:0000274E ; ---------------------------------------------------------------------------
.text$mn:0000274E
.text$mn:0000274E loc_274E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000274E                 mov     eax, [ebp+var_4]
.text$mn:00002751                 add     eax, 4
.text$mn:00002754                 mov     [ebp+var_8], eax
.text$mn:00002757
.text$mn:00002757 loc_2757:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002757                 mov     eax, [ebp+var_8]
.text$mn:0000275A                 mov     esp, ebp
.text$mn:0000275C                 pop     ebp
.text$mn:0000275D                 retn
.text$mn:0000275D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000275D
.text$mn:0000275D ; ---------------------------------------------------------------------------
.text$mn:0000275E                 align 10h
.text$mn:0000275E _text$mn        ends
.text$mn:0000275E
.text$mn:00002760 ; ===========================================================================
.text$mn:00002760
.text$mn:00002760 ; Segment type: Pure code
.text$mn:00002760 ; Segment permissions: Read/Execute
.text$mn:00002760 _text$mn        segment para public 'CODE' use32
.text$mn:00002760                 assume cs:_text$mn
.text$mn:00002760                 ;org 2760h
.text$mn:00002760 ; COMDAT (pick any)
.text$mn:00002760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002760
.text$mn:00002760 ; =============== S U B R O U T I N E =======================================
.text$mn:00002760
.text$mn:00002760 ; Attributes: bp-based frame
.text$mn:00002760
.text$mn:00002760 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00002760                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00002760 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00002760                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00002760
.text$mn:00002760 var_8           = dword ptr -8
.text$mn:00002760 var_4           = dword ptr -4
.text$mn:00002760
.text$mn:00002760                 push    ebp
.text$mn:00002761                 mov     ebp, esp
.text$mn:00002763                 sub     esp, 8
.text$mn:00002766                 mov     [ebp+var_4], ecx
.text$mn:00002769                 mov     eax, [ebp+var_4]
.text$mn:0000276C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002770                 jb      short loc_2786
.text$mn:00002772                 mov     ecx, [ebp+var_4]
.text$mn:00002775                 mov     edx, [ecx+4]
.text$mn:00002778                 push    edx
.text$mn:00002779                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000277E                 add     esp, 4
.text$mn:00002781                 mov     [ebp+var_8], eax
.text$mn:00002784                 jmp     short loc_278F
.text$mn:00002786 ; ---------------------------------------------------------------------------
.text$mn:00002786
.text$mn:00002786 loc_2786:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002786                 mov     eax, [ebp+var_4]
.text$mn:00002789                 add     eax, 4
.text$mn:0000278C                 mov     [ebp+var_8], eax
.text$mn:0000278F
.text$mn:0000278F loc_278F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000278F                 mov     eax, [ebp+var_8]
.text$mn:00002792                 mov     esp, ebp
.text$mn:00002794                 pop     ebp
.text$mn:00002795                 retn
.text$mn:00002795 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00002795
.text$mn:00002795 ; ---------------------------------------------------------------------------
.text$mn:00002796                 align 4
.text$mn:00002796 _text$mn        ends
.text$mn:00002796
.text$mn:00002798 ; ===========================================================================
.text$mn:00002798
.text$mn:00002798 ; Segment type: Pure code
.text$mn:00002798 ; Segment permissions: Read/Execute
.text$mn:00002798 _text$mn        segment para public 'CODE' use32
.text$mn:00002798                 assume cs:_text$mn
.text$mn:00002798                 ;org 2798h
.text$mn:00002798 ; COMDAT (pick any)
.text$mn:00002798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002798
.text$mn:00002798 ; =============== S U B R O U T I N E =======================================
.text$mn:00002798
.text$mn:00002798 ; Attributes: bp-based frame
.text$mn:00002798
.text$mn:00002798 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002798                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00002798 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00002798                                         ; CODE XREF: $LN19_0+14p
.text$mn:00002798                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00002798
.text$mn:00002798 var_8           = dword ptr -8
.text$mn:00002798 var_4           = dword ptr -4
.text$mn:00002798
.text$mn:00002798                 push    ebp
.text$mn:00002799                 mov     ebp, esp
.text$mn:0000279B                 sub     esp, 8
.text$mn:0000279E                 mov     [ebp+var_4], ecx
.text$mn:000027A1                 mov     eax, [ebp+var_4]
.text$mn:000027A4                 cmp     dword ptr [eax+18h], 8
.text$mn:000027A8                 jb      short loc_27BE
.text$mn:000027AA                 mov     ecx, [ebp+var_4]
.text$mn:000027AD                 mov     edx, [ecx+4]
.text$mn:000027B0                 push    edx
.text$mn:000027B1                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000027B6                 add     esp, 4
.text$mn:000027B9                 mov     [ebp+var_8], eax
.text$mn:000027BC                 jmp     short loc_27C7
.text$mn:000027BE ; ---------------------------------------------------------------------------
.text$mn:000027BE
.text$mn:000027BE loc_27BE:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000027BE                 mov     eax, [ebp+var_4]
.text$mn:000027C1                 add     eax, 4
.text$mn:000027C4                 mov     [ebp+var_8], eax
.text$mn:000027C7
.text$mn:000027C7 loc_27C7:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000027C7                 mov     eax, [ebp+var_8]
.text$mn:000027CA                 mov     esp, ebp
.text$mn:000027CC                 pop     ebp
.text$mn:000027CD                 retn
.text$mn:000027CD ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:000027CD
.text$mn:000027CD ; ---------------------------------------------------------------------------
.text$mn:000027CE                 align 10h
.text$mn:000027CE _text$mn        ends
.text$mn:000027CE
.text$mn:000027D0 ; ===========================================================================
.text$mn:000027D0
.text$mn:000027D0 ; Segment type: Pure code
.text$mn:000027D0 ; Segment permissions: Read/Execute
.text$mn:000027D0 _text$mn        segment para public 'CODE' use32
.text$mn:000027D0                 assume cs:_text$mn
.text$mn:000027D0                 ;org 27D0h
.text$mn:000027D0 ; COMDAT (pick any)
.text$mn:000027D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027D0
.text$mn:000027D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027D0
.text$mn:000027D0 ; Attributes: bp-based frame
.text$mn:000027D0
.text$mn:000027D0 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:000027D0                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:000027D0 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:000027D0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:000027D0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap ...
.text$mn:000027D0
.text$mn:000027D0 var_8           = dword ptr -8
.text$mn:000027D0 var_4           = dword ptr -4
.text$mn:000027D0
.text$mn:000027D0                 push    ebp
.text$mn:000027D1                 mov     ebp, esp
.text$mn:000027D3                 sub     esp, 8
.text$mn:000027D6                 mov     [ebp+var_4], ecx
.text$mn:000027D9                 mov     eax, [ebp+var_4]
.text$mn:000027DC                 cmp     dword ptr [eax+18h], 8
.text$mn:000027E0                 jb      short loc_27F6
.text$mn:000027E2                 mov     ecx, [ebp+var_4]
.text$mn:000027E5                 mov     edx, [ecx+4]
.text$mn:000027E8                 push    edx
.text$mn:000027E9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000027EE                 add     esp, 4
.text$mn:000027F1                 mov     [ebp+var_8], eax
.text$mn:000027F4                 jmp     short loc_27FF
.text$mn:000027F6 ; ---------------------------------------------------------------------------
.text$mn:000027F6
.text$mn:000027F6 loc_27F6:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000027F6                 mov     eax, [ebp+var_4]
.text$mn:000027F9                 add     eax, 4
.text$mn:000027FC                 mov     [ebp+var_8], eax
.text$mn:000027FF
.text$mn:000027FF loc_27FF:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000027FF                 mov     eax, [ebp+var_8]
.text$mn:00002802                 mov     esp, ebp
.text$mn:00002804                 pop     ebp
.text$mn:00002805                 retn
.text$mn:00002805 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00002805
.text$mn:00002805 ; ---------------------------------------------------------------------------
.text$mn:00002806                 align 4
.text$mn:00002806 _text$mn        ends
.text$mn:00002806
.text$mn:00002808 ; ===========================================================================
.text$mn:00002808
.text$mn:00002808 ; Segment type: Pure code
.text$mn:00002808 ; Segment permissions: Read/Execute
.text$mn:00002808 _text$mn        segment para public 'CODE' use32
.text$mn:00002808                 assume cs:_text$mn
.text$mn:00002808                 ;org 2808h
.text$mn:00002808 ; COMDAT (pick any)
.text$mn:00002808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002808
.text$mn:00002808 ; =============== S U B R O U T I N E =======================================
.text$mn:00002808
.text$mn:00002808 ; Attributes: bp-based frame
.text$mn:00002808
.text$mn:00002808 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00002808                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002808 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00002808                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00002808                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00002808
.text$mn:00002808 var_18          = byte ptr -18h
.text$mn:00002808 var_14          = dword ptr -14h
.text$mn:00002808 var_10          = dword ptr -10h
.text$mn:00002808 var_C           = dword ptr -0Ch
.text$mn:00002808 var_4           = dword ptr -4
.text$mn:00002808
.text$mn:00002808                 push    ebp
.text$mn:00002809                 mov     ebp, esp
.text$mn:0000280B                 push    0FFFFFFFFh
.text$mn:0000280D                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002812                 mov     eax, large fs:0
.text$mn:00002818                 push    eax
.text$mn:00002819                 sub     esp, 0Ch
.text$mn:0000281C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002821                 xor     eax, ebp
.text$mn:00002823                 push    eax
.text$mn:00002824                 lea     eax, [ebp+var_C]
.text$mn:00002827                 mov     large fs:0, eax
.text$mn:0000282D                 mov     [ebp+var_14], ecx
.text$mn:00002830                 mov     eax, [ebp+var_14]
.text$mn:00002833                 cmp     dword ptr [eax], 0
.text$mn:00002836                 jz      short loc_2893
.text$mn:00002838                 push    3               ; int
.text$mn:0000283A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000283D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00002842                 mov     [ebp+var_4], 0
.text$mn:00002849                 mov     ecx, [ebp+var_14]
.text$mn:0000284C                 mov     edx, [ecx]
.text$mn:0000284E                 add     edx, 4
.text$mn:00002851                 mov     [ebp+var_10], edx
.text$mn:00002854                 jmp     short loc_2863
.text$mn:00002856 ; ---------------------------------------------------------------------------
.text$mn:00002856
.text$mn:00002856 loc_2856:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00002856                 mov     eax, [ebp+var_10]
.text$mn:00002859                 mov     ecx, [eax]
.text$mn:0000285B                 mov     edx, [ebp+var_10]
.text$mn:0000285E                 mov     eax, [ecx+4]
.text$mn:00002861                 mov     [edx], eax
.text$mn:00002863
.text$mn:00002863 loc_2863:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00002863                 mov     ecx, [ebp+var_10]
.text$mn:00002866                 cmp     dword ptr [ecx], 0
.text$mn:00002869                 jz      short loc_2878
.text$mn:0000286B                 mov     edx, [ebp+var_10]
.text$mn:0000286E                 mov     eax, [edx]
.text$mn:00002870                 mov     dword ptr [eax], 0
.text$mn:00002876                 jmp     short loc_2856
.text$mn:00002878 ; ---------------------------------------------------------------------------
.text$mn:00002878
.text$mn:00002878 loc_2878:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00002878                 mov     ecx, [ebp+var_14]
.text$mn:0000287B                 mov     edx, [ecx]
.text$mn:0000287D                 mov     dword ptr [edx+4], 0
.text$mn:00002884                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000288B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000288E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00002893
.text$mn:00002893 loc_2893:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00002893                 mov     ecx, [ebp+var_C]
.text$mn:00002896                 mov     large fs:0, ecx
.text$mn:0000289D                 pop     ecx
.text$mn:0000289E                 mov     esp, ebp
.text$mn:000028A0                 pop     ebp
.text$mn:000028A1                 retn
.text$mn:000028A1 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000028A1
.text$mn:000028A1 ; ---------------------------------------------------------------------------
.text$mn:000028A2                 align 4
.text$mn:000028A2 _text$mn        ends
.text$mn:000028A2
.text$x:000028A4 ; ===========================================================================
.text$x:000028A4
.text$x:000028A4 ; Segment type: Pure code
.text$x:000028A4 ; Segment permissions: Read/Execute
.text$x:000028A4 _text$x         segment para public 'CODE' use32
.text$x:000028A4                 assume cs:_text$x
.text$x:000028A4                 ;org 28A4h
.text$x:000028A4 ; COMDAT (pick associative to section at 2808)
.text$x:000028A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028A4
.text$x:000028A4 ; =============== S U B R O U T I N E =======================================
.text$x:000028A4
.text$x:000028A4
.text$x:000028A4 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000028A4                                         ; DATA XREF: .xdata$x:00003F14o
.text$x:000028A4                 lea     ecx, [ebp-18h]  ; this
.text$x:000028A7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000028A7 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000028A7
.text$x:000028AC
.text$x:000028AC ; =============== S U B R O U T I N E =======================================
.text$x:000028AC
.text$x:000028AC
.text$x:000028AC __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000028AC                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000028AC
.text$x:000028AC arg_4           = dword ptr  8
.text$x:000028AC
.text$x:000028AC                 mov     edx, [esp+arg_4]
.text$x:000028B0                 lea     eax, [edx+0Ch]
.text$x:000028B3                 mov     ecx, [edx-10h]
.text$x:000028B6                 xor     ecx, eax
.text$x:000028B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028BD                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000028C2                 jmp     ___CxxFrameHandler3
.text$x:000028C2 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000028C2
.text$x:000028C2 ; ---------------------------------------------------------------------------
.text$x:000028C7                 align 4
.text$x:000028C7 _text$x         ends
.text$x:000028C7
.text$mn:000028C8 ; ===========================================================================
.text$mn:000028C8
.text$mn:000028C8 ; Segment type: Pure code
.text$mn:000028C8 ; Segment permissions: Read/Execute
.text$mn:000028C8 _text$mn        segment para public 'CODE' use32
.text$mn:000028C8                 assume cs:_text$mn
.text$mn:000028C8                 ;org 28C8h
.text$mn:000028C8 ; COMDAT (pick any)
.text$mn:000028C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028C8
.text$mn:000028C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028C8
.text$mn:000028C8 ; Attributes: bp-based frame
.text$mn:000028C8
.text$mn:000028C8 ; protected: void __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Orphan_range(struct HMENU__ * *, struct HMENU__ * *)const
.text$mn:000028C8                 public ?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z
.text$mn:000028C8 ?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z proc near
.text$mn:000028C8                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+66p
.text$mn:000028C8                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+CCp
.text$mn:000028C8
.text$mn:000028C8 var_18          = byte ptr -18h
.text$mn:000028C8 var_14          = dword ptr -14h
.text$mn:000028C8 var_10          = dword ptr -10h
.text$mn:000028C8 var_C           = dword ptr -0Ch
.text$mn:000028C8 var_4           = dword ptr -4
.text$mn:000028C8 arg_0           = dword ptr  8
.text$mn:000028C8 arg_4           = dword ptr  0Ch
.text$mn:000028C8
.text$mn:000028C8                 push    ebp
.text$mn:000028C9                 mov     ebp, esp
.text$mn:000028CB                 push    0FFFFFFFFh
.text$mn:000028CD                 push    offset __ehhandler$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z
.text$mn:000028D2                 mov     eax, large fs:0
.text$mn:000028D8                 push    eax
.text$mn:000028D9                 sub     esp, 0Ch
.text$mn:000028DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028E1                 xor     eax, ebp
.text$mn:000028E3                 push    eax
.text$mn:000028E4                 lea     eax, [ebp+var_C]
.text$mn:000028E7                 mov     large fs:0, eax
.text$mn:000028ED                 mov     [ebp+var_14], ecx
.text$mn:000028F0                 push    3               ; int
.text$mn:000028F2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000028F5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000028FA                 mov     [ebp+var_4], 0
.text$mn:00002901                 mov     ecx, [ebp+var_14] ; this
.text$mn:00002904                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00002909                 mov     [ebp+var_10], eax
.text$mn:0000290C                 cmp     [ebp+var_10], 0
.text$mn:00002910                 jz      short loc_2960
.text$mn:00002912
.text$mn:00002912 loc_2912:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *):loc_295Ej
.text$mn:00002912                 mov     eax, [ebp+var_10]
.text$mn:00002915                 cmp     dword ptr [eax], 0
.text$mn:00002918                 jz      short loc_2960
.text$mn:0000291A                 mov     ecx, [ebp+var_10]
.text$mn:0000291D                 mov     edx, [ecx]
.text$mn:0000291F                 mov     eax, [edx+8]
.text$mn:00002922                 cmp     eax, [ebp+arg_0]
.text$mn:00002925                 jb      short loc_2934
.text$mn:00002927                 mov     ecx, [ebp+var_10]
.text$mn:0000292A                 mov     edx, [ecx]
.text$mn:0000292C                 mov     eax, [ebp+arg_4]
.text$mn:0000292F                 cmp     eax, [edx+8]
.text$mn:00002932                 jnb     short loc_2943
.text$mn:00002934
.text$mn:00002934 loc_2934:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+5Dj
.text$mn:00002934                 mov     ecx, [ebp+var_10]
.text$mn:00002937                 mov     ecx, [ecx]      ; this
.text$mn:00002939                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000293E                 mov     [ebp+var_10], eax
.text$mn:00002941                 jmp     short loc_295E
.text$mn:00002943 ; ---------------------------------------------------------------------------
.text$mn:00002943
.text$mn:00002943 loc_2943:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+6Aj
.text$mn:00002943                 mov     edx, [ebp+var_10]
.text$mn:00002946                 mov     ecx, [edx]      ; this
.text$mn:00002948                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000294D                 mov     eax, [ebp+var_10]
.text$mn:00002950                 mov     ecx, [eax]      ; this
.text$mn:00002952                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00002957                 mov     ecx, [ebp+var_10]
.text$mn:0000295A                 mov     edx, [eax]
.text$mn:0000295C                 mov     [ecx], edx
.text$mn:0000295E
.text$mn:0000295E loc_295E:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+79j
.text$mn:0000295E                 jmp     short loc_2912
.text$mn:00002960 ; ---------------------------------------------------------------------------
.text$mn:00002960
.text$mn:00002960 loc_2960:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+48j
.text$mn:00002960                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+50j
.text$mn:00002960                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002967                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000296A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000296F                 mov     ecx, [ebp+var_C]
.text$mn:00002972                 mov     large fs:0, ecx
.text$mn:00002979                 pop     ecx
.text$mn:0000297A                 mov     esp, ebp
.text$mn:0000297C                 pop     ebp
.text$mn:0000297D                 retn    8
.text$mn:0000297D ?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z endp
.text$mn:0000297D
.text$mn:0000297D _text$mn        ends
.text$mn:0000297D
.text$x:00002980 ; ===========================================================================
.text$x:00002980
.text$x:00002980 ; Segment type: Pure code
.text$x:00002980 ; Segment permissions: Read/Execute
.text$x:00002980 _text$x         segment para public 'CODE' use32
.text$x:00002980                 assume cs:_text$x
.text$x:00002980                 ;org 2980h
.text$x:00002980 ; COMDAT (pick associative to section at 28C8)
.text$x:00002980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002980
.text$x:00002980 ; =============== S U B R O U T I N E =======================================
.text$x:00002980
.text$x:00002980
.text$x:00002980 __unwindfunclet$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z$0 proc near
.text$x:00002980                                         ; DATA XREF: .xdata$x:00004588o
.text$x:00002980                 lea     ecx, [ebp-18h]  ; this
.text$x:00002983                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00002983 __unwindfunclet$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z$0 endp
.text$x:00002983
.text$x:00002988
.text$x:00002988 ; =============== S U B R O U T I N E =======================================
.text$x:00002988
.text$x:00002988
.text$x:00002988 __ehhandler$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z proc near
.text$x:00002988                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+5o
.text$x:00002988
.text$x:00002988 arg_4           = dword ptr  8
.text$x:00002988
.text$x:00002988                 mov     edx, [esp+arg_4]
.text$x:0000298C                 lea     eax, [edx+0Ch]
.text$x:0000298F                 mov     ecx, [edx-10h]
.text$x:00002992                 xor     ecx, eax
.text$x:00002994                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002999                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z
.text$x:0000299E                 jmp     ___CxxFrameHandler3
.text$x:0000299E __ehhandler$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z endp
.text$x:0000299E
.text$x:0000299E ; ---------------------------------------------------------------------------
.text$x:000029A3                 align 4
.text$x:000029A3 _text$x         ends
.text$x:000029A3
.text$mn:000029A4 ; ===========================================================================
.text$mn:000029A4
.text$mn:000029A4 ; Segment type: Pure code
.text$mn:000029A4 ; Segment permissions: Read/Execute
.text$mn:000029A4 _text$mn        segment para public 'CODE' use32
.text$mn:000029A4                 assume cs:_text$mn
.text$mn:000029A4                 ;org 29A4h
.text$mn:000029A4 ; COMDAT (pick any)
.text$mn:000029A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029A4
.text$mn:000029A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029A4
.text$mn:000029A4 ; Attributes: bp-based frame
.text$mn:000029A4
.text$mn:000029A4 ; protected: void __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Reallocate(unsigned int)
.text$mn:000029A4                 public ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$mn:000029A4 ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z proc near
.text$mn:000029A4                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)+4Ep
.text$mn:000029A4
.text$mn:000029A4 var_20          = dword ptr -20h
.text$mn:000029A4 var_1C          = dword ptr -1Ch
.text$mn:000029A4 var_18          = dword ptr -18h
.text$mn:000029A4 var_13          = byte ptr -13h
.text$mn:000029A4 var_11          = byte ptr -11h
.text$mn:000029A4 var_10          = dword ptr -10h
.text$mn:000029A4 var_C           = dword ptr -0Ch
.text$mn:000029A4 var_4           = dword ptr -4
.text$mn:000029A4 arg_0           = dword ptr  8
.text$mn:000029A4
.text$mn:000029A4 ; FUNCTION CHUNK AT .text$mn:00002A3A SIZE 00000009 BYTES
.text$mn:000029A4 ; FUNCTION CHUNK AT .text$mn:00002A4A SIZE 00000097 BYTES
.text$mn:000029A4
.text$mn:000029A4                 push    ebp
.text$mn:000029A5                 mov     ebp, esp
.text$mn:000029A7                 push    0FFFFFFFFh
.text$mn:000029A9                 push    offset __ehhandler$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$mn:000029AE                 mov     eax, large fs:0
.text$mn:000029B4                 push    eax
.text$mn:000029B5                 push    ecx
.text$mn:000029B6                 sub     esp, 10h
.text$mn:000029B9                 push    ebx
.text$mn:000029BA                 push    esi
.text$mn:000029BB                 push    edi
.text$mn:000029BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000029C1                 xor     eax, ebp
.text$mn:000029C3                 push    eax
.text$mn:000029C4                 lea     eax, [ebp+var_C]
.text$mn:000029C7                 mov     large fs:0, eax
.text$mn:000029CD                 mov     [ebp+var_10], esp
.text$mn:000029D0                 mov     [ebp+var_18], ecx
.text$mn:000029D3                 mov     eax, [ebp+arg_0]
.text$mn:000029D6                 push    eax
.text$mn:000029D7                 lea     ecx, [ebp+var_11]
.text$mn:000029DA                 push    ecx
.text$mn:000029DB                 mov     ecx, [ebp+var_18]
.text$mn:000029DE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:000029E3                 mov     ecx, eax
.text$mn:000029E5                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEPAPAUHMENU__@@I@Z ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::allocate(uint)
.text$mn:000029EA                 mov     [ebp+var_1C], eax
.text$mn:000029ED                 mov     [ebp+var_4], 0
.text$mn:000029F4                 mov     edx, [ebp+var_1C]
.text$mn:000029F7                 push    edx
.text$mn:000029F8                 mov     eax, [ebp+var_18]
.text$mn:000029FB                 mov     ecx, [eax+8]
.text$mn:000029FE                 push    ecx
.text$mn:000029FF                 mov     edx, [ebp+var_18]
.text$mn:00002A02                 mov     eax, [edx+4]
.text$mn:00002A05                 push    eax
.text$mn:00002A06                 mov     ecx, [ebp+var_18]
.text$mn:00002A09                 call    ??$_Umove@PAPAUHMENU__@@@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEPAPAUHMENU__@@PAPAU2@00@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Umove<HMENU__ * *>(HMENU__ * *,HMENU__ * *,HMENU__ * *)
.text$mn:00002A0E                 jmp     short loc_2A3A
.text$mn:00002A0E ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z endp
.text$mn:00002A0E
.text$mn:00002A10
.text$mn:00002A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A10
.text$mn:00002A10 ; Attributes: noreturn
.text$mn:00002A10
.text$mn:00002A10 __catch$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00002A10                                         ; DATA XREF: .xdata$x:00004538o
.text$mn:00002A10                 mov     ecx, [ebp+8]
.text$mn:00002A13                 push    ecx             ; int
.text$mn:00002A14                 mov     edx, [ebp-1Ch]
.text$mn:00002A17                 push    edx             ; void *
.text$mn:00002A18                 lea     eax, [ebp-12h]
.text$mn:00002A1B                 push    eax
.text$mn:00002A1C                 mov     ecx, [ebp-18h]
.text$mn:00002A1F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:00002A24                 mov     ecx, eax
.text$mn:00002A26                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@I@Z ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::deallocate(HMENU__ * *,uint)
.text$mn:00002A2B                 push    0
.text$mn:00002A2D                 push    0
.text$mn:00002A2F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002A2F __catch$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00002A2F
.text$mn:00002A34 ; ---------------------------------------------------------------------------
.text$mn:00002A34                 mov     eax, offset $LN8
.text$mn:00002A39                 retn
.text$mn:00002A3A ; ---------------------------------------------------------------------------
.text$mn:00002A3A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$mn:00002A3A
.text$mn:00002A3A loc_2A3A:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+6Aj
.text$mn:00002A3A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A41                 jmp     short loc_2A4A
.text$mn:00002A41 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$mn:00002A43
.text$mn:00002A43 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A43
.text$mn:00002A43
.text$mn:00002A43 $LN8            proc near               ; DATA XREF: .text$mn:00002A34o
.text$mn:00002A43                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002A43 $LN8            endp ; sp-analysis failed
.text$mn:00002A43
.text$mn:00002A4A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$mn:00002A4A
.text$mn:00002A4A loc_2A4A:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+9Dj
.text$mn:00002A4A                 mov     ecx, [ebp+var_18]
.text$mn:00002A4D                 call    ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::size(void)
.text$mn:00002A52                 mov     [ebp+var_20], eax
.text$mn:00002A55                 mov     ecx, [ebp+var_18]
.text$mn:00002A58                 cmp     dword ptr [ecx+4], 0
.text$mn:00002A5C                 jz      short loc_2A9E
.text$mn:00002A5E                 mov     edx, [ebp+var_18]
.text$mn:00002A61                 mov     eax, [edx+8]
.text$mn:00002A64                 push    eax
.text$mn:00002A65                 mov     ecx, [ebp+var_18]
.text$mn:00002A68                 mov     edx, [ecx+4]
.text$mn:00002A6B                 push    edx
.text$mn:00002A6C                 mov     ecx, [ebp+var_18]
.text$mn:00002A6F                 call    ?_Destroy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXPAPAUHMENU__@@0@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Destroy(HMENU__ * *,HMENU__ * *)
.text$mn:00002A74                 mov     eax, [ebp+var_18]
.text$mn:00002A77                 mov     ecx, [ebp+var_18]
.text$mn:00002A7A                 mov     edx, [eax+0Ch]
.text$mn:00002A7D                 sub     edx, [ecx+4]
.text$mn:00002A80                 sar     edx, 2
.text$mn:00002A83                 push    edx             ; int
.text$mn:00002A84                 mov     eax, [ebp+var_18]
.text$mn:00002A87                 mov     ecx, [eax+4]
.text$mn:00002A8A                 push    ecx             ; void *
.text$mn:00002A8B                 lea     edx, [ebp+var_13]
.text$mn:00002A8E                 push    edx
.text$mn:00002A8F                 mov     ecx, [ebp+var_18]
.text$mn:00002A92                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:00002A97                 mov     ecx, eax
.text$mn:00002A99                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@I@Z ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::deallocate(HMENU__ * *,uint)
.text$mn:00002A9E
.text$mn:00002A9E loc_2A9E:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+B8j
.text$mn:00002A9E                 mov     ecx, [ebp+var_18] ; this
.text$mn:00002AA1                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002AA6                 mov     eax, [ebp+arg_0]
.text$mn:00002AA9                 mov     ecx, [ebp+var_1C]
.text$mn:00002AAC                 lea     edx, [ecx+eax*4]
.text$mn:00002AAF                 mov     eax, [ebp+var_18]
.text$mn:00002AB2                 mov     [eax+0Ch], edx
.text$mn:00002AB5                 mov     ecx, [ebp+var_20]
.text$mn:00002AB8                 mov     edx, [ebp+var_1C]
.text$mn:00002ABB                 lea     eax, [edx+ecx*4]
.text$mn:00002ABE                 mov     ecx, [ebp+var_18]
.text$mn:00002AC1                 mov     [ecx+8], eax
.text$mn:00002AC4                 mov     edx, [ebp+var_18]
.text$mn:00002AC7                 mov     eax, [ebp+var_1C]
.text$mn:00002ACA                 mov     [edx+4], eax
.text$mn:00002ACD                 mov     ecx, [ebp+var_C]
.text$mn:00002AD0                 mov     large fs:0, ecx
.text$mn:00002AD7                 pop     ecx
.text$mn:00002AD8                 pop     edi
.text$mn:00002AD9                 pop     esi
.text$mn:00002ADA                 pop     ebx
.text$mn:00002ADB                 mov     esp, ebp
.text$mn:00002ADD                 pop     ebp
.text$mn:00002ADE                 retn    4
.text$mn:00002ADE ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$mn:00002ADE ; ---------------------------------------------------------------------------
.text$mn:00002AE1                 align 4
.text$mn:00002AE1 _text$mn        ends
.text$mn:00002AE1
.text$x:00002AE4 ; ===========================================================================
.text$x:00002AE4
.text$x:00002AE4 ; Segment type: Pure code
.text$x:00002AE4 ; Segment permissions: Read/Execute
.text$x:00002AE4 _text$x         segment para public 'CODE' use32
.text$x:00002AE4                 assume cs:_text$x
.text$x:00002AE4                 ;org 2AE4h
.text$x:00002AE4 ; COMDAT (pick associative to section at 29A4)
.text$x:00002AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AE4
.text$x:00002AE4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AE4
.text$x:00002AE4
.text$x:00002AE4 __ehhandler$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z proc near
.text$x:00002AE4                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+5o
.text$x:00002AE4
.text$x:00002AE4 arg_4           = dword ptr  8
.text$x:00002AE4
.text$x:00002AE4                 mov     edx, [esp+arg_4]
.text$x:00002AE8                 lea     eax, [edx+0Ch]
.text$x:00002AEB                 mov     ecx, [edx-24h]
.text$x:00002AEE                 xor     ecx, eax
.text$x:00002AF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AF5                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$x:00002AFA                 jmp     ___CxxFrameHandler3
.text$x:00002AFA __ehhandler$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z endp
.text$x:00002AFA
.text$x:00002AFA ; ---------------------------------------------------------------------------
.text$x:00002AFF                 align 10h
.text$x:00002AFF _text$x         ends
.text$x:00002AFF
.text$mn:00002B00 ; ===========================================================================
.text$mn:00002B00
.text$mn:00002B00 ; Segment type: Pure code
.text$mn:00002B00 ; Segment permissions: Read/Execute
.text$mn:00002B00 _text$mn        segment para public 'CODE' use32
.text$mn:00002B00                 assume cs:_text$mn
.text$mn:00002B00                 ;org 2B00h
.text$mn:00002B00 ; COMDAT (pick any)
.text$mn:00002B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B00
.text$mn:00002B00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B00
.text$mn:00002B00 ; Attributes: bp-based frame
.text$mn:00002B00
.text$mn:00002B00 ; protected: void __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Reserve(unsigned int)
.text$mn:00002B00                 public ?_Reserve@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.text$mn:00002B00 ?_Reserve@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z proc near
.text$mn:00002B00                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+50p
.text$mn:00002B00                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+B6p
.text$mn:00002B00
.text$mn:00002B00 var_4           = dword ptr -4
.text$mn:00002B00 arg_0           = dword ptr  8
.text$mn:00002B00
.text$mn:00002B00                 push    ebp
.text$mn:00002B01                 mov     ebp, esp
.text$mn:00002B03                 push    ecx
.text$mn:00002B04                 push    esi
.text$mn:00002B05                 mov     [ebp+var_4], ecx
.text$mn:00002B08                 mov     ecx, [ebp+var_4]
.text$mn:00002B0B                 call    ?_Unused_capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Unused_capacity(void)
.text$mn:00002B10                 cmp     eax, [ebp+arg_0]
.text$mn:00002B13                 jnb     short loc_2B53
.text$mn:00002B15                 mov     ecx, [ebp+var_4]
.text$mn:00002B18                 call    ?max_size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::max_size(void)
.text$mn:00002B1D                 mov     esi, eax
.text$mn:00002B1F                 mov     ecx, [ebp+var_4]
.text$mn:00002B22                 call    ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::size(void)
.text$mn:00002B27                 sub     esi, eax
.text$mn:00002B29                 cmp     esi, [ebp+arg_0]
.text$mn:00002B2C                 jnb     short loc_2B36
.text$mn:00002B2E                 mov     ecx, [ebp+var_4]
.text$mn:00002B31                 call    ?_Xlen@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Xlen(void)
.text$mn:00002B36
.text$mn:00002B36 loc_2B36:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)+2Cj
.text$mn:00002B36                 mov     ecx, [ebp+var_4]
.text$mn:00002B39                 call    ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::size(void)
.text$mn:00002B3E                 add     eax, [ebp+arg_0]
.text$mn:00002B41                 push    eax
.text$mn:00002B42                 mov     ecx, [ebp+var_4]
.text$mn:00002B45                 call    ?_Grow_to@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEII@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Grow_to(uint)
.text$mn:00002B4A                 push    eax
.text$mn:00002B4B                 mov     ecx, [ebp+var_4]
.text$mn:00002B4E                 call    ?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)
.text$mn:00002B53
.text$mn:00002B53 loc_2B53:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)+13j
.text$mn:00002B53                 pop     esi
.text$mn:00002B54                 mov     esp, ebp
.text$mn:00002B56                 pop     ebp
.text$mn:00002B57                 retn    4
.text$mn:00002B57 ?_Reserve@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z endp
.text$mn:00002B57
.text$mn:00002B57 ; ---------------------------------------------------------------------------
.text$mn:00002B5A                 align 4
.text$mn:00002B5A _text$mn        ends
.text$mn:00002B5A
.text$mn:00002B5C ; ===========================================================================
.text$mn:00002B5C
.text$mn:00002B5C ; Segment type: Pure code
.text$mn:00002B5C ; Segment permissions: Read/Execute
.text$mn:00002B5C _text$mn        segment para public 'CODE' use32
.text$mn:00002B5C                 assume cs:_text$mn
.text$mn:00002B5C                 ;org 2B5Ch
.text$mn:00002B5C ; COMDAT (pick any)
.text$mn:00002B5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B5C
.text$mn:00002B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B5C
.text$mn:00002B5C ; Attributes: bp-based frame
.text$mn:00002B5C
.text$mn:00002B5C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00002B5C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00002B5C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00002B5C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00002B5C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00002B5C
.text$mn:00002B5C var_C           = dword ptr -0Ch
.text$mn:00002B5C var_8           = dword ptr -8
.text$mn:00002B5C var_2           = byte ptr -2
.text$mn:00002B5C var_1           = byte ptr -1
.text$mn:00002B5C arg_0           = byte ptr  8
.text$mn:00002B5C Size            = dword ptr  0Ch
.text$mn:00002B5C
.text$mn:00002B5C                 push    ebp
.text$mn:00002B5D                 mov     ebp, esp
.text$mn:00002B5F                 sub     esp, 0Ch
.text$mn:00002B62                 mov     [ebp+var_8], ecx
.text$mn:00002B65                 movzx   eax, [ebp+arg_0]
.text$mn:00002B69                 test    eax, eax
.text$mn:00002B6B                 jnz     short loc_2B6F
.text$mn:00002B6D                 jmp     short loc_2BE2
.text$mn:00002B6F ; ---------------------------------------------------------------------------
.text$mn:00002B6F
.text$mn:00002B6F loc_2B6F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00002B6F                 mov     ecx, [ebp+var_8]
.text$mn:00002B72                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00002B76                 jb      short loc_2BE2
.text$mn:00002B78                 mov     edx, [ebp+var_8]
.text$mn:00002B7B                 mov     eax, [edx+4]
.text$mn:00002B7E                 mov     [ebp+var_C], eax
.text$mn:00002B81                 mov     ecx, [ebp+var_8]
.text$mn:00002B84                 add     ecx, 4
.text$mn:00002B87                 push    ecx
.text$mn:00002B88                 lea     edx, [ebp+var_1]
.text$mn:00002B8B                 push    edx
.text$mn:00002B8C                 mov     ecx, [ebp+var_8]
.text$mn:00002B8F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002B94                 mov     ecx, eax
.text$mn:00002B96                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002B9B                 cmp     [ebp+Size], 0
.text$mn:00002B9F                 jbe     short loc_2BC1
.text$mn:00002BA1                 mov     eax, [ebp+Size]
.text$mn:00002BA4                 push    eax             ; Size
.text$mn:00002BA5                 mov     ecx, [ebp+var_C]
.text$mn:00002BA8                 push    ecx
.text$mn:00002BA9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002BAE                 add     esp, 4
.text$mn:00002BB1                 push    eax             ; Src
.text$mn:00002BB2                 mov     edx, [ebp+var_8]
.text$mn:00002BB5                 add     edx, 4
.text$mn:00002BB8                 push    edx             ; Dst
.text$mn:00002BB9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002BBE                 add     esp, 0Ch
.text$mn:00002BC1
.text$mn:00002BC1 loc_2BC1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002BC1                 mov     eax, [ebp+var_8]
.text$mn:00002BC4                 mov     ecx, [eax+18h]
.text$mn:00002BC7                 add     ecx, 1
.text$mn:00002BCA                 push    ecx             ; int
.text$mn:00002BCB                 mov     edx, [ebp+var_C]
.text$mn:00002BCE                 push    edx             ; void *
.text$mn:00002BCF                 lea     eax, [ebp+var_2]
.text$mn:00002BD2                 push    eax
.text$mn:00002BD3                 mov     ecx, [ebp+var_8]
.text$mn:00002BD6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002BDB                 mov     ecx, eax
.text$mn:00002BDD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00002BE2
.text$mn:00002BE2 loc_2BE2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00002BE2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00002BE2                 mov     ecx, [ebp+var_8]
.text$mn:00002BE5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00002BEC                 mov     edx, [ebp+Size]
.text$mn:00002BEF                 push    edx
.text$mn:00002BF0                 mov     ecx, [ebp+var_8]
.text$mn:00002BF3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002BF8                 mov     esp, ebp
.text$mn:00002BFA                 pop     ebp
.text$mn:00002BFB                 retn    8
.text$mn:00002BFB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00002BFB
.text$mn:00002BFB ; ---------------------------------------------------------------------------
.text$mn:00002BFE                 align 10h
.text$mn:00002BFE _text$mn        ends
.text$mn:00002BFE
.text$mn:00002C00 ; ===========================================================================
.text$mn:00002C00
.text$mn:00002C00 ; Segment type: Pure code
.text$mn:00002C00 ; Segment permissions: Read/Execute
.text$mn:00002C00 _text$mn        segment para public 'CODE' use32
.text$mn:00002C00                 assume cs:_text$mn
.text$mn:00002C00                 ;org 2C00h
.text$mn:00002C00 ; COMDAT (pick any)
.text$mn:00002C00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C00
.text$mn:00002C00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C00
.text$mn:00002C00 ; Attributes: bp-based frame
.text$mn:00002C00
.text$mn:00002C00 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00002C00                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00002C00 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00002C00                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p
.text$mn:00002C00                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+47p ...
.text$mn:00002C00
.text$mn:00002C00 var_C           = dword ptr -0Ch
.text$mn:00002C00 var_8           = dword ptr -8
.text$mn:00002C00 var_2           = byte ptr -2
.text$mn:00002C00 var_1           = byte ptr -1
.text$mn:00002C00 arg_0           = byte ptr  8
.text$mn:00002C00 arg_4           = dword ptr  0Ch
.text$mn:00002C00
.text$mn:00002C00                 push    ebp
.text$mn:00002C01                 mov     ebp, esp
.text$mn:00002C03                 sub     esp, 0Ch
.text$mn:00002C06                 mov     [ebp+var_8], ecx
.text$mn:00002C09                 movzx   eax, [ebp+arg_0]
.text$mn:00002C0D                 test    eax, eax
.text$mn:00002C0F                 jnz     short loc_2C13
.text$mn:00002C11                 jmp     short loc_2C86
.text$mn:00002C13 ; ---------------------------------------------------------------------------
.text$mn:00002C13
.text$mn:00002C13 loc_2C13:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00002C13                 mov     ecx, [ebp+var_8]
.text$mn:00002C16                 cmp     dword ptr [ecx+18h], 8
.text$mn:00002C1A                 jb      short loc_2C86
.text$mn:00002C1C                 mov     edx, [ebp+var_8]
.text$mn:00002C1F                 mov     eax, [edx+4]
.text$mn:00002C22                 mov     [ebp+var_C], eax
.text$mn:00002C25                 mov     ecx, [ebp+var_8]
.text$mn:00002C28                 add     ecx, 4
.text$mn:00002C2B                 push    ecx
.text$mn:00002C2C                 lea     edx, [ebp+var_1]
.text$mn:00002C2F                 push    edx
.text$mn:00002C30                 mov     ecx, [ebp+var_8]
.text$mn:00002C33                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002C38                 mov     ecx, eax
.text$mn:00002C3A                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002C3F                 cmp     [ebp+arg_4], 0
.text$mn:00002C43                 jbe     short loc_2C65
.text$mn:00002C45                 mov     eax, [ebp+arg_4]
.text$mn:00002C48                 push    eax             ; int
.text$mn:00002C49                 mov     ecx, [ebp+var_C]
.text$mn:00002C4C                 push    ecx
.text$mn:00002C4D                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00002C52                 add     esp, 4
.text$mn:00002C55                 push    eax             ; Src
.text$mn:00002C56                 mov     edx, [ebp+var_8]
.text$mn:00002C59                 add     edx, 4
.text$mn:00002C5C                 push    edx             ; Dst
.text$mn:00002C5D                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002C62                 add     esp, 0Ch
.text$mn:00002C65
.text$mn:00002C65 loc_2C65:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00002C65                 mov     eax, [ebp+var_8]
.text$mn:00002C68                 mov     ecx, [eax+18h]
.text$mn:00002C6B                 add     ecx, 1
.text$mn:00002C6E                 push    ecx             ; int
.text$mn:00002C6F                 mov     edx, [ebp+var_C]
.text$mn:00002C72                 push    edx             ; void *
.text$mn:00002C73                 lea     eax, [ebp+var_2]
.text$mn:00002C76                 push    eax
.text$mn:00002C77                 mov     ecx, [ebp+var_8]
.text$mn:00002C7A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002C7F                 mov     ecx, eax
.text$mn:00002C81                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00002C86
.text$mn:00002C86 loc_2C86:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00002C86                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00002C86                 mov     ecx, [ebp+var_8]
.text$mn:00002C89                 mov     dword ptr [ecx+18h], 7
.text$mn:00002C90                 mov     edx, [ebp+arg_4]
.text$mn:00002C93                 push    edx
.text$mn:00002C94                 mov     ecx, [ebp+var_8]
.text$mn:00002C97                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002C9C                 mov     esp, ebp
.text$mn:00002C9E                 pop     ebp
.text$mn:00002C9F                 retn    8
.text$mn:00002C9F ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00002C9F
.text$mn:00002C9F ; ---------------------------------------------------------------------------
.text$mn:00002CA2                 align 4
.text$mn:00002CA2 _text$mn        ends
.text$mn:00002CA2
.text$mn:00002CA4 ; ===========================================================================
.text$mn:00002CA4
.text$mn:00002CA4 ; Segment type: Pure code
.text$mn:00002CA4 ; Segment permissions: Read/Execute
.text$mn:00002CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002CA4                 assume cs:_text$mn
.text$mn:00002CA4                 ;org 2CA4h
.text$mn:00002CA4 ; COMDAT (pick any)
.text$mn:00002CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CA4
.text$mn:00002CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CA4
.text$mn:00002CA4 ; Attributes: bp-based frame
.text$mn:00002CA4
.text$mn:00002CA4 ; protected: void __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Tidy(void)
.text$mn:00002CA4                 public ?_Tidy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXXZ
.text$mn:00002CA4 ?_Tidy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXXZ proc near
.text$mn:00002CA4                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::~vector<HMENU__ *,std::allocator<HMENU__ *>>(void)+30p
.text$mn:00002CA4
.text$mn:00002CA4 var_8           = dword ptr -8
.text$mn:00002CA4 var_1           = byte ptr -1
.text$mn:00002CA4
.text$mn:00002CA4                 push    ebp
.text$mn:00002CA5                 mov     ebp, esp
.text$mn:00002CA7                 sub     esp, 8
.text$mn:00002CAA                 mov     [ebp+var_8], ecx
.text$mn:00002CAD                 mov     eax, [ebp+var_8]
.text$mn:00002CB0                 cmp     dword ptr [eax+4], 0
.text$mn:00002CB4                 jz      short loc_2D1C
.text$mn:00002CB6                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002CB9                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002CBE                 mov     ecx, [ebp+var_8]
.text$mn:00002CC1                 mov     edx, [ecx+8]
.text$mn:00002CC4                 push    edx
.text$mn:00002CC5                 mov     eax, [ebp+var_8]
.text$mn:00002CC8                 mov     ecx, [eax+4]
.text$mn:00002CCB                 push    ecx
.text$mn:00002CCC                 mov     ecx, [ebp+var_8]
.text$mn:00002CCF                 call    ?_Destroy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXPAPAUHMENU__@@0@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Destroy(HMENU__ * *,HMENU__ * *)
.text$mn:00002CD4                 mov     edx, [ebp+var_8]
.text$mn:00002CD7                 mov     eax, [ebp+var_8]
.text$mn:00002CDA                 mov     ecx, [edx+0Ch]
.text$mn:00002CDD                 sub     ecx, [eax+4]
.text$mn:00002CE0                 sar     ecx, 2
.text$mn:00002CE3                 push    ecx             ; int
.text$mn:00002CE4                 mov     edx, [ebp+var_8]
.text$mn:00002CE7                 mov     eax, [edx+4]
.text$mn:00002CEA                 push    eax             ; void *
.text$mn:00002CEB                 lea     ecx, [ebp+var_1]
.text$mn:00002CEE                 push    ecx
.text$mn:00002CEF                 mov     ecx, [ebp+var_8]
.text$mn:00002CF2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:00002CF7                 mov     ecx, eax
.text$mn:00002CF9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@I@Z ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::deallocate(HMENU__ * *,uint)
.text$mn:00002CFE                 mov     edx, [ebp+var_8]
.text$mn:00002D01                 mov     dword ptr [edx+4], 0
.text$mn:00002D08                 mov     eax, [ebp+var_8]
.text$mn:00002D0B                 mov     dword ptr [eax+8], 0
.text$mn:00002D12                 mov     ecx, [ebp+var_8]
.text$mn:00002D15                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00002D1C
.text$mn:00002D1C loc_2D1C:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Tidy(void)+10j
.text$mn:00002D1C                 mov     esp, ebp
.text$mn:00002D1E                 pop     ebp
.text$mn:00002D1F                 retn
.text$mn:00002D1F ?_Tidy@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXXZ endp
.text$mn:00002D1F
.text$mn:00002D1F _text$mn        ends
.text$mn:00002D1F
.text$mn:00002D20 ; ===========================================================================
.text$mn:00002D20
.text$mn:00002D20 ; Segment type: Pure code
.text$mn:00002D20 ; Segment permissions: Read/Execute
.text$mn:00002D20 _text$mn        segment para public 'CODE' use32
.text$mn:00002D20                 assume cs:_text$mn
.text$mn:00002D20                 ;org 2D20h
.text$mn:00002D20 ; COMDAT (pick any)
.text$mn:00002D20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D20
.text$mn:00002D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D20
.text$mn:00002D20 ; Attributes: bp-based frame
.text$mn:00002D20
.text$mn:00002D20 ; public: unsigned int __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Unused_capacity(void)const
.text$mn:00002D20                 public ?_Unused_capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ
.text$mn:00002D20 ?_Unused_capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ proc near
.text$mn:00002D20                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)+Bp
.text$mn:00002D20
.text$mn:00002D20 var_4           = dword ptr -4
.text$mn:00002D20
.text$mn:00002D20                 push    ebp
.text$mn:00002D21                 mov     ebp, esp
.text$mn:00002D23                 push    ecx
.text$mn:00002D24                 mov     [ebp+var_4], ecx
.text$mn:00002D27                 mov     eax, [ebp+var_4]
.text$mn:00002D2A                 mov     ecx, [ebp+var_4]
.text$mn:00002D2D                 mov     eax, [eax+0Ch]
.text$mn:00002D30                 sub     eax, [ecx+8]
.text$mn:00002D33                 sar     eax, 2
.text$mn:00002D36                 mov     esp, ebp
.text$mn:00002D38                 pop     ebp
.text$mn:00002D39                 retn
.text$mn:00002D39 ?_Unused_capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ endp
.text$mn:00002D39
.text$mn:00002D39 ; ---------------------------------------------------------------------------
.text$mn:00002D3A                 align 4
.text$mn:00002D3A _text$mn        ends
.text$mn:00002D3A
.text$mn:00002D3C ; ===========================================================================
.text$mn:00002D3C
.text$mn:00002D3C ; Segment type: Pure code
.text$mn:00002D3C ; Segment permissions: Read/Execute
.text$mn:00002D3C _text$mn        segment para public 'CODE' use32
.text$mn:00002D3C                 assume cs:_text$mn
.text$mn:00002D3C                 ;org 2D3Ch
.text$mn:00002D3C ; COMDAT (pick any)
.text$mn:00002D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D3C
.text$mn:00002D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D3C
.text$mn:00002D3C ; Attributes: bp-based frame
.text$mn:00002D3C
.text$mn:00002D3C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00002D3C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002D3C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002D3C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00002D3C
.text$mn:00002D3C var_4           = dword ptr -4
.text$mn:00002D3C
.text$mn:00002D3C                 push    ebp
.text$mn:00002D3D                 mov     ebp, esp
.text$mn:00002D3F                 push    ecx
.text$mn:00002D40                 mov     [ebp+var_4], ecx
.text$mn:00002D43                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00002D48                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00002D4D                 mov     esp, ebp
.text$mn:00002D4F                 pop     ebp
.text$mn:00002D50                 retn
.text$mn:00002D50 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002D50
.text$mn:00002D50 ; ---------------------------------------------------------------------------
.text$mn:00002D51                 align 4
.text$mn:00002D51 _text$mn        ends
.text$mn:00002D51
.text$mn:00002D54 ; ===========================================================================
.text$mn:00002D54
.text$mn:00002D54 ; Segment type: Pure code
.text$mn:00002D54 ; Segment permissions: Read/Execute
.text$mn:00002D54 _text$mn        segment para public 'CODE' use32
.text$mn:00002D54                 assume cs:_text$mn
.text$mn:00002D54                 ;org 2D54h
.text$mn:00002D54 ; COMDAT (pick any)
.text$mn:00002D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D54
.text$mn:00002D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D54
.text$mn:00002D54 ; Attributes: bp-based frame
.text$mn:00002D54
.text$mn:00002D54 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00002D54                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00002D54 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00002D54                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00002D54
.text$mn:00002D54 var_4           = dword ptr -4
.text$mn:00002D54
.text$mn:00002D54                 push    ebp
.text$mn:00002D55                 mov     ebp, esp
.text$mn:00002D57                 push    ecx
.text$mn:00002D58                 mov     [ebp+var_4], ecx
.text$mn:00002D5B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00002D60                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00002D65                 mov     esp, ebp
.text$mn:00002D67                 pop     ebp
.text$mn:00002D68                 retn
.text$mn:00002D68 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00002D68
.text$mn:00002D68 ; ---------------------------------------------------------------------------
.text$mn:00002D69                 align 4
.text$mn:00002D69 _text$mn        ends
.text$mn:00002D69
.text$mn:00002D6C ; ===========================================================================
.text$mn:00002D6C
.text$mn:00002D6C ; Segment type: Pure code
.text$mn:00002D6C ; Segment permissions: Read/Execute
.text$mn:00002D6C _text$mn        segment para public 'CODE' use32
.text$mn:00002D6C                 assume cs:_text$mn
.text$mn:00002D6C                 ;org 2D6Ch
.text$mn:00002D6C ; COMDAT (pick any)
.text$mn:00002D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D6C
.text$mn:00002D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D6C
.text$mn:00002D6C ; Attributes: bp-based frame
.text$mn:00002D6C
.text$mn:00002D6C ; protected: void __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::_Xlen(void)const
.text$mn:00002D6C                 public ?_Xlen@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXXZ
.text$mn:00002D6C ?_Xlen@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXXZ proc near
.text$mn:00002D6C                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)+31p
.text$mn:00002D6C
.text$mn:00002D6C var_4           = dword ptr -4
.text$mn:00002D6C
.text$mn:00002D6C                 push    ebp
.text$mn:00002D6D                 mov     ebp, esp
.text$mn:00002D6F                 push    ecx
.text$mn:00002D70                 mov     [ebp+var_4], ecx
.text$mn:00002D73                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00002D78                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00002D7D                 mov     esp, ebp
.text$mn:00002D7F                 pop     ebp
.text$mn:00002D80                 retn
.text$mn:00002D80 ?_Xlen@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXXZ endp
.text$mn:00002D80
.text$mn:00002D80 ; ---------------------------------------------------------------------------
.text$mn:00002D81                 align 4
.text$mn:00002D81 _text$mn        ends
.text$mn:00002D81
.text$mn:00002D84 ; ===========================================================================
.text$mn:00002D84
.text$mn:00002D84 ; Segment type: Pure code
.text$mn:00002D84 ; Segment permissions: Read/Execute
.text$mn:00002D84 _text$mn        segment para public 'CODE' use32
.text$mn:00002D84                 assume cs:_text$mn
.text$mn:00002D84                 ;org 2D84h
.text$mn:00002D84 ; COMDAT (pick any)
.text$mn:00002D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D84
.text$mn:00002D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D84
.text$mn:00002D84 ; Attributes: bp-based frame
.text$mn:00002D84
.text$mn:00002D84 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00002D84                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002D84 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002D84                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00002D84                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00002D84
.text$mn:00002D84 var_4           = dword ptr -4
.text$mn:00002D84
.text$mn:00002D84                 push    ebp
.text$mn:00002D85                 mov     ebp, esp
.text$mn:00002D87                 push    ecx
.text$mn:00002D88                 mov     [ebp+var_4], ecx
.text$mn:00002D8B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00002D90                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002D95                 mov     esp, ebp
.text$mn:00002D97                 pop     ebp
.text$mn:00002D98                 retn
.text$mn:00002D98 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002D98
.text$mn:00002D98 ; ---------------------------------------------------------------------------
.text$mn:00002D99                 align 4
.text$mn:00002D99 _text$mn        ends
.text$mn:00002D99
.text$mn:00002D9C ; ===========================================================================
.text$mn:00002D9C
.text$mn:00002D9C ; Segment type: Pure code
.text$mn:00002D9C ; Segment permissions: Read/Execute
.text$mn:00002D9C _text$mn        segment para public 'CODE' use32
.text$mn:00002D9C                 assume cs:_text$mn
.text$mn:00002D9C                 ;org 2D9Ch
.text$mn:00002D9C ; COMDAT (pick any)
.text$mn:00002D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D9C
.text$mn:00002D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D9C
.text$mn:00002D9C ; Attributes: bp-based frame
.text$mn:00002D9C
.text$mn:00002D9C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00002D9C                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00002D9C ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00002D9C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00002D9C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+33p ...
.text$mn:00002D9C
.text$mn:00002D9C var_4           = dword ptr -4
.text$mn:00002D9C
.text$mn:00002D9C                 push    ebp
.text$mn:00002D9D                 mov     ebp, esp
.text$mn:00002D9F                 push    ecx
.text$mn:00002DA0                 mov     [ebp+var_4], ecx
.text$mn:00002DA3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00002DA8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002DAD                 mov     esp, ebp
.text$mn:00002DAF                 pop     ebp
.text$mn:00002DB0                 retn
.text$mn:00002DB0 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00002DB0
.text$mn:00002DB0 ; ---------------------------------------------------------------------------
.text$mn:00002DB1                 align 4
.text$mn:00002DB1 _text$mn        ends
.text$mn:00002DB1
.text$mn:00002DB4 ; ===========================================================================
.text$mn:00002DB4
.text$mn:00002DB4 ; Segment type: Pure code
.text$mn:00002DB4 ; Segment permissions: Read/Execute
.text$mn:00002DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002DB4                 assume cs:_text$mn
.text$mn:00002DB4                 ;org 2DB4h
.text$mn:00002DB4 ; COMDAT (pick any)
.text$mn:00002DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DB4
.text$mn:00002DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DB4
.text$mn:00002DB4 ; Attributes: bp-based frame
.text$mn:00002DB4
.text$mn:00002DB4 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00002DB4                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00002DB4 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00002DB4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00002DB4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00002DB4
.text$mn:00002DB4 var_4           = dword ptr -4
.text$mn:00002DB4 arg_0           = dword ptr  8
.text$mn:00002DB4
.text$mn:00002DB4                 push    ebp
.text$mn:00002DB5                 mov     ebp, esp
.text$mn:00002DB7                 push    ecx
.text$mn:00002DB8                 mov     [ebp+var_4], ecx
.text$mn:00002DBB                 mov     eax, [ebp+arg_0]
.text$mn:00002DBE                 push    eax
.text$mn:00002DBF                 mov     ecx, [ebp+var_4]
.text$mn:00002DC2                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00002DC7                 mov     esp, ebp
.text$mn:00002DC9                 pop     ebp
.text$mn:00002DCA                 retn    4
.text$mn:00002DCA ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00002DCA
.text$mn:00002DCA ; ---------------------------------------------------------------------------
.text$mn:00002DCD                 align 10h
.text$mn:00002DCD _text$mn        ends
.text$mn:00002DCD
.text$mn:00002DD0 ; ===========================================================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Segment type: Pure code
.text$mn:00002DD0 ; Segment permissions: Read/Execute
.text$mn:00002DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD0                 assume cs:_text$mn
.text$mn:00002DD0                 ;org 2DD0h
.text$mn:00002DD0 ; COMDAT (pick any)
.text$mn:00002DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DD0
.text$mn:00002DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Attributes: bp-based frame
.text$mn:00002DD0
.text$mn:00002DD0 ; public: struct HMENU__ * * __thiscall std::_Wrap_alloc<class std::allocator<struct HMENU__ *>>::allocate(unsigned int)
.text$mn:00002DD0                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEPAPAUHMENU__@@I@Z
.text$mn:00002DD0 ?allocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEPAPAUHMENU__@@I@Z proc near
.text$mn:00002DD0                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+41p
.text$mn:00002DD0
.text$mn:00002DD0 var_4           = dword ptr -4
.text$mn:00002DD0 arg_0           = dword ptr  8
.text$mn:00002DD0
.text$mn:00002DD0                 push    ebp
.text$mn:00002DD1                 mov     ebp, esp
.text$mn:00002DD3                 push    ecx
.text$mn:00002DD4                 mov     [ebp+var_4], ecx
.text$mn:00002DD7                 mov     eax, [ebp+arg_0]
.text$mn:00002DDA                 push    eax
.text$mn:00002DDB                 mov     ecx, [ebp+var_4]
.text$mn:00002DDE                 call    ?allocate@?$allocator@PAUHMENU__@@@std@@QAEPAPAUHMENU__@@I@Z ; std::allocator<HMENU__ *>::allocate(uint)
.text$mn:00002DE3                 mov     esp, ebp
.text$mn:00002DE5                 pop     ebp
.text$mn:00002DE6                 retn    4
.text$mn:00002DE6 ?allocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEPAPAUHMENU__@@I@Z endp
.text$mn:00002DE6
.text$mn:00002DE6 ; ---------------------------------------------------------------------------
.text$mn:00002DE9                 align 4
.text$mn:00002DE9 _text$mn        ends
.text$mn:00002DE9
.text$mn:00002DEC ; ===========================================================================
.text$mn:00002DEC
.text$mn:00002DEC ; Segment type: Pure code
.text$mn:00002DEC ; Segment permissions: Read/Execute
.text$mn:00002DEC _text$mn        segment para public 'CODE' use32
.text$mn:00002DEC                 assume cs:_text$mn
.text$mn:00002DEC                 ;org 2DECh
.text$mn:00002DEC ; COMDAT (pick any)
.text$mn:00002DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DEC
.text$mn:00002DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002DEC
.text$mn:00002DEC ; Attributes: bp-based frame
.text$mn:00002DEC
.text$mn:00002DEC ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00002DEC                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00002DEC ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00002DEC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00002DEC                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00002DEC
.text$mn:00002DEC var_4           = dword ptr -4
.text$mn:00002DEC arg_0           = dword ptr  8
.text$mn:00002DEC
.text$mn:00002DEC                 push    ebp
.text$mn:00002DED                 mov     ebp, esp
.text$mn:00002DEF                 push    ecx
.text$mn:00002DF0                 mov     [ebp+var_4], ecx
.text$mn:00002DF3                 mov     eax, [ebp+arg_0]
.text$mn:00002DF6                 push    eax
.text$mn:00002DF7                 mov     ecx, [ebp+var_4]
.text$mn:00002DFA                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00002DFF                 mov     esp, ebp
.text$mn:00002E01                 pop     ebp
.text$mn:00002E02                 retn    4
.text$mn:00002E02 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:00002E02
.text$mn:00002E02 ; ---------------------------------------------------------------------------
.text$mn:00002E05                 align 4
.text$mn:00002E05 _text$mn        ends
.text$mn:00002E05
.text$mn:00002E08 ; ===========================================================================
.text$mn:00002E08
.text$mn:00002E08 ; Segment type: Pure code
.text$mn:00002E08 ; Segment permissions: Read/Execute
.text$mn:00002E08 _text$mn        segment para public 'CODE' use32
.text$mn:00002E08                 assume cs:_text$mn
.text$mn:00002E08                 ;org 2E08h
.text$mn:00002E08 ; COMDAT (pick any)
.text$mn:00002E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E08
.text$mn:00002E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E08
.text$mn:00002E08 ; Attributes: bp-based frame
.text$mn:00002E08
.text$mn:00002E08 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00002E08                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00002E08 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00002E08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00002E08
.text$mn:00002E08 var_4           = dword ptr -4
.text$mn:00002E08 arg_0           = dword ptr  8
.text$mn:00002E08
.text$mn:00002E08                 push    ebp
.text$mn:00002E09                 mov     ebp, esp
.text$mn:00002E0B                 push    ecx
.text$mn:00002E0C                 mov     [ebp+var_4], ecx
.text$mn:00002E0F                 push    0
.text$mn:00002E11                 mov     eax, [ebp+arg_0]
.text$mn:00002E14                 push    eax
.text$mn:00002E15                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00002E1A                 add     esp, 8
.text$mn:00002E1D                 mov     esp, ebp
.text$mn:00002E1F                 pop     ebp
.text$mn:00002E20                 retn    4
.text$mn:00002E20 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00002E20
.text$mn:00002E20 ; ---------------------------------------------------------------------------
.text$mn:00002E23                 align 4
.text$mn:00002E23 _text$mn        ends
.text$mn:00002E23
.text$mn:00002E24 ; ===========================================================================
.text$mn:00002E24
.text$mn:00002E24 ; Segment type: Pure code
.text$mn:00002E24 ; Segment permissions: Read/Execute
.text$mn:00002E24 _text$mn        segment para public 'CODE' use32
.text$mn:00002E24                 assume cs:_text$mn
.text$mn:00002E24                 ;org 2E24h
.text$mn:00002E24 ; COMDAT (pick any)
.text$mn:00002E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E24
.text$mn:00002E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E24
.text$mn:00002E24 ; Attributes: bp-based frame
.text$mn:00002E24
.text$mn:00002E24 ; public: struct HMENU__ * * __thiscall std::allocator<struct HMENU__ *>::allocate(unsigned int)
.text$mn:00002E24                 public ?allocate@?$allocator@PAUHMENU__@@@std@@QAEPAPAUHMENU__@@I@Z
.text$mn:00002E24 ?allocate@?$allocator@PAUHMENU__@@@std@@QAEPAPAUHMENU__@@I@Z proc near
.text$mn:00002E24                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::allocate(uint)+Ep
.text$mn:00002E24
.text$mn:00002E24 var_4           = dword ptr -4
.text$mn:00002E24 arg_0           = dword ptr  8
.text$mn:00002E24
.text$mn:00002E24                 push    ebp
.text$mn:00002E25                 mov     ebp, esp
.text$mn:00002E27                 push    ecx
.text$mn:00002E28                 mov     [ebp+var_4], ecx
.text$mn:00002E2B                 push    0
.text$mn:00002E2D                 mov     eax, [ebp+arg_0]
.text$mn:00002E30                 push    eax
.text$mn:00002E31                 call    ??$_Allocate@PAUHMENU__@@@std@@YAPAPAUHMENU__@@IPAPAU1@@Z ; std::_Allocate<HMENU__ *>(uint,HMENU__ * *)
.text$mn:00002E36                 add     esp, 8
.text$mn:00002E39                 mov     esp, ebp
.text$mn:00002E3B                 pop     ebp
.text$mn:00002E3C                 retn    4
.text$mn:00002E3C ?allocate@?$allocator@PAUHMENU__@@@std@@QAEPAPAUHMENU__@@I@Z endp
.text$mn:00002E3C
.text$mn:00002E3C ; ---------------------------------------------------------------------------
.text$mn:00002E3F                 align 10h
.text$mn:00002E3F _text$mn        ends
.text$mn:00002E3F
.text$mn:00002E40 ; ===========================================================================
.text$mn:00002E40
.text$mn:00002E40 ; Segment type: Pure code
.text$mn:00002E40 ; Segment permissions: Read/Execute
.text$mn:00002E40 _text$mn        segment para public 'CODE' use32
.text$mn:00002E40                 assume cs:_text$mn
.text$mn:00002E40                 ;org 2E40h
.text$mn:00002E40 ; COMDAT (pick any)
.text$mn:00002E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E40
.text$mn:00002E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E40
.text$mn:00002E40 ; Attributes: bp-based frame
.text$mn:00002E40
.text$mn:00002E40 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00002E40                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00002E40 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00002E40                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00002E40                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:00002E40
.text$mn:00002E40 var_4           = dword ptr -4
.text$mn:00002E40 arg_0           = dword ptr  8
.text$mn:00002E40
.text$mn:00002E40                 push    ebp
.text$mn:00002E41                 mov     ebp, esp
.text$mn:00002E43                 push    ecx
.text$mn:00002E44                 mov     [ebp+var_4], ecx
.text$mn:00002E47                 push    0
.text$mn:00002E49                 mov     eax, [ebp+arg_0]
.text$mn:00002E4C                 push    eax
.text$mn:00002E4D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00002E52                 add     esp, 8
.text$mn:00002E55                 mov     esp, ebp
.text$mn:00002E57                 pop     ebp
.text$mn:00002E58                 retn    4
.text$mn:00002E58 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002E58
.text$mn:00002E58 ; ---------------------------------------------------------------------------
.text$mn:00002E5B                 align 4
.text$mn:00002E5B _text$mn        ends
.text$mn:00002E5B
.text$mn:00002E5C ; ===========================================================================
.text$mn:00002E5C
.text$mn:00002E5C ; Segment type: Pure code
.text$mn:00002E5C ; Segment permissions: Read/Execute
.text$mn:00002E5C _text$mn        segment para public 'CODE' use32
.text$mn:00002E5C                 assume cs:_text$mn
.text$mn:00002E5C                 ;org 2E5Ch
.text$mn:00002E5C ; COMDAT (pick any)
.text$mn:00002E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E5C
.text$mn:00002E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E5C
.text$mn:00002E5C ; Attributes: bp-based frame
.text$mn:00002E5C
.text$mn:00002E5C ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00002E5C                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00002E5C ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00002E5C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00002E5C
.text$mn:00002E5C var_4           = dword ptr -4
.text$mn:00002E5C arg_0           = dword ptr  8
.text$mn:00002E5C
.text$mn:00002E5C                 push    ebp
.text$mn:00002E5D                 mov     ebp, esp
.text$mn:00002E5F                 push    ecx
.text$mn:00002E60                 mov     [ebp+var_4], ecx
.text$mn:00002E63                 push    0
.text$mn:00002E65                 mov     eax, [ebp+arg_0]
.text$mn:00002E68                 push    eax
.text$mn:00002E69                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00002E6E                 add     esp, 8
.text$mn:00002E71                 mov     esp, ebp
.text$mn:00002E73                 pop     ebp
.text$mn:00002E74                 retn    4
.text$mn:00002E74 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00002E74
.text$mn:00002E74 ; ---------------------------------------------------------------------------
.text$mn:00002E77                 align 4
.text$mn:00002E77 _text$mn        ends
.text$mn:00002E77
.text$mn:00002E78 ; ===========================================================================
.text$mn:00002E78
.text$mn:00002E78 ; Segment type: Pure code
.text$mn:00002E78 ; Segment permissions: Read/Execute
.text$mn:00002E78 _text$mn        segment para public 'CODE' use32
.text$mn:00002E78                 assume cs:_text$mn
.text$mn:00002E78                 ;org 2E78h
.text$mn:00002E78 ; COMDAT (pick any)
.text$mn:00002E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E78
.text$mn:00002E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E78
.text$mn:00002E78 ; Attributes: bp-based frame
.text$mn:00002E78
.text$mn:00002E78 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002E78                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002E78 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002E78                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002E78
.text$mn:00002E78 Size            = dword ptr -8
.text$mn:00002E78 var_4           = dword ptr -4
.text$mn:00002E78 arg_0           = dword ptr  8
.text$mn:00002E78 arg_4           = dword ptr  0Ch
.text$mn:00002E78 arg_8           = dword ptr  10h
.text$mn:00002E78
.text$mn:00002E78                 push    ebp
.text$mn:00002E79                 mov     ebp, esp
.text$mn:00002E7B                 sub     esp, 8
.text$mn:00002E7E                 mov     [ebp+var_4], ecx
.text$mn:00002E81                 mov     ecx, [ebp+arg_0]
.text$mn:00002E84                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002E89                 cmp     eax, [ebp+arg_4]
.text$mn:00002E8C                 jnb     short loc_2E96
.text$mn:00002E8E                 mov     ecx, [ebp+var_4]
.text$mn:00002E91                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002E96
.text$mn:00002E96 loc_2E96:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00002E96                 mov     ecx, [ebp+arg_0]
.text$mn:00002E99                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002E9E                 sub     eax, [ebp+arg_4]
.text$mn:00002EA1                 mov     [ebp+Size], eax
.text$mn:00002EA4                 mov     eax, [ebp+arg_8]
.text$mn:00002EA7                 cmp     eax, [ebp+Size]
.text$mn:00002EAA                 jnb     short loc_2EB2
.text$mn:00002EAC                 mov     ecx, [ebp+arg_8]
.text$mn:00002EAF                 mov     [ebp+Size], ecx
.text$mn:00002EB2
.text$mn:00002EB2 loc_2EB2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00002EB2                 mov     edx, [ebp+var_4]
.text$mn:00002EB5                 cmp     edx, [ebp+arg_0]
.text$mn:00002EB8                 jnz     short loc_2ED9
.text$mn:00002EBA                 mov     eax, [ebp+arg_4]
.text$mn:00002EBD                 add     eax, [ebp+Size]
.text$mn:00002EC0                 push    eax
.text$mn:00002EC1                 mov     ecx, [ebp+var_4]
.text$mn:00002EC4                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00002EC9                 mov     ecx, [ebp+arg_4]
.text$mn:00002ECC                 push    ecx
.text$mn:00002ECD                 push    0
.text$mn:00002ECF                 mov     ecx, [ebp+var_4]
.text$mn:00002ED2                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00002ED7                 jmp     short loc_2F1B
.text$mn:00002ED9 ; ---------------------------------------------------------------------------
.text$mn:00002ED9
.text$mn:00002ED9 loc_2ED9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00002ED9                 push    0
.text$mn:00002EDB                 mov     edx, [ebp+Size]
.text$mn:00002EDE                 push    edx
.text$mn:00002EDF                 mov     ecx, [ebp+var_4]
.text$mn:00002EE2                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002EE7                 movzx   eax, al
.text$mn:00002EEA                 test    eax, eax
.text$mn:00002EEC                 jz      short loc_2F1B
.text$mn:00002EEE                 mov     ecx, [ebp+Size]
.text$mn:00002EF1                 push    ecx             ; Size
.text$mn:00002EF2                 mov     ecx, [ebp+arg_0]
.text$mn:00002EF5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002EFA                 add     eax, [ebp+arg_4]
.text$mn:00002EFD                 push    eax             ; Src
.text$mn:00002EFE                 mov     ecx, [ebp+var_4]
.text$mn:00002F01                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002F06                 push    eax             ; Dst
.text$mn:00002F07                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002F0C                 add     esp, 0Ch
.text$mn:00002F0F                 mov     edx, [ebp+Size]
.text$mn:00002F12                 push    edx
.text$mn:00002F13                 mov     ecx, [ebp+var_4]
.text$mn:00002F16                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002F1B
.text$mn:00002F1B loc_2F1B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00002F1B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00002F1B                 mov     eax, [ebp+var_4]
.text$mn:00002F1E                 mov     esp, ebp
.text$mn:00002F20                 pop     ebp
.text$mn:00002F21                 retn    0Ch
.text$mn:00002F21 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00002F21
.text$mn:00002F21 _text$mn        ends
.text$mn:00002F21
.text$mn:00002F24 ; ===========================================================================
.text$mn:00002F24
.text$mn:00002F24 ; Segment type: Pure code
.text$mn:00002F24 ; Segment permissions: Read/Execute
.text$mn:00002F24 _text$mn        segment para public 'CODE' use32
.text$mn:00002F24                 assume cs:_text$mn
.text$mn:00002F24                 ;org 2F24h
.text$mn:00002F24 ; COMDAT (pick any)
.text$mn:00002F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F24
.text$mn:00002F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F24
.text$mn:00002F24 ; Attributes: bp-based frame
.text$mn:00002F24
.text$mn:00002F24 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00002F24                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00002F24 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00002F24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00002F24
.text$mn:00002F24 var_4           = dword ptr -4
.text$mn:00002F24 Str             = dword ptr  8
.text$mn:00002F24
.text$mn:00002F24                 push    ebp
.text$mn:00002F25                 mov     ebp, esp
.text$mn:00002F27                 push    ecx
.text$mn:00002F28                 mov     [ebp+var_4], ecx
.text$mn:00002F2B                 push    490h            ; unsigned int
.text$mn:00002F30                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002F35                 mov     eax, [ebp+Str]
.text$mn:00002F38                 push    eax             ; int
.text$mn:00002F39                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002F3E                 add     esp, 0Ch
.text$mn:00002F41                 mov     ecx, [ebp+Str]
.text$mn:00002F44                 push    ecx             ; Str
.text$mn:00002F45                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002F4A                 add     esp, 4
.text$mn:00002F4D                 push    eax             ; Size
.text$mn:00002F4E                 mov     edx, [ebp+Str]
.text$mn:00002F51                 push    edx             ; Src
.text$mn:00002F52                 mov     ecx, [ebp+var_4]
.text$mn:00002F55                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00002F5A                 mov     esp, ebp
.text$mn:00002F5C                 pop     ebp
.text$mn:00002F5D                 retn    4
.text$mn:00002F5D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00002F5D
.text$mn:00002F5D _text$mn        ends
.text$mn:00002F5D
.text$mn:00002F60 ; ===========================================================================
.text$mn:00002F60
.text$mn:00002F60 ; Segment type: Pure code
.text$mn:00002F60 ; Segment permissions: Read/Execute
.text$mn:00002F60 _text$mn        segment para public 'CODE' use32
.text$mn:00002F60                 assume cs:_text$mn
.text$mn:00002F60                 ;org 2F60h
.text$mn:00002F60 ; COMDAT (pick any)
.text$mn:00002F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F60
.text$mn:00002F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F60
.text$mn:00002F60 ; Attributes: bp-based frame
.text$mn:00002F60
.text$mn:00002F60 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00002F60                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00002F60 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00002F60                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00002F60
.text$mn:00002F60 var_4           = dword ptr -4
.text$mn:00002F60 Src             = dword ptr  8
.text$mn:00002F60 Size            = dword ptr  0Ch
.text$mn:00002F60
.text$mn:00002F60                 push    ebp
.text$mn:00002F61                 mov     ebp, esp
.text$mn:00002F63                 push    ecx
.text$mn:00002F64                 mov     [ebp+var_4], ecx
.text$mn:00002F67                 cmp     [ebp+Size], 0
.text$mn:00002F6B                 jz      short loc_2F83
.text$mn:00002F6D                 push    47Fh            ; unsigned int
.text$mn:00002F72                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002F77                 mov     eax, [ebp+Src]
.text$mn:00002F7A                 push    eax             ; int
.text$mn:00002F7B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002F80                 add     esp, 0Ch
.text$mn:00002F83
.text$mn:00002F83 loc_2F83:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00002F83                 mov     ecx, [ebp+Src]
.text$mn:00002F86                 push    ecx
.text$mn:00002F87                 mov     ecx, [ebp+var_4]
.text$mn:00002F8A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00002F8F                 movzx   edx, al
.text$mn:00002F92                 test    edx, edx
.text$mn:00002F94                 jz      short loc_2FB6
.text$mn:00002F96                 mov     eax, [ebp+Size]
.text$mn:00002F99                 push    eax
.text$mn:00002F9A                 mov     ecx, [ebp+var_4]
.text$mn:00002F9D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002FA2                 mov     ecx, [ebp+Src]
.text$mn:00002FA5                 sub     ecx, eax
.text$mn:00002FA7                 push    ecx
.text$mn:00002FA8                 mov     edx, [ebp+var_4]
.text$mn:00002FAB                 push    edx
.text$mn:00002FAC                 mov     ecx, [ebp+var_4]
.text$mn:00002FAF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002FB4                 jmp     short loc_2FF3
.text$mn:00002FB6 ; ---------------------------------------------------------------------------
.text$mn:00002FB6
.text$mn:00002FB6 loc_2FB6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00002FB6                 push    0
.text$mn:00002FB8                 mov     eax, [ebp+Size]
.text$mn:00002FBB                 push    eax
.text$mn:00002FBC                 mov     ecx, [ebp+var_4]
.text$mn:00002FBF                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002FC4                 movzx   ecx, al
.text$mn:00002FC7                 test    ecx, ecx
.text$mn:00002FC9                 jz      short loc_2FF0
.text$mn:00002FCB                 mov     edx, [ebp+Size]
.text$mn:00002FCE                 push    edx             ; Size
.text$mn:00002FCF                 mov     eax, [ebp+Src]
.text$mn:00002FD2                 push    eax             ; Src
.text$mn:00002FD3                 mov     ecx, [ebp+var_4]
.text$mn:00002FD6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002FDB                 push    eax             ; Dst
.text$mn:00002FDC                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002FE1                 add     esp, 0Ch
.text$mn:00002FE4                 mov     ecx, [ebp+Size]
.text$mn:00002FE7                 push    ecx
.text$mn:00002FE8                 mov     ecx, [ebp+var_4]
.text$mn:00002FEB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002FF0
.text$mn:00002FF0 loc_2FF0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00002FF0                 mov     eax, [ebp+var_4]
.text$mn:00002FF3
.text$mn:00002FF3 loc_2FF3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00002FF3                 mov     esp, ebp
.text$mn:00002FF5                 pop     ebp
.text$mn:00002FF6                 retn    8
.text$mn:00002FF6 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002FF6
.text$mn:00002FF6 ; ---------------------------------------------------------------------------
.text$mn:00002FF9                 align 4
.text$mn:00002FF9 _text$mn        ends
.text$mn:00002FF9
.text$mn:00002FFC ; ===========================================================================
.text$mn:00002FFC
.text$mn:00002FFC ; Segment type: Pure code
.text$mn:00002FFC ; Segment permissions: Read/Execute
.text$mn:00002FFC _text$mn        segment para public 'CODE' use32
.text$mn:00002FFC                 assume cs:_text$mn
.text$mn:00002FFC                 ;org 2FFCh
.text$mn:00002FFC ; COMDAT (pick any)
.text$mn:00002FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FFC
.text$mn:00002FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00002FFC
.text$mn:00002FFC ; Attributes: bp-based frame
.text$mn:00002FFC
.text$mn:00002FFC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00002FFC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:00002FFC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:00002FFC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+66p
.text$mn:00002FFC
.text$mn:00002FFC var_4           = dword ptr -4
.text$mn:00002FFC arg_0           = dword ptr  8
.text$mn:00002FFC
.text$mn:00002FFC                 push    ebp
.text$mn:00002FFD                 mov     ebp, esp
.text$mn:00002FFF                 push    ecx
.text$mn:00003000                 mov     [ebp+var_4], ecx
.text$mn:00003003                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00003008                 push    eax
.text$mn:00003009                 push    0
.text$mn:0000300B                 mov     ecx, [ebp+arg_0]
.text$mn:0000300E                 push    ecx
.text$mn:0000300F                 mov     ecx, [ebp+var_4]
.text$mn:00003012                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00003017                 mov     esp, ebp
.text$mn:00003019                 pop     ebp
.text$mn:0000301A                 retn    4
.text$mn:0000301A ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:0000301A
.text$mn:0000301A ; ---------------------------------------------------------------------------
.text$mn:0000301D                 align 10h
.text$mn:0000301D _text$mn        ends
.text$mn:0000301D
.text$mn:00003020 ; ===========================================================================
.text$mn:00003020
.text$mn:00003020 ; Segment type: Pure code
.text$mn:00003020 ; Segment permissions: Read/Execute
.text$mn:00003020 _text$mn        segment para public 'CODE' use32
.text$mn:00003020                 assume cs:_text$mn
.text$mn:00003020                 ;org 3020h
.text$mn:00003020 ; COMDAT (pick any)
.text$mn:00003020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003020
.text$mn:00003020 ; =============== S U B R O U T I N E =======================================
.text$mn:00003020
.text$mn:00003020 ; Attributes: bp-based frame
.text$mn:00003020
.text$mn:00003020 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00003020                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00003020 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00003020                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p
.text$mn:00003020                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00003020
.text$mn:00003020 var_8           = dword ptr -8
.text$mn:00003020 var_4           = dword ptr -4
.text$mn:00003020 arg_0           = dword ptr  8
.text$mn:00003020 arg_4           = dword ptr  0Ch
.text$mn:00003020 arg_8           = dword ptr  10h
.text$mn:00003020
.text$mn:00003020                 push    ebp
.text$mn:00003021                 mov     ebp, esp
.text$mn:00003023                 sub     esp, 8
.text$mn:00003026                 mov     [ebp+var_4], ecx
.text$mn:00003029                 mov     ecx, [ebp+arg_0]
.text$mn:0000302C                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00003031                 cmp     eax, [ebp+arg_4]
.text$mn:00003034                 jnb     short loc_303E
.text$mn:00003036                 mov     ecx, [ebp+var_4]
.text$mn:00003039                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000303E
.text$mn:0000303E loc_303E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000303E                 mov     ecx, [ebp+arg_0]
.text$mn:00003041                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00003046                 sub     eax, [ebp+arg_4]
.text$mn:00003049                 mov     [ebp+var_8], eax
.text$mn:0000304C                 mov     eax, [ebp+arg_8]
.text$mn:0000304F                 cmp     eax, [ebp+var_8]
.text$mn:00003052                 jnb     short loc_305A
.text$mn:00003054                 mov     ecx, [ebp+arg_8]
.text$mn:00003057                 mov     [ebp+var_8], ecx
.text$mn:0000305A
.text$mn:0000305A loc_305A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000305A                 mov     edx, [ebp+var_4]
.text$mn:0000305D                 cmp     edx, [ebp+arg_0]
.text$mn:00003060                 jnz     short loc_3081
.text$mn:00003062                 mov     eax, [ebp+arg_4]
.text$mn:00003065                 add     eax, [ebp+var_8]
.text$mn:00003068                 push    eax
.text$mn:00003069                 mov     ecx, [ebp+var_4]
.text$mn:0000306C                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00003071                 mov     ecx, [ebp+arg_4]
.text$mn:00003074                 push    ecx
.text$mn:00003075                 push    0
.text$mn:00003077                 mov     ecx, [ebp+var_4]
.text$mn:0000307A                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000307F                 jmp     short loc_30C6
.text$mn:00003081 ; ---------------------------------------------------------------------------
.text$mn:00003081
.text$mn:00003081 loc_3081:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00003081                 push    0
.text$mn:00003083                 mov     edx, [ebp+var_8]
.text$mn:00003086                 push    edx
.text$mn:00003087                 mov     ecx, [ebp+var_4]
.text$mn:0000308A                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000308F                 movzx   eax, al
.text$mn:00003092                 test    eax, eax
.text$mn:00003094                 jz      short loc_30C6
.text$mn:00003096                 mov     ecx, [ebp+var_8]
.text$mn:00003099                 push    ecx             ; int
.text$mn:0000309A                 mov     ecx, [ebp+arg_0]
.text$mn:0000309D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000030A2                 mov     edx, [ebp+arg_4]
.text$mn:000030A5                 lea     eax, [eax+edx*2]
.text$mn:000030A8                 push    eax             ; Src
.text$mn:000030A9                 mov     ecx, [ebp+var_4]
.text$mn:000030AC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000030B1                 push    eax             ; Dst
.text$mn:000030B2                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000030B7                 add     esp, 0Ch
.text$mn:000030BA                 mov     ecx, [ebp+var_8]
.text$mn:000030BD                 push    ecx
.text$mn:000030BE                 mov     ecx, [ebp+var_4]
.text$mn:000030C1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000030C6
.text$mn:000030C6 loc_30C6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:000030C6                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:000030C6                 mov     eax, [ebp+var_4]
.text$mn:000030C9                 mov     esp, ebp
.text$mn:000030CB                 pop     ebp
.text$mn:000030CC                 retn    0Ch
.text$mn:000030CC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000030CC
.text$mn:000030CC ; ---------------------------------------------------------------------------
.text$mn:000030CF                 align 10h
.text$mn:000030CF _text$mn        ends
.text$mn:000030CF
.text$mn:000030D0 ; ===========================================================================
.text$mn:000030D0
.text$mn:000030D0 ; Segment type: Pure code
.text$mn:000030D0 ; Segment permissions: Read/Execute
.text$mn:000030D0 _text$mn        segment para public 'CODE' use32
.text$mn:000030D0                 assume cs:_text$mn
.text$mn:000030D0                 ;org 30D0h
.text$mn:000030D0 ; COMDAT (pick any)
.text$mn:000030D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030D0
.text$mn:000030D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030D0
.text$mn:000030D0 ; Attributes: bp-based frame
.text$mn:000030D0
.text$mn:000030D0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:000030D0                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:000030D0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:000030D0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:000030D0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:000030D0
.text$mn:000030D0 var_4           = dword ptr -4
.text$mn:000030D0 Str             = dword ptr  8
.text$mn:000030D0
.text$mn:000030D0                 push    ebp
.text$mn:000030D1                 mov     ebp, esp
.text$mn:000030D3                 push    ecx
.text$mn:000030D4                 mov     [ebp+var_4], ecx
.text$mn:000030D7                 push    490h            ; unsigned int
.text$mn:000030DC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000030E1                 mov     eax, [ebp+Str]
.text$mn:000030E4                 push    eax             ; int
.text$mn:000030E5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000030EA                 add     esp, 0Ch
.text$mn:000030ED                 mov     ecx, [ebp+Str]
.text$mn:000030F0                 push    ecx             ; Str
.text$mn:000030F1                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000030F6                 add     esp, 4
.text$mn:000030F9                 push    eax             ; int
.text$mn:000030FA                 mov     edx, [ebp+Str]
.text$mn:000030FD                 push    edx             ; Src
.text$mn:000030FE                 mov     ecx, [ebp+var_4]
.text$mn:00003101                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00003106                 mov     esp, ebp
.text$mn:00003108                 pop     ebp
.text$mn:00003109                 retn    4
.text$mn:00003109 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00003109
.text$mn:00003109 _text$mn        ends
.text$mn:00003109
.text$mn:0000310C ; ===========================================================================
.text$mn:0000310C
.text$mn:0000310C ; Segment type: Pure code
.text$mn:0000310C ; Segment permissions: Read/Execute
.text$mn:0000310C _text$mn        segment para public 'CODE' use32
.text$mn:0000310C                 assume cs:_text$mn
.text$mn:0000310C                 ;org 310Ch
.text$mn:0000310C ; COMDAT (pick any)
.text$mn:0000310C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000310C
.text$mn:0000310C ; =============== S U B R O U T I N E =======================================
.text$mn:0000310C
.text$mn:0000310C ; Attributes: bp-based frame
.text$mn:0000310C
.text$mn:0000310C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:0000310C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000310C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000310C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:0000310C
.text$mn:0000310C var_4           = dword ptr -4
.text$mn:0000310C Src             = dword ptr  8
.text$mn:0000310C arg_4           = dword ptr  0Ch
.text$mn:0000310C
.text$mn:0000310C                 push    ebp
.text$mn:0000310D                 mov     ebp, esp
.text$mn:0000310F                 push    ecx
.text$mn:00003110                 mov     [ebp+var_4], ecx
.text$mn:00003113                 cmp     [ebp+arg_4], 0
.text$mn:00003117                 jz      short loc_312F
.text$mn:00003119                 push    47Fh            ; unsigned int
.text$mn:0000311E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003123                 mov     eax, [ebp+Src]
.text$mn:00003126                 push    eax             ; int
.text$mn:00003127                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000312C                 add     esp, 0Ch
.text$mn:0000312F
.text$mn:0000312F loc_312F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:0000312F                 mov     ecx, [ebp+Src]
.text$mn:00003132                 push    ecx
.text$mn:00003133                 mov     ecx, [ebp+var_4]
.text$mn:00003136                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000313B                 movzx   edx, al
.text$mn:0000313E                 test    edx, edx
.text$mn:00003140                 jz      short loc_3164
.text$mn:00003142                 mov     eax, [ebp+arg_4]
.text$mn:00003145                 push    eax
.text$mn:00003146                 mov     ecx, [ebp+var_4]
.text$mn:00003149                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000314E                 mov     ecx, [ebp+Src]
.text$mn:00003151                 sub     ecx, eax
.text$mn:00003153                 sar     ecx, 1
.text$mn:00003155                 push    ecx
.text$mn:00003156                 mov     edx, [ebp+var_4]
.text$mn:00003159                 push    edx
.text$mn:0000315A                 mov     ecx, [ebp+var_4]
.text$mn:0000315D                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00003162                 jmp     short loc_31A1
.text$mn:00003164 ; ---------------------------------------------------------------------------
.text$mn:00003164
.text$mn:00003164 loc_3164:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00003164                 push    0
.text$mn:00003166                 mov     eax, [ebp+arg_4]
.text$mn:00003169                 push    eax
.text$mn:0000316A                 mov     ecx, [ebp+var_4]
.text$mn:0000316D                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00003172                 movzx   ecx, al
.text$mn:00003175                 test    ecx, ecx
.text$mn:00003177                 jz      short loc_319E
.text$mn:00003179                 mov     edx, [ebp+arg_4]
.text$mn:0000317C                 push    edx             ; int
.text$mn:0000317D                 mov     eax, [ebp+Src]
.text$mn:00003180                 push    eax             ; Src
.text$mn:00003181                 mov     ecx, [ebp+var_4]
.text$mn:00003184                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003189                 push    eax             ; Dst
.text$mn:0000318A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000318F                 add     esp, 0Ch
.text$mn:00003192                 mov     ecx, [ebp+arg_4]
.text$mn:00003195                 push    ecx
.text$mn:00003196                 mov     ecx, [ebp+var_4]
.text$mn:00003199                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000319E
.text$mn:0000319E loc_319E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000319E                 mov     eax, [ebp+var_4]
.text$mn:000031A1
.text$mn:000031A1 loc_31A1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:000031A1                 mov     esp, ebp
.text$mn:000031A3                 pop     ebp
.text$mn:000031A4                 retn    8
.text$mn:000031A4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:000031A4
.text$mn:000031A4 ; ---------------------------------------------------------------------------
.text$mn:000031A7                 align 4
.text$mn:000031A7 _text$mn        ends
.text$mn:000031A7
.text$mn:000031A8 ; ===========================================================================
.text$mn:000031A8
.text$mn:000031A8 ; Segment type: Pure code
.text$mn:000031A8 ; Segment permissions: Read/Execute
.text$mn:000031A8 _text$mn        segment para public 'CODE' use32
.text$mn:000031A8                 assume cs:_text$mn
.text$mn:000031A8                 ;org 31A8h
.text$mn:000031A8 ; COMDAT (pick any)
.text$mn:000031A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031A8
.text$mn:000031A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000031A8
.text$mn:000031A8 ; Attributes: bp-based frame
.text$mn:000031A8
.text$mn:000031A8 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000031A8                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000031A8 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000031A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000031A8
.text$mn:000031A8 arg_0           = dword ptr  8
.text$mn:000031A8 arg_4           = dword ptr  0Ch
.text$mn:000031A8
.text$mn:000031A8                 push    ebp
.text$mn:000031A9                 mov     ebp, esp
.text$mn:000031AB                 mov     eax, [ebp+arg_0]
.text$mn:000031AE                 mov     ecx, [ebp+arg_4]
.text$mn:000031B1                 mov     dl, [ecx]
.text$mn:000031B3                 mov     [eax], dl
.text$mn:000031B5                 pop     ebp
.text$mn:000031B6                 retn
.text$mn:000031B6 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000031B6
.text$mn:000031B6 ; ---------------------------------------------------------------------------
.text$mn:000031B7                 align 4
.text$mn:000031B7 _text$mn        ends
.text$mn:000031B7
.text$mn:000031B8 ; ===========================================================================
.text$mn:000031B8
.text$mn:000031B8 ; Segment type: Pure code
.text$mn:000031B8 ; Segment permissions: Read/Execute
.text$mn:000031B8 _text$mn        segment para public 'CODE' use32
.text$mn:000031B8                 assume cs:_text$mn
.text$mn:000031B8                 ;org 31B8h
.text$mn:000031B8 ; COMDAT (pick any)
.text$mn:000031B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031B8
.text$mn:000031B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000031B8
.text$mn:000031B8 ; Attributes: bp-based frame
.text$mn:000031B8
.text$mn:000031B8 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:000031B8                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:000031B8 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:000031B8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:000031B8
.text$mn:000031B8 arg_0           = dword ptr  8
.text$mn:000031B8 arg_4           = dword ptr  0Ch
.text$mn:000031B8
.text$mn:000031B8                 push    ebp
.text$mn:000031B9                 mov     ebp, esp
.text$mn:000031BB                 mov     eax, [ebp+arg_0]
.text$mn:000031BE                 mov     ecx, [ebp+arg_4]
.text$mn:000031C1                 mov     dx, [ecx]
.text$mn:000031C4                 mov     [eax], dx
.text$mn:000031C7                 pop     ebp
.text$mn:000031C8                 retn
.text$mn:000031C8 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:000031C8
.text$mn:000031C8 ; ---------------------------------------------------------------------------
.text$mn:000031C9                 align 4
.text$mn:000031C9 _text$mn        ends
.text$mn:000031C9
.text$mn:000031CC ; ===========================================================================
.text$mn:000031CC
.text$mn:000031CC ; Segment type: Pure code
.text$mn:000031CC ; Segment permissions: Read/Execute
.text$mn:000031CC _text$mn        segment para public 'CODE' use32
.text$mn:000031CC                 assume cs:_text$mn
.text$mn:000031CC                 ;org 31CCh
.text$mn:000031CC ; COMDAT (pick any)
.text$mn:000031CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031CC
.text$mn:000031CC ; =============== S U B R O U T I N E =======================================
.text$mn:000031CC
.text$mn:000031CC ; Attributes: bp-based frame
.text$mn:000031CC
.text$mn:000031CC ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:000031CC                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:000031CC ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:000031CC                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+120p
.text$mn:000031CC                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+175p ...
.text$mn:000031CC
.text$mn:000031CC var_4           = dword ptr -4
.text$mn:000031CC
.text$mn:000031CC                 push    ebp
.text$mn:000031CD                 mov     ebp, esp
.text$mn:000031CF                 push    ecx
.text$mn:000031D0                 mov     [ebp+var_4], ecx
.text$mn:000031D3                 mov     ecx, [ebp+var_4]
.text$mn:000031D6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000031DB                 mov     esp, ebp
.text$mn:000031DD                 pop     ebp
.text$mn:000031DE                 retn
.text$mn:000031DE ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:000031DE
.text$mn:000031DE ; ---------------------------------------------------------------------------
.text$mn:000031DF                 align 10h
.text$mn:000031DF _text$mn        ends
.text$mn:000031DF
.text$mn:000031E0 ; ===========================================================================
.text$mn:000031E0
.text$mn:000031E0 ; Segment type: Pure code
.text$mn:000031E0 ; Segment permissions: Read/Execute
.text$mn:000031E0 _text$mn        segment para public 'CODE' use32
.text$mn:000031E0                 assume cs:_text$mn
.text$mn:000031E0                 ;org 31E0h
.text$mn:000031E0 ; COMDAT (pick any)
.text$mn:000031E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031E0
.text$mn:000031E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031E0
.text$mn:000031E0 ; Attributes: bp-based frame
.text$mn:000031E0
.text$mn:000031E0 ; public: unsigned int __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::capacity(void)const
.text$mn:000031E0                 public ?capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ
.text$mn:000031E0 ?capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ proc near
.text$mn:000031E0                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Grow_to(uint)+Cp
.text$mn:000031E0
.text$mn:000031E0 var_4           = dword ptr -4
.text$mn:000031E0
.text$mn:000031E0                 push    ebp
.text$mn:000031E1                 mov     ebp, esp
.text$mn:000031E3                 push    ecx
.text$mn:000031E4                 mov     [ebp+var_4], ecx
.text$mn:000031E7                 mov     eax, [ebp+var_4]
.text$mn:000031EA                 mov     ecx, [ebp+var_4]
.text$mn:000031ED                 mov     eax, [eax+0Ch]
.text$mn:000031F0                 sub     eax, [ecx+4]
.text$mn:000031F3                 sar     eax, 2
.text$mn:000031F6                 mov     esp, ebp
.text$mn:000031F8                 pop     ebp
.text$mn:000031F9                 retn
.text$mn:000031F9 ?capacity@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ endp
.text$mn:000031F9
.text$mn:000031F9 ; ---------------------------------------------------------------------------
.text$mn:000031FA                 align 4
.text$mn:000031FA _text$mn        ends
.text$mn:000031FA
.text$mn:000031FC ; ===========================================================================
.text$mn:000031FC
.text$mn:000031FC ; Segment type: Pure code
.text$mn:000031FC ; Segment permissions: Read/Execute
.text$mn:000031FC _text$mn        segment para public 'CODE' use32
.text$mn:000031FC                 assume cs:_text$mn
.text$mn:000031FC                 ;org 31FCh
.text$mn:000031FC ; COMDAT (pick any)
.text$mn:000031FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031FC
.text$mn:000031FC ; =============== S U B R O U T I N E =======================================
.text$mn:000031FC
.text$mn:000031FC ; Attributes: bp-based frame
.text$mn:000031FC
.text$mn:000031FC ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000031FC                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000031FC ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000031FC                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000031FC
.text$mn:000031FC var_4           = dword ptr -4
.text$mn:000031FC
.text$mn:000031FC                 push    ebp
.text$mn:000031FD                 mov     ebp, esp
.text$mn:000031FF                 push    ecx
.text$mn:00003200                 mov     [ebp+var_4], ecx
.text$mn:00003203                 mov     eax, [ebp+var_4]
.text$mn:00003206                 mov     eax, [eax+4]
.text$mn:00003209                 mov     esp, ebp
.text$mn:0000320B                 pop     ebp
.text$mn:0000320C                 retn
.text$mn:0000320C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000320C
.text$mn:0000320C ; ---------------------------------------------------------------------------
.text$mn:0000320D                 align 10h
.text$mn:0000320D _text$mn        ends
.text$mn:0000320D
.text$mn:00003210 ; ===========================================================================
.text$mn:00003210
.text$mn:00003210 ; Segment type: Pure code
.text$mn:00003210 ; Segment permissions: Read/Execute
.text$mn:00003210 _text$mn        segment para public 'CODE' use32
.text$mn:00003210                 assume cs:_text$mn
.text$mn:00003210                 ;org 3210h
.text$mn:00003210 ; COMDAT (pick any)
.text$mn:00003210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003210
.text$mn:00003210 ; =============== S U B R O U T I N E =======================================
.text$mn:00003210
.text$mn:00003210 ; Attributes: bp-based frame
.text$mn:00003210
.text$mn:00003210 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00003210                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00003210 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00003210                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00003210                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00003210
.text$mn:00003210 var_4           = dword ptr -4
.text$mn:00003210
.text$mn:00003210                 push    ebp
.text$mn:00003211                 mov     ebp, esp
.text$mn:00003213                 push    ecx
.text$mn:00003214                 mov     [ebp+var_4], ecx
.text$mn:00003217                 mov     eax, [ebp+var_4]
.text$mn:0000321A                 mov     eax, [eax+4]
.text$mn:0000321D                 mov     esp, ebp
.text$mn:0000321F                 pop     ebp
.text$mn:00003220                 retn
.text$mn:00003220 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00003220
.text$mn:00003220 ; ---------------------------------------------------------------------------
.text$mn:00003221                 align 4
.text$mn:00003221 _text$mn        ends
.text$mn:00003221
.text$mn:00003224 ; ===========================================================================
.text$mn:00003224
.text$mn:00003224 ; Segment type: Pure code
.text$mn:00003224 ; Segment permissions: Read/Execute
.text$mn:00003224 _text$mn        segment para public 'CODE' use32
.text$mn:00003224                 assume cs:_text$mn
.text$mn:00003224                 ;org 3224h
.text$mn:00003224 ; COMDAT (pick any)
.text$mn:00003224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003224
.text$mn:00003224 ; =============== S U B R O U T I N E =======================================
.text$mn:00003224
.text$mn:00003224 ; Attributes: bp-based frame
.text$mn:00003224
.text$mn:00003224 ; void __thiscall ContextMenu::checkItem(ContextMenu *this, UINT uIDCheckItem, bool)
.text$mn:00003224                 public ?checkItem@ContextMenu@@QBEXH_N@Z
.text$mn:00003224 ?checkItem@ContextMenu@@QBEXH_N@Z proc near
.text$mn:00003224                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+2D4p
.text$mn:00003224
.text$mn:00003224 var_8           = dword ptr -8
.text$mn:00003224 uCheck          = dword ptr -4
.text$mn:00003224 uIDCheckItem    = dword ptr  8
.text$mn:00003224 arg_4           = byte ptr  0Ch
.text$mn:00003224
.text$mn:00003224                 push    ebp
.text$mn:00003225                 mov     ebp, esp
.text$mn:00003227                 sub     esp, 8
.text$mn:0000322A                 mov     [ebp+var_8], ecx
.text$mn:0000322D                 movzx   eax, [ebp+arg_4]
.text$mn:00003231                 test    eax, eax
.text$mn:00003233                 jz      short loc_323E
.text$mn:00003235                 mov     [ebp+uCheck], 8
.text$mn:0000323C                 jmp     short loc_3245
.text$mn:0000323E ; ---------------------------------------------------------------------------
.text$mn:0000323E
.text$mn:0000323E loc_323E:                               ; CODE XREF: ContextMenu::checkItem(int,bool)+Fj
.text$mn:0000323E                 mov     [ebp+uCheck], 0
.text$mn:00003245
.text$mn:00003245 loc_3245:                               ; CODE XREF: ContextMenu::checkItem(int,bool)+18j
.text$mn:00003245                 mov     ecx, [ebp+uCheck]
.text$mn:00003248                 push    ecx             ; uCheck
.text$mn:00003249                 mov     edx, [ebp+uIDCheckItem]
.text$mn:0000324C                 push    edx             ; uIDCheckItem
.text$mn:0000324D                 mov     eax, [ebp+var_8]
.text$mn:00003250                 mov     ecx, [eax+4]
.text$mn:00003253                 push    ecx             ; hMenu
.text$mn:00003254                 call    dword ptr ds:__imp__CheckMenuItem@12 ; CheckMenuItem(x,x,x)
.text$mn:0000325A                 mov     esp, ebp
.text$mn:0000325C                 pop     ebp
.text$mn:0000325D                 retn    8
.text$mn:0000325D ?checkItem@ContextMenu@@QBEXH_N@Z endp
.text$mn:0000325D
.text$mn:0000325D _text$mn        ends
.text$mn:0000325D
.text$mn:00003260 ; ===========================================================================
.text$mn:00003260
.text$mn:00003260 ; Segment type: Pure code
.text$mn:00003260 ; Segment permissions: Read/Execute
.text$mn:00003260 _text$mn        segment para public 'CODE' use32
.text$mn:00003260                 assume cs:_text$mn
.text$mn:00003260                 ;org 3260h
.text$mn:00003260 ; COMDAT (pick any)
.text$mn:00003260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003260
.text$mn:00003260 ; =============== S U B R O U T I N E =======================================
.text$mn:00003260
.text$mn:00003260 ; Attributes: bp-based frame
.text$mn:00003260
.text$mn:00003260 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)const
.text$mn:00003260                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z
.text$mn:00003260 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z proc near
.text$mn:00003260                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Bp
.text$mn:00003260
.text$mn:00003260 var_4           = dword ptr -4
.text$mn:00003260 arg_0           = dword ptr  8
.text$mn:00003260
.text$mn:00003260                 push    ebp
.text$mn:00003261                 mov     ebp, esp
.text$mn:00003263                 push    ecx
.text$mn:00003264                 mov     [ebp+var_4], ecx
.text$mn:00003267                 mov     ecx, [ebp+arg_0]
.text$mn:0000326A                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000326F                 push    eax
.text$mn:00003270                 mov     ecx, [ebp+arg_0]
.text$mn:00003273                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003278                 push    eax
.text$mn:00003279                 mov     eax, [ebp+var_4]
.text$mn:0000327C                 mov     ecx, [eax+14h]
.text$mn:0000327F                 push    ecx
.text$mn:00003280                 push    0
.text$mn:00003282                 mov     ecx, [ebp+var_4]
.text$mn:00003285                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:0000328A                 mov     esp, ebp
.text$mn:0000328C                 pop     ebp
.text$mn:0000328D                 retn    4
.text$mn:0000328D ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z endp
.text$mn:0000328D
.text$mn:0000328D _text$mn        ends
.text$mn:0000328D
.text$mn:00003290 ; ===========================================================================
.text$mn:00003290
.text$mn:00003290 ; Segment type: Pure code
.text$mn:00003290 ; Segment permissions: Read/Execute
.text$mn:00003290 _text$mn        segment para public 'CODE' use32
.text$mn:00003290                 assume cs:_text$mn
.text$mn:00003290                 ;org 3290h
.text$mn:00003290 ; COMDAT (pick any)
.text$mn:00003290                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003290
.text$mn:00003290 ; =============== S U B R O U T I N E =======================================
.text$mn:00003290
.text$mn:00003290 ; Attributes: bp-based frame
.text$mn:00003290
.text$mn:00003290 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:00003290                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:00003290 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:00003290                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+25p
.text$mn:00003290                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:00003290
.text$mn:00003290 var_18          = dword ptr -18h
.text$mn:00003290 var_14          = dword ptr -14h
.text$mn:00003290 var_10          = dword ptr -10h
.text$mn:00003290 var_C           = dword ptr -0Ch
.text$mn:00003290 var_8           = dword ptr -8
.text$mn:00003290 var_4           = dword ptr -4
.text$mn:00003290 arg_0           = dword ptr  8
.text$mn:00003290 arg_4           = dword ptr  0Ch
.text$mn:00003290 arg_8           = dword ptr  10h
.text$mn:00003290 arg_C           = dword ptr  14h
.text$mn:00003290
.text$mn:00003290                 push    ebp
.text$mn:00003291                 mov     ebp, esp
.text$mn:00003293                 sub     esp, 18h
.text$mn:00003296                 mov     [ebp+var_4], ecx
.text$mn:00003299                 cmp     [ebp+arg_C], 0
.text$mn:0000329D                 jz      short loc_32B5
.text$mn:0000329F                 push    87Dh            ; unsigned int
.text$mn:000032A4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000032A9                 mov     eax, [ebp+arg_8]
.text$mn:000032AC                 push    eax             ; int
.text$mn:000032AD                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000032B2                 add     esp, 0Ch
.text$mn:000032B5
.text$mn:000032B5 loc_32B5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:000032B5                 mov     ecx, [ebp+var_4]
.text$mn:000032B8                 mov     edx, [ecx+14h]
.text$mn:000032BB                 cmp     edx, [ebp+arg_0]
.text$mn:000032BE                 jnb     short loc_32C8
.text$mn:000032C0                 mov     ecx, [ebp+var_4]
.text$mn:000032C3                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000032C8
.text$mn:000032C8 loc_32C8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:000032C8                 mov     eax, [ebp+var_4]
.text$mn:000032CB                 mov     ecx, [eax+14h]
.text$mn:000032CE                 sub     ecx, [ebp+arg_0]
.text$mn:000032D1                 cmp     ecx, [ebp+arg_4]
.text$mn:000032D4                 jnb     short loc_32E2
.text$mn:000032D6                 mov     edx, [ebp+var_4]
.text$mn:000032D9                 mov     eax, [edx+14h]
.text$mn:000032DC                 sub     eax, [ebp+arg_0]
.text$mn:000032DF                 mov     [ebp+arg_4], eax
.text$mn:000032E2
.text$mn:000032E2 loc_32E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:000032E2                 mov     ecx, [ebp+arg_4]
.text$mn:000032E5                 cmp     ecx, [ebp+arg_C]
.text$mn:000032E8                 jnb     short loc_32F2
.text$mn:000032EA                 mov     edx, [ebp+arg_4]
.text$mn:000032ED                 mov     [ebp+var_8], edx
.text$mn:000032F0                 jmp     short loc_32F8
.text$mn:000032F2 ; ---------------------------------------------------------------------------
.text$mn:000032F2
.text$mn:000032F2 loc_32F2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:000032F2                 mov     eax, [ebp+arg_C]
.text$mn:000032F5                 mov     [ebp+var_8], eax
.text$mn:000032F8
.text$mn:000032F8 loc_32F8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:000032F8                 mov     ecx, [ebp+var_8]
.text$mn:000032FB                 push    ecx
.text$mn:000032FC                 mov     edx, [ebp+arg_8]
.text$mn:000032FF                 push    edx
.text$mn:00003300                 mov     ecx, [ebp+var_4]
.text$mn:00003303                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003308                 mov     ecx, [ebp+arg_0]
.text$mn:0000330B                 lea     edx, [eax+ecx*2]
.text$mn:0000330E                 push    edx
.text$mn:0000330F                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:00003314                 add     esp, 0Ch
.text$mn:00003317                 mov     [ebp+var_C], eax
.text$mn:0000331A                 cmp     [ebp+var_C], 0
.text$mn:0000331E                 jz      short loc_3328
.text$mn:00003320                 mov     eax, [ebp+var_C]
.text$mn:00003323                 mov     [ebp+var_18], eax
.text$mn:00003326                 jmp     short loc_335D
.text$mn:00003328 ; ---------------------------------------------------------------------------
.text$mn:00003328
.text$mn:00003328 loc_3328:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:00003328                 mov     ecx, [ebp+arg_4]
.text$mn:0000332B                 cmp     ecx, [ebp+arg_C]
.text$mn:0000332E                 jnb     short loc_3339
.text$mn:00003330                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:00003337                 jmp     short loc_3357
.text$mn:00003339 ; ---------------------------------------------------------------------------
.text$mn:00003339
.text$mn:00003339 loc_3339:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:00003339                 mov     edx, [ebp+arg_4]
.text$mn:0000333C                 cmp     edx, [ebp+arg_C]
.text$mn:0000333F                 jnz     short loc_334A
.text$mn:00003341                 mov     [ebp+var_10], 0
.text$mn:00003348                 jmp     short loc_3351
.text$mn:0000334A ; ---------------------------------------------------------------------------
.text$mn:0000334A
.text$mn:0000334A loc_334A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:0000334A                 mov     [ebp+var_10], 1
.text$mn:00003351
.text$mn:00003351 loc_3351:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:00003351                 mov     eax, [ebp+var_10]
.text$mn:00003354                 mov     [ebp+var_14], eax
.text$mn:00003357
.text$mn:00003357 loc_3357:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:00003357                 mov     ecx, [ebp+var_14]
.text$mn:0000335A                 mov     [ebp+var_18], ecx
.text$mn:0000335D
.text$mn:0000335D loc_335D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:0000335D                 mov     eax, [ebp+var_18]
.text$mn:00003360                 mov     esp, ebp
.text$mn:00003362                 pop     ebp
.text$mn:00003363                 retn    10h
.text$mn:00003363 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:00003363
.text$mn:00003363 ; ---------------------------------------------------------------------------
.text$mn:00003366                 align 4
.text$mn:00003366 _text$mn        ends
.text$mn:00003366
.text$mn:00003368 ; ===========================================================================
.text$mn:00003368
.text$mn:00003368 ; Segment type: Pure code
.text$mn:00003368 ; Segment permissions: Read/Execute
.text$mn:00003368 _text$mn        segment para public 'CODE' use32
.text$mn:00003368                 assume cs:_text$mn
.text$mn:00003368                 ;org 3368h
.text$mn:00003368 ; COMDAT (pick any)
.text$mn:00003368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003368
.text$mn:00003368 ; =============== S U B R O U T I N E =======================================
.text$mn:00003368
.text$mn:00003368 ; Attributes: bp-based frame
.text$mn:00003368
.text$mn:00003368 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:00003368                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:00003368 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:00003368                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:00003368
.text$mn:00003368 var_4           = dword ptr -4
.text$mn:00003368 Str             = dword ptr  8
.text$mn:00003368
.text$mn:00003368                 push    ebp
.text$mn:00003369                 mov     ebp, esp
.text$mn:0000336B                 push    ecx
.text$mn:0000336C                 mov     [ebp+var_4], ecx
.text$mn:0000336F                 push    86Eh            ; unsigned int
.text$mn:00003374                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003379                 mov     eax, [ebp+Str]
.text$mn:0000337C                 push    eax             ; int
.text$mn:0000337D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00003382                 add     esp, 0Ch
.text$mn:00003385                 mov     ecx, [ebp+Str]
.text$mn:00003388                 push    ecx             ; Str
.text$mn:00003389                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000338E                 add     esp, 4
.text$mn:00003391                 push    eax
.text$mn:00003392                 mov     edx, [ebp+Str]
.text$mn:00003395                 push    edx
.text$mn:00003396                 mov     eax, [ebp+var_4]
.text$mn:00003399                 mov     ecx, [eax+14h]
.text$mn:0000339C                 push    ecx
.text$mn:0000339D                 push    0
.text$mn:0000339F                 mov     ecx, [ebp+var_4]
.text$mn:000033A2                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:000033A7                 mov     esp, ebp
.text$mn:000033A9                 pop     ebp
.text$mn:000033AA                 retn    4
.text$mn:000033AA ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:000033AA
.text$mn:000033AA ; ---------------------------------------------------------------------------
.text$mn:000033AD                 align 10h
.text$mn:000033AD _text$mn        ends
.text$mn:000033AD
.text$mn:000033B0 ; ===========================================================================
.text$mn:000033B0
.text$mn:000033B0 ; Segment type: Pure code
.text$mn:000033B0 ; Segment permissions: Read/Execute
.text$mn:000033B0 _text$mn        segment para public 'CODE' use32
.text$mn:000033B0                 assume cs:_text$mn
.text$mn:000033B0                 ;org 33B0h
.text$mn:000033B0 ; COMDAT (pick any)
.text$mn:000033B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033B0
.text$mn:000033B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033B0
.text$mn:000033B0 ; Attributes: bp-based frame
.text$mn:000033B0
.text$mn:000033B0 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:000033B0                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:000033B0 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:000033B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:000033B0
.text$mn:000033B0 var_4           = dword ptr -4
.text$mn:000033B0 arg_0           = dword ptr  8
.text$mn:000033B0 arg_4           = dword ptr  0Ch
.text$mn:000033B0 arg_8           = dword ptr  10h
.text$mn:000033B0
.text$mn:000033B0                 push    ebp
.text$mn:000033B1                 mov     ebp, esp
.text$mn:000033B3                 push    ecx
.text$mn:000033B4                 cmp     [ebp+arg_8], 0
.text$mn:000033B8                 jnz     short loc_33C3
.text$mn:000033BA                 mov     [ebp+var_4], 0
.text$mn:000033C1                 jmp     short loc_33DA
.text$mn:000033C3 ; ---------------------------------------------------------------------------
.text$mn:000033C3
.text$mn:000033C3 loc_33C3:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:000033C3                 mov     eax, [ebp+arg_8]
.text$mn:000033C6                 push    eax
.text$mn:000033C7                 mov     ecx, [ebp+arg_4]
.text$mn:000033CA                 push    ecx
.text$mn:000033CB                 mov     edx, [ebp+arg_0]
.text$mn:000033CE                 push    edx
.text$mn:000033CF                 call    _wmemcmp
.text$mn:000033D4                 add     esp, 0Ch
.text$mn:000033D7                 mov     [ebp+var_4], eax
.text$mn:000033DA
.text$mn:000033DA loc_33DA:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:000033DA                 mov     eax, [ebp+var_4]
.text$mn:000033DD                 mov     esp, ebp
.text$mn:000033DF                 pop     ebp
.text$mn:000033E0                 retn
.text$mn:000033E0 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:000033E0
.text$mn:000033E0 ; ---------------------------------------------------------------------------
.text$mn:000033E1                 align 4
.text$mn:000033E1 _text$mn        ends
.text$mn:000033E1
.text$mn:000033E4 ; ===========================================================================
.text$mn:000033E4
.text$mn:000033E4 ; Segment type: Pure code
.text$mn:000033E4 ; Segment permissions: Read/Execute
.text$mn:000033E4 _text$mn        segment para public 'CODE' use32
.text$mn:000033E4                 assume cs:_text$mn
.text$mn:000033E4                 ;org 33E4h
.text$mn:000033E4 ; COMDAT (pick any)
.text$mn:000033E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033E4
.text$mn:000033E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000033E4
.text$mn:000033E4 ; Attributes: bp-based frame
.text$mn:000033E4
.text$mn:000033E4 ; int __stdcall std::allocator<HMENU__ *>::construct(void *, int)
.text$mn:000033E4                 public ?construct@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@ABQAU3@@Z
.text$mn:000033E4 ?construct@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@ABQAU3@@Z proc near
.text$mn:000033E4                                         ; CODE XREF: std::allocator_traits<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(std::allocator<HMENU__ *> &,HMENU__ * *,HMENU__ * const &)+17p
.text$mn:000033E4
.text$mn:000033E4 var_C           = dword ptr -0Ch
.text$mn:000033E4 var_8           = dword ptr -8
.text$mn:000033E4 var_4           = dword ptr -4
.text$mn:000033E4 arg_0           = dword ptr  8
.text$mn:000033E4 arg_4           = dword ptr  0Ch
.text$mn:000033E4
.text$mn:000033E4                 push    ebp
.text$mn:000033E5                 mov     ebp, esp
.text$mn:000033E7                 sub     esp, 0Ch
.text$mn:000033EA                 mov     [ebp+var_C], ecx
.text$mn:000033ED                 mov     eax, [ebp+arg_0]
.text$mn:000033F0                 push    eax             ; void *
.text$mn:000033F1                 push    4               ; unsigned int
.text$mn:000033F3                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000033F8                 add     esp, 8
.text$mn:000033FB                 mov     [ebp+var_4], eax
.text$mn:000033FE                 cmp     [ebp+var_4], 0
.text$mn:00003402                 jz      short loc_3416
.text$mn:00003404                 mov     ecx, [ebp+var_4]
.text$mn:00003407                 mov     edx, [ebp+arg_4]
.text$mn:0000340A                 mov     eax, [edx]
.text$mn:0000340C                 mov     [ecx], eax
.text$mn:0000340E                 mov     ecx, [ebp+var_4]
.text$mn:00003411                 mov     [ebp+var_8], ecx
.text$mn:00003414                 jmp     short loc_341D
.text$mn:00003416 ; ---------------------------------------------------------------------------
.text$mn:00003416
.text$mn:00003416 loc_3416:                               ; CODE XREF: std::allocator<HMENU__ *>::construct(HMENU__ * *,HMENU__ * const &)+1Ej
.text$mn:00003416                 mov     [ebp+var_8], 0
.text$mn:0000341D
.text$mn:0000341D loc_341D:                               ; CODE XREF: std::allocator<HMENU__ *>::construct(HMENU__ * *,HMENU__ * const &)+30j
.text$mn:0000341D                 mov     esp, ebp
.text$mn:0000341F                 pop     ebp
.text$mn:00003420                 retn    8
.text$mn:00003420 ?construct@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@ABQAU3@@Z endp
.text$mn:00003420
.text$mn:00003420 ; ---------------------------------------------------------------------------
.text$mn:00003423                 align 4
.text$mn:00003423 _text$mn        ends
.text$mn:00003423
.text$mn:00003424 ; ===========================================================================
.text$mn:00003424
.text$mn:00003424 ; Segment type: Pure code
.text$mn:00003424 ; Segment permissions: Read/Execute
.text$mn:00003424 _text$mn        segment para public 'CODE' use32
.text$mn:00003424                 assume cs:_text$mn
.text$mn:00003424                 ;org 3424h
.text$mn:00003424 ; COMDAT (pick any)
.text$mn:00003424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003424
.text$mn:00003424 ; =============== S U B R O U T I N E =======================================
.text$mn:00003424
.text$mn:00003424 ; Attributes: bp-based frame
.text$mn:00003424
.text$mn:00003424 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00003424                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00003424 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00003424                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00003424
.text$mn:00003424 var_4           = dword ptr -4
.text$mn:00003424 Dst             = dword ptr  8
.text$mn:00003424 Src             = dword ptr  0Ch
.text$mn:00003424 Size            = dword ptr  10h
.text$mn:00003424
.text$mn:00003424                 push    ebp
.text$mn:00003425                 mov     ebp, esp
.text$mn:00003427                 push    ecx
.text$mn:00003428                 cmp     [ebp+Size], 0
.text$mn:0000342C                 jnz     short loc_3436
.text$mn:0000342E                 mov     eax, [ebp+Dst]
.text$mn:00003431                 mov     [ebp+var_4], eax
.text$mn:00003434                 jmp     short loc_344D
.text$mn:00003436 ; ---------------------------------------------------------------------------
.text$mn:00003436
.text$mn:00003436 loc_3436:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00003436                 mov     ecx, [ebp+Size]
.text$mn:00003439                 push    ecx             ; Size
.text$mn:0000343A                 mov     edx, [ebp+Src]
.text$mn:0000343D                 push    edx             ; Src
.text$mn:0000343E                 mov     eax, [ebp+Dst]
.text$mn:00003441                 push    eax             ; Dst
.text$mn:00003442                 call    _memcpy
.text$mn:00003447                 add     esp, 0Ch
.text$mn:0000344A                 mov     [ebp+var_4], eax
.text$mn:0000344D
.text$mn:0000344D loc_344D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000344D                 mov     eax, [ebp+var_4]
.text$mn:00003450                 mov     esp, ebp
.text$mn:00003452                 pop     ebp
.text$mn:00003453                 retn
.text$mn:00003453 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00003453
.text$mn:00003453 _text$mn        ends
.text$mn:00003453
.text$mn:00003454 ; ===========================================================================
.text$mn:00003454
.text$mn:00003454 ; Segment type: Pure code
.text$mn:00003454 ; Segment permissions: Read/Execute
.text$mn:00003454 _text$mn        segment para public 'CODE' use32
.text$mn:00003454                 assume cs:_text$mn
.text$mn:00003454                 ;org 3454h
.text$mn:00003454 ; COMDAT (pick any)
.text$mn:00003454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003454
.text$mn:00003454 ; =============== S U B R O U T I N E =======================================
.text$mn:00003454
.text$mn:00003454 ; Attributes: bp-based frame
.text$mn:00003454
.text$mn:00003454 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00003454                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00003454 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00003454                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00003454                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00003454
.text$mn:00003454 var_4           = dword ptr -4
.text$mn:00003454 Dst             = dword ptr  8
.text$mn:00003454 Src             = dword ptr  0Ch
.text$mn:00003454 arg_8           = dword ptr  10h
.text$mn:00003454
.text$mn:00003454                 push    ebp
.text$mn:00003455                 mov     ebp, esp
.text$mn:00003457                 push    ecx
.text$mn:00003458                 cmp     [ebp+arg_8], 0
.text$mn:0000345C                 jnz     short loc_3466
.text$mn:0000345E                 mov     eax, [ebp+Dst]
.text$mn:00003461                 mov     [ebp+var_4], eax
.text$mn:00003464                 jmp     short loc_347D
.text$mn:00003466 ; ---------------------------------------------------------------------------
.text$mn:00003466
.text$mn:00003466 loc_3466:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00003466                 mov     ecx, [ebp+arg_8]
.text$mn:00003469                 push    ecx             ; int
.text$mn:0000346A                 mov     edx, [ebp+Src]
.text$mn:0000346D                 push    edx             ; Src
.text$mn:0000346E                 mov     eax, [ebp+Dst]
.text$mn:00003471                 push    eax             ; Dst
.text$mn:00003472                 call    _wmemcpy
.text$mn:00003477                 add     esp, 0Ch
.text$mn:0000347A                 mov     [ebp+var_4], eax
.text$mn:0000347D
.text$mn:0000347D loc_347D:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000347D                 mov     eax, [ebp+var_4]
.text$mn:00003480                 mov     esp, ebp
.text$mn:00003482                 pop     ebp
.text$mn:00003483                 retn
.text$mn:00003483 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00003483
.text$mn:00003483 _text$mn        ends
.text$mn:00003483
.text$mn:00003484 ; ===========================================================================
.text$mn:00003484
.text$mn:00003484 ; Segment type: Pure code
.text$mn:00003484 ; Segment permissions: Read/Execute
.text$mn:00003484 _text$mn        segment para public 'CODE' use32
.text$mn:00003484                 assume cs:_text$mn
.text$mn:00003484                 ;org 3484h
.text$mn:00003484 ; COMDAT (pick any)
.text$mn:00003484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003484
.text$mn:00003484 ; =============== S U B R O U T I N E =======================================
.text$mn:00003484
.text$mn:00003484 ; Attributes: bp-based frame
.text$mn:00003484
.text$mn:00003484 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00003484                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00003484 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00003484                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00003484
.text$mn:00003484 var_4           = dword ptr -4
.text$mn:00003484 arg_0           = dword ptr  8
.text$mn:00003484 arg_4           = dword ptr  0Ch
.text$mn:00003484
.text$mn:00003484                 push    ebp
.text$mn:00003485                 mov     ebp, esp
.text$mn:00003487                 push    ecx
.text$mn:00003488                 mov     [ebp+var_4], ecx
.text$mn:0000348B                 mov     eax, [ebp+arg_4]
.text$mn:0000348E                 push    eax             ; int
.text$mn:0000348F                 mov     ecx, [ebp+arg_0]
.text$mn:00003492                 push    ecx             ; void *
.text$mn:00003493                 mov     ecx, [ebp+var_4]
.text$mn:00003496                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000349B                 mov     esp, ebp
.text$mn:0000349D                 pop     ebp
.text$mn:0000349E                 retn    8
.text$mn:0000349E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000349E
.text$mn:0000349E ; ---------------------------------------------------------------------------
.text$mn:000034A1                 align 4
.text$mn:000034A1 _text$mn        ends
.text$mn:000034A1
.text$mn:000034A4 ; ===========================================================================
.text$mn:000034A4
.text$mn:000034A4 ; Segment type: Pure code
.text$mn:000034A4 ; Segment permissions: Read/Execute
.text$mn:000034A4 _text$mn        segment para public 'CODE' use32
.text$mn:000034A4                 assume cs:_text$mn
.text$mn:000034A4                 ;org 34A4h
.text$mn:000034A4 ; COMDAT (pick any)
.text$mn:000034A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034A4
.text$mn:000034A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034A4
.text$mn:000034A4 ; Attributes: bp-based frame
.text$mn:000034A4
.text$mn:000034A4 ; int __stdcall std::_Wrap_alloc<std::allocator<HMENU__ *>>::deallocate(void *, int)
.text$mn:000034A4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@I@Z
.text$mn:000034A4 ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@I@Z proc near
.text$mn:000034A4                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:000034A4                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reallocate(uint)+F5p ...
.text$mn:000034A4
.text$mn:000034A4 var_4           = dword ptr -4
.text$mn:000034A4 arg_0           = dword ptr  8
.text$mn:000034A4 arg_4           = dword ptr  0Ch
.text$mn:000034A4
.text$mn:000034A4                 push    ebp
.text$mn:000034A5                 mov     ebp, esp
.text$mn:000034A7                 push    ecx
.text$mn:000034A8                 mov     [ebp+var_4], ecx
.text$mn:000034AB                 mov     eax, [ebp+arg_4]
.text$mn:000034AE                 push    eax             ; int
.text$mn:000034AF                 mov     ecx, [ebp+arg_0]
.text$mn:000034B2                 push    ecx             ; void *
.text$mn:000034B3                 mov     ecx, [ebp+var_4]
.text$mn:000034B6                 call    ?deallocate@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@I@Z ; std::allocator<HMENU__ *>::deallocate(HMENU__ * *,uint)
.text$mn:000034BB                 mov     esp, ebp
.text$mn:000034BD                 pop     ebp
.text$mn:000034BE                 retn    8
.text$mn:000034BE ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@I@Z endp
.text$mn:000034BE
.text$mn:000034BE ; ---------------------------------------------------------------------------
.text$mn:000034C1                 align 4
.text$mn:000034C1 _text$mn        ends
.text$mn:000034C1
.text$mn:000034C4 ; ===========================================================================
.text$mn:000034C4
.text$mn:000034C4 ; Segment type: Pure code
.text$mn:000034C4 ; Segment permissions: Read/Execute
.text$mn:000034C4 _text$mn        segment para public 'CODE' use32
.text$mn:000034C4                 assume cs:_text$mn
.text$mn:000034C4                 ;org 34C4h
.text$mn:000034C4 ; COMDAT (pick any)
.text$mn:000034C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034C4
.text$mn:000034C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034C4
.text$mn:000034C4 ; Attributes: bp-based frame
.text$mn:000034C4
.text$mn:000034C4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:000034C4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000034C4 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000034C4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Free_proxy(void)+32p
.text$mn:000034C4
.text$mn:000034C4 var_4           = dword ptr -4
.text$mn:000034C4 arg_0           = dword ptr  8
.text$mn:000034C4 arg_4           = dword ptr  0Ch
.text$mn:000034C4
.text$mn:000034C4                 push    ebp
.text$mn:000034C5                 mov     ebp, esp
.text$mn:000034C7                 push    ecx
.text$mn:000034C8                 mov     [ebp+var_4], ecx
.text$mn:000034CB                 mov     eax, [ebp+arg_4]
.text$mn:000034CE                 push    eax             ; int
.text$mn:000034CF                 mov     ecx, [ebp+arg_0]
.text$mn:000034D2                 push    ecx             ; void *
.text$mn:000034D3                 mov     ecx, [ebp+var_4]
.text$mn:000034D6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000034DB                 mov     esp, ebp
.text$mn:000034DD                 pop     ebp
.text$mn:000034DE                 retn    8
.text$mn:000034DE ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000034DE
.text$mn:000034DE ; ---------------------------------------------------------------------------
.text$mn:000034E1                 align 4
.text$mn:000034E1 _text$mn        ends
.text$mn:000034E1
.text$mn:000034E4 ; ===========================================================================
.text$mn:000034E4
.text$mn:000034E4 ; Segment type: Pure code
.text$mn:000034E4 ; Segment permissions: Read/Execute
.text$mn:000034E4 _text$mn        segment para public 'CODE' use32
.text$mn:000034E4                 assume cs:_text$mn
.text$mn:000034E4                 ;org 34E4h
.text$mn:000034E4 ; COMDAT (pick any)
.text$mn:000034E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034E4
.text$mn:000034E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034E4
.text$mn:000034E4 ; Attributes: bp-based frame
.text$mn:000034E4
.text$mn:000034E4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:000034E4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:000034E4 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:000034E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:000034E4
.text$mn:000034E4 var_4           = dword ptr -4
.text$mn:000034E4 arg_0           = dword ptr  8
.text$mn:000034E4 arg_4           = dword ptr  0Ch
.text$mn:000034E4
.text$mn:000034E4                 push    ebp
.text$mn:000034E5                 mov     ebp, esp
.text$mn:000034E7                 push    ecx
.text$mn:000034E8                 mov     [ebp+var_4], ecx
.text$mn:000034EB                 mov     eax, [ebp+arg_4]
.text$mn:000034EE                 push    eax             ; int
.text$mn:000034EF                 mov     ecx, [ebp+arg_0]
.text$mn:000034F2                 push    ecx             ; void *
.text$mn:000034F3                 mov     ecx, [ebp+var_4]
.text$mn:000034F6                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:000034FB                 mov     esp, ebp
.text$mn:000034FD                 pop     ebp
.text$mn:000034FE                 retn    8
.text$mn:000034FE ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:000034FE
.text$mn:000034FE ; ---------------------------------------------------------------------------
.text$mn:00003501                 align 4
.text$mn:00003501 _text$mn        ends
.text$mn:00003501
.text$mn:00003504 ; ===========================================================================
.text$mn:00003504
.text$mn:00003504 ; Segment type: Pure code
.text$mn:00003504 ; Segment permissions: Read/Execute
.text$mn:00003504 _text$mn        segment para public 'CODE' use32
.text$mn:00003504                 assume cs:_text$mn
.text$mn:00003504                 ;org 3504h
.text$mn:00003504 ; COMDAT (pick any)
.text$mn:00003504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003504
.text$mn:00003504 ; =============== S U B R O U T I N E =======================================
.text$mn:00003504
.text$mn:00003504 ; Attributes: bp-based frame
.text$mn:00003504
.text$mn:00003504 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00003504                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00003504 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00003504                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00003504
.text$mn:00003504 var_4           = dword ptr -4
.text$mn:00003504 arg_0           = dword ptr  8
.text$mn:00003504
.text$mn:00003504                 push    ebp
.text$mn:00003505                 mov     ebp, esp
.text$mn:00003507                 push    ecx
.text$mn:00003508                 mov     [ebp+var_4], ecx
.text$mn:0000350B                 mov     eax, [ebp+arg_0]
.text$mn:0000350E                 push    eax             ; void *
.text$mn:0000350F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003514                 add     esp, 4
.text$mn:00003517                 mov     esp, ebp
.text$mn:00003519                 pop     ebp
.text$mn:0000351A                 retn    8
.text$mn:0000351A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000351A
.text$mn:0000351A ; ---------------------------------------------------------------------------
.text$mn:0000351D                 align 10h
.text$mn:0000351D _text$mn        ends
.text$mn:0000351D
.text$mn:00003520 ; ===========================================================================
.text$mn:00003520
.text$mn:00003520 ; Segment type: Pure code
.text$mn:00003520 ; Segment permissions: Read/Execute
.text$mn:00003520 _text$mn        segment para public 'CODE' use32
.text$mn:00003520                 assume cs:_text$mn
.text$mn:00003520                 ;org 3520h
.text$mn:00003520 ; COMDAT (pick any)
.text$mn:00003520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003520
.text$mn:00003520 ; =============== S U B R O U T I N E =======================================
.text$mn:00003520
.text$mn:00003520 ; Attributes: bp-based frame
.text$mn:00003520
.text$mn:00003520 ; int __stdcall std::allocator<HMENU__ *>::deallocate(void *, int)
.text$mn:00003520                 public ?deallocate@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@I@Z
.text$mn:00003520 ?deallocate@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@I@Z proc near
.text$mn:00003520                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::deallocate(HMENU__ * *,uint)+12p
.text$mn:00003520
.text$mn:00003520 var_4           = dword ptr -4
.text$mn:00003520 arg_0           = dword ptr  8
.text$mn:00003520
.text$mn:00003520                 push    ebp
.text$mn:00003521                 mov     ebp, esp
.text$mn:00003523                 push    ecx
.text$mn:00003524                 mov     [ebp+var_4], ecx
.text$mn:00003527                 mov     eax, [ebp+arg_0]
.text$mn:0000352A                 push    eax             ; void *
.text$mn:0000352B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003530                 add     esp, 4
.text$mn:00003533                 mov     esp, ebp
.text$mn:00003535                 pop     ebp
.text$mn:00003536                 retn    8
.text$mn:00003536 ?deallocate@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@I@Z endp
.text$mn:00003536
.text$mn:00003536 ; ---------------------------------------------------------------------------
.text$mn:00003539                 align 4
.text$mn:00003539 _text$mn        ends
.text$mn:00003539
.text$mn:0000353C ; ===========================================================================
.text$mn:0000353C
.text$mn:0000353C ; Segment type: Pure code
.text$mn:0000353C ; Segment permissions: Read/Execute
.text$mn:0000353C _text$mn        segment para public 'CODE' use32
.text$mn:0000353C                 assume cs:_text$mn
.text$mn:0000353C                 ;org 353Ch
.text$mn:0000353C ; COMDAT (pick any)
.text$mn:0000353C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000353C
.text$mn:0000353C ; =============== S U B R O U T I N E =======================================
.text$mn:0000353C
.text$mn:0000353C ; Attributes: bp-based frame
.text$mn:0000353C
.text$mn:0000353C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000353C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000353C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000353C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000353C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:0000353C
.text$mn:0000353C var_4           = dword ptr -4
.text$mn:0000353C arg_0           = dword ptr  8
.text$mn:0000353C
.text$mn:0000353C                 push    ebp
.text$mn:0000353D                 mov     ebp, esp
.text$mn:0000353F                 push    ecx
.text$mn:00003540                 mov     [ebp+var_4], ecx
.text$mn:00003543                 mov     eax, [ebp+arg_0]
.text$mn:00003546                 push    eax             ; void *
.text$mn:00003547                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000354C                 add     esp, 4
.text$mn:0000354F                 mov     esp, ebp
.text$mn:00003551                 pop     ebp
.text$mn:00003552                 retn    8
.text$mn:00003552 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00003552
.text$mn:00003552 ; ---------------------------------------------------------------------------
.text$mn:00003555                 align 4
.text$mn:00003555 _text$mn        ends
.text$mn:00003555
.text$mn:00003558 ; ===========================================================================
.text$mn:00003558
.text$mn:00003558 ; Segment type: Pure code
.text$mn:00003558 ; Segment permissions: Read/Execute
.text$mn:00003558 _text$mn        segment para public 'CODE' use32
.text$mn:00003558                 assume cs:_text$mn
.text$mn:00003558                 ;org 3558h
.text$mn:00003558 ; COMDAT (pick any)
.text$mn:00003558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003558
.text$mn:00003558 ; =============== S U B R O U T I N E =======================================
.text$mn:00003558
.text$mn:00003558 ; Attributes: bp-based frame
.text$mn:00003558
.text$mn:00003558 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00003558                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00003558 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00003558                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00003558
.text$mn:00003558 var_4           = dword ptr -4
.text$mn:00003558 arg_0           = dword ptr  8
.text$mn:00003558
.text$mn:00003558                 push    ebp
.text$mn:00003559                 mov     ebp, esp
.text$mn:0000355B                 push    ecx
.text$mn:0000355C                 mov     [ebp+var_4], ecx
.text$mn:0000355F                 mov     eax, [ebp+arg_0]
.text$mn:00003562                 push    eax             ; void *
.text$mn:00003563                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003568                 add     esp, 4
.text$mn:0000356B                 mov     esp, ebp
.text$mn:0000356D                 pop     ebp
.text$mn:0000356E                 retn    8
.text$mn:0000356E ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000356E
.text$mn:0000356E ; ---------------------------------------------------------------------------
.text$mn:00003571                 align 4
.text$mn:00003571 _text$mn        ends
.text$mn:00003571
.text$mn:00003574 ; ===========================================================================
.text$mn:00003574
.text$mn:00003574 ; Segment type: Pure code
.text$mn:00003574 ; Segment permissions: Read/Execute
.text$mn:00003574 _text$mn        segment para public 'CODE' use32
.text$mn:00003574                 assume cs:_text$mn
.text$mn:00003574                 ;org 3574h
.text$mn:00003574 ; COMDAT (pick any)
.text$mn:00003574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003574
.text$mn:00003574 ; =============== S U B R O U T I N E =======================================
.text$mn:00003574
.text$mn:00003574 ; Attributes: bp-based frame
.text$mn:00003574
.text$mn:00003574 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00003574                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00003574 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00003574                                         ; DATA XREF: .rdata:00004704o
.text$mn:00003574
.text$mn:00003574 var_4           = dword ptr -4
.text$mn:00003574 arg_0           = dword ptr  8
.text$mn:00003574 arg_4           = dword ptr  0Ch
.text$mn:00003574
.text$mn:00003574                 push    ebp
.text$mn:00003575                 mov     ebp, esp
.text$mn:00003577                 push    ecx
.text$mn:00003578                 mov     [ebp+var_4], ecx
.text$mn:0000357B                 mov     eax, [ebp+arg_4]
.text$mn:0000357E                 push    eax             ; int
.text$mn:0000357F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003584                 add     esp, 4
.text$mn:00003587                 test    eax, eax
.text$mn:00003589                 jz      short loc_35A4
.text$mn:0000358B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00003590                 push    eax             ; struct std::error_category *
.text$mn:00003591                 mov     ecx, [ebp+arg_4]
.text$mn:00003594                 push    ecx             ; int
.text$mn:00003595                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003598                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000359D                 mov     eax, [ebp+arg_0]
.text$mn:000035A0                 jmp     short loc_35B9
.text$mn:000035A2 ; ---------------------------------------------------------------------------
.text$mn:000035A2                 jmp     short loc_35B9
.text$mn:000035A4 ; ---------------------------------------------------------------------------
.text$mn:000035A4
.text$mn:000035A4 loc_35A4:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000035A4                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000035A9                 push    eax             ; struct std::error_category *
.text$mn:000035AA                 mov     edx, [ebp+arg_4]
.text$mn:000035AD                 push    edx             ; int
.text$mn:000035AE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000035B1                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000035B6                 mov     eax, [ebp+arg_0]
.text$mn:000035B9
.text$mn:000035B9 loc_35B9:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000035B9                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000035B9                 mov     esp, ebp
.text$mn:000035BB                 pop     ebp
.text$mn:000035BC                 retn    8
.text$mn:000035BC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000035BC
.text$mn:000035BC ; ---------------------------------------------------------------------------
.text$mn:000035BF                 align 10h
.text$mn:000035BF _text$mn        ends
.text$mn:000035BF
.text$mn:000035C0 ; ===========================================================================
.text$mn:000035C0
.text$mn:000035C0 ; Segment type: Pure code
.text$mn:000035C0 ; Segment permissions: Read/Execute
.text$mn:000035C0 _text$mn        segment para public 'CODE' use32
.text$mn:000035C0                 assume cs:_text$mn
.text$mn:000035C0                 ;org 35C0h
.text$mn:000035C0 ; COMDAT (pick any)
.text$mn:000035C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035C0
.text$mn:000035C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035C0
.text$mn:000035C0 ; Attributes: bp-based frame
.text$mn:000035C0
.text$mn:000035C0 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000035C0                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000035C0 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000035C0                                         ; DATA XREF: .rdata:00004674o
.text$mn:000035C0                                         ; .rdata:00004690o ...
.text$mn:000035C0
.text$mn:000035C0 var_4           = dword ptr -4
.text$mn:000035C0 arg_0           = dword ptr  8
.text$mn:000035C0 arg_4           = dword ptr  0Ch
.text$mn:000035C0
.text$mn:000035C0                 push    ebp
.text$mn:000035C1                 mov     ebp, esp
.text$mn:000035C3                 push    ecx
.text$mn:000035C4                 mov     [ebp+var_4], ecx
.text$mn:000035C7                 mov     eax, [ebp+var_4]
.text$mn:000035CA                 push    eax             ; struct std::error_category *
.text$mn:000035CB                 mov     ecx, [ebp+arg_4]
.text$mn:000035CE                 push    ecx             ; int
.text$mn:000035CF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000035D2                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000035D7                 mov     eax, [ebp+arg_0]
.text$mn:000035DA                 mov     esp, ebp
.text$mn:000035DC                 pop     ebp
.text$mn:000035DD                 retn    8
.text$mn:000035DD ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000035DD
.text$mn:000035DD _text$mn        ends
.text$mn:000035DD
.text$mn:000035E0 ; ===========================================================================
.text$mn:000035E0
.text$mn:000035E0 ; Segment type: Pure code
.text$mn:000035E0 ; Segment permissions: Read/Execute
.text$mn:000035E0 _text$mn        segment para public 'CODE' use32
.text$mn:000035E0                 assume cs:_text$mn
.text$mn:000035E0                 ;org 35E0h
.text$mn:000035E0 ; COMDAT (pick any)
.text$mn:000035E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035E0
.text$mn:000035E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035E0
.text$mn:000035E0 ; Attributes: bp-based frame
.text$mn:000035E0
.text$mn:000035E0 ; void __thiscall ContextMenu::enableItem(ContextMenu *this, UINT uIDEnableItem, bool)
.text$mn:000035E0                 public ?enableItem@ContextMenu@@QBEXH_N@Z
.text$mn:000035E0 ?enableItem@ContextMenu@@QBEXH_N@Z proc near
.text$mn:000035E0                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+2B9p
.text$mn:000035E0
.text$mn:000035E0 var_C           = dword ptr -0Ch
.text$mn:000035E0 uEnable         = dword ptr -8
.text$mn:000035E0 var_4           = dword ptr -4
.text$mn:000035E0 uIDEnableItem   = dword ptr  8
.text$mn:000035E0 arg_4           = byte ptr  0Ch
.text$mn:000035E0
.text$mn:000035E0                 push    ebp
.text$mn:000035E1                 mov     ebp, esp
.text$mn:000035E3                 sub     esp, 0Ch
.text$mn:000035E6                 mov     [ebp+var_C], ecx
.text$mn:000035E9                 movzx   eax, [ebp+arg_4]
.text$mn:000035ED                 test    eax, eax
.text$mn:000035EF                 jz      short loc_35FA
.text$mn:000035F1                 mov     [ebp+var_4], 0
.text$mn:000035F8                 jmp     short loc_3601
.text$mn:000035FA ; ---------------------------------------------------------------------------
.text$mn:000035FA
.text$mn:000035FA loc_35FA:                               ; CODE XREF: ContextMenu::enableItem(int,bool)+Fj
.text$mn:000035FA                 mov     [ebp+var_4], 3
.text$mn:00003601
.text$mn:00003601 loc_3601:                               ; CODE XREF: ContextMenu::enableItem(int,bool)+18j
.text$mn:00003601                 mov     ecx, [ebp+var_4]
.text$mn:00003604                 mov     [ebp+uEnable], ecx
.text$mn:00003607                 mov     edx, [ebp+uEnable]
.text$mn:0000360A                 push    edx             ; uEnable
.text$mn:0000360B                 mov     eax, [ebp+uIDEnableItem]
.text$mn:0000360E                 push    eax             ; uIDEnableItem
.text$mn:0000360F                 mov     ecx, [ebp+var_C]
.text$mn:00003612                 mov     edx, [ecx+4]
.text$mn:00003615                 push    edx             ; hMenu
.text$mn:00003616                 call    dword ptr ds:__imp__EnableMenuItem@12 ; EnableMenuItem(x,x,x)
.text$mn:0000361C                 mov     esp, ebp
.text$mn:0000361E                 pop     ebp
.text$mn:0000361F                 retn    8
.text$mn:0000361F ?enableItem@ContextMenu@@QBEXH_N@Z endp
.text$mn:0000361F
.text$mn:0000361F ; ---------------------------------------------------------------------------
.text$mn:00003622                 align 4
.text$mn:00003622 _text$mn        ends
.text$mn:00003622
.text$mn:00003624 ; ===========================================================================
.text$mn:00003624
.text$mn:00003624 ; Segment type: Pure code
.text$mn:00003624 ; Segment permissions: Read/Execute
.text$mn:00003624 _text$mn        segment para public 'CODE' use32
.text$mn:00003624                 assume cs:_text$mn
.text$mn:00003624                 ;org 3624h
.text$mn:00003624 ; COMDAT (pick any)
.text$mn:00003624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003624
.text$mn:00003624 ; =============== S U B R O U T I N E =======================================
.text$mn:00003624
.text$mn:00003624 ; Attributes: bp-based frame
.text$mn:00003624
.text$mn:00003624 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00003624                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00003624 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00003624                                         ; DATA XREF: .rdata:00004678o
.text$mn:00003624                                         ; .rdata:00004694o ...
.text$mn:00003624
.text$mn:00003624 var_8           = dword ptr -8
.text$mn:00003624 var_4           = dword ptr -4
.text$mn:00003624 arg_0           = dword ptr  8
.text$mn:00003624 arg_4           = dword ptr  0Ch
.text$mn:00003624
.text$mn:00003624                 push    ebp
.text$mn:00003625                 mov     ebp, esp
.text$mn:00003627                 sub     esp, 8
.text$mn:0000362A                 mov     [ebp+var_8], ecx
.text$mn:0000362D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003630                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00003635                 push    eax
.text$mn:00003636                 mov     ecx, [ebp+var_8]
.text$mn:00003639                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000363E                 movzx   eax, al
.text$mn:00003641                 test    eax, eax
.text$mn:00003643                 jz      short loc_365B
.text$mn:00003645                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003648                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000364D                 cmp     eax, [ebp+arg_4]
.text$mn:00003650                 jnz     short loc_365B
.text$mn:00003652                 mov     [ebp+var_4], 1
.text$mn:00003659                 jmp     short loc_3662
.text$mn:0000365B ; ---------------------------------------------------------------------------
.text$mn:0000365B
.text$mn:0000365B loc_365B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000365B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000365B                 mov     [ebp+var_4], 0
.text$mn:00003662
.text$mn:00003662 loc_3662:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00003662                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003665                 mov     esp, ebp
.text$mn:00003667                 pop     ebp
.text$mn:00003668                 retn    8
.text$mn:00003668 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00003668
.text$mn:00003668 ; ---------------------------------------------------------------------------
.text$mn:0000366B                 align 4
.text$mn:0000366B _text$mn        ends
.text$mn:0000366B
.text$mn:0000366C ; ===========================================================================
.text$mn:0000366C
.text$mn:0000366C ; Segment type: Pure code
.text$mn:0000366C ; Segment permissions: Read/Execute
.text$mn:0000366C _text$mn        segment para public 'CODE' use32
.text$mn:0000366C                 assume cs:_text$mn
.text$mn:0000366C                 ;org 366Ch
.text$mn:0000366C ; COMDAT (pick any)
.text$mn:0000366C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000366C
.text$mn:0000366C ; =============== S U B R O U T I N E =======================================
.text$mn:0000366C
.text$mn:0000366C ; Attributes: bp-based frame
.text$mn:0000366C
.text$mn:0000366C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000366C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000366C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000366C                                         ; DATA XREF: .rdata:0000467Co
.text$mn:0000366C                                         ; .rdata:00004698o ...
.text$mn:0000366C
.text$mn:0000366C var_C           = byte ptr -0Ch
.text$mn:0000366C var_4           = dword ptr -4
.text$mn:0000366C arg_0           = dword ptr  8
.text$mn:0000366C arg_4           = dword ptr  0Ch
.text$mn:0000366C
.text$mn:0000366C                 push    ebp
.text$mn:0000366D                 mov     ebp, esp
.text$mn:0000366F                 sub     esp, 0Ch
.text$mn:00003672                 mov     [ebp+var_4], ecx
.text$mn:00003675                 mov     eax, [ebp+arg_4]
.text$mn:00003678                 push    eax             ; std::error_condition *
.text$mn:00003679                 mov     ecx, [ebp+arg_0]
.text$mn:0000367C                 push    ecx
.text$mn:0000367D                 lea     edx, [ebp+var_C]
.text$mn:00003680                 push    edx
.text$mn:00003681                 mov     eax, [ebp+var_4]
.text$mn:00003684                 mov     edx, [eax]
.text$mn:00003686                 mov     ecx, [ebp+var_4]
.text$mn:00003689                 mov     eax, [edx+0Ch]
.text$mn:0000368C                 call    eax
.text$mn:0000368E                 mov     ecx, eax
.text$mn:00003690                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00003695                 mov     esp, ebp
.text$mn:00003697                 pop     ebp
.text$mn:00003698                 retn    8
.text$mn:00003698 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00003698
.text$mn:00003698 ; ---------------------------------------------------------------------------
.text$mn:0000369B                 align 4
.text$mn:0000369B _text$mn        ends
.text$mn:0000369B
.text$mn:0000369C ; ===========================================================================
.text$mn:0000369C
.text$mn:0000369C ; Segment type: Pure code
.text$mn:0000369C ; Segment permissions: Read/Execute
.text$mn:0000369C _text$mn        segment para public 'CODE' use32
.text$mn:0000369C                 assume cs:_text$mn
.text$mn:0000369C                 ;org 369Ch
.text$mn:0000369C ; COMDAT (pick any)
.text$mn:0000369C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000369C
.text$mn:0000369C ; =============== S U B R O U T I N E =======================================
.text$mn:0000369C
.text$mn:0000369C ; Attributes: bp-based frame
.text$mn:0000369C
.text$mn:0000369C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000369C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000369C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000369C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000369C
.text$mn:0000369C var_4           = dword ptr -4
.text$mn:0000369C arg_0           = dword ptr  8
.text$mn:0000369C
.text$mn:0000369C                 push    ebp
.text$mn:0000369D                 mov     ebp, esp
.text$mn:0000369F                 push    ecx
.text$mn:000036A0                 mov     [ebp+var_4], ecx
.text$mn:000036A3                 mov     eax, [ebp+var_4]
.text$mn:000036A6                 mov     ecx, [eax+14h]
.text$mn:000036A9                 cmp     ecx, [ebp+arg_0]
.text$mn:000036AC                 jnb     short loc_36B6
.text$mn:000036AE                 mov     ecx, [ebp+var_4]
.text$mn:000036B1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000036B6
.text$mn:000036B6 loc_36B6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000036B6                 mov     edx, [ebp+arg_0]
.text$mn:000036B9                 push    edx
.text$mn:000036BA                 mov     ecx, [ebp+var_4]
.text$mn:000036BD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000036C2                 mov     eax, [ebp+var_4]
.text$mn:000036C5                 mov     esp, ebp
.text$mn:000036C7                 pop     ebp
.text$mn:000036C8                 retn    4
.text$mn:000036C8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000036C8
.text$mn:000036C8 ; ---------------------------------------------------------------------------
.text$mn:000036CB                 align 4
.text$mn:000036CB _text$mn        ends
.text$mn:000036CB
.text$mn:000036CC ; ===========================================================================
.text$mn:000036CC
.text$mn:000036CC ; Segment type: Pure code
.text$mn:000036CC ; Segment permissions: Read/Execute
.text$mn:000036CC _text$mn        segment para public 'CODE' use32
.text$mn:000036CC                 assume cs:_text$mn
.text$mn:000036CC                 ;org 36CCh
.text$mn:000036CC ; COMDAT (pick any)
.text$mn:000036CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036CC
.text$mn:000036CC ; =============== S U B R O U T I N E =======================================
.text$mn:000036CC
.text$mn:000036CC ; Attributes: bp-based frame
.text$mn:000036CC
.text$mn:000036CC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000036CC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000036CC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000036CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000036CC
.text$mn:000036CC var_C           = dword ptr -0Ch
.text$mn:000036CC Dst             = dword ptr -8
.text$mn:000036CC var_4           = dword ptr -4
.text$mn:000036CC arg_0           = dword ptr  8
.text$mn:000036CC arg_4           = dword ptr  0Ch
.text$mn:000036CC
.text$mn:000036CC                 push    ebp
.text$mn:000036CD                 mov     ebp, esp
.text$mn:000036CF                 sub     esp, 0Ch
.text$mn:000036D2                 mov     [ebp+var_4], ecx
.text$mn:000036D5                 mov     eax, [ebp+var_4]
.text$mn:000036D8                 mov     ecx, [eax+14h]
.text$mn:000036DB                 cmp     ecx, [ebp+arg_0]
.text$mn:000036DE                 jnb     short loc_36E8
.text$mn:000036E0                 mov     ecx, [ebp+var_4]
.text$mn:000036E3                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000036E8
.text$mn:000036E8 loc_36E8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000036E8                 mov     edx, [ebp+var_4]
.text$mn:000036EB                 mov     eax, [edx+14h]
.text$mn:000036EE                 sub     eax, [ebp+arg_0]
.text$mn:000036F1                 cmp     eax, [ebp+arg_4]
.text$mn:000036F4                 ja      short loc_3704
.text$mn:000036F6                 mov     ecx, [ebp+arg_0]
.text$mn:000036F9                 push    ecx
.text$mn:000036FA                 mov     ecx, [ebp+var_4]
.text$mn:000036FD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003702                 jmp     short loc_374A
.text$mn:00003704 ; ---------------------------------------------------------------------------
.text$mn:00003704
.text$mn:00003704 loc_3704:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00003704                 cmp     [ebp+arg_4], 0
.text$mn:00003708                 jbe     short loc_374A
.text$mn:0000370A                 mov     ecx, [ebp+var_4]
.text$mn:0000370D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003712                 add     eax, [ebp+arg_0]
.text$mn:00003715                 mov     [ebp+Dst], eax
.text$mn:00003718                 mov     edx, [ebp+var_4]
.text$mn:0000371B                 mov     eax, [edx+14h]
.text$mn:0000371E                 sub     eax, [ebp+arg_4]
.text$mn:00003721                 mov     [ebp+var_C], eax
.text$mn:00003724                 mov     ecx, [ebp+var_C]
.text$mn:00003727                 sub     ecx, [ebp+arg_0]
.text$mn:0000372A                 push    ecx             ; Size
.text$mn:0000372B                 mov     edx, [ebp+Dst]
.text$mn:0000372E                 add     edx, [ebp+arg_4]
.text$mn:00003731                 push    edx             ; Src
.text$mn:00003732                 mov     eax, [ebp+Dst]
.text$mn:00003735                 push    eax             ; Dst
.text$mn:00003736                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000373B                 add     esp, 0Ch
.text$mn:0000373E                 mov     ecx, [ebp+var_C]
.text$mn:00003741                 push    ecx
.text$mn:00003742                 mov     ecx, [ebp+var_4]
.text$mn:00003745                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000374A
.text$mn:0000374A loc_374A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000374A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000374A                 mov     eax, [ebp+var_4]
.text$mn:0000374D                 mov     esp, ebp
.text$mn:0000374F                 pop     ebp
.text$mn:00003750                 retn    8
.text$mn:00003750 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00003750
.text$mn:00003750 ; ---------------------------------------------------------------------------
.text$mn:00003753                 align 4
.text$mn:00003753 _text$mn        ends
.text$mn:00003753
.text$mn:00003754 ; ===========================================================================
.text$mn:00003754
.text$mn:00003754 ; Segment type: Pure code
.text$mn:00003754 ; Segment permissions: Read/Execute
.text$mn:00003754 _text$mn        segment para public 'CODE' use32
.text$mn:00003754                 assume cs:_text$mn
.text$mn:00003754                 ;org 3754h
.text$mn:00003754 ; COMDAT (pick any)
.text$mn:00003754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003754
.text$mn:00003754 ; =============== S U B R O U T I N E =======================================
.text$mn:00003754
.text$mn:00003754 ; Attributes: bp-based frame
.text$mn:00003754
.text$mn:00003754 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00003754                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00003754 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00003754                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00003754
.text$mn:00003754 var_4           = dword ptr -4
.text$mn:00003754 arg_0           = dword ptr  8
.text$mn:00003754
.text$mn:00003754                 push    ebp
.text$mn:00003755                 mov     ebp, esp
.text$mn:00003757                 push    ecx
.text$mn:00003758                 mov     [ebp+var_4], ecx
.text$mn:0000375B                 mov     eax, [ebp+var_4]
.text$mn:0000375E                 mov     ecx, [eax+14h]
.text$mn:00003761                 cmp     ecx, [ebp+arg_0]
.text$mn:00003764                 jnb     short loc_376E
.text$mn:00003766                 mov     ecx, [ebp+var_4]
.text$mn:00003769                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000376E
.text$mn:0000376E loc_376E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000376E                 mov     edx, [ebp+arg_0]
.text$mn:00003771                 push    edx
.text$mn:00003772                 mov     ecx, [ebp+var_4]
.text$mn:00003775                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000377A                 mov     eax, [ebp+var_4]
.text$mn:0000377D                 mov     esp, ebp
.text$mn:0000377F                 pop     ebp
.text$mn:00003780                 retn    4
.text$mn:00003780 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00003780
.text$mn:00003780 ; ---------------------------------------------------------------------------
.text$mn:00003783                 align 4
.text$mn:00003783 _text$mn        ends
.text$mn:00003783
.text$mn:00003784 ; ===========================================================================
.text$mn:00003784
.text$mn:00003784 ; Segment type: Pure code
.text$mn:00003784 ; Segment permissions: Read/Execute
.text$mn:00003784 _text$mn        segment para public 'CODE' use32
.text$mn:00003784                 assume cs:_text$mn
.text$mn:00003784                 ;org 3784h
.text$mn:00003784 ; COMDAT (pick any)
.text$mn:00003784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003784
.text$mn:00003784 ; =============== S U B R O U T I N E =======================================
.text$mn:00003784
.text$mn:00003784 ; Attributes: bp-based frame
.text$mn:00003784
.text$mn:00003784 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00003784                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00003784 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00003784                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00003784
.text$mn:00003784 var_C           = dword ptr -0Ch
.text$mn:00003784 Dst             = dword ptr -8
.text$mn:00003784 var_4           = dword ptr -4
.text$mn:00003784 arg_0           = dword ptr  8
.text$mn:00003784 arg_4           = dword ptr  0Ch
.text$mn:00003784
.text$mn:00003784                 push    ebp
.text$mn:00003785                 mov     ebp, esp
.text$mn:00003787                 sub     esp, 0Ch
.text$mn:0000378A                 mov     [ebp+var_4], ecx
.text$mn:0000378D                 mov     eax, [ebp+var_4]
.text$mn:00003790                 mov     ecx, [eax+14h]
.text$mn:00003793                 cmp     ecx, [ebp+arg_0]
.text$mn:00003796                 jnb     short loc_37A0
.text$mn:00003798                 mov     ecx, [ebp+var_4]
.text$mn:0000379B                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000037A0
.text$mn:000037A0 loc_37A0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:000037A0                 mov     edx, [ebp+var_4]
.text$mn:000037A3                 mov     eax, [edx+14h]
.text$mn:000037A6                 sub     eax, [ebp+arg_0]
.text$mn:000037A9                 cmp     eax, [ebp+arg_4]
.text$mn:000037AC                 ja      short loc_37BC
.text$mn:000037AE                 mov     ecx, [ebp+arg_0]
.text$mn:000037B1                 push    ecx
.text$mn:000037B2                 mov     ecx, [ebp+var_4]
.text$mn:000037B5                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000037BA                 jmp     short loc_3808
.text$mn:000037BC ; ---------------------------------------------------------------------------
.text$mn:000037BC
.text$mn:000037BC loc_37BC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:000037BC                 cmp     [ebp+arg_4], 0
.text$mn:000037C0                 jbe     short loc_3808
.text$mn:000037C2                 mov     ecx, [ebp+var_4]
.text$mn:000037C5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000037CA                 mov     edx, [ebp+arg_0]
.text$mn:000037CD                 lea     eax, [eax+edx*2]
.text$mn:000037D0                 mov     [ebp+Dst], eax
.text$mn:000037D3                 mov     ecx, [ebp+var_4]
.text$mn:000037D6                 mov     edx, [ecx+14h]
.text$mn:000037D9                 sub     edx, [ebp+arg_4]
.text$mn:000037DC                 mov     [ebp+var_C], edx
.text$mn:000037DF                 mov     eax, [ebp+var_C]
.text$mn:000037E2                 sub     eax, [ebp+arg_0]
.text$mn:000037E5                 push    eax             ; int
.text$mn:000037E6                 mov     ecx, [ebp+arg_4]
.text$mn:000037E9                 mov     edx, [ebp+Dst]
.text$mn:000037EC                 lea     eax, [edx+ecx*2]
.text$mn:000037EF                 push    eax             ; Src
.text$mn:000037F0                 mov     ecx, [ebp+Dst]
.text$mn:000037F3                 push    ecx             ; Dst
.text$mn:000037F4                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000037F9                 add     esp, 0Ch
.text$mn:000037FC                 mov     edx, [ebp+var_C]
.text$mn:000037FF                 push    edx
.text$mn:00003800                 mov     ecx, [ebp+var_4]
.text$mn:00003803                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003808
.text$mn:00003808 loc_3808:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00003808                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00003808                 mov     eax, [ebp+var_4]
.text$mn:0000380B                 mov     esp, ebp
.text$mn:0000380D                 pop     ebp
.text$mn:0000380E                 retn    8
.text$mn:0000380E ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000380E
.text$mn:0000380E ; ---------------------------------------------------------------------------
.text$mn:00003811                 align 4
.text$mn:00003811 _text$mn        ends
.text$mn:00003811
.text$mn:00003814 ; ===========================================================================
.text$mn:00003814
.text$mn:00003814 ; Segment type: Pure code
.text$mn:00003814 ; Segment permissions: Read/Execute
.text$mn:00003814 _text$mn        segment para public 'CODE' use32
.text$mn:00003814                 assume cs:_text$mn
.text$mn:00003814                 ;org 3814h
.text$mn:00003814 ; COMDAT (pick any)
.text$mn:00003814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003814
.text$mn:00003814 ; =============== S U B R O U T I N E =======================================
.text$mn:00003814
.text$mn:00003814 ; Attributes: bp-based frame
.text$mn:00003814
.text$mn:00003814 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00003814                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00003814 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00003814                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00003814                 push    ebp
.text$mn:00003815                 mov     ebp, esp
.text$mn:00003817                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000381C                 pop     ebp
.text$mn:0000381D                 retn
.text$mn:0000381D ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000381D
.text$mn:0000381D ; ---------------------------------------------------------------------------
.text$mn:0000381E                 align 10h
.text$mn:0000381E _text$mn        ends
.text$mn:0000381E
.text$mn:00003820 ; ===========================================================================
.text$mn:00003820
.text$mn:00003820 ; Segment type: Pure code
.text$mn:00003820 ; Segment permissions: Read/Execute
.text$mn:00003820 _text$mn        segment para public 'CODE' use32
.text$mn:00003820                 assume cs:_text$mn
.text$mn:00003820                 ;org 3820h
.text$mn:00003820 ; COMDAT (pick any)
.text$mn:00003820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003820
.text$mn:00003820 ; =============== S U B R O U T I N E =======================================
.text$mn:00003820
.text$mn:00003820 ; Attributes: bp-based frame
.text$mn:00003820
.text$mn:00003820 ; bool __thiscall ContextMenu::isCreated(ContextMenu *__hidden this)
.text$mn:00003820                 public ?isCreated@ContextMenu@@QBE_NXZ
.text$mn:00003820 ?isCreated@ContextMenu@@QBE_NXZ proc near
.text$mn:00003820                                         ; CODE XREF: ContextMenu::~ContextMenu(void)+32p
.text$mn:00003820
.text$mn:00003820 var_8           = dword ptr -8
.text$mn:00003820 var_4           = dword ptr -4
.text$mn:00003820
.text$mn:00003820                 push    ebp
.text$mn:00003821                 mov     ebp, esp
.text$mn:00003823                 sub     esp, 8
.text$mn:00003826                 mov     [ebp+var_8], ecx
.text$mn:00003829                 mov     eax, [ebp+var_8]
.text$mn:0000382C                 cmp     dword ptr [eax+4], 0
.text$mn:00003830                 jz      short loc_383B
.text$mn:00003832                 mov     [ebp+var_4], 1
.text$mn:00003839                 jmp     short loc_3842
.text$mn:0000383B ; ---------------------------------------------------------------------------
.text$mn:0000383B
.text$mn:0000383B loc_383B:                               ; CODE XREF: ContextMenu::isCreated(void)+10j
.text$mn:0000383B                 mov     [ebp+var_4], 0
.text$mn:00003842
.text$mn:00003842 loc_3842:                               ; CODE XREF: ContextMenu::isCreated(void)+19j
.text$mn:00003842                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003845                 mov     esp, ebp
.text$mn:00003847                 pop     ebp
.text$mn:00003848                 retn
.text$mn:00003848 ?isCreated@ContextMenu@@QBE_NXZ endp
.text$mn:00003848
.text$mn:00003848 ; ---------------------------------------------------------------------------
.text$mn:00003849                 align 4
.text$mn:00003849 _text$mn        ends
.text$mn:00003849
.text$mn:0000384C ; ===========================================================================
.text$mn:0000384C
.text$mn:0000384C ; Segment type: Pure code
.text$mn:0000384C ; Segment permissions: Read/Execute
.text$mn:0000384C _text$mn        segment para public 'CODE' use32
.text$mn:0000384C                 assume cs:_text$mn
.text$mn:0000384C                 ;org 384Ch
.text$mn:0000384C ; COMDAT (pick any)
.text$mn:0000384C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000384C
.text$mn:0000384C ; =============== S U B R O U T I N E =======================================
.text$mn:0000384C
.text$mn:0000384C ; Attributes: bp-based frame
.text$mn:0000384C
.text$mn:0000384C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000384C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000384C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000384C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000384C
.text$mn:0000384C var_4           = dword ptr -4
.text$mn:0000384C Str             = dword ptr  8
.text$mn:0000384C
.text$mn:0000384C                 push    ebp
.text$mn:0000384D                 mov     ebp, esp
.text$mn:0000384F                 push    ecx
.text$mn:00003850                 mov     eax, [ebp+Str]
.text$mn:00003853                 movsx   ecx, byte ptr [eax]
.text$mn:00003856                 test    ecx, ecx
.text$mn:00003858                 jnz     short loc_3863
.text$mn:0000385A                 mov     [ebp+var_4], 0
.text$mn:00003861                 jmp     short loc_3872
.text$mn:00003863 ; ---------------------------------------------------------------------------
.text$mn:00003863
.text$mn:00003863 loc_3863:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00003863                 mov     edx, [ebp+Str]
.text$mn:00003866                 push    edx             ; Str
.text$mn:00003867                 call    _strlen
.text$mn:0000386C                 add     esp, 4
.text$mn:0000386F                 mov     [ebp+var_4], eax
.text$mn:00003872
.text$mn:00003872 loc_3872:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00003872                 mov     eax, [ebp+var_4]
.text$mn:00003875                 mov     esp, ebp
.text$mn:00003877                 pop     ebp
.text$mn:00003878                 retn
.text$mn:00003878 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00003878
.text$mn:00003878 ; ---------------------------------------------------------------------------
.text$mn:00003879                 align 4
.text$mn:00003879 _text$mn        ends
.text$mn:00003879
.text$mn:0000387C ; ===========================================================================
.text$mn:0000387C
.text$mn:0000387C ; Segment type: Pure code
.text$mn:0000387C ; Segment permissions: Read/Execute
.text$mn:0000387C _text$mn        segment para public 'CODE' use32
.text$mn:0000387C                 assume cs:_text$mn
.text$mn:0000387C                 ;org 387Ch
.text$mn:0000387C ; COMDAT (pick any)
.text$mn:0000387C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000387C
.text$mn:0000387C ; =============== S U B R O U T I N E =======================================
.text$mn:0000387C
.text$mn:0000387C ; Attributes: bp-based frame
.text$mn:0000387C
.text$mn:0000387C ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000387C                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000387C ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000387C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:0000387C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+21p
.text$mn:0000387C
.text$mn:0000387C var_4           = dword ptr -4
.text$mn:0000387C Str             = dword ptr  8
.text$mn:0000387C
.text$mn:0000387C                 push    ebp
.text$mn:0000387D                 mov     ebp, esp
.text$mn:0000387F                 push    ecx
.text$mn:00003880                 mov     eax, [ebp+Str]
.text$mn:00003883                 movzx   ecx, word ptr [eax]
.text$mn:00003886                 test    ecx, ecx
.text$mn:00003888                 jnz     short loc_3893
.text$mn:0000388A                 mov     [ebp+var_4], 0
.text$mn:00003891                 jmp     short loc_38A2
.text$mn:00003893 ; ---------------------------------------------------------------------------
.text$mn:00003893
.text$mn:00003893 loc_3893:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00003893                 mov     edx, [ebp+Str]
.text$mn:00003896                 push    edx             ; Str
.text$mn:00003897                 call    _wcslen
.text$mn:0000389C                 add     esp, 4
.text$mn:0000389F                 mov     [ebp+var_4], eax
.text$mn:000038A2
.text$mn:000038A2 loc_38A2:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:000038A2                 mov     eax, [ebp+var_4]
.text$mn:000038A5                 mov     esp, ebp
.text$mn:000038A7                 pop     ebp
.text$mn:000038A8                 retn
.text$mn:000038A8 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:000038A8
.text$mn:000038A8 ; ---------------------------------------------------------------------------
.text$mn:000038A9                 align 4
.text$mn:000038A9 _text$mn        ends
.text$mn:000038A9
.text$mn:000038AC ; ===========================================================================
.text$mn:000038AC
.text$mn:000038AC ; Segment type: Pure code
.text$mn:000038AC ; Segment permissions: Read/Execute
.text$mn:000038AC _text$mn        segment para public 'CODE' use32
.text$mn:000038AC                 assume cs:_text$mn
.text$mn:000038AC                 ;org 38ACh
.text$mn:000038AC ; COMDAT (pick any)
.text$mn:000038AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038AC
.text$mn:000038AC ; =============== S U B R O U T I N E =======================================
.text$mn:000038AC
.text$mn:000038AC ; Attributes: bp-based frame
.text$mn:000038AC
.text$mn:000038AC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000038AC                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000038AC ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000038AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000038AC
.text$mn:000038AC var_4           = dword ptr -4
.text$mn:000038AC
.text$mn:000038AC                 push    ebp
.text$mn:000038AD                 mov     ebp, esp
.text$mn:000038AF                 push    ecx
.text$mn:000038B0                 mov     [ebp+var_4], ecx
.text$mn:000038B3                 mov     eax, [ebp+var_4]
.text$mn:000038B6                 push    eax
.text$mn:000038B7                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000038BC                 add     esp, 4
.text$mn:000038BF                 mov     esp, ebp
.text$mn:000038C1                 pop     ebp
.text$mn:000038C2                 retn
.text$mn:000038C2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000038C2
.text$mn:000038C2 ; ---------------------------------------------------------------------------
.text$mn:000038C3                 align 4
.text$mn:000038C3 _text$mn        ends
.text$mn:000038C3
.text$mn:000038C4 ; ===========================================================================
.text$mn:000038C4
.text$mn:000038C4 ; Segment type: Pure code
.text$mn:000038C4 ; Segment permissions: Read/Execute
.text$mn:000038C4 _text$mn        segment para public 'CODE' use32
.text$mn:000038C4                 assume cs:_text$mn
.text$mn:000038C4                 ;org 38C4h
.text$mn:000038C4 ; COMDAT (pick any)
.text$mn:000038C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038C4
.text$mn:000038C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038C4
.text$mn:000038C4 ; Attributes: bp-based frame
.text$mn:000038C4
.text$mn:000038C4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct HMENU__ *>>::max_size(void)const
.text$mn:000038C4                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ
.text$mn:000038C4 ?max_size@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ proc near
.text$mn:000038C4                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::max_size(void)+17p
.text$mn:000038C4
.text$mn:000038C4 var_4           = dword ptr -4
.text$mn:000038C4
.text$mn:000038C4                 push    ebp
.text$mn:000038C5                 mov     ebp, esp
.text$mn:000038C7                 push    ecx
.text$mn:000038C8                 mov     [ebp+var_4], ecx
.text$mn:000038CB                 mov     eax, [ebp+var_4]
.text$mn:000038CE                 push    eax
.text$mn:000038CF                 call    ?max_size@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAIABV?$allocator@PAUHMENU__@@@2@@Z ; std::allocator_traits<std::allocator<HMENU__ *>>::max_size(std::allocator<HMENU__ *> const &)
.text$mn:000038D4                 add     esp, 4
.text$mn:000038D7                 mov     esp, ebp
.text$mn:000038D9                 pop     ebp
.text$mn:000038DA                 retn
.text$mn:000038DA ?max_size@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ endp
.text$mn:000038DA
.text$mn:000038DA ; ---------------------------------------------------------------------------
.text$mn:000038DB                 align 4
.text$mn:000038DB _text$mn        ends
.text$mn:000038DB
.text$mn:000038DC ; ===========================================================================
.text$mn:000038DC
.text$mn:000038DC ; Segment type: Pure code
.text$mn:000038DC ; Segment permissions: Read/Execute
.text$mn:000038DC _text$mn        segment para public 'CODE' use32
.text$mn:000038DC                 assume cs:_text$mn
.text$mn:000038DC                 ;org 38DCh
.text$mn:000038DC ; COMDAT (pick any)
.text$mn:000038DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038DC
.text$mn:000038DC ; =============== S U B R O U T I N E =======================================
.text$mn:000038DC
.text$mn:000038DC ; Attributes: bp-based frame
.text$mn:000038DC
.text$mn:000038DC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:000038DC                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:000038DC ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:000038DC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:000038DC
.text$mn:000038DC var_4           = dword ptr -4
.text$mn:000038DC
.text$mn:000038DC                 push    ebp
.text$mn:000038DD                 mov     ebp, esp
.text$mn:000038DF                 push    ecx
.text$mn:000038E0                 mov     [ebp+var_4], ecx
.text$mn:000038E3                 mov     eax, [ebp+var_4]
.text$mn:000038E6                 push    eax
.text$mn:000038E7                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:000038EC                 add     esp, 4
.text$mn:000038EF                 mov     esp, ebp
.text$mn:000038F1                 pop     ebp
.text$mn:000038F2                 retn
.text$mn:000038F2 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:000038F2
.text$mn:000038F2 ; ---------------------------------------------------------------------------
.text$mn:000038F3                 align 4
.text$mn:000038F3 _text$mn        ends
.text$mn:000038F3
.text$mn:000038F4 ; ===========================================================================
.text$mn:000038F4
.text$mn:000038F4 ; Segment type: Pure code
.text$mn:000038F4 ; Segment permissions: Read/Execute
.text$mn:000038F4 _text$mn        segment para public 'CODE' use32
.text$mn:000038F4                 assume cs:_text$mn
.text$mn:000038F4                 ;org 38F4h
.text$mn:000038F4 ; COMDAT (pick any)
.text$mn:000038F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038F4
.text$mn:000038F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038F4
.text$mn:000038F4 ; Attributes: bp-based frame
.text$mn:000038F4
.text$mn:000038F4 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000038F4                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000038F4 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000038F4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000038F4
.text$mn:000038F4 var_4           = dword ptr -4
.text$mn:000038F4
.text$mn:000038F4                 push    ebp
.text$mn:000038F5                 mov     ebp, esp
.text$mn:000038F7                 push    ecx
.text$mn:000038F8                 mov     [ebp+var_4], ecx
.text$mn:000038FB                 or      eax, 0FFFFFFFFh
.text$mn:000038FE                 mov     esp, ebp
.text$mn:00003900                 pop     ebp
.text$mn:00003901                 retn
.text$mn:00003901 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00003901
.text$mn:00003901 ; ---------------------------------------------------------------------------
.text$mn:00003902                 align 4
.text$mn:00003902 _text$mn        ends
.text$mn:00003902
.text$mn:00003904 ; ===========================================================================
.text$mn:00003904
.text$mn:00003904 ; Segment type: Pure code
.text$mn:00003904 ; Segment permissions: Read/Execute
.text$mn:00003904 _text$mn        segment para public 'CODE' use32
.text$mn:00003904                 assume cs:_text$mn
.text$mn:00003904                 ;org 3904h
.text$mn:00003904 ; COMDAT (pick any)
.text$mn:00003904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003904
.text$mn:00003904 ; =============== S U B R O U T I N E =======================================
.text$mn:00003904
.text$mn:00003904 ; Attributes: bp-based frame
.text$mn:00003904
.text$mn:00003904 ; public: unsigned int __thiscall std::allocator<struct HMENU__ *>::max_size(void)const
.text$mn:00003904                 public ?max_size@?$allocator@PAUHMENU__@@@std@@QBEIXZ
.text$mn:00003904 ?max_size@?$allocator@PAUHMENU__@@@std@@QBEIXZ proc near
.text$mn:00003904                                         ; CODE XREF: std::allocator_traits<std::allocator<HMENU__ *>>::max_size(std::allocator<HMENU__ *> const &)+6p
.text$mn:00003904
.text$mn:00003904 var_4           = dword ptr -4
.text$mn:00003904
.text$mn:00003904                 push    ebp
.text$mn:00003905                 mov     ebp, esp
.text$mn:00003907                 push    ecx
.text$mn:00003908                 mov     [ebp+var_4], ecx
.text$mn:0000390B                 mov     eax, 3FFFFFFFh
.text$mn:00003910                 mov     esp, ebp
.text$mn:00003912                 pop     ebp
.text$mn:00003913                 retn
.text$mn:00003913 ?max_size@?$allocator@PAUHMENU__@@@std@@QBEIXZ endp
.text$mn:00003913
.text$mn:00003913 _text$mn        ends
.text$mn:00003913
.text$mn:00003914 ; ===========================================================================
.text$mn:00003914
.text$mn:00003914 ; Segment type: Pure code
.text$mn:00003914 ; Segment permissions: Read/Execute
.text$mn:00003914 _text$mn        segment para public 'CODE' use32
.text$mn:00003914                 assume cs:_text$mn
.text$mn:00003914                 ;org 3914h
.text$mn:00003914 ; COMDAT (pick any)
.text$mn:00003914                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003914
.text$mn:00003914 ; =============== S U B R O U T I N E =======================================
.text$mn:00003914
.text$mn:00003914 ; Attributes: bp-based frame
.text$mn:00003914
.text$mn:00003914 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:00003914                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:00003914 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:00003914                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:00003914
.text$mn:00003914 var_4           = dword ptr -4
.text$mn:00003914
.text$mn:00003914                 push    ebp
.text$mn:00003915                 mov     ebp, esp
.text$mn:00003917                 push    ecx
.text$mn:00003918                 mov     [ebp+var_4], ecx
.text$mn:0000391B                 mov     eax, 7FFFFFFFh
.text$mn:00003920                 mov     esp, ebp
.text$mn:00003922                 pop     ebp
.text$mn:00003923                 retn
.text$mn:00003923 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:00003923
.text$mn:00003923 _text$mn        ends
.text$mn:00003923
.text$mn:00003924 ; ===========================================================================
.text$mn:00003924
.text$mn:00003924 ; Segment type: Pure code
.text$mn:00003924 ; Segment permissions: Read/Execute
.text$mn:00003924 _text$mn        segment para public 'CODE' use32
.text$mn:00003924                 assume cs:_text$mn
.text$mn:00003924                 ;org 3924h
.text$mn:00003924 ; COMDAT (pick any)
.text$mn:00003924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003924
.text$mn:00003924 ; =============== S U B R O U T I N E =======================================
.text$mn:00003924
.text$mn:00003924 ; Attributes: bp-based frame
.text$mn:00003924
.text$mn:00003924 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00003924                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00003924 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00003924                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00003924
.text$mn:00003924 arg_0           = dword ptr  8
.text$mn:00003924
.text$mn:00003924                 push    ebp
.text$mn:00003925                 mov     ebp, esp
.text$mn:00003927                 mov     ecx, [ebp+arg_0]
.text$mn:0000392A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000392F                 pop     ebp
.text$mn:00003930                 retn
.text$mn:00003930 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00003930
.text$mn:00003930 ; ---------------------------------------------------------------------------
.text$mn:00003931                 align 4
.text$mn:00003931 _text$mn        ends
.text$mn:00003931
.text$mn:00003934 ; ===========================================================================
.text$mn:00003934
.text$mn:00003934 ; Segment type: Pure code
.text$mn:00003934 ; Segment permissions: Read/Execute
.text$mn:00003934 _text$mn        segment para public 'CODE' use32
.text$mn:00003934                 assume cs:_text$mn
.text$mn:00003934                 ;org 3934h
.text$mn:00003934 ; COMDAT (pick any)
.text$mn:00003934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003934
.text$mn:00003934 ; =============== S U B R O U T I N E =======================================
.text$mn:00003934
.text$mn:00003934 ; Attributes: bp-based frame
.text$mn:00003934
.text$mn:00003934 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct HMENU__ *>>::max_size(class std::allocator<struct HMENU__ *> const &)
.text$mn:00003934                 public ?max_size@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAIABV?$allocator@PAUHMENU__@@@2@@Z
.text$mn:00003934 ?max_size@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAIABV?$allocator@PAUHMENU__@@@2@@Z proc near
.text$mn:00003934                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HMENU__ *>>::max_size(void)+Bp
.text$mn:00003934
.text$mn:00003934 arg_0           = dword ptr  8
.text$mn:00003934
.text$mn:00003934                 push    ebp
.text$mn:00003935                 mov     ebp, esp
.text$mn:00003937                 mov     ecx, [ebp+arg_0]
.text$mn:0000393A                 call    ?max_size@?$allocator@PAUHMENU__@@@std@@QBEIXZ ; std::allocator<HMENU__ *>::max_size(void)
.text$mn:0000393F                 pop     ebp
.text$mn:00003940                 retn
.text$mn:00003940 ?max_size@?$allocator_traits@V?$allocator@PAUHMENU__@@@std@@@std@@SAIABV?$allocator@PAUHMENU__@@@2@@Z endp
.text$mn:00003940
.text$mn:00003940 ; ---------------------------------------------------------------------------
.text$mn:00003941                 align 4
.text$mn:00003941 _text$mn        ends
.text$mn:00003941
.text$mn:00003944 ; ===========================================================================
.text$mn:00003944
.text$mn:00003944 ; Segment type: Pure code
.text$mn:00003944 ; Segment permissions: Read/Execute
.text$mn:00003944 _text$mn        segment para public 'CODE' use32
.text$mn:00003944                 assume cs:_text$mn
.text$mn:00003944                 ;org 3944h
.text$mn:00003944 ; COMDAT (pick any)
.text$mn:00003944                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003944
.text$mn:00003944 ; =============== S U B R O U T I N E =======================================
.text$mn:00003944
.text$mn:00003944 ; Attributes: bp-based frame
.text$mn:00003944
.text$mn:00003944 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:00003944                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:00003944 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:00003944                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:00003944
.text$mn:00003944 arg_0           = dword ptr  8
.text$mn:00003944
.text$mn:00003944                 push    ebp
.text$mn:00003945                 mov     ebp, esp
.text$mn:00003947                 mov     ecx, [ebp+arg_0]
.text$mn:0000394A                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000394F                 pop     ebp
.text$mn:00003950                 retn
.text$mn:00003950 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:00003950
.text$mn:00003950 ; ---------------------------------------------------------------------------
.text$mn:00003951                 align 4
.text$mn:00003951 _text$mn        ends
.text$mn:00003951
.text$mn:00003954 ; ===========================================================================
.text$mn:00003954
.text$mn:00003954 ; Segment type: Pure code
.text$mn:00003954 ; Segment permissions: Read/Execute
.text$mn:00003954 _text$mn        segment para public 'CODE' use32
.text$mn:00003954                 assume cs:_text$mn
.text$mn:00003954                 ;org 3954h
.text$mn:00003954 ; COMDAT (pick any)
.text$mn:00003954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003954
.text$mn:00003954 ; =============== S U B R O U T I N E =======================================
.text$mn:00003954
.text$mn:00003954 ; Attributes: bp-based frame
.text$mn:00003954
.text$mn:00003954 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00003954                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00003954 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00003954                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00003954                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00003954
.text$mn:00003954 var_10          = dword ptr -10h
.text$mn:00003954 var_C           = dword ptr -0Ch
.text$mn:00003954 var_8           = dword ptr -8
.text$mn:00003954 var_1           = byte ptr -1
.text$mn:00003954
.text$mn:00003954                 push    ebp
.text$mn:00003955                 mov     ebp, esp
.text$mn:00003957                 sub     esp, 10h
.text$mn:0000395A                 mov     [ebp+var_10], ecx
.text$mn:0000395D                 lea     eax, [ebp+var_1]
.text$mn:00003960                 push    eax
.text$mn:00003961                 mov     ecx, [ebp+var_10]
.text$mn:00003964                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003969                 mov     ecx, eax
.text$mn:0000396B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00003970                 mov     [ebp+var_8], eax
.text$mn:00003973                 cmp     [ebp+var_8], 1
.text$mn:00003977                 ja      short loc_3982
.text$mn:00003979                 mov     [ebp+var_C], 1
.text$mn:00003980                 jmp     short loc_398B
.text$mn:00003982 ; ---------------------------------------------------------------------------
.text$mn:00003982
.text$mn:00003982 loc_3982:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00003982                 mov     ecx, [ebp+var_8]
.text$mn:00003985                 sub     ecx, 1
.text$mn:00003988                 mov     [ebp+var_C], ecx
.text$mn:0000398B
.text$mn:0000398B loc_398B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000398B                 mov     eax, [ebp+var_C]
.text$mn:0000398E                 mov     esp, ebp
.text$mn:00003990                 pop     ebp
.text$mn:00003991                 retn
.text$mn:00003991 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003991
.text$mn:00003991 ; ---------------------------------------------------------------------------
.text$mn:00003992                 align 4
.text$mn:00003992 _text$mn        ends
.text$mn:00003992
.text$mn:00003994 ; ===========================================================================
.text$mn:00003994
.text$mn:00003994 ; Segment type: Pure code
.text$mn:00003994 ; Segment permissions: Read/Execute
.text$mn:00003994 _text$mn        segment para public 'CODE' use32
.text$mn:00003994                 assume cs:_text$mn
.text$mn:00003994                 ;org 3994h
.text$mn:00003994 ; COMDAT (pick any)
.text$mn:00003994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003994
.text$mn:00003994 ; =============== S U B R O U T I N E =======================================
.text$mn:00003994
.text$mn:00003994 ; Attributes: bp-based frame
.text$mn:00003994
.text$mn:00003994 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00003994                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00003994 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00003994                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:00003994                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:00003994
.text$mn:00003994 var_10          = dword ptr -10h
.text$mn:00003994 var_C           = dword ptr -0Ch
.text$mn:00003994 var_8           = dword ptr -8
.text$mn:00003994 var_1           = byte ptr -1
.text$mn:00003994
.text$mn:00003994                 push    ebp
.text$mn:00003995                 mov     ebp, esp
.text$mn:00003997                 sub     esp, 10h
.text$mn:0000399A                 mov     [ebp+var_10], ecx
.text$mn:0000399D                 lea     eax, [ebp+var_1]
.text$mn:000039A0                 push    eax
.text$mn:000039A1                 mov     ecx, [ebp+var_10]
.text$mn:000039A4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000039A9                 mov     ecx, eax
.text$mn:000039AB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:000039B0                 mov     [ebp+var_8], eax
.text$mn:000039B3                 cmp     [ebp+var_8], 1
.text$mn:000039B7                 ja      short loc_39C2
.text$mn:000039B9                 mov     [ebp+var_C], 1
.text$mn:000039C0                 jmp     short loc_39CB
.text$mn:000039C2 ; ---------------------------------------------------------------------------
.text$mn:000039C2
.text$mn:000039C2 loc_39C2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:000039C2                 mov     ecx, [ebp+var_8]
.text$mn:000039C5                 sub     ecx, 1
.text$mn:000039C8                 mov     [ebp+var_C], ecx
.text$mn:000039CB
.text$mn:000039CB loc_39CB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:000039CB                 mov     eax, [ebp+var_C]
.text$mn:000039CE                 mov     esp, ebp
.text$mn:000039D0                 pop     ebp
.text$mn:000039D1                 retn
.text$mn:000039D1 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:000039D1
.text$mn:000039D1 ; ---------------------------------------------------------------------------
.text$mn:000039D2                 align 4
.text$mn:000039D2 _text$mn        ends
.text$mn:000039D2
.text$mn:000039D4 ; ===========================================================================
.text$mn:000039D4
.text$mn:000039D4 ; Segment type: Pure code
.text$mn:000039D4 ; Segment permissions: Read/Execute
.text$mn:000039D4 _text$mn        segment para public 'CODE' use32
.text$mn:000039D4                 assume cs:_text$mn
.text$mn:000039D4                 ;org 39D4h
.text$mn:000039D4 ; COMDAT (pick any)
.text$mn:000039D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039D4
.text$mn:000039D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039D4
.text$mn:000039D4 ; Attributes: bp-based frame
.text$mn:000039D4
.text$mn:000039D4 ; public: unsigned int __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::max_size(void)const
.text$mn:000039D4                 public ?max_size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ
.text$mn:000039D4 ?max_size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ proc near
.text$mn:000039D4                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Grow_to(uint)+17p
.text$mn:000039D4                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)+18p
.text$mn:000039D4
.text$mn:000039D4 var_8           = dword ptr -8
.text$mn:000039D4 var_1           = byte ptr -1
.text$mn:000039D4
.text$mn:000039D4                 push    ebp
.text$mn:000039D5                 mov     ebp, esp
.text$mn:000039D7                 sub     esp, 8
.text$mn:000039DA                 mov     [ebp+var_8], ecx
.text$mn:000039DD                 lea     eax, [ebp+var_1]
.text$mn:000039E0                 push    eax
.text$mn:000039E1                 mov     ecx, [ebp+var_8]
.text$mn:000039E4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:000039E9                 mov     ecx, eax
.text$mn:000039EB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::max_size(void)
.text$mn:000039F0                 mov     esp, ebp
.text$mn:000039F2                 pop     ebp
.text$mn:000039F3                 retn
.text$mn:000039F3 ?max_size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ endp
.text$mn:000039F3
.text$mn:000039F3 _text$mn        ends
.text$mn:000039F3
.text$mn:000039F4 ; ===========================================================================
.text$mn:000039F4
.text$mn:000039F4 ; Segment type: Pure code
.text$mn:000039F4 ; Segment permissions: Read/Execute
.text$mn:000039F4 _text$mn        segment para public 'CODE' use32
.text$mn:000039F4                 assume cs:_text$mn
.text$mn:000039F4                 ;org 39F4h
.text$mn:000039F4 ; COMDAT (pick any)
.text$mn:000039F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039F4
.text$mn:000039F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039F4
.text$mn:000039F4 ; Attributes: bp-based frame
.text$mn:000039F4
.text$mn:000039F4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000039F4                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000039F4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000039F4                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000039F4                                         ; DATA XREF: .rdata:0000468Co
.text$mn:000039F4
.text$mn:000039F4 var_1C          = dword ptr -1Ch
.text$mn:000039F4 var_18          = dword ptr -18h
.text$mn:000039F4 Str             = dword ptr -14h
.text$mn:000039F4 var_10          = dword ptr -10h
.text$mn:000039F4 var_C           = dword ptr -0Ch
.text$mn:000039F4 var_4           = dword ptr -4
.text$mn:000039F4 arg_0           = dword ptr  8
.text$mn:000039F4 arg_4           = dword ptr  0Ch
.text$mn:000039F4
.text$mn:000039F4                 push    ebp
.text$mn:000039F5                 mov     ebp, esp
.text$mn:000039F7                 push    0FFFFFFFFh
.text$mn:000039F9                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000039FE                 mov     eax, large fs:0
.text$mn:00003A04                 push    eax
.text$mn:00003A05                 sub     esp, 10h
.text$mn:00003A08                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A0D                 xor     eax, ebp
.text$mn:00003A0F                 push    eax
.text$mn:00003A10                 lea     eax, [ebp+var_C]
.text$mn:00003A13                 mov     large fs:0, eax
.text$mn:00003A19                 mov     [ebp+var_1C], ecx
.text$mn:00003A1C                 mov     [ebp+var_18], 0
.text$mn:00003A23                 mov     eax, [ebp+arg_4]
.text$mn:00003A26                 push    eax             ; int
.text$mn:00003A27                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003A2C                 add     esp, 4
.text$mn:00003A2F                 mov     [ebp+var_10], eax
.text$mn:00003A32                 cmp     [ebp+var_10], 0
.text$mn:00003A36                 jz      short loc_3A40
.text$mn:00003A38                 mov     ecx, [ebp+var_10]
.text$mn:00003A3B                 mov     [ebp+Str], ecx
.text$mn:00003A3E                 jmp     short loc_3A47
.text$mn:00003A40 ; ---------------------------------------------------------------------------
.text$mn:00003A40
.text$mn:00003A40 loc_3A40:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00003A40                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00003A47
.text$mn:00003A47 loc_3A47:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00003A47                 mov     edx, [ebp+Str]
.text$mn:00003A4A                 push    edx             ; Str
.text$mn:00003A4B                 mov     ecx, [ebp+arg_0]
.text$mn:00003A4E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003A53                 mov     [ebp+var_4], 0
.text$mn:00003A5A                 mov     eax, [ebp+var_18]
.text$mn:00003A5D                 or      eax, 1
.text$mn:00003A60                 mov     [ebp+var_18], eax
.text$mn:00003A63                 mov     eax, [ebp+arg_0]
.text$mn:00003A66                 mov     ecx, [ebp+var_C]
.text$mn:00003A69                 mov     large fs:0, ecx
.text$mn:00003A70                 pop     ecx
.text$mn:00003A71                 mov     esp, ebp
.text$mn:00003A73                 pop     ebp
.text$mn:00003A74                 retn    8
.text$mn:00003A74 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003A74
.text$mn:00003A74 ; ---------------------------------------------------------------------------
.text$mn:00003A77                 align 4
.text$mn:00003A77 _text$mn        ends
.text$mn:00003A77
.text$x:00003A78 ; ===========================================================================
.text$x:00003A78
.text$x:00003A78 ; Segment type: Pure code
.text$x:00003A78 ; Segment permissions: Read/Execute
.text$x:00003A78 _text$x         segment para public 'CODE' use32
.text$x:00003A78                 assume cs:_text$x
.text$x:00003A78                 ;org 3A78h
.text$x:00003A78 ; COMDAT (pick associative to section at 39F4)
.text$x:00003A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003A78
.text$x:00003A78 ; =============== S U B R O U T I N E =======================================
.text$x:00003A78
.text$x:00003A78
.text$x:00003A78 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003A78                                         ; DATA XREF: .xdata$x:00004100o
.text$x:00003A78                 mov     eax, [ebp-18h]
.text$x:00003A7B                 and     eax, 1
.text$x:00003A7E                 jz      $LN6
.text$x:00003A84                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00003A88                 mov     ecx, [ebp+8]
.text$x:00003A8B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003A90 ; ---------------------------------------------------------------------------
.text$x:00003A90
.text$x:00003A90 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003A90                 retn
.text$x:00003A90 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003A90
.text$x:00003A91
.text$x:00003A91 ; =============== S U B R O U T I N E =======================================
.text$x:00003A91
.text$x:00003A91
.text$x:00003A91 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003A91                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00003A91
.text$x:00003A91 arg_4           = dword ptr  8
.text$x:00003A91
.text$x:00003A91                 mov     edx, [esp+arg_4]
.text$x:00003A95                 lea     eax, [edx+0Ch]
.text$x:00003A98                 mov     ecx, [edx-14h]
.text$x:00003A9B                 xor     ecx, eax
.text$x:00003A9D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AA2                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003AA7                 jmp     ___CxxFrameHandler3
.text$x:00003AA7 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003AA7
.text$x:00003AA7 _text$x         ends
.text$x:00003AA7
.text$mn:00003AAC ; ===========================================================================
.text$mn:00003AAC
.text$mn:00003AAC ; Segment type: Pure code
.text$mn:00003AAC ; Segment permissions: Read/Execute
.text$mn:00003AAC _text$mn        segment para public 'CODE' use32
.text$mn:00003AAC                 assume cs:_text$mn
.text$mn:00003AAC                 ;org 3AACh
.text$mn:00003AAC ; COMDAT (pick any)
.text$mn:00003AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AAC
.text$mn:00003AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003AAC
.text$mn:00003AAC ; Attributes: bp-based frame
.text$mn:00003AAC
.text$mn:00003AAC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00003AAC                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003AAC ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003AAC                                         ; DATA XREF: .rdata:000046C0o
.text$mn:00003AAC
.text$mn:00003AAC var_14          = dword ptr -14h
.text$mn:00003AAC var_10          = dword ptr -10h
.text$mn:00003AAC var_C           = dword ptr -0Ch
.text$mn:00003AAC var_4           = dword ptr -4
.text$mn:00003AAC arg_0           = dword ptr  8
.text$mn:00003AAC arg_4           = dword ptr  0Ch
.text$mn:00003AAC
.text$mn:00003AAC                 push    ebp
.text$mn:00003AAD                 mov     ebp, esp
.text$mn:00003AAF                 push    0FFFFFFFFh
.text$mn:00003AB1                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003AB6                 mov     eax, large fs:0
.text$mn:00003ABC                 push    eax
.text$mn:00003ABD                 sub     esp, 8
.text$mn:00003AC0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AC5                 xor     eax, ebp
.text$mn:00003AC7                 push    eax
.text$mn:00003AC8                 lea     eax, [ebp+var_C]
.text$mn:00003ACB                 mov     large fs:0, eax
.text$mn:00003AD1                 mov     [ebp+var_14], ecx
.text$mn:00003AD4                 mov     [ebp+var_10], 0
.text$mn:00003ADB                 cmp     [ebp+arg_4], 1
.text$mn:00003ADF                 jnz     short loc_3B05
.text$mn:00003AE1                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00003AE6                 mov     ecx, [ebp+arg_0]
.text$mn:00003AE9                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003AEE                 mov     [ebp+var_4], 0
.text$mn:00003AF5                 mov     eax, [ebp+var_10]
.text$mn:00003AF8                 or      eax, 1
.text$mn:00003AFB                 mov     [ebp+var_10], eax
.text$mn:00003AFE                 mov     eax, [ebp+arg_0]
.text$mn:00003B01                 jmp     short loc_3B28
.text$mn:00003B03 ; ---------------------------------------------------------------------------
.text$mn:00003B03                 jmp     short loc_3B28
.text$mn:00003B05 ; ---------------------------------------------------------------------------
.text$mn:00003B05
.text$mn:00003B05 loc_3B05:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00003B05                 mov     ecx, [ebp+arg_4]
.text$mn:00003B08                 push    ecx
.text$mn:00003B09                 mov     edx, [ebp+arg_0]
.text$mn:00003B0C                 push    edx
.text$mn:00003B0D                 mov     ecx, [ebp+var_14]
.text$mn:00003B10                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00003B15                 mov     [ebp+var_4], 0
.text$mn:00003B1C                 mov     eax, [ebp+var_10]
.text$mn:00003B1F                 or      eax, 1
.text$mn:00003B22                 mov     [ebp+var_10], eax
.text$mn:00003B25                 mov     eax, [ebp+arg_0]
.text$mn:00003B28
.text$mn:00003B28 loc_3B28:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00003B28                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00003B28                 mov     ecx, [ebp+var_C]
.text$mn:00003B2B                 mov     large fs:0, ecx
.text$mn:00003B32                 pop     ecx
.text$mn:00003B33                 mov     esp, ebp
.text$mn:00003B35                 pop     ebp
.text$mn:00003B36                 retn    8
.text$mn:00003B36 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003B36
.text$mn:00003B36 ; ---------------------------------------------------------------------------
.text$mn:00003B39                 align 4
.text$mn:00003B39 _text$mn        ends
.text$mn:00003B39
.text$x:00003B3C ; ===========================================================================
.text$x:00003B3C
.text$x:00003B3C ; Segment type: Pure code
.text$x:00003B3C ; Segment permissions: Read/Execute
.text$x:00003B3C _text$x         segment para public 'CODE' use32
.text$x:00003B3C                 assume cs:_text$x
.text$x:00003B3C                 ;org 3B3Ch
.text$x:00003B3C ; COMDAT (pick associative to section at 3AAC)
.text$x:00003B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B3C
.text$x:00003B3C ; =============== S U B R O U T I N E =======================================
.text$x:00003B3C
.text$x:00003B3C
.text$x:00003B3C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003B3C                                         ; DATA XREF: .xdata$x:00004184o
.text$x:00003B3C                 mov     eax, [ebp-10h]
.text$x:00003B3F                 and     eax, 1
.text$x:00003B42                 jz      $LN6_0
.text$x:00003B48                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003B4C                 mov     ecx, [ebp+8]
.text$x:00003B4F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003B54 ; ---------------------------------------------------------------------------
.text$x:00003B54
.text$x:00003B54 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003B54                 retn
.text$x:00003B54 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003B54
.text$x:00003B55
.text$x:00003B55 ; =============== S U B R O U T I N E =======================================
.text$x:00003B55
.text$x:00003B55
.text$x:00003B55 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003B55                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00003B55
.text$x:00003B55 arg_4           = dword ptr  8
.text$x:00003B55
.text$x:00003B55                 mov     edx, [esp+arg_4]
.text$x:00003B59                 lea     eax, [edx+0Ch]
.text$x:00003B5C                 mov     ecx, [edx-0Ch]
.text$x:00003B5F                 xor     ecx, eax
.text$x:00003B61                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003B66                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003B6B                 jmp     ___CxxFrameHandler3
.text$x:00003B6B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003B6B
.text$x:00003B6B _text$x         ends
.text$x:00003B6B
.text$mn:00003B70 ; ===========================================================================
.text$mn:00003B70
.text$mn:00003B70 ; Segment type: Pure code
.text$mn:00003B70 ; Segment permissions: Read/Execute
.text$mn:00003B70 _text$mn        segment para public 'CODE' use32
.text$mn:00003B70                 assume cs:_text$mn
.text$mn:00003B70                 ;org 3B70h
.text$mn:00003B70 ; COMDAT (pick any)
.text$mn:00003B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B70
.text$mn:00003B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B70
.text$mn:00003B70 ; Attributes: bp-based frame
.text$mn:00003B70
.text$mn:00003B70 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00003B70                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003B70 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003B70                                         ; DATA XREF: .rdata:00004700o
.text$mn:00003B70
.text$mn:00003B70 var_1C          = dword ptr -1Ch
.text$mn:00003B70 var_18          = dword ptr -18h
.text$mn:00003B70 Str             = dword ptr -14h
.text$mn:00003B70 var_10          = dword ptr -10h
.text$mn:00003B70 var_C           = dword ptr -0Ch
.text$mn:00003B70 var_4           = dword ptr -4
.text$mn:00003B70 arg_0           = dword ptr  8
.text$mn:00003B70 arg_4           = dword ptr  0Ch
.text$mn:00003B70
.text$mn:00003B70                 push    ebp
.text$mn:00003B71                 mov     ebp, esp
.text$mn:00003B73                 push    0FFFFFFFFh
.text$mn:00003B75                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003B7A                 mov     eax, large fs:0
.text$mn:00003B80                 push    eax
.text$mn:00003B81                 sub     esp, 10h
.text$mn:00003B84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B89                 xor     eax, ebp
.text$mn:00003B8B                 push    eax
.text$mn:00003B8C                 lea     eax, [ebp+var_C]
.text$mn:00003B8F                 mov     large fs:0, eax
.text$mn:00003B95                 mov     [ebp+var_1C], ecx
.text$mn:00003B98                 mov     [ebp+var_18], 0
.text$mn:00003B9F                 mov     eax, [ebp+arg_4]
.text$mn:00003BA2                 push    eax             ; int
.text$mn:00003BA3                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00003BA8                 add     esp, 4
.text$mn:00003BAB                 mov     [ebp+var_10], eax
.text$mn:00003BAE                 cmp     [ebp+var_10], 0
.text$mn:00003BB2                 jz      short loc_3BBC
.text$mn:00003BB4                 mov     ecx, [ebp+var_10]
.text$mn:00003BB7                 mov     [ebp+Str], ecx
.text$mn:00003BBA                 jmp     short loc_3BC3
.text$mn:00003BBC ; ---------------------------------------------------------------------------
.text$mn:00003BBC
.text$mn:00003BBC loc_3BBC:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00003BBC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00003BC3
.text$mn:00003BC3 loc_3BC3:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00003BC3                 mov     edx, [ebp+Str]
.text$mn:00003BC6                 push    edx             ; Str
.text$mn:00003BC7                 mov     ecx, [ebp+arg_0]
.text$mn:00003BCA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003BCF                 mov     [ebp+var_4], 0
.text$mn:00003BD6                 mov     eax, [ebp+var_18]
.text$mn:00003BD9                 or      eax, 1
.text$mn:00003BDC                 mov     [ebp+var_18], eax
.text$mn:00003BDF                 mov     eax, [ebp+arg_0]
.text$mn:00003BE2                 mov     ecx, [ebp+var_C]
.text$mn:00003BE5                 mov     large fs:0, ecx
.text$mn:00003BEC                 pop     ecx
.text$mn:00003BED                 mov     esp, ebp
.text$mn:00003BEF                 pop     ebp
.text$mn:00003BF0                 retn    8
.text$mn:00003BF0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003BF0
.text$mn:00003BF0 ; ---------------------------------------------------------------------------
.text$mn:00003BF3                 align 4
.text$mn:00003BF3 _text$mn        ends
.text$mn:00003BF3
.text$x:00003BF4 ; ===========================================================================
.text$x:00003BF4
.text$x:00003BF4 ; Segment type: Pure code
.text$x:00003BF4 ; Segment permissions: Read/Execute
.text$x:00003BF4 _text$x         segment para public 'CODE' use32
.text$x:00003BF4                 assume cs:_text$x
.text$x:00003BF4                 ;org 3BF4h
.text$x:00003BF4 ; COMDAT (pick associative to section at 3B70)
.text$x:00003BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BF4
.text$x:00003BF4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BF4
.text$x:00003BF4
.text$x:00003BF4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003BF4                                         ; DATA XREF: .xdata$x:00004208o
.text$x:00003BF4                 mov     eax, [ebp-18h]
.text$x:00003BF7                 and     eax, 1
.text$x:00003BFA                 jz      $LN6_1
.text$x:00003C00                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00003C04                 mov     ecx, [ebp+8]
.text$x:00003C07                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003C0C ; ---------------------------------------------------------------------------
.text$x:00003C0C
.text$x:00003C0C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003C0C                 retn
.text$x:00003C0C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003C0C
.text$x:00003C0D
.text$x:00003C0D ; =============== S U B R O U T I N E =======================================
.text$x:00003C0D
.text$x:00003C0D
.text$x:00003C0D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003C0D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00003C0D
.text$x:00003C0D arg_4           = dword ptr  8
.text$x:00003C0D
.text$x:00003C0D                 mov     edx, [esp+arg_4]
.text$x:00003C11                 lea     eax, [edx+0Ch]
.text$x:00003C14                 mov     ecx, [edx-14h]
.text$x:00003C17                 xor     ecx, eax
.text$x:00003C19                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C1E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003C23                 jmp     ___CxxFrameHandler3
.text$x:00003C23 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003C23
.text$x:00003C23 _text$x         ends
.text$x:00003C23
.text$mn:00003C28 ; ===========================================================================
.text$mn:00003C28
.text$mn:00003C28 ; Segment type: Pure code
.text$mn:00003C28 ; Segment permissions: Read/Execute
.text$mn:00003C28 _text$mn        segment para public 'CODE' use32
.text$mn:00003C28                 assume cs:_text$mn
.text$mn:00003C28                 ;org 3C28h
.text$mn:00003C28 ; COMDAT (pick any)
.text$mn:00003C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C28
.text$mn:00003C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C28
.text$mn:00003C28 ; Attributes: bp-based frame
.text$mn:00003C28
.text$mn:00003C28 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00003C28                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00003C28 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00003C28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00003C28
.text$mn:00003C28 var_4           = dword ptr -4
.text$mn:00003C28 Dst             = dword ptr  8
.text$mn:00003C28 Src             = dword ptr  0Ch
.text$mn:00003C28 Size            = dword ptr  10h
.text$mn:00003C28
.text$mn:00003C28                 push    ebp
.text$mn:00003C29                 mov     ebp, esp
.text$mn:00003C2B                 push    ecx
.text$mn:00003C2C                 cmp     [ebp+Size], 0
.text$mn:00003C30                 jnz     short loc_3C3A
.text$mn:00003C32                 mov     eax, [ebp+Dst]
.text$mn:00003C35                 mov     [ebp+var_4], eax
.text$mn:00003C38                 jmp     short loc_3C51
.text$mn:00003C3A ; ---------------------------------------------------------------------------
.text$mn:00003C3A
.text$mn:00003C3A loc_3C3A:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00003C3A                 mov     ecx, [ebp+Size]
.text$mn:00003C3D                 push    ecx             ; Size
.text$mn:00003C3E                 mov     edx, [ebp+Src]
.text$mn:00003C41                 push    edx             ; Src
.text$mn:00003C42                 mov     eax, [ebp+Dst]
.text$mn:00003C45                 push    eax             ; Dst
.text$mn:00003C46                 call    _memmove
.text$mn:00003C4B                 add     esp, 0Ch
.text$mn:00003C4E                 mov     [ebp+var_4], eax
.text$mn:00003C51
.text$mn:00003C51 loc_3C51:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00003C51                 mov     eax, [ebp+var_4]
.text$mn:00003C54                 mov     esp, ebp
.text$mn:00003C56                 pop     ebp
.text$mn:00003C57                 retn
.text$mn:00003C57 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00003C57
.text$mn:00003C57 _text$mn        ends
.text$mn:00003C57
.text$mn:00003C58 ; ===========================================================================
.text$mn:00003C58
.text$mn:00003C58 ; Segment type: Pure code
.text$mn:00003C58 ; Segment permissions: Read/Execute
.text$mn:00003C58 _text$mn        segment para public 'CODE' use32
.text$mn:00003C58                 assume cs:_text$mn
.text$mn:00003C58                 ;org 3C58h
.text$mn:00003C58 ; COMDAT (pick any)
.text$mn:00003C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C58
.text$mn:00003C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C58
.text$mn:00003C58 ; Attributes: bp-based frame
.text$mn:00003C58
.text$mn:00003C58 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00003C58                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00003C58 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00003C58                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:00003C58
.text$mn:00003C58 var_4           = dword ptr -4
.text$mn:00003C58 Dst             = dword ptr  8
.text$mn:00003C58 Src             = dword ptr  0Ch
.text$mn:00003C58 arg_8           = dword ptr  10h
.text$mn:00003C58
.text$mn:00003C58                 push    ebp
.text$mn:00003C59                 mov     ebp, esp
.text$mn:00003C5B                 push    ecx
.text$mn:00003C5C                 cmp     [ebp+arg_8], 0
.text$mn:00003C60                 jnz     short loc_3C6A
.text$mn:00003C62                 mov     eax, [ebp+Dst]
.text$mn:00003C65                 mov     [ebp+var_4], eax
.text$mn:00003C68                 jmp     short loc_3C81
.text$mn:00003C6A ; ---------------------------------------------------------------------------
.text$mn:00003C6A
.text$mn:00003C6A loc_3C6A:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00003C6A                 mov     ecx, [ebp+arg_8]
.text$mn:00003C6D                 push    ecx             ; int
.text$mn:00003C6E                 mov     edx, [ebp+Src]
.text$mn:00003C71                 push    edx             ; Src
.text$mn:00003C72                 mov     eax, [ebp+Dst]
.text$mn:00003C75                 push    eax             ; Dst
.text$mn:00003C76                 call    _wmemmove
.text$mn:00003C7B                 add     esp, 0Ch
.text$mn:00003C7E                 mov     [ebp+var_4], eax
.text$mn:00003C81
.text$mn:00003C81 loc_3C81:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00003C81                 mov     eax, [ebp+var_4]
.text$mn:00003C84                 mov     esp, ebp
.text$mn:00003C86                 pop     ebp
.text$mn:00003C87                 retn
.text$mn:00003C87 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00003C87
.text$mn:00003C87 _text$mn        ends
.text$mn:00003C87
.text$mn:00003C88 ; ===========================================================================
.text$mn:00003C88
.text$mn:00003C88 ; Segment type: Pure code
.text$mn:00003C88 ; Segment permissions: Read/Execute
.text$mn:00003C88 _text$mn        segment para public 'CODE' use32
.text$mn:00003C88                 assume cs:_text$mn
.text$mn:00003C88                 ;org 3C88h
.text$mn:00003C88 ; COMDAT (pick any)
.text$mn:00003C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C88
.text$mn:00003C88 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C88
.text$mn:00003C88 ; Attributes: bp-based frame
.text$mn:00003C88
.text$mn:00003C88 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00003C88                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00003C88 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00003C88                                         ; DATA XREF: .rdata:00004688o
.text$mn:00003C88
.text$mn:00003C88 var_4           = dword ptr -4
.text$mn:00003C88
.text$mn:00003C88                 push    ebp
.text$mn:00003C89                 mov     ebp, esp
.text$mn:00003C8B                 push    ecx
.text$mn:00003C8C                 mov     [ebp+var_4], ecx
.text$mn:00003C8F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00003C94                 mov     esp, ebp
.text$mn:00003C96                 pop     ebp
.text$mn:00003C97                 retn
.text$mn:00003C97 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00003C97
.text$mn:00003C97 _text$mn        ends
.text$mn:00003C97
.text$mn:00003C98 ; ===========================================================================
.text$mn:00003C98
.text$mn:00003C98 ; Segment type: Pure code
.text$mn:00003C98 ; Segment permissions: Read/Execute
.text$mn:00003C98 _text$mn        segment para public 'CODE' use32
.text$mn:00003C98                 assume cs:_text$mn
.text$mn:00003C98                 ;org 3C98h
.text$mn:00003C98 ; COMDAT (pick any)
.text$mn:00003C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C98
.text$mn:00003C98 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C98
.text$mn:00003C98 ; Attributes: bp-based frame
.text$mn:00003C98
.text$mn:00003C98 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00003C98                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00003C98 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00003C98                                         ; DATA XREF: .rdata:000046BCo
.text$mn:00003C98
.text$mn:00003C98 var_4           = dword ptr -4
.text$mn:00003C98
.text$mn:00003C98                 push    ebp
.text$mn:00003C99                 mov     ebp, esp
.text$mn:00003C9B                 push    ecx
.text$mn:00003C9C                 mov     [ebp+var_4], ecx
.text$mn:00003C9F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00003CA4                 mov     esp, ebp
.text$mn:00003CA6                 pop     ebp
.text$mn:00003CA7                 retn
.text$mn:00003CA7 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00003CA7
.text$mn:00003CA7 _text$mn        ends
.text$mn:00003CA7
.text$mn:00003CA8 ; ===========================================================================
.text$mn:00003CA8
.text$mn:00003CA8 ; Segment type: Pure code
.text$mn:00003CA8 ; Segment permissions: Read/Execute
.text$mn:00003CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA8                 assume cs:_text$mn
.text$mn:00003CA8                 ;org 3CA8h
.text$mn:00003CA8 ; COMDAT (pick any)
.text$mn:00003CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CA8
.text$mn:00003CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA8
.text$mn:00003CA8 ; Attributes: bp-based frame
.text$mn:00003CA8
.text$mn:00003CA8 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00003CA8                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00003CA8 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00003CA8                                         ; DATA XREF: .rdata:000046FCo
.text$mn:00003CA8
.text$mn:00003CA8 var_4           = dword ptr -4
.text$mn:00003CA8
.text$mn:00003CA8                 push    ebp
.text$mn:00003CA9                 mov     ebp, esp
.text$mn:00003CAB                 push    ecx
.text$mn:00003CAC                 mov     [ebp+var_4], ecx
.text$mn:00003CAF                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00003CB4                 mov     esp, ebp
.text$mn:00003CB6                 pop     ebp
.text$mn:00003CB7                 retn
.text$mn:00003CB7 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00003CB7
.text$mn:00003CB7 _text$mn        ends
.text$mn:00003CB7
.text$mn:00003CB8 ; ===========================================================================
.text$mn:00003CB8
.text$mn:00003CB8 ; Segment type: Pure code
.text$mn:00003CB8 ; Segment permissions: Read/Execute
.text$mn:00003CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CB8                 assume cs:_text$mn
.text$mn:00003CB8                 ;org 3CB8h
.text$mn:00003CB8 ; COMDAT (pick any)
.text$mn:00003CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CB8
.text$mn:00003CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CB8
.text$mn:00003CB8 ; Attributes: bp-based frame
.text$mn:00003CB8
.text$mn:00003CB8 ; public: void __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::push_back(struct HMENU__ * const &)
.text$mn:00003CB8                 public ?push_back@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXABQAUHMENU__@@@Z
.text$mn:00003CB8 ?push_back@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXABQAUHMENU__@@@Z proc near
.text$mn:00003CB8                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+118p
.text$mn:00003CB8
.text$mn:00003CB8 var_C           = dword ptr -0Ch
.text$mn:00003CB8 var_8           = dword ptr -8
.text$mn:00003CB8 var_2           = byte ptr -2
.text$mn:00003CB8 var_1           = byte ptr -1
.text$mn:00003CB8 arg_0           = dword ptr  8
.text$mn:00003CB8
.text$mn:00003CB8                 push    ebp
.text$mn:00003CB9                 mov     ebp, esp
.text$mn:00003CBB                 sub     esp, 0Ch
.text$mn:00003CBE                 mov     [ebp+var_8], ecx
.text$mn:00003CC1                 mov     eax, [ebp+arg_0]
.text$mn:00003CC4                 push    eax
.text$mn:00003CC5                 call    ??$addressof@QAUHMENU__@@@std@@YAPBQAUHMENU__@@ABQAU1@@Z ; std::addressof<HMENU__ * const>(HMENU__ * const &)
.text$mn:00003CCA                 add     esp, 4
.text$mn:00003CCD                 push    eax
.text$mn:00003CCE                 mov     ecx, [ebp+var_8]
.text$mn:00003CD1                 call    ?_Inside@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBE_NPBQAUHMENU__@@@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Inside(HMENU__ * const *)
.text$mn:00003CD6                 movzx   ecx, al
.text$mn:00003CD9                 test    ecx, ecx
.text$mn:00003CDB                 jz      short loc_3D5B
.text$mn:00003CDD                 mov     edx, [ebp+arg_0]
.text$mn:00003CE0                 push    edx
.text$mn:00003CE1                 call    ??$addressof@QAUHMENU__@@@std@@YAPBQAUHMENU__@@ABQAU1@@Z ; std::addressof<HMENU__ * const>(HMENU__ * const &)
.text$mn:00003CE6                 add     esp, 4
.text$mn:00003CE9                 mov     ecx, [ebp+var_8]
.text$mn:00003CEC                 sub     eax, [ecx+4]
.text$mn:00003CEF                 sar     eax, 2
.text$mn:00003CF2                 mov     [ebp+var_C], eax
.text$mn:00003CF5                 mov     edx, [ebp+var_8]
.text$mn:00003CF8                 mov     eax, [ebp+var_8]
.text$mn:00003CFB                 mov     ecx, [edx+8]
.text$mn:00003CFE                 cmp     ecx, [eax+0Ch]
.text$mn:00003D01                 jnz     short loc_3D0D
.text$mn:00003D03                 push    1
.text$mn:00003D05                 mov     ecx, [ebp+var_8]
.text$mn:00003D08                 call    ?_Reserve@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)
.text$mn:00003D0D
.text$mn:00003D0D loc_3D0D:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+49j
.text$mn:00003D0D                 mov     edx, [ebp+var_8]
.text$mn:00003D10                 mov     eax, [edx+8]
.text$mn:00003D13                 push    eax
.text$mn:00003D14                 mov     ecx, [ebp+var_8]
.text$mn:00003D17                 mov     edx, [ecx+8]
.text$mn:00003D1A                 push    edx
.text$mn:00003D1B                 mov     ecx, [ebp+var_8]
.text$mn:00003D1E                 call    ?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)
.text$mn:00003D23                 mov     eax, [ebp+var_8]
.text$mn:00003D26                 mov     ecx, [eax+4]
.text$mn:00003D29                 mov     edx, [ebp+var_C]
.text$mn:00003D2C                 lea     eax, [ecx+edx*4]
.text$mn:00003D2F                 push    eax             ; int
.text$mn:00003D30                 mov     ecx, [ebp+var_8]
.text$mn:00003D33                 mov     edx, [ecx+8]
.text$mn:00003D36                 push    edx             ; void *
.text$mn:00003D37                 lea     eax, [ebp+var_1]
.text$mn:00003D3A                 push    eax
.text$mn:00003D3B                 mov     ecx, [ebp+var_8]
.text$mn:00003D3E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:00003D43                 mov     ecx, eax
.text$mn:00003D45                 call    ??$construct@PAUHMENU__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * &>(HMENU__ * *,HMENU__ * &)
.text$mn:00003D4A                 mov     ecx, [ebp+var_8]
.text$mn:00003D4D                 mov     edx, [ecx+8]
.text$mn:00003D50                 add     edx, 4
.text$mn:00003D53                 mov     eax, [ebp+var_8]
.text$mn:00003D56                 mov     [eax+8], edx
.text$mn:00003D59                 jmp     short loc_3DB6
.text$mn:00003D5B ; ---------------------------------------------------------------------------
.text$mn:00003D5B
.text$mn:00003D5B loc_3D5B:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+23j
.text$mn:00003D5B                 mov     ecx, [ebp+var_8]
.text$mn:00003D5E                 mov     edx, [ebp+var_8]
.text$mn:00003D61                 mov     eax, [ecx+8]
.text$mn:00003D64                 cmp     eax, [edx+0Ch]
.text$mn:00003D67                 jnz     short loc_3D73
.text$mn:00003D69                 push    1
.text$mn:00003D6B                 mov     ecx, [ebp+var_8]
.text$mn:00003D6E                 call    ?_Reserve@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Reserve(uint)
.text$mn:00003D73
.text$mn:00003D73 loc_3D73:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+AFj
.text$mn:00003D73                 mov     ecx, [ebp+var_8]
.text$mn:00003D76                 mov     edx, [ecx+8]
.text$mn:00003D79                 push    edx
.text$mn:00003D7A                 mov     eax, [ebp+var_8]
.text$mn:00003D7D                 mov     ecx, [eax+8]
.text$mn:00003D80                 push    ecx
.text$mn:00003D81                 mov     ecx, [ebp+var_8]
.text$mn:00003D84                 call    ?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)
.text$mn:00003D89                 mov     edx, [ebp+arg_0]
.text$mn:00003D8C                 push    edx             ; int
.text$mn:00003D8D                 mov     eax, [ebp+var_8]
.text$mn:00003D90                 mov     ecx, [eax+8]
.text$mn:00003D93                 push    ecx             ; void *
.text$mn:00003D94                 lea     edx, [ebp+var_2]
.text$mn:00003D97                 push    edx
.text$mn:00003D98                 mov     ecx, [ebp+var_8]
.text$mn:00003D9B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HMENU__ *,std::allocator<HMENU__ *>>>::_Getal(void)
.text$mn:00003DA0                 mov     ecx, eax
.text$mn:00003DA2                 call    ??$construct@PAUHMENU__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXPAPAUHMENU__@@ABQAU2@@Z ; std::_Wrap_alloc<std::allocator<HMENU__ *>>::construct<HMENU__ *,HMENU__ * const &>(HMENU__ * *,HMENU__ * const &)
.text$mn:00003DA7                 mov     eax, [ebp+var_8]
.text$mn:00003DAA                 mov     ecx, [eax+8]
.text$mn:00003DAD                 add     ecx, 4
.text$mn:00003DB0                 mov     edx, [ebp+var_8]
.text$mn:00003DB3                 mov     [edx+8], ecx
.text$mn:00003DB6
.text$mn:00003DB6 loc_3DB6:                               ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::push_back(HMENU__ * const &)+A1j
.text$mn:00003DB6                 mov     esp, ebp
.text$mn:00003DB8                 pop     ebp
.text$mn:00003DB9                 retn    4
.text$mn:00003DB9 ?push_back@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAEXABQAUHMENU__@@@Z endp
.text$mn:00003DB9
.text$mn:00003DB9 _text$mn        ends
.text$mn:00003DB9
.text$mn:00003DBC ; ===========================================================================
.text$mn:00003DBC
.text$mn:00003DBC ; Segment type: Pure code
.text$mn:00003DBC ; Segment permissions: Read/Execute
.text$mn:00003DBC _text$mn        segment para public 'CODE' use32
.text$mn:00003DBC                 assume cs:_text$mn
.text$mn:00003DBC                 ;org 3DBCh
.text$mn:00003DBC ; COMDAT (pick any)
.text$mn:00003DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DBC
.text$mn:00003DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DBC
.text$mn:00003DBC ; Attributes: bp-based frame
.text$mn:00003DBC
.text$mn:00003DBC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00003DBC                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00003DBC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00003DBC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00003DBC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00003DBC
.text$mn:00003DBC var_4           = dword ptr -4
.text$mn:00003DBC
.text$mn:00003DBC                 push    ebp
.text$mn:00003DBD                 mov     ebp, esp
.text$mn:00003DBF                 push    ecx
.text$mn:00003DC0                 mov     [ebp+var_4], ecx
.text$mn:00003DC3                 mov     eax, [ebp+var_4]
.text$mn:00003DC6                 mov     eax, [eax+14h]
.text$mn:00003DC9                 mov     esp, ebp
.text$mn:00003DCB                 pop     ebp
.text$mn:00003DCC                 retn
.text$mn:00003DCC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003DCC
.text$mn:00003DCC ; ---------------------------------------------------------------------------
.text$mn:00003DCD                 align 10h
.text$mn:00003DCD _text$mn        ends
.text$mn:00003DCD
.text$mn:00003DD0 ; ===========================================================================
.text$mn:00003DD0
.text$mn:00003DD0 ; Segment type: Pure code
.text$mn:00003DD0 ; Segment permissions: Read/Execute
.text$mn:00003DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DD0                 assume cs:_text$mn
.text$mn:00003DD0                 ;org 3DD0h
.text$mn:00003DD0 ; COMDAT (pick any)
.text$mn:00003DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DD0
.text$mn:00003DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DD0
.text$mn:00003DD0 ; Attributes: bp-based frame
.text$mn:00003DD0
.text$mn:00003DD0 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00003DD0                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00003DD0 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00003DD0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00003DD0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:00003DD0
.text$mn:00003DD0 var_4           = dword ptr -4
.text$mn:00003DD0
.text$mn:00003DD0                 push    ebp
.text$mn:00003DD1                 mov     ebp, esp
.text$mn:00003DD3                 push    ecx
.text$mn:00003DD4                 mov     [ebp+var_4], ecx
.text$mn:00003DD7                 mov     eax, [ebp+var_4]
.text$mn:00003DDA                 mov     eax, [eax+14h]
.text$mn:00003DDD                 mov     esp, ebp
.text$mn:00003DDF                 pop     ebp
.text$mn:00003DE0                 retn
.text$mn:00003DE0 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00003DE0
.text$mn:00003DE0 ; ---------------------------------------------------------------------------
.text$mn:00003DE1                 align 4
.text$mn:00003DE1 _text$mn        ends
.text$mn:00003DE1
.text$mn:00003DE4 ; ===========================================================================
.text$mn:00003DE4
.text$mn:00003DE4 ; Segment type: Pure code
.text$mn:00003DE4 ; Segment permissions: Read/Execute
.text$mn:00003DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DE4                 assume cs:_text$mn
.text$mn:00003DE4                 ;org 3DE4h
.text$mn:00003DE4 ; COMDAT (pick any)
.text$mn:00003DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DE4
.text$mn:00003DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DE4
.text$mn:00003DE4 ; Attributes: bp-based frame
.text$mn:00003DE4
.text$mn:00003DE4 ; public: unsigned int __thiscall std::vector<struct HMENU__ *, class std::allocator<struct HMENU__ *>>::size(void)const
.text$mn:00003DE4                 public ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ
.text$mn:00003DE4 ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ proc near
.text$mn:00003DE4                                         ; CODE XREF: ContextMenu::~ContextMenu(void)+4Bp
.text$mn:00003DE4                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+Ap ...
.text$mn:00003DE4
.text$mn:00003DE4 var_4           = dword ptr -4
.text$mn:00003DE4
.text$mn:00003DE4                 push    ebp
.text$mn:00003DE5                 mov     ebp, esp
.text$mn:00003DE7                 push    ecx
.text$mn:00003DE8                 mov     [ebp+var_4], ecx
.text$mn:00003DEB                 mov     eax, [ebp+var_4]
.text$mn:00003DEE                 mov     ecx, [ebp+var_4]
.text$mn:00003DF1                 mov     eax, [eax+8]
.text$mn:00003DF4                 sub     eax, [ecx+4]
.text$mn:00003DF7                 sar     eax, 2
.text$mn:00003DFA                 mov     esp, ebp
.text$mn:00003DFC                 pop     ebp
.text$mn:00003DFD                 retn
.text$mn:00003DFD ?size@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QBEIXZ endp
.text$mn:00003DFD
.text$mn:00003DFD ; ---------------------------------------------------------------------------
.text$mn:00003DFE                 align 10h
.text$mn:00003DFE _text$mn        ends
.text$mn:00003DFE
.text$mn:00003E00 ; ===========================================================================
.text$mn:00003E00
.text$mn:00003E00 ; Segment type: Pure code
.text$mn:00003E00 ; Segment permissions: Read/Execute
.text$mn:00003E00 _text$mn        segment para public 'CODE' use32
.text$mn:00003E00                 assume cs:_text$mn
.text$mn:00003E00                 ;org 3E00h
.text$mn:00003E00 ; COMDAT (pick any)
.text$mn:00003E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E00
.text$mn:00003E00 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E00
.text$mn:00003E00 ; Attributes: bp-based frame
.text$mn:00003E00
.text$mn:00003E00 ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::size(void)const
.text$mn:00003E00                 public ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:00003E00 ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:00003E00                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+6Fp
.text$mn:00003E00                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+1AEp ...
.text$mn:00003E00
.text$mn:00003E00 var_4           = dword ptr -4
.text$mn:00003E00
.text$mn:00003E00                 push    ebp
.text$mn:00003E01                 mov     ebp, esp
.text$mn:00003E03                 push    ecx
.text$mn:00003E04                 mov     [ebp+var_4], ecx
.text$mn:00003E07                 mov     eax, [ebp+var_4]
.text$mn:00003E0A                 mov     ecx, [ebp+var_4]
.text$mn:00003E0D                 mov     eax, [eax+8]
.text$mn:00003E10                 sub     eax, [ecx+4]
.text$mn:00003E13                 cdq
.text$mn:00003E14                 mov     ecx, 3Ch ; '<'
.text$mn:00003E19                 idiv    ecx
.text$mn:00003E1B                 mov     esp, ebp
.text$mn:00003E1D                 pop     ebp
.text$mn:00003E1E                 retn
.text$mn:00003E1E ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:00003E1E
.text$mn:00003E1E ; ---------------------------------------------------------------------------
.text$mn:00003E1F                 align 10h
.text$mn:00003E1F _text$mn        ends
.text$mn:00003E1F
.text$mn:00003E20 ; ===========================================================================
.text$mn:00003E20
.text$mn:00003E20 ; Segment type: Pure code
.text$mn:00003E20 ; Segment permissions: Read/Execute
.text$mn:00003E20 _text$mn        segment para public 'CODE' use32
.text$mn:00003E20                 assume cs:_text$mn
.text$mn:00003E20                 ;org 3E20h
.text$mn:00003E20 ; COMDAT (pick any)
.text$mn:00003E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E20
.text$mn:00003E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E20
.text$mn:00003E20 ; Attributes: bp-based frame
.text$mn:00003E20
.text$mn:00003E20 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00003E20                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00003E20 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00003E20                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_35A4p
.text$mn:00003E20                 push    ebp
.text$mn:00003E21                 mov     ebp, esp
.text$mn:00003E23                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00003E28                 pop     ebp
.text$mn:00003E29                 retn
.text$mn:00003E29 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00003E29
.text$mn:00003E29 ; ---------------------------------------------------------------------------
.text$mn:00003E2A                 align 4
.text$mn:00003E2A _text$mn        ends
.text$mn:00003E2A
.text$mn:00003E2C ; ===========================================================================
.text$mn:00003E2C
.text$mn:00003E2C ; Segment type: Pure code
.text$mn:00003E2C ; Segment permissions: Read/Execute
.text$mn:00003E2C _text$mn        segment para public 'CODE' use32
.text$mn:00003E2C                 assume cs:_text$mn
.text$mn:00003E2C                 ;org 3E2Ch
.text$mn:00003E2C ; COMDAT (pick any)
.text$mn:00003E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E2C
.text$mn:00003E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E2C
.text$mn:00003E2C ; Attributes: bp-based frame
.text$mn:00003E2C
.text$mn:00003E2C ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00003E2C                 public ?value@error_code@std@@QBEHXZ
.text$mn:00003E2C ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00003E2C
.text$mn:00003E2C var_4           = dword ptr -4
.text$mn:00003E2C
.text$mn:00003E2C                 push    ebp
.text$mn:00003E2D                 mov     ebp, esp
.text$mn:00003E2F                 push    ecx
.text$mn:00003E30                 mov     [ebp+var_4], ecx
.text$mn:00003E33                 mov     eax, [ebp+var_4]
.text$mn:00003E36                 mov     eax, [eax]
.text$mn:00003E38                 mov     esp, ebp
.text$mn:00003E3A                 pop     ebp
.text$mn:00003E3B                 retn
.text$mn:00003E3B ?value@error_code@std@@QBEHXZ endp
.text$mn:00003E3B
.text$mn:00003E3B _text$mn        ends
.text$mn:00003E3B
.text$mn:00003E3C ; ===========================================================================
.text$mn:00003E3C
.text$mn:00003E3C ; Segment type: Pure code
.text$mn:00003E3C ; Segment permissions: Read/Execute
.text$mn:00003E3C _text$mn        segment para public 'CODE' use32
.text$mn:00003E3C                 assume cs:_text$mn
.text$mn:00003E3C                 ;org 3E3Ch
.text$mn:00003E3C ; COMDAT (pick any)
.text$mn:00003E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E3C
.text$mn:00003E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E3C
.text$mn:00003E3C ; Attributes: bp-based frame
.text$mn:00003E3C
.text$mn:00003E3C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00003E3C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00003E3C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00003E3C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00003E3C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00003E3C
.text$mn:00003E3C var_4           = dword ptr -4
.text$mn:00003E3C
.text$mn:00003E3C                 push    ebp
.text$mn:00003E3D                 mov     ebp, esp
.text$mn:00003E3F                 push    ecx
.text$mn:00003E40                 mov     [ebp+var_4], ecx
.text$mn:00003E43                 mov     eax, [ebp+var_4]
.text$mn:00003E46                 mov     eax, [eax]
.text$mn:00003E48                 mov     esp, ebp
.text$mn:00003E4A                 pop     ebp
.text$mn:00003E4B                 retn
.text$mn:00003E4B ?value@error_condition@std@@QBEHXZ endp
.text$mn:00003E4B
.text$mn:00003E4B _text$mn        ends
.text$mn:00003E4B
.text$mn:00003E4C ; ===========================================================================
.text$mn:00003E4C
.text$mn:00003E4C ; Segment type: Pure code
.text$mn:00003E4C ; Segment permissions: Read/Execute
.text$mn:00003E4C _text$mn        segment para public 'CODE' use32
.text$mn:00003E4C                 assume cs:_text$mn
.text$mn:00003E4C                 ;org 3E4Ch
.text$mn:00003E4C ; COMDAT (pick any)
.text$mn:00003E4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E4C
.text$mn:00003E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E4C
.text$mn:00003E4C ; Attributes: bp-based frame
.text$mn:00003E4C
.text$mn:00003E4C                 public _hypot
.text$mn:00003E4C _hypot          proc near
.text$mn:00003E4C
.text$mn:00003E4C var_10          = qword ptr -10h
.text$mn:00003E4C var_8           = qword ptr -8
.text$mn:00003E4C arg_0           = qword ptr  8
.text$mn:00003E4C arg_8           = qword ptr  10h
.text$mn:00003E4C
.text$mn:00003E4C                 push    ebp
.text$mn:00003E4D                 mov     ebp, esp
.text$mn:00003E4F                 sub     esp, 8
.text$mn:00003E52                 movsd   xmm0, [ebp+arg_8]
.text$mn:00003E57                 movsd   [esp+8+var_8], xmm0
.text$mn:00003E5C                 sub     esp, 8
.text$mn:00003E5F                 movsd   xmm0, [ebp+arg_0]
.text$mn:00003E64                 movsd   [esp+10h+var_10], xmm0
.text$mn:00003E69                 call    __hypot
.text$mn:00003E6E                 add     esp, 10h
.text$mn:00003E71                 pop     ebp
.text$mn:00003E72                 retn
.text$mn:00003E72 _hypot          endp
.text$mn:00003E72
.text$mn:00003E72 ; ---------------------------------------------------------------------------
.text$mn:00003E73                 align 4
.text$mn:00003E73 _text$mn        ends
.text$mn:00003E73
.text$mn:00003E74 ; ===========================================================================
.text$mn:00003E74
.text$mn:00003E74 ; Segment type: Pure code
.text$mn:00003E74 ; Segment permissions: Read/Execute
.text$mn:00003E74 _text$mn        segment para public 'CODE' use32
.text$mn:00003E74                 assume cs:_text$mn
.text$mn:00003E74                 ;org 3E74h
.text$mn:00003E74 ; COMDAT (pick any)
.text$mn:00003E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E74
.text$mn:00003E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E74
.text$mn:00003E74 ; Attributes: bp-based frame
.text$mn:00003E74
.text$mn:00003E74                 public _wmemcmp
.text$mn:00003E74 _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:00003E74
.text$mn:00003E74 var_4           = dword ptr -4
.text$mn:00003E74 arg_0           = dword ptr  8
.text$mn:00003E74 arg_4           = dword ptr  0Ch
.text$mn:00003E74 arg_8           = dword ptr  10h
.text$mn:00003E74
.text$mn:00003E74                 push    ebp
.text$mn:00003E75                 mov     ebp, esp
.text$mn:00003E77                 push    ecx
.text$mn:00003E78                 jmp     short loc_3E95
.text$mn:00003E7A ; ---------------------------------------------------------------------------
.text$mn:00003E7A
.text$mn:00003E7A loc_3E7A:                               ; CODE XREF: _wmemcmp:loc_3ED0j
.text$mn:00003E7A                 mov     eax, [ebp+arg_0]
.text$mn:00003E7D                 add     eax, 2
.text$mn:00003E80                 mov     [ebp+arg_0], eax
.text$mn:00003E83                 mov     ecx, [ebp+arg_4]
.text$mn:00003E86                 add     ecx, 2
.text$mn:00003E89                 mov     [ebp+arg_4], ecx
.text$mn:00003E8C                 mov     edx, [ebp+arg_8]
.text$mn:00003E8F                 sub     edx, 1
.text$mn:00003E92                 mov     [ebp+arg_8], edx
.text$mn:00003E95
.text$mn:00003E95 loc_3E95:                               ; CODE XREF: _wmemcmp+4j
.text$mn:00003E95                 cmp     [ebp+arg_8], 0
.text$mn:00003E99                 jbe     short loc_3ED2
.text$mn:00003E9B                 mov     eax, [ebp+arg_0]
.text$mn:00003E9E                 movzx   ecx, word ptr [eax]
.text$mn:00003EA1                 mov     edx, [ebp+arg_4]
.text$mn:00003EA4                 movzx   eax, word ptr [edx]
.text$mn:00003EA7                 cmp     ecx, eax
.text$mn:00003EA9                 jz      short loc_3ED0
.text$mn:00003EAB                 mov     ecx, [ebp+arg_0]
.text$mn:00003EAE                 movzx   edx, word ptr [ecx]
.text$mn:00003EB1                 mov     eax, [ebp+arg_4]
.text$mn:00003EB4                 movzx   ecx, word ptr [eax]
.text$mn:00003EB7                 cmp     edx, ecx
.text$mn:00003EB9                 jge     short loc_3EC4
.text$mn:00003EBB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003EC2                 jmp     short loc_3ECB
.text$mn:00003EC4 ; ---------------------------------------------------------------------------
.text$mn:00003EC4
.text$mn:00003EC4 loc_3EC4:                               ; CODE XREF: _wmemcmp+45j
.text$mn:00003EC4                 mov     [ebp+var_4], 1
.text$mn:00003ECB
.text$mn:00003ECB loc_3ECB:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:00003ECB                 mov     eax, [ebp+var_4]
.text$mn:00003ECE                 jmp     short loc_3ED4
.text$mn:00003ED0 ; ---------------------------------------------------------------------------
.text$mn:00003ED0
.text$mn:00003ED0 loc_3ED0:                               ; CODE XREF: _wmemcmp+35j
.text$mn:00003ED0                 jmp     short loc_3E7A
.text$mn:00003ED2 ; ---------------------------------------------------------------------------
.text$mn:00003ED2
.text$mn:00003ED2 loc_3ED2:                               ; CODE XREF: _wmemcmp+25j
.text$mn:00003ED2                 xor     eax, eax
.text$mn:00003ED4
.text$mn:00003ED4 loc_3ED4:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:00003ED4                 mov     esp, ebp
.text$mn:00003ED6                 pop     ebp
.text$mn:00003ED7                 retn
.text$mn:00003ED7 _wmemcmp        endp
.text$mn:00003ED7
.text$mn:00003ED7 _text$mn        ends
.text$mn:00003ED7
.text$mn:00003ED8 ; ===========================================================================
.text$mn:00003ED8
.text$mn:00003ED8 ; Segment type: Pure code
.text$mn:00003ED8 ; Segment permissions: Read/Execute
.text$mn:00003ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00003ED8                 assume cs:_text$mn
.text$mn:00003ED8                 ;org 3ED8h
.text$mn:00003ED8 ; COMDAT (pick any)
.text$mn:00003ED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003ED8
.text$mn:00003ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003ED8
.text$mn:00003ED8 ; Attributes: bp-based frame
.text$mn:00003ED8
.text$mn:00003ED8 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00003ED8                 public _wmemcpy
.text$mn:00003ED8 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00003ED8
.text$mn:00003ED8 Dst             = dword ptr  8
.text$mn:00003ED8 Src             = dword ptr  0Ch
.text$mn:00003ED8 arg_8           = dword ptr  10h
.text$mn:00003ED8
.text$mn:00003ED8                 push    ebp
.text$mn:00003ED9                 mov     ebp, esp
.text$mn:00003EDB                 mov     eax, [ebp+arg_8]
.text$mn:00003EDE                 shl     eax, 1
.text$mn:00003EE0                 push    eax             ; Size
.text$mn:00003EE1                 mov     ecx, [ebp+Src]
.text$mn:00003EE4                 push    ecx             ; Src
.text$mn:00003EE5                 mov     edx, [ebp+Dst]
.text$mn:00003EE8                 push    edx             ; Dst
.text$mn:00003EE9                 call    _memcpy
.text$mn:00003EEE                 add     esp, 0Ch
.text$mn:00003EF1                 pop     ebp
.text$mn:00003EF2                 retn
.text$mn:00003EF2 _wmemcpy        endp
.text$mn:00003EF2
.text$mn:00003EF2 ; ---------------------------------------------------------------------------
.text$mn:00003EF3                 align 4
.text$mn:00003EF3 _text$mn        ends
.text$mn:00003EF3
.text$mn:00003EF4 ; ===========================================================================
.text$mn:00003EF4
.text$mn:00003EF4 ; Segment type: Pure code
.text$mn:00003EF4 ; Segment permissions: Read/Execute
.text$mn:00003EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00003EF4                 assume cs:_text$mn
.text$mn:00003EF4                 ;org 3EF4h
.text$mn:00003EF4 ; COMDAT (pick any)
.text$mn:00003EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EF4
.text$mn:00003EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EF4
.text$mn:00003EF4 ; Attributes: bp-based frame
.text$mn:00003EF4
.text$mn:00003EF4 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00003EF4                 public _wmemmove
.text$mn:00003EF4 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00003EF4
.text$mn:00003EF4 Dst             = dword ptr  8
.text$mn:00003EF4 Src             = dword ptr  0Ch
.text$mn:00003EF4 arg_8           = dword ptr  10h
.text$mn:00003EF4
.text$mn:00003EF4                 push    ebp
.text$mn:00003EF5                 mov     ebp, esp
.text$mn:00003EF7                 mov     eax, [ebp+arg_8]
.text$mn:00003EFA                 shl     eax, 1
.text$mn:00003EFC                 push    eax             ; Size
.text$mn:00003EFD                 mov     ecx, [ebp+Src]
.text$mn:00003F00                 push    ecx             ; Src
.text$mn:00003F01                 mov     edx, [ebp+Dst]
.text$mn:00003F04                 push    edx             ; Dst
.text$mn:00003F05                 call    _memmove
.text$mn:00003F0A                 add     esp, 0Ch
.text$mn:00003F0D                 pop     ebp
.text$mn:00003F0E                 retn
.text$mn:00003F0E _wmemmove       endp
.text$mn:00003F0E
.text$mn:00003F0E ; ---------------------------------------------------------------------------
.text$mn:00003F0F                 align 10h
.text$mn:00003F0F _text$mn        ends
.text$mn:00003F0F
.xdata$x:00003F10 ; ===========================================================================
.xdata$x:00003F10
.xdata$x:00003F10 ; Segment type: Pure data
.xdata$x:00003F10 ; Segment permissions: Read
.xdata$x:00003F10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003F10                 assume cs:_xdata$x
.xdata$x:00003F10                 ;org 3F10h
.xdata$x:00003F10 ; COMDAT (pick associative to section at 2808)
.xdata$x:00003F10 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00003F10                                         ; DATA XREF: .xdata$x:00003F20o
.xdata$x:00003F11                 db 0FFh
.xdata$x:00003F12                 db 0FFh
.xdata$x:00003F13                 db 0FFh
.xdata$x:00003F14                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00003F18 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00003F18                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00003F19                 db    5
.xdata$x:00003F1A                 db  93h ; ô
.xdata$x:00003F1B                 db  19h
.xdata$x:00003F1C                 db    1
.xdata$x:00003F1D                 db    0
.xdata$x:00003F1E                 db    0
.xdata$x:00003F1F                 db    0
.xdata$x:00003F20                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00003F24                 db    0
.xdata$x:00003F25                 db    0
.xdata$x:00003F26                 db    0
.xdata$x:00003F27                 db    0
.xdata$x:00003F28                 db    0
.xdata$x:00003F29                 db    0
.xdata$x:00003F2A                 db    0
.xdata$x:00003F2B                 db    0
.xdata$x:00003F2C                 db    0
.xdata$x:00003F2D                 db    0
.xdata$x:00003F2E                 db    0
.xdata$x:00003F2F                 db    0
.xdata$x:00003F30                 db    0
.xdata$x:00003F31                 db    0
.xdata$x:00003F32                 db    0
.xdata$x:00003F33                 db    0
.xdata$x:00003F34                 db    0
.xdata$x:00003F35                 db    0
.xdata$x:00003F36                 db    0
.xdata$x:00003F37                 db    0
.xdata$x:00003F38                 db    0
.xdata$x:00003F39                 db    0
.xdata$x:00003F3A                 db    0
.xdata$x:00003F3B                 db    0
.xdata$x:00003F3B _xdata$x        ends
.xdata$x:00003F3B
.xdata$x:00003F3C ; ===========================================================================
.xdata$x:00003F3C
.xdata$x:00003F3C ; Segment type: Pure data
.xdata$x:00003F3C ; Segment permissions: Read
.xdata$x:00003F3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003F3C                 assume cs:_xdata$x
.xdata$x:00003F3C                 ;org 3F3Ch
.xdata$x:00003F3C ; COMDAT (pick associative to section at F98)
.xdata$x:00003F3C __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003F3C                                         ; DATA XREF: .xdata$x:00003F4Co
.xdata$x:00003F3D                 db 0FFh
.xdata$x:00003F3E                 db 0FFh
.xdata$x:00003F3F                 db 0FFh
.xdata$x:00003F40                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00003F44 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003F44                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00003F45                 db    5
.xdata$x:00003F46                 db  93h ; ô
.xdata$x:00003F47                 db  19h
.xdata$x:00003F48                 db    1
.xdata$x:00003F49                 db    0
.xdata$x:00003F4A                 db    0
.xdata$x:00003F4B                 db    0
.xdata$x:00003F4C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003F50                 db    0
.xdata$x:00003F51                 db    0
.xdata$x:00003F52                 db    0
.xdata$x:00003F53                 db    0
.xdata$x:00003F54                 db    0
.xdata$x:00003F55                 db    0
.xdata$x:00003F56                 db    0
.xdata$x:00003F57                 db    0
.xdata$x:00003F58                 db    0
.xdata$x:00003F59                 db    0
.xdata$x:00003F5A                 db    0
.xdata$x:00003F5B                 db    0
.xdata$x:00003F5C                 db    0
.xdata$x:00003F5D                 db    0
.xdata$x:00003F5E                 db    0
.xdata$x:00003F5F                 db    0
.xdata$x:00003F60                 db    0
.xdata$x:00003F61                 db    0
.xdata$x:00003F62                 db    0
.xdata$x:00003F63                 db    0
.xdata$x:00003F64                 db    0
.xdata$x:00003F65                 db    0
.xdata$x:00003F66                 db    0
.xdata$x:00003F67                 db    0
.xdata$x:00003F67 _xdata$x        ends
.xdata$x:00003F67
.xdata$x:00003F68 ; ===========================================================================
.xdata$x:00003F68
.xdata$x:00003F68 ; Segment type: Pure data
.xdata$x:00003F68 ; Segment permissions: Read
.xdata$x:00003F68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003F68                 assume cs:_xdata$x
.xdata$x:00003F68                 ;org 3F68h
.xdata$x:00003F68 ; COMDAT (pick associative to section at 1608)
.xdata$x:00003F68 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003F68                                         ; DATA XREF: .xdata$x:00003F78o
.xdata$x:00003F69                 db 0FFh
.xdata$x:00003F6A                 db 0FFh
.xdata$x:00003F6B                 db 0FFh
.xdata$x:00003F6C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00003F70 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003F70                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00003F71                 db    5
.xdata$x:00003F72                 db  93h ; ô
.xdata$x:00003F73                 db  19h
.xdata$x:00003F74                 db    1
.xdata$x:00003F75                 db    0
.xdata$x:00003F76                 db    0
.xdata$x:00003F77                 db    0
.xdata$x:00003F78                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003F7C                 db    0
.xdata$x:00003F7D                 db    0
.xdata$x:00003F7E                 db    0
.xdata$x:00003F7F                 db    0
.xdata$x:00003F80                 db    0
.xdata$x:00003F81                 db    0
.xdata$x:00003F82                 db    0
.xdata$x:00003F83                 db    0
.xdata$x:00003F84                 db    0
.xdata$x:00003F85                 db    0
.xdata$x:00003F86                 db    0
.xdata$x:00003F87                 db    0
.xdata$x:00003F88                 db    0
.xdata$x:00003F89                 db    0
.xdata$x:00003F8A                 db    0
.xdata$x:00003F8B                 db    0
.xdata$x:00003F8C                 db    0
.xdata$x:00003F8D                 db    0
.xdata$x:00003F8E                 db    0
.xdata$x:00003F8F                 db    0
.xdata$x:00003F90                 db    0
.xdata$x:00003F91                 db    0
.xdata$x:00003F92                 db    0
.xdata$x:00003F93                 db    0
.xdata$x:00003F93 _xdata$x        ends
.xdata$x:00003F93
.xdata$x:00003F94 ; ===========================================================================
.xdata$x:00003F94
.xdata$x:00003F94 ; Segment type: Pure data
.xdata$x:00003F94 ; Segment permissions: Read
.xdata$x:00003F94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003F94                 assume cs:_xdata$x
.xdata$x:00003F94                 ;org 3F94h
.xdata$x:00003F94 ; COMDAT (pick associative to section at EA0)
.xdata$x:00003F94 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00003F94                                         ; DATA XREF: .xdata$x:00003FA4o
.xdata$x:00003F95                 db 0FFh
.xdata$x:00003F96                 db 0FFh
.xdata$x:00003F97                 db 0FFh
.xdata$x:00003F98                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00003F9C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00003F9C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00003F9D                 db    5
.xdata$x:00003F9E                 db  93h ; ô
.xdata$x:00003F9F                 db  19h
.xdata$x:00003FA0                 db    1
.xdata$x:00003FA1                 db    0
.xdata$x:00003FA2                 db    0
.xdata$x:00003FA3                 db    0
.xdata$x:00003FA4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00003FA8                 align 20h
.xdata$x:00003FA8 _xdata$x        ends
.xdata$x:00003FA8
.xdata$x:00003FC0 ; ===========================================================================
.xdata$x:00003FC0
.xdata$x:00003FC0 ; Segment type: Pure data
.xdata$x:00003FC0 ; Segment permissions: Read
.xdata$x:00003FC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003FC0                 assume cs:_xdata$x
.xdata$x:00003FC0                 ;org 3FC0h
.xdata$x:00003FC0 ; COMDAT (pick associative to section at 1518)
.xdata$x:00003FC0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003FC0                                         ; DATA XREF: .xdata$x:00003FD0o
.xdata$x:00003FC1                 db 0FFh
.xdata$x:00003FC2                 db 0FFh
.xdata$x:00003FC3                 db 0FFh
.xdata$x:00003FC4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00003FC8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003FC8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00003FC9                 db    5
.xdata$x:00003FCA                 db  93h ; ô
.xdata$x:00003FCB                 db  19h
.xdata$x:00003FCC                 db    1
.xdata$x:00003FCD                 db    0
.xdata$x:00003FCE                 db    0
.xdata$x:00003FCF                 db    0
.xdata$x:00003FD0                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00003FD4                 db    0
.xdata$x:00003FD5                 db    0
.xdata$x:00003FD6                 db    0
.xdata$x:00003FD7                 db    0
.xdata$x:00003FD8                 db    0
.xdata$x:00003FD9                 db    0
.xdata$x:00003FDA                 db    0
.xdata$x:00003FDB                 db    0
.xdata$x:00003FDC                 db    0
.xdata$x:00003FDD                 db    0
.xdata$x:00003FDE                 db    0
.xdata$x:00003FDF                 db    0
.xdata$x:00003FE0                 db    0
.xdata$x:00003FE1                 db    0
.xdata$x:00003FE2                 db    0
.xdata$x:00003FE3                 db    0
.xdata$x:00003FE4                 db    0
.xdata$x:00003FE5                 db    0
.xdata$x:00003FE6                 db    0
.xdata$x:00003FE7                 db    0
.xdata$x:00003FE8                 db    0
.xdata$x:00003FE9                 db    0
.xdata$x:00003FEA                 db    0
.xdata$x:00003FEB                 db    0
.xdata$x:00003FEB _xdata$x        ends
.xdata$x:00003FEB
.xdata$x:00003FEC ; ===========================================================================
.xdata$x:00003FEC
.xdata$x:00003FEC ; Segment type: Pure data
.xdata$x:00003FEC ; Segment permissions: Read
.xdata$x:00003FEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003FEC                 assume cs:_xdata$x
.xdata$x:00003FEC                 ;org 3FECh
.xdata$x:00003FEC ; COMDAT (pick associative to section at 1158)
.xdata$x:00003FEC __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00003FEC                                         ; DATA XREF: .xdata$x:00003FFCo
.xdata$x:00003FED                 db 0FFh
.xdata$x:00003FEE                 db 0FFh
.xdata$x:00003FEF                 db 0FFh
.xdata$x:00003FF0                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00003FF4 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00003FF4                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00003FF5                 db    5
.xdata$x:00003FF6                 db  93h ; ô
.xdata$x:00003FF7                 db  19h
.xdata$x:00003FF8                 db    1
.xdata$x:00003FF9                 db    0
.xdata$x:00003FFA                 db    0
.xdata$x:00003FFB                 db    0
.xdata$x:00003FFC                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00004000                 db    0
.xdata$x:00004001                 db    0
.xdata$x:00004002                 db    0
.xdata$x:00004003                 db    0
.xdata$x:00004004                 db    0
.xdata$x:00004005                 db    0
.xdata$x:00004006                 db    0
.xdata$x:00004007                 db    0
.xdata$x:00004008                 db    0
.xdata$x:00004009                 db    0
.xdata$x:0000400A                 db    0
.xdata$x:0000400B                 db    0
.xdata$x:0000400C                 db    0
.xdata$x:0000400D                 db    0
.xdata$x:0000400E                 db    0
.xdata$x:0000400F                 db    0
.xdata$x:00004010                 db    0
.xdata$x:00004011                 db    0
.xdata$x:00004012                 db    0
.xdata$x:00004013                 db    0
.xdata$x:00004014                 db    0
.xdata$x:00004015                 db    0
.xdata$x:00004016                 db    0
.xdata$x:00004017                 db    0
.xdata$x:00004017 _xdata$x        ends
.xdata$x:00004017
.xdata$x:00004018 ; ===========================================================================
.xdata$x:00004018
.xdata$x:00004018 ; Segment type: Pure data
.xdata$x:00004018 ; Segment permissions: Read
.xdata$x:00004018 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004018                 assume cs:_xdata$x
.xdata$x:00004018                 ;org 4018h
.xdata$x:00004018 ; COMDAT (pick associative to section at 17D0)
.xdata$x:00004018 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00004018                                         ; DATA XREF: .xdata$x:00004028o
.xdata$x:00004019                 db 0FFh
.xdata$x:0000401A                 db 0FFh
.xdata$x:0000401B                 db 0FFh
.xdata$x:0000401C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00004020 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00004020                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00004021                 db    5
.xdata$x:00004022                 db  93h ; ô
.xdata$x:00004023                 db  19h
.xdata$x:00004024                 db    1
.xdata$x:00004025                 db    0
.xdata$x:00004026                 db    0
.xdata$x:00004027                 db    0
.xdata$x:00004028                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000402C                 db    0
.xdata$x:0000402D                 db    0
.xdata$x:0000402E                 db    0
.xdata$x:0000402F                 db    0
.xdata$x:00004030                 db    0
.xdata$x:00004031                 db    0
.xdata$x:00004032                 db    0
.xdata$x:00004033                 db    0
.xdata$x:00004034                 db    0
.xdata$x:00004035                 db    0
.xdata$x:00004036                 db    0
.xdata$x:00004037                 db    0
.xdata$x:00004038                 db    0
.xdata$x:00004039                 db    0
.xdata$x:0000403A                 db    0
.xdata$x:0000403B                 db    0
.xdata$x:0000403C                 db    0
.xdata$x:0000403D                 db    0
.xdata$x:0000403E                 db    0
.xdata$x:0000403F                 db    0
.xdata$x:00004040                 db    0
.xdata$x:00004041                 db    0
.xdata$x:00004042                 db    0
.xdata$x:00004043                 db    0
.xdata$x:00004043 _xdata$x        ends
.xdata$x:00004043
.xdata$x:00004044 ; ===========================================================================
.xdata$x:00004044
.xdata$x:00004044 ; Segment type: Pure data
.xdata$x:00004044 ; Segment permissions: Read
.xdata$x:00004044 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004044                 assume cs:_xdata$x
.xdata$x:00004044                 ;org 4044h
.xdata$x:00004044 ; COMDAT (pick associative to section at 1F54)
.xdata$x:00004044 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00004044                                         ; DATA XREF: .xdata$x:000040CCo
.xdata$x:00004045                 db    0
.xdata$x:00004046                 db    0
.xdata$x:00004047                 db    0
.xdata$x:00004048                 db    0
.xdata$x:00004049                 db    0
.xdata$x:0000404A                 db    0
.xdata$x:0000404B                 db    0
.xdata$x:0000404C                 db    0
.xdata$x:0000404D                 db    0
.xdata$x:0000404E                 db    0
.xdata$x:0000404F                 db    0
.xdata$x:00004050                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00004054 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00004054                                         ; DATA XREF: .xdata$x:000040B8o
.xdata$x:00004055                 db    0
.xdata$x:00004056                 db    0
.xdata$x:00004057                 db    0
.xdata$x:00004058                 db    0
.xdata$x:00004059                 db    0
.xdata$x:0000405A                 db    0
.xdata$x:0000405B                 db    0
.xdata$x:0000405C                 db    0
.xdata$x:0000405D                 db    0
.xdata$x:0000405E                 db    0
.xdata$x:0000405F                 db    0
.xdata$x:00004060                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00004064 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00004064                                         ; DATA XREF: .xdata$x:0000408Co
.xdata$x:00004065                 db 0FFh
.xdata$x:00004066                 db 0FFh
.xdata$x:00004067                 db 0FFh
.xdata$x:00004068                 db    0
.xdata$x:00004069                 db    0
.xdata$x:0000406A                 db    0
.xdata$x:0000406B                 db    0
.xdata$x:0000406C                 db 0FFh
.xdata$x:0000406D                 db 0FFh
.xdata$x:0000406E                 db 0FFh
.xdata$x:0000406F                 db 0FFh
.xdata$x:00004070                 db    0
.xdata$x:00004071                 db    0
.xdata$x:00004072                 db    0
.xdata$x:00004073                 db    0
.xdata$x:00004074                 db    1
.xdata$x:00004075                 db    0
.xdata$x:00004076                 db    0
.xdata$x:00004077                 db    0
.xdata$x:00004078                 db    0
.xdata$x:00004079                 db    0
.xdata$x:0000407A                 db    0
.xdata$x:0000407B                 db    0
.xdata$x:0000407C                 db    1
.xdata$x:0000407D                 db    0
.xdata$x:0000407E                 db    0
.xdata$x:0000407F                 db    0
.xdata$x:00004080                 db    0
.xdata$x:00004081                 db    0
.xdata$x:00004082                 db    0
.xdata$x:00004083                 db    0
.xdata$x:00004084 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00004084                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00004085                 db    5
.xdata$x:00004086                 db  93h ; ô
.xdata$x:00004087                 db  19h
.xdata$x:00004088                 db    4
.xdata$x:00004089                 db    0
.xdata$x:0000408A                 db    0
.xdata$x:0000408B                 db    0
.xdata$x:0000408C                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00004090                 db    2
.xdata$x:00004091                 db    0
.xdata$x:00004092                 db    0
.xdata$x:00004093                 db    0
.xdata$x:00004094                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00004098                 db    0
.xdata$x:00004099                 db    0
.xdata$x:0000409A                 db    0
.xdata$x:0000409B                 db    0
.xdata$x:0000409C                 db    0
.xdata$x:0000409D                 db    0
.xdata$x:0000409E                 db    0
.xdata$x:0000409F                 db    0
.xdata$x:000040A0                 db    0
.xdata$x:000040A1                 db    0
.xdata$x:000040A2                 db    0
.xdata$x:000040A3                 db    0
.xdata$x:000040A4                 db    0
.xdata$x:000040A5                 db    0
.xdata$x:000040A6                 db    0
.xdata$x:000040A7                 db    0
.xdata$x:000040A8 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000040A8                                         ; DATA XREF: .xdata$x:00004094o
.xdata$x:000040A9                 db    0
.xdata$x:000040AA                 db    0
.xdata$x:000040AB                 db    0
.xdata$x:000040AC                 db    2
.xdata$x:000040AD                 db    0
.xdata$x:000040AE                 db    0
.xdata$x:000040AF                 db    0
.xdata$x:000040B0                 db    3
.xdata$x:000040B1                 db    0
.xdata$x:000040B2                 db    0
.xdata$x:000040B3                 db    0
.xdata$x:000040B4                 db    1
.xdata$x:000040B5                 db    0
.xdata$x:000040B6                 db    0
.xdata$x:000040B7                 db    0
.xdata$x:000040B8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000040BC                 db    0
.xdata$x:000040BD                 db    0
.xdata$x:000040BE                 db    0
.xdata$x:000040BF                 db    0
.xdata$x:000040C0                 db    0
.xdata$x:000040C1                 db    0
.xdata$x:000040C2                 db    0
.xdata$x:000040C3                 db    0
.xdata$x:000040C4                 db    3
.xdata$x:000040C5                 db    0
.xdata$x:000040C6                 db    0
.xdata$x:000040C7                 db    0
.xdata$x:000040C8                 db    1
.xdata$x:000040C9                 db    0
.xdata$x:000040CA                 db    0
.xdata$x:000040CB                 db    0
.xdata$x:000040CC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000040CC _xdata$x        ends
.xdata$x:000040CC
.xdata$x:000040D0 ; ===========================================================================
.xdata$x:000040D0
.xdata$x:000040D0 ; Segment type: Pure data
.xdata$x:000040D0 ; Segment permissions: Read
.xdata$x:000040D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000040D0                 assume cs:_xdata$x
.xdata$x:000040D0                 ;org 40D0h
.xdata$x:000040D0 ; COMDAT (pick associative to section at 1350)
.xdata$x:000040D0 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000040D0                                         ; DATA XREF: .xdata$x:000040E0o
.xdata$x:000040D1                 db 0FFh
.xdata$x:000040D2                 db 0FFh
.xdata$x:000040D3                 db 0FFh
.xdata$x:000040D4                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000040D8 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000040D8                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000040D9                 db    5
.xdata$x:000040DA                 db  93h ; ô
.xdata$x:000040DB                 db  19h
.xdata$x:000040DC                 db    1
.xdata$x:000040DD                 db    0
.xdata$x:000040DE                 db    0
.xdata$x:000040DF                 db    0
.xdata$x:000040E0                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000040E4                 db    0
.xdata$x:000040E5                 db    0
.xdata$x:000040E6                 db    0
.xdata$x:000040E7                 db    0
.xdata$x:000040E8                 db    0
.xdata$x:000040E9                 db    0
.xdata$x:000040EA                 db    0
.xdata$x:000040EB                 db    0
.xdata$x:000040EC                 db    0
.xdata$x:000040ED                 db    0
.xdata$x:000040EE                 db    0
.xdata$x:000040EF                 db    0
.xdata$x:000040F0                 db    0
.xdata$x:000040F1                 db    0
.xdata$x:000040F2                 db    0
.xdata$x:000040F3                 db    0
.xdata$x:000040F4                 db    0
.xdata$x:000040F5                 db    0
.xdata$x:000040F6                 db    0
.xdata$x:000040F7                 db    0
.xdata$x:000040F8                 db    0
.xdata$x:000040F9                 db    0
.xdata$x:000040FA                 db    0
.xdata$x:000040FB                 db    0
.xdata$x:000040FB _xdata$x        ends
.xdata$x:000040FB
.xdata$x:000040FC ; ===========================================================================
.xdata$x:000040FC
.xdata$x:000040FC ; Segment type: Pure data
.xdata$x:000040FC ; Segment permissions: Read
.xdata$x:000040FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000040FC                 assume cs:_xdata$x
.xdata$x:000040FC                 ;org 40FCh
.xdata$x:000040FC ; COMDAT (pick associative to section at 39F4)
.xdata$x:000040FC __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000040FC                                         ; DATA XREF: .xdata$x:0000410Co
.xdata$x:000040FD                 db 0FFh
.xdata$x:000040FE                 db 0FFh
.xdata$x:000040FF                 db 0FFh
.xdata$x:00004100                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00004104 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00004104                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00004105                 db    5
.xdata$x:00004106                 db  93h ; ô
.xdata$x:00004107                 db  19h
.xdata$x:00004108                 db    1
.xdata$x:00004109                 db    0
.xdata$x:0000410A                 db    0
.xdata$x:0000410B                 db    0
.xdata$x:0000410C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004110                 db    0
.xdata$x:00004111                 db    0
.xdata$x:00004112                 db    0
.xdata$x:00004113                 db    0
.xdata$x:00004114                 db    0
.xdata$x:00004115                 db    0
.xdata$x:00004116                 db    0
.xdata$x:00004117                 db    0
.xdata$x:00004118                 db    0
.xdata$x:00004119                 db    0
.xdata$x:0000411A                 db    0
.xdata$x:0000411B                 db    0
.xdata$x:0000411C                 db    0
.xdata$x:0000411D                 db    0
.xdata$x:0000411E                 db    0
.xdata$x:0000411F                 db    0
.xdata$x:00004120                 db    0
.xdata$x:00004121                 db    0
.xdata$x:00004122                 db    0
.xdata$x:00004123                 db    0
.xdata$x:00004124                 db    0
.xdata$x:00004125                 db    0
.xdata$x:00004126                 db    0
.xdata$x:00004127                 db    0
.xdata$x:00004127 _xdata$x        ends
.xdata$x:00004127
.xdata$x:00004128 ; ===========================================================================
.xdata$x:00004128
.xdata$x:00004128 ; Segment type: Pure data
.xdata$x:00004128 ; Segment permissions: Read
.xdata$x:00004128 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004128                 assume cs:_xdata$x
.xdata$x:00004128                 ;org 4128h
.xdata$x:00004128 ; COMDAT (pick associative to section at 1954)
.xdata$x:00004128 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00004128                                         ; DATA XREF: .xdata$x:00004138o
.xdata$x:00004129                 db 0FFh
.xdata$x:0000412A                 db 0FFh
.xdata$x:0000412B                 db 0FFh
.xdata$x:0000412C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00004130 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00004130                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00004131                 db    5
.xdata$x:00004132                 db  93h ; ô
.xdata$x:00004133                 db  19h
.xdata$x:00004134                 db    1
.xdata$x:00004135                 db    0
.xdata$x:00004136                 db    0
.xdata$x:00004137                 db    0
.xdata$x:00004138                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000413C                 db    0
.xdata$x:0000413D                 db    0
.xdata$x:0000413E                 db    0
.xdata$x:0000413F                 db    0
.xdata$x:00004140                 db    0
.xdata$x:00004141                 db    0
.xdata$x:00004142                 db    0
.xdata$x:00004143                 db    0
.xdata$x:00004144                 db    0
.xdata$x:00004145                 db    0
.xdata$x:00004146                 db    0
.xdata$x:00004147                 db    0
.xdata$x:00004148                 db    0
.xdata$x:00004149                 db    0
.xdata$x:0000414A                 db    0
.xdata$x:0000414B                 db    0
.xdata$x:0000414C                 db    0
.xdata$x:0000414D                 db    0
.xdata$x:0000414E                 db    0
.xdata$x:0000414F                 db    0
.xdata$x:00004150                 db    0
.xdata$x:00004151                 db    0
.xdata$x:00004152                 db    0
.xdata$x:00004153                 db    0
.xdata$x:00004153 _xdata$x        ends
.xdata$x:00004153
.xdata$x:00004154 ; ===========================================================================
.xdata$x:00004154
.xdata$x:00004154 ; Segment type: Pure data
.xdata$x:00004154 ; Segment permissions: Read
.xdata$x:00004154 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004154                 assume cs:_xdata$x
.xdata$x:00004154                 ;org 4154h
.xdata$x:00004154 ; COMDAT (pick associative to section at 13CC)
.xdata$x:00004154 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00004154                                         ; DATA XREF: .xdata$x:00004164o
.xdata$x:00004155                 db 0FFh
.xdata$x:00004156                 db 0FFh
.xdata$x:00004157                 db 0FFh
.xdata$x:00004158                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000415C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000415C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000415D                 db    5
.xdata$x:0000415E                 db  93h ; ô
.xdata$x:0000415F                 db  19h
.xdata$x:00004160                 db    1
.xdata$x:00004161                 db    0
.xdata$x:00004162                 db    0
.xdata$x:00004163                 db    0
.xdata$x:00004164                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00004168                 align 20h
.xdata$x:00004168 _xdata$x        ends
.xdata$x:00004168
.xdata$x:00004180 ; ===========================================================================
.xdata$x:00004180
.xdata$x:00004180 ; Segment type: Pure data
.xdata$x:00004180 ; Segment permissions: Read
.xdata$x:00004180 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004180                 assume cs:_xdata$x
.xdata$x:00004180                 ;org 4180h
.xdata$x:00004180 ; COMDAT (pick associative to section at 3AAC)
.xdata$x:00004180 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004180                                         ; DATA XREF: .xdata$x:00004190o
.xdata$x:00004181                 db 0FFh
.xdata$x:00004182                 db 0FFh
.xdata$x:00004183                 db 0FFh
.xdata$x:00004184                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00004188 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00004188                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00004189                 db    5
.xdata$x:0000418A                 db  93h ; ô
.xdata$x:0000418B                 db  19h
.xdata$x:0000418C                 db    1
.xdata$x:0000418D                 db    0
.xdata$x:0000418E                 db    0
.xdata$x:0000418F                 db    0
.xdata$x:00004190                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004194                 db    0
.xdata$x:00004195                 db    0
.xdata$x:00004196                 db    0
.xdata$x:00004197                 db    0
.xdata$x:00004198                 db    0
.xdata$x:00004199                 db    0
.xdata$x:0000419A                 db    0
.xdata$x:0000419B                 db    0
.xdata$x:0000419C                 db    0
.xdata$x:0000419D                 db    0
.xdata$x:0000419E                 db    0
.xdata$x:0000419F                 db    0
.xdata$x:000041A0                 db    0
.xdata$x:000041A1                 db    0
.xdata$x:000041A2                 db    0
.xdata$x:000041A3                 db    0
.xdata$x:000041A4                 db    0
.xdata$x:000041A5                 db    0
.xdata$x:000041A6                 db    0
.xdata$x:000041A7                 db    0
.xdata$x:000041A8                 db    0
.xdata$x:000041A9                 db    0
.xdata$x:000041AA                 db    0
.xdata$x:000041AB                 db    0
.xdata$x:000041AB _xdata$x        ends
.xdata$x:000041AB
.xdata$x:000041AC ; ===========================================================================
.xdata$x:000041AC
.xdata$x:000041AC ; Segment type: Pure data
.xdata$x:000041AC ; Segment permissions: Read
.xdata$x:000041AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000041AC                 assume cs:_xdata$x
.xdata$x:000041AC                 ;org 41ACh
.xdata$x:000041AC ; COMDAT (pick associative to section at 19C4)
.xdata$x:000041AC __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000041AC                                         ; DATA XREF: .xdata$x:000041BCo
.xdata$x:000041AD                 db 0FFh
.xdata$x:000041AE                 db 0FFh
.xdata$x:000041AF                 db 0FFh
.xdata$x:000041B0                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000041B4 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000041B4                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000041B5                 db    5
.xdata$x:000041B6                 db  93h ; ô
.xdata$x:000041B7                 db  19h
.xdata$x:000041B8                 db    1
.xdata$x:000041B9                 db    0
.xdata$x:000041BA                 db    0
.xdata$x:000041BB                 db    0
.xdata$x:000041BC                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000041C0                 db    0
.xdata$x:000041C1                 db    0
.xdata$x:000041C2                 db    0
.xdata$x:000041C3                 db    0
.xdata$x:000041C4                 db    0
.xdata$x:000041C5                 db    0
.xdata$x:000041C6                 db    0
.xdata$x:000041C7                 db    0
.xdata$x:000041C8                 db    0
.xdata$x:000041C9                 db    0
.xdata$x:000041CA                 db    0
.xdata$x:000041CB                 db    0
.xdata$x:000041CC                 db    0
.xdata$x:000041CD                 db    0
.xdata$x:000041CE                 db    0
.xdata$x:000041CF                 db    0
.xdata$x:000041D0                 db    0
.xdata$x:000041D1                 db    0
.xdata$x:000041D2                 db    0
.xdata$x:000041D3                 db    0
.xdata$x:000041D4                 db    0
.xdata$x:000041D5                 db    0
.xdata$x:000041D6                 db    0
.xdata$x:000041D7                 db    0
.xdata$x:000041D7 _xdata$x        ends
.xdata$x:000041D7
.xdata$x:000041D8 ; ===========================================================================
.xdata$x:000041D8
.xdata$x:000041D8 ; Segment type: Pure data
.xdata$x:000041D8 ; Segment permissions: Read
.xdata$x:000041D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000041D8                 assume cs:_xdata$x
.xdata$x:000041D8                 ;org 41D8h
.xdata$x:000041D8 ; COMDAT (pick associative to section at 1448)
.xdata$x:000041D8 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000041D8                                         ; DATA XREF: .xdata$x:000041E8o
.xdata$x:000041D9                 db 0FFh
.xdata$x:000041DA                 db 0FFh
.xdata$x:000041DB                 db 0FFh
.xdata$x:000041DC                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000041E0 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000041E0                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000041E1                 db    5
.xdata$x:000041E2                 db  93h ; ô
.xdata$x:000041E3                 db  19h
.xdata$x:000041E4                 db    1
.xdata$x:000041E5                 db    0
.xdata$x:000041E6                 db    0
.xdata$x:000041E7                 db    0
.xdata$x:000041E8                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000041EC                 db    0
.xdata$x:000041ED                 db    0
.xdata$x:000041EE                 db    0
.xdata$x:000041EF                 db    0
.xdata$x:000041F0                 db    0
.xdata$x:000041F1                 db    0
.xdata$x:000041F2                 db    0
.xdata$x:000041F3                 db    0
.xdata$x:000041F4                 db    0
.xdata$x:000041F5                 db    0
.xdata$x:000041F6                 db    0
.xdata$x:000041F7                 db    0
.xdata$x:000041F8                 db    0
.xdata$x:000041F9                 db    0
.xdata$x:000041FA                 db    0
.xdata$x:000041FB                 db    0
.xdata$x:000041FC                 db    0
.xdata$x:000041FD                 db    0
.xdata$x:000041FE                 db    0
.xdata$x:000041FF                 db    0
.xdata$x:00004200                 db    0
.xdata$x:00004201                 db    0
.xdata$x:00004202                 db    0
.xdata$x:00004203                 db    0
.xdata$x:00004203 _xdata$x        ends
.xdata$x:00004203
.xdata$x:00004204 ; ===========================================================================
.xdata$x:00004204
.xdata$x:00004204 ; Segment type: Pure data
.xdata$x:00004204 ; Segment permissions: Read
.xdata$x:00004204 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004204                 assume cs:_xdata$x
.xdata$x:00004204                 ;org 4204h
.xdata$x:00004204 ; COMDAT (pick associative to section at 3B70)
.xdata$x:00004204 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004204                                         ; DATA XREF: .xdata$x:00004214o
.xdata$x:00004205                 db 0FFh
.xdata$x:00004206                 db 0FFh
.xdata$x:00004207                 db 0FFh
.xdata$x:00004208                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000420C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000420C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000420D                 db    5
.xdata$x:0000420E                 db  93h ; ô
.xdata$x:0000420F                 db  19h
.xdata$x:00004210                 db    1
.xdata$x:00004211                 db    0
.xdata$x:00004212                 db    0
.xdata$x:00004213                 db    0
.xdata$x:00004214                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004218                 db    0
.xdata$x:00004219                 db    0
.xdata$x:0000421A                 db    0
.xdata$x:0000421B                 db    0
.xdata$x:0000421C                 db    0
.xdata$x:0000421D                 db    0
.xdata$x:0000421E                 db    0
.xdata$x:0000421F                 db    0
.xdata$x:00004220                 db    0
.xdata$x:00004221                 db    0
.xdata$x:00004222                 db    0
.xdata$x:00004223                 db    0
.xdata$x:00004224                 db    0
.xdata$x:00004225                 db    0
.xdata$x:00004226                 db    0
.xdata$x:00004227                 db    0
.xdata$x:00004228                 db    0
.xdata$x:00004229                 db    0
.xdata$x:0000422A                 db    0
.xdata$x:0000422B                 db    0
.xdata$x:0000422C                 db    0
.xdata$x:0000422D                 db    0
.xdata$x:0000422E                 db    0
.xdata$x:0000422F                 db    0
.xdata$x:0000422F _xdata$x        ends
.xdata$x:0000422F
.xdata$x:00004230 ; ===========================================================================
.xdata$x:00004230
.xdata$x:00004230 ; Segment type: Pure data
.xdata$x:00004230 ; Segment permissions: Read
.xdata$x:00004230 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004230                 assume cs:_xdata$x
.xdata$x:00004230                 ;org 4230h
.xdata$x:00004230 ; COMDAT (pick associative to section at 1A34)
.xdata$x:00004230 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00004230                                         ; DATA XREF: .xdata$x:00004240o
.xdata$x:00004231                 db 0FFh
.xdata$x:00004232                 db 0FFh
.xdata$x:00004233                 db 0FFh
.xdata$x:00004234                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00004238 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00004238                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00004239                 db    5
.xdata$x:0000423A                 db  93h ; ô
.xdata$x:0000423B                 db  19h
.xdata$x:0000423C                 db    1
.xdata$x:0000423D                 db    0
.xdata$x:0000423E                 db    0
.xdata$x:0000423F                 db    0
.xdata$x:00004240                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00004244                 db    0
.xdata$x:00004245                 db    0
.xdata$x:00004246                 db    0
.xdata$x:00004247                 db    0
.xdata$x:00004248                 db    0
.xdata$x:00004249                 db    0
.xdata$x:0000424A                 db    0
.xdata$x:0000424B                 db    0
.xdata$x:0000424C                 db    0
.xdata$x:0000424D                 db    0
.xdata$x:0000424E                 db    0
.xdata$x:0000424F                 db    0
.xdata$x:00004250                 db    0
.xdata$x:00004251                 db    0
.xdata$x:00004252                 db    0
.xdata$x:00004253                 db    0
.xdata$x:00004254                 db    0
.xdata$x:00004255                 db    0
.xdata$x:00004256                 db    0
.xdata$x:00004257                 db    0
.xdata$x:00004258                 db    0
.xdata$x:00004259                 db    0
.xdata$x:0000425A                 db    0
.xdata$x:0000425B                 db    0
.xdata$x:0000425B _xdata$x        ends
.xdata$x:0000425B
.xdata$x:0000425C ; ===========================================================================
.xdata$x:0000425C
.xdata$x:0000425C ; Segment type: Pure data
.xdata$x:0000425C ; Segment permissions: Read
.xdata$x:0000425C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000425C                 assume cs:_xdata$x
.xdata$x:0000425C                 ;org 425Ch
.xdata$x:0000425C ; COMDAT (pick associative to section at 1020)
.xdata$x:0000425C __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000425C                                         ; DATA XREF: .xdata$x:0000426Co
.xdata$x:0000425D                 db 0FFh
.xdata$x:0000425E                 db 0FFh
.xdata$x:0000425F                 db 0FFh
.xdata$x:00004260                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00004264 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004264                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00004265                 db    5
.xdata$x:00004266                 db  93h ; ô
.xdata$x:00004267                 db  19h
.xdata$x:00004268                 db    1
.xdata$x:00004269                 db    0
.xdata$x:0000426A                 db    0
.xdata$x:0000426B                 db    0
.xdata$x:0000426C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00004270                 db    0
.xdata$x:00004271                 db    0
.xdata$x:00004272                 db    0
.xdata$x:00004273                 db    0
.xdata$x:00004274                 db    0
.xdata$x:00004275                 db    0
.xdata$x:00004276                 db    0
.xdata$x:00004277                 db    0
.xdata$x:00004278                 db    0
.xdata$x:00004279                 db    0
.xdata$x:0000427A                 db    0
.xdata$x:0000427B                 db    0
.xdata$x:0000427C                 db    0
.xdata$x:0000427D                 db    0
.xdata$x:0000427E                 db    0
.xdata$x:0000427F                 db    0
.xdata$x:00004280                 db    0
.xdata$x:00004281                 db    0
.xdata$x:00004282                 db    0
.xdata$x:00004283                 db    0
.xdata$x:00004284                 db    0
.xdata$x:00004285                 db    0
.xdata$x:00004286                 db    0
.xdata$x:00004287                 db    0
.xdata$x:00004287 _xdata$x        ends
.xdata$x:00004287
.xdata$x:00004288 ; ===========================================================================
.xdata$x:00004288
.xdata$x:00004288 ; Segment type: Pure data
.xdata$x:00004288 ; Segment permissions: Read
.xdata$x:00004288 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004288                 assume cs:_xdata$x
.xdata$x:00004288                 ;org 4288h
.xdata$x:00004288 ; COMDAT (pick associative to section at 1678)
.xdata$x:00004288 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004288                                         ; DATA XREF: .xdata$x:00004298o
.xdata$x:00004289                 db 0FFh
.xdata$x:0000428A                 db 0FFh
.xdata$x:0000428B                 db 0FFh
.xdata$x:0000428C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00004290 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004290                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00004291                 db    5
.xdata$x:00004292                 db  93h ; ô
.xdata$x:00004293                 db  19h
.xdata$x:00004294                 db    1
.xdata$x:00004295                 db    0
.xdata$x:00004296                 db    0
.xdata$x:00004297                 db    0
.xdata$x:00004298                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000429C                 db    0
.xdata$x:0000429D                 db    0
.xdata$x:0000429E                 db    0
.xdata$x:0000429F                 db    0
.xdata$x:000042A0                 db    0
.xdata$x:000042A1                 db    0
.xdata$x:000042A2                 db    0
.xdata$x:000042A3                 db    0
.xdata$x:000042A4                 db    0
.xdata$x:000042A5                 db    0
.xdata$x:000042A6                 db    0
.xdata$x:000042A7                 db    0
.xdata$x:000042A8                 db    0
.xdata$x:000042A9                 db    0
.xdata$x:000042AA                 db    0
.xdata$x:000042AB                 db    0
.xdata$x:000042AC                 db    0
.xdata$x:000042AD                 db    0
.xdata$x:000042AE                 db    0
.xdata$x:000042AF                 db    0
.xdata$x:000042B0                 db    0
.xdata$x:000042B1                 db    0
.xdata$x:000042B2                 db    0
.xdata$x:000042B3                 db    0
.xdata$x:000042B3 _xdata$x        ends
.xdata$x:000042B3
.xdata$x:000042B4 ; ===========================================================================
.xdata$x:000042B4
.xdata$x:000042B4 ; Segment type: Pure data
.xdata$x:000042B4 ; Segment permissions: Read
.xdata$x:000042B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000042B4                 assume cs:_xdata$x
.xdata$x:000042B4                 ;org 42B4h
.xdata$x:000042B4 ; COMDAT (pick associative to section at F1C)
.xdata$x:000042B4 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:000042B4                                         ; DATA XREF: .xdata$x:000042C4o
.xdata$x:000042B5                 db 0FFh
.xdata$x:000042B6                 db 0FFh
.xdata$x:000042B7                 db 0FFh
.xdata$x:000042B8                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:000042BC __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:000042BC                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:000042BD                 db    5
.xdata$x:000042BE                 db  93h ; ô
.xdata$x:000042BF                 db  19h
.xdata$x:000042C0                 db    1
.xdata$x:000042C1                 db    0
.xdata$x:000042C2                 db    0
.xdata$x:000042C3                 db    0
.xdata$x:000042C4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:000042C8                 align 20h
.xdata$x:000042C8 _xdata$x        ends
.xdata$x:000042C8
.xdata$x:000042E0 ; ===========================================================================
.xdata$x:000042E0
.xdata$x:000042E0 ; Segment type: Pure data
.xdata$x:000042E0 ; Segment permissions: Read
.xdata$x:000042E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000042E0                 assume cs:_xdata$x
.xdata$x:000042E0                 ;org 42E0h
.xdata$x:000042E0 ; COMDAT (pick associative to section at 1590)
.xdata$x:000042E0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000042E0                                         ; DATA XREF: .xdata$x:000042F0o
.xdata$x:000042E1                 db 0FFh
.xdata$x:000042E2                 db 0FFh
.xdata$x:000042E3                 db 0FFh
.xdata$x:000042E4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000042E8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000042E8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000042E9                 db    5
.xdata$x:000042EA                 db  93h ; ô
.xdata$x:000042EB                 db  19h
.xdata$x:000042EC                 db    1
.xdata$x:000042ED                 db    0
.xdata$x:000042EE                 db    0
.xdata$x:000042EF                 db    0
.xdata$x:000042F0                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:000042F4                 db    0
.xdata$x:000042F5                 db    0
.xdata$x:000042F6                 db    0
.xdata$x:000042F7                 db    0
.xdata$x:000042F8                 db    0
.xdata$x:000042F9                 db    0
.xdata$x:000042FA                 db    0
.xdata$x:000042FB                 db    0
.xdata$x:000042FC                 db    0
.xdata$x:000042FD                 db    0
.xdata$x:000042FE                 db    0
.xdata$x:000042FF                 db    0
.xdata$x:00004300                 db    0
.xdata$x:00004301                 db    0
.xdata$x:00004302                 db    0
.xdata$x:00004303                 db    0
.xdata$x:00004304                 db    0
.xdata$x:00004305                 db    0
.xdata$x:00004306                 db    0
.xdata$x:00004307                 db    0
.xdata$x:00004308                 db    0
.xdata$x:00004309                 db    0
.xdata$x:0000430A                 db    0
.xdata$x:0000430B                 db    0
.xdata$x:0000430B _xdata$x        ends
.xdata$x:0000430B
.xdata$x:0000430C ; ===========================================================================
.xdata$x:0000430C
.xdata$x:0000430C ; Segment type: Pure data
.xdata$x:0000430C ; Segment permissions: Read
.xdata$x:0000430C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000430C                 assume cs:_xdata$x
.xdata$x:0000430C                 ;org 430Ch
.xdata$x:0000430C ; COMDAT (pick associative to section at 1288)
.xdata$x:0000430C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000430C                                         ; DATA XREF: .xdata$x:0000431Co
.xdata$x:0000430D                 db 0FFh
.xdata$x:0000430E                 db 0FFh
.xdata$x:0000430F                 db 0FFh
.xdata$x:00004310                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00004314 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00004314                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00004315                 db    5
.xdata$x:00004316                 db  93h ; ô
.xdata$x:00004317                 db  19h
.xdata$x:00004318                 db    1
.xdata$x:00004319                 db    0
.xdata$x:0000431A                 db    0
.xdata$x:0000431B                 db    0
.xdata$x:0000431C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00004320                 db    0
.xdata$x:00004321                 db    0
.xdata$x:00004322                 db    0
.xdata$x:00004323                 db    0
.xdata$x:00004324                 db    0
.xdata$x:00004325                 db    0
.xdata$x:00004326                 db    0
.xdata$x:00004327                 db    0
.xdata$x:00004328                 db    0
.xdata$x:00004329                 db    0
.xdata$x:0000432A                 db    0
.xdata$x:0000432B                 db    0
.xdata$x:0000432C                 db    0
.xdata$x:0000432D                 db    0
.xdata$x:0000432E                 db    0
.xdata$x:0000432F                 db    0
.xdata$x:00004330                 db    0
.xdata$x:00004331                 db    0
.xdata$x:00004332                 db    0
.xdata$x:00004333                 db    0
.xdata$x:00004334                 db    0
.xdata$x:00004335                 db    0
.xdata$x:00004336                 db    0
.xdata$x:00004337                 db    0
.xdata$x:00004337 _xdata$x        ends
.xdata$x:00004337
.xdata$x:00004338 ; ===========================================================================
.xdata$x:00004338
.xdata$x:00004338 ; Segment type: Pure data
.xdata$x:00004338 ; Segment permissions: Read
.xdata$x:00004338 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004338                 assume cs:_xdata$x
.xdata$x:00004338                 ;org 4338h
.xdata$x:00004338 ; COMDAT (pick associative to section at 11F0)
.xdata$x:00004338 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:00004338                                         ; DATA XREF: .xdata$x:00004348o
.xdata$x:00004339                 db 0FFh
.xdata$x:0000433A                 db 0FFh
.xdata$x:0000433B                 db 0FFh
.xdata$x:0000433C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00004340 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00004340                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00004341                 db    5
.xdata$x:00004342                 db  93h ; ô
.xdata$x:00004343                 db  19h
.xdata$x:00004344                 db    1
.xdata$x:00004345                 db    0
.xdata$x:00004346                 db    0
.xdata$x:00004347                 db    0
.xdata$x:00004348                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:0000434C                 db    0
.xdata$x:0000434D                 db    0
.xdata$x:0000434E                 db    0
.xdata$x:0000434F                 db    0
.xdata$x:00004350                 db    0
.xdata$x:00004351                 db    0
.xdata$x:00004352                 db    0
.xdata$x:00004353                 db    0
.xdata$x:00004354                 db    0
.xdata$x:00004355                 db    0
.xdata$x:00004356                 db    0
.xdata$x:00004357                 db    0
.xdata$x:00004358                 db    0
.xdata$x:00004359                 db    0
.xdata$x:0000435A                 db    0
.xdata$x:0000435B                 db    0
.xdata$x:0000435C                 db    0
.xdata$x:0000435D                 db    0
.xdata$x:0000435E                 db    0
.xdata$x:0000435F                 db    0
.xdata$x:00004360                 db    0
.xdata$x:00004361                 db    0
.xdata$x:00004362                 db    0
.xdata$x:00004363                 db    0
.xdata$x:00004363 _xdata$x        ends
.xdata$x:00004363
.xdata$x:00004364 ; ===========================================================================
.xdata$x:00004364
.xdata$x:00004364 ; Segment type: Pure data
.xdata$x:00004364 ; Segment permissions: Read
.xdata$x:00004364 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004364                 assume cs:_xdata$x
.xdata$x:00004364                 ;org 4364h
.xdata$x:00004364 ; COMDAT (pick associative to section at 184C)
.xdata$x:00004364 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00004364                                         ; DATA XREF: .xdata$x:00004374o
.xdata$x:00004365                 db 0FFh
.xdata$x:00004366                 db 0FFh
.xdata$x:00004367                 db 0FFh
.xdata$x:00004368                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000436C __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000436C                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000436D                 db    5
.xdata$x:0000436E                 db  93h ; ô
.xdata$x:0000436F                 db  19h
.xdata$x:00004370                 db    1
.xdata$x:00004371                 db    0
.xdata$x:00004372                 db    0
.xdata$x:00004373                 db    0
.xdata$x:00004374                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00004378                 db    0
.xdata$x:00004379                 db    0
.xdata$x:0000437A                 db    0
.xdata$x:0000437B                 db    0
.xdata$x:0000437C                 db    0
.xdata$x:0000437D                 db    0
.xdata$x:0000437E                 db    0
.xdata$x:0000437F                 db    0
.xdata$x:00004380                 db    0
.xdata$x:00004381                 db    0
.xdata$x:00004382                 db    0
.xdata$x:00004383                 db    0
.xdata$x:00004384                 db    0
.xdata$x:00004385                 db    0
.xdata$x:00004386                 db    0
.xdata$x:00004387                 db    0
.xdata$x:00004388                 db    0
.xdata$x:00004389                 db    0
.xdata$x:0000438A                 db    0
.xdata$x:0000438B                 db    0
.xdata$x:0000438C                 db    0
.xdata$x:0000438D                 db    0
.xdata$x:0000438E                 db    0
.xdata$x:0000438F                 db    0
.xdata$x:0000438F _xdata$x        ends
.xdata$x:0000438F
.xdata$x:00004390 ; ===========================================================================
.xdata$x:00004390
.xdata$x:00004390 ; Segment type: Pure data
.xdata$x:00004390 ; Segment permissions: Read
.xdata$x:00004390 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004390                 assume cs:_xdata$x
.xdata$x:00004390                 ;org 4390h
.xdata$x:00004390 ; COMDAT (pick associative to section at 2114)
.xdata$x:00004390 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00004390                                         ; DATA XREF: .xdata$x:00004418o
.xdata$x:00004391                 db    0
.xdata$x:00004392                 db    0
.xdata$x:00004393                 db    0
.xdata$x:00004394                 db    0
.xdata$x:00004395                 db    0
.xdata$x:00004396                 db    0
.xdata$x:00004397                 db    0
.xdata$x:00004398                 db    0
.xdata$x:00004399                 db    0
.xdata$x:0000439A                 db    0
.xdata$x:0000439B                 db    0
.xdata$x:0000439C                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:000043A0 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000043A0                                         ; DATA XREF: .xdata$x:00004404o
.xdata$x:000043A1                 db    0
.xdata$x:000043A2                 db    0
.xdata$x:000043A3                 db    0
.xdata$x:000043A4                 db    0
.xdata$x:000043A5                 db    0
.xdata$x:000043A6                 db    0
.xdata$x:000043A7                 db    0
.xdata$x:000043A8                 db    0
.xdata$x:000043A9                 db    0
.xdata$x:000043AA                 db    0
.xdata$x:000043AB                 db    0
.xdata$x:000043AC                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:000043B0 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000043B0                                         ; DATA XREF: .xdata$x:000043D8o
.xdata$x:000043B1                 db 0FFh
.xdata$x:000043B2                 db 0FFh
.xdata$x:000043B3                 db 0FFh
.xdata$x:000043B4                 db    0
.xdata$x:000043B5                 db    0
.xdata$x:000043B6                 db    0
.xdata$x:000043B7                 db    0
.xdata$x:000043B8                 db 0FFh
.xdata$x:000043B9                 db 0FFh
.xdata$x:000043BA                 db 0FFh
.xdata$x:000043BB                 db 0FFh
.xdata$x:000043BC                 db    0
.xdata$x:000043BD                 db    0
.xdata$x:000043BE                 db    0
.xdata$x:000043BF                 db    0
.xdata$x:000043C0                 db    1
.xdata$x:000043C1                 db    0
.xdata$x:000043C2                 db    0
.xdata$x:000043C3                 db    0
.xdata$x:000043C4                 db    0
.xdata$x:000043C5                 db    0
.xdata$x:000043C6                 db    0
.xdata$x:000043C7                 db    0
.xdata$x:000043C8                 db    1
.xdata$x:000043C9                 db    0
.xdata$x:000043CA                 db    0
.xdata$x:000043CB                 db    0
.xdata$x:000043CC                 db    0
.xdata$x:000043CD                 db    0
.xdata$x:000043CE                 db    0
.xdata$x:000043CF                 db    0
.xdata$x:000043D0 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000043D0                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:000043D1                 db    5
.xdata$x:000043D2                 db  93h ; ô
.xdata$x:000043D3                 db  19h
.xdata$x:000043D4                 db    4
.xdata$x:000043D5                 db    0
.xdata$x:000043D6                 db    0
.xdata$x:000043D7                 db    0
.xdata$x:000043D8                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:000043DC                 db    2
.xdata$x:000043DD                 db    0
.xdata$x:000043DE                 db    0
.xdata$x:000043DF                 db    0
.xdata$x:000043E0                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:000043E4                 db    0
.xdata$x:000043E5                 db    0
.xdata$x:000043E6                 db    0
.xdata$x:000043E7                 db    0
.xdata$x:000043E8                 db    0
.xdata$x:000043E9                 db    0
.xdata$x:000043EA                 db    0
.xdata$x:000043EB                 db    0
.xdata$x:000043EC                 db    0
.xdata$x:000043ED                 db    0
.xdata$x:000043EE                 db    0
.xdata$x:000043EF                 db    0
.xdata$x:000043F0                 db    0
.xdata$x:000043F1                 db    0
.xdata$x:000043F2                 db    0
.xdata$x:000043F3                 db    0
.xdata$x:000043F4 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:000043F4                                         ; DATA XREF: .xdata$x:000043E0o
.xdata$x:000043F5                 db    0
.xdata$x:000043F6                 db    0
.xdata$x:000043F7                 db    0
.xdata$x:000043F8                 db    2
.xdata$x:000043F9                 db    0
.xdata$x:000043FA                 db    0
.xdata$x:000043FB                 db    0
.xdata$x:000043FC                 db    3
.xdata$x:000043FD                 db    0
.xdata$x:000043FE                 db    0
.xdata$x:000043FF                 db    0
.xdata$x:00004400                 db    1
.xdata$x:00004401                 db    0
.xdata$x:00004402                 db    0
.xdata$x:00004403                 db    0
.xdata$x:00004404                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00004408                 align 10h
.xdata$x:00004410                 db    3
.xdata$x:00004411                 db    0
.xdata$x:00004412                 db    0
.xdata$x:00004413                 db    0
.xdata$x:00004414                 db    1
.xdata$x:00004415                 db    0
.xdata$x:00004416                 db    0
.xdata$x:00004417                 db    0
.xdata$x:00004418                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00004418 _xdata$x        ends
.xdata$x:00004418
.xdata$x:0000441C ; ===========================================================================
.xdata$x:0000441C
.xdata$x:0000441C ; Segment type: Pure data
.xdata$x:0000441C ; Segment permissions: Read
.xdata$x:0000441C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000441C                 assume cs:_xdata$x
.xdata$x:0000441C                 ;org 441Ch
.xdata$x:0000441C __unwindtable$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z db 0FFh
.xdata$x:0000441C                                         ; DATA XREF: .xdata$x:00004444o
.xdata$x:0000441D                 db 0FFh
.xdata$x:0000441E                 db 0FFh
.xdata$x:0000441F                 db 0FFh
.xdata$x:00004420                 dd offset __unwindfunclet$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z$0
.xdata$x:00004424 __unwindtable$??1ContextMenu@@QAE@XZ db 0FFh
.xdata$x:00004424                                         ; DATA XREF: .xdata$x:00004468o
.xdata$x:00004425                 db 0FFh
.xdata$x:00004426                 db 0FFh
.xdata$x:00004427                 db 0FFh
.xdata$x:00004428                 dd offset __unwindfunclet$??1ContextMenu@@QAE@XZ$0
.xdata$x:0000442C __unwindtable$??0MenuItemUnit@@QAE@KPB_W0@Z db 0FFh
.xdata$x:0000442C                                         ; DATA XREF: .xdata$x:0000448Co
.xdata$x:0000442D                 db 0FFh
.xdata$x:0000442E                 db 0FFh
.xdata$x:0000442F                 db 0FFh
.xdata$x:00004430                 dd offset __unwindfunclet$??0MenuItemUnit@@QAE@KPB_W0@Z$0
.xdata$x:00004434                 align 8
.xdata$x:00004438                 dd offset __unwindfunclet$??0MenuItemUnit@@QAE@KPB_W0@Z$1
.xdata$x:0000443C __ehfuncinfo$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z db  22h ; "
.xdata$x:0000443C                                         ; DATA XREF: __ehhandler$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z+1Bo
.xdata$x:0000443D                 db    5
.xdata$x:0000443E                 db  93h ; ô
.xdata$x:0000443F                 db  19h
.xdata$x:00004440                 db    1
.xdata$x:00004441                 db    0
.xdata$x:00004442                 db    0
.xdata$x:00004443                 db    0
.xdata$x:00004444                 dd offset __unwindtable$?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z
.xdata$x:00004448                 align 20h
.xdata$x:00004460 __ehfuncinfo$??1ContextMenu@@QAE@XZ db  22h ; "
.xdata$x:00004460                                         ; DATA XREF: __ehhandler$??1ContextMenu@@QAE@XZ+11o
.xdata$x:00004461                 db    5
.xdata$x:00004462                 db  93h ; ô
.xdata$x:00004463                 db  19h
.xdata$x:00004464                 db    1
.xdata$x:00004465                 db    0
.xdata$x:00004466                 db    0
.xdata$x:00004467                 db    0
.xdata$x:00004468                 dd offset __unwindtable$??1ContextMenu@@QAE@XZ
.xdata$x:0000446C                 db    0
.xdata$x:0000446D                 db    0
.xdata$x:0000446E                 db    0
.xdata$x:0000446F                 db    0
.xdata$x:00004470                 db    0
.xdata$x:00004471                 db    0
.xdata$x:00004472                 db    0
.xdata$x:00004473                 db    0
.xdata$x:00004474                 db    0
.xdata$x:00004475                 db    0
.xdata$x:00004476                 db    0
.xdata$x:00004477                 db    0
.xdata$x:00004478                 db    0
.xdata$x:00004479                 db    0
.xdata$x:0000447A                 db    0
.xdata$x:0000447B                 db    0
.xdata$x:0000447C                 db    0
.xdata$x:0000447D                 db    0
.xdata$x:0000447E                 db    0
.xdata$x:0000447F                 db    0
.xdata$x:00004480                 db    0
.xdata$x:00004481                 db    0
.xdata$x:00004482                 db    0
.xdata$x:00004483                 db    0
.xdata$x:00004484 __ehfuncinfo$??0MenuItemUnit@@QAE@KPB_W0@Z db  22h ; "
.xdata$x:00004484                                         ; DATA XREF: __ehhandler$??0MenuItemUnit@@QAE@KPB_W0@Z+11o
.xdata$x:00004485                 db    5
.xdata$x:00004486                 db  93h ; ô
.xdata$x:00004487                 db  19h
.xdata$x:00004488                 db    2
.xdata$x:00004489                 db    0
.xdata$x:0000448A                 db    0
.xdata$x:0000448B                 db    0
.xdata$x:0000448C                 dd offset __unwindtable$??0MenuItemUnit@@QAE@KPB_W0@Z
.xdata$x:00004490                 db    0
.xdata$x:00004491                 db    0
.xdata$x:00004492                 db    0
.xdata$x:00004493                 db    0
.xdata$x:00004494                 db    0
.xdata$x:00004495                 db    0
.xdata$x:00004496                 db    0
.xdata$x:00004497                 db    0
.xdata$x:00004498                 db    0
.xdata$x:00004499                 db    0
.xdata$x:0000449A                 db    0
.xdata$x:0000449B                 db    0
.xdata$x:0000449C                 db    0
.xdata$x:0000449D                 db    0
.xdata$x:0000449E                 db    0
.xdata$x:0000449F                 db    0
.xdata$x:000044A0                 db    0
.xdata$x:000044A1                 db    0
.xdata$x:000044A2                 db    0
.xdata$x:000044A3                 db    0
.xdata$x:000044A4                 db    0
.xdata$x:000044A5                 db    0
.xdata$x:000044A6                 db    0
.xdata$x:000044A7                 db    0
.xdata$x:000044A7 _xdata$x        ends
.xdata$x:000044A7
.xdata$x:000044A8 ; ===========================================================================
.xdata$x:000044A8
.xdata$x:000044A8 ; Segment type: Pure data
.xdata$x:000044A8 ; Segment permissions: Read
.xdata$x:000044A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000044A8                 assume cs:_xdata$x
.xdata$x:000044A8                 ;org 44A8h
.xdata$x:000044A8 ; COMDAT (pick associative to section at 1760)
.xdata$x:000044A8 __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000044A8                                         ; DATA XREF: .xdata$x:000044B8o
.xdata$x:000044A9                 db 0FFh
.xdata$x:000044AA                 db 0FFh
.xdata$x:000044AB                 db 0FFh
.xdata$x:000044AC                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ$0
.xdata$x:000044B0 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000044B0                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ+11o
.xdata$x:000044B1                 db    5
.xdata$x:000044B2                 db  93h ; ô
.xdata$x:000044B3                 db  19h
.xdata$x:000044B4                 db    1
.xdata$x:000044B5                 db    0
.xdata$x:000044B6                 db    0
.xdata$x:000044B7                 db    0
.xdata$x:000044B8                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAUHMENU__@@@std@@@std@@QAE@XZ
.xdata$x:000044BC                 db    0
.xdata$x:000044BD                 db    0
.xdata$x:000044BE                 db    0
.xdata$x:000044BF                 db    0
.xdata$x:000044C0                 db    0
.xdata$x:000044C1                 db    0
.xdata$x:000044C2                 db    0
.xdata$x:000044C3                 db    0
.xdata$x:000044C4                 db    0
.xdata$x:000044C5                 db    0
.xdata$x:000044C6                 db    0
.xdata$x:000044C7                 db    0
.xdata$x:000044C8                 db    0
.xdata$x:000044C9                 db    0
.xdata$x:000044CA                 db    0
.xdata$x:000044CB                 db    0
.xdata$x:000044CC                 db    0
.xdata$x:000044CD                 db    0
.xdata$x:000044CE                 db    0
.xdata$x:000044CF                 db    0
.xdata$x:000044D0                 db    0
.xdata$x:000044D1                 db    0
.xdata$x:000044D2                 db    0
.xdata$x:000044D3                 db    0
.xdata$x:000044D3 _xdata$x        ends
.xdata$x:000044D3
.xdata$x:000044D4 ; ===========================================================================
.xdata$x:000044D4
.xdata$x:000044D4 ; Segment type: Pure data
.xdata$x:000044D4 ; Segment permissions: Read
.xdata$x:000044D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000044D4                 assume cs:_xdata$x
.xdata$x:000044D4                 ;org 44D4h
.xdata$x:000044D4 ; COMDAT (pick associative to section at 16E8)
.xdata$x:000044D4 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000044D4                                         ; DATA XREF: .xdata$x:000044E4o
.xdata$x:000044D5                 db 0FFh
.xdata$x:000044D6                 db 0FFh
.xdata$x:000044D7                 db 0FFh
.xdata$x:000044D8                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000044DC __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000044DC                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000044DD                 db    5
.xdata$x:000044DE                 db  93h ; ô
.xdata$x:000044DF                 db  19h
.xdata$x:000044E0                 db    1
.xdata$x:000044E1                 db    0
.xdata$x:000044E2                 db    0
.xdata$x:000044E3                 db    0
.xdata$x:000044E4                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@@std@@QAE@XZ
.xdata$x:000044E8                 align 20h
.xdata$x:000044E8 _xdata$x        ends
.xdata$x:000044E8
.xdata$x:00004500 ; ===========================================================================
.xdata$x:00004500
.xdata$x:00004500 ; Segment type: Pure data
.xdata$x:00004500 ; Segment permissions: Read
.xdata$x:00004500 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004500                 assume cs:_xdata$x
.xdata$x:00004500                 ;org 4500h
.xdata$x:00004500 ; COMDAT (pick associative to section at 18C8)
.xdata$x:00004500 __unwindtable$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004500                                         ; DATA XREF: .xdata$x:00004510o
.xdata$x:00004501                 db 0FFh
.xdata$x:00004502                 db 0FFh
.xdata$x:00004503                 db 0FFh
.xdata$x:00004504                 dd offset __unwindfunclet$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ$0
.xdata$x:00004508 __ehfuncinfo$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004508                                         ; DATA XREF: __ehhandler$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ+11o
.xdata$x:00004509                 db    5
.xdata$x:0000450A                 db  93h ; ô
.xdata$x:0000450B                 db  19h
.xdata$x:0000450C                 db    1
.xdata$x:0000450D                 db    0
.xdata$x:0000450E                 db    0
.xdata$x:0000450F                 db    0
.xdata$x:00004510                 dd offset __unwindtable$??1?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@QAE@XZ
.xdata$x:00004514                 db    0
.xdata$x:00004515                 db    0
.xdata$x:00004516                 db    0
.xdata$x:00004517                 db    0
.xdata$x:00004518                 db    0
.xdata$x:00004519                 db    0
.xdata$x:0000451A                 db    0
.xdata$x:0000451B                 db    0
.xdata$x:0000451C                 db    0
.xdata$x:0000451D                 db    0
.xdata$x:0000451E                 db    0
.xdata$x:0000451F                 db    0
.xdata$x:00004520                 db    0
.xdata$x:00004521                 db    0
.xdata$x:00004522                 db    0
.xdata$x:00004523                 db    0
.xdata$x:00004524                 db    0
.xdata$x:00004525                 db    0
.xdata$x:00004526                 db    0
.xdata$x:00004527                 db    0
.xdata$x:00004528                 db    0
.xdata$x:00004529                 db    0
.xdata$x:0000452A                 db    0
.xdata$x:0000452B                 db    0
.xdata$x:0000452B _xdata$x        ends
.xdata$x:0000452B
.xdata$x:0000452C ; ===========================================================================
.xdata$x:0000452C
.xdata$x:0000452C ; Segment type: Pure data
.xdata$x:0000452C ; Segment permissions: Read
.xdata$x:0000452C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000452C                 assume cs:_xdata$x
.xdata$x:0000452C                 ;org 452Ch
.xdata$x:0000452C ; COMDAT (pick associative to section at 29A4)
.xdata$x:0000452C __catchsym$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000452C                                         ; DATA XREF: .xdata$x:0000455Co
.xdata$x:0000452D                 db    0
.xdata$x:0000452E                 db    0
.xdata$x:0000452F                 db    0
.xdata$x:00004530                 db    0
.xdata$x:00004531                 db    0
.xdata$x:00004532                 db    0
.xdata$x:00004533                 db    0
.xdata$x:00004534                 db    0
.xdata$x:00004535                 db    0
.xdata$x:00004536                 db    0
.xdata$x:00004537                 db    0
.xdata$x:00004538                 dd offset __catch$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000453C __unwindtable$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000453C                                         ; DATA XREF: .xdata$x:00004568o
.xdata$x:0000453D                 db 0FFh
.xdata$x:0000453E                 db 0FFh
.xdata$x:0000453F                 db 0FFh
.xdata$x:00004540                 db    0
.xdata$x:00004541                 db    0
.xdata$x:00004542                 db    0
.xdata$x:00004543                 db    0
.xdata$x:00004544                 db 0FFh
.xdata$x:00004545                 db 0FFh
.xdata$x:00004546                 db 0FFh
.xdata$x:00004547                 db 0FFh
.xdata$x:00004548                 db    0
.xdata$x:00004549                 db    0
.xdata$x:0000454A                 db    0
.xdata$x:0000454B                 db    0
.xdata$x:0000454C __tryblocktable$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000454C                                         ; DATA XREF: .xdata$x:00004570o
.xdata$x:0000454D                 db    0
.xdata$x:0000454E                 db    0
.xdata$x:0000454F                 db    0
.xdata$x:00004550                 db    0
.xdata$x:00004551                 db    0
.xdata$x:00004552                 db    0
.xdata$x:00004553                 db    0
.xdata$x:00004554                 db    1
.xdata$x:00004555                 db    0
.xdata$x:00004556                 db    0
.xdata$x:00004557                 db    0
.xdata$x:00004558                 db    1
.xdata$x:00004559                 db    0
.xdata$x:0000455A                 db    0
.xdata$x:0000455B                 db    0
.xdata$x:0000455C                 dd offset __catchsym$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z$2
.xdata$x:00004560 __ehfuncinfo$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00004560                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z+11o
.xdata$x:00004561                 db    5
.xdata$x:00004562                 db  93h ; ô
.xdata$x:00004563                 db  19h
.xdata$x:00004564                 db    2
.xdata$x:00004565                 db    0
.xdata$x:00004566                 db    0
.xdata$x:00004567                 db    0
.xdata$x:00004568                 dd offset __unwindtable$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.xdata$x:0000456C                 db    1
.xdata$x:0000456D                 db    0
.xdata$x:0000456E                 db    0
.xdata$x:0000456F                 db    0
.xdata$x:00004570                 dd offset __tryblocktable$?_Reallocate@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IAEXI@Z
.xdata$x:00004574                 db    0
.xdata$x:00004575                 db    0
.xdata$x:00004576                 db    0
.xdata$x:00004577                 db    0
.xdata$x:00004578                 db    0
.xdata$x:00004579                 db    0
.xdata$x:0000457A                 db    0
.xdata$x:0000457B                 db    0
.xdata$x:0000457C                 db    0
.xdata$x:0000457D                 db    0
.xdata$x:0000457E                 db    0
.xdata$x:0000457F                 db    0
.xdata$x:00004580                 db    0
.xdata$x:00004581                 db    0
.xdata$x:00004582                 db    0
.xdata$x:00004583                 db    0
.xdata$x:00004583 _xdata$x        ends
.xdata$x:00004583
.xdata$x:00004584 ; ===========================================================================
.xdata$x:00004584
.xdata$x:00004584 ; Segment type: Pure data
.xdata$x:00004584 ; Segment permissions: Read
.xdata$x:00004584 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004584                 assume cs:_xdata$x
.xdata$x:00004584                 ;org 4584h
.xdata$x:00004584 ; COMDAT (pick associative to section at 28C8)
.xdata$x:00004584 __unwindtable$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z db 0FFh
.xdata$x:00004584                                         ; DATA XREF: .xdata$x:00004594o
.xdata$x:00004585                 db 0FFh
.xdata$x:00004586                 db 0FFh
.xdata$x:00004587                 db 0FFh
.xdata$x:00004588                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z$0
.xdata$x:0000458C __ehfuncinfo$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z db  22h ; "
.xdata$x:0000458C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z+11o
.xdata$x:0000458D                 db    5
.xdata$x:0000458E                 db  93h ; ô
.xdata$x:0000458F                 db  19h
.xdata$x:00004590                 db    1
.xdata$x:00004591                 db    0
.xdata$x:00004592                 db    0
.xdata$x:00004593                 db    0
.xdata$x:00004594                 dd offset __unwindtable$?_Orphan_range@?$vector@PAUHMENU__@@V?$allocator@PAUHMENU__@@@std@@@std@@IBEXPAPAUHMENU__@@0@Z
.xdata$x:00004598                 db    0
.xdata$x:00004599                 db    0
.xdata$x:0000459A                 db    0
.xdata$x:0000459B                 db    0
.xdata$x:0000459C                 db    0
.xdata$x:0000459D                 db    0
.xdata$x:0000459E                 db    0
.xdata$x:0000459F                 db    0
.xdata$x:000045A0                 db    0
.xdata$x:000045A1                 db    0
.xdata$x:000045A2                 db    0
.xdata$x:000045A3                 db    0
.xdata$x:000045A4                 db    0
.xdata$x:000045A5                 db    0
.xdata$x:000045A6                 db    0
.xdata$x:000045A7                 db    0
.xdata$x:000045A8                 db    0
.xdata$x:000045A9                 db    0
.xdata$x:000045AA                 db    0
.xdata$x:000045AB                 db    0
.xdata$x:000045AC                 db    0
.xdata$x:000045AD                 db    0
.xdata$x:000045AE                 db    0
.xdata$x:000045AF                 db    0
.xdata$x:000045AF _xdata$x        ends
.xdata$x:000045AF
.xdata$x:000045B0 ; ===========================================================================
.xdata$x:000045B0
.xdata$x:000045B0 ; Segment type: Pure data
.xdata$x:000045B0 ; Segment permissions: Read
.xdata$x:000045B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000045B0                 assume cs:_xdata$x
.xdata$x:000045B0                 ;org 45B0h
.xdata$x:000045B0 ; COMDAT (pick associative to section at CF4)
.xdata$x:000045B0 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000045B0                                         ; DATA XREF: .xdata$x:000045C0o
.xdata$x:000045B1                 db 0FFh
.xdata$x:000045B2                 db 0FFh
.xdata$x:000045B3                 db 0FFh
.xdata$x:000045B4                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000045B8 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000045B8                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000045B9                 db    5
.xdata$x:000045BA                 db  93h ; ô
.xdata$x:000045BB                 db  19h
.xdata$x:000045BC                 db    1
.xdata$x:000045BD                 db    0
.xdata$x:000045BE                 db    0
.xdata$x:000045BF                 db    0
.xdata$x:000045C0                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000045C4                 db    0
.xdata$x:000045C5                 db    0
.xdata$x:000045C6                 db    0
.xdata$x:000045C7                 db    0
.xdata$x:000045C8                 db    0
.xdata$x:000045C9                 db    0
.xdata$x:000045CA                 db    0
.xdata$x:000045CB                 db    0
.xdata$x:000045CC                 db    0
.xdata$x:000045CD                 db    0
.xdata$x:000045CE                 db    0
.xdata$x:000045CF                 db    0
.xdata$x:000045D0                 db    0
.xdata$x:000045D1                 db    0
.xdata$x:000045D2                 db    0
.xdata$x:000045D3                 db    0
.xdata$x:000045D4                 db    0
.xdata$x:000045D5                 db    0
.xdata$x:000045D6                 db    0
.xdata$x:000045D7                 db    0
.xdata$x:000045D8                 db    0
.xdata$x:000045D9                 db    0
.xdata$x:000045DA                 db    0
.xdata$x:000045DB                 db    0
.xdata$x:000045DB _xdata$x        ends
.xdata$x:000045DB
.xdata$x:000045DC ; ===========================================================================
.xdata$x:000045DC
.xdata$x:000045DC ; Segment type: Pure data
.xdata$x:000045DC ; Segment permissions: Read
.xdata$x:000045DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000045DC                 assume cs:_xdata$x
.xdata$x:000045DC                 ;org 45DCh
.xdata$x:000045DC ; COMDAT (pick associative to section at AD4)
.xdata$x:000045DC __unwindtable$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z db 0FFh
.xdata$x:000045DC                                         ; DATA XREF: .xdata$x:000045ECo
.xdata$x:000045DD                 db 0FFh
.xdata$x:000045DE                 db 0FFh
.xdata$x:000045DF                 db 0FFh
.xdata$x:000045E0                 dd offset __unwindfunclet$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z$0
.xdata$x:000045E4 __ehfuncinfo$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z db  22h ; "
.xdata$x:000045E4                                         ; DATA XREF: __ehhandler$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z+11o
.xdata$x:000045E5                 db    5
.xdata$x:000045E6                 db  93h ; ô
.xdata$x:000045E7                 db  19h
.xdata$x:000045E8                 db    1
.xdata$x:000045E9                 db    0
.xdata$x:000045EA                 db    0
.xdata$x:000045EB                 db    0
.xdata$x:000045EC                 dd offset __unwindtable$??$construct@PAUHMENU__@@AAPAU1@@?$allocator@PAUHMENU__@@@std@@QAEXPAPAUHMENU__@@AAPAU2@@Z
.xdata$x:000045F0                 db    0
.xdata$x:000045F1                 db    0
.xdata$x:000045F2                 db    0
.xdata$x:000045F3                 db    0
.xdata$x:000045F4                 db    0
.xdata$x:000045F5                 db    0
.xdata$x:000045F6                 db    0
.xdata$x:000045F7                 db    0
.xdata$x:000045F8                 db    0
.xdata$x:000045F9                 db    0
.xdata$x:000045FA                 db    0
.xdata$x:000045FB                 db    0
.xdata$x:000045FC                 db    0
.xdata$x:000045FD                 db    0
.xdata$x:000045FE                 db    0
.xdata$x:000045FF                 db    0
.xdata$x:00004600                 db    0
.xdata$x:00004601                 db    0
.xdata$x:00004602                 db    0
.xdata$x:00004603                 db    0
.xdata$x:00004604                 db    0
.xdata$x:00004605                 db    0
.xdata$x:00004606                 db    0
.xdata$x:00004607                 db    0
.xdata$x:00004607 _xdata$x        ends
.xdata$x:00004607
.xdata$x:00004608 ; ===========================================================================
.xdata$x:00004608
.xdata$x:00004608 ; Segment type: Pure data
.xdata$x:00004608 ; Segment permissions: Read
.xdata$x:00004608 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004608                 assume cs:_xdata$x
.xdata$x:00004608                 ;org 4608h
.xdata$x:00004608 ; COMDAT (pick associative to section at 9D4)
.xdata$x:00004608 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00004608                                         ; DATA XREF: .xdata$x:00004618o
.xdata$x:00004609                 db 0FFh
.xdata$x:0000460A                 db 0FFh
.xdata$x:0000460B                 db 0FFh
.xdata$x:0000460C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00004610 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00004610                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00004611                 db    5
.xdata$x:00004612                 db  93h ; ô
.xdata$x:00004613                 db  19h
.xdata$x:00004614                 db    1
.xdata$x:00004615                 db    0
.xdata$x:00004616                 db    0
.xdata$x:00004617                 db    0
.xdata$x:00004618                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000461C                 db    0
.xdata$x:0000461D                 db    0
.xdata$x:0000461E                 db    0
.xdata$x:0000461F                 db    0
.xdata$x:00004620                 db    0
.xdata$x:00004621                 db    0
.xdata$x:00004622                 db    0
.xdata$x:00004623                 db    0
.xdata$x:00004624                 db    0
.xdata$x:00004625                 db    0
.xdata$x:00004626                 db    0
.xdata$x:00004627                 db    0
.xdata$x:00004628                 db    0
.xdata$x:00004629                 db    0
.xdata$x:0000462A                 db    0
.xdata$x:0000462B                 db    0
.xdata$x:0000462C                 db    0
.xdata$x:0000462D                 db    0
.xdata$x:0000462E                 db    0
.xdata$x:0000462F                 db    0
.xdata$x:00004630                 db    0
.xdata$x:00004631                 db    0
.xdata$x:00004632                 db    0
.xdata$x:00004633                 db    0
.xdata$x:00004633 _xdata$x        ends
.xdata$x:00004633
.xdata$x:00004634 ; ===========================================================================
.xdata$x:00004634
.xdata$x:00004634 ; Segment type: Pure data
.xdata$x:00004634 ; Segment permissions: Read
.xdata$x:00004634 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004634                 assume cs:_xdata$x
.xdata$x:00004634                 ;org 4634h
.xdata$x:00004634 ; COMDAT (pick associative to section at C20)
.xdata$x:00004634 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00004634                                         ; DATA XREF: .xdata$x:00004644o
.xdata$x:00004635                 db 0FFh
.xdata$x:00004636                 db 0FFh
.xdata$x:00004637                 db 0FFh
.xdata$x:00004638                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000463C __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000463C                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000463D                 db    5
.xdata$x:0000463E                 db  93h ; ô
.xdata$x:0000463F                 db  19h
.xdata$x:00004640                 db    1
.xdata$x:00004641                 db    0
.xdata$x:00004642                 db    0
.xdata$x:00004643                 db    0
.xdata$x:00004644                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00004648                 align 20h
.xdata$x:00004648 _xdata$x        ends
.xdata$x:00004648
.bss:00004660 ; ===========================================================================
.bss:00004660
.bss:00004660 ; Segment type: Uninitialized
.bss:00004660 ; Segment permissions: Read/Write
.bss:00004660 _bss            segment byte public 'BSS' use32
.bss:00004660                 assume cs:_bss
.bss:00004660                 ;org 4660h
.bss:00004660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004660 _allocator_arg  db    ? ;
.bss:00004661 _piecewise_construct db    ? ;
.bss:00004662                 align 4
.bss:00004662 _bss            ends
.bss:00004662
.rdata:00004664 ; ===========================================================================
.rdata:00004664
.rdata:00004664 ; Segment type: Pure data
.rdata:00004664 ; Segment permissions: Read
.rdata:00004664 _rdata          segment dword public 'DATA' use32
.rdata:00004664                 assume cs:_rdata
.rdata:00004664                 ;org 4664h
.rdata:00004664 ; COMDAT (pick largest)
.rdata:00004664                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00004668                 public ??_7error_category@std@@6B@
.rdata:00004668 ; const std::error_category::`vftable'
.rdata:00004668 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00004668                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00004668                                         ; std::error_category::~error_category(void)+Ao
.rdata:00004668                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000466C                 dd offset __purecall
.rdata:00004670                 dd offset __purecall
.rdata:00004674                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004678                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000467C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000467C _rdata          ends
.rdata:0000467C
.rdata:00004680 ; ===========================================================================
.rdata:00004680
.rdata:00004680 ; Segment type: Pure data
.rdata:00004680 ; Segment permissions: Read
.rdata:00004680 _rdata          segment dword public 'DATA' use32
.rdata:00004680                 assume cs:_rdata
.rdata:00004680                 ;org 4680h
.rdata:00004680 ; COMDAT (pick largest)
.rdata:00004680                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00004684                 public ??_7_Generic_error_category@std@@6B@
.rdata:00004684 ; const std::_Generic_error_category::`vftable'
.rdata:00004684 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00004684                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00004684                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00004688                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000468C                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00004690                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004694                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004698                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004698 _rdata          ends
.rdata:00004698
.rdata:0000469C ; ===========================================================================
.rdata:0000469C
.rdata:0000469C ; Segment type: Pure data
.rdata:0000469C ; Segment permissions: Read
.rdata:0000469C _rdata          segment dword public 'DATA' use32
.rdata:0000469C                 assume cs:_rdata
.rdata:0000469C                 ;org 469Ch
.rdata:0000469C ; COMDAT (pick any)
.rdata:0000469C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000469C ; `string'
.rdata:0000469C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000469C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000469C _rdata          ends
.rdata:0000469C
.rdata:000046A4 ; ===========================================================================
.rdata:000046A4
.rdata:000046A4 ; Segment type: Pure data
.rdata:000046A4 ; Segment permissions: Read
.rdata:000046A4 _rdata          segment dword public 'DATA' use32
.rdata:000046A4                 assume cs:_rdata
.rdata:000046A4                 ;org 46A4h
.rdata:000046A4 ; COMDAT (pick any)
.rdata:000046A4                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:000046A4 ; `string'
.rdata:000046A4 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:000046A4                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_3A40o
.rdata:000046A4                                         ; std::_System_error_category::message(int):loc_3BBCo
.rdata:000046B2                 align 4
.rdata:000046B2 _rdata          ends
.rdata:000046B2
.rdata:000046B4 ; ===========================================================================
.rdata:000046B4
.rdata:000046B4 ; Segment type: Pure data
.rdata:000046B4 ; Segment permissions: Read
.rdata:000046B4 _rdata          segment dword public 'DATA' use32
.rdata:000046B4                 assume cs:_rdata
.rdata:000046B4                 ;org 46B4h
.rdata:000046B4 ; COMDAT (pick largest)
.rdata:000046B4                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:000046B8                 public ??_7_Iostream_error_category@std@@6B@
.rdata:000046B8 ; const std::_Iostream_error_category::`vftable'
.rdata:000046B8 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:000046B8                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:000046B8                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:000046BC                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000046C0                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000046C4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000046C8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000046CC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000046CC _rdata          ends
.rdata:000046CC
.rdata:000046D0 ; ===========================================================================
.rdata:000046D0
.rdata:000046D0 ; Segment type: Pure data
.rdata:000046D0 ; Segment permissions: Read
.rdata:000046D0 _rdata          segment dword public 'DATA' use32
.rdata:000046D0                 assume cs:_rdata
.rdata:000046D0                 ;org 46D0h
.rdata:000046D0 ; COMDAT (pick any)
.rdata:000046D0                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000046D0 ; `string'
.rdata:000046D0 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000046D0                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000046D9                 align 4
.rdata:000046D9 _rdata          ends
.rdata:000046D9
.rdata:000046DC ; ===========================================================================
.rdata:000046DC
.rdata:000046DC ; Segment type: Pure data
.rdata:000046DC ; Segment permissions: Read
.rdata:000046DC _rdata          segment dword public 'DATA' use32
.rdata:000046DC                 assume cs:_rdata
.rdata:000046DC                 ;org 46DCh
.rdata:000046DC ; COMDAT (pick any)
.rdata:000046DC                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000046DC ; char `string'[]
.rdata:000046DC ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000046DC                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:000046F2                 align 4
.rdata:000046F2 _rdata          ends
.rdata:000046F2
.rdata:000046F4 ; ===========================================================================
.rdata:000046F4
.rdata:000046F4 ; Segment type: Pure data
.rdata:000046F4 ; Segment permissions: Read
.rdata:000046F4 _rdata          segment dword public 'DATA' use32
.rdata:000046F4                 assume cs:_rdata
.rdata:000046F4                 ;org 46F4h
.rdata:000046F4 ; COMDAT (pick largest)
.rdata:000046F4                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:000046F8                 public ??_7_System_error_category@std@@6B@
.rdata:000046F8 ; const std::_System_error_category::`vftable'
.rdata:000046F8 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:000046F8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:000046F8                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000046FC                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00004700                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00004704                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00004708                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000470C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000470C _rdata          ends
.rdata:0000470C
.rdata:00004710 ; ===========================================================================
.rdata:00004710
.rdata:00004710 ; Segment type: Pure data
.rdata:00004710 ; Segment permissions: Read
.rdata:00004710 _rdata          segment dword public 'DATA' use32
.rdata:00004710                 assume cs:_rdata
.rdata:00004710                 ;org 4710h
.rdata:00004710 ; COMDAT (pick any)
.rdata:00004710                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00004710 ; `string'
.rdata:00004710 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00004710                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00004717                 align 4
.rdata:00004717 _rdata          ends
.rdata:00004717
.bss:00004718 ; ===========================================================================
.bss:00004718
.bss:00004718 ; Segment type: Uninitialized
.bss:00004718 ; Segment permissions: Read/Write
.bss:00004718 _bss            segment dword public 'BSS' use32
.bss:00004718                 assume cs:_bss
.bss:00004718                 ;org 4718h
.bss:00004718 ; COMDAT (pick any)
.bss:00004718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004718                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00004718 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00004718 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00004718                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00004718                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00004719                 db    ? ;
.bss:0000471A                 db    ? ;
.bss:0000471B                 db    ? ;
.bss:0000471B _bss            ends
.bss:0000471B
.bss:0000471C ; ===========================================================================
.bss:0000471C
.bss:0000471C ; Segment type: Uninitialized
.bss:0000471C ; Segment permissions: Read/Write
.bss:0000471C _bss            segment dword public 'BSS' use32
.bss:0000471C                 assume cs:_bss
.bss:0000471C                 ;org 471Ch
.bss:0000471C ; COMDAT (pick any)
.bss:0000471C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000471C                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000471C ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000471C ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000471C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000471C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000471D                 db    ? ;
.bss:0000471E                 db    ? ;
.bss:0000471F                 db    ? ;
.bss:0000471F _bss            ends
.bss:0000471F
.bss:00004720 ; ===========================================================================
.bss:00004720
.bss:00004720 ; Segment type: Uninitialized
.bss:00004720 ; Segment permissions: Read/Write
.bss:00004720 _bss            segment dword public 'BSS' use32
.bss:00004720                 assume cs:_bss
.bss:00004720                 ;org 4720h
.bss:00004720 ; COMDAT (pick any)
.bss:00004720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004720                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00004720 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00004720 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00004720                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00004720                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00004721                 db    ? ;
.bss:00004722                 db    ? ;
.bss:00004723                 db    ? ;
.bss:00004723 _bss            ends
.bss:00004723
.rdata:00004724 ; ===========================================================================
.rdata:00004724
.rdata:00004724 ; Segment type: Pure data
.rdata:00004724 ; Segment permissions: Read
.rdata:00004724 _rdata          segment dword public 'DATA' use32
.rdata:00004724                 assume cs:_rdata
.rdata:00004724                 ;org 4724h
.rdata:00004724 ; COMDAT (pick any)
.rdata:00004724                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:00004724 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:00004724 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:00004724                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7r
.rdata:00004724 _rdata          ends
.rdata:00004724
.bss:00004728 ; ===========================================================================
.bss:00004728
.bss:00004728 ; Segment type: Uninitialized
.bss:00004728 ; Segment permissions: Read/Write
.bss:00004728 _bss            segment dword public 'BSS' use32
.bss:00004728                 assume cs:_bss
.bss:00004728                 ;org 4728h
.bss:00004728 ; COMDAT (pick any)
.bss:00004728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004728                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00004728 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00004728 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00004728                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00004729                 db    ? ;
.bss:0000472A                 db    ? ;
.bss:0000472B                 db    ? ;
.bss:0000472B _bss            ends
.bss:0000472B
.bss:0000472C ; ===========================================================================
.bss:0000472C
.bss:0000472C ; Segment type: Uninitialized
.bss:0000472C ; Segment permissions: Read/Write
.bss:0000472C _bss            segment dword public 'BSS' use32
.bss:0000472C                 assume cs:_bss
.bss:0000472C                 ;org 472Ch
.bss:0000472C ; COMDAT (pick any)
.bss:0000472C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000472C                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000472C ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000472C ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000472C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000472D                 db    ? ;
.bss:0000472E                 db    ? ;
.bss:0000472F                 db    ? ;
.bss:0000472F _bss            ends
.bss:0000472F
.rdata:00004730 ; ===========================================================================
.rdata:00004730
.rdata:00004730 ; Segment type: Pure data
.rdata:00004730 ; Segment permissions: Read
.rdata:00004730 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00004730 _rdata          segment para public 'DATA' use32
.rdata:00004730                 assume cs:_rdata
.rdata:00004730                 ;org 4730h
.rdata:00004730 ; COMDAT (pick any)
.rdata:00004730                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00004730 ; wchar_t `string'
.rdata:00004730 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00004730                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00004730                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00004730                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00004730                 unicode 0, <clude\xstring>,0
.rdata:000047BE                 align 10h
.rdata:000047BE _rdata          ends
.rdata:000047BE
.bss:000047C0 ; ===========================================================================
.bss:000047C0
.bss:000047C0 ; Segment type: Uninitialized
.bss:000047C0 ; Segment permissions: Read/Write
.bss:000047C0 _bss            segment dword public 'BSS' use32
.bss:000047C0                 assume cs:_bss
.bss:000047C0                 ;org 47C0h
.bss:000047C0 ; COMDAT (pick any)
.bss:000047C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000047C0                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000047C0 ; std::locale::id std::numpunct<char>::id
.bss:000047C0 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000047C0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000047C1                 db    ? ;
.bss:000047C2                 db    ? ;
.bss:000047C3                 db    ? ;
.bss:000047C3 _bss            ends
.bss:000047C3
.bss:000047C4 ; ===========================================================================
.bss:000047C4
.bss:000047C4 ; Segment type: Uninitialized
.bss:000047C4 ; Segment permissions: Read/Write
.bss:000047C4 _bss            segment dword public 'BSS' use32
.bss:000047C4                 assume cs:_bss
.bss:000047C4                 ;org 47C4h
.bss:000047C4 ; COMDAT (pick any)
.bss:000047C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000047C4                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000047C4 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000047C4 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000047C4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000047C5                 db    ? ;
.bss:000047C6                 db    ? ;
.bss:000047C7                 db    ? ;
.bss:000047C7 _bss            ends
.bss:000047C7
.rdata:000047C8 ; ===========================================================================
.rdata:000047C8
.rdata:000047C8 ; Segment type: Pure data
.rdata:000047C8 ; Segment permissions: Read
.rdata:000047C8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000047C8 _rdata          segment para public 'DATA' use32
.rdata:000047C8                 assume cs:_rdata
.rdata:000047C8                 ;org 47C8h
.rdata:000047C8 ; COMDAT (pick any)
.rdata:000047C8                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000047C8 ; wchar_t `string'
.rdata:000047C8 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000047C8                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+19o
.rdata:000047C8                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+49o ...
.rdata:000047C8                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000047C8                 unicode 0, <clude\vector>,0
.rdata:000047C8 _rdata          ends
.rdata:000047C8
.rdata:00004854 ; ===========================================================================
.rdata:00004854
.rdata:00004854 ; Segment type: Pure data
.rdata:00004854 ; Segment permissions: Read
.rdata:00004854 _rdata          segment dword public 'DATA' use32
.rdata:00004854                 assume cs:_rdata
.rdata:00004854                 ;org 4854h
.rdata:00004854 ; COMDAT (pick any)
.rdata:00004854                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00004854 ; wchar_t `string'
.rdata:00004854 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00004854                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+1Eo
.rdata:00004854                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+1Eo
.rdata:00004854                 unicode 0, <vector subscript out of range>,0
.rdata:00004854 _rdata          ends
.rdata:00004854
.rdata:00004890 ; ===========================================================================
.rdata:00004890
.rdata:00004890 ; Segment type: Pure data
.rdata:00004890 ; Segment permissions: Read
.rdata:00004890 _rdata          segment dword public 'DATA' use32
.rdata:00004890                 assume cs:_rdata
.rdata:00004890                 ;org 4890h
.rdata:00004890 ; COMDAT (pick any)
.rdata:00004890                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00004890 ; `string'
.rdata:00004890 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00004890                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+2Bo
.rdata:00004890                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+2Bo
.rdata:00004890 _rdata          ends
.rdata:00004890
.rdata:000048B4 ; ===========================================================================
.rdata:000048B4
.rdata:000048B4 ; Segment type: Pure data
.rdata:000048B4 ; Segment permissions: Read
.rdata:000048B4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000048B4 _rdata          segment para public 'DATA' use32
.rdata:000048B4                 assume cs:_rdata
.rdata:000048B4                 ;org 48B4h
.rdata:000048B4 ; COMDAT (pick any)
.rdata:000048B4                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:000048B4 ; `string'
.rdata:000048B4 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:000048B4                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint):loc_1C18o
.rdata:000048B4                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint):loc_1CA8o
.rdata:000048B4                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000490A                 align 4
.rdata:0000490A _rdata          ends
.rdata:0000490A
.rdata:0000490C ; ===========================================================================
.rdata:0000490C
.rdata:0000490C ; Segment type: Pure data
.rdata:0000490C ; Segment permissions: Read
.rdata:0000490C _rdata          segment dword public 'DATA' use32
.rdata:0000490C                 assume cs:_rdata
.rdata:0000490C                 ;org 490Ch
.rdata:0000490C ; COMDAT (pick any)
.rdata:0000490C                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000490C ; `string'
.rdata:0000490C ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000490C                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+3Do
.rdata:0000490C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+3Do
.rdata:0000490C                 unicode 0, <%s>,0
.rdata:00004912                 align 4
.rdata:00004912 _rdata          ends
.rdata:00004912
.rdata:00004914 ; ===========================================================================
.rdata:00004914
.rdata:00004914 ; Segment type: Pure data
.rdata:00004914 ; Segment permissions: Read
.rdata:00004914 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00004914 _rdata          segment para public 'DATA' use32
.rdata:00004914                 assume cs:_rdata
.rdata:00004914                 ;org 4914h
.rdata:00004914 ; COMDAT (pick any)
.rdata:00004914                 public ??_C@_1KG@BGKNHFHH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAH?$AAM?$AAE?$AAN?$AAU?$AA_?$AA_?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa@
.rdata:00004914 ; `string'
.rdata:00004914 ??_C@_1KG@BGKNHFHH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAH?$AAM?$AAE?$AAN?$AAU?$AA_?$AA_?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa@:
.rdata:00004914                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+6Ao
.rdata:00004914                 unicode 0, <std::vector>
.rdata:00004914                 dw 3Ch
.rdata:00004914                 unicode 0, <struct HMENU__ *,class std::allocator>
.rdata:00004914                 dw 3Ch
.rdata:00004914                 unicode 0, <struct HMENU__ *>
.rdata:00004914                 dw 3Eh
.rdata:00004914                 unicode 0, < >
.rdata:00004914                 dw 3Eh
.rdata:00004914                 unicode 0, <::operator []>,0
.rdata:000049BA                 align 4
.rdata:000049BA _rdata          ends
.rdata:000049BA
.rdata:000049BC ; ===========================================================================
.rdata:000049BC
.rdata:000049BC ; Segment type: Pure data
.rdata:000049BC ; Segment permissions: Read
.rdata:000049BC _rdata          segment dword public 'DATA' use32
.rdata:000049BC                 assume cs:_rdata
.rdata:000049BC                 ;org 49BCh
.rdata:000049BC ; COMDAT (pick any)
.rdata:000049BC                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:000049BC ; `string'
.rdata:000049BC ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:000049BC                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+6Fo
.rdata:000049BC                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+6Fo
.rdata:000049BC                 unicode 0, <"out of range">,0
.rdata:000049DA                 align 4
.rdata:000049DA _rdata          ends
.rdata:000049DA
.rdata:000049DC ; ===========================================================================
.rdata:000049DC
.rdata:000049DC ; Segment type: Pure data
.rdata:000049DC ; Segment permissions: Read
.rdata:000049DC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000049DC _rdata          segment para public 'DATA' use32
.rdata:000049DC                 assume cs:_rdata
.rdata:000049DC                 ;org 49DCh
.rdata:000049DC ; COMDAT (pick any)
.rdata:000049DC                 public ??_C@_1LC@CAPJOKNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAM?$AAe?$AAn?$AAu?$AAI?$AAt?$AAe?$AAm?$AAU?$AAn?$AAi?$AAt?$AA?0@
.rdata:000049DC ; `string'
.rdata:000049DC ??_C@_1LC@CAPJOKNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAM?$AAe?$AAn?$AAu?$AAI?$AAt?$AAe?$AAm?$AAU?$AAn?$AAi?$AAt?$AA?0@:
.rdata:000049DC                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+6Ao
.rdata:000049DC                 unicode 0, <std::vector>
.rdata:000049DC                 dw 3Ch
.rdata:000049DC                 unicode 0, <struct MenuItemUnit,class std::allocator>
.rdata:000049DC                 dw 3Ch
.rdata:000049DC                 unicode 0, <struct MenuItemUnit>
.rdata:000049DC                 dw 3Eh
.rdata:000049DC                 unicode 0, < >
.rdata:000049DC                 dw 3Eh
.rdata:000049DC                 unicode 0, <::operator []>,0
.rdata:00004A8E                 align 10h
.rdata:00004A8E _rdata          ends
.rdata:00004A8E
.rdata:00004A90 ; ===========================================================================
.rdata:00004A90
.rdata:00004A90 ; Segment type: Pure data
.rdata:00004A90 ; Segment permissions: Read
.rdata:00004A90 _rdata          segment dword public 'DATA' use32
.rdata:00004A90                 assume cs:_rdata
.rdata:00004A90                 ;org 4A90h
.rdata:00004A90 ; COMDAT (pick any)
.rdata:00004A90                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00004A90 ; char `string'[]
.rdata:00004A90 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00004A90                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00004A90                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00004A90 _rdata          ends
.rdata:00004A90
.rdata:00004AA0 ; ===========================================================================
.rdata:00004AA0
.rdata:00004AA0 ; Segment type: Pure data
.rdata:00004AA0 ; Segment permissions: Read
.rdata:00004AA0 _rdata          segment dword public 'DATA' use32
.rdata:00004AA0                 assume cs:_rdata
.rdata:00004AA0                 ;org 4AA0h
.rdata:00004AA0 ; COMDAT (pick any)
.rdata:00004AA0                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00004AA0 ; char `string'[]
.rdata:00004AA0 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00004AA0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00004AA0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00004AA0 _rdata          ends
.rdata:00004AA0
.rdata:00004AB8 ; ===========================================================================
.rdata:00004AB8
.rdata:00004AB8 ; Segment type: Pure data
.rdata:00004AB8 ; Segment permissions: Read
.rdata:00004AB8 _rdata          segment dword public 'DATA' use32
.rdata:00004AB8                 assume cs:_rdata
.rdata:00004AB8                 ;org 4AB8h
.rdata:00004AB8 ; COMDAT (pick any)
.rdata:00004AB8                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:00004AB8 ; char `string'[]
.rdata:00004AB8 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:00004AB8                                         ; DATA XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Xlen(void)+7o
.rdata:00004ACB                 align 4
.rdata:00004ACB _rdata          ends
.rdata:00004ACB
.rdata:00004ACC ; ===========================================================================
.rdata:00004ACC
.rdata:00004ACC ; Segment type: Pure data
.rdata:00004ACC ; Segment permissions: Read
.rdata:00004ACC _rdata          segment dword public 'DATA' use32
.rdata:00004ACC                 assume cs:_rdata
.rdata:00004ACC                 ;org 4ACCh
.rdata:00004ACC ; COMDAT (pick any)
.rdata:00004ACC                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00004ACC ; wchar_t `string'
.rdata:00004ACC ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00004ACC                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00004ACC                                         ; std::_Debug_pointer<HMENU__ *>(HMENU__ * *,wchar_t const *,uint)+11o ...
.rdata:00004ACC                 unicode 0, <invalid null pointer>,0
.rdata:00004AF6                 align 4
.rdata:00004AF6 _rdata          ends
.rdata:00004AF6
.rdata:00004AF8 ; ===========================================================================
.rdata:00004AF8
.rdata:00004AF8 ; Segment type: Pure data
.rdata:00004AF8 ; Segment permissions: Read
.rdata:00004AF8 _rdata          segment dword public 'DATA' use32
.rdata:00004AF8                 assume cs:_rdata
.rdata:00004AF8                 ;org 4AF8h
.rdata:00004AF8 ; COMDAT (pick any)
.rdata:00004AF8                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00004AF8 ; wchar_t `string'
.rdata:00004AF8 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00004AF8                                         ; DATA XREF: std::_Debug_range2<HMENU__ * *>(HMENU__ * *,HMENU__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:00004AF8                 unicode 0, <invalid iterator range>,0
.rdata:00004B26                 align 4
.rdata:00004B26 _rdata          ends
.rdata:00004B26
.rdata:00004B28 ; ===========================================================================
.rdata:00004B28
.rdata:00004B28 ; Segment type: Pure data
.rdata:00004B28 ; Segment permissions: Read
.rdata:00004B28 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00004B28 _rdata          segment para public 'DATA' use32
.rdata:00004B28                 assume cs:_rdata
.rdata:00004B28                 ;org 4B28h
.rdata:00004B28 ; COMDAT (pick any)
.rdata:00004B28                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00004B28 ; wchar_t `string'
.rdata:00004B28 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00004B28                                         ; DATA XREF: std::_Uninit_move<HMENU__ *,HMENU__ *,HMENU__ *>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &,HMENU__ * *,std::_Scalar_ptr_iterator_tag)+9o
.rdata:00004B28                                         ; std::_Uninit_move<HMENU__ *,HMENU__ *,HMENU__ *>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &,HMENU__ * *,std::_Scalar_ptr_iterator_tag)+23o
.rdata:00004B28                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00004B28                 unicode 0, <clude\xmemory>,0
.rdata:00004BB6                 align 4
.rdata:00004BB6 _rdata          ends
.rdata:00004BB6
.rdata$r:00004BB8 ; ===========================================================================
.rdata$r:00004BB8
.rdata$r:00004BB8 ; Segment type: Pure data
.rdata$r:00004BB8 ; Segment permissions: Read
.rdata$r:00004BB8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004BB8                 assume cs:_rdata$r
.rdata$r:00004BB8                 ;org 4BB8h
.rdata$r:00004BB8 ; COMDAT (pick any)
.rdata$r:00004BB8                 public ??_R4error_category@std@@6B@
.rdata$r:00004BB8 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00004BB8 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00004664o
.rdata$r:00004BB9                 db    0
.rdata$r:00004BBA                 db    0
.rdata$r:00004BBB                 db    0
.rdata$r:00004BBC                 db    0
.rdata$r:00004BBD                 db    0
.rdata$r:00004BBE                 db    0
.rdata$r:00004BBF                 db    0
.rdata$r:00004BC0                 db    0
.rdata$r:00004BC1                 db    0
.rdata$r:00004BC2                 db    0
.rdata$r:00004BC3                 db    0
.rdata$r:00004BC4                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00004BC8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004BC8 _rdata$r        ends
.rdata$r:00004BC8
.data$r:00004BCC ; ===========================================================================
.data$r:00004BCC
.data$r:00004BCC ; Segment type: Pure data
.data$r:00004BCC ; Segment permissions: Read/Write
.data$r:00004BCC _data$r         segment dword public 'DATA' use32
.data$r:00004BCC                 assume cs:_data$r
.data$r:00004BCC                 ;org 4BCCh
.data$r:00004BCC ; COMDAT (pick any)
.data$r:00004BCC                 public ??_R0?AVerror_category@std@@@8
.data$r:00004BCC ; class std::error_category `RTTI Type Descriptor'
.data$r:00004BCC ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004BCC                                         ; DATA XREF: .rdata$r:00004BC4o
.data$r:00004BCC                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004BCC                                         ; const type_info::`vftable'
.data$r:00004BD0                 db    0
.data$r:00004BD1                 db    0
.data$r:00004BD2                 db    0
.data$r:00004BD3                 db    0
.data$r:00004BD4                 db  2Eh ; .
.data$r:00004BD5                 db  3Fh ; ?
.data$r:00004BD6                 db  41h ; A
.data$r:00004BD7                 db  56h ; V
.data$r:00004BD8                 db  65h ; e
.data$r:00004BD9                 db  72h ; r
.data$r:00004BDA                 db  72h ; r
.data$r:00004BDB                 db  6Fh ; o
.data$r:00004BDC                 db  72h ; r
.data$r:00004BDD                 db  5Fh ; _
.data$r:00004BDE                 db  63h ; c
.data$r:00004BDF                 db  61h ; a
.data$r:00004BE0                 db  74h ; t
.data$r:00004BE1                 db  65h ; e
.data$r:00004BE2                 db  67h ; g
.data$r:00004BE3                 db  6Fh ; o
.data$r:00004BE4                 db  72h ; r
.data$r:00004BE5                 db  79h ; y
.data$r:00004BE6                 db  40h ; @
.data$r:00004BE7                 db  73h ; s
.data$r:00004BE8                 db  74h ; t
.data$r:00004BE9                 db  64h ; d
.data$r:00004BEA                 db  40h ; @
.data$r:00004BEB                 db  40h ; @
.data$r:00004BEC                 db    0
.data$r:00004BED                 align 10h
.data$r:00004BED _data$r         ends
.data$r:00004BED
.rdata$r:00004BF0 ; ===========================================================================
.rdata$r:00004BF0
.rdata$r:00004BF0 ; Segment type: Pure data
.rdata$r:00004BF0 ; Segment permissions: Read
.rdata$r:00004BF0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004BF0                 assume cs:_rdata$r
.rdata$r:00004BF0                 ;org 4BF0h
.rdata$r:00004BF0 ; COMDAT (pick any)
.rdata$r:00004BF0                 public ??_R3error_category@std@@8
.rdata$r:00004BF0 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004BF0 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00004BC8o
.rdata$r:00004BF0                                         ; .rdata$r:00004C20o
.rdata$r:00004BF1                 db    0
.rdata$r:00004BF2                 db    0
.rdata$r:00004BF3                 db    0
.rdata$r:00004BF4                 db    0
.rdata$r:00004BF5                 db    0
.rdata$r:00004BF6                 db    0
.rdata$r:00004BF7                 db    0
.rdata$r:00004BF8                 db    1
.rdata$r:00004BF9                 db    0
.rdata$r:00004BFA                 db    0
.rdata$r:00004BFB                 db    0
.rdata$r:00004BFC                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00004BFC _rdata$r        ends
.rdata$r:00004BFC
.rdata$r:00004C00 ; ===========================================================================
.rdata$r:00004C00
.rdata$r:00004C00 ; Segment type: Pure data
.rdata$r:00004C00 ; Segment permissions: Read
.rdata$r:00004C00 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C00                 assume cs:_rdata$r
.rdata$r:00004C00                 ;org 4C00h
.rdata$r:00004C00 ; COMDAT (pick any)
.rdata$r:00004C00                 public ??_R2error_category@std@@8
.rdata$r:00004C00 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00004C00 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00004C00                                         ; DATA XREF: .rdata$r:00004BFCo
.rdata$r:00004C00                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004C04                 db    0
.rdata$r:00004C05                 align 4
.rdata$r:00004C05 _rdata$r        ends
.rdata$r:00004C05
.rdata$r:00004C08 ; ===========================================================================
.rdata$r:00004C08
.rdata$r:00004C08 ; Segment type: Pure data
.rdata$r:00004C08 ; Segment permissions: Read
.rdata$r:00004C08 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C08                 assume cs:_rdata$r
.rdata$r:00004C08                 ;org 4C08h
.rdata$r:00004C08 ; COMDAT (pick any)
.rdata$r:00004C08                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00004C08 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004C08 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00004C08                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00004C08                                         ; .rdata$r:00004C78o ...
.rdata$r:00004C08                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00004C0C                 db    0
.rdata$r:00004C0D                 db    0
.rdata$r:00004C0E                 db    0
.rdata$r:00004C0F                 db    0
.rdata$r:00004C10                 db    0
.rdata$r:00004C11                 db    0
.rdata$r:00004C12                 db    0
.rdata$r:00004C13                 db    0
.rdata$r:00004C14                 db 0FFh
.rdata$r:00004C15                 db 0FFh
.rdata$r:00004C16                 db 0FFh
.rdata$r:00004C17                 db 0FFh
.rdata$r:00004C18                 db    0
.rdata$r:00004C19                 db    0
.rdata$r:00004C1A                 db    0
.rdata$r:00004C1B                 db    0
.rdata$r:00004C1C                 db  40h ; @
.rdata$r:00004C1D                 db    0
.rdata$r:00004C1E                 db    0
.rdata$r:00004C1F                 db    0
.rdata$r:00004C20                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004C20 _rdata$r        ends
.rdata$r:00004C20
.rdata$r:00004C24 ; ===========================================================================
.rdata$r:00004C24
.rdata$r:00004C24 ; Segment type: Pure data
.rdata$r:00004C24 ; Segment permissions: Read
.rdata$r:00004C24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C24                 assume cs:_rdata$r
.rdata$r:00004C24                 ;org 4C24h
.rdata$r:00004C24 ; COMDAT (pick any)
.rdata$r:00004C24                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00004C24 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00004C24 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00004C24                                         ; DATA XREF: .rdata:00004680o
.rdata$r:00004C25                 db    0
.rdata$r:00004C26                 db    0
.rdata$r:00004C27                 db    0
.rdata$r:00004C28                 db    0
.rdata$r:00004C29                 db    0
.rdata$r:00004C2A                 db    0
.rdata$r:00004C2B                 db    0
.rdata$r:00004C2C                 db    0
.rdata$r:00004C2D                 db    0
.rdata$r:00004C2E                 db    0
.rdata$r:00004C2F                 db    0
.rdata$r:00004C30                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004C34                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004C34 _rdata$r        ends
.rdata$r:00004C34
.data$r:00004C38 ; ===========================================================================
.data$r:00004C38
.data$r:00004C38 ; Segment type: Pure data
.data$r:00004C38 ; Segment permissions: Read/Write
.data$r:00004C38 _data$r         segment dword public 'DATA' use32
.data$r:00004C38                 assume cs:_data$r
.data$r:00004C38                 ;org 4C38h
.data$r:00004C38 ; COMDAT (pick any)
.data$r:00004C38                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00004C38 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00004C38 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004C38                                         ; DATA XREF: .rdata$r:00004C30o
.data$r:00004C38                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004C38                                         ; const type_info::`vftable'
.data$r:00004C3C                 align 10h
.data$r:00004C40 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00004C62                 align 4
.data$r:00004C62 _data$r         ends
.data$r:00004C62
.rdata$r:00004C64 ; ===========================================================================
.rdata$r:00004C64
.rdata$r:00004C64 ; Segment type: Pure data
.rdata$r:00004C64 ; Segment permissions: Read
.rdata$r:00004C64 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C64                 assume cs:_rdata$r
.rdata$r:00004C64                 ;org 4C64h
.rdata$r:00004C64 ; COMDAT (pick any)
.rdata$r:00004C64                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00004C64 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004C64 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00004C64                                         ; DATA XREF: .rdata$r:00004C34o
.rdata$r:00004C64                                         ; .rdata$r:00004C98o
.rdata$r:00004C65                 db    0
.rdata$r:00004C66                 db    0
.rdata$r:00004C67                 db    0
.rdata$r:00004C68                 db    0
.rdata$r:00004C69                 db    0
.rdata$r:00004C6A                 db    0
.rdata$r:00004C6B                 db    0
.rdata$r:00004C6C                 db    2
.rdata$r:00004C6D                 db    0
.rdata$r:00004C6E                 db    0
.rdata$r:00004C6F                 db    0
.rdata$r:00004C70                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00004C70 _rdata$r        ends
.rdata$r:00004C70
.rdata$r:00004C74 ; ===========================================================================
.rdata$r:00004C74
.rdata$r:00004C74 ; Segment type: Pure data
.rdata$r:00004C74 ; Segment permissions: Read
.rdata$r:00004C74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C74                 assume cs:_rdata$r
.rdata$r:00004C74                 ;org 4C74h
.rdata$r:00004C74 ; COMDAT (pick any)
.rdata$r:00004C74                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00004C74 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00004C74 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00004C74                                         ; DATA XREF: .rdata$r:00004C70o
.rdata$r:00004C74                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004C78                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004C7C                 db    0
.rdata$r:00004C7D                 align 10h
.rdata$r:00004C7D _rdata$r        ends
.rdata$r:00004C7D
.rdata$r:00004C80 ; ===========================================================================
.rdata$r:00004C80
.rdata$r:00004C80 ; Segment type: Pure data
.rdata$r:00004C80 ; Segment permissions: Read
.rdata$r:00004C80 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C80                 assume cs:_rdata$r
.rdata$r:00004C80                 ;org 4C80h
.rdata$r:00004C80 ; COMDAT (pick any)
.rdata$r:00004C80                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00004C80 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004C80 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00004C80                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00004C80                                         ; .rdata$r:00004CF0o ...
.rdata$r:00004C80                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004C84                 db    1
.rdata$r:00004C85                 db    0
.rdata$r:00004C86                 db    0
.rdata$r:00004C87                 db    0
.rdata$r:00004C88                 db    0
.rdata$r:00004C89                 db    0
.rdata$r:00004C8A                 db    0
.rdata$r:00004C8B                 db    0
.rdata$r:00004C8C                 db 0FFh
.rdata$r:00004C8D                 db 0FFh
.rdata$r:00004C8E                 db 0FFh
.rdata$r:00004C8F                 db 0FFh
.rdata$r:00004C90                 db    0
.rdata$r:00004C91                 db    0
.rdata$r:00004C92                 db    0
.rdata$r:00004C93                 db    0
.rdata$r:00004C94                 db  40h ; @
.rdata$r:00004C95                 db    0
.rdata$r:00004C96                 db    0
.rdata$r:00004C97                 db    0
.rdata$r:00004C98                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004C98 _rdata$r        ends
.rdata$r:00004C98
.rdata$r:00004C9C ; ===========================================================================
.rdata$r:00004C9C
.rdata$r:00004C9C ; Segment type: Pure data
.rdata$r:00004C9C ; Segment permissions: Read
.rdata$r:00004C9C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C9C                 assume cs:_rdata$r
.rdata$r:00004C9C                 ;org 4C9Ch
.rdata$r:00004C9C ; COMDAT (pick any)
.rdata$r:00004C9C                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00004C9C ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00004C9C ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00004C9C                                         ; DATA XREF: .rdata:000046B4o
.rdata$r:00004C9D                 db    0
.rdata$r:00004C9E                 db    0
.rdata$r:00004C9F                 db    0
.rdata$r:00004CA0                 db    0
.rdata$r:00004CA1                 db    0
.rdata$r:00004CA2                 db    0
.rdata$r:00004CA3                 db    0
.rdata$r:00004CA4                 db    0
.rdata$r:00004CA5                 db    0
.rdata$r:00004CA6                 db    0
.rdata$r:00004CA7                 db    0
.rdata$r:00004CA8                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004CAC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004CAC _rdata$r        ends
.rdata$r:00004CAC
.data$r:00004CB0 ; ===========================================================================
.data$r:00004CB0
.data$r:00004CB0 ; Segment type: Pure data
.data$r:00004CB0 ; Segment permissions: Read/Write
.data$r:00004CB0 _data$r         segment dword public 'DATA' use32
.data$r:00004CB0                 assume cs:_data$r
.data$r:00004CB0                 ;org 4CB0h
.data$r:00004CB0 ; COMDAT (pick any)
.data$r:00004CB0                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00004CB0 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00004CB0 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004CB0                                         ; DATA XREF: .rdata$r:00004CA8o
.data$r:00004CB0                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004CB0                                         ; const type_info::`vftable'
.data$r:00004CB4                 align 8
.data$r:00004CB8 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00004CDB                 align 4
.data$r:00004CDB _data$r         ends
.data$r:00004CDB
.rdata$r:00004CDC ; ===========================================================================
.rdata$r:00004CDC
.rdata$r:00004CDC ; Segment type: Pure data
.rdata$r:00004CDC ; Segment permissions: Read
.rdata$r:00004CDC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004CDC                 assume cs:_rdata$r
.rdata$r:00004CDC                 ;org 4CDCh
.rdata$r:00004CDC ; COMDAT (pick any)
.rdata$r:00004CDC                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00004CDC ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004CDC ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00004CDC                                         ; DATA XREF: .rdata$r:00004CACo
.rdata$r:00004CDC                                         ; .rdata$r:00004D14o
.rdata$r:00004CDD                 db    0
.rdata$r:00004CDE                 db    0
.rdata$r:00004CDF                 db    0
.rdata$r:00004CE0                 db    0
.rdata$r:00004CE1                 db    0
.rdata$r:00004CE2                 db    0
.rdata$r:00004CE3                 db    0
.rdata$r:00004CE4                 db    3
.rdata$r:00004CE5                 db    0
.rdata$r:00004CE6                 db    0
.rdata$r:00004CE7                 db    0
.rdata$r:00004CE8                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00004CE8 _rdata$r        ends
.rdata$r:00004CE8
.rdata$r:00004CEC ; ===========================================================================
.rdata$r:00004CEC
.rdata$r:00004CEC ; Segment type: Pure data
.rdata$r:00004CEC ; Segment permissions: Read
.rdata$r:00004CEC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004CEC                 assume cs:_rdata$r
.rdata$r:00004CEC                 ;org 4CECh
.rdata$r:00004CEC ; COMDAT (pick any)
.rdata$r:00004CEC                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00004CEC ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00004CEC ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004CEC                                         ; DATA XREF: .rdata$r:00004CE8o
.rdata$r:00004CEC                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004CF0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004CF4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004CF8                 db    0
.rdata$r:00004CF9                 align 4
.rdata$r:00004CF9 _rdata$r        ends
.rdata$r:00004CF9
.rdata$r:00004CFC ; ===========================================================================
.rdata$r:00004CFC
.rdata$r:00004CFC ; Segment type: Pure data
.rdata$r:00004CFC ; Segment permissions: Read
.rdata$r:00004CFC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004CFC                 assume cs:_rdata$r
.rdata$r:00004CFC                 ;org 4CFCh
.rdata$r:00004CFC ; COMDAT (pick any)
.rdata$r:00004CFC                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004CFC ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004CFC ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00004CFC                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00004CFC                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004D00                 db    2
.rdata$r:00004D01                 db    0
.rdata$r:00004D02                 db    0
.rdata$r:00004D03                 db    0
.rdata$r:00004D04                 db    0
.rdata$r:00004D05                 db    0
.rdata$r:00004D06                 db    0
.rdata$r:00004D07                 db    0
.rdata$r:00004D08                 db 0FFh
.rdata$r:00004D09                 db 0FFh
.rdata$r:00004D0A                 db 0FFh
.rdata$r:00004D0B                 db 0FFh
.rdata$r:00004D0C                 db    0
.rdata$r:00004D0D                 db    0
.rdata$r:00004D0E                 db    0
.rdata$r:00004D0F                 db    0
.rdata$r:00004D10                 db  40h ; @
.rdata$r:00004D11                 db    0
.rdata$r:00004D12                 db    0
.rdata$r:00004D13                 db    0
.rdata$r:00004D14                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004D14 _rdata$r        ends
.rdata$r:00004D14
.rdata$r:00004D18 ; ===========================================================================
.rdata$r:00004D18
.rdata$r:00004D18 ; Segment type: Pure data
.rdata$r:00004D18 ; Segment permissions: Read
.rdata$r:00004D18 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004D18                 assume cs:_rdata$r
.rdata$r:00004D18                 ;org 4D18h
.rdata$r:00004D18 ; COMDAT (pick any)
.rdata$r:00004D18                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00004D18 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00004D18 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:000046F4o
.rdata$r:00004D19                 db    0
.rdata$r:00004D1A                 db    0
.rdata$r:00004D1B                 db    0
.rdata$r:00004D1C                 db    0
.rdata$r:00004D1D                 db    0
.rdata$r:00004D1E                 db    0
.rdata$r:00004D1F                 db    0
.rdata$r:00004D20                 db    0
.rdata$r:00004D21                 db    0
.rdata$r:00004D22                 db    0
.rdata$r:00004D23                 db    0
.rdata$r:00004D24                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004D28                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004D28 _rdata$r        ends
.rdata$r:00004D28
.data$r:00004D2C ; ===========================================================================
.data$r:00004D2C
.data$r:00004D2C ; Segment type: Pure data
.data$r:00004D2C ; Segment permissions: Read/Write
.data$r:00004D2C _data$r         segment dword public 'DATA' use32
.data$r:00004D2C                 assume cs:_data$r
.data$r:00004D2C                 ;org 4D2Ch
.data$r:00004D2C ; COMDAT (pick any)
.data$r:00004D2C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00004D2C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00004D2C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004D2C                                         ; DATA XREF: .rdata$r:00004D24o
.data$r:00004D2C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004D2C                                         ; const type_info::`vftable'
.data$r:00004D30                 db    0
.data$r:00004D31                 db    0
.data$r:00004D32                 db    0
.data$r:00004D33                 db    0
.data$r:00004D34                 db  2Eh ; .
.data$r:00004D35                 db  3Fh ; ?
.data$r:00004D36                 db  41h ; A
.data$r:00004D37                 db  56h ; V
.data$r:00004D38                 db  5Fh ; _
.data$r:00004D39                 db  53h ; S
.data$r:00004D3A                 db  79h ; y
.data$r:00004D3B                 db  73h ; s
.data$r:00004D3C                 db  74h ; t
.data$r:00004D3D                 db  65h ; e
.data$r:00004D3E                 db  6Dh ; m
.data$r:00004D3F                 db  5Fh ; _
.data$r:00004D40                 db  65h ; e
.data$r:00004D41                 db  72h ; r
.data$r:00004D42                 db  72h ; r
.data$r:00004D43                 db  6Fh ; o
.data$r:00004D44                 db  72h ; r
.data$r:00004D45                 db  5Fh ; _
.data$r:00004D46                 db  63h ; c
.data$r:00004D47                 db  61h ; a
.data$r:00004D48                 db  74h ; t
.data$r:00004D49                 db  65h ; e
.data$r:00004D4A                 db  67h ; g
.data$r:00004D4B                 db  6Fh ; o
.data$r:00004D4C                 db  72h ; r
.data$r:00004D4D                 db  79h ; y
.data$r:00004D4E                 db  40h ; @
.data$r:00004D4F                 db  73h ; s
.data$r:00004D50                 db  74h ; t
.data$r:00004D51                 db  64h ; d
.data$r:00004D52                 db  40h ; @
.data$r:00004D53                 db  40h ; @
.data$r:00004D54                 db    0
.data$r:00004D55                 align 4
.data$r:00004D55 _data$r         ends
.data$r:00004D55
.rdata$r:00004D58 ; ===========================================================================
.rdata$r:00004D58
.rdata$r:00004D58 ; Segment type: Pure data
.rdata$r:00004D58 ; Segment permissions: Read
.rdata$r:00004D58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004D58                 assume cs:_rdata$r
.rdata$r:00004D58                 ;org 4D58h
.rdata$r:00004D58 ; COMDAT (pick any)
.rdata$r:00004D58                 public ??_R3_System_error_category@std@@8
.rdata$r:00004D58 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004D58 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00004D28o
.rdata$r:00004D58                                         ; .rdata$r:00004D90o
.rdata$r:00004D59                 db    0
.rdata$r:00004D5A                 db    0
.rdata$r:00004D5B                 db    0
.rdata$r:00004D5C                 db    0
.rdata$r:00004D5D                 db    0
.rdata$r:00004D5E                 db    0
.rdata$r:00004D5F                 db    0
.rdata$r:00004D60                 db    3
.rdata$r:00004D61                 db    0
.rdata$r:00004D62                 db    0
.rdata$r:00004D63                 db    0
.rdata$r:00004D64                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004D64 _rdata$r        ends
.rdata$r:00004D64
.rdata$r:00004D68 ; ===========================================================================
.rdata$r:00004D68
.rdata$r:00004D68 ; Segment type: Pure data
.rdata$r:00004D68 ; Segment permissions: Read
.rdata$r:00004D68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004D68                 assume cs:_rdata$r
.rdata$r:00004D68                 ;org 4D68h
.rdata$r:00004D68 ; COMDAT (pick any)
.rdata$r:00004D68                 public ??_R2_System_error_category@std@@8
.rdata$r:00004D68 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004D68 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004D68                                         ; DATA XREF: .rdata$r:00004D64o
.rdata$r:00004D68                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004D6C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004D70                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004D74                 db    0
.rdata$r:00004D75                 align 4
.rdata$r:00004D75 _rdata$r        ends
.rdata$r:00004D75
.rdata$r:00004D78 ; ===========================================================================
.rdata$r:00004D78
.rdata$r:00004D78 ; Segment type: Pure data
.rdata$r:00004D78 ; Segment permissions: Read
.rdata$r:00004D78 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004D78                 assume cs:_rdata$r
.rdata$r:00004D78                 ;org 4D78h
.rdata$r:00004D78 ; COMDAT (pick any)
.rdata$r:00004D78                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004D78 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004D78 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00004D78                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00004D78                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004D7C                 db    2
.rdata$r:00004D7D                 db    0
.rdata$r:00004D7E                 db    0
.rdata$r:00004D7F                 db    0
.rdata$r:00004D80                 db    0
.rdata$r:00004D81                 db    0
.rdata$r:00004D82                 db    0
.rdata$r:00004D83                 db    0
.rdata$r:00004D84                 db 0FFh
.rdata$r:00004D85                 db 0FFh
.rdata$r:00004D86                 db 0FFh
.rdata$r:00004D87                 db 0FFh
.rdata$r:00004D88                 db    0
.rdata$r:00004D89                 db    0
.rdata$r:00004D8A                 db    0
.rdata$r:00004D8B                 db    0
.rdata$r:00004D8C                 db  40h ; @
.rdata$r:00004D8D                 db    0
.rdata$r:00004D8E                 db    0
.rdata$r:00004D8F                 db    0
.rdata$r:00004D90                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004D90 _rdata$r        ends
.rdata$r:00004D90
.CRT$XCU:00004D94 ; ===========================================================================
.CRT$XCU:00004D94
.CRT$XCU:00004D94 ; Segment type: Pure data
.CRT$XCU:00004D94 ; Segment permissions: Read
.CRT$XCU:00004D94 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004D94                 assume cs:_CRT$XCU
.CRT$XCU:00004D94                 ;org 4D94h
.CRT$XCU:00004D94 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00004D98 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00004D98 _CRT$XCU        ends
.CRT$XCU:00004D98
.CRT$XCU:00004D9C ; ===========================================================================
.CRT$XCU:00004D9C
.CRT$XCU:00004D9C ; Segment type: Pure data
.CRT$XCU:00004D9C ; Segment permissions: Read
.CRT$XCU:00004D9C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004D9C                 assume cs:_CRT$XCU
.CRT$XCU:00004D9C                 ;org 4D9Ch
.CRT$XCU:00004D9C ; COMDAT (pick associative to section at 4718)
.CRT$XCU:00004D9C ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00004D9C ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00004D9C _CRT$XCU        ends
.CRT$XCU:00004D9C
.CRT$XCU:00004DA0 ; ===========================================================================
.CRT$XCU:00004DA0
.CRT$XCU:00004DA0 ; Segment type: Pure data
.CRT$XCU:00004DA0 ; Segment permissions: Read
.CRT$XCU:00004DA0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004DA0                 assume cs:_CRT$XCU
.CRT$XCU:00004DA0                 ;org 4DA0h
.CRT$XCU:00004DA0 ; COMDAT (pick associative to section at 471C)
.CRT$XCU:00004DA0 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00004DA0 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00004DA0 _CRT$XCU        ends
.CRT$XCU:00004DA0
.CRT$XCU:00004DA4 ; ===========================================================================
.CRT$XCU:00004DA4
.CRT$XCU:00004DA4 ; Segment type: Pure data
.CRT$XCU:00004DA4 ; Segment permissions: Read
.CRT$XCU:00004DA4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004DA4                 assume cs:_CRT$XCU
.CRT$XCU:00004DA4                 ;org 4DA4h
.CRT$XCU:00004DA4 ; COMDAT (pick associative to section at 4720)
.CRT$XCU:00004DA4 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00004DA4 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00004DA4 _CRT$XCU        ends
.CRT$XCU:00004DA4
.CRT$XCU:00004DA8 ; ===========================================================================
.CRT$XCU:00004DA8
.CRT$XCU:00004DA8 ; Segment type: Pure data
.CRT$XCU:00004DA8 ; Segment permissions: Read
.CRT$XCU:00004DA8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004DA8                 assume cs:_CRT$XCU
.CRT$XCU:00004DA8                 ;org 4DA8h
.CRT$XCU:00004DA8 ; COMDAT (pick associative to section at 4728)
.CRT$XCU:00004DA8 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00004DA8 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00004DA8 _CRT$XCU        ends
.CRT$XCU:00004DA8
.CRT$XCU:00004DAC ; ===========================================================================
.CRT$XCU:00004DAC
.CRT$XCU:00004DAC ; Segment type: Pure data
.CRT$XCU:00004DAC ; Segment permissions: Read
.CRT$XCU:00004DAC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004DAC                 assume cs:_CRT$XCU
.CRT$XCU:00004DAC                 ;org 4DACh
.CRT$XCU:00004DAC ; COMDAT (pick associative to section at 472C)
.CRT$XCU:00004DAC ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00004DAC ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00004DAC _CRT$XCU        ends
.CRT$XCU:00004DAC
.CRT$XCU:00004DB0 ; ===========================================================================
.CRT$XCU:00004DB0
.CRT$XCU:00004DB0 ; Segment type: Pure data
.CRT$XCU:00004DB0 ; Segment permissions: Read
.CRT$XCU:00004DB0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004DB0                 assume cs:_CRT$XCU
.CRT$XCU:00004DB0                 ;org 4DB0h
.CRT$XCU:00004DB0 ; COMDAT (pick associative to section at 47C0)
.CRT$XCU:00004DB0 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00004DB0 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00004DB0 _CRT$XCU        ends
.CRT$XCU:00004DB0
.CRT$XCU:00004DB4 ; ===========================================================================
.CRT$XCU:00004DB4
.CRT$XCU:00004DB4 ; Segment type: Pure data
.CRT$XCU:00004DB4 ; Segment permissions: Read
.CRT$XCU:00004DB4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004DB4                 assume cs:_CRT$XCU
.CRT$XCU:00004DB4                 ;org 4DB4h
.CRT$XCU:00004DB4 ; COMDAT (pick associative to section at 47C4)
.CRT$XCU:00004DB4 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00004DB4 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00004DB4 _CRT$XCU        ends
.CRT$XCU:00004DB4
UNDEF:00004DC0 ; ===========================================================================
UNDEF:00004DC0
UNDEF:00004DC0 ; Segment type: Externs
UNDEF:00004DC0 ; UNDEF
UNDEF:00004DC0                 extrn __purecall:near   ; DATA XREF: .rdata:0000466Co
UNDEF:00004DC0                                         ; .rdata:00004670o
UNDEF:00004DC4 ; void *__cdecl operator new(unsigned int)
UNDEF:00004DC4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00004DC4                                         ; std::_Allocate<HMENU__ *>(uint,HMENU__ * *)+23p ...
UNDEF:00004DC8 ; void __cdecl operator delete(void *)
UNDEF:00004DC8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00004DC8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00004DCC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00004DCC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00004DCC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00004DD0                 extrn __invalid_parameter:near
UNDEF:00004DD0                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+74p
UNDEF:00004DD0                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+74p
UNDEF:00004DD4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00004DD4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00004DD4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00004DD4                                         ; std::vector<HMENU__ *,std::allocator<HMENU__ *>>::_Orphan_range(HMENU__ * *,HMENU__ * *)+2Dp
UNDEF:00004DD8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00004DD8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00004DD8                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00004DD8                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j ...
UNDEF:00004DDC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00004DE0 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:00004DE0                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00004DE4 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00004DE4                 extrn _memmove:near     ; CODE XREF: std::_Uninit_move<HMENU__ *,HMENU__ *,HMENU__ *>(HMENU__ * *,HMENU__ * *,HMENU__ * *,std::_Wrap_alloc<std::allocator<HMENU__ *>> &,HMENU__ * *,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:00004DE4                                         ; std::char_traits<char>::move(char *,char const *,uint)+1Ep ...
UNDEF:00004DE8 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00004DE8                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00004DE8                                         ; _wmemcpy+11p
UNDEF:00004DEC ; size_t __cdecl strlen(const char *Str)
UNDEF:00004DEC                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00004DF0                 extrn __CrtDbgReportW:near
UNDEF:00004DF0                                         ; CODE XREF: std::vector<HMENU__ *,std::allocator<HMENU__ *>>::operator[](uint)+50p
UNDEF:00004DF0                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::operator[](uint)+50p
UNDEF:00004DF4 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00004DF4                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00004DF4                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00004DF4                                         ; std::_Debug_pointer<HMENU__ *>(HMENU__ * *,wchar_t const *,uint)+16p ...
UNDEF:00004DF8 ; void __cdecl std::_Xbad_alloc()
UNDEF:00004DF8                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00004DF8                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_632p
UNDEF:00004DF8                                         ; std::_Allocate<HMENU__ *>(uint,HMENU__ * *):loc_674p ...
UNDEF:00004DFC ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00004DFC                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00004DFC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00004DFC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:00004E00 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00004E00                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00004E00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00004E00                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00004E04 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E04                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E04                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00004E08 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00004E08                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00004E08                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00004E08                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00004E0C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00004E0C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00004E0C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00004E10 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E10                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E10                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00004E14 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E14                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E14                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00004E18 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E18                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E18                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00004E1C ; UINT __stdcall GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
UNDEF:00004E1C                 extrn __imp__GetMenuState@12:near
UNDEF:00004E1C                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+255p
UNDEF:00004E1C                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+282p
UNDEF:00004E1C                                         ; DATA XREF: ...
UNDEF:00004E20 ; HMENU __stdcall CreateMenu()
UNDEF:00004E20                 extrn __imp__CreateMenu@0:near
UNDEF:00004E20                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+FEp
UNDEF:00004E20                                         ; DATA XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+FEr
UNDEF:00004E24 ; HMENU __stdcall CreatePopupMenu()
UNDEF:00004E24                 extrn __imp__CreatePopupMenu@0:near
UNDEF:00004E24                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+33p
UNDEF:00004E24                                         ; DATA XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+33r
UNDEF:00004E28 ; BOOL __stdcall DestroyMenu(HMENU hMenu)
UNDEF:00004E28                 extrn __imp__DestroyMenu@4:near
UNDEF:00004E28                                         ; CODE XREF: ContextMenu::~ContextMenu(void)+78p
UNDEF:00004E28                                         ; ContextMenu::~ContextMenu(void)+87p
UNDEF:00004E28                                         ; DATA XREF: ...
UNDEF:00004E2C ; DWORD __stdcall CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
UNDEF:00004E2C                 extrn __imp__CheckMenuItem@12:near
UNDEF:00004E2C                                         ; CODE XREF: ContextMenu::checkItem(int,bool)+30p
UNDEF:00004E2C                                         ; DATA XREF: ContextMenu::checkItem(int,bool)+30r
UNDEF:00004E30 ; BOOL __stdcall EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
UNDEF:00004E30                 extrn __imp__EnableMenuItem@12:near
UNDEF:00004E30                                         ; CODE XREF: ContextMenu::enableItem(int,bool)+36p
UNDEF:00004E30                                         ; DATA XREF: ContextMenu::enableItem(int,bool)+36r
UNDEF:00004E34 ; BOOL __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
UNDEF:00004E34                 extrn __imp__InsertMenuW@20:near
UNDEF:00004E34                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+13Ap
UNDEF:00004E34                                         ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+18Dp ...
UNDEF:00004E38 ; __fastcall __security_check_cookie(x)
UNDEF:00004E38                 extrn @__security_check_cookie@4:near
UNDEF:00004E38                                         ; CODE XREF: ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)+2FDp
UNDEF:00004E38                                         ; __ehhandler$??0MenuItemUnit@@QAE@KPB_W0@Z+Cp ...
UNDEF:00004E3C ; __stdcall _CxxThrowException(x, x)
UNDEF:00004E3C                 extrn __CxxThrowException@8:near
UNDEF:00004E3C                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00004E3C                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+10p ...
UNDEF:00004E40                 extrn ___CxxFrameHandler3:near
UNDEF:00004E40                                         ; CODE XREF: __ehhandler$??0MenuItemUnit@@QAE@KPB_W0@Z+16j
UNDEF:00004E40                                         ; __ehhandler$??1ContextMenu@@QAE@XZ+16j ...
UNDEF:00004E44 ; const type_info::`vftable'
UNDEF:00004E44                 extrn ??_7type_info@@6B@:near
UNDEF:00004E44                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00004E44                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00004E48                 extrn ___security_cookie:near
UNDEF:00004E48                                         ; DATA XREF: MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)+12r
UNDEF:00004E48                                         ; ContextMenu::~ContextMenu(void)+14r ...
UNDEF:00004E4C                 extrn __fltused:near
UNDEF:00004E4C
UNDEF:00004E4C
UNDEF:00004E4C                 end