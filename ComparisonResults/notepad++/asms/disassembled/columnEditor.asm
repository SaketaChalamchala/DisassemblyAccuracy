.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : D3998537F75BC3443D57AC2E42EADD97
.rdata:00000000 ; Input CRC32 : 0E2F9B93
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\columnEditor.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; char _SG168125[]
.rdata:00000000 $SG168125       db 'StaticDialog::init : ppEditView is null.',0
.rdata:00000000                                         ; DATA XREF: ColumnEditorDlg::init(HINSTANCE__ *,HWND__ *,ScintillaEditView * *)+1Fo
.rdata:00000029                 align 10h
.rdata:00000030 ; wchar_t _SG169245
.rdata:00000030 $SG169245:                              ; DATA XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+9FCo
.rdata:00000030                 unicode 0, <..\src\ScitillaComponent\columnEditor.cpp>,0
.rdata:00000084 ; wchar_t _SG169246
.rdata:00000084 $SG169246:                              ; DATA XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+A01o
.rdata:00000084                 unicode 0, <numbers.size() >
.rdata:00000084                 dw 3Eh
.rdata:00000084                 unicode 0, < 0>,0
.rdata:000000AA                 align 4
.rdata:000000AC $SG160408       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:000000B7                 align 4
.rdata:000000B8 $SG160409       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000AE4o
.rdata:000000C4 $SG160410       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000AE8o
.rdata:000000D0 $SG160411       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:00000AECo
.rdata:000000DC $SG160412       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000AF0o
.rdata:000000E8 $SG160413       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000AF4o
.rdata:000000F4 $SG160414       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000AF8o
.rdata:00000100 $SG160415       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:00000AFCo
.rdata:0000010C $SG160416       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000B00o
.rdata:00000118 $SG160417       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000B04o
.rdata:00000124 $SG160418       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000B08o
.rdata:00000130 $SG160419       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:00000B0Co
.rdata:0000013C $SG160420       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000B10o
.rdata:00000148 $SG160421       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000B14o
.rdata:00000154 $SG160422       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000B18o
.rdata:00000160 $SG160423       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:00000B1Co
.rdata:0000016C $SG160424       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000B20o
.rdata:00000178 $SG160425       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000B24o
.rdata:00000184 $SG160426       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000B28o
.rdata:00000190 $SG160427       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:00000B2Co
.rdata:0000019C $SG160428       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000B30o
.rdata:000001A8 $SG160429       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000B34o
.rdata:000001B4 $SG160430       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000B38o
.rdata:000001C0 $SG160431       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:00000B3Co
.rdata:000001CC $SG160432       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000B40o
.rdata:000001D8 $SG160433       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000B44o
.rdata:000001E4 $SG160434       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000B48o
.rdata:000001F0 $SG160435       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:00000B4Co
.rdata:000001FC $SG160436       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000B50o
.rdata:00000208 $SG160437       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000B54o
.rdata:00000214 $SG160438       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000B58o
.rdata:00000220 $SG160439       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:00000B5Co
.rdata:0000022C $SG160440       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000B60o
.rdata:00000238 $SG160441       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000B64o
.rdata:00000244 $SG160442       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000B68o
.rdata:00000250 $SG160443       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:00000B6Co
.rdata:0000025C $SG160444       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000B70o
.rdata:00000268 $SG160445       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000B74o
.rdata:00000274 $SG160446       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000B78o
.rdata:00000280 $SG160447       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:00000B7Co
.rdata:0000028C $SG160448       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:00000B80o
.rdata:00000298 $SG160449       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:00000B84o
.rdata:000002A4 $SG160450       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:00000B88o
.rdata:000002B0 $SG160451       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:00000B8Co
.rdata:000002BC $SG160452       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:00000B90o
.rdata:000002C8 $SG160453       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:00000B94o
.rdata:000002D4 $SG160454       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:00000B98o
.rdata:000002E0 $SG160455       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:00000B9Co
.rdata:000002EC $SG160456       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:00000BA0o
.rdata:000002F8 $SG160457       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:00000BA4o
.rdata:00000304 $SG160458       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:00000BA8o
.rdata:00000310 $SG160459       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:00000BACo
.rdata:0000031C $SG160460       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:00000BB0o
.rdata:00000328 $SG160461       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:00000BB4o
.rdata:00000334 $SG160462       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:00000BB8o
.rdata:00000340 $SG160463       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:00000BBCo
.rdata:0000034C $SG160464       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:00000BC0o
.rdata:00000358 $SG160465       db '    .+      ',0     ; DATA XREF: .data:00000BC4o
.rdata:00000365                 align 4
.rdata:00000368 $SG160466       db '    @#$     ',0     ; DATA XREF: .data:00000BC8o
.rdata:00000375                 align 4
.rdata:00000378 $SG160467       db '    %&*=    ',0     ; DATA XREF: .data:00000BCCo
.rdata:00000385                 align 4
.rdata:00000388 $SG160468       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:00000BD0o
.rdata:00000395                 align 4
.rdata:00000398 $SG160469       db '    )!~{]^  ',0     ; DATA XREF: .data:00000BD4o
.rdata:000003A5                 align 4
.rdata:000003A8 $SG160470       db '    /(_:<[} ',0     ; DATA XREF: .data:00000BD8o
.rdata:000003B5                 align 4
.rdata:000003B8 $SG160471       db '    |123456 ',0     ; DATA XREF: .data:00000BDCo
.rdata:000003C5                 align 4
.rdata:000003C8 $SG160472       db '    7890abc ',0     ; DATA XREF: .data:00000BE0o
.rdata:000003D5                 align 4
.rdata:000003D8 $SG160473       db '    defgh   ',0     ; DATA XREF: .data:00000BE4o
.rdata:000003E5                 align 4
.rdata:000003E8 $SG160474       db '    ijkl    ',0     ; DATA XREF: .data:00000BE8o
.rdata:000003F5                 align 4
.rdata:000003F8 $SG160475       db '    mno     ',0     ; DATA XREF: .data:00000BECo
.rdata:00000405                 align 4
.rdata:00000408 $SG160476       db '    pq      ',0     ; DATA XREF: .data:00000BF0o
.rdata:00000415                 align 4
.rdata:00000418 $SG160478       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:00000423                 align 4
.rdata:00000424 $SG160479       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000BFCo
.rdata:00000430 $SG160480       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000C00o
.rdata:0000043C $SG160481       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000C04o
.rdata:00000448 $SG160482       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000C08o
.rdata:00000454 $SG160483       db '#',9,'c #6397E1',0  ; DATA XREF: .data:00000C0Co
.rdata:00000460 $SG160484       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000C10o
.rdata:0000046C $SG160485       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000C14o
.rdata:00000478 $SG160486       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000C18o
.rdata:00000484 $SG160487       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:00000C1Co
.rdata:00000490 $SG160488       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000C20o
.rdata:0000049C $SG160489       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000C24o
.rdata:000004A8 $SG160490       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000C28o
.rdata:000004B4 $SG160491       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:00000C2Co
.rdata:000004C0 $SG160492       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000C30o
.rdata:000004CC $SG160493       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000C34o
.rdata:000004D8 $SG160494       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000C38o
.rdata:000004E4 $SG160495       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:00000C3Co
.rdata:000004F0 $SG160496       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000C40o
.rdata:000004FC $SG160497       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000C44o
.rdata:00000508 $SG160498       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000C48o
.rdata:00000514 $SG160499       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:00000C4Co
.rdata:00000520 $SG160500       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000C50o
.rdata:0000052C $SG160501       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000C54o
.rdata:00000538 $SG160502       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000C58o
.rdata:00000544 $SG160503       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:00000C5Co
.rdata:00000550 $SG160504       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000C60o
.rdata:0000055C $SG160505       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000C64o
.rdata:00000568 $SG160506       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000C68o
.rdata:00000574 $SG160507       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:00000C6Co
.rdata:00000580 $SG160508       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000C70o
.rdata:0000058C $SG160509       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000C74o
.rdata:00000598 $SG160510       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000C78o
.rdata:000005A4 $SG160511       db '4',9,'c #195CC6',0  ; DATA XREF: .data:00000C7Co
.rdata:000005B0 $SG160512       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:00000C80o
.rdata:000005BC $SG160513       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:00000C84o
.rdata:000005C8 $SG160514       db '7',9,'c #4885D6',0  ; DATA XREF: .data:00000C88o
.rdata:000005D4 $SG160515       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:00000C8Co
.rdata:000005E0 $SG160516       db '9',9,'c #6698DB',0  ; DATA XREF: .data:00000C90o
.rdata:000005EC $SG160517       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:00000C94o
.rdata:000005F8 $SG160518       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:00000C98o
.rdata:00000604 $SG160519       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:00000C9Co
.rdata:00000610 $SG160520       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:00000CA0o
.rdata:0000061C $SG160521       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:00000CA4o
.rdata:00000628 $SG160522       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:00000CA8o
.rdata:00000634 $SG160523       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:00000CACo
.rdata:00000640 $SG160524       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:00000CB0o
.rdata:0000064C $SG160525       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:00000CB4o
.rdata:00000658 $SG160526       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:00000CB8o
.rdata:00000664 $SG160527       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:00000CBCo
.rdata:00000670 $SG160528       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:00000CC0o
.rdata:0000067C $SG160529       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:00000CC4o
.rdata:00000688 $SG160530       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:00000CC8o
.rdata:00000694 $SG160531       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:00000CCCo
.rdata:000006A0 $SG160532       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:00000CD0o
.rdata:000006AC $SG160533       db '         .+ ',0     ; DATA XREF: .data:00000CD4o
.rdata:000006B9                 align 4
.rdata:000006BC $SG160534       db '        @#$ ',0     ; DATA XREF: .data:00000CD8o
.rdata:000006C9                 align 4
.rdata:000006CC $SG160535       db '       %&*= L',0    ; DATA XREF: .data:00000CDCo
.rdata:000006DA                 align 4
.rdata:000006DC $SG160536       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000CE0o
.rdata:000006E9                 align 4
.rdata:000006EC $SG160537       db '     )!>~{] ',0     ; DATA XREF: .data:00000CE4o
.rdata:000006F9                 align 4
.rdata:000006FC $SG160538       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000CE8o
.rdata:00000709                 align 4
.rdata:0000070C $SG160539       db '    (}|1234 ',0     ; DATA XREF: .data:00000CECo
.rdata:00000719                 align 4
.rdata:0000071C $SG160540       db '    567890a ',0     ; DATA XREF: .data:00000CF0o
.rdata:00000729                 align 4
.rdata:0000072C $SG160541       db '      bcdef ',0     ; DATA XREF: .data:00000CF4o
.rdata:00000739                 align 4
.rdata:0000073C $SG160542       db '       ghij ',0     ; DATA XREF: .data:00000CF8o
.rdata:00000749                 align 4
.rdata:0000074C $SG160543       db '        klm ',0     ; DATA XREF: .data:00000CFCo
.rdata:00000759                 align 4
.rdata:0000075C $SG160544       db '         no ',0     ; DATA XREF: .data:00000D00o
.rdata:00000769                 align 4
.rdata:0000076C $SG160546       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000777                 align 4
.rdata:00000778 $SG160547       db ' ',9,'c None',0     ; DATA XREF: .data:00000D0Co
.rdata:00000781                 align 4
.rdata:00000784 $SG160548       db '.',9,'c #545254',0  ; DATA XREF: .data:00000D10o
.rdata:00000790 $SG160549       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000D14o
.rdata:0000079C $SG160550       db '@',9,'c #646464',0  ; DATA XREF: .data:00000D18o
.rdata:000007A8 $SG160551       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:00000D1Co
.rdata:000007B4 $SG160552       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000D20o
.rdata:000007C0 $SG160553       db '%',9,'c #747284',0  ; DATA XREF: .data:00000D24o
.rdata:000007CC $SG160554       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000D28o
.rdata:000007D8 $SG160555       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:00000D2Co
.rdata:000007E4 $SG160556       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000D30o
.rdata:000007F0 $SG160557       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000D34o
.rdata:000007FC $SG160558       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000D38o
.rdata:00000808 $SG160559       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:00000D3Co
.rdata:00000814 $SG160560       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000D40o
.rdata:00000820 $SG160561       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000D44o
.rdata:0000082C $SG160562       db ')',9,'c #282668',0  ; DATA XREF: .data:00000D48o
.rdata:00000838 $SG160563       db '!',9,'c #24367C',0  ; DATA XREF: .data:00000D4Co
.rdata:00000844 $SG160564       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000D50o
.rdata:00000850 $SG160565       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000D54o
.rdata:0000085C $SG160566       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000D58o
.rdata:00000868 $SG160567       db '^',9,'c #142E7C',0  ; DATA XREF: .data:00000D5Co
.rdata:00000874 $SG160568       db '/',9,'c #143789',0  ; DATA XREF: .data:00000D60o
.rdata:00000880 $SG160569       db '(',9,'c #204990',0  ; DATA XREF: .data:00000D64o
.rdata:0000088C $SG160570       db '_',9,'c #174091',0  ; DATA XREF: .data:00000D68o
.rdata:00000898 $SG160571       db ':',9,'c #0C0630',0  ; DATA XREF: .data:00000D6Co
.rdata:000008A4 $SG160572       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000D70o
.rdata:000008B0 $SG160573       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000D74o
.rdata:000008BC $SG160574       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000D78o
.rdata:000008C8 $SG160575       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:00000D7Co
.rdata:000008D4 $SG160576       db '1',9,'c #141244',0  ; DATA XREF: .data:00000D80o
.rdata:000008E0 $SG160577       db '2',9,'c #24428C',0  ; DATA XREF: .data:00000D84o
.rdata:000008EC $SG160578       db '3',9,'c #3462B9',0  ; DATA XREF: .data:00000D88o
.rdata:000008F8 $SG160579       db '4',9,'c #4470C4',0  ; DATA XREF: .data:00000D8Co
.rdata:00000904 $SG160580       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:00000D90o
.rdata:00000910 $SG160581       db '6',9,'c #4472CC',0  ; DATA XREF: .data:00000D94o
.rdata:0000091C $SG160582       db '7',9,'c #24224C',0  ; DATA XREF: .data:00000D98o
.rdata:00000928 $SG160583       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:00000D9Co
.rdata:00000934 $SG160584       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:00000DA0o
.rdata:00000940 $SG160585       db '0',9,'c #5482DF',0  ; DATA XREF: .data:00000DA4o
.rdata:0000094C $SG160586       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:00000DA8o
.rdata:00000958 $SG160587       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:00000DACo
.rdata:00000964 $SG160588       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:00000DB0o
.rdata:00000970 $SG160589       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:00000DB4o
.rdata:0000097C $SG160590       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:00000DB8o
.rdata:00000988 $SG160591       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:00000DBCo
.rdata:00000994 $SG160592       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:00000DC0o
.rdata:000009A0 $SG160593       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:00000DC4o
.rdata:000009AC $SG160594       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:00000DC8o
.rdata:000009B8 $SG160595       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:00000DCCo
.rdata:000009C4 $SG160596       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:00000DD0o
.rdata:000009D0 $SG160597       db 'l',9,'c #243250',0  ; DATA XREF: .data:00000DD4o
.rdata:000009DC $SG160598       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:00000DD8o
.rdata:000009E8 $SG160599       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:00000DDCo
.rdata:000009F4 $SG160600       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000DE0o
.rdata:00000A00 $SG160601       db '     .+.     ',0    ; DATA XREF: .data:00000DE4o
.rdata:00000A0E                 align 10h
.rdata:00000A10 $SG160602       db '   @##$##@   ',0    ; DATA XREF: .data:00000DE8o
.rdata:00000A1E                 align 10h
.rdata:00000A20 $SG160603       db '  @%&***&%@  ',0    ; DATA XREF: .data:00000DECo
.rdata:00000A2E                 align 10h
.rdata:00000A30 $SG160604       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000DF0o
.rdata:00000A3E                 align 10h
.rdata:00000A40 $SG160605       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000A40                                         ; DATA XREF: .data:00000DF4o
.rdata:00000A4E                 align 10h
.rdata:00000A50 $SG160606       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000DF8o
.rdata:00000A5E                 align 10h
.rdata:00000A60 $SG160607       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:00000DFCo
.rdata:00000A6E                 align 10h
.rdata:00000A70 $SG160608       db '12[3455563[21',0    ; DATA XREF: .data:00000E00o
.rdata:00000A7E                 align 10h
.rdata:00000A80 $SG160609       db '7_365899063_7',0    ; DATA XREF: .data:00000E04o
.rdata:00000A8E                 align 10h
.rdata:00000A90 $SG160610       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000E08o
.rdata:00000A9E                 align 10h
.rdata:00000AA0 $SG160611       db ' d}8efgfb83d ',0    ; DATA XREF: .data:00000E0Co
.rdata:00000AAE                 align 10h
.rdata:00000AB0 $SG160612       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000E10o
.rdata:00000ABE                 align 10h
.rdata:00000AC0 $SG160613       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000E14o
.rdata:00000ACE                 align 10h
.rdata:00000AD0 $SG160614       db '     o@o     ',0    ; DATA XREF: .data:00000E18o
.rdata:00000ADE                 align 10h
.rdata:00000ADE _rdata          ends
.rdata:00000ADE
.data:00000AE0 ; ===========================================================================
.data:00000AE0
.data:00000AE0 ; Segment type: Pure data
.data:00000AE0 ; Segment permissions: Read/Write
.data:00000AE0 ; Segment alignment 'qword' can not be represented in assembly
.data:00000AE0 _data           segment para public 'DATA' use32
.data:00000AE0                 assume cs:_data
.data:00000AE0                 ;org 0AE0h
.data:00000AE0 _acTop_xpm      dd offset $SG160408     ; "12 12 56 1"
.data:00000AE4                 dd offset $SG160409     ; " \tc #FFFFFF"
.data:00000AE8                 dd offset $SG160410     ; ".\tc #8AB2E9"
.data:00000AEC                 dd offset $SG160411     ; "+\tc #CCDCF6"
.data:00000AF0                 dd offset $SG160412     ; "@\tc #80ABEA"
.data:00000AF4                 dd offset $SG160413     ; "#\tc #7DA9E8"
.data:00000AF8                 dd offset $SG160414     ; "$\tc #C7DAF3"
.data:00000AFC                 dd offset $SG160415     ; "%\tc #79A7E6"
.data:00000B00                 dd offset $SG160416     ; "&\tc #ADC8EF"
.data:00000B04                 dd offset $SG160417     ; "*\tc #87B0E8"
.data:00000B08                 dd offset $SG160418     ; "=\tc #BBD2F0"
.data:00000B0C                 dd offset $SG160419     ; "-\tc #6EA0E2"
.data:00000B10                 dd offset $SG160420     ; ";\tc #A8C7EE"
.data:00000B14                 dd offset $SG160421     ; ">\tc #A3C2ED"
.data:00000B18                 dd offset $SG160422     ; ",\tc #75A4E3"
.data:00000B1C                 dd offset $SG160423     ; "'\tc #A7C4EB"
.data:00000B20                 dd offset $SG160424     ; ")\tc #6297E1"
.data:00000B24                 dd offset $SG160425     ; "!\tc #A1C1EC"
.data:00000B28                 dd offset $SG160426     ; "~\tc #92B7E8"
.data:00000B2C                 dd offset $SG160427     ; "{\tc #99BBE9"
.data:00000B30                 dd offset $SG160428     ; "]\tc #6197DD"
.data:00000B34                 dd offset $SG160429     ; "^\tc #96B9E6"
.data:00000B38                 dd offset $SG160430     ; "/\tc #538EDB"
.data:00000B3C                 dd offset $SG160431     ; "(\tc #99BBEA"
.data:00000B40                 dd offset $SG160432     ; "_\tc #80AAE3"
.data:00000B44                 dd offset $SG160433     ; ":\tc #81ABE3"
.data:00000B48                 dd offset $SG160434     ; "<\tc #8AB1E4"
.data:00000B4C                 dd offset $SG160435     ; "[\tc #4B88D6"
.data:00000B50                 dd offset $SG160436     ; "}\tc #4882D1"
.data:00000B54                 dd offset $SG160437     ; "|\tc #4384D6"
.data:00000B58                 dd offset $SG160438     ; "1\tc #90B5E7"
.data:00000B5C                 dd offset $SG160439     ; "2\tc #74A3E0"
.data:00000B60                 dd offset $SG160440     ; "3\tc #77A4E0"
.data:00000B64                 dd offset $SG160441     ; "4\tc #81ABE2"
.data:00000B68                 dd offset $SG160442     ; "5\tc #437FD3"
.data:00000B6C                 dd offset $SG160443     ; "6\tc #7FA2DF"
.data:00000B70                 dd offset $SG160444     ; "7\tc #3577D2"
.data:00000B74                 dd offset $SG160445     ; "8\tc #87AFE4"
.data:00000B78                 dd offset $SG160446     ; "9\tc #72A1DF"
.data:00000B7C                 dd offset $SG160447     ; "0\tc #7CA9E1"
.data:00000B80                 dd offset $SG160448     ; "a\tc #3F7AD0"
.data:00000B84                 dd offset $SG160449     ; "b\tc #85A4DE"
.data:00000B88                 dd offset $SG160450     ; "c\tc #FBFCFE"
.data:00000B8C                 dd offset $SG160451     ; "d\tc #236ECD"
.data:00000B90                 dd offset $SG160452     ; "e\tc #7EA8E1"
.data:00000B94                 dd offset $SG160453     ; "f\tc #79A6E0"
.data:00000B98                 dd offset $SG160454     ; "g\tc #3D77D0"
.data:00000B9C                 dd offset $SG160455     ; "h\tc #87A4DC"
.data:00000BA0                 dd offset $SG160456     ; "i\tc #1A62C9"
.data:00000BA4                 dd offset $SG160457     ; "j\tc #75A3DF"
.data:00000BA8                 dd offset $SG160458     ; "k\tc #3C74CF"
.data:00000BAC                 dd offset $SG160459     ; "l\tc #8DA6DE"
.data:00000BB0                 dd offset $SG160460     ; "m\tc #1859C4"
.data:00000BB4                 dd offset $SG160461     ; "n\tc #3B71CC"
.data:00000BB8                 dd offset $SG160462     ; "o\tc #8EA5DD"
.data:00000BBC                 dd offset $SG160463     ; "p\tc #164EC0"
.data:00000BC0                 dd offset $SG160464     ; "q\tc #92A7DD"
.data:00000BC4                 dd offset $SG160465     ; "    .+      "
.data:00000BC8                 dd offset $SG160466     ; "    @#$     "
.data:00000BCC                 dd offset $SG160467     ; "    %&*=    "
.data:00000BD0                 dd offset $SG160468     ; "    -;>,'   "
.data:00000BD4                 dd offset $SG160469     ; "    )!~{]^  "
.data:00000BD8                 dd offset $SG160470     ; "    /(_:<[} "
.data:00000BDC                 dd offset $SG160471     ; "    |123456 "
.data:00000BE0                 dd offset $SG160472     ; "    7890abc "
.data:00000BE4                 dd offset $SG160473     ; "    defgh   "
.data:00000BE8                 dd offset $SG160474     ; "    ijkl    "
.data:00000BEC                 dd offset $SG160475     ; "    mno     "
.data:00000BF0                 dd offset $SG160476     ; "    pq      "
.data:00000BF4                 align 8
.data:00000BF8 _acBottom_xpm   dd offset $SG160478     ; "12 12 54 1"
.data:00000BFC                 dd offset $SG160479     ; " \tc #FFFFFF"
.data:00000C00                 dd offset $SG160480     ; ".\tc #C4D7F3"
.data:00000C04                 dd offset $SG160481     ; "+\tc #72A1E3"
.data:00000C08                 dd offset $SG160482     ; "@\tc #C1D6F2"
.data:00000C0C                 dd offset $SG160483     ; "#\tc #6397E1"
.data:00000C10                 dd offset $SG160484     ; "$\tc #5990DD"
.data:00000C14                 dd offset $SG160485     ; "%\tc #BBD2F0"
.data:00000C18                 dd offset $SG160486     ; "&\tc #7AA6E5"
.data:00000C1C                 dd offset $SG160487     ; "*\tc #9ABDEA"
.data:00000C20                 dd offset $SG160488     ; "=\tc #4A87D9"
.data:00000C24                 dd offset $SG160489     ; "-\tc #B1CAEE"
.data:00000C28                 dd offset $SG160490     ; ";\tc #75A4E3"
.data:00000C2C                 dd offset $SG160491     ; ">\tc #99BBE9"
.data:00000C30                 dd offset $SG160492     ; ",\tc #95B9E8"
.data:00000C34                 dd offset $SG160493     ; "'\tc #3A7CD4"
.data:00000C38                 dd offset $SG160494     ; ")\tc #A9C6EC"
.data:00000C3C                 dd offset $SG160495     ; "!\tc #71A0E0"
.data:00000C40                 dd offset $SG160496     ; "~\tc #86AFE5"
.data:00000C44                 dd offset $SG160497     ; "{\tc #8DB2E6"
.data:00000C48                 dd offset $SG160498     ; "]\tc #2A72CF"
.data:00000C4C                 dd offset $SG160499     ; "^\tc #73A0E0"
.data:00000C50                 dd offset $SG160500     ; "/\tc #6B9DE0"
.data:00000C54                 dd offset $SG160501     ; "(\tc #95B8E8"
.data:00000C58                 dd offset $SG160502     ; "_\tc #81ABE3"
.data:00000C5C                 dd offset $SG160503     ; ":\tc #72A1DF"
.data:00000C60                 dd offset $SG160504     ; "<\tc #83ADE3"
.data:00000C64                 dd offset $SG160505     ; "[\tc #1B65C9"
.data:00000C68                 dd offset $SG160506     ; "}\tc #5F95DC"
.data:00000C6C                 dd offset $SG160507     ; "|\tc #8BB3E5"
.data:00000C70                 dd offset $SG160508     ; "1\tc #77A4E0"
.data:00000C74                 dd offset $SG160509     ; "2\tc #679ADC"
.data:00000C78                 dd offset $SG160510     ; "3\tc #7AA6E1"
.data:00000C7C                 dd offset $SG160511     ; "4\tc #195CC6"
.data:00000C80                 dd offset $SG160512     ; "5\tc #FCFDFE"
.data:00000C84                 dd offset $SG160513     ; "6\tc #8DB2E4"
.data:00000C88                 dd offset $SG160514     ; "7\tc #4885D6"
.data:00000C8C                 dd offset $SG160515     ; "8\tc #7CA9E1"
.data:00000C90                 dd offset $SG160516     ; "9\tc #6698DB"
.data:00000C94                 dd offset $SG160517     ; "0\tc #71A1DE"
.data:00000C98                 dd offset $SG160518     ; "a\tc #1752C0"
.data:00000C9C                 dd offset $SG160519     ; "b\tc #88ABE0"
.data:00000CA0                 dd offset $SG160520     ; "c\tc #3D77D0"
.data:00000CA4                 dd offset $SG160521     ; "d\tc #6E9FDD"
.data:00000CA8                 dd offset $SG160522     ; "e\tc #699BDC"
.data:00000CAC                 dd offset $SG160523     ; "f\tc #1547BD"
.data:00000CB0                 dd offset $SG160524     ; "g\tc #8DA6DE"
.data:00000CB4                 dd offset $SG160525     ; "h\tc #376BC9"
.data:00000CB8                 dd offset $SG160526     ; "i\tc #6295DA"
.data:00000CBC                 dd offset $SG160527     ; "j\tc #1440B9"
.data:00000CC0                 dd offset $SG160528     ; "k\tc #8DA0DB"
.data:00000CC4                 dd offset $SG160529     ; "l\tc #315FC4"
.data:00000CC8                 dd offset $SG160530     ; "m\tc #1339B7"
.data:00000CCC                 dd offset $SG160531     ; "n\tc #909FDA"
.data:00000CD0                 dd offset $SG160532     ; "o\tc #1233B4"
.data:00000CD4                 dd offset $SG160533     ; "         .+ "
.data:00000CD8                 dd offset $SG160534     ; "        @#$ "
.data:00000CDC                 dd offset $SG160535     ; "       %&*= L"
.data:00000CE0                 dd offset $SG160536     ; "      -;>,' "
.data:00000CE4                 dd offset $SG160537     ; "     )!>~{] "
.data:00000CE8                 dd offset $SG160538     ; "    ^/(_:<[ "
.data:00000CEC                 dd offset $SG160539     ; "    (}|1234 "
.data:00000CF0                 dd offset $SG160540     ; "    567890a "
.data:00000CF4                 dd offset $SG160541     ; "      bcdef "
.data:00000CF8                 dd offset $SG160542     ; "       ghij "
.data:00000CFC                 dd offset $SG160543     ; "        klm "
.data:00000D00                 dd offset $SG160544     ; "         no "
.data:00000D04                 align 8
.data:00000D08 _bookmark_xpm   dd offset $SG160546     ; "13 14 54 1"
.data:00000D0C                 dd offset $SG160547     ; " \tc None"
.data:00000D10                 dd offset $SG160548     ; ".\tc #545254"
.data:00000D14                 dd offset $SG160549     ; "+\tc #3C3E3C"
.data:00000D18                 dd offset $SG160550     ; "@\tc #646464"
.data:00000D1C                 dd offset $SG160551     ; "#\tc #A4A4A4"
.data:00000D20                 dd offset $SG160552     ; "$\tc #B7B8B7"
.data:00000D24                 dd offset $SG160553     ; "%\tc #747284"
.data:00000D28                 dd offset $SG160554     ; "&\tc #B4B2C4"
.data:00000D2C                 dd offset $SG160555     ; "*\tc #DCD7E4"
.data:00000D30                 dd offset $SG160556     ; "=\tc #1C1A1C"
.data:00000D34                 dd offset $SG160557     ; "-\tc #403E58"
.data:00000D38                 dd offset $SG160558     ; ";\tc #5C5A8C"
.data:00000D3C                 dd offset $SG160559     ; ">\tc #7C7EAC"
.data:00000D40                 dd offset $SG160560     ; ",\tc #7C8EBC"
.data:00000D44                 dd offset $SG160561     ; "'\tc #242644"
.data:00000D48                 dd offset $SG160562     ; ")\tc #282668"
.data:00000D4C                 dd offset $SG160563     ; "!\tc #24367C"
.data:00000D50                 dd offset $SG160564     ; "~\tc #244A84"
.data:00000D54                 dd offset $SG160565     ; "{\tc #2C5098"
.data:00000D58                 dd offset $SG160566     ; "]\tc #14162C"
.data:00000D5C                 dd offset $SG160567     ; "^\tc #142E7C"
.data:00000D60                 dd offset $SG160568     ; "/\tc #143789"
.data:00000D64                 dd offset $SG160569     ; "(\tc #204990"
.data:00000D68                 dd offset $SG160570     ; "_\tc #174091"
.data:00000D6C                 dd offset $SG160571     ; ":\tc #0C0630"
.data:00000D70                 dd offset $SG160572     ; "<\tc #24327C"
.data:00000D74                 dd offset $SG160573     ; "[\tc #2450A0"
.data:00000D78                 dd offset $SG160574     ; "}\tc #345DB4"
.data:00000D7C                 dd offset $SG160575     ; "|\tc #3C68B8"
.data:00000D80                 dd offset $SG160576     ; "1\tc #141244"
.data:00000D84                 dd offset $SG160577     ; "2\tc #24428C"
.data:00000D88                 dd offset $SG160578     ; "3\tc #3462B9"
.data:00000D8C                 dd offset $SG160579     ; "4\tc #4470C4"
.data:00000D90                 dd offset $SG160580     ; "5\tc #4C7FD6"
.data:00000D94                 dd offset $SG160581     ; "6\tc #4472CC"
.data:00000D98                 dd offset $SG160582     ; "7\tc #24224C"
.data:00000D9C                 dd offset $SG160583     ; "8\tc #5C8DEC"
.data:00000DA0                 dd offset $SG160584     ; "9\tc #5C94F6"
.data:00000DA4                 dd offset $SG160585     ; "0\tc #5482DF"
.data:00000DA8                 dd offset $SG160586     ; "a\tc #619DF7"
.data:00000DAC                 dd offset $SG160587     ; "b\tc #6CA6FC"
.data:00000DB0                 dd offset $SG160588     ; "c\tc #64A2FC"
.data:00000DB4                 dd offset $SG160589     ; "d\tc #1C2E5C"
.data:00000DB8                 dd offset $SG160590     ; "e\tc #6CA2FC"
.data:00000DBC                 dd offset $SG160591     ; "f\tc #74B2FC"
.data:00000DC0                 dd offset $SG160592     ; "g\tc #7CB8FC"
.data:00000DC4                 dd offset $SG160593     ; "h\tc #1C3264"
.data:00000DC8                 dd offset $SG160594     ; "i\tc #346AD4"
.data:00000DCC                 dd offset $SG160595     ; "j\tc #7CBEFC"
.data:00000DD0                 dd offset $SG160596     ; "k\tc #3C72DC"
.data:00000DD4                 dd offset $SG160597     ; "l\tc #243250"
.data:00000DD8                 dd offset $SG160598     ; "m\tc #346AB4"
.data:00000DDC                 dd offset $SG160599     ; "n\tc #3C82DC"
.data:00000DE0                 dd offset $SG160600     ; "o\tc #6C6A6C"
.data:00000DE4                 dd offset $SG160601     ; "     .+.     "
.data:00000DE8                 dd offset $SG160602     ; "   @##$##@   "
.data:00000DEC                 dd offset $SG160603     ; "  @%&***&%@  "
.data:00000DF0                 dd offset $SG160604     ; " =-;>,,,>;-= "
.data:00000DF4                 dd offset $SG160605     ; " ')!~{{{~!)' "
.data:00000DF8                 dd offset $SG160606     ; "])^/({{{(_^)]"
.data:00000DFC                 dd offset $SG160607     ; ":<_[}|||}[_<:"
.data:00000E00                 dd offset $SG160608     ; "12[3455563[21"
.data:00000E04                 dd offset $SG160609     ; "7_365899063_7"
.data:00000E08                 dd offset $SG160610     ; " /|09abc904/ "
.data:00000E0C                 dd offset $SG160611     ; " d}8efgfb83d "
.data:00000E10                 dd offset $SG160612     ; "  hiafjgakh  "
.data:00000E14                 dd offset $SG160613     ; "   l~mnm~l   "
.data:00000E18                 dd offset $SG160614     ; "     o@o     "
.data:00000E18 _data           ends
.data:00000E18
.text$mn:00000E1C ; ===========================================================================
.text$mn:00000E1C
.text$mn:00000E1C ; Segment type: Pure code
.text$mn:00000E1C ; Segment permissions: Read/Execute
.text$mn:00000E1C _text$mn        segment para public 'CODE' use32
.text$mn:00000E1C                 assume cs:_text$mn
.text$mn:00000E1C                 ;org 0E1Ch
.text$mn:00000E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E1C
.text$mn:00000E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E1C
.text$mn:00000E1C ; Attributes: bp-based frame
.text$mn:00000E1C
.text$mn:00000E1C ; void __thiscall ColumnEditorDlg::init(ColumnEditorDlg *this, HINSTANCE, HWND, struct ScintillaEditView **)
.text$mn:00000E1C                 public ?init@ColumnEditorDlg@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAPAVScintillaEditView@@@Z
.text$mn:00000E1C ?init@ColumnEditorDlg@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAPAVScintillaEditView@@@Z proc near
.text$mn:00000E1C
.text$mn:00000E1C var_10          = byte ptr -10h
.text$mn:00000E1C var_4           = dword ptr -4
.text$mn:00000E1C arg_0           = dword ptr  8
.text$mn:00000E1C arg_4           = dword ptr  0Ch
.text$mn:00000E1C arg_8           = dword ptr  10h
.text$mn:00000E1C
.text$mn:00000E1C                 push    ebp
.text$mn:00000E1D                 mov     ebp, esp
.text$mn:00000E1F                 sub     esp, 10h
.text$mn:00000E22                 mov     [ebp+var_4], ecx
.text$mn:00000E25                 mov     eax, [ebp+arg_4]
.text$mn:00000E28                 push    eax             ; HWND
.text$mn:00000E29                 mov     ecx, [ebp+arg_0]
.text$mn:00000E2C                 push    ecx             ; HINSTANCE
.text$mn:00000E2D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E30                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000E35                 cmp     [ebp+arg_8], 0
.text$mn:00000E39                 jnz     short loc_E56
.text$mn:00000E3B                 push    offset $SG168125 ; "StaticDialog::init : ppEditView is null"...
.text$mn:00000E40                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000E43                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000E48                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000E4D                 lea     edx, [ebp+var_10]
.text$mn:00000E50                 push    edx
.text$mn:00000E51                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000E56 ; ---------------------------------------------------------------------------
.text$mn:00000E56
.text$mn:00000E56 loc_E56:                                ; CODE XREF: ColumnEditorDlg::init(HINSTANCE__ *,HWND__ *,ScintillaEditView * *)+1Dj
.text$mn:00000E56                 mov     eax, [ebp+var_4]
.text$mn:00000E59                 mov     ecx, [ebp+arg_8]
.text$mn:00000E5C                 mov     [eax+20h], ecx
.text$mn:00000E5F                 mov     esp, ebp
.text$mn:00000E61                 pop     ebp
.text$mn:00000E62                 retn    0Ch
.text$mn:00000E62 ?init@ColumnEditorDlg@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAPAVScintillaEditView@@@Z endp
.text$mn:00000E62
.text$mn:00000E62 ; ---------------------------------------------------------------------------
.text$mn:00000E65                 db 7 dup(0CCh)
.text$mn:00000E6C
.text$mn:00000E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E6C
.text$mn:00000E6C ; Attributes: bp-based frame
.text$mn:00000E6C
.text$mn:00000E6C ; void __thiscall ColumnEditorDlg::display(ColumnEditorDlg *this, bool)
.text$mn:00000E6C                 public ?display@ColumnEditorDlg@@UBEX_N@Z
.text$mn:00000E6C ?display@ColumnEditorDlg@@UBEX_N@Z proc near
.text$mn:00000E6C
.text$mn:00000E6C var_4           = dword ptr -4
.text$mn:00000E6C arg_0           = byte ptr  8
.text$mn:00000E6C
.text$mn:00000E6C                 push    ebp
.text$mn:00000E6D                 mov     ebp, esp
.text$mn:00000E6F                 push    ecx
.text$mn:00000E70                 mov     [ebp+var_4], ecx
.text$mn:00000E73                 movzx   eax, [ebp+arg_0]
.text$mn:00000E77                 push    eax             ; bool
.text$mn:00000E78                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E7B                 call    ?display@Window@@UBEX_N@Z ; Window::display(bool)
.text$mn:00000E80                 movzx   ecx, [ebp+arg_0]
.text$mn:00000E84                 test    ecx, ecx
.text$mn:00000E86                 jz      short loc_EA1
.text$mn:00000E88                 push    7D1h            ; nIDDlgItem
.text$mn:00000E8D                 mov     edx, [ebp+var_4]
.text$mn:00000E90                 mov     eax, [edx+0Ch]
.text$mn:00000E93                 push    eax             ; hDlg
.text$mn:00000E94                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000E9A                 push    eax             ; hWnd
.text$mn:00000E9B                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:00000EA1
.text$mn:00000EA1 loc_EA1:                                ; CODE XREF: ColumnEditorDlg::display(bool)+1Aj
.text$mn:00000EA1                 mov     esp, ebp
.text$mn:00000EA3                 pop     ebp
.text$mn:00000EA4                 retn    4
.text$mn:00000EA4 ?display@ColumnEditorDlg@@UBEX_N@Z endp
.text$mn:00000EA4
.text$mn:00000EA4 ; ---------------------------------------------------------------------------
.text$mn:00000EA7                 db 5 dup(0CCh)
.text$mn:00000EAC
.text$mn:00000EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000EAC
.text$mn:00000EAC ; Attributes: bp-based frame
.text$mn:00000EAC
.text$mn:00000EAC ; void __thiscall ColumnEditorDlg::switchTo(ColumnEditorDlg *this, bool)
.text$mn:00000EAC                 public ?switchTo@ColumnEditorDlg@@QAEX_N@Z
.text$mn:00000EAC ?switchTo@ColumnEditorDlg@@QAEX_N@Z proc near
.text$mn:00000EAC                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+56p
.text$mn:00000EAC                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+E7Ap
.text$mn:00000EAC
.text$mn:00000EAC var_48          = dword ptr -48h
.text$mn:00000EAC var_44          = dword ptr -44h
.text$mn:00000EAC hWnd            = dword ptr -40h
.text$mn:00000EAC var_3C          = dword ptr -3Ch
.text$mn:00000EAC var_38          = dword ptr -38h
.text$mn:00000EAC var_34          = dword ptr -34h
.text$mn:00000EAC var_30          = dword ptr -30h
.text$mn:00000EAC var_2C          = dword ptr -2Ch
.text$mn:00000EAC var_28          = dword ptr -28h
.text$mn:00000EAC var_24          = dword ptr -24h
.text$mn:00000EAC var_20          = dword ptr -20h
.text$mn:00000EAC var_1C          = dword ptr -1Ch
.text$mn:00000EAC var_18          = dword ptr -18h
.text$mn:00000EAC var_14          = dword ptr -14h
.text$mn:00000EAC var_10          = dword ptr -10h
.text$mn:00000EAC bEnable         = dword ptr -0Ch
.text$mn:00000EAC wParam          = dword ptr -8
.text$mn:00000EAC var_4           = dword ptr -4
.text$mn:00000EAC arg_0           = byte ptr  8
.text$mn:00000EAC
.text$mn:00000EAC                 push    ebp
.text$mn:00000EAD                 mov     ebp, esp
.text$mn:00000EAF                 sub     esp, 48h
.text$mn:00000EB2                 mov     [ebp+var_4], ecx
.text$mn:00000EB5                 push    7F2h            ; nIDDlgItem
.text$mn:00000EBA                 mov     eax, [ebp+var_4]
.text$mn:00000EBD                 mov     ecx, [eax+0Ch]
.text$mn:00000EC0                 push    ecx             ; hDlg
.text$mn:00000EC1                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000EC7                 mov     [ebp+hWnd], eax
.text$mn:00000ECA                 movzx   edx, [ebp+arg_0]
.text$mn:00000ECE                 push    edx             ; bEnable
.text$mn:00000ECF                 mov     eax, [ebp+hWnd]
.text$mn:00000ED2                 push    eax             ; hWnd
.text$mn:00000ED3                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00000ED9                 movzx   ecx, [ebp+arg_0]
.text$mn:00000EDD                 push    ecx             ; bEnable
.text$mn:00000EDE                 push    7E7h            ; nIDDlgItem
.text$mn:00000EE3                 mov     edx, [ebp+var_4]
.text$mn:00000EE6                 mov     eax, [edx+0Ch]
.text$mn:00000EE9                 push    eax             ; hDlg
.text$mn:00000EEA                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000EF0                 push    eax             ; hWnd
.text$mn:00000EF1                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00000EF7                 push    0               ; lParam
.text$mn:00000EF9                 movzx   ecx, [ebp+arg_0]
.text$mn:00000EFD                 push    ecx             ; wParam
.text$mn:00000EFE                 push    0F1h ; '±'      ; Msg
.text$mn:00000F03                 push    7ECh            ; nIDDlgItem
.text$mn:00000F08                 mov     edx, [ebp+var_4]
.text$mn:00000F0B                 mov     eax, [edx+0Ch]
.text$mn:00000F0E                 push    eax             ; hDlg
.text$mn:00000F0F                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000F15                 push    7E5h            ; nIDDlgItem
.text$mn:00000F1A                 mov     ecx, [ebp+var_4]
.text$mn:00000F1D                 mov     edx, [ecx+0Ch]
.text$mn:00000F20                 push    edx             ; hDlg
.text$mn:00000F21                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000F27                 mov     [ebp+var_44], eax
.text$mn:00000F2A                 movzx   eax, [ebp+arg_0]
.text$mn:00000F2E                 test    eax, eax
.text$mn:00000F30                 jnz     short loc_F3B
.text$mn:00000F32                 mov     [ebp+wParam], 1
.text$mn:00000F39                 jmp     short loc_F42
.text$mn:00000F3B ; ---------------------------------------------------------------------------
.text$mn:00000F3B
.text$mn:00000F3B loc_F3B:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+84j
.text$mn:00000F3B                 mov     [ebp+wParam], 0
.text$mn:00000F42
.text$mn:00000F42 loc_F42:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+8Dj
.text$mn:00000F42                 push    0               ; lParam
.text$mn:00000F44                 mov     ecx, [ebp+wParam]
.text$mn:00000F47                 push    ecx             ; wParam
.text$mn:00000F48                 push    0F1h ; '±'      ; Msg
.text$mn:00000F4D                 push    7EDh            ; nIDDlgItem
.text$mn:00000F52                 mov     edx, [ebp+var_4]
.text$mn:00000F55                 mov     eax, [edx+0Ch]
.text$mn:00000F58                 push    eax             ; hDlg
.text$mn:00000F59                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000F5F                 movzx   ecx, [ebp+arg_0]
.text$mn:00000F63                 test    ecx, ecx
.text$mn:00000F65                 jnz     short loc_F70
.text$mn:00000F67                 mov     [ebp+bEnable], 1
.text$mn:00000F6E                 jmp     short loc_F77
.text$mn:00000F70 ; ---------------------------------------------------------------------------
.text$mn:00000F70
.text$mn:00000F70 loc_F70:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+B9j
.text$mn:00000F70                 mov     [ebp+bEnable], 0
.text$mn:00000F77
.text$mn:00000F77 loc_F77:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+C2j
.text$mn:00000F77                 mov     edx, [ebp+bEnable]
.text$mn:00000F7A                 push    edx             ; bEnable
.text$mn:00000F7B                 push    7F1h            ; nIDDlgItem
.text$mn:00000F80                 mov     eax, [ebp+var_4]
.text$mn:00000F83                 mov     ecx, [eax+0Ch]
.text$mn:00000F86                 push    ecx             ; hDlg
.text$mn:00000F87                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000F8D                 push    eax             ; hWnd
.text$mn:00000F8E                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00000F94                 movzx   edx, [ebp+arg_0]
.text$mn:00000F98                 test    edx, edx
.text$mn:00000F9A                 jnz     short loc_FA5
.text$mn:00000F9C                 mov     [ebp+var_10], 1
.text$mn:00000FA3                 jmp     short loc_FAC
.text$mn:00000FA5 ; ---------------------------------------------------------------------------
.text$mn:00000FA5
.text$mn:00000FA5 loc_FA5:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+EEj
.text$mn:00000FA5                 mov     [ebp+var_10], 0
.text$mn:00000FAC
.text$mn:00000FAC loc_FAC:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+F7j
.text$mn:00000FAC                 mov     eax, [ebp+var_10]
.text$mn:00000FAF                 push    eax             ; bEnable
.text$mn:00000FB0                 push    7EEh            ; nIDDlgItem
.text$mn:00000FB5                 mov     ecx, [ebp+var_4]
.text$mn:00000FB8                 mov     edx, [ecx+0Ch]
.text$mn:00000FBB                 push    edx             ; hDlg
.text$mn:00000FBC                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000FC2                 push    eax             ; hWnd
.text$mn:00000FC3                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00000FC9                 movzx   eax, [ebp+arg_0]
.text$mn:00000FCD                 test    eax, eax
.text$mn:00000FCF                 jnz     short loc_FDA
.text$mn:00000FD1                 mov     [ebp+var_14], 1
.text$mn:00000FD8                 jmp     short loc_FE1
.text$mn:00000FDA ; ---------------------------------------------------------------------------
.text$mn:00000FDA
.text$mn:00000FDA loc_FDA:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+123j
.text$mn:00000FDA                 mov     [ebp+var_14], 0
.text$mn:00000FE1
.text$mn:00000FE1 loc_FE1:                                ; CODE XREF: ColumnEditorDlg::switchTo(bool)+12Cj
.text$mn:00000FE1                 mov     ecx, [ebp+var_14]
.text$mn:00000FE4                 push    ecx             ; bEnable
.text$mn:00000FE5                 mov     edx, [ebp+var_44]
.text$mn:00000FE8                 push    edx             ; hWnd
.text$mn:00000FE9                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00000FEF                 movzx   eax, [ebp+arg_0]
.text$mn:00000FF3                 test    eax, eax
.text$mn:00000FF5                 jnz     short loc_1000
.text$mn:00000FF7                 mov     [ebp+var_18], 1
.text$mn:00000FFE                 jmp     short loc_1007
.text$mn:00001000 ; ---------------------------------------------------------------------------
.text$mn:00001000
.text$mn:00001000 loc_1000:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+149j
.text$mn:00001000                 mov     [ebp+var_18], 0
.text$mn:00001007
.text$mn:00001007 loc_1007:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+152j
.text$mn:00001007                 mov     ecx, [ebp+var_18]
.text$mn:0000100A                 push    ecx             ; bEnable
.text$mn:0000100B                 push    7EFh            ; nIDDlgItem
.text$mn:00001010                 mov     edx, [ebp+var_4]
.text$mn:00001013                 mov     eax, [edx+0Ch]
.text$mn:00001016                 push    eax             ; hDlg
.text$mn:00001017                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:0000101D                 push    eax             ; hWnd
.text$mn:0000101E                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001024                 movzx   ecx, [ebp+arg_0]
.text$mn:00001028                 test    ecx, ecx
.text$mn:0000102A                 jnz     short loc_1035
.text$mn:0000102C                 mov     [ebp+var_1C], 1
.text$mn:00001033                 jmp     short loc_103C
.text$mn:00001035 ; ---------------------------------------------------------------------------
.text$mn:00001035
.text$mn:00001035 loc_1035:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+17Ej
.text$mn:00001035                 mov     [ebp+var_1C], 0
.text$mn:0000103C
.text$mn:0000103C loc_103C:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+187j
.text$mn:0000103C                 mov     edx, [ebp+var_1C]
.text$mn:0000103F                 push    edx             ; bEnable
.text$mn:00001040                 push    7E6h            ; nIDDlgItem
.text$mn:00001045                 mov     eax, [ebp+var_4]
.text$mn:00001048                 mov     ecx, [eax+0Ch]
.text$mn:0000104B                 push    ecx             ; hDlg
.text$mn:0000104C                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001052                 push    eax             ; hWnd
.text$mn:00001053                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001059                 movzx   edx, [ebp+arg_0]
.text$mn:0000105D                 test    edx, edx
.text$mn:0000105F                 jnz     short loc_106A
.text$mn:00001061                 mov     [ebp+var_20], 1
.text$mn:00001068                 jmp     short loc_1071
.text$mn:0000106A ; ---------------------------------------------------------------------------
.text$mn:0000106A
.text$mn:0000106A loc_106A:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+1B3j
.text$mn:0000106A                 mov     [ebp+var_20], 0
.text$mn:00001071
.text$mn:00001071 loc_1071:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+1BCj
.text$mn:00001071                 mov     eax, [ebp+var_20]
.text$mn:00001074                 push    eax             ; bEnable
.text$mn:00001075                 push    7F4h            ; nIDDlgItem
.text$mn:0000107A                 mov     ecx, [ebp+var_4]
.text$mn:0000107D                 mov     edx, [ecx+0Ch]
.text$mn:00001080                 push    edx             ; hDlg
.text$mn:00001081                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001087                 push    eax             ; hWnd
.text$mn:00001088                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:0000108E                 movzx   eax, [ebp+arg_0]
.text$mn:00001092                 test    eax, eax
.text$mn:00001094                 jnz     short loc_109F
.text$mn:00001096                 mov     [ebp+var_24], 1
.text$mn:0000109D                 jmp     short loc_10A6
.text$mn:0000109F ; ---------------------------------------------------------------------------
.text$mn:0000109F
.text$mn:0000109F loc_109F:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+1E8j
.text$mn:0000109F                 mov     [ebp+var_24], 0
.text$mn:000010A6
.text$mn:000010A6 loc_10A6:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+1F1j
.text$mn:000010A6                 mov     ecx, [ebp+var_24]
.text$mn:000010A9                 push    ecx             ; bEnable
.text$mn:000010AA                 push    7F5h            ; nIDDlgItem
.text$mn:000010AF                 mov     edx, [ebp+var_4]
.text$mn:000010B2                 mov     eax, [edx+0Ch]
.text$mn:000010B5                 push    eax             ; hDlg
.text$mn:000010B6                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000010BC                 push    eax             ; hWnd
.text$mn:000010BD                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:000010C3                 movzx   ecx, [ebp+arg_0]
.text$mn:000010C7                 test    ecx, ecx
.text$mn:000010C9                 jnz     short loc_10D4
.text$mn:000010CB                 mov     [ebp+var_28], 1
.text$mn:000010D2                 jmp     short loc_10DB
.text$mn:000010D4 ; ---------------------------------------------------------------------------
.text$mn:000010D4
.text$mn:000010D4 loc_10D4:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+21Dj
.text$mn:000010D4                 mov     [ebp+var_28], 0
.text$mn:000010DB
.text$mn:000010DB loc_10DB:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+226j
.text$mn:000010DB                 mov     edx, [ebp+var_28]
.text$mn:000010DE                 push    edx             ; bEnable
.text$mn:000010DF                 push    7F0h            ; nIDDlgItem
.text$mn:000010E4                 mov     eax, [ebp+var_4]
.text$mn:000010E7                 mov     ecx, [eax+0Ch]
.text$mn:000010EA                 push    ecx             ; hDlg
.text$mn:000010EB                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000010F1                 push    eax             ; hWnd
.text$mn:000010F2                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:000010F8                 movzx   edx, [ebp+arg_0]
.text$mn:000010FC                 test    edx, edx
.text$mn:000010FE                 jnz     short loc_1109
.text$mn:00001100                 mov     [ebp+var_2C], 1
.text$mn:00001107                 jmp     short loc_1110
.text$mn:00001109 ; ---------------------------------------------------------------------------
.text$mn:00001109
.text$mn:00001109 loc_1109:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+252j
.text$mn:00001109                 mov     [ebp+var_2C], 0
.text$mn:00001110
.text$mn:00001110 loc_1110:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+25Bj
.text$mn:00001110                 mov     eax, [ebp+var_2C]
.text$mn:00001113                 push    eax             ; bEnable
.text$mn:00001114                 push    7E8h            ; nIDDlgItem
.text$mn:00001119                 mov     ecx, [ebp+var_4]
.text$mn:0000111C                 mov     edx, [ecx+0Ch]
.text$mn:0000111F                 push    edx             ; hDlg
.text$mn:00001120                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001126                 push    eax             ; hWnd
.text$mn:00001127                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:0000112D                 movzx   eax, [ebp+arg_0]
.text$mn:00001131                 test    eax, eax
.text$mn:00001133                 jnz     short loc_113E
.text$mn:00001135                 mov     [ebp+var_30], 1
.text$mn:0000113C                 jmp     short loc_1145
.text$mn:0000113E ; ---------------------------------------------------------------------------
.text$mn:0000113E
.text$mn:0000113E loc_113E:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+287j
.text$mn:0000113E                 mov     [ebp+var_30], 0
.text$mn:00001145
.text$mn:00001145 loc_1145:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+290j
.text$mn:00001145                 mov     ecx, [ebp+var_30]
.text$mn:00001148                 push    ecx             ; bEnable
.text$mn:00001149                 push    7EAh            ; nIDDlgItem
.text$mn:0000114E                 mov     edx, [ebp+var_4]
.text$mn:00001151                 mov     eax, [edx+0Ch]
.text$mn:00001154                 push    eax             ; hDlg
.text$mn:00001155                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:0000115B                 push    eax             ; hWnd
.text$mn:0000115C                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001162                 movzx   ecx, [ebp+arg_0]
.text$mn:00001166                 test    ecx, ecx
.text$mn:00001168                 jnz     short loc_1173
.text$mn:0000116A                 mov     [ebp+var_34], 1
.text$mn:00001171                 jmp     short loc_117A
.text$mn:00001173 ; ---------------------------------------------------------------------------
.text$mn:00001173
.text$mn:00001173 loc_1173:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+2BCj
.text$mn:00001173                 mov     [ebp+var_34], 0
.text$mn:0000117A
.text$mn:0000117A loc_117A:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+2C5j
.text$mn:0000117A                 mov     edx, [ebp+var_34]
.text$mn:0000117D                 push    edx             ; bEnable
.text$mn:0000117E                 push    7E9h            ; nIDDlgItem
.text$mn:00001183                 mov     eax, [ebp+var_4]
.text$mn:00001186                 mov     ecx, [eax+0Ch]
.text$mn:00001189                 push    ecx             ; hDlg
.text$mn:0000118A                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001190                 push    eax             ; hWnd
.text$mn:00001191                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001197                 movzx   edx, [ebp+arg_0]
.text$mn:0000119B                 test    edx, edx
.text$mn:0000119D                 jnz     short loc_11A8
.text$mn:0000119F                 mov     [ebp+var_38], 1
.text$mn:000011A6                 jmp     short loc_11AF
.text$mn:000011A8 ; ---------------------------------------------------------------------------
.text$mn:000011A8
.text$mn:000011A8 loc_11A8:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+2F1j
.text$mn:000011A8                 mov     [ebp+var_38], 0
.text$mn:000011AF
.text$mn:000011AF loc_11AF:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+2FAj
.text$mn:000011AF                 mov     eax, [ebp+var_38]
.text$mn:000011B2                 push    eax             ; bEnable
.text$mn:000011B3                 push    7EBh            ; nIDDlgItem
.text$mn:000011B8                 mov     ecx, [ebp+var_4]
.text$mn:000011BB                 mov     edx, [ecx+0Ch]
.text$mn:000011BE                 push    edx             ; hDlg
.text$mn:000011BF                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000011C5                 push    eax             ; hWnd
.text$mn:000011C6                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:000011CC                 movzx   eax, [ebp+arg_0]
.text$mn:000011D0                 test    eax, eax
.text$mn:000011D2                 jnz     short loc_11DD
.text$mn:000011D4                 mov     [ebp+var_3C], 1
.text$mn:000011DB                 jmp     short loc_11E4
.text$mn:000011DD ; ---------------------------------------------------------------------------
.text$mn:000011DD
.text$mn:000011DD loc_11DD:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+326j
.text$mn:000011DD                 mov     [ebp+var_3C], 0
.text$mn:000011E4
.text$mn:000011E4 loc_11E4:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+32Fj
.text$mn:000011E4                 mov     ecx, [ebp+var_3C]
.text$mn:000011E7                 push    ecx             ; bEnable
.text$mn:000011E8                 push    7F3h            ; nIDDlgItem
.text$mn:000011ED                 mov     edx, [ebp+var_4]
.text$mn:000011F0                 mov     eax, [edx+0Ch]
.text$mn:000011F3                 push    eax             ; hDlg
.text$mn:000011F4                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000011FA                 push    eax             ; hWnd
.text$mn:000011FB                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00001201                 movzx   ecx, [ebp+arg_0]
.text$mn:00001205                 test    ecx, ecx
.text$mn:00001207                 jz      short loc_1211
.text$mn:00001209                 mov     edx, [ebp+hWnd]
.text$mn:0000120C                 mov     [ebp+var_48], edx
.text$mn:0000120F                 jmp     short loc_1217
.text$mn:00001211 ; ---------------------------------------------------------------------------
.text$mn:00001211
.text$mn:00001211 loc_1211:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+35Bj
.text$mn:00001211                 mov     eax, [ebp+var_44]
.text$mn:00001214                 mov     [ebp+var_48], eax
.text$mn:00001217
.text$mn:00001217 loc_1217:                               ; CODE XREF: ColumnEditorDlg::switchTo(bool)+363j
.text$mn:00001217                 mov     ecx, [ebp+var_48]
.text$mn:0000121A                 push    ecx             ; hWnd
.text$mn:0000121B                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:00001221                 mov     esp, ebp
.text$mn:00001223                 pop     ebp
.text$mn:00001224                 retn    4
.text$mn:00001224 ?switchTo@ColumnEditorDlg@@QAEX_N@Z endp
.text$mn:00001224
.text$mn:00001224 ; ---------------------------------------------------------------------------
.text$mn:00001227                 db 5 dup(0CCh)
.text$mn:0000122C
.text$mn:0000122C ; =============== S U B R O U T I N E =======================================
.text$mn:0000122C
.text$mn:0000122C ; Attributes: bp-based frame
.text$mn:0000122C
.text$mn:0000122C ; unsigned __int8 __thiscall ColumnEditorDlg::getFormat(ColumnEditorDlg *__hidden this)
.text$mn:0000122C                 public ?getFormat@ColumnEditorDlg@@QAEEXZ
.text$mn:0000122C ?getFormat@ColumnEditorDlg@@QAEEXZ proc near
.text$mn:0000122C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+6EBp
.text$mn:0000122C
.text$mn:0000122C var_10          = dword ptr -10h
.text$mn:0000122C var_C           = dword ptr -0Ch
.text$mn:0000122C var_8           = dword ptr -8
.text$mn:0000122C var_2           = byte ptr -2
.text$mn:0000122C var_1           = byte ptr -1
.text$mn:0000122C
.text$mn:0000122C                 push    ebp
.text$mn:0000122D                 mov     ebp, esp
.text$mn:0000122F                 sub     esp, 10h
.text$mn:00001232                 mov     [ebp+var_8], ecx
.text$mn:00001235                 push    0               ; lParam
.text$mn:00001237                 push    0               ; wParam
.text$mn:00001239                 push    0F0h ; '='      ; Msg
.text$mn:0000123E                 push    7F3h            ; nIDDlgItem
.text$mn:00001243                 mov     eax, [ebp+var_8]
.text$mn:00001246                 mov     ecx, [eax+0Ch]
.text$mn:00001249                 push    ecx             ; hDlg
.text$mn:0000124A                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00001250                 cmp     eax, 1
.text$mn:00001253                 jnz     short loc_125E
.text$mn:00001255                 mov     [ebp+var_C], 1
.text$mn:0000125C                 jmp     short loc_1265
.text$mn:0000125E ; ---------------------------------------------------------------------------
.text$mn:0000125E
.text$mn:0000125E loc_125E:                               ; CODE XREF: ColumnEditorDlg::getFormat(void)+27j
.text$mn:0000125E                 mov     [ebp+var_C], 0
.text$mn:00001265
.text$mn:00001265 loc_1265:                               ; CODE XREF: ColumnEditorDlg::getFormat(void)+30j
.text$mn:00001265                 mov     dl, byte ptr [ebp+var_C]
.text$mn:00001268                 mov     [ebp+var_2], dl
.text$mn:0000126B                 mov     [ebp+var_1], 0
.text$mn:0000126F                 push    0               ; lParam
.text$mn:00001271                 push    0               ; wParam
.text$mn:00001273                 push    0F0h ; '='      ; Msg
.text$mn:00001278                 push    7EAh            ; nIDDlgItem
.text$mn:0000127D                 mov     eax, [ebp+var_8]
.text$mn:00001280                 mov     ecx, [eax+0Ch]
.text$mn:00001283                 push    ecx             ; hDlg
.text$mn:00001284                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:0000128A                 cmp     eax, 1
.text$mn:0000128D                 jnz     short loc_1295
.text$mn:0000128F                 mov     [ebp+var_1], 1
.text$mn:00001293                 jmp     short loc_12DF
.text$mn:00001295 ; ---------------------------------------------------------------------------
.text$mn:00001295
.text$mn:00001295 loc_1295:                               ; CODE XREF: ColumnEditorDlg::getFormat(void)+61j
.text$mn:00001295                 push    0               ; lParam
.text$mn:00001297                 push    0               ; wParam
.text$mn:00001299                 push    0F0h ; '='      ; Msg
.text$mn:0000129E                 push    7E9h            ; nIDDlgItem
.text$mn:000012A3                 mov     edx, [ebp+var_8]
.text$mn:000012A6                 mov     eax, [edx+0Ch]
.text$mn:000012A9                 push    eax             ; hDlg
.text$mn:000012AA                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:000012B0                 cmp     eax, 1
.text$mn:000012B3                 jnz     short loc_12BB
.text$mn:000012B5                 mov     [ebp+var_1], 2
.text$mn:000012B9                 jmp     short loc_12DF
.text$mn:000012BB ; ---------------------------------------------------------------------------
.text$mn:000012BB
.text$mn:000012BB loc_12BB:                               ; CODE XREF: ColumnEditorDlg::getFormat(void)+87j
.text$mn:000012BB                 push    0               ; lParam
.text$mn:000012BD                 push    0               ; wParam
.text$mn:000012BF                 push    0F0h ; '='      ; Msg
.text$mn:000012C4                 push    7EBh            ; nIDDlgItem
.text$mn:000012C9                 mov     ecx, [ebp+var_8]
.text$mn:000012CC                 mov     edx, [ecx+0Ch]
.text$mn:000012CF                 push    edx             ; hDlg
.text$mn:000012D0                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:000012D6                 cmp     eax, 1
.text$mn:000012D9                 jnz     short loc_12DF
.text$mn:000012DB                 mov     [ebp+var_1], 3
.text$mn:000012DF
.text$mn:000012DF loc_12DF:                               ; CODE XREF: ColumnEditorDlg::getFormat(void)+67j
.text$mn:000012DF                                         ; ColumnEditorDlg::getFormat(void)+8Dj ...
.text$mn:000012DF                 movzx   eax, [ebp+var_2]
.text$mn:000012E3                 test    eax, eax
.text$mn:000012E5                 jz      short loc_12F0
.text$mn:000012E7                 mov     [ebp+var_10], 4
.text$mn:000012EE                 jmp     short loc_12F7
.text$mn:000012F0 ; ---------------------------------------------------------------------------
.text$mn:000012F0
.text$mn:000012F0 loc_12F0:                               ; CODE XREF: ColumnEditorDlg::getFormat(void)+B9j
.text$mn:000012F0                 mov     [ebp+var_10], 0
.text$mn:000012F7
.text$mn:000012F7 loc_12F7:                               ; CODE XREF: ColumnEditorDlg::getFormat(void)+C2j
.text$mn:000012F7                 movzx   eax, [ebp+var_1]
.text$mn:000012FB                 or      eax, [ebp+var_10]
.text$mn:000012FE                 mov     esp, ebp
.text$mn:00001300                 pop     ebp
.text$mn:00001301                 retn
.text$mn:00001301 ?getFormat@ColumnEditorDlg@@QAEEXZ endp
.text$mn:00001301
.text$mn:00001301 ; ---------------------------------------------------------------------------
.text$mn:00001302                 db 0Ah dup(0CCh)
.text$mn:0000130C
.text$mn:0000130C ; =============== S U B R O U T I N E =======================================
.text$mn:0000130C
.text$mn:0000130C ; Attributes: bp-based frame
.text$mn:0000130C
.text$mn:0000130C ; int __stdcall ColumnEditorDlg::run_dlgProc(ColumnEditorDlg *this, unsigned int, unsigned int, __int32)
.text$mn:0000130C                 public ?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z
.text$mn:0000130C ?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z proc near
.text$mn:0000130C
.text$mn:0000130C var_A10         = byte ptr -0A10h
.text$mn:0000130C var_A04         = dword ptr -0A04h
.text$mn:0000130C var_A00         = dword ptr -0A00h
.text$mn:0000130C var_9FC         = dword ptr -9FCh
.text$mn:0000130C var_9F8         = dword ptr -9F8h
.text$mn:0000130C var_9F4         = dword ptr -9F4h
.text$mn:0000130C var_9F0         = dword ptr -9F0h
.text$mn:0000130C var_9EC         = dword ptr -9ECh
.text$mn:0000130C var_9E8         = dword ptr -9E8h
.text$mn:0000130C var_9E4         = dword ptr -9E4h
.text$mn:0000130C var_9E0         = dword ptr -9E0h
.text$mn:0000130C var_9DC         = dword ptr -9DCh
.text$mn:0000130C var_9D8         = dword ptr -9D8h
.text$mn:0000130C var_9D4         = dword ptr -9D4h
.text$mn:0000130C var_9D0         = dword ptr -9D0h
.text$mn:0000130C var_9CC         = dword ptr -9CCh
.text$mn:0000130C var_9C8         = dword ptr -9C8h
.text$mn:0000130C var_9C4         = dword ptr -9C4h
.text$mn:0000130C var_9C0         = dword ptr -9C0h
.text$mn:0000130C var_9BC         = dword ptr -9BCh
.text$mn:0000130C var_9B8         = dword ptr -9B8h
.text$mn:0000130C var_9B4         = dword ptr -9B4h
.text$mn:0000130C var_9B0         = dword ptr -9B0h
.text$mn:0000130C var_9AC         = dword ptr -9ACh
.text$mn:0000130C var_9A8         = dword ptr -9A8h
.text$mn:0000130C var_9A4         = dword ptr -9A4h
.text$mn:0000130C var_9A0         = byte ptr -9A0h
.text$mn:0000130C var_990         = dword ptr -990h
.text$mn:0000130C var_98C         = byte ptr -98Ch
.text$mn:0000130C var_97C         = dword ptr -97Ch
.text$mn:0000130C var_978         = byte ptr -978h
.text$mn:0000130C var_968         = dword ptr -968h
.text$mn:0000130C var_964         = dword ptr -964h
.text$mn:0000130C var_960         = dword ptr -960h
.text$mn:0000130C var_95C         = dword ptr -95Ch
.text$mn:0000130C var_958         = dword ptr -958h
.text$mn:0000130C var_954         = dword ptr -954h
.text$mn:0000130C var_950         = dword ptr -950h
.text$mn:0000130C var_94C         = dword ptr -94Ch
.text$mn:0000130C var_948         = dword ptr -948h
.text$mn:0000130C var_944         = dword ptr -944h
.text$mn:0000130C var_940         = dword ptr -940h
.text$mn:0000130C var_93C         = dword ptr -93Ch
.text$mn:0000130C var_938         = dword ptr -938h
.text$mn:0000130C var_934         = dword ptr -934h
.text$mn:0000130C var_930         = dword ptr -930h
.text$mn:0000130C var_92C         = dword ptr -92Ch
.text$mn:0000130C var_928         = dword ptr -928h
.text$mn:0000130C var_924         = dword ptr -924h
.text$mn:0000130C var_920         = dword ptr -920h
.text$mn:0000130C var_91C         = dword ptr -91Ch
.text$mn:0000130C var_918         = dword ptr -918h
.text$mn:0000130C var_914         = dword ptr -914h
.text$mn:0000130C var_910         = dword ptr -910h
.text$mn:0000130C var_90C         = dword ptr -90Ch
.text$mn:0000130C var_908         = dword ptr -908h
.text$mn:0000130C var_904         = dword ptr -904h
.text$mn:0000130C var_900         = dword ptr -900h
.text$mn:0000130C var_8FC         = dword ptr -8FCh
.text$mn:0000130C var_8F8         = dword ptr -8F8h
.text$mn:0000130C var_8F4         = dword ptr -8F4h
.text$mn:0000130C var_8F0         = dword ptr -8F0h
.text$mn:0000130C var_8EC         = dword ptr -8ECh
.text$mn:0000130C var_8E8         = dword ptr -8E8h
.text$mn:0000130C var_8E4         = dword ptr -8E4h
.text$mn:0000130C var_8E0         = dword ptr -8E0h
.text$mn:0000130C var_8DC         = dword ptr -8DCh
.text$mn:0000130C var_8D8         = dword ptr -8D8h
.text$mn:0000130C var_8D4         = dword ptr -8D4h
.text$mn:0000130C var_8D0         = dword ptr -8D0h
.text$mn:0000130C var_8CC         = dword ptr -8CCh
.text$mn:0000130C var_8C8         = dword ptr -8C8h
.text$mn:0000130C var_8C4         = dword ptr -8C4h
.text$mn:0000130C var_8C0         = dword ptr -8C0h
.text$mn:0000130C var_8BC         = dword ptr -8BCh
.text$mn:0000130C var_8B8         = dword ptr -8B8h
.text$mn:0000130C var_8B4         = dword ptr -8B4h
.text$mn:0000130C var_8B0         = dword ptr -8B0h
.text$mn:0000130C var_8AC         = dword ptr -8ACh
.text$mn:0000130C var_8A8         = dword ptr -8A8h
.text$mn:0000130C Str             = dword ptr -8A4h
.text$mn:0000130C var_8A0         = dword ptr -8A0h
.text$mn:0000130C var_89C         = dword ptr -89Ch
.text$mn:0000130C var_898         = dword ptr -898h
.text$mn:0000130C var_894         = dword ptr -894h
.text$mn:0000130C var_88F         = byte ptr -88Fh
.text$mn:0000130C var_88E         = byte ptr -88Eh
.text$mn:0000130C var_88D         = byte ptr -88Dh
.text$mn:0000130C var_88C         = dword ptr -88Ch
.text$mn:0000130C var_886         = byte ptr -886h
.text$mn:0000130C var_885         = byte ptr -885h
.text$mn:0000130C var_884         = byte ptr -884h
.text$mn:0000130C var_883         = byte ptr -883h
.text$mn:0000130C var_882         = byte ptr -882h
.text$mn:0000130C var_881         = byte ptr -881h
.text$mn:0000130C var_880         = byte ptr -880h
.text$mn:0000130C var_864         = byte ptr -864h
.text$mn:0000130C var_848         = byte ptr -848h
.text$mn:0000130C var_82C         = byte ptr -82Ch
.text$mn:0000130C lParam          = dword ptr -810h
.text$mn:0000130C var_10          = dword ptr -10h
.text$mn:0000130C var_C           = dword ptr -0Ch
.text$mn:0000130C var_4           = dword ptr -4
.text$mn:0000130C this            = dword ptr  8
.text$mn:0000130C arg_4           = dword ptr  0Ch
.text$mn:0000130C arg_8           = dword ptr  10h
.text$mn:0000130C
.text$mn:0000130C                 push    ebp
.text$mn:0000130D                 mov     ebp, esp
.text$mn:0000130F                 push    0FFFFFFFFh
.text$mn:00001311                 push    offset __ehhandler$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z
.text$mn:00001316                 mov     eax, large fs:0
.text$mn:0000131C                 push    eax
.text$mn:0000131D                 sub     esp, 0A04h
.text$mn:00001323                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001328                 xor     eax, ebp
.text$mn:0000132A                 mov     [ebp+var_10], eax
.text$mn:0000132D                 push    eax
.text$mn:0000132E                 lea     eax, [ebp+var_C]
.text$mn:00001331                 mov     large fs:0, eax
.text$mn:00001337                 mov     eax, [ebp+arg_4]
.text$mn:0000133A                 mov     [ebp+var_8F0], eax
.text$mn:00001340                 cmp     [ebp+var_8F0], 110h
.text$mn:0000134A                 jz      short loc_135D
.text$mn:0000134C                 cmp     [ebp+var_8F0], 111h
.text$mn:00001356                 jz      short loc_13D7
.text$mn:00001358                 jmp     loc_21CB
.text$mn:0000135D ; ---------------------------------------------------------------------------
.text$mn:0000135D
.text$mn:0000135D loc_135D:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+3Ej
.text$mn:0000135D                 push    1               ; bool
.text$mn:0000135F                 mov     ecx, [ebp+this] ; this
.text$mn:00001362                 call    ?switchTo@ColumnEditorDlg@@QAEX_N@Z ; ColumnEditorDlg::switchTo(bool)
.text$mn:00001367                 push    0               ; lParam
.text$mn:00001369                 push    1               ; wParam
.text$mn:0000136B                 push    0F1h ; '±'      ; Msg
.text$mn:00001370                 push    7E8h            ; nIDDlgItem
.text$mn:00001375                 mov     ecx, [ebp+this]
.text$mn:00001378                 mov     edx, [ecx+0Ch]
.text$mn:0000137B                 push    edx             ; hDlg
.text$mn:0000137C                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00001382                 mov     ecx, [ebp+this] ; this
.text$mn:00001385                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:0000138A                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000138F                 mov     [ebp+var_9C0], eax
.text$mn:00001395                 mov     ecx, [ebp+var_9C0]
.text$mn:0000139B                 call    ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ ; NppParameters::getEnableThemeDlgTexture(void)
.text$mn:000013A0                 mov     [ebp+var_8FC], eax
.text$mn:000013A6                 cmp     [ebp+var_8FC], 0
.text$mn:000013AD                 jz      short loc_13CD
.text$mn:000013AF                 push    6
.text$mn:000013B1                 mov     eax, [ebp+this]
.text$mn:000013B4                 mov     ecx, [eax+0Ch]
.text$mn:000013B7                 push    ecx
.text$mn:000013B8                 call    [ebp+var_8FC]
.text$mn:000013BE                 push    0
.text$mn:000013C0                 mov     edx, [ebp+this]
.text$mn:000013C3                 mov     eax, [edx]
.text$mn:000013C5                 mov     ecx, [ebp+this]
.text$mn:000013C8                 mov     edx, [eax+18h]
.text$mn:000013CB                 call    edx
.text$mn:000013CD
.text$mn:000013CD loc_13CD:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+A1j
.text$mn:000013CD                 mov     eax, 1
.text$mn:000013D2                 jmp     loc_21CD
.text$mn:000013D7 ; ---------------------------------------------------------------------------
.text$mn:000013D7
.text$mn:000013D7 loc_13D7:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+4Aj
.text$mn:000013D7                 mov     eax, [ebp+arg_8]
.text$mn:000013DA                 mov     [ebp+var_89C], eax
.text$mn:000013E0                 cmp     [ebp+var_89C], 2
.text$mn:000013E7                 ja      short loc_1400
.text$mn:000013E9                 cmp     [ebp+var_89C], 2
.text$mn:000013F0                 jz      short loc_1425
.text$mn:000013F2                 cmp     [ebp+var_89C], 1
.text$mn:000013F9                 jz      short loc_143E
.text$mn:000013FB                 jmp     loc_2192
.text$mn:00001400 ; ---------------------------------------------------------------------------
.text$mn:00001400
.text$mn:00001400 loc_1400:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+DBj
.text$mn:00001400                 cmp     [ebp+var_89C], 7ECh
.text$mn:0000140A                 jb      loc_2192
.text$mn:00001410                 cmp     [ebp+var_89C], 7EDh
.text$mn:0000141A                 jbe     loc_2162
.text$mn:00001420                 jmp     loc_2192
.text$mn:00001425 ; ---------------------------------------------------------------------------
.text$mn:00001425
.text$mn:00001425 loc_1425:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+E4j
.text$mn:00001425                 push    0
.text$mn:00001427                 mov     ecx, [ebp+this]
.text$mn:0000142A                 mov     edx, [ecx]
.text$mn:0000142C                 mov     ecx, [ebp+this]
.text$mn:0000142F                 mov     eax, [edx+0Ch]
.text$mn:00001432                 call    eax
.text$mn:00001434                 mov     eax, 1
.text$mn:00001439                 jmp     loc_21CD
.text$mn:0000143E ; ---------------------------------------------------------------------------
.text$mn:0000143E
.text$mn:0000143E loc_143E:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+EDj
.text$mn:0000143E                 push    0               ; __int32
.text$mn:00001440                 push    0               ; unsigned int
.text$mn:00001442                 push    81Eh            ; unsigned int
.text$mn:00001447                 mov     ecx, [ebp+this]
.text$mn:0000144A                 mov     edx, [ecx+20h]
.text$mn:0000144D                 mov     ecx, [edx]      ; this
.text$mn:0000144F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001454                 mov     [ebp+var_9D4], 400h
.text$mn:0000145E                 push    0               ; lParam
.text$mn:00001460                 push    0               ; wParam
.text$mn:00001462                 push    0F0h ; '='      ; Msg
.text$mn:00001467                 push    7ECh            ; nIDDlgItem
.text$mn:0000146C                 mov     eax, [ebp+this]
.text$mn:0000146F                 mov     ecx, [eax+0Ch]
.text$mn:00001472                 push    ecx             ; hDlg
.text$mn:00001473                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00001479                 cmp     eax, 1
.text$mn:0000147C                 jnz     short loc_148A
.text$mn:0000147E                 mov     [ebp+var_904], 1
.text$mn:00001488                 jmp     short loc_1494
.text$mn:0000148A ; ---------------------------------------------------------------------------
.text$mn:0000148A
.text$mn:0000148A loc_148A:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+170j
.text$mn:0000148A                 mov     [ebp+var_904], 0
.text$mn:00001494
.text$mn:00001494 loc_1494:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+17Cj
.text$mn:00001494                 mov     dl, byte ptr [ebp+var_904]
.text$mn:0000149A                 mov     [ebp+var_88E], dl
.text$mn:000014A0                 movzx   eax, [ebp+var_88E]
.text$mn:000014A7                 test    eax, eax
.text$mn:000014A9                 jz      loc_198D
.text$mn:000014AF                 lea     ecx, [ebp+lParam]
.text$mn:000014B5                 push    ecx             ; lParam
.text$mn:000014B6                 push    400h            ; wParam
.text$mn:000014BB                 push    0Dh             ; Msg
.text$mn:000014BD                 push    7F2h            ; nIDDlgItem
.text$mn:000014C2                 mov     edx, [ebp+this]
.text$mn:000014C5                 mov     eax, [edx+0Ch]
.text$mn:000014C8                 push    eax             ; hDlg
.text$mn:000014C9                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:000014CF                 push    0
.text$mn:000014D1                 mov     ecx, [ebp+this]
.text$mn:000014D4                 mov     edx, [ecx]
.text$mn:000014D6                 mov     ecx, [ebp+this]
.text$mn:000014D9                 mov     eax, [edx+0Ch]
.text$mn:000014DC                 call    eax
.text$mn:000014DE                 push    0               ; __int32
.text$mn:000014E0                 push    0               ; unsigned int
.text$mn:000014E2                 push    944h            ; unsigned int
.text$mn:000014E7                 mov     ecx, [ebp+this]
.text$mn:000014EA                 mov     edx, [ecx+20h]
.text$mn:000014ED                 mov     ecx, [edx]      ; this
.text$mn:000014EF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000014F4                 test    eax, eax
.text$mn:000014F6                 jnz     short loc_1517
.text$mn:000014F8                 push    0               ; __int32
.text$mn:000014FA                 push    0               ; unsigned int
.text$mn:000014FC                 push    0A0Ah           ; unsigned int
.text$mn:00001501                 mov     eax, [ebp+this]
.text$mn:00001504                 mov     ecx, [eax+20h]
.text$mn:00001507                 mov     ecx, [ecx]      ; this
.text$mn:00001509                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000150E                 cmp     eax, 1
.text$mn:00001511                 jle     loc_1664
.text$mn:00001517
.text$mn:00001517 loc_1517:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+1EAj
.text$mn:00001517                 lea     edx, [ebp+var_978]
.text$mn:0000151D                 push    edx
.text$mn:0000151E                 mov     eax, [ebp+this]
.text$mn:00001521                 mov     ecx, [eax+20h]
.text$mn:00001524                 mov     ecx, [ecx]
.text$mn:00001526                 call    ?getColumnModeSelectInfo@ScintillaEditView@@QAE?AV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@XZ ; ScintillaEditView::getColumnModeSelectInfo(void)
.text$mn:0000152B                 mov     [ebp+var_4], 0
.text$mn:00001532                 xor     edx, edx
.text$mn:00001534                 mov     [ebp+var_885], dl
.text$mn:0000153A                 movzx   eax, [ebp+var_885]
.text$mn:00001541                 push    eax
.text$mn:00001542                 sub     esp, 0Ch
.text$mn:00001545                 mov     ecx, esp
.text$mn:00001547                 mov     [ebp+var_9C4], esp
.text$mn:0000154D                 push    ecx
.text$mn:0000154E                 lea     ecx, [ebp+var_978]
.text$mn:00001554                 call    ?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::end(void)
.text$mn:00001559                 mov     [ebp+var_9A8], eax
.text$mn:0000155F                 mov     edx, [ebp+var_9A8]
.text$mn:00001565                 mov     [ebp+var_9DC], edx
.text$mn:0000156B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000156F                 sub     esp, 0Ch
.text$mn:00001572                 mov     eax, esp
.text$mn:00001574                 mov     [ebp+var_9E4], esp
.text$mn:0000157A                 push    eax
.text$mn:0000157B                 lea     ecx, [ebp+var_978]
.text$mn:00001581                 call    ?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::begin(void)
.text$mn:00001586                 mov     [ebp+var_9B0], eax
.text$mn:0000158C                 mov     ecx, [ebp+var_9B0]
.text$mn:00001592                 mov     [ebp+var_9EC], ecx
.text$mn:00001598                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000159C                 mov     byte ptr [ebp+var_4], 0
.text$mn:000015A0                 call    ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)
.text$mn:000015A5                 add     esp, 1Ch
.text$mn:000015A8                 lea     edx, [ebp+lParam]
.text$mn:000015AE                 push    edx
.text$mn:000015AF                 lea     eax, [ebp+var_978]
.text$mn:000015B5                 push    eax
.text$mn:000015B6                 mov     ecx, [ebp+this]
.text$mn:000015B9                 mov     edx, [ecx+20h]
.text$mn:000015BC                 mov     ecx, [edx]
.text$mn:000015BE                 call    ?columnReplace@ScintillaEditView@@QAEXAAV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@PB_W@Z ; ScintillaEditView::columnReplace(std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>> &,wchar_t const *)
.text$mn:000015C3                 xor     eax, eax
.text$mn:000015C5                 mov     [ebp+var_886], al
.text$mn:000015CB                 movzx   ecx, [ebp+var_886]
.text$mn:000015D2                 push    ecx
.text$mn:000015D3                 sub     esp, 0Ch
.text$mn:000015D6                 mov     edx, esp
.text$mn:000015D8                 mov     [ebp+var_9F4], esp
.text$mn:000015DE                 push    edx
.text$mn:000015DF                 lea     ecx, [ebp+var_978]
.text$mn:000015E5                 call    ?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::end(void)
.text$mn:000015EA                 mov     [ebp+var_9B8], eax
.text$mn:000015F0                 mov     eax, [ebp+var_9B8]
.text$mn:000015F6                 mov     [ebp+var_9FC], eax
.text$mn:000015FC                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001600                 sub     esp, 0Ch
.text$mn:00001603                 mov     ecx, esp
.text$mn:00001605                 mov     [ebp+var_A04], esp
.text$mn:0000160B                 push    ecx
.text$mn:0000160C                 lea     ecx, [ebp+var_978]
.text$mn:00001612                 call    ?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::begin(void)
.text$mn:00001617                 mov     [ebp+var_920], eax
.text$mn:0000161D                 mov     edx, [ebp+var_920]
.text$mn:00001623                 mov     [ebp+var_9E8], edx
.text$mn:00001629                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000162D                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001631                 call    ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder)
.text$mn:00001636                 add     esp, 1Ch
.text$mn:00001639                 lea     eax, [ebp+var_978]
.text$mn:0000163F                 push    eax
.text$mn:00001640                 mov     ecx, [ebp+this]
.text$mn:00001643                 mov     edx, [ecx+20h]
.text$mn:00001646                 mov     ecx, [edx]
.text$mn:00001648                 call    ?setMultiSelections@ScintillaEditView@@QAEXABV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@Z ; ScintillaEditView::setMultiSelections(std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>> const &)
.text$mn:0000164D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001654                 lea     ecx, [ebp+var_978]
.text$mn:0000165A                 call    ??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::~vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>(void)
.text$mn:0000165F                 jmp     loc_1988
.text$mn:00001664 ; ---------------------------------------------------------------------------
.text$mn:00001664
.text$mn:00001664 loc_1664:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+205j
.text$mn:00001664                 push    0               ; __int32
.text$mn:00001666                 push    0               ; unsigned int
.text$mn:00001668                 push    7D8h            ; unsigned int
.text$mn:0000166D                 mov     eax, [ebp+this]
.text$mn:00001670                 mov     ecx, [eax+20h]
.text$mn:00001673                 mov     ecx, [ecx]      ; this
.text$mn:00001675                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000167A                 mov     [ebp+var_90C], eax
.text$mn:00001680                 push    0               ; __int32
.text$mn:00001682                 mov     edx, [ebp+var_90C]
.text$mn:00001688                 push    edx             ; unsigned int
.text$mn:00001689                 push    851h            ; unsigned int
.text$mn:0000168E                 mov     eax, [ebp+this]
.text$mn:00001691                 mov     ecx, [eax+20h]
.text$mn:00001694                 mov     ecx, [ecx]      ; this
.text$mn:00001696                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000169B                 mov     [ebp+var_8C0], eax
.text$mn:000016A1                 push    0               ; __int32
.text$mn:000016A3                 mov     edx, [ebp+var_90C]
.text$mn:000016A9                 push    edx             ; unsigned int
.text$mn:000016AA                 push    876h            ; unsigned int
.text$mn:000016AF                 mov     eax, [ebp+this]
.text$mn:000016B2                 mov     ecx, [eax+20h]
.text$mn:000016B5                 mov     ecx, [ecx]      ; this
.text$mn:000016B7                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000016BC                 mov     [ebp+var_9A4], eax
.text$mn:000016C2                 push    0               ; __int32
.text$mn:000016C4                 push    0               ; unsigned int
.text$mn:000016C6                 push    7D6h            ; unsigned int
.text$mn:000016CB                 mov     edx, [ebp+this]
.text$mn:000016CE                 mov     eax, [edx+20h]
.text$mn:000016D1                 mov     ecx, [eax]      ; this
.text$mn:000016D3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000016D8                 mov     [ebp+var_928], eax
.text$mn:000016DE                 push    0               ; __int32
.text$mn:000016E0                 mov     ecx, [ebp+var_928]
.text$mn:000016E6                 push    ecx             ; unsigned int
.text$mn:000016E7                 push    876h            ; unsigned int
.text$mn:000016EC                 mov     edx, [ebp+this]
.text$mn:000016EF                 mov     eax, [edx+20h]
.text$mn:000016F2                 mov     ecx, [eax]      ; this
.text$mn:000016F4                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000016F9                 mov     [ebp+var_930], eax
.text$mn:000016FF                 mov     [ebp+var_914], 400h
.text$mn:00001709                 xor     ecx, ecx
.text$mn:0000170B                 mov     eax, [ebp+var_914]
.text$mn:00001711                 mov     edx, 2
.text$mn:00001716                 mul     edx
.text$mn:00001718                 seto    cl
.text$mn:0000171B                 neg     ecx
.text$mn:0000171D                 or      ecx, eax
.text$mn:0000171F                 push    ecx             ; unsigned int
.text$mn:00001720                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001725                 add     esp, 4
.text$mn:00001728                 mov     [ebp+var_964], eax
.text$mn:0000172E                 mov     eax, [ebp+var_964]
.text$mn:00001734                 mov     [ebp+Str], eax
.text$mn:0000173A                 mov     ecx, [ebp+var_9A4]
.text$mn:00001740                 mov     [ebp+var_894], ecx
.text$mn:00001746                 jmp     short loc_1757
.text$mn:00001748 ; ---------------------------------------------------------------------------
.text$mn:00001748
.text$mn:00001748 loc_1748:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+65Cj
.text$mn:00001748                 mov     edx, [ebp+var_894]
.text$mn:0000174E                 add     edx, 1
.text$mn:00001751                 mov     [ebp+var_894], edx
.text$mn:00001757
.text$mn:00001757 loc_1757:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+43Aj
.text$mn:00001757                 mov     eax, [ebp+var_894]
.text$mn:0000175D                 cmp     eax, [ebp+var_930]
.text$mn:00001763                 jg      loc_196D
.text$mn:00001769                 push    0               ; __int32
.text$mn:0000176B                 mov     ecx, [ebp+var_894]
.text$mn:00001771                 push    ecx             ; unsigned int
.text$mn:00001772                 push    877h            ; unsigned int
.text$mn:00001777                 mov     edx, [ebp+this]
.text$mn:0000177A                 mov     eax, [edx+20h]
.text$mn:0000177D                 mov     ecx, [eax]      ; this
.text$mn:0000177F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001784                 mov     [ebp+var_8B0], eax
.text$mn:0000178A                 push    0               ; __int32
.text$mn:0000178C                 mov     ecx, [ebp+var_894]
.text$mn:00001792                 push    ecx             ; unsigned int
.text$mn:00001793                 push    858h            ; unsigned int
.text$mn:00001798                 mov     edx, [ebp+this]
.text$mn:0000179B                 mov     eax, [edx+20h]
.text$mn:0000179E                 mov     ecx, [eax]      ; this
.text$mn:000017A0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000017A5                 mov     [ebp+var_8AC], eax
.text$mn:000017AB                 push    0               ; __int32
.text$mn:000017AD                 mov     ecx, [ebp+var_8AC]
.text$mn:000017B3                 push    ecx             ; unsigned int
.text$mn:000017B4                 push    851h            ; unsigned int
.text$mn:000017B9                 mov     edx, [ebp+this]
.text$mn:000017BC                 mov     eax, [edx+20h]
.text$mn:000017BF                 mov     ecx, [eax]      ; this
.text$mn:000017C1                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000017C6                 mov     [ebp+var_91C], eax
.text$mn:000017CC                 mov     ecx, [ebp+var_8AC]
.text$mn:000017D2                 sub     ecx, [ebp+var_8B0]
.text$mn:000017D8                 add     ecx, 1
.text$mn:000017DB                 mov     [ebp+var_8D8], ecx
.text$mn:000017E1                 mov     edx, [ebp+var_8D8]
.text$mn:000017E7                 cmp     edx, [ebp+var_914]
.text$mn:000017ED                 jle     short loc_183B
.text$mn:000017EF                 mov     eax, [ebp+Str]
.text$mn:000017F5                 mov     [ebp+var_968], eax
.text$mn:000017FB                 mov     ecx, [ebp+var_968]
.text$mn:00001801                 push    ecx             ; void *
.text$mn:00001802                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001807                 add     esp, 4
.text$mn:0000180A                 xor     ecx, ecx
.text$mn:0000180C                 mov     eax, [ebp+var_8D8]
.text$mn:00001812                 mov     edx, 2
.text$mn:00001817                 mul     edx
.text$mn:00001819                 seto    cl
.text$mn:0000181C                 neg     ecx
.text$mn:0000181E                 or      ecx, eax
.text$mn:00001820                 push    ecx             ; unsigned int
.text$mn:00001821                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001826                 add     esp, 4
.text$mn:00001829                 mov     [ebp+var_938], eax
.text$mn:0000182F                 mov     eax, [ebp+var_938]
.text$mn:00001835                 mov     [ebp+Str], eax
.text$mn:0000183B
.text$mn:0000183B loc_183B:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+4E1j
.text$mn:0000183B                 mov     ecx, [ebp+var_8AC]
.text$mn:00001841                 push    ecx             ; int
.text$mn:00001842                 mov     edx, [ebp+var_8B0]
.text$mn:00001848                 push    edx             ; int
.text$mn:00001849                 mov     eax, [ebp+var_8D8]
.text$mn:0000184F                 push    eax             ; unsigned int
.text$mn:00001850                 mov     ecx, [ebp+Str]
.text$mn:00001856                 push    ecx             ; wchar_t *
.text$mn:00001857                 mov     edx, [ebp+this]
.text$mn:0000185A                 mov     eax, [edx+20h]
.text$mn:0000185D                 mov     ecx, [eax]      ; this
.text$mn:0000185F                 call    ?getGenericText@ScintillaEditView@@QBEXPA_WIHH@Z ; ScintillaEditView::getGenericText(wchar_t *,uint,int,int)
.text$mn:00001864                 mov     ecx, [ebp+Str]
.text$mn:0000186A                 push    ecx             ; Str
.text$mn:0000186B                 lea     ecx, [ebp+var_848]
.text$mn:00001871                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001876                 mov     [ebp+var_4], 5
.text$mn:0000187D                 mov     edx, [ebp+var_91C]
.text$mn:00001883                 cmp     edx, [ebp+var_8C0]
.text$mn:00001889                 jge     short loc_18DE
.text$mn:0000188B                 push    20h ; ' '
.text$mn:0000188D                 mov     eax, [ebp+var_8C0]
.text$mn:00001893                 sub     eax, [ebp+var_91C]
.text$mn:00001899                 push    eax
.text$mn:0000189A                 lea     ecx, [ebp+var_864]
.text$mn:000018A0                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(uint,wchar_t)
.text$mn:000018A5                 mov     byte ptr [ebp+var_4], 6
.text$mn:000018A9                 lea     ecx, [ebp+var_864]
.text$mn:000018AF                 push    ecx
.text$mn:000018B0                 lea     ecx, [ebp+var_848]
.text$mn:000018B6                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000018BB                 lea     edx, [ebp+lParam]
.text$mn:000018C1                 push    edx             ; Str
.text$mn:000018C2                 lea     ecx, [ebp+var_848]
.text$mn:000018C8                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:000018CD                 mov     byte ptr [ebp+var_4], 5
.text$mn:000018D1                 lea     ecx, [ebp+var_864]
.text$mn:000018D7                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000018DC                 jmp     short loc_192F
.text$mn:000018DE ; ---------------------------------------------------------------------------
.text$mn:000018DE
.text$mn:000018DE loc_18DE:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+57Dj
.text$mn:000018DE                 mov     eax, [ebp+var_8C0]
.text$mn:000018E4                 push    eax             ; __int32
.text$mn:000018E5                 mov     ecx, [ebp+var_894]
.text$mn:000018EB                 push    ecx             ; unsigned int
.text$mn:000018EC                 push    998h            ; unsigned int
.text$mn:000018F1                 mov     edx, [ebp+this]
.text$mn:000018F4                 mov     eax, [edx+20h]
.text$mn:000018F7                 mov     ecx, [eax]      ; this
.text$mn:000018F9                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000018FE                 mov     [ebp+var_9B4], eax
.text$mn:00001904                 mov     ecx, [ebp+var_9B4]
.text$mn:0000190A                 sub     ecx, [ebp+var_8B0]
.text$mn:00001910                 mov     [ebp+var_940], ecx
.text$mn:00001916                 lea     edx, [ebp+lParam]
.text$mn:0000191C                 push    edx             ; Str
.text$mn:0000191D                 mov     eax, [ebp+var_940]
.text$mn:00001923                 push    eax             ; int
.text$mn:00001924                 lea     ecx, [ebp+var_848]
.text$mn:0000192A                 call    ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *)
.text$mn:0000192F
.text$mn:0000192F loc_192F:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+5D0j
.text$mn:0000192F                 mov     ecx, [ebp+var_8AC]
.text$mn:00001935                 push    ecx             ; int
.text$mn:00001936                 mov     edx, [ebp+var_8B0]
.text$mn:0000193C                 push    edx             ; int
.text$mn:0000193D                 lea     ecx, [ebp+var_848]
.text$mn:00001943                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001948                 push    eax             ; wchar_t *
.text$mn:00001949                 mov     eax, [ebp+this]
.text$mn:0000194C                 mov     ecx, [eax+20h]
.text$mn:0000194F                 mov     ecx, [ecx]      ; this
.text$mn:00001951                 call    ?replaceTarget@ScintillaEditView@@QBEHPB_WHH@Z ; ScintillaEditView::replaceTarget(wchar_t const *,int,int)
.text$mn:00001956                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000195D                 lea     ecx, [ebp+var_848]
.text$mn:00001963                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001968                 jmp     loc_1748
.text$mn:0000196D ; ---------------------------------------------------------------------------
.text$mn:0000196D
.text$mn:0000196D loc_196D:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+457j
.text$mn:0000196D                 mov     edx, [ebp+Str]
.text$mn:00001973                 mov     [ebp+var_97C], edx
.text$mn:00001979                 mov     eax, [ebp+var_97C]
.text$mn:0000197F                 push    eax             ; void *
.text$mn:00001980                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001985                 add     esp, 4
.text$mn:00001988
.text$mn:00001988 loc_1988:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+353j
.text$mn:00001988                 jmp     loc_2138
.text$mn:0000198D ; ---------------------------------------------------------------------------
.text$mn:0000198D
.text$mn:0000198D loc_198D:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+19Dj
.text$mn:0000198D                 push    1               ; bSigned
.text$mn:0000198F                 push    0               ; lpTranslated
.text$mn:00001991                 push    7E5h            ; nIDDlgItem
.text$mn:00001996                 mov     ecx, [ebp+this]
.text$mn:00001999                 mov     edx, [ecx+0Ch]
.text$mn:0000199C                 push    edx             ; hDlg
.text$mn:0000199D                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:000019A3                 mov     [ebp+var_8BC], eax
.text$mn:000019A9                 push    1               ; bSigned
.text$mn:000019AB                 push    0               ; lpTranslated
.text$mn:000019AD                 push    7E6h            ; nIDDlgItem
.text$mn:000019B2                 mov     eax, [ebp+this]
.text$mn:000019B5                 mov     ecx, [eax+0Ch]
.text$mn:000019B8                 push    ecx             ; hDlg
.text$mn:000019B9                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:000019BF                 mov     [ebp+var_910], eax
.text$mn:000019C5                 push    1               ; bSigned
.text$mn:000019C7                 push    0               ; lpTranslated
.text$mn:000019C9                 push    7F5h            ; nIDDlgItem
.text$mn:000019CE                 mov     edx, [ebp+this]
.text$mn:000019D1                 mov     eax, [edx+0Ch]
.text$mn:000019D4                 push    eax             ; hDlg
.text$mn:000019D5                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:000019DB                 mov     [ebp+var_8B8], eax
.text$mn:000019E1                 cmp     [ebp+var_8B8], 0
.text$mn:000019E8                 jnz     short loc_19F4
.text$mn:000019EA                 mov     [ebp+var_8B8], 1
.text$mn:000019F4
.text$mn:000019F4 loc_19F4:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+6DCj
.text$mn:000019F4                 mov     ecx, [ebp+this] ; this
.text$mn:000019F7                 call    ?getFormat@ColumnEditorDlg@@QAEEXZ ; ColumnEditorDlg::getFormat(void)
.text$mn:000019FC                 mov     [ebp+var_882], al
.text$mn:00001A02                 push    0
.text$mn:00001A04                 mov     ecx, [ebp+this]
.text$mn:00001A07                 mov     edx, [ecx]
.text$mn:00001A09                 mov     ecx, [ebp+this]
.text$mn:00001A0C                 mov     eax, [edx+0Ch]
.text$mn:00001A0F                 call    eax
.text$mn:00001A11                 push    0               ; __int32
.text$mn:00001A13                 push    0               ; unsigned int
.text$mn:00001A15                 push    944h            ; unsigned int
.text$mn:00001A1A                 mov     ecx, [ebp+this]
.text$mn:00001A1D                 mov     edx, [ecx+20h]
.text$mn:00001A20                 mov     ecx, [edx]      ; this
.text$mn:00001A22                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001A27                 test    eax, eax
.text$mn:00001A29                 jnz     short loc_1A4A
.text$mn:00001A2B                 push    0               ; __int32
.text$mn:00001A2D                 push    0               ; unsigned int
.text$mn:00001A2F                 push    0A0Ah           ; unsigned int
.text$mn:00001A34                 mov     eax, [ebp+this]
.text$mn:00001A37                 mov     ecx, [eax+20h]
.text$mn:00001A3A                 mov     ecx, [ecx]      ; this
.text$mn:00001A3C                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001A41                 cmp     eax, 1
.text$mn:00001A44                 jle     loc_1BAD
.text$mn:00001A4A
.text$mn:00001A4A loc_1A4A:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+71Dj
.text$mn:00001A4A                 lea     edx, [ebp+var_98C]
.text$mn:00001A50                 push    edx
.text$mn:00001A51                 mov     eax, [ebp+this]
.text$mn:00001A54                 mov     ecx, [eax+20h]
.text$mn:00001A57                 mov     ecx, [ecx]
.text$mn:00001A59                 call    ?getColumnModeSelectInfo@ScintillaEditView@@QAE?AV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@XZ ; ScintillaEditView::getColumnModeSelectInfo(void)
.text$mn:00001A5E                 mov     [ebp+var_4], 7
.text$mn:00001A65                 xor     edx, edx
.text$mn:00001A67                 mov     [ebp+var_88D], dl
.text$mn:00001A6D                 movzx   eax, [ebp+var_88D]
.text$mn:00001A74                 push    eax
.text$mn:00001A75                 sub     esp, 0Ch
.text$mn:00001A78                 mov     ecx, esp
.text$mn:00001A7A                 mov     [ebp+var_9CC], esp
.text$mn:00001A80                 push    ecx
.text$mn:00001A81                 lea     ecx, [ebp+var_98C]
.text$mn:00001A87                 call    ?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::end(void)
.text$mn:00001A8C                 mov     [ebp+var_948], eax
.text$mn:00001A92                 mov     edx, [ebp+var_948]
.text$mn:00001A98                 mov     [ebp+var_9D0], edx
.text$mn:00001A9E                 mov     byte ptr [ebp+var_4], 8
.text$mn:00001AA2                 sub     esp, 0Ch
.text$mn:00001AA5                 mov     eax, esp
.text$mn:00001AA7                 mov     [ebp+var_9F8], esp
.text$mn:00001AAD                 push    eax
.text$mn:00001AAE                 lea     ecx, [ebp+var_98C]
.text$mn:00001AB4                 call    ?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::begin(void)
.text$mn:00001AB9                 mov     [ebp+var_9AC], eax
.text$mn:00001ABF                 mov     ecx, [ebp+var_9AC]
.text$mn:00001AC5                 mov     [ebp+var_9D8], ecx
.text$mn:00001ACB                 mov     byte ptr [ebp+var_4], 9
.text$mn:00001ACF                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001AD3                 call    ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)
.text$mn:00001AD8                 add     esp, 1Ch
.text$mn:00001ADB                 movzx   edx, [ebp+var_882]
.text$mn:00001AE2                 push    edx
.text$mn:00001AE3                 mov     eax, [ebp+var_8B8]
.text$mn:00001AE9                 push    eax
.text$mn:00001AEA                 mov     ecx, [ebp+var_910]
.text$mn:00001AF0                 push    ecx
.text$mn:00001AF1                 mov     edx, [ebp+var_8BC]
.text$mn:00001AF7                 push    edx
.text$mn:00001AF8                 lea     eax, [ebp+var_98C]
.text$mn:00001AFE                 push    eax
.text$mn:00001AFF                 mov     ecx, [ebp+this]
.text$mn:00001B02                 mov     edx, [ecx+20h]
.text$mn:00001B05                 mov     ecx, [edx]
.text$mn:00001B07                 call    ?columnReplace@ScintillaEditView@@QAEXAAV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@HHHE@Z ; ScintillaEditView::columnReplace(std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>> &,int,int,int,uchar)
.text$mn:00001B0C                 xor     eax, eax
.text$mn:00001B0E                 mov     [ebp+var_88F], al
.text$mn:00001B14                 movzx   ecx, [ebp+var_88F]
.text$mn:00001B1B                 push    ecx
.text$mn:00001B1C                 sub     esp, 0Ch
.text$mn:00001B1F                 mov     edx, esp
.text$mn:00001B21                 mov     [ebp+var_9F0], esp
.text$mn:00001B27                 push    edx
.text$mn:00001B28                 lea     ecx, [ebp+var_98C]
.text$mn:00001B2E                 call    ?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::end(void)
.text$mn:00001B33                 mov     [ebp+var_950], eax
.text$mn:00001B39                 mov     eax, [ebp+var_950]
.text$mn:00001B3F                 mov     [ebp+var_9E0], eax
.text$mn:00001B45                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00001B49                 sub     esp, 0Ch
.text$mn:00001B4C                 mov     ecx, esp
.text$mn:00001B4E                 mov     [ebp+var_A00], esp
.text$mn:00001B54                 push    ecx
.text$mn:00001B55                 lea     ecx, [ebp+var_98C]
.text$mn:00001B5B                 call    ?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::begin(void)
.text$mn:00001B60                 mov     [ebp+var_990], eax
.text$mn:00001B66                 mov     edx, [ebp+var_990]
.text$mn:00001B6C                 mov     [ebp+var_9C8], edx
.text$mn:00001B72                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00001B76                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001B7A                 call    ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder)
.text$mn:00001B7F                 add     esp, 1Ch
.text$mn:00001B82                 lea     eax, [ebp+var_98C]
.text$mn:00001B88                 push    eax
.text$mn:00001B89                 mov     ecx, [ebp+this]
.text$mn:00001B8C                 mov     edx, [ecx+20h]
.text$mn:00001B8F                 mov     ecx, [edx]
.text$mn:00001B91                 call    ?setMultiSelections@ScintillaEditView@@QAEXABV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@Z ; ScintillaEditView::setMultiSelections(std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>> const &)
.text$mn:00001B96                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B9D                 lea     ecx, [ebp+var_98C]
.text$mn:00001BA3                 call    ??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::~vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>(void)
.text$mn:00001BA8                 jmp     loc_2138
.text$mn:00001BAD ; ---------------------------------------------------------------------------
.text$mn:00001BAD
.text$mn:00001BAD loc_1BAD:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+738j
.text$mn:00001BAD                 push    0               ; __int32
.text$mn:00001BAF                 push    0               ; unsigned int
.text$mn:00001BB1                 push    7D8h            ; unsigned int
.text$mn:00001BB6                 mov     eax, [ebp+this]
.text$mn:00001BB9                 mov     ecx, [eax+20h]
.text$mn:00001BBC                 mov     ecx, [ecx]      ; this
.text$mn:00001BBE                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001BC3                 mov     [ebp+var_900], eax
.text$mn:00001BC9                 push    0               ; __int32
.text$mn:00001BCB                 mov     edx, [ebp+var_900]
.text$mn:00001BD1                 push    edx             ; unsigned int
.text$mn:00001BD2                 push    851h            ; unsigned int
.text$mn:00001BD7                 mov     eax, [ebp+this]
.text$mn:00001BDA                 mov     ecx, [eax+20h]
.text$mn:00001BDD                 mov     ecx, [ecx]      ; this
.text$mn:00001BDF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001BE4                 mov     [ebp+var_8D4], eax
.text$mn:00001BEA                 push    0               ; __int32
.text$mn:00001BEC                 mov     edx, [ebp+var_900]
.text$mn:00001BF2                 push    edx             ; unsigned int
.text$mn:00001BF3                 push    876h            ; unsigned int
.text$mn:00001BF8                 mov     eax, [ebp+this]
.text$mn:00001BFB                 mov     ecx, [eax+20h]
.text$mn:00001BFE                 mov     ecx, [ecx]      ; this
.text$mn:00001C00                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001C05                 mov     [ebp+var_8CC], eax
.text$mn:00001C0B                 push    0               ; __int32
.text$mn:00001C0D                 push    0               ; unsigned int
.text$mn:00001C0F                 push    7D6h            ; unsigned int
.text$mn:00001C14                 mov     edx, [ebp+this]
.text$mn:00001C17                 mov     eax, [edx+20h]
.text$mn:00001C1A                 mov     ecx, [eax]      ; this
.text$mn:00001C1C                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001C21                 mov     [ebp+var_958], eax
.text$mn:00001C27                 push    0               ; __int32
.text$mn:00001C29                 mov     ecx, [ebp+var_958]
.text$mn:00001C2F                 push    ecx             ; unsigned int
.text$mn:00001C30                 push    876h            ; unsigned int
.text$mn:00001C35                 mov     edx, [ebp+this]
.text$mn:00001C38                 mov     eax, [edx+20h]
.text$mn:00001C3B                 mov     ecx, [eax]      ; this
.text$mn:00001C3D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001C42                 mov     [ebp+var_8E0], eax
.text$mn:00001C48                 lea     ecx, [ebp+var_9A0]
.text$mn:00001C4E                 call    ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)
.text$mn:00001C53                 mov     [ebp+var_4], 0Ch
.text$mn:00001C5A                 mov     ecx, [ebp+var_8BC]
.text$mn:00001C60                 mov     [ebp+var_8D0], ecx
.text$mn:00001C66                 mov     edx, [ebp+var_8E0]
.text$mn:00001C6C                 add     edx, 1
.text$mn:00001C6F                 sub     edx, [ebp+var_8CC]
.text$mn:00001C75                 mov     [ebp+var_8E8], edx
.text$mn:00001C7B
.text$mn:00001C7B loc_1C7B:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+9E6j
.text$mn:00001C7B                 lea     ecx, [ebp+var_9A0]
.text$mn:00001C81                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001C86                 cmp     eax, [ebp+var_8E8]
.text$mn:00001C8C                 jnb     short loc_1CF4
.text$mn:00001C8E                 mov     [ebp+var_8C8], 0
.text$mn:00001C98                 jmp     short loc_1CA9
.text$mn:00001C9A ; ---------------------------------------------------------------------------
.text$mn:00001C9A
.text$mn:00001C9A loc_1C9A:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long):loc_1CDEj
.text$mn:00001C9A                 mov     eax, [ebp+var_8C8]
.text$mn:00001CA0                 add     eax, 1
.text$mn:00001CA3                 mov     [ebp+var_8C8], eax
.text$mn:00001CA9
.text$mn:00001CA9 loc_1CA9:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+98Cj
.text$mn:00001CA9                 mov     ecx, [ebp+var_8C8]
.text$mn:00001CAF                 cmp     ecx, [ebp+var_8B8]
.text$mn:00001CB5                 jge     short loc_1CE0
.text$mn:00001CB7                 lea     edx, [ebp+var_8D0]
.text$mn:00001CBD                 push    edx
.text$mn:00001CBE                 lea     ecx, [ebp+var_9A0]
.text$mn:00001CC4                 call    ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int>>::push_back(int const &)
.text$mn:00001CC9                 lea     ecx, [ebp+var_9A0]
.text$mn:00001CCF                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001CD4                 cmp     eax, [ebp+var_8E8]
.text$mn:00001CDA                 jb      short loc_1CDE
.text$mn:00001CDC                 jmp     short loc_1CE0
.text$mn:00001CDE ; ---------------------------------------------------------------------------
.text$mn:00001CDE
.text$mn:00001CDE loc_1CDE:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+9CEj
.text$mn:00001CDE                 jmp     short loc_1C9A
.text$mn:00001CE0 ; ---------------------------------------------------------------------------
.text$mn:00001CE0
.text$mn:00001CE0 loc_1CE0:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+9A9j
.text$mn:00001CE0                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+9D0j
.text$mn:00001CE0                 mov     eax, [ebp+var_8D0]
.text$mn:00001CE6                 add     eax, [ebp+var_910]
.text$mn:00001CEC                 mov     [ebp+var_8D0], eax
.text$mn:00001CF2                 jmp     short loc_1C7B
.text$mn:00001CF4 ; ---------------------------------------------------------------------------
.text$mn:00001CF4
.text$mn:00001CF4 loc_1CF4:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+980j
.text$mn:00001CF4                 lea     ecx, [ebp+var_9A0]
.text$mn:00001CFA                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001CFF                 test    eax, eax
.text$mn:00001D01                 ja      short loc_1D1A
.text$mn:00001D03                 push    0C0h ; '+'      ; Line
.text$mn:00001D08                 push    offset $SG169245 ; "..\\src\\ScitillaComponent\\columnEdito"...
.text$mn:00001D0D                 push    offset $SG169246 ; "numbers.size() > 0"
.text$mn:00001D12                 call    __wassert
.text$mn:00001D17 ; ---------------------------------------------------------------------------
.text$mn:00001D17                 add     esp, 0Ch
.text$mn:00001D1A
.text$mn:00001D1A loc_1D1A:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+9F5j
.text$mn:00001D1A                 mov     [ebp+var_8E4], 400h
.text$mn:00001D24                 xor     ecx, ecx
.text$mn:00001D26                 mov     eax, [ebp+var_8E4]
.text$mn:00001D2C                 mov     edx, 2
.text$mn:00001D31                 mul     edx
.text$mn:00001D33                 seto    cl
.text$mn:00001D36                 neg     ecx
.text$mn:00001D38                 or      ecx, eax
.text$mn:00001D3A                 push    ecx             ; unsigned int
.text$mn:00001D3B                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001D40                 add     esp, 4
.text$mn:00001D43                 mov     [ebp+var_9BC], eax
.text$mn:00001D49                 mov     eax, [ebp+var_9BC]
.text$mn:00001D4F                 mov     [ebp+var_8A0], eax
.text$mn:00001D55                 movzx   ecx, [ebp+var_882]
.text$mn:00001D5C                 and     ecx, 3
.text$mn:00001D5F                 mov     [ebp+var_881], cl
.text$mn:00001D65                 movzx   edx, [ebp+var_882]
.text$mn:00001D6C                 and     edx, 4
.text$mn:00001D6F                 jz      short loc_1D7D
.text$mn:00001D71                 mov     [ebp+var_8DC], 1
.text$mn:00001D7B                 jmp     short loc_1D87
.text$mn:00001D7D ; ---------------------------------------------------------------------------
.text$mn:00001D7D
.text$mn:00001D7D loc_1D7D:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+A63j
.text$mn:00001D7D                 mov     [ebp+var_8DC], 0
.text$mn:00001D87
.text$mn:00001D87 loc_1D87:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+A6Fj
.text$mn:00001D87                 mov     al, byte ptr [ebp+var_8DC]
.text$mn:00001D8D                 mov     [ebp+var_884], al
.text$mn:00001D93                 mov     [ebp+var_898], 0Ah
.text$mn:00001D9D                 movzx   ecx, [ebp+var_881]
.text$mn:00001DA4                 cmp     ecx, 1
.text$mn:00001DA7                 jnz     short loc_1DB5
.text$mn:00001DA9                 mov     [ebp+var_898], 10h
.text$mn:00001DB3                 jmp     short loc_1DE3
.text$mn:00001DB5 ; ---------------------------------------------------------------------------
.text$mn:00001DB5
.text$mn:00001DB5 loc_1DB5:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+A9Bj
.text$mn:00001DB5                 movzx   edx, [ebp+var_881]
.text$mn:00001DBC                 cmp     edx, 2
.text$mn:00001DBF                 jnz     short loc_1DCD
.text$mn:00001DC1                 mov     [ebp+var_898], 8
.text$mn:00001DCB                 jmp     short loc_1DE3
.text$mn:00001DCD ; ---------------------------------------------------------------------------
.text$mn:00001DCD
.text$mn:00001DCD loc_1DCD:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+AB3j
.text$mn:00001DCD                 movzx   eax, [ebp+var_881]
.text$mn:00001DD4                 cmp     eax, 3
.text$mn:00001DD7                 jnz     short loc_1DE3
.text$mn:00001DD9                 mov     [ebp+var_898], 2
.text$mn:00001DE3
.text$mn:00001DE3 loc_1DE3:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+AA7j
.text$mn:00001DE3                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+ABFj ...
.text$mn:00001DE3                 lea     ecx, [ebp+var_A10]
.text$mn:00001DE9                 push    ecx
.text$mn:00001DEA                 lea     ecx, [ebp+var_9A0]
.text$mn:00001DF0                 call    ?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::rbegin(void)
.text$mn:00001DF5                 mov     [ebp+var_960], eax
.text$mn:00001DFB                 mov     edx, [ebp+var_960]
.text$mn:00001E01                 mov     [ebp+var_924], edx
.text$mn:00001E07                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00001E0B                 mov     ecx, [ebp+var_924]
.text$mn:00001E11                 call    ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::operator*(void)
.text$mn:00001E16                 mov     eax, [eax]
.text$mn:00001E18                 mov     [ebp+var_92C], eax
.text$mn:00001E1E                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00001E22                 lea     ecx, [ebp+var_A10]
.text$mn:00001E28                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(void)
.text$mn:00001E2D                 mov     ecx, [ebp+var_898]
.text$mn:00001E33                 push    ecx             ; int
.text$mn:00001E34                 mov     edx, [ebp+var_92C]
.text$mn:00001E3A                 push    edx             ; int
.text$mn:00001E3B                 call    ?getNbDigits@@YAHHH@Z ; getNbDigits(int,int)
.text$mn:00001E40                 add     esp, 8
.text$mn:00001E43                 mov     [ebp+var_8F8], eax
.text$mn:00001E49                 mov     eax, [ebp+var_898]
.text$mn:00001E4F                 push    eax             ; int
.text$mn:00001E50                 mov     ecx, [ebp+var_8BC]
.text$mn:00001E56                 push    ecx             ; int
.text$mn:00001E57                 call    ?getNbDigits@@YAHHH@Z ; getNbDigits(int,int)
.text$mn:00001E5C                 add     esp, 8
.text$mn:00001E5F                 mov     [ebp+var_908], eax
.text$mn:00001E65                 mov     edx, [ebp+var_908]
.text$mn:00001E6B                 cmp     edx, [ebp+var_8F8]
.text$mn:00001E71                 jle     short loc_1E81
.text$mn:00001E73                 mov     eax, [ebp+var_908]
.text$mn:00001E79                 mov     [ebp+var_918], eax
.text$mn:00001E7F                 jmp     short loc_1E8D
.text$mn:00001E81 ; ---------------------------------------------------------------------------
.text$mn:00001E81
.text$mn:00001E81 loc_1E81:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+B65j
.text$mn:00001E81                 mov     ecx, [ebp+var_8F8]
.text$mn:00001E87                 mov     [ebp+var_918], ecx
.text$mn:00001E8D
.text$mn:00001E8D loc_1E8D:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+B73j
.text$mn:00001E8D                 mov     edx, [ebp+var_918]
.text$mn:00001E93                 mov     [ebp+var_944], edx
.text$mn:00001E99                 mov     eax, [ebp+var_8CC]
.text$mn:00001E9F                 mov     [ebp+var_88C], eax
.text$mn:00001EA5                 jmp     short loc_1EB6
.text$mn:00001EA7 ; ---------------------------------------------------------------------------
.text$mn:00001EA7
.text$mn:00001EA7 loc_1EA7:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+DFAj
.text$mn:00001EA7                 mov     ecx, [ebp+var_88C]
.text$mn:00001EAD                 add     ecx, 1
.text$mn:00001EB0                 mov     [ebp+var_88C], ecx
.text$mn:00001EB6
.text$mn:00001EB6 loc_1EB6:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+B99j
.text$mn:00001EB6                 mov     edx, [ebp+var_88C]
.text$mn:00001EBC                 cmp     edx, [ebp+var_8E0]
.text$mn:00001EC2                 jg      loc_210B
.text$mn:00001EC8                 push    0               ; __int32
.text$mn:00001ECA                 mov     eax, [ebp+var_88C]
.text$mn:00001ED0                 push    eax             ; unsigned int
.text$mn:00001ED1                 push    877h            ; unsigned int
.text$mn:00001ED6                 mov     ecx, [ebp+this]
.text$mn:00001ED9                 mov     edx, [ecx+20h]
.text$mn:00001EDC                 mov     ecx, [edx]      ; this
.text$mn:00001EDE                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001EE3                 mov     [ebp+var_8B4], eax
.text$mn:00001EE9                 push    0               ; __int32
.text$mn:00001EEB                 mov     eax, [ebp+var_88C]
.text$mn:00001EF1                 push    eax             ; unsigned int
.text$mn:00001EF2                 push    858h            ; unsigned int
.text$mn:00001EF7                 mov     ecx, [ebp+this]
.text$mn:00001EFA                 mov     edx, [ecx+20h]
.text$mn:00001EFD                 mov     ecx, [edx]      ; this
.text$mn:00001EFF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001F04                 mov     [ebp+var_8A8], eax
.text$mn:00001F0A                 push    0               ; __int32
.text$mn:00001F0C                 mov     eax, [ebp+var_8A8]
.text$mn:00001F12                 push    eax             ; unsigned int
.text$mn:00001F13                 push    851h            ; unsigned int
.text$mn:00001F18                 mov     ecx, [ebp+this]
.text$mn:00001F1B                 mov     edx, [ecx+20h]
.text$mn:00001F1E                 mov     ecx, [edx]      ; this
.text$mn:00001F20                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001F25                 mov     [ebp+var_8EC], eax
.text$mn:00001F2B                 mov     eax, [ebp+var_8A8]
.text$mn:00001F31                 sub     eax, [ebp+var_8B4]
.text$mn:00001F37                 add     eax, 1
.text$mn:00001F3A                 mov     [ebp+var_8C4], eax
.text$mn:00001F40                 mov     ecx, [ebp+var_8C4]
.text$mn:00001F46                 cmp     ecx, [ebp+var_8E4]
.text$mn:00001F4C                 jle     short loc_1F9A
.text$mn:00001F4E                 mov     edx, [ebp+var_8A0]
.text$mn:00001F54                 mov     [ebp+var_934], edx
.text$mn:00001F5A                 mov     eax, [ebp+var_934]
.text$mn:00001F60                 push    eax             ; void *
.text$mn:00001F61                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001F66                 add     esp, 4
.text$mn:00001F69                 xor     ecx, ecx
.text$mn:00001F6B                 mov     eax, [ebp+var_8C4]
.text$mn:00001F71                 mov     edx, 2
.text$mn:00001F76                 mul     edx
.text$mn:00001F78                 seto    cl
.text$mn:00001F7B                 neg     ecx
.text$mn:00001F7D                 or      ecx, eax
.text$mn:00001F7F                 push    ecx             ; unsigned int
.text$mn:00001F80                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001F85                 add     esp, 4
.text$mn:00001F88                 mov     [ebp+var_93C], eax
.text$mn:00001F8E                 mov     eax, [ebp+var_93C]
.text$mn:00001F94                 mov     [ebp+var_8A0], eax
.text$mn:00001F9A
.text$mn:00001F9A loc_1F9A:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+C40j
.text$mn:00001F9A                 mov     ecx, [ebp+var_8A8]
.text$mn:00001FA0                 push    ecx             ; int
.text$mn:00001FA1                 mov     edx, [ebp+var_8B4]
.text$mn:00001FA7                 push    edx             ; int
.text$mn:00001FA8                 mov     eax, [ebp+var_8C4]
.text$mn:00001FAE                 push    eax             ; unsigned int
.text$mn:00001FAF                 mov     ecx, [ebp+var_8A0]
.text$mn:00001FB5                 push    ecx             ; wchar_t *
.text$mn:00001FB6                 mov     edx, [ebp+this]
.text$mn:00001FB9                 mov     eax, [edx+20h]
.text$mn:00001FBC                 mov     ecx, [eax]      ; this
.text$mn:00001FBE                 call    ?getGenericText@ScintillaEditView@@QBEXPA_WIHH@Z ; ScintillaEditView::getGenericText(wchar_t *,uint,int,int)
.text$mn:00001FC3                 mov     ecx, [ebp+var_8A0]
.text$mn:00001FC9                 push    ecx             ; Str
.text$mn:00001FCA                 lea     ecx, [ebp+var_82C]
.text$mn:00001FD0                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001FD5                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00001FD9                 movzx   edx, [ebp+var_884]
.text$mn:00001FE0                 push    edx             ; bool
.text$mn:00001FE1                 mov     eax, [ebp+var_944]
.text$mn:00001FE7                 push    eax             ; int
.text$mn:00001FE8                 mov     ecx, [ebp+var_898]
.text$mn:00001FEE                 push    ecx             ; int
.text$mn:00001FEF                 mov     edx, [ebp+var_88C]
.text$mn:00001FF5                 sub     edx, [ebp+var_8CC]
.text$mn:00001FFB                 push    edx
.text$mn:00001FFC                 lea     ecx, [ebp+var_9A0]
.text$mn:00002002                 call    ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::at(uint)
.text$mn:00002007                 mov     eax, [eax]
.text$mn:00002009                 push    eax             ; int
.text$mn:0000200A                 push    400h            ; int
.text$mn:0000200F                 lea     ecx, [ebp+lParam]
.text$mn:00002015                 push    ecx             ; wchar_t *
.text$mn:00002016                 call    ?int2str@@YAPA_WPA_WHHHH_N@Z ; int2str(wchar_t *,int,int,int,int,bool)
.text$mn:0000201B                 add     esp, 18h
.text$mn:0000201E                 mov     edx, [ebp+var_8EC]
.text$mn:00002024                 cmp     edx, [ebp+var_8D4]
.text$mn:0000202A                 jge     short loc_207F
.text$mn:0000202C                 push    20h ; ' '
.text$mn:0000202E                 mov     eax, [ebp+var_8D4]
.text$mn:00002034                 sub     eax, [ebp+var_8EC]
.text$mn:0000203A                 push    eax
.text$mn:0000203B                 lea     ecx, [ebp+var_880]
.text$mn:00002041                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(uint,wchar_t)
.text$mn:00002046                 mov     byte ptr [ebp+var_4], 0Fh
.text$mn:0000204A                 lea     ecx, [ebp+var_880]
.text$mn:00002050                 push    ecx
.text$mn:00002051                 lea     ecx, [ebp+var_82C]
.text$mn:00002057                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000205C                 lea     edx, [ebp+lParam]
.text$mn:00002062                 push    edx             ; Str
.text$mn:00002063                 lea     ecx, [ebp+var_82C]
.text$mn:00002069                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:0000206E                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00002072                 lea     ecx, [ebp+var_880]
.text$mn:00002078                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000207D                 jmp     short loc_20D0
.text$mn:0000207F ; ---------------------------------------------------------------------------
.text$mn:0000207F
.text$mn:0000207F loc_207F:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+D1Ej
.text$mn:0000207F                 mov     eax, [ebp+var_8D4]
.text$mn:00002085                 push    eax             ; __int32
.text$mn:00002086                 mov     ecx, [ebp+var_88C]
.text$mn:0000208C                 push    ecx             ; unsigned int
.text$mn:0000208D                 push    998h            ; unsigned int
.text$mn:00002092                 mov     edx, [ebp+this]
.text$mn:00002095                 mov     eax, [edx+20h]
.text$mn:00002098                 mov     ecx, [eax]      ; this
.text$mn:0000209A                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000209F                 mov     [ebp+var_94C], eax
.text$mn:000020A5                 mov     ecx, [ebp+var_94C]
.text$mn:000020AB                 sub     ecx, [ebp+var_8B4]
.text$mn:000020B1                 mov     [ebp+var_954], ecx
.text$mn:000020B7                 lea     edx, [ebp+lParam]
.text$mn:000020BD                 push    edx             ; Str
.text$mn:000020BE                 mov     eax, [ebp+var_954]
.text$mn:000020C4                 push    eax             ; int
.text$mn:000020C5                 lea     ecx, [ebp+var_82C]
.text$mn:000020CB                 call    ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *)
.text$mn:000020D0
.text$mn:000020D0 loc_20D0:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+D71j
.text$mn:000020D0                 mov     ecx, [ebp+var_8A8]
.text$mn:000020D6                 push    ecx             ; int
.text$mn:000020D7                 mov     edx, [ebp+var_8B4]
.text$mn:000020DD                 push    edx             ; int
.text$mn:000020DE                 lea     ecx, [ebp+var_82C]
.text$mn:000020E4                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000020E9                 push    eax             ; wchar_t *
.text$mn:000020EA                 mov     eax, [ebp+this]
.text$mn:000020ED                 mov     ecx, [eax+20h]
.text$mn:000020F0                 mov     ecx, [ecx]      ; this
.text$mn:000020F2                 call    ?replaceTarget@ScintillaEditView@@QBEHPB_WHH@Z ; ScintillaEditView::replaceTarget(wchar_t const *,int,int)
.text$mn:000020F7                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:000020FB                 lea     ecx, [ebp+var_82C]
.text$mn:00002101                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002106                 jmp     loc_1EA7
.text$mn:0000210B ; ---------------------------------------------------------------------------
.text$mn:0000210B
.text$mn:0000210B loc_210B:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+BB6j
.text$mn:0000210B                 mov     edx, [ebp+var_8A0]
.text$mn:00002111                 mov     [ebp+var_95C], edx
.text$mn:00002117                 mov     eax, [ebp+var_95C]
.text$mn:0000211D                 push    eax             ; void *
.text$mn:0000211E                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00002123                 add     esp, 4
.text$mn:00002126                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000212D                 lea     ecx, [ebp+var_9A0]
.text$mn:00002133                 call    ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$mn:00002138
.text$mn:00002138 loc_2138:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long):loc_1988j
.text$mn:00002138                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+89Cj
.text$mn:00002138                 push    0               ; __int32
.text$mn:0000213A                 push    0               ; unsigned int
.text$mn:0000213C                 push    81Fh            ; unsigned int
.text$mn:00002141                 mov     ecx, [ebp+this]
.text$mn:00002144                 mov     edx, [ecx+20h]
.text$mn:00002147                 mov     ecx, [edx]      ; this
.text$mn:00002149                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000214E                 mov     eax, [ebp+this]
.text$mn:00002151                 mov     ecx, [eax+20h]
.text$mn:00002154                 mov     ecx, [ecx]      ; this
.text$mn:00002156                 call    ?getFocus@Window@@QBEXXZ ; Window::getFocus(void)
.text$mn:0000215B                 mov     eax, 1
.text$mn:00002160                 jmp     short loc_21CD
.text$mn:00002162 ; ---------------------------------------------------------------------------
.text$mn:00002162
.text$mn:00002162 loc_2162:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+10Ej
.text$mn:00002162                 cmp     [ebp+arg_8], 7ECh
.text$mn:00002169                 jnz     short loc_2174
.text$mn:0000216B                 mov     [ebp+var_883], 1
.text$mn:00002172                 jmp     short loc_217B
.text$mn:00002174 ; ---------------------------------------------------------------------------
.text$mn:00002174
.text$mn:00002174 loc_2174:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+E5Dj
.text$mn:00002174                 mov     [ebp+var_883], 0
.text$mn:0000217B
.text$mn:0000217B loc_217B:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+E66j
.text$mn:0000217B                 movzx   edx, [ebp+var_883]
.text$mn:00002182                 push    edx             ; bool
.text$mn:00002183                 mov     ecx, [ebp+this] ; this
.text$mn:00002186                 call    ?switchTo@ColumnEditorDlg@@QAEX_N@Z ; ColumnEditorDlg::switchTo(bool)
.text$mn:0000218B                 mov     eax, 1
.text$mn:00002190                 jmp     short loc_21CD
.text$mn:00002192 ; ---------------------------------------------------------------------------
.text$mn:00002192
.text$mn:00002192 loc_2192:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+EFj
.text$mn:00002192                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+FEj ...
.text$mn:00002192                 mov     eax, [ebp+arg_8]
.text$mn:00002195                 shr     eax, 10h
.text$mn:00002198                 and     eax, 0FFFFh
.text$mn:0000219D                 movzx   ecx, ax
.text$mn:000021A0                 mov     [ebp+var_8F4], ecx
.text$mn:000021A6                 cmp     [ebp+var_8F4], 6
.text$mn:000021AD                 jz      short loc_21BD
.text$mn:000021AF                 cmp     [ebp+var_8F4], 100h
.text$mn:000021B9                 jz      short loc_21BD
.text$mn:000021BB                 jmp     short loc_21C4
.text$mn:000021BD ; ---------------------------------------------------------------------------
.text$mn:000021BD
.text$mn:000021BD loc_21BD:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+EA1j
.text$mn:000021BD                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+EADj
.text$mn:000021BD                 mov     eax, 1
.text$mn:000021C2                 jmp     short loc_21CD
.text$mn:000021C4 ; ---------------------------------------------------------------------------
.text$mn:000021C4
.text$mn:000021C4 loc_21C4:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+EAFj
.text$mn:000021C4                 mov     eax, 1
.text$mn:000021C9                 jmp     short loc_21CD
.text$mn:000021CB ; ---------------------------------------------------------------------------
.text$mn:000021CB
.text$mn:000021CB loc_21CB:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+4Cj
.text$mn:000021CB                 xor     eax, eax
.text$mn:000021CD
.text$mn:000021CD loc_21CD:                               ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+C6j
.text$mn:000021CD                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+12Dj ...
.text$mn:000021CD                 mov     ecx, [ebp+var_C]
.text$mn:000021D0                 mov     large fs:0, ecx
.text$mn:000021D7                 pop     ecx
.text$mn:000021D8                 mov     ecx, [ebp+var_10]
.text$mn:000021DB                 xor     ecx, ebp
.text$mn:000021DD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000021E2                 mov     esp, ebp
.text$mn:000021E4                 pop     ebp
.text$mn:000021E5                 retn    10h
.text$mn:000021E5 ?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z endp
.text$mn:000021E5
.text$mn:000021E5 _text$mn        ends
.text$mn:000021E5
.text$x:000021E8 ; ===========================================================================
.text$x:000021E8
.text$x:000021E8 ; Segment type: Pure code
.text$x:000021E8 ; Segment permissions: Read/Execute
.text$x:000021E8 _text$x         segment para public 'CODE' use32
.text$x:000021E8                 assume cs:_text$x
.text$x:000021E8                 ;org 21E8h
.text$x:000021E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000021E8
.text$x:000021E8 ; =============== S U B R O U T I N E =======================================
.text$x:000021E8
.text$x:000021E8
.text$x:000021E8 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$0 proc near
.text$x:000021E8                                         ; DATA XREF: .xdata$x:0000A144o
.text$x:000021E8                 lea     ecx, [ebp-978h]
.text$x:000021EE                 jmp     ??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::~vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>(void)
.text$x:000021EE __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$0 endp
.text$x:000021EE
.text$x:000021F3
.text$x:000021F3 ; =============== S U B R O U T I N E =======================================
.text$x:000021F3
.text$x:000021F3
.text$x:000021F3 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$1 proc near
.text$x:000021F3                                         ; DATA XREF: .xdata$x:0000A14Co
.text$x:000021F3                 mov     ecx, [ebp-9C4h]
.text$x:000021F9                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:000021F9 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$1 endp
.text$x:000021F9
.text$x:000021FE
.text$x:000021FE ; =============== S U B R O U T I N E =======================================
.text$x:000021FE
.text$x:000021FE
.text$x:000021FE __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$2 proc near
.text$x:000021FE                                         ; DATA XREF: .xdata$x:0000A154o
.text$x:000021FE                 mov     ecx, [ebp-9E4h]
.text$x:00002204                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002204 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$2 endp
.text$x:00002204
.text$x:00002209
.text$x:00002209 ; =============== S U B R O U T I N E =======================================
.text$x:00002209
.text$x:00002209
.text$x:00002209 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$3 proc near
.text$x:00002209                                         ; DATA XREF: .xdata$x:0000A15Co
.text$x:00002209                 mov     ecx, [ebp-9F4h]
.text$x:0000220F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:0000220F __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$3 endp
.text$x:0000220F
.text$x:00002214
.text$x:00002214 ; =============== S U B R O U T I N E =======================================
.text$x:00002214
.text$x:00002214
.text$x:00002214 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$4 proc near
.text$x:00002214                                         ; DATA XREF: .xdata$x:0000A164o
.text$x:00002214                 mov     ecx, [ebp-0A04h]
.text$x:0000221A                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:0000221A __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$4 endp
.text$x:0000221A
.text$x:0000221F
.text$x:0000221F ; =============== S U B R O U T I N E =======================================
.text$x:0000221F
.text$x:0000221F
.text$x:0000221F __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$5 proc near
.text$x:0000221F                                         ; DATA XREF: .xdata$x:0000A16Co
.text$x:0000221F                 lea     ecx, [ebp-848h]
.text$x:00002225                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002225 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$5 endp
.text$x:00002225
.text$x:0000222A
.text$x:0000222A ; =============== S U B R O U T I N E =======================================
.text$x:0000222A
.text$x:0000222A
.text$x:0000222A __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$6 proc near
.text$x:0000222A                                         ; DATA XREF: .xdata$x:0000A174o
.text$x:0000222A                 lea     ecx, [ebp-864h]
.text$x:00002230                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002230 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$6 endp
.text$x:00002230
.text$x:00002235
.text$x:00002235 ; =============== S U B R O U T I N E =======================================
.text$x:00002235
.text$x:00002235
.text$x:00002235 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$7 proc near
.text$x:00002235                                         ; DATA XREF: .xdata$x:0000A17Co
.text$x:00002235                 lea     ecx, [ebp-98Ch]
.text$x:0000223B                 jmp     ??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::~vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>(void)
.text$x:0000223B __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$7 endp
.text$x:0000223B
.text$x:00002240
.text$x:00002240 ; =============== S U B R O U T I N E =======================================
.text$x:00002240
.text$x:00002240
.text$x:00002240 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$8 proc near
.text$x:00002240                                         ; DATA XREF: .xdata$x:0000A184o
.text$x:00002240                 mov     ecx, [ebp-9CCh]
.text$x:00002246                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002246 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$8 endp
.text$x:00002246
.text$x:0000224B
.text$x:0000224B ; =============== S U B R O U T I N E =======================================
.text$x:0000224B
.text$x:0000224B
.text$x:0000224B __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$9 proc near
.text$x:0000224B                                         ; DATA XREF: .xdata$x:0000A18Co
.text$x:0000224B                 mov     ecx, [ebp-9F8h]
.text$x:00002251                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002251 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$9 endp
.text$x:00002251
.text$x:00002256
.text$x:00002256 ; =============== S U B R O U T I N E =======================================
.text$x:00002256
.text$x:00002256
.text$x:00002256 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$10 proc near
.text$x:00002256                                         ; DATA XREF: .xdata$x:0000A194o
.text$x:00002256                 mov     ecx, [ebp-9F0h]
.text$x:0000225C                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:0000225C __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$10 endp
.text$x:0000225C
.text$x:00002261
.text$x:00002261 ; =============== S U B R O U T I N E =======================================
.text$x:00002261
.text$x:00002261
.text$x:00002261 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$11 proc near
.text$x:00002261                                         ; DATA XREF: .xdata$x:0000A19Co
.text$x:00002261                 mov     ecx, [ebp-0A00h]
.text$x:00002267                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002267 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$11 endp
.text$x:00002267
.text$x:0000226C
.text$x:0000226C ; =============== S U B R O U T I N E =======================================
.text$x:0000226C
.text$x:0000226C
.text$x:0000226C __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$12 proc near
.text$x:0000226C                                         ; DATA XREF: .xdata$x:0000A1A4o
.text$x:0000226C                 lea     ecx, [ebp-9A0h]
.text$x:00002272                 jmp     ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)
.text$x:00002272 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$12 endp
.text$x:00002272
.text$x:00002277
.text$x:00002277 ; =============== S U B R O U T I N E =======================================
.text$x:00002277
.text$x:00002277
.text$x:00002277 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$13 proc near
.text$x:00002277                                         ; DATA XREF: .xdata$x:0000A1ACo
.text$x:00002277                 lea     ecx, [ebp-0A10h]
.text$x:0000227D                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(void)
.text$x:0000227D __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$13 endp
.text$x:0000227D
.text$x:00002282
.text$x:00002282 ; =============== S U B R O U T I N E =======================================
.text$x:00002282
.text$x:00002282
.text$x:00002282 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$14 proc near
.text$x:00002282                                         ; DATA XREF: .xdata$x:0000A1B4o
.text$x:00002282                 lea     ecx, [ebp-82Ch]
.text$x:00002288                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002288 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$14 endp
.text$x:00002288
.text$x:0000228D
.text$x:0000228D ; =============== S U B R O U T I N E =======================================
.text$x:0000228D
.text$x:0000228D
.text$x:0000228D __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$15 proc near
.text$x:0000228D                                         ; DATA XREF: .xdata$x:0000A1BCo
.text$x:0000228D                 lea     ecx, [ebp-880h]
.text$x:00002293                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002293 __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$15 endp
.text$x:00002293
.text$x:00002298
.text$x:00002298 ; =============== S U B R O U T I N E =======================================
.text$x:00002298
.text$x:00002298
.text$x:00002298 __ehhandler$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z proc near
.text$x:00002298                                         ; DATA XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+5o
.text$x:00002298
.text$x:00002298 arg_4           = dword ptr  8
.text$x:00002298
.text$x:00002298                 mov     edx, [esp+arg_4]
.text$x:0000229C                 lea     eax, [edx+0Ch]
.text$x:0000229F                 mov     ecx, [edx-0A08h]
.text$x:000022A5                 xor     ecx, eax
.text$x:000022A7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022AC                 mov     ecx, [edx-4]
.text$x:000022AF                 xor     ecx, eax
.text$x:000022B1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022B6                 mov     eax, offset __ehfuncinfo$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z
.text$x:000022BB                 jmp     ___CxxFrameHandler3
.text$x:000022BB __ehhandler$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z endp
.text$x:000022BB
.text$x:000022BB _text$x         ends
.text$x:000022BB
.text$mn:000022C0 ; ===========================================================================
.text$mn:000022C0
.text$mn:000022C0 ; Segment type: Pure code
.text$mn:000022C0 ; Segment permissions: Read/Execute
.text$mn:000022C0 _text$mn        segment para public 'CODE' use32
.text$mn:000022C0                 assume cs:_text$mn
.text$mn:000022C0                 ;org 22C0h
.text$mn:000022C0 ; COMDAT (pick any)
.text$mn:000022C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022C0
.text$mn:000022C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022C0
.text$mn:000022C0 ; Attributes: bp-based frame
.text$mn:000022C0
.text$mn:000022C0 ; public: __thiscall std::pair<struct ColumnModeInfo *, struct ColumnModeInfo *>::pair<struct ColumnModeInfo *, struct ColumnModeInfo *>(struct ColumnModeInfo * &, struct ColumnModeInfo * &)
.text$mn:000022C0                 public ??$?0AAPAUColumnModeInfo@@AAPAU0@X@?$pair@PAUColumnModeInfo@@PAU1@@std@@QAE@AAPAUColumnModeInfo@@0@Z
.text$mn:000022C0 ??$?0AAPAUColumnModeInfo@@AAPAU0@X@?$pair@PAUColumnModeInfo@@PAU1@@std@@QAE@AAPAUColumnModeInfo@@0@Z proc near
.text$mn:000022C0                                         ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+22Dp
.text$mn:000022C0                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+22Dp
.text$mn:000022C0
.text$mn:000022C0 var_4           = dword ptr -4
.text$mn:000022C0 arg_0           = dword ptr  8
.text$mn:000022C0 arg_4           = dword ptr  0Ch
.text$mn:000022C0
.text$mn:000022C0                 push    ebp
.text$mn:000022C1                 mov     ebp, esp
.text$mn:000022C3                 push    ecx
.text$mn:000022C4                 mov     [ebp+var_4], ecx
.text$mn:000022C7                 mov     eax, [ebp+arg_0]
.text$mn:000022CA                 push    eax
.text$mn:000022CB                 call    ??$forward@AAPAUColumnModeInfo@@@std@@YAAAPAUColumnModeInfo@@AAPAU1@@Z ; std::forward<ColumnModeInfo * &>(ColumnModeInfo * &)
.text$mn:000022D0                 add     esp, 4
.text$mn:000022D3                 mov     ecx, [ebp+var_4]
.text$mn:000022D6                 mov     edx, [eax]
.text$mn:000022D8                 mov     [ecx], edx
.text$mn:000022DA                 mov     eax, [ebp+arg_4]
.text$mn:000022DD                 push    eax
.text$mn:000022DE                 call    ??$forward@AAPAUColumnModeInfo@@@std@@YAAAPAUColumnModeInfo@@AAPAU1@@Z ; std::forward<ColumnModeInfo * &>(ColumnModeInfo * &)
.text$mn:000022E3                 add     esp, 4
.text$mn:000022E6                 mov     ecx, [ebp+var_4]
.text$mn:000022E9                 mov     edx, [eax]
.text$mn:000022EB                 mov     [ecx+4], edx
.text$mn:000022EE                 mov     eax, [ebp+var_4]
.text$mn:000022F1                 mov     esp, ebp
.text$mn:000022F3                 pop     ebp
.text$mn:000022F4                 retn    8
.text$mn:000022F4 ??$?0AAPAUColumnModeInfo@@AAPAU0@X@?$pair@PAUColumnModeInfo@@PAU1@@std@@QAE@AAPAUColumnModeInfo@@0@Z endp
.text$mn:000022F4
.text$mn:000022F4 ; ---------------------------------------------------------------------------
.text$mn:000022F7                 align 4
.text$mn:000022F7 _text$mn        ends
.text$mn:000022F7
.text$mn:000022F8 ; ===========================================================================
.text$mn:000022F8
.text$mn:000022F8 ; Segment type: Pure code
.text$mn:000022F8 ; Segment permissions: Read/Execute
.text$mn:000022F8 _text$mn        segment para public 'CODE' use32
.text$mn:000022F8                 assume cs:_text$mn
.text$mn:000022F8                 ;org 22F8h
.text$mn:000022F8 ; COMDAT (pick any)
.text$mn:000022F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022F8
.text$mn:000022F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000022F8
.text$mn:000022F8 ; Attributes: bp-based frame
.text$mn:000022F8
.text$mn:000022F8 ; void __cdecl std::_Adjust_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInPositionOrder>(struct ColumnModeInfo *, int, int, struct ColumnModeInfo &&, struct SortInPositionOrder)
.text$mn:000022F8                 public ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z
.text$mn:000022F8 ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z proc near
.text$mn:000022F8                                         ; CODE XREF: std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,int *,ColumnModeInfo *)+82p
.text$mn:000022F8                                         ; std::_Pop_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo &&,SortInPositionOrder,int *)+5Bp
.text$mn:000022F8
.text$mn:000022F8 var_8           = dword ptr -8
.text$mn:000022F8 var_4           = dword ptr -4
.text$mn:000022F8 arg_0           = dword ptr  8
.text$mn:000022F8 arg_4           = dword ptr  0Ch
.text$mn:000022F8 arg_8           = dword ptr  10h
.text$mn:000022F8 arg_C           = dword ptr  14h
.text$mn:000022F8 arg_10          = byte ptr  18h
.text$mn:000022F8
.text$mn:000022F8                 push    ebp
.text$mn:000022F9                 mov     ebp, esp
.text$mn:000022FB                 sub     esp, 8
.text$mn:000022FE                 mov     eax, [ebp+arg_4]
.text$mn:00002301                 mov     [ebp+var_8], eax
.text$mn:00002304                 mov     ecx, [ebp+arg_4]
.text$mn:00002307                 lea     edx, [ecx+ecx+2]
.text$mn:0000230B                 mov     [ebp+var_4], edx
.text$mn:0000230E                 jmp     short loc_231A
.text$mn:00002310 ; ---------------------------------------------------------------------------
.text$mn:00002310
.text$mn:00002310 loc_2310:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+A9j
.text$mn:00002310                 mov     eax, [ebp+var_4]
.text$mn:00002313                 lea     ecx, [eax+eax+2]
.text$mn:00002317                 mov     [ebp+var_4], ecx
.text$mn:0000231A
.text$mn:0000231A loc_231A:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+16j
.text$mn:0000231A                 mov     edx, [ebp+var_4]
.text$mn:0000231D                 cmp     edx, [ebp+arg_8]
.text$mn:00002320                 jge     loc_23A6
.text$mn:00002326                 push    946h            ; unsigned int
.text$mn:0000232B                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002330                 mov     eax, [ebp+var_4]
.text$mn:00002333                 sub     eax, 1
.text$mn:00002336                 imul    ecx, eax, 18h
.text$mn:00002339                 add     ecx, [ebp+arg_0]
.text$mn:0000233C                 push    ecx             ; int
.text$mn:0000233D                 imul    edx, [ebp+var_4], 18h
.text$mn:00002341                 add     edx, [ebp+arg_0]
.text$mn:00002344                 push    edx             ; int
.text$mn:00002345                 movzx   eax, [ebp+arg_10]
.text$mn:00002349                 push    eax             ; char
.text$mn:0000234A                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:0000234F                 add     esp, 14h
.text$mn:00002352                 movzx   ecx, al
.text$mn:00002355                 test    ecx, ecx
.text$mn:00002357                 jz      short loc_2362
.text$mn:00002359                 mov     edx, [ebp+var_4]
.text$mn:0000235C                 sub     edx, 1
.text$mn:0000235F                 mov     [ebp+var_4], edx
.text$mn:00002362
.text$mn:00002362 loc_2362:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+5Fj
.text$mn:00002362                 imul    eax, [ebp+var_4], 18h
.text$mn:00002366                 add     eax, [ebp+arg_0]
.text$mn:00002369                 push    eax
.text$mn:0000236A                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000236F                 add     esp, 4
.text$mn:00002372                 imul    ecx, [ebp+arg_4], 18h
.text$mn:00002376                 add     ecx, [ebp+arg_0]
.text$mn:00002379                 mov     edx, [eax]
.text$mn:0000237B                 mov     [ecx], edx
.text$mn:0000237D                 mov     edx, [eax+4]
.text$mn:00002380                 mov     [ecx+4], edx
.text$mn:00002383                 mov     edx, [eax+8]
.text$mn:00002386                 mov     [ecx+8], edx
.text$mn:00002389                 mov     edx, [eax+0Ch]
.text$mn:0000238C                 mov     [ecx+0Ch], edx
.text$mn:0000238F                 mov     edx, [eax+10h]
.text$mn:00002392                 mov     [ecx+10h], edx
.text$mn:00002395                 mov     eax, [eax+14h]
.text$mn:00002398                 mov     [ecx+14h], eax
.text$mn:0000239B                 mov     ecx, [ebp+var_4]
.text$mn:0000239E                 mov     [ebp+arg_4], ecx
.text$mn:000023A1                 jmp     loc_2310
.text$mn:000023A6 ; ---------------------------------------------------------------------------
.text$mn:000023A6
.text$mn:000023A6 loc_23A6:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+28j
.text$mn:000023A6                 mov     edx, [ebp+var_4]
.text$mn:000023A9                 cmp     edx, [ebp+arg_8]
.text$mn:000023AC                 jnz     short loc_23F5
.text$mn:000023AE                 mov     eax, [ebp+arg_8]
.text$mn:000023B1                 sub     eax, 1
.text$mn:000023B4                 imul    ecx, eax, 18h
.text$mn:000023B7                 add     ecx, [ebp+arg_0]
.text$mn:000023BA                 push    ecx
.text$mn:000023BB                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000023C0                 add     esp, 4
.text$mn:000023C3                 imul    edx, [ebp+arg_4], 18h
.text$mn:000023C7                 add     edx, [ebp+arg_0]
.text$mn:000023CA                 mov     ecx, [eax]
.text$mn:000023CC                 mov     [edx], ecx
.text$mn:000023CE                 mov     ecx, [eax+4]
.text$mn:000023D1                 mov     [edx+4], ecx
.text$mn:000023D4                 mov     ecx, [eax+8]
.text$mn:000023D7                 mov     [edx+8], ecx
.text$mn:000023DA                 mov     ecx, [eax+0Ch]
.text$mn:000023DD                 mov     [edx+0Ch], ecx
.text$mn:000023E0                 mov     ecx, [eax+10h]
.text$mn:000023E3                 mov     [edx+10h], ecx
.text$mn:000023E6                 mov     eax, [eax+14h]
.text$mn:000023E9                 mov     [edx+14h], eax
.text$mn:000023EC                 mov     ecx, [ebp+arg_8]
.text$mn:000023EF                 sub     ecx, 1
.text$mn:000023F2                 mov     [ebp+arg_4], ecx
.text$mn:000023F5
.text$mn:000023F5 loc_23F5:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+B4j
.text$mn:000023F5                 movzx   edx, [ebp+arg_10]
.text$mn:000023F9                 push    edx
.text$mn:000023FA                 mov     eax, [ebp+arg_C]
.text$mn:000023FD                 push    eax
.text$mn:000023FE                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002403                 add     esp, 4
.text$mn:00002406                 push    eax
.text$mn:00002407                 mov     ecx, [ebp+var_8]
.text$mn:0000240A                 push    ecx
.text$mn:0000240B                 mov     edx, [ebp+arg_4]
.text$mn:0000240E                 push    edx
.text$mn:0000240F                 mov     eax, [ebp+arg_0]
.text$mn:00002412                 push    eax
.text$mn:00002413                 call    ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z ; std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)
.text$mn:00002418                 add     esp, 14h
.text$mn:0000241B                 mov     esp, ebp
.text$mn:0000241D                 pop     ebp
.text$mn:0000241E                 retn
.text$mn:0000241E ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z endp
.text$mn:0000241E
.text$mn:0000241E ; ---------------------------------------------------------------------------
.text$mn:0000241F                 align 10h
.text$mn:0000241F _text$mn        ends
.text$mn:0000241F
.text$mn:00002420 ; ===========================================================================
.text$mn:00002420
.text$mn:00002420 ; Segment type: Pure code
.text$mn:00002420 ; Segment permissions: Read/Execute
.text$mn:00002420 _text$mn        segment para public 'CODE' use32
.text$mn:00002420                 assume cs:_text$mn
.text$mn:00002420                 ;org 2420h
.text$mn:00002420 ; COMDAT (pick any)
.text$mn:00002420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002420
.text$mn:00002420 ; =============== S U B R O U T I N E =======================================
.text$mn:00002420
.text$mn:00002420 ; Attributes: bp-based frame
.text$mn:00002420
.text$mn:00002420 ; void __cdecl std::_Adjust_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInSelectOrder>(struct ColumnModeInfo *, int, int, struct ColumnModeInfo &&, struct SortInSelectOrder)
.text$mn:00002420                 public ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z
.text$mn:00002420 ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z proc near
.text$mn:00002420                                         ; CODE XREF: std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,int *,ColumnModeInfo *)+82p
.text$mn:00002420                                         ; std::_Pop_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo &&,SortInSelectOrder,int *)+5Bp
.text$mn:00002420
.text$mn:00002420 var_8           = dword ptr -8
.text$mn:00002420 var_4           = dword ptr -4
.text$mn:00002420 arg_0           = dword ptr  8
.text$mn:00002420 arg_4           = dword ptr  0Ch
.text$mn:00002420 arg_8           = dword ptr  10h
.text$mn:00002420 arg_C           = dword ptr  14h
.text$mn:00002420 arg_10          = byte ptr  18h
.text$mn:00002420
.text$mn:00002420                 push    ebp
.text$mn:00002421                 mov     ebp, esp
.text$mn:00002423                 sub     esp, 8
.text$mn:00002426                 mov     eax, [ebp+arg_4]
.text$mn:00002429                 mov     [ebp+var_8], eax
.text$mn:0000242C                 mov     ecx, [ebp+arg_4]
.text$mn:0000242F                 lea     edx, [ecx+ecx+2]
.text$mn:00002433                 mov     [ebp+var_4], edx
.text$mn:00002436                 jmp     short loc_2442
.text$mn:00002438 ; ---------------------------------------------------------------------------
.text$mn:00002438
.text$mn:00002438 loc_2438:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+A9j
.text$mn:00002438                 mov     eax, [ebp+var_4]
.text$mn:0000243B                 lea     ecx, [eax+eax+2]
.text$mn:0000243F                 mov     [ebp+var_4], ecx
.text$mn:00002442
.text$mn:00002442 loc_2442:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+16j
.text$mn:00002442                 mov     edx, [ebp+var_4]
.text$mn:00002445                 cmp     edx, [ebp+arg_8]
.text$mn:00002448                 jge     loc_24CE
.text$mn:0000244E                 push    946h            ; unsigned int
.text$mn:00002453                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002458                 mov     eax, [ebp+var_4]
.text$mn:0000245B                 sub     eax, 1
.text$mn:0000245E                 imul    ecx, eax, 18h
.text$mn:00002461                 add     ecx, [ebp+arg_0]
.text$mn:00002464                 push    ecx             ; int
.text$mn:00002465                 imul    edx, [ebp+var_4], 18h
.text$mn:00002469                 add     edx, [ebp+arg_0]
.text$mn:0000246C                 push    edx             ; int
.text$mn:0000246D                 movzx   eax, [ebp+arg_10]
.text$mn:00002471                 push    eax             ; char
.text$mn:00002472                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00002477                 add     esp, 14h
.text$mn:0000247A                 movzx   ecx, al
.text$mn:0000247D                 test    ecx, ecx
.text$mn:0000247F                 jz      short loc_248A
.text$mn:00002481                 mov     edx, [ebp+var_4]
.text$mn:00002484                 sub     edx, 1
.text$mn:00002487                 mov     [ebp+var_4], edx
.text$mn:0000248A
.text$mn:0000248A loc_248A:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+5Fj
.text$mn:0000248A                 imul    eax, [ebp+var_4], 18h
.text$mn:0000248E                 add     eax, [ebp+arg_0]
.text$mn:00002491                 push    eax
.text$mn:00002492                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002497                 add     esp, 4
.text$mn:0000249A                 imul    ecx, [ebp+arg_4], 18h
.text$mn:0000249E                 add     ecx, [ebp+arg_0]
.text$mn:000024A1                 mov     edx, [eax]
.text$mn:000024A3                 mov     [ecx], edx
.text$mn:000024A5                 mov     edx, [eax+4]
.text$mn:000024A8                 mov     [ecx+4], edx
.text$mn:000024AB                 mov     edx, [eax+8]
.text$mn:000024AE                 mov     [ecx+8], edx
.text$mn:000024B1                 mov     edx, [eax+0Ch]
.text$mn:000024B4                 mov     [ecx+0Ch], edx
.text$mn:000024B7                 mov     edx, [eax+10h]
.text$mn:000024BA                 mov     [ecx+10h], edx
.text$mn:000024BD                 mov     eax, [eax+14h]
.text$mn:000024C0                 mov     [ecx+14h], eax
.text$mn:000024C3                 mov     ecx, [ebp+var_4]
.text$mn:000024C6                 mov     [ebp+arg_4], ecx
.text$mn:000024C9                 jmp     loc_2438
.text$mn:000024CE ; ---------------------------------------------------------------------------
.text$mn:000024CE
.text$mn:000024CE loc_24CE:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+28j
.text$mn:000024CE                 mov     edx, [ebp+var_4]
.text$mn:000024D1                 cmp     edx, [ebp+arg_8]
.text$mn:000024D4                 jnz     short loc_251D
.text$mn:000024D6                 mov     eax, [ebp+arg_8]
.text$mn:000024D9                 sub     eax, 1
.text$mn:000024DC                 imul    ecx, eax, 18h
.text$mn:000024DF                 add     ecx, [ebp+arg_0]
.text$mn:000024E2                 push    ecx
.text$mn:000024E3                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000024E8                 add     esp, 4
.text$mn:000024EB                 imul    edx, [ebp+arg_4], 18h
.text$mn:000024EF                 add     edx, [ebp+arg_0]
.text$mn:000024F2                 mov     ecx, [eax]
.text$mn:000024F4                 mov     [edx], ecx
.text$mn:000024F6                 mov     ecx, [eax+4]
.text$mn:000024F9                 mov     [edx+4], ecx
.text$mn:000024FC                 mov     ecx, [eax+8]
.text$mn:000024FF                 mov     [edx+8], ecx
.text$mn:00002502                 mov     ecx, [eax+0Ch]
.text$mn:00002505                 mov     [edx+0Ch], ecx
.text$mn:00002508                 mov     ecx, [eax+10h]
.text$mn:0000250B                 mov     [edx+10h], ecx
.text$mn:0000250E                 mov     eax, [eax+14h]
.text$mn:00002511                 mov     [edx+14h], eax
.text$mn:00002514                 mov     ecx, [ebp+arg_8]
.text$mn:00002517                 sub     ecx, 1
.text$mn:0000251A                 mov     [ebp+arg_4], ecx
.text$mn:0000251D
.text$mn:0000251D loc_251D:                               ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+B4j
.text$mn:0000251D                 movzx   edx, [ebp+arg_10]
.text$mn:00002521                 push    edx
.text$mn:00002522                 mov     eax, [ebp+arg_C]
.text$mn:00002525                 push    eax
.text$mn:00002526                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000252B                 add     esp, 4
.text$mn:0000252E                 push    eax
.text$mn:0000252F                 mov     ecx, [ebp+var_8]
.text$mn:00002532                 push    ecx
.text$mn:00002533                 mov     edx, [ebp+arg_4]
.text$mn:00002536                 push    edx
.text$mn:00002537                 mov     eax, [ebp+arg_0]
.text$mn:0000253A                 push    eax
.text$mn:0000253B                 call    ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z ; std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)
.text$mn:00002540                 add     esp, 14h
.text$mn:00002543                 mov     esp, ebp
.text$mn:00002545                 pop     ebp
.text$mn:00002546                 retn
.text$mn:00002546 ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z endp
.text$mn:00002546
.text$mn:00002546 ; ---------------------------------------------------------------------------
.text$mn:00002547                 align 4
.text$mn:00002547 _text$mn        ends
.text$mn:00002547
.text$mn:00002548 ; ===========================================================================
.text$mn:00002548
.text$mn:00002548 ; Segment type: Pure code
.text$mn:00002548 ; Segment permissions: Read/Execute
.text$mn:00002548 _text$mn        segment para public 'CODE' use32
.text$mn:00002548                 assume cs:_text$mn
.text$mn:00002548                 ;org 2548h
.text$mn:00002548 ; COMDAT (pick any)
.text$mn:00002548                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002548
.text$mn:00002548 ; =============== S U B R O U T I N E =======================================
.text$mn:00002548
.text$mn:00002548 ; Attributes: bp-based frame
.text$mn:00002548
.text$mn:00002548 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00002548                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00002548 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00002548                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00002548
.text$mn:00002548 var_4           = dword ptr -4
.text$mn:00002548 arg_0           = dword ptr  8
.text$mn:00002548
.text$mn:00002548                 push    ebp
.text$mn:00002549                 mov     ebp, esp
.text$mn:0000254B                 push    ecx
.text$mn:0000254C                 mov     [ebp+var_4], 0
.text$mn:00002553                 cmp     [ebp+arg_0], 0
.text$mn:00002557                 jnz     short loc_255B
.text$mn:00002559                 jmp     short loc_257B
.text$mn:0000255B ; ---------------------------------------------------------------------------
.text$mn:0000255B
.text$mn:0000255B loc_255B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000255B                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000255F                 ja      short loc_2576
.text$mn:00002561                 mov     eax, [ebp+arg_0]
.text$mn:00002564                 push    eax             ; unsigned int
.text$mn:00002565                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000256A                 add     esp, 4
.text$mn:0000256D                 mov     [ebp+var_4], eax
.text$mn:00002570                 cmp     [ebp+var_4], 0
.text$mn:00002574                 jnz     short loc_257B
.text$mn:00002576
.text$mn:00002576 loc_2576:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00002576                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000257B
.text$mn:0000257B loc_257B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000257B                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000257B                 mov     eax, [ebp+var_4]
.text$mn:0000257E                 mov     esp, ebp
.text$mn:00002580                 pop     ebp
.text$mn:00002581                 retn
.text$mn:00002581 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00002581
.text$mn:00002581 ; ---------------------------------------------------------------------------
.text$mn:00002582                 align 4
.text$mn:00002582 _text$mn        ends
.text$mn:00002582
.text$mn:00002584 ; ===========================================================================
.text$mn:00002584
.text$mn:00002584 ; Segment type: Pure code
.text$mn:00002584 ; Segment permissions: Read/Execute
.text$mn:00002584 _text$mn        segment para public 'CODE' use32
.text$mn:00002584                 assume cs:_text$mn
.text$mn:00002584                 ;org 2584h
.text$mn:00002584 ; COMDAT (pick any)
.text$mn:00002584                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002584
.text$mn:00002584 ; =============== S U B R O U T I N E =======================================
.text$mn:00002584
.text$mn:00002584 ; Attributes: bp-based frame
.text$mn:00002584
.text$mn:00002584 ; int * __cdecl std::_Allocate<int>(unsigned int, int *)
.text$mn:00002584                 public ??$_Allocate@H@std@@YAPAHIPAH@Z
.text$mn:00002584 ??$_Allocate@H@std@@YAPAHIPAH@Z proc near
.text$mn:00002584                                         ; CODE XREF: std::allocator<int>::allocate(uint)+Dp
.text$mn:00002584
.text$mn:00002584 var_4           = dword ptr -4
.text$mn:00002584 arg_0           = dword ptr  8
.text$mn:00002584
.text$mn:00002584                 push    ebp
.text$mn:00002585                 mov     ebp, esp
.text$mn:00002587                 push    ecx
.text$mn:00002588                 mov     [ebp+var_4], 0
.text$mn:0000258F                 cmp     [ebp+arg_0], 0
.text$mn:00002593                 jnz     short loc_2597
.text$mn:00002595                 jmp     short loc_25BD
.text$mn:00002597 ; ---------------------------------------------------------------------------
.text$mn:00002597
.text$mn:00002597 loc_2597:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+Fj
.text$mn:00002597                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:0000259E                 ja      short loc_25B8
.text$mn:000025A0                 mov     eax, [ebp+arg_0]
.text$mn:000025A3                 shl     eax, 2
.text$mn:000025A6                 push    eax             ; unsigned int
.text$mn:000025A7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000025AC                 add     esp, 4
.text$mn:000025AF                 mov     [ebp+var_4], eax
.text$mn:000025B2                 cmp     [ebp+var_4], 0
.text$mn:000025B6                 jnz     short loc_25BD
.text$mn:000025B8
.text$mn:000025B8 loc_25B8:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+1Aj
.text$mn:000025B8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000025BD
.text$mn:000025BD loc_25BD:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+11j
.text$mn:000025BD                                         ; std::_Allocate<int>(uint,int *)+32j
.text$mn:000025BD                 mov     eax, [ebp+var_4]
.text$mn:000025C0                 mov     esp, ebp
.text$mn:000025C2                 pop     ebp
.text$mn:000025C3                 retn
.text$mn:000025C3 ??$_Allocate@H@std@@YAPAHIPAH@Z endp
.text$mn:000025C3
.text$mn:000025C3 _text$mn        ends
.text$mn:000025C3
.text$mn:000025C4 ; ===========================================================================
.text$mn:000025C4
.text$mn:000025C4 ; Segment type: Pure code
.text$mn:000025C4 ; Segment permissions: Read/Execute
.text$mn:000025C4 _text$mn        segment para public 'CODE' use32
.text$mn:000025C4                 assume cs:_text$mn
.text$mn:000025C4                 ;org 25C4h
.text$mn:000025C4 ; COMDAT (pick any)
.text$mn:000025C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025C4
.text$mn:000025C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025C4
.text$mn:000025C4 ; Attributes: bp-based frame
.text$mn:000025C4
.text$mn:000025C4 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000025C4                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000025C4 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000025C4                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000025C4
.text$mn:000025C4 var_4           = dword ptr -4
.text$mn:000025C4 arg_0           = dword ptr  8
.text$mn:000025C4
.text$mn:000025C4                 push    ebp
.text$mn:000025C5                 mov     ebp, esp
.text$mn:000025C7                 push    ecx
.text$mn:000025C8                 mov     [ebp+var_4], 0
.text$mn:000025CF                 cmp     [ebp+arg_0], 0
.text$mn:000025D3                 jnz     short loc_25D7
.text$mn:000025D5                 jmp     short loc_25FD
.text$mn:000025D7 ; ---------------------------------------------------------------------------
.text$mn:000025D7
.text$mn:000025D7 loc_25D7:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000025D7                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000025DE                 ja      short loc_25F8
.text$mn:000025E0                 mov     eax, [ebp+arg_0]
.text$mn:000025E3                 shl     eax, 3
.text$mn:000025E6                 push    eax             ; unsigned int
.text$mn:000025E7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000025EC                 add     esp, 4
.text$mn:000025EF                 mov     [ebp+var_4], eax
.text$mn:000025F2                 cmp     [ebp+var_4], 0
.text$mn:000025F6                 jnz     short loc_25FD
.text$mn:000025F8
.text$mn:000025F8 loc_25F8:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000025F8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000025FD
.text$mn:000025FD loc_25FD:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000025FD                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000025FD                 mov     eax, [ebp+var_4]
.text$mn:00002600                 mov     esp, ebp
.text$mn:00002602                 pop     ebp
.text$mn:00002603                 retn
.text$mn:00002603 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00002603
.text$mn:00002603 _text$mn        ends
.text$mn:00002603
.text$mn:00002604 ; ===========================================================================
.text$mn:00002604
.text$mn:00002604 ; Segment type: Pure code
.text$mn:00002604 ; Segment permissions: Read/Execute
.text$mn:00002604 _text$mn        segment para public 'CODE' use32
.text$mn:00002604                 assume cs:_text$mn
.text$mn:00002604                 ;org 2604h
.text$mn:00002604 ; COMDAT (pick any)
.text$mn:00002604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002604
.text$mn:00002604 ; =============== S U B R O U T I N E =======================================
.text$mn:00002604
.text$mn:00002604 ; Attributes: bp-based frame
.text$mn:00002604
.text$mn:00002604 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00002604                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00002604 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00002604                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00002604
.text$mn:00002604 var_4           = dword ptr -4
.text$mn:00002604 arg_0           = dword ptr  8
.text$mn:00002604
.text$mn:00002604                 push    ebp
.text$mn:00002605                 mov     ebp, esp
.text$mn:00002607                 push    ecx
.text$mn:00002608                 mov     [ebp+var_4], 0
.text$mn:0000260F                 cmp     [ebp+arg_0], 0
.text$mn:00002613                 jnz     short loc_2617
.text$mn:00002615                 jmp     short loc_263C
.text$mn:00002617 ; ---------------------------------------------------------------------------
.text$mn:00002617
.text$mn:00002617 loc_2617:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00002617                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:0000261E                 ja      short loc_2637
.text$mn:00002620                 mov     eax, [ebp+arg_0]
.text$mn:00002623                 shl     eax, 1
.text$mn:00002625                 push    eax             ; unsigned int
.text$mn:00002626                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000262B                 add     esp, 4
.text$mn:0000262E                 mov     [ebp+var_4], eax
.text$mn:00002631                 cmp     [ebp+var_4], 0
.text$mn:00002635                 jnz     short loc_263C
.text$mn:00002637
.text$mn:00002637 loc_2637:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00002637                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000263C
.text$mn:0000263C loc_263C:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:0000263C                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:0000263C                 mov     eax, [ebp+var_4]
.text$mn:0000263F                 mov     esp, ebp
.text$mn:00002641                 pop     ebp
.text$mn:00002642                 retn
.text$mn:00002642 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00002642
.text$mn:00002642 ; ---------------------------------------------------------------------------
.text$mn:00002643                 align 4
.text$mn:00002643 _text$mn        ends
.text$mn:00002643
.text$mn:00002644 ; ===========================================================================
.text$mn:00002644
.text$mn:00002644 ; Segment type: Pure code
.text$mn:00002644 ; Segment permissions: Read/Execute
.text$mn:00002644 _text$mn        segment para public 'CODE' use32
.text$mn:00002644                 assume cs:_text$mn
.text$mn:00002644                 ;org 2644h
.text$mn:00002644 ; COMDAT (pick any)
.text$mn:00002644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002644
.text$mn:00002644 ; =============== S U B R O U T I N E =======================================
.text$mn:00002644
.text$mn:00002644 ; Attributes: bp-based frame
.text$mn:00002644
.text$mn:00002644 ; void __cdecl std::_Debug_heap<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:00002644                 public ??$_Debug_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z
.text$mn:00002644 ??$_Debug_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z proc near
.text$mn:00002644                                         ; CODE XREF: std::sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+52p
.text$mn:00002644
.text$mn:00002644 var_4           = dword ptr -4
.text$mn:00002644 arg_0           = dword ptr  8
.text$mn:00002644 arg_4           = dword ptr  0Ch
.text$mn:00002644 arg_8           = byte ptr  10h
.text$mn:00002644
.text$mn:00002644                 push    ebp
.text$mn:00002645                 mov     ebp, esp
.text$mn:00002647                 push    ecx
.text$mn:00002648                 mov     eax, [ebp+arg_0]
.text$mn:0000264B                 cmp     eax, [ebp+arg_4]
.text$mn:0000264E                 jz      loc_2710
.text$mn:00002654                 mov     ecx, [ebp+arg_0]
.text$mn:00002657                 mov     [ebp+var_4], ecx
.text$mn:0000265A                 jmp     short loc_2665
.text$mn:0000265C ; ---------------------------------------------------------------------------
.text$mn:0000265C
.text$mn:0000265C loc_265C:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder):loc_270Bj
.text$mn:0000265C                 mov     edx, [ebp+var_4]
.text$mn:0000265F                 add     edx, 18h
.text$mn:00002662                 mov     [ebp+var_4], edx
.text$mn:00002665
.text$mn:00002665 loc_2665:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+16j
.text$mn:00002665                 mov     eax, [ebp+arg_0]
.text$mn:00002668                 add     eax, 18h
.text$mn:0000266B                 mov     [ebp+arg_0], eax
.text$mn:0000266E                 mov     ecx, [ebp+arg_0]
.text$mn:00002671                 cmp     ecx, [ebp+arg_4]
.text$mn:00002674                 jz      loc_2710
.text$mn:0000267A                 push    8F0h            ; unsigned int
.text$mn:0000267F                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002684                 mov     edx, [ebp+arg_0]
.text$mn:00002687                 push    edx             ; int
.text$mn:00002688                 mov     eax, [ebp+var_4]
.text$mn:0000268B                 push    eax             ; int
.text$mn:0000268C                 movzx   ecx, [ebp+arg_8]
.text$mn:00002690                 push    ecx             ; char
.text$mn:00002691                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00002696                 add     esp, 14h
.text$mn:00002699                 movzx   edx, al
.text$mn:0000269C                 test    edx, edx
.text$mn:0000269E                 jz      short loc_26B9
.text$mn:000026A0                 push    8F1h            ; unsigned int
.text$mn:000026A5                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000026AA                 push    offset ??_C@_1BK@KAECGCDK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAh?$AAe?$AAa?$AAp?$AA?$AA@ ; "invalid heap"
.text$mn:000026AF                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000026B4                 add     esp, 0Ch
.text$mn:000026B7                 jmp     short loc_270B
.text$mn:000026B9 ; ---------------------------------------------------------------------------
.text$mn:000026B9
.text$mn:000026B9 loc_26B9:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+5Aj
.text$mn:000026B9                 mov     eax, [ebp+arg_0]
.text$mn:000026BC                 add     eax, 18h
.text$mn:000026BF                 mov     [ebp+arg_0], eax
.text$mn:000026C2                 mov     ecx, [ebp+arg_0]
.text$mn:000026C5                 cmp     ecx, [ebp+arg_4]
.text$mn:000026C8                 jnz     short loc_26CE
.text$mn:000026CA                 jmp     short loc_2710
.text$mn:000026CC ; ---------------------------------------------------------------------------
.text$mn:000026CC                 jmp     short loc_270B
.text$mn:000026CE ; ---------------------------------------------------------------------------
.text$mn:000026CE
.text$mn:000026CE loc_26CE:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+84j
.text$mn:000026CE                 push    8F4h            ; unsigned int
.text$mn:000026D3                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000026D8                 mov     edx, [ebp+arg_0]
.text$mn:000026DB                 push    edx             ; int
.text$mn:000026DC                 mov     eax, [ebp+var_4]
.text$mn:000026DF                 push    eax             ; int
.text$mn:000026E0                 movzx   ecx, [ebp+arg_8]
.text$mn:000026E4                 push    ecx             ; char
.text$mn:000026E5                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000026EA                 add     esp, 14h
.text$mn:000026ED                 movzx   edx, al
.text$mn:000026F0                 test    edx, edx
.text$mn:000026F2                 jz      short loc_270B
.text$mn:000026F4                 push    8F5h            ; unsigned int
.text$mn:000026F9                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000026FE                 push    offset ??_C@_1BK@KAECGCDK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAh?$AAe?$AAa?$AAp?$AA?$AA@ ; "invalid heap"
.text$mn:00002703                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002708                 add     esp, 0Ch
.text$mn:0000270B
.text$mn:0000270B loc_270B:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+73j
.text$mn:0000270B                                         ; std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+88j ...
.text$mn:0000270B                 jmp     loc_265C
.text$mn:00002710 ; ---------------------------------------------------------------------------
.text$mn:00002710
.text$mn:00002710 loc_2710:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+Aj
.text$mn:00002710                                         ; std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+30j ...
.text$mn:00002710                 mov     esp, ebp
.text$mn:00002712                 pop     ebp
.text$mn:00002713                 retn
.text$mn:00002713 ??$_Debug_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z endp
.text$mn:00002713
.text$mn:00002713 _text$mn        ends
.text$mn:00002713
.text$mn:00002714 ; ===========================================================================
.text$mn:00002714
.text$mn:00002714 ; Segment type: Pure code
.text$mn:00002714 ; Segment permissions: Read/Execute
.text$mn:00002714 _text$mn        segment para public 'CODE' use32
.text$mn:00002714                 assume cs:_text$mn
.text$mn:00002714                 ;org 2714h
.text$mn:00002714 ; COMDAT (pick any)
.text$mn:00002714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002714
.text$mn:00002714 ; =============== S U B R O U T I N E =======================================
.text$mn:00002714
.text$mn:00002714 ; Attributes: bp-based frame
.text$mn:00002714
.text$mn:00002714 ; void __cdecl std::_Debug_heap<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:00002714                 public ??$_Debug_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z
.text$mn:00002714 ??$_Debug_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z proc near
.text$mn:00002714                                         ; CODE XREF: std::sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+52p
.text$mn:00002714
.text$mn:00002714 var_4           = dword ptr -4
.text$mn:00002714 arg_0           = dword ptr  8
.text$mn:00002714 arg_4           = dword ptr  0Ch
.text$mn:00002714 arg_8           = byte ptr  10h
.text$mn:00002714
.text$mn:00002714                 push    ebp
.text$mn:00002715                 mov     ebp, esp
.text$mn:00002717                 push    ecx
.text$mn:00002718                 mov     eax, [ebp+arg_0]
.text$mn:0000271B                 cmp     eax, [ebp+arg_4]
.text$mn:0000271E                 jz      loc_27E0
.text$mn:00002724                 mov     ecx, [ebp+arg_0]
.text$mn:00002727                 mov     [ebp+var_4], ecx
.text$mn:0000272A                 jmp     short loc_2735
.text$mn:0000272C ; ---------------------------------------------------------------------------
.text$mn:0000272C
.text$mn:0000272C loc_272C:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder):loc_27DBj
.text$mn:0000272C                 mov     edx, [ebp+var_4]
.text$mn:0000272F                 add     edx, 18h
.text$mn:00002732                 mov     [ebp+var_4], edx
.text$mn:00002735
.text$mn:00002735 loc_2735:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+16j
.text$mn:00002735                 mov     eax, [ebp+arg_0]
.text$mn:00002738                 add     eax, 18h
.text$mn:0000273B                 mov     [ebp+arg_0], eax
.text$mn:0000273E                 mov     ecx, [ebp+arg_0]
.text$mn:00002741                 cmp     ecx, [ebp+arg_4]
.text$mn:00002744                 jz      loc_27E0
.text$mn:0000274A                 push    8F0h            ; unsigned int
.text$mn:0000274F                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002754                 mov     edx, [ebp+arg_0]
.text$mn:00002757                 push    edx             ; int
.text$mn:00002758                 mov     eax, [ebp+var_4]
.text$mn:0000275B                 push    eax             ; int
.text$mn:0000275C                 movzx   ecx, [ebp+arg_8]
.text$mn:00002760                 push    ecx             ; char
.text$mn:00002761                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00002766                 add     esp, 14h
.text$mn:00002769                 movzx   edx, al
.text$mn:0000276C                 test    edx, edx
.text$mn:0000276E                 jz      short loc_2789
.text$mn:00002770                 push    8F1h            ; unsigned int
.text$mn:00002775                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000277A                 push    offset ??_C@_1BK@KAECGCDK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAh?$AAe?$AAa?$AAp?$AA?$AA@ ; "invalid heap"
.text$mn:0000277F                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002784                 add     esp, 0Ch
.text$mn:00002787                 jmp     short loc_27DB
.text$mn:00002789 ; ---------------------------------------------------------------------------
.text$mn:00002789
.text$mn:00002789 loc_2789:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+5Aj
.text$mn:00002789                 mov     eax, [ebp+arg_0]
.text$mn:0000278C                 add     eax, 18h
.text$mn:0000278F                 mov     [ebp+arg_0], eax
.text$mn:00002792                 mov     ecx, [ebp+arg_0]
.text$mn:00002795                 cmp     ecx, [ebp+arg_4]
.text$mn:00002798                 jnz     short loc_279E
.text$mn:0000279A                 jmp     short loc_27E0
.text$mn:0000279C ; ---------------------------------------------------------------------------
.text$mn:0000279C                 jmp     short loc_27DB
.text$mn:0000279E ; ---------------------------------------------------------------------------
.text$mn:0000279E
.text$mn:0000279E loc_279E:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+84j
.text$mn:0000279E                 push    8F4h            ; unsigned int
.text$mn:000027A3                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000027A8                 mov     edx, [ebp+arg_0]
.text$mn:000027AB                 push    edx             ; int
.text$mn:000027AC                 mov     eax, [ebp+var_4]
.text$mn:000027AF                 push    eax             ; int
.text$mn:000027B0                 movzx   ecx, [ebp+arg_8]
.text$mn:000027B4                 push    ecx             ; char
.text$mn:000027B5                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000027BA                 add     esp, 14h
.text$mn:000027BD                 movzx   edx, al
.text$mn:000027C0                 test    edx, edx
.text$mn:000027C2                 jz      short loc_27DB
.text$mn:000027C4                 push    8F5h            ; unsigned int
.text$mn:000027C9                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000027CE                 push    offset ??_C@_1BK@KAECGCDK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAh?$AAe?$AAa?$AAp?$AA?$AA@ ; "invalid heap"
.text$mn:000027D3                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000027D8                 add     esp, 0Ch
.text$mn:000027DB
.text$mn:000027DB loc_27DB:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+73j
.text$mn:000027DB                                         ; std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+88j ...
.text$mn:000027DB                 jmp     loc_272C
.text$mn:000027E0 ; ---------------------------------------------------------------------------
.text$mn:000027E0
.text$mn:000027E0 loc_27E0:                               ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+Aj
.text$mn:000027E0                                         ; std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+30j ...
.text$mn:000027E0                 mov     esp, ebp
.text$mn:000027E2                 pop     ebp
.text$mn:000027E3                 retn
.text$mn:000027E3 ??$_Debug_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z endp
.text$mn:000027E3
.text$mn:000027E3 _text$mn        ends
.text$mn:000027E3
.text$mn:000027E4 ; ===========================================================================
.text$mn:000027E4
.text$mn:000027E4 ; Segment type: Pure code
.text$mn:000027E4 ; Segment permissions: Read/Execute
.text$mn:000027E4 _text$mn        segment para public 'CODE' use32
.text$mn:000027E4                 assume cs:_text$mn
.text$mn:000027E4                 ;org 27E4h
.text$mn:000027E4 ; COMDAT (pick any)
.text$mn:000027E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027E4
.text$mn:000027E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027E4
.text$mn:000027E4 ; Attributes: bp-based frame
.text$mn:000027E4
.text$mn:000027E4 ; int __cdecl std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(char, int, int, wchar_t *, unsigned int)
.text$mn:000027E4                 public ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z
.text$mn:000027E4 ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z proc near
.text$mn:000027E4                                         ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+52p
.text$mn:000027E4                                         ; std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+4Dp ...
.text$mn:000027E4
.text$mn:000027E4 arg_0           = byte ptr  8
.text$mn:000027E4 arg_4           = dword ptr  0Ch
.text$mn:000027E4 arg_8           = dword ptr  10h
.text$mn:000027E4 arg_C           = dword ptr  14h
.text$mn:000027E4 arg_10          = dword ptr  18h
.text$mn:000027E4
.text$mn:000027E4                 push    ebp
.text$mn:000027E5                 mov     ebp, esp
.text$mn:000027E7                 mov     eax, [ebp+arg_8]
.text$mn:000027EA                 push    eax
.text$mn:000027EB                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000027F0                 add     esp, 4
.text$mn:000027F3                 push    eax
.text$mn:000027F4                 mov     ecx, [ebp+arg_4]
.text$mn:000027F7                 push    ecx
.text$mn:000027F8                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000027FD                 add     esp, 4
.text$mn:00002800                 push    eax
.text$mn:00002801                 lea     ecx, [ebp+arg_0]
.text$mn:00002804                 call    ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:00002809                 movzx   edx, al
.text$mn:0000280C                 test    edx, edx
.text$mn:0000280E                 jnz     short loc_2816
.text$mn:00002810                 xor     al, al
.text$mn:00002812                 jmp     short loc_2856
.text$mn:00002814 ; ---------------------------------------------------------------------------
.text$mn:00002814                 jmp     short loc_2854
.text$mn:00002816 ; ---------------------------------------------------------------------------
.text$mn:00002816
.text$mn:00002816 loc_2816:                               ; CODE XREF: std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+2Aj
.text$mn:00002816                 mov     eax, [ebp+arg_4]
.text$mn:00002819                 push    eax
.text$mn:0000281A                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000281F                 add     esp, 4
.text$mn:00002822                 push    eax
.text$mn:00002823                 mov     ecx, [ebp+arg_8]
.text$mn:00002826                 push    ecx
.text$mn:00002827                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000282C                 add     esp, 4
.text$mn:0000282F                 push    eax
.text$mn:00002830                 lea     ecx, [ebp+arg_0]
.text$mn:00002833                 call    ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:00002838                 movzx   edx, al
.text$mn:0000283B                 test    edx, edx
.text$mn:0000283D                 jz      short loc_2854
.text$mn:0000283F                 mov     eax, [ebp+arg_10]
.text$mn:00002842                 push    eax             ; unsigned int
.text$mn:00002843                 mov     ecx, [ebp+arg_C]
.text$mn:00002846                 push    ecx             ; wchar_t *
.text$mn:00002847                 push    offset ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@ ; "invalid operator<"
.text$mn:0000284C                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002851                 add     esp, 0Ch
.text$mn:00002854
.text$mn:00002854 loc_2854:                               ; CODE XREF: std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+30j
.text$mn:00002854                                         ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+59j
.text$mn:00002854                 mov     al, 1
.text$mn:00002856
.text$mn:00002856 loc_2856:                               ; CODE XREF: std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+2Ej
.text$mn:00002856                 pop     ebp
.text$mn:00002857                 retn
.text$mn:00002857 ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z endp
.text$mn:00002857
.text$mn:00002857 _text$mn        ends
.text$mn:00002857
.text$mn:00002858 ; ===========================================================================
.text$mn:00002858
.text$mn:00002858 ; Segment type: Pure code
.text$mn:00002858 ; Segment permissions: Read/Execute
.text$mn:00002858 _text$mn        segment para public 'CODE' use32
.text$mn:00002858                 assume cs:_text$mn
.text$mn:00002858                 ;org 2858h
.text$mn:00002858 ; COMDAT (pick any)
.text$mn:00002858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002858
.text$mn:00002858 ; =============== S U B R O U T I N E =======================================
.text$mn:00002858
.text$mn:00002858 ; Attributes: bp-based frame
.text$mn:00002858
.text$mn:00002858 ; int __cdecl std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(char, int, int, wchar_t *, unsigned int)
.text$mn:00002858                 public ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z
.text$mn:00002858 ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z proc near
.text$mn:00002858                                         ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+52p
.text$mn:00002858                                         ; std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+4Dp ...
.text$mn:00002858
.text$mn:00002858 arg_0           = byte ptr  8
.text$mn:00002858 arg_4           = dword ptr  0Ch
.text$mn:00002858 arg_8           = dword ptr  10h
.text$mn:00002858 arg_C           = dword ptr  14h
.text$mn:00002858 arg_10          = dword ptr  18h
.text$mn:00002858
.text$mn:00002858                 push    ebp
.text$mn:00002859                 mov     ebp, esp
.text$mn:0000285B                 mov     eax, [ebp+arg_8]
.text$mn:0000285E                 push    eax
.text$mn:0000285F                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002864                 add     esp, 4
.text$mn:00002867                 push    eax
.text$mn:00002868                 mov     ecx, [ebp+arg_4]
.text$mn:0000286B                 push    ecx
.text$mn:0000286C                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002871                 add     esp, 4
.text$mn:00002874                 push    eax
.text$mn:00002875                 lea     ecx, [ebp+arg_0]
.text$mn:00002878                 call    ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:0000287D                 movzx   edx, al
.text$mn:00002880                 test    edx, edx
.text$mn:00002882                 jnz     short loc_288A
.text$mn:00002884                 xor     al, al
.text$mn:00002886                 jmp     short loc_28CA
.text$mn:00002888 ; ---------------------------------------------------------------------------
.text$mn:00002888                 jmp     short loc_28C8
.text$mn:0000288A ; ---------------------------------------------------------------------------
.text$mn:0000288A
.text$mn:0000288A loc_288A:                               ; CODE XREF: std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+2Aj
.text$mn:0000288A                 mov     eax, [ebp+arg_4]
.text$mn:0000288D                 push    eax
.text$mn:0000288E                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002893                 add     esp, 4
.text$mn:00002896                 push    eax
.text$mn:00002897                 mov     ecx, [ebp+arg_8]
.text$mn:0000289A                 push    ecx
.text$mn:0000289B                 call    ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z ; std::forward<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000028A0                 add     esp, 4
.text$mn:000028A3                 push    eax
.text$mn:000028A4                 lea     ecx, [ebp+arg_0]
.text$mn:000028A7                 call    ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:000028AC                 movzx   edx, al
.text$mn:000028AF                 test    edx, edx
.text$mn:000028B1                 jz      short loc_28C8
.text$mn:000028B3                 mov     eax, [ebp+arg_10]
.text$mn:000028B6                 push    eax             ; unsigned int
.text$mn:000028B7                 mov     ecx, [ebp+arg_C]
.text$mn:000028BA                 push    ecx             ; wchar_t *
.text$mn:000028BB                 push    offset ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@ ; "invalid operator<"
.text$mn:000028C0                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000028C5                 add     esp, 0Ch
.text$mn:000028C8
.text$mn:000028C8 loc_28C8:                               ; CODE XREF: std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+30j
.text$mn:000028C8                                         ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+59j
.text$mn:000028C8                 mov     al, 1
.text$mn:000028CA
.text$mn:000028CA loc_28CA:                               ; CODE XREF: std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+2Ej
.text$mn:000028CA                 pop     ebp
.text$mn:000028CB                 retn
.text$mn:000028CB ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z endp
.text$mn:000028CB
.text$mn:000028CB _text$mn        ends
.text$mn:000028CB
.text$mn:000028CC ; ===========================================================================
.text$mn:000028CC
.text$mn:000028CC ; Segment type: Pure code
.text$mn:000028CC ; Segment permissions: Read/Execute
.text$mn:000028CC _text$mn        segment para public 'CODE' use32
.text$mn:000028CC                 assume cs:_text$mn
.text$mn:000028CC                 ;org 28CCh
.text$mn:000028CC ; COMDAT (pick any)
.text$mn:000028CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028CC
.text$mn:000028CC ; =============== S U B R O U T I N E =======================================
.text$mn:000028CC
.text$mn:000028CC ; Attributes: bp-based frame
.text$mn:000028CC
.text$mn:000028CC ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000028CC                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000028CC ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000028CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000028CC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000028CC
.text$mn:000028CC arg_0           = dword ptr  8
.text$mn:000028CC arg_4           = dword ptr  0Ch
.text$mn:000028CC arg_8           = dword ptr  10h
.text$mn:000028CC
.text$mn:000028CC                 push    ebp
.text$mn:000028CD                 mov     ebp, esp
.text$mn:000028CF                 cmp     [ebp+arg_0], 0
.text$mn:000028D3                 jnz     short loc_28EA
.text$mn:000028D5                 mov     eax, [ebp+arg_8]
.text$mn:000028D8                 push    eax             ; unsigned int
.text$mn:000028D9                 mov     ecx, [ebp+arg_4]
.text$mn:000028DC                 push    ecx             ; wchar_t *
.text$mn:000028DD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000028E2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000028E7                 add     esp, 0Ch
.text$mn:000028EA
.text$mn:000028EA loc_28EA:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000028EA                 pop     ebp
.text$mn:000028EB                 retn
.text$mn:000028EB ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000028EB
.text$mn:000028EB _text$mn        ends
.text$mn:000028EB
.text$mn:000028EC ; ===========================================================================
.text$mn:000028EC
.text$mn:000028EC ; Segment type: Pure code
.text$mn:000028EC ; Segment permissions: Read/Execute
.text$mn:000028EC _text$mn        segment para public 'CODE' use32
.text$mn:000028EC                 assume cs:_text$mn
.text$mn:000028EC                 ;org 28ECh
.text$mn:000028EC ; COMDAT (pick any)
.text$mn:000028EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028EC
.text$mn:000028EC ; =============== S U B R O U T I N E =======================================
.text$mn:000028EC
.text$mn:000028EC ; Attributes: bp-based frame
.text$mn:000028EC
.text$mn:000028EC ; int __cdecl std::_Debug_pointer<int>(int, wchar_t *, unsigned int)
.text$mn:000028EC                 public ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z
.text$mn:000028EC ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z proc near
.text$mn:000028EC                                         ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000028EC                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000028EC
.text$mn:000028EC arg_0           = dword ptr  8
.text$mn:000028EC arg_4           = dword ptr  0Ch
.text$mn:000028EC arg_8           = dword ptr  10h
.text$mn:000028EC
.text$mn:000028EC                 push    ebp
.text$mn:000028ED                 mov     ebp, esp
.text$mn:000028EF                 cmp     [ebp+arg_0], 0
.text$mn:000028F3                 jnz     short loc_290A
.text$mn:000028F5                 mov     eax, [ebp+arg_8]
.text$mn:000028F8                 push    eax             ; unsigned int
.text$mn:000028F9                 mov     ecx, [ebp+arg_4]
.text$mn:000028FC                 push    ecx             ; wchar_t *
.text$mn:000028FD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002902                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002907                 add     esp, 0Ch
.text$mn:0000290A
.text$mn:0000290A loc_290A:                               ; CODE XREF: std::_Debug_pointer<int>(int *,wchar_t const *,uint)+7j
.text$mn:0000290A                 pop     ebp
.text$mn:0000290B                 retn
.text$mn:0000290B ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z endp
.text$mn:0000290B
.text$mn:0000290B _text$mn        ends
.text$mn:0000290B
.text$mn:0000290C ; ===========================================================================
.text$mn:0000290C
.text$mn:0000290C ; Segment type: Pure code
.text$mn:0000290C ; Segment permissions: Read/Execute
.text$mn:0000290C _text$mn        segment para public 'CODE' use32
.text$mn:0000290C                 assume cs:_text$mn
.text$mn:0000290C                 ;org 290Ch
.text$mn:0000290C ; COMDAT (pick any)
.text$mn:0000290C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000290C
.text$mn:0000290C ; =============== S U B R O U T I N E =======================================
.text$mn:0000290C
.text$mn:0000290C ; Attributes: bp-based frame
.text$mn:0000290C
.text$mn:0000290C ; int __cdecl std::_Debug_pointer<ColumnModeInfo>(int, wchar_t *, unsigned int)
.text$mn:0000290C                 public ??$_Debug_pointer@UColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@PB_WI@Z
.text$mn:0000290C ??$_Debug_pointer@UColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@PB_WI@Z proc near
.text$mn:0000290C                                         ; CODE XREF: std::_Debug_range2<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000290C                                         ; std::_Debug_range2<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:0000290C
.text$mn:0000290C arg_0           = dword ptr  8
.text$mn:0000290C arg_4           = dword ptr  0Ch
.text$mn:0000290C arg_8           = dword ptr  10h
.text$mn:0000290C
.text$mn:0000290C                 push    ebp
.text$mn:0000290D                 mov     ebp, esp
.text$mn:0000290F                 cmp     [ebp+arg_0], 0
.text$mn:00002913                 jnz     short loc_292A
.text$mn:00002915                 mov     eax, [ebp+arg_8]
.text$mn:00002918                 push    eax             ; unsigned int
.text$mn:00002919                 mov     ecx, [ebp+arg_4]
.text$mn:0000291C                 push    ecx             ; wchar_t *
.text$mn:0000291D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002922                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002927                 add     esp, 0Ch
.text$mn:0000292A
.text$mn:0000292A loc_292A:                               ; CODE XREF: std::_Debug_pointer<ColumnModeInfo>(ColumnModeInfo *,wchar_t const *,uint)+7j
.text$mn:0000292A                 pop     ebp
.text$mn:0000292B                 retn
.text$mn:0000292B ??$_Debug_pointer@UColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@PB_WI@Z endp
.text$mn:0000292B
.text$mn:0000292B _text$mn        ends
.text$mn:0000292B
.text$mn:0000292C ; ===========================================================================
.text$mn:0000292C
.text$mn:0000292C ; Segment type: Pure code
.text$mn:0000292C ; Segment permissions: Read/Execute
.text$mn:0000292C _text$mn        segment para public 'CODE' use32
.text$mn:0000292C                 assume cs:_text$mn
.text$mn:0000292C                 ;org 292Ch
.text$mn:0000292C ; COMDAT (pick any)
.text$mn:0000292C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000292C
.text$mn:0000292C ; =============== S U B R O U T I N E =======================================
.text$mn:0000292C
.text$mn:0000292C ; Attributes: bp-based frame
.text$mn:0000292C
.text$mn:0000292C ; void __cdecl std::_Debug_pointer<struct SortInPositionOrder>(struct SortInPositionOrder &, wchar_t const *, unsigned int)
.text$mn:0000292C                 public ??$_Debug_pointer@USortInPositionOrder@@@std@@YAXAAUSortInPositionOrder@@PB_WI@Z
.text$mn:0000292C ??$_Debug_pointer@USortInPositionOrder@@@std@@YAXAAUSortInPositionOrder@@PB_WI@Z proc near
.text$mn:0000292C                                         ; CODE XREF: std::make_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+2Bp
.text$mn:0000292C                                         ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)+8Cp ...
.text$mn:0000292C                 push    ebp
.text$mn:0000292D                 mov     ebp, esp
.text$mn:0000292F                 pop     ebp
.text$mn:00002930                 retn
.text$mn:00002930 ??$_Debug_pointer@USortInPositionOrder@@@std@@YAXAAUSortInPositionOrder@@PB_WI@Z endp
.text$mn:00002930
.text$mn:00002930 ; ---------------------------------------------------------------------------
.text$mn:00002931                 align 4
.text$mn:00002931 _text$mn        ends
.text$mn:00002931
.text$mn:00002934 ; ===========================================================================
.text$mn:00002934
.text$mn:00002934 ; Segment type: Pure code
.text$mn:00002934 ; Segment permissions: Read/Execute
.text$mn:00002934 _text$mn        segment para public 'CODE' use32
.text$mn:00002934                 assume cs:_text$mn
.text$mn:00002934                 ;org 2934h
.text$mn:00002934 ; COMDAT (pick any)
.text$mn:00002934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002934
.text$mn:00002934 ; =============== S U B R O U T I N E =======================================
.text$mn:00002934
.text$mn:00002934 ; Attributes: bp-based frame
.text$mn:00002934
.text$mn:00002934 ; void __cdecl std::_Debug_pointer<struct SortInSelectOrder>(struct SortInSelectOrder &, wchar_t const *, unsigned int)
.text$mn:00002934                 public ??$_Debug_pointer@USortInSelectOrder@@@std@@YAXAAUSortInSelectOrder@@PB_WI@Z
.text$mn:00002934 ??$_Debug_pointer@USortInSelectOrder@@@std@@YAXAAUSortInSelectOrder@@PB_WI@Z proc near
.text$mn:00002934                                         ; CODE XREF: std::make_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+2Bp
.text$mn:00002934                                         ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder)+8Cp ...
.text$mn:00002934                 push    ebp
.text$mn:00002935                 mov     ebp, esp
.text$mn:00002937                 pop     ebp
.text$mn:00002938                 retn
.text$mn:00002938 ??$_Debug_pointer@USortInSelectOrder@@@std@@YAXAAUSortInSelectOrder@@PB_WI@Z endp
.text$mn:00002938
.text$mn:00002938 ; ---------------------------------------------------------------------------
.text$mn:00002939                 align 4
.text$mn:00002939 _text$mn        ends
.text$mn:00002939
.text$mn:0000293C ; ===========================================================================
.text$mn:0000293C
.text$mn:0000293C ; Segment type: Pure code
.text$mn:0000293C ; Segment permissions: Read/Execute
.text$mn:0000293C _text$mn        segment para public 'CODE' use32
.text$mn:0000293C                 assume cs:_text$mn
.text$mn:0000293C                 ;org 293Ch
.text$mn:0000293C ; COMDAT (pick any)
.text$mn:0000293C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000293C
.text$mn:0000293C ; =============== S U B R O U T I N E =======================================
.text$mn:0000293C
.text$mn:0000293C ; Attributes: bp-based frame
.text$mn:0000293C
.text$mn:0000293C ; void __cdecl std::_Debug_pointer<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>> &, wchar_t const *, unsigned int)
.text$mn:0000293C                 public ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@PB_WI@Z
.text$mn:0000293C ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@PB_WI@Z proc near
.text$mn:0000293C                                         ; CODE XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+48p
.text$mn:0000293C                                         ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5Cp
.text$mn:0000293C                 push    ebp
.text$mn:0000293D                 mov     ebp, esp
.text$mn:0000293F                 pop     ebp
.text$mn:00002940                 retn
.text$mn:00002940 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@PB_WI@Z endp
.text$mn:00002940
.text$mn:00002940 ; ---------------------------------------------------------------------------
.text$mn:00002941                 align 4
.text$mn:00002941 _text$mn        ends
.text$mn:00002941
.text$mn:00002944 ; ===========================================================================
.text$mn:00002944
.text$mn:00002944 ; Segment type: Pure code
.text$mn:00002944 ; Segment permissions: Read/Execute
.text$mn:00002944 _text$mn        segment para public 'CODE' use32
.text$mn:00002944                 assume cs:_text$mn
.text$mn:00002944                 ;org 2944h
.text$mn:00002944 ; COMDAT (pick any)
.text$mn:00002944                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002944
.text$mn:00002944 ; =============== S U B R O U T I N E =======================================
.text$mn:00002944
.text$mn:00002944 ; Attributes: bp-based frame
.text$mn:00002944
.text$mn:00002944 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00002944                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00002944 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00002944                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:00002944                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:00002944
.text$mn:00002944 arg_0           = dword ptr  8
.text$mn:00002944 arg_4           = dword ptr  0Ch
.text$mn:00002944 arg_8           = dword ptr  10h
.text$mn:00002944
.text$mn:00002944                 push    ebp
.text$mn:00002945                 mov     ebp, esp
.text$mn:00002947                 cmp     [ebp+arg_0], 0
.text$mn:0000294B                 jnz     short loc_2962
.text$mn:0000294D                 mov     eax, [ebp+arg_8]
.text$mn:00002950                 push    eax             ; unsigned int
.text$mn:00002951                 mov     ecx, [ebp+arg_4]
.text$mn:00002954                 push    ecx             ; wchar_t *
.text$mn:00002955                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000295A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000295F                 add     esp, 0Ch
.text$mn:00002962
.text$mn:00002962 loc_2962:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:00002962                 pop     ebp
.text$mn:00002963                 retn
.text$mn:00002963 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:00002963
.text$mn:00002963 _text$mn        ends
.text$mn:00002963
.text$mn:00002964 ; ===========================================================================
.text$mn:00002964
.text$mn:00002964 ; Segment type: Pure code
.text$mn:00002964 ; Segment permissions: Read/Execute
.text$mn:00002964 _text$mn        segment para public 'CODE' use32
.text$mn:00002964                 assume cs:_text$mn
.text$mn:00002964                 ;org 2964h
.text$mn:00002964 ; COMDAT (pick any)
.text$mn:00002964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002964
.text$mn:00002964 ; =============== S U B R O U T I N E =======================================
.text$mn:00002964
.text$mn:00002964 ; Attributes: bp-based frame
.text$mn:00002964
.text$mn:00002964 ; int __cdecl std::_Debug_range2<int *>(int, int, wchar_t *, unsigned int)
.text$mn:00002964                 public ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002964 ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002964                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+2Ap
.text$mn:00002964
.text$mn:00002964 arg_0           = dword ptr  8
.text$mn:00002964 arg_4           = dword ptr  0Ch
.text$mn:00002964 arg_8           = dword ptr  10h
.text$mn:00002964 arg_C           = dword ptr  14h
.text$mn:00002964
.text$mn:00002964                 push    ebp
.text$mn:00002965                 mov     ebp, esp
.text$mn:00002967                 mov     eax, [ebp+arg_0]
.text$mn:0000296A                 cmp     eax, [ebp+arg_4]
.text$mn:0000296D                 jz      short loc_29B4
.text$mn:0000296F                 mov     ecx, [ebp+arg_C]
.text$mn:00002972                 push    ecx             ; unsigned int
.text$mn:00002973                 mov     edx, [ebp+arg_8]
.text$mn:00002976                 push    edx             ; wchar_t *
.text$mn:00002977                 mov     eax, [ebp+arg_0]
.text$mn:0000297A                 push    eax             ; int
.text$mn:0000297B                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00002980                 add     esp, 0Ch
.text$mn:00002983                 mov     ecx, [ebp+arg_C]
.text$mn:00002986                 push    ecx             ; unsigned int
.text$mn:00002987                 mov     edx, [ebp+arg_8]
.text$mn:0000298A                 push    edx             ; wchar_t *
.text$mn:0000298B                 mov     eax, [ebp+arg_4]
.text$mn:0000298E                 push    eax             ; int
.text$mn:0000298F                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00002994                 add     esp, 0Ch
.text$mn:00002997                 mov     ecx, [ebp+arg_4]
.text$mn:0000299A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000299D                 jnb     short loc_29B4
.text$mn:0000299F                 mov     edx, [ebp+arg_C]
.text$mn:000029A2                 push    edx             ; unsigned int
.text$mn:000029A3                 mov     eax, [ebp+arg_8]
.text$mn:000029A6                 push    eax             ; wchar_t *
.text$mn:000029A7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000029AC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000029B1                 add     esp, 0Ch
.text$mn:000029B4
.text$mn:000029B4 loc_29B4:                               ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000029B4                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000029B4                 pop     ebp
.text$mn:000029B5                 retn
.text$mn:000029B5 ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000029B5
.text$mn:000029B5 ; ---------------------------------------------------------------------------
.text$mn:000029B6                 align 4
.text$mn:000029B6 _text$mn        ends
.text$mn:000029B6
.text$mn:000029B8 ; ===========================================================================
.text$mn:000029B8
.text$mn:000029B8 ; Segment type: Pure code
.text$mn:000029B8 ; Segment permissions: Read/Execute
.text$mn:000029B8 _text$mn        segment para public 'CODE' use32
.text$mn:000029B8                 assume cs:_text$mn
.text$mn:000029B8                 ;org 29B8h
.text$mn:000029B8 ; COMDAT (pick any)
.text$mn:000029B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029B8
.text$mn:000029B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B8
.text$mn:000029B8 ; Attributes: bp-based frame
.text$mn:000029B8
.text$mn:000029B8 ; int __cdecl std::_Debug_range2<ColumnModeInfo *>(int, int, wchar_t *, unsigned int)
.text$mn:000029B8                 public ??$_Debug_range2@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000029B8 ??$_Debug_range2@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000029B8                                         ; CODE XREF: std::_Debug_range<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint)+2Ap
.text$mn:000029B8
.text$mn:000029B8 arg_0           = dword ptr  8
.text$mn:000029B8 arg_4           = dword ptr  0Ch
.text$mn:000029B8 arg_8           = dword ptr  10h
.text$mn:000029B8 arg_C           = dword ptr  14h
.text$mn:000029B8
.text$mn:000029B8                 push    ebp
.text$mn:000029B9                 mov     ebp, esp
.text$mn:000029BB                 mov     eax, [ebp+arg_0]
.text$mn:000029BE                 cmp     eax, [ebp+arg_4]
.text$mn:000029C1                 jz      short loc_2A08
.text$mn:000029C3                 mov     ecx, [ebp+arg_C]
.text$mn:000029C6                 push    ecx             ; unsigned int
.text$mn:000029C7                 mov     edx, [ebp+arg_8]
.text$mn:000029CA                 push    edx             ; wchar_t *
.text$mn:000029CB                 mov     eax, [ebp+arg_0]
.text$mn:000029CE                 push    eax             ; int
.text$mn:000029CF                 call    ??$_Debug_pointer@UColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@PB_WI@Z ; std::_Debug_pointer<ColumnModeInfo>(ColumnModeInfo *,wchar_t const *,uint)
.text$mn:000029D4                 add     esp, 0Ch
.text$mn:000029D7                 mov     ecx, [ebp+arg_C]
.text$mn:000029DA                 push    ecx             ; unsigned int
.text$mn:000029DB                 mov     edx, [ebp+arg_8]
.text$mn:000029DE                 push    edx             ; wchar_t *
.text$mn:000029DF                 mov     eax, [ebp+arg_4]
.text$mn:000029E2                 push    eax             ; int
.text$mn:000029E3                 call    ??$_Debug_pointer@UColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@PB_WI@Z ; std::_Debug_pointer<ColumnModeInfo>(ColumnModeInfo *,wchar_t const *,uint)
.text$mn:000029E8                 add     esp, 0Ch
.text$mn:000029EB                 mov     ecx, [ebp+arg_4]
.text$mn:000029EE                 cmp     ecx, [ebp+arg_0]
.text$mn:000029F1                 jnb     short loc_2A08
.text$mn:000029F3                 mov     edx, [ebp+arg_C]
.text$mn:000029F6                 push    edx             ; unsigned int
.text$mn:000029F7                 mov     eax, [ebp+arg_8]
.text$mn:000029FA                 push    eax             ; wchar_t *
.text$mn:000029FB                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002A00                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002A05                 add     esp, 0Ch
.text$mn:00002A08
.text$mn:00002A08 loc_2A08:                               ; CODE XREF: std::_Debug_range2<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002A08                                         ; std::_Debug_range2<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002A08                 pop     ebp
.text$mn:00002A09                 retn
.text$mn:00002A09 ??$_Debug_range2@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002A09
.text$mn:00002A09 ; ---------------------------------------------------------------------------
.text$mn:00002A0A                 align 4
.text$mn:00002A0A _text$mn        ends
.text$mn:00002A0A
.text$mn:00002A0C ; ===========================================================================
.text$mn:00002A0C
.text$mn:00002A0C ; Segment type: Pure code
.text$mn:00002A0C ; Segment permissions: Read/Execute
.text$mn:00002A0C _text$mn        segment para public 'CODE' use32
.text$mn:00002A0C                 assume cs:_text$mn
.text$mn:00002A0C                 ;org 2A0Ch
.text$mn:00002A0C ; COMDAT (pick any)
.text$mn:00002A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A0C
.text$mn:00002A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A0C
.text$mn:00002A0C ; Attributes: bp-based frame
.text$mn:00002A0C
.text$mn:00002A0C ; int __cdecl std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(char, int, int, char, int, int, wchar_t *, unsigned int)
.text$mn:00002A0C                 public ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002A0C ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002A0C                                         ; CODE XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint)+8Ap
.text$mn:00002A0C
.text$mn:00002A0C var_C           = dword ptr -0Ch
.text$mn:00002A0C var_4           = dword ptr -4
.text$mn:00002A0C arg_0           = byte ptr  8
.text$mn:00002A0C arg_C           = byte ptr  14h
.text$mn:00002A0C arg_18          = dword ptr  20h
.text$mn:00002A0C arg_1C          = dword ptr  24h
.text$mn:00002A0C
.text$mn:00002A0C                 push    ebp
.text$mn:00002A0D                 mov     ebp, esp
.text$mn:00002A0F                 push    0FFFFFFFFh
.text$mn:00002A11                 push    offset __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002A16                 mov     eax, large fs:0
.text$mn:00002A1C                 push    eax
.text$mn:00002A1D                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A22                 xor     eax, ebp
.text$mn:00002A24                 push    eax
.text$mn:00002A25                 lea     eax, [ebp+var_C]
.text$mn:00002A28                 mov     large fs:0, eax
.text$mn:00002A2E                 mov     [ebp+var_4], 1
.text$mn:00002A35                 lea     eax, [ebp+arg_C]
.text$mn:00002A38                 push    eax             ; std::_Iterator_base12 *
.text$mn:00002A39                 lea     ecx, [ebp+arg_0]
.text$mn:00002A3C                 call    ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00002A41                 movzx   ecx, al
.text$mn:00002A44                 test    ecx, ecx
.text$mn:00002A46                 jz      short loc_2A98
.text$mn:00002A48                 mov     edx, [ebp+arg_1C]
.text$mn:00002A4B                 push    edx
.text$mn:00002A4C                 mov     eax, [ebp+arg_18]
.text$mn:00002A4F                 push    eax
.text$mn:00002A50                 lea     ecx, [ebp+arg_0]
.text$mn:00002A53                 push    ecx
.text$mn:00002A54                 call    ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> &,wchar_t const *,uint)
.text$mn:00002A59                 add     esp, 0Ch
.text$mn:00002A5C                 mov     edx, [ebp+arg_1C]
.text$mn:00002A5F                 push    edx
.text$mn:00002A60                 mov     eax, [ebp+arg_18]
.text$mn:00002A63                 push    eax
.text$mn:00002A64                 lea     ecx, [ebp+arg_C]
.text$mn:00002A67                 push    ecx
.text$mn:00002A68                 call    ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> &,wchar_t const *,uint)
.text$mn:00002A6D                 add     esp, 0Ch
.text$mn:00002A70                 lea     edx, [ebp+arg_0]
.text$mn:00002A73                 push    edx             ; std::_Iterator_base12 *
.text$mn:00002A74                 lea     ecx, [ebp+arg_C]
.text$mn:00002A77                 call    ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00002A7C                 movzx   eax, al
.text$mn:00002A7F                 test    eax, eax
.text$mn:00002A81                 jz      short loc_2A98
.text$mn:00002A83                 mov     ecx, [ebp+arg_1C]
.text$mn:00002A86                 push    ecx             ; unsigned int
.text$mn:00002A87                 mov     edx, [ebp+arg_18]
.text$mn:00002A8A                 push    edx             ; wchar_t *
.text$mn:00002A8B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002A90                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002A95                 add     esp, 0Ch
.text$mn:00002A98
.text$mn:00002A98 loc_2A98:                               ; CODE XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+3Aj
.text$mn:00002A98                                         ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+75j
.text$mn:00002A98                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002A9C                 lea     ecx, [ebp+arg_0]
.text$mn:00002A9F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00002AA4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002AAB                 lea     ecx, [ebp+arg_C]
.text$mn:00002AAE                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00002AB3                 mov     ecx, [ebp+var_C]
.text$mn:00002AB6                 mov     large fs:0, ecx
.text$mn:00002ABD                 pop     ecx
.text$mn:00002ABE                 mov     esp, ebp
.text$mn:00002AC0                 pop     ebp
.text$mn:00002AC1                 retn
.text$mn:00002AC1 ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002AC1
.text$mn:00002AC1 ; ---------------------------------------------------------------------------
.text$mn:00002AC2                 align 4
.text$mn:00002AC2 _text$mn        ends
.text$mn:00002AC2
.text$x:00002AC4 ; ===========================================================================
.text$x:00002AC4
.text$x:00002AC4 ; Segment type: Pure code
.text$x:00002AC4 ; Segment permissions: Read/Execute
.text$x:00002AC4 _text$x         segment para public 'CODE' use32
.text$x:00002AC4                 assume cs:_text$x
.text$x:00002AC4                 ;org 2AC4h
.text$x:00002AC4 ; COMDAT (pick associative to section at 2A0C)
.text$x:00002AC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AC4
.text$x:00002AC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AC4
.text$x:00002AC4
.text$x:00002AC4 __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:00002AC4                                         ; DATA XREF: .xdata$x:0000AD88o
.text$x:00002AC4                 lea     ecx, [ebp+14h]
.text$x:00002AC7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002AC7 __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:00002AC7
.text$x:00002ACC
.text$x:00002ACC ; =============== S U B R O U T I N E =======================================
.text$x:00002ACC
.text$x:00002ACC
.text$x:00002ACC __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:00002ACC                                         ; DATA XREF: .xdata$x:0000AD90o
.text$x:00002ACC                 lea     ecx, [ebp+8]
.text$x:00002ACF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002ACF __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:00002ACF
.text$x:00002AD4
.text$x:00002AD4 ; =============== S U B R O U T I N E =======================================
.text$x:00002AD4
.text$x:00002AD4
.text$x:00002AD4 __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$x:00002AD4                                         ; DATA XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5o
.text$x:00002AD4
.text$x:00002AD4 arg_4           = dword ptr  8
.text$x:00002AD4
.text$x:00002AD4                 mov     edx, [esp+arg_4]
.text$x:00002AD8                 lea     eax, [edx+0Ch]
.text$x:00002ADB                 mov     ecx, [edx-4]
.text$x:00002ADE                 xor     ecx, eax
.text$x:00002AE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AE5                 mov     eax, offset __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$x:00002AEA                 jmp     ___CxxFrameHandler3
.text$x:00002AEA __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$x:00002AEA
.text$x:00002AEA ; ---------------------------------------------------------------------------
.text$x:00002AEF                 align 10h
.text$x:00002AEF _text$x         ends
.text$x:00002AEF
.text$mn:00002AF0 ; ===========================================================================
.text$mn:00002AF0
.text$mn:00002AF0 ; Segment type: Pure code
.text$mn:00002AF0 ; Segment permissions: Read/Execute
.text$mn:00002AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AF0                 assume cs:_text$mn
.text$mn:00002AF0                 ;org 2AF0h
.text$mn:00002AF0 ; COMDAT (pick any)
.text$mn:00002AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AF0
.text$mn:00002AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AF0
.text$mn:00002AF0 ; Attributes: bp-based frame
.text$mn:00002AF0
.text$mn:00002AF0 ; int __cdecl std::_Debug_range<int *>(int, int, wchar_t *, unsigned int)
.text$mn:00002AF0                 public ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z
.text$mn:00002AF0 ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z proc near
.text$mn:00002AF0                                         ; CODE XREF: std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002AF0
.text$mn:00002AF0 var_1           = byte ptr -1
.text$mn:00002AF0 arg_0           = dword ptr  8
.text$mn:00002AF0 arg_4           = dword ptr  0Ch
.text$mn:00002AF0 arg_8           = dword ptr  10h
.text$mn:00002AF0 arg_C           = dword ptr  14h
.text$mn:00002AF0
.text$mn:00002AF0                 push    ebp
.text$mn:00002AF1                 mov     ebp, esp
.text$mn:00002AF3                 push    ecx
.text$mn:00002AF4                 lea     eax, [ebp+arg_0]
.text$mn:00002AF7                 push    eax
.text$mn:00002AF8                 lea     ecx, [ebp+var_1]
.text$mn:00002AFB                 push    ecx
.text$mn:00002AFC                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:00002B01                 add     esp, 8
.text$mn:00002B04                 mov     dl, [eax]
.text$mn:00002B06                 movzx   eax, dl
.text$mn:00002B09                 push    eax
.text$mn:00002B0A                 mov     ecx, [ebp+arg_C]
.text$mn:00002B0D                 push    ecx             ; unsigned int
.text$mn:00002B0E                 mov     edx, [ebp+arg_8]
.text$mn:00002B11                 push    edx             ; wchar_t *
.text$mn:00002B12                 mov     eax, [ebp+arg_4]
.text$mn:00002B15                 push    eax             ; int
.text$mn:00002B16                 mov     ecx, [ebp+arg_0]
.text$mn:00002B19                 push    ecx             ; int
.text$mn:00002B1A                 call    ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002B1F                 add     esp, 14h
.text$mn:00002B22                 mov     esp, ebp
.text$mn:00002B24                 pop     ebp
.text$mn:00002B25                 retn
.text$mn:00002B25 ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z endp
.text$mn:00002B25
.text$mn:00002B25 ; ---------------------------------------------------------------------------
.text$mn:00002B26                 align 4
.text$mn:00002B26 _text$mn        ends
.text$mn:00002B26
.text$mn:00002B28 ; ===========================================================================
.text$mn:00002B28
.text$mn:00002B28 ; Segment type: Pure code
.text$mn:00002B28 ; Segment permissions: Read/Execute
.text$mn:00002B28 _text$mn        segment para public 'CODE' use32
.text$mn:00002B28                 assume cs:_text$mn
.text$mn:00002B28                 ;org 2B28h
.text$mn:00002B28 ; COMDAT (pick any)
.text$mn:00002B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B28
.text$mn:00002B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B28
.text$mn:00002B28 ; Attributes: bp-based frame
.text$mn:00002B28
.text$mn:00002B28 ; int __cdecl std::_Debug_range<ColumnModeInfo *>(int, int, wchar_t *, unsigned int)
.text$mn:00002B28                 public ??$_Debug_range@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WI@Z
.text$mn:00002B28 ??$_Debug_range@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WI@Z proc near
.text$mn:00002B28                                         ; CODE XREF: std::make_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+15p
.text$mn:00002B28                                         ; std::make_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+15p ...
.text$mn:00002B28
.text$mn:00002B28 var_1           = byte ptr -1
.text$mn:00002B28 arg_0           = dword ptr  8
.text$mn:00002B28 arg_4           = dword ptr  0Ch
.text$mn:00002B28 arg_8           = dword ptr  10h
.text$mn:00002B28 arg_C           = dword ptr  14h
.text$mn:00002B28
.text$mn:00002B28                 push    ebp
.text$mn:00002B29                 mov     ebp, esp
.text$mn:00002B2B                 push    ecx
.text$mn:00002B2C                 lea     eax, [ebp+arg_0]
.text$mn:00002B2F                 push    eax
.text$mn:00002B30                 lea     ecx, [ebp+var_1]
.text$mn:00002B33                 push    ecx
.text$mn:00002B34                 call    ??$_Iter_cat@PAUColumnModeInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUColumnModeInfo@@@Z ; std::_Iter_cat<ColumnModeInfo *>(ColumnModeInfo * const &)
.text$mn:00002B39                 add     esp, 8
.text$mn:00002B3C                 mov     dl, [eax]
.text$mn:00002B3E                 movzx   eax, dl
.text$mn:00002B41                 push    eax
.text$mn:00002B42                 mov     ecx, [ebp+arg_C]
.text$mn:00002B45                 push    ecx             ; unsigned int
.text$mn:00002B46                 mov     edx, [ebp+arg_8]
.text$mn:00002B49                 push    edx             ; wchar_t *
.text$mn:00002B4A                 mov     eax, [ebp+arg_4]
.text$mn:00002B4D                 push    eax             ; int
.text$mn:00002B4E                 mov     ecx, [ebp+arg_0]
.text$mn:00002B51                 push    ecx             ; int
.text$mn:00002B52                 call    ??$_Debug_range2@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002B57                 add     esp, 14h
.text$mn:00002B5A                 mov     esp, ebp
.text$mn:00002B5C                 pop     ebp
.text$mn:00002B5D                 retn
.text$mn:00002B5D ??$_Debug_range@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WI@Z endp
.text$mn:00002B5D
.text$mn:00002B5D ; ---------------------------------------------------------------------------
.text$mn:00002B5E                 align 10h
.text$mn:00002B5E _text$mn        ends
.text$mn:00002B5E
.text$mn:00002B60 ; ===========================================================================
.text$mn:00002B60
.text$mn:00002B60 ; Segment type: Pure code
.text$mn:00002B60 ; Segment permissions: Read/Execute
.text$mn:00002B60 _text$mn        segment para public 'CODE' use32
.text$mn:00002B60                 assume cs:_text$mn
.text$mn:00002B60                 ;org 2B60h
.text$mn:00002B60 ; COMDAT (pick any)
.text$mn:00002B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B60
.text$mn:00002B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B60
.text$mn:00002B60 ; Attributes: bp-based frame
.text$mn:00002B60
.text$mn:00002B60 ; int __cdecl std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(char, int, int, int, int, int, wchar_t *, unsigned int)
.text$mn:00002B60                 public ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z
.text$mn:00002B60 ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z proc near
.text$mn:00002B60                                         ; CODE XREF: std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)+76p
.text$mn:00002B60                                         ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder)+76p
.text$mn:00002B60
.text$mn:00002B60 var_28          = dword ptr -28h
.text$mn:00002B60 var_24          = dword ptr -24h
.text$mn:00002B60 var_20          = dword ptr -20h
.text$mn:00002B60 var_1C          = dword ptr -1Ch
.text$mn:00002B60 var_18          = dword ptr -18h
.text$mn:00002B60 var_14          = dword ptr -14h
.text$mn:00002B60 var_D           = byte ptr -0Dh
.text$mn:00002B60 var_C           = dword ptr -0Ch
.text$mn:00002B60 var_4           = dword ptr -4
.text$mn:00002B60 arg_0           = byte ptr  8
.text$mn:00002B60 arg_C           = dword ptr  14h
.text$mn:00002B60 arg_18          = dword ptr  20h
.text$mn:00002B60 arg_1C          = dword ptr  24h
.text$mn:00002B60
.text$mn:00002B60                 push    ebp
.text$mn:00002B61                 mov     ebp, esp
.text$mn:00002B63                 push    0FFFFFFFFh
.text$mn:00002B65                 push    offset __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z
.text$mn:00002B6A                 mov     eax, large fs:0
.text$mn:00002B70                 push    eax
.text$mn:00002B71                 sub     esp, 1Ch
.text$mn:00002B74                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B79                 xor     eax, ebp
.text$mn:00002B7B                 push    eax
.text$mn:00002B7C                 lea     eax, [ebp+var_C]
.text$mn:00002B7F                 mov     large fs:0, eax
.text$mn:00002B85                 mov     [ebp+var_4], 1
.text$mn:00002B8C                 lea     eax, [ebp+arg_0]
.text$mn:00002B8F                 push    eax
.text$mn:00002B90                 lea     ecx, [ebp+var_D]
.text$mn:00002B93                 push    ecx
.text$mn:00002B94                 call    ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00002B99                 add     esp, 8
.text$mn:00002B9C                 mov     dl, [eax]
.text$mn:00002B9E                 movzx   eax, dl
.text$mn:00002BA1                 push    eax
.text$mn:00002BA2                 mov     ecx, [ebp+arg_1C]
.text$mn:00002BA5                 push    ecx             ; unsigned int
.text$mn:00002BA6                 mov     edx, [ebp+arg_18]
.text$mn:00002BA9                 push    edx             ; wchar_t *
.text$mn:00002BAA                 sub     esp, 0Ch
.text$mn:00002BAD                 mov     ecx, esp
.text$mn:00002BAF                 mov     [ebp+var_1C], esp
.text$mn:00002BB2                 lea     eax, [ebp+arg_C]
.text$mn:00002BB5                 push    eax             ; int
.text$mn:00002BB6                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00002BBB                 mov     [ebp+var_14], eax
.text$mn:00002BBE                 mov     ecx, [ebp+var_14]
.text$mn:00002BC1                 mov     [ebp+var_20], ecx
.text$mn:00002BC4                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002BC8                 sub     esp, 0Ch
.text$mn:00002BCB                 mov     ecx, esp
.text$mn:00002BCD                 mov     [ebp+var_24], esp
.text$mn:00002BD0                 lea     edx, [ebp+arg_0]
.text$mn:00002BD3                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00002BD4                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00002BD9                 mov     [ebp+var_18], eax
.text$mn:00002BDC                 mov     eax, [ebp+var_18]
.text$mn:00002BDF                 mov     [ebp+var_28], eax
.text$mn:00002BE2                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002BE6                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002BEA                 call    ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002BEF                 add     esp, 24h
.text$mn:00002BF2                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002BF6                 lea     ecx, [ebp+arg_0]
.text$mn:00002BF9                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00002BFE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C05                 lea     ecx, [ebp+arg_C]
.text$mn:00002C08                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00002C0D                 mov     ecx, [ebp+var_C]
.text$mn:00002C10                 mov     large fs:0, ecx
.text$mn:00002C17                 pop     ecx
.text$mn:00002C18                 mov     esp, ebp
.text$mn:00002C1A                 pop     ebp
.text$mn:00002C1B                 retn
.text$mn:00002C1B ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z endp
.text$mn:00002C1B
.text$mn:00002C1B _text$mn        ends
.text$mn:00002C1B
.text$x:00002C1C ; ===========================================================================
.text$x:00002C1C
.text$x:00002C1C ; Segment type: Pure code
.text$x:00002C1C ; Segment permissions: Read/Execute
.text$x:00002C1C _text$x         segment para public 'CODE' use32
.text$x:00002C1C                 assume cs:_text$x
.text$x:00002C1C                 ;org 2C1Ch
.text$x:00002C1C ; COMDAT (pick associative to section at 2B60)
.text$x:00002C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002C1C
.text$x:00002C1C ; =============== S U B R O U T I N E =======================================
.text$x:00002C1C
.text$x:00002C1C
.text$x:00002C1C __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$0 proc near
.text$x:00002C1C                                         ; DATA XREF: .xdata$x:0000AD18o
.text$x:00002C1C                 lea     ecx, [ebp+14h]
.text$x:00002C1F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002C1F __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$0 endp
.text$x:00002C1F
.text$x:00002C24
.text$x:00002C24 ; =============== S U B R O U T I N E =======================================
.text$x:00002C24
.text$x:00002C24
.text$x:00002C24 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$1 proc near
.text$x:00002C24                                         ; DATA XREF: .xdata$x:0000AD20o
.text$x:00002C24                 lea     ecx, [ebp+8]
.text$x:00002C27                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002C27 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$1 endp
.text$x:00002C27
.text$x:00002C2C
.text$x:00002C2C ; =============== S U B R O U T I N E =======================================
.text$x:00002C2C
.text$x:00002C2C
.text$x:00002C2C __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$2 proc near
.text$x:00002C2C                                         ; DATA XREF: .xdata$x:0000AD28o
.text$x:00002C2C                 mov     ecx, [ebp-1Ch]
.text$x:00002C2F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002C2F __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$2 endp
.text$x:00002C2F
.text$x:00002C34
.text$x:00002C34 ; =============== S U B R O U T I N E =======================================
.text$x:00002C34
.text$x:00002C34
.text$x:00002C34 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$3 proc near
.text$x:00002C34                                         ; DATA XREF: .xdata$x:0000AD30o
.text$x:00002C34                 mov     ecx, [ebp-24h]
.text$x:00002C37                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00002C37 __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$3 endp
.text$x:00002C37
.text$x:00002C3C
.text$x:00002C3C ; =============== S U B R O U T I N E =======================================
.text$x:00002C3C
.text$x:00002C3C
.text$x:00002C3C __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z proc near
.text$x:00002C3C                                         ; DATA XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint)+5o
.text$x:00002C3C
.text$x:00002C3C arg_4           = dword ptr  8
.text$x:00002C3C
.text$x:00002C3C                 mov     edx, [esp+arg_4]
.text$x:00002C40                 lea     eax, [edx+0Ch]
.text$x:00002C43                 mov     ecx, [edx-20h]
.text$x:00002C46                 xor     ecx, eax
.text$x:00002C48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C4D                 mov     eax, offset __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z
.text$x:00002C52                 jmp     ___CxxFrameHandler3
.text$x:00002C52 __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z endp
.text$x:00002C52
.text$x:00002C52 ; ---------------------------------------------------------------------------
.text$x:00002C57                 align 4
.text$x:00002C57 _text$x         ends
.text$x:00002C57
.text$mn:00002C58 ; ===========================================================================
.text$mn:00002C58
.text$mn:00002C58 ; Segment type: Pure code
.text$mn:00002C58 ; Segment permissions: Read/Execute
.text$mn:00002C58 _text$mn        segment para public 'CODE' use32
.text$mn:00002C58                 assume cs:_text$mn
.text$mn:00002C58                 ;org 2C58h
.text$mn:00002C58 ; COMDAT (pick any)
.text$mn:00002C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C58
.text$mn:00002C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C58
.text$mn:00002C58 ; Attributes: bp-based frame
.text$mn:00002C58
.text$mn:00002C58 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:00002C58                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00002C58 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00002C58                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+21p
.text$mn:00002C58
.text$mn:00002C58 var_1           = byte ptr -1
.text$mn:00002C58 arg_0           = dword ptr  8
.text$mn:00002C58 arg_4           = dword ptr  0Ch
.text$mn:00002C58 arg_8           = dword ptr  10h
.text$mn:00002C58
.text$mn:00002C58                 push    ebp
.text$mn:00002C59                 mov     ebp, esp
.text$mn:00002C5B                 push    ecx
.text$mn:00002C5C                 mov     eax, [ebp+arg_4]
.text$mn:00002C5F                 push    eax
.text$mn:00002C60                 mov     ecx, [ebp+arg_0]
.text$mn:00002C63                 push    ecx
.text$mn:00002C64                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00002C69                 add     esp, 8
.text$mn:00002C6C                 mov     [ebp+var_1], al
.text$mn:00002C6F                 movzx   edx, [ebp+var_1]
.text$mn:00002C73                 push    edx
.text$mn:00002C74                 mov     eax, [ebp+arg_8]
.text$mn:00002C77                 push    eax
.text$mn:00002C78                 mov     ecx, [ebp+arg_4]
.text$mn:00002C7B                 push    ecx
.text$mn:00002C7C                 mov     edx, [ebp+arg_0]
.text$mn:00002C7F                 push    edx
.text$mn:00002C80                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002C85                 add     esp, 10h
.text$mn:00002C88                 mov     esp, ebp
.text$mn:00002C8A                 pop     ebp
.text$mn:00002C8B                 retn
.text$mn:00002C8B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00002C8B
.text$mn:00002C8B _text$mn        ends
.text$mn:00002C8B
.text$mn:00002C8C ; ===========================================================================
.text$mn:00002C8C
.text$mn:00002C8C ; Segment type: Pure code
.text$mn:00002C8C ; Segment permissions: Read/Execute
.text$mn:00002C8C _text$mn        segment para public 'CODE' use32
.text$mn:00002C8C                 assume cs:_text$mn
.text$mn:00002C8C                 ;org 2C8Ch
.text$mn:00002C8C ; COMDAT (pick any)
.text$mn:00002C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C8C
.text$mn:00002C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C8C
.text$mn:00002C8C ; Attributes: bp-based frame
.text$mn:00002C8C
.text$mn:00002C8C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00002C8C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002C8C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002C8C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+28p
.text$mn:00002C8C                 push    ebp
.text$mn:00002C8D                 mov     ebp, esp
.text$mn:00002C8F                 pop     ebp
.text$mn:00002C90                 retn
.text$mn:00002C90 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002C90
.text$mn:00002C90 ; ---------------------------------------------------------------------------
.text$mn:00002C91                 align 4
.text$mn:00002C91 _text$mn        ends
.text$mn:00002C91
.text$mn:00002C94 ; ===========================================================================
.text$mn:00002C94
.text$mn:00002C94 ; Segment type: Pure code
.text$mn:00002C94 ; Segment permissions: Read/Execute
.text$mn:00002C94 _text$mn        segment para public 'CODE' use32
.text$mn:00002C94                 assume cs:_text$mn
.text$mn:00002C94                 ;org 2C94h
.text$mn:00002C94 ; COMDAT (pick any)
.text$mn:00002C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C94
.text$mn:00002C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C94
.text$mn:00002C94 ; Attributes: bp-based frame
.text$mn:00002C94
.text$mn:00002C94 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>>>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct std::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>> &)
.text$mn:00002C94                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@@Z
.text$mn:00002C94 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@@Z proc near
.text$mn:00002C94                                         ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Destroy(ColumnModeInfo *,ColumnModeInfo *)+21p
.text$mn:00002C94
.text$mn:00002C94 var_1           = byte ptr -1
.text$mn:00002C94 arg_0           = dword ptr  8
.text$mn:00002C94 arg_4           = dword ptr  0Ch
.text$mn:00002C94 arg_8           = dword ptr  10h
.text$mn:00002C94
.text$mn:00002C94                 push    ebp
.text$mn:00002C95                 mov     ebp, esp
.text$mn:00002C97                 push    ecx
.text$mn:00002C98                 mov     eax, [ebp+arg_4]
.text$mn:00002C9B                 push    eax
.text$mn:00002C9C                 mov     ecx, [ebp+arg_0]
.text$mn:00002C9F                 push    ecx
.text$mn:00002CA0                 call    ??$_Ptr_cat@UColumnModeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUColumnModeInfo@@0@Z ; std::_Ptr_cat<ColumnModeInfo,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00002CA5                 add     esp, 8
.text$mn:00002CA8                 mov     [ebp+var_1], al
.text$mn:00002CAB                 movzx   edx, [ebp+var_1]
.text$mn:00002CAF                 push    edx
.text$mn:00002CB0                 mov     eax, [ebp+arg_8]
.text$mn:00002CB3                 push    eax
.text$mn:00002CB4                 mov     ecx, [ebp+arg_4]
.text$mn:00002CB7                 push    ecx
.text$mn:00002CB8                 mov     edx, [ebp+arg_0]
.text$mn:00002CBB                 push    edx
.text$mn:00002CBC                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002CC1                 add     esp, 10h
.text$mn:00002CC4                 mov     esp, ebp
.text$mn:00002CC6                 pop     ebp
.text$mn:00002CC7                 retn
.text$mn:00002CC7 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@@Z endp
.text$mn:00002CC7
.text$mn:00002CC7 _text$mn        ends
.text$mn:00002CC7
.text$mn:00002CC8 ; ===========================================================================
.text$mn:00002CC8
.text$mn:00002CC8 ; Segment type: Pure code
.text$mn:00002CC8 ; Segment permissions: Read/Execute
.text$mn:00002CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CC8                 assume cs:_text$mn
.text$mn:00002CC8                 ;org 2CC8h
.text$mn:00002CC8 ; COMDAT (pick any)
.text$mn:00002CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CC8
.text$mn:00002CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CC8
.text$mn:00002CC8 ; Attributes: bp-based frame
.text$mn:00002CC8
.text$mn:00002CC8 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>>>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct std::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002CC8                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002CC8 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002CC8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &)+28p
.text$mn:00002CC8
.text$mn:00002CC8 arg_0           = dword ptr  8
.text$mn:00002CC8 arg_4           = dword ptr  0Ch
.text$mn:00002CC8 arg_8           = dword ptr  10h
.text$mn:00002CC8
.text$mn:00002CC8                 push    ebp
.text$mn:00002CC9                 mov     ebp, esp
.text$mn:00002CCB                 jmp     short loc_2CD6
.text$mn:00002CCD ; ---------------------------------------------------------------------------
.text$mn:00002CCD
.text$mn:00002CCD loc_2CCD:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00002CCD                 mov     eax, [ebp+arg_0]
.text$mn:00002CD0                 add     eax, 18h
.text$mn:00002CD3                 mov     [ebp+arg_0], eax
.text$mn:00002CD6
.text$mn:00002CD6 loc_2CD6:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00002CD6                 mov     ecx, [ebp+arg_0]
.text$mn:00002CD9                 cmp     ecx, [ebp+arg_4]
.text$mn:00002CDC                 jz      short loc_2CEC
.text$mn:00002CDE                 mov     edx, [ebp+arg_0]
.text$mn:00002CE1                 push    edx
.text$mn:00002CE2                 mov     ecx, [ebp+arg_8]
.text$mn:00002CE5                 call    ??$destroy@UColumnModeInfo@@@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@@Z ; std::_Wrap_alloc<std::allocator<ColumnModeInfo>>::destroy<ColumnModeInfo>(ColumnModeInfo *)
.text$mn:00002CEA                 jmp     short loc_2CCD
.text$mn:00002CEC ; ---------------------------------------------------------------------------
.text$mn:00002CEC
.text$mn:00002CEC loc_2CEC:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00002CEC                 pop     ebp
.text$mn:00002CED                 retn
.text$mn:00002CED ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002CED
.text$mn:00002CED ; ---------------------------------------------------------------------------
.text$mn:00002CEE                 align 10h
.text$mn:00002CEE _text$mn        ends
.text$mn:00002CEE
.text$mn:00002CF0 ; ===========================================================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Segment type: Pure code
.text$mn:00002CF0 ; Segment permissions: Read/Execute
.text$mn:00002CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CF0                 assume cs:_text$mn
.text$mn:00002CF0                 ;org 2CF0h
.text$mn:00002CF0 ; COMDAT (pick any)
.text$mn:00002CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CF0
.text$mn:00002CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Attributes: bp-based frame
.text$mn:00002CF0
.text$mn:00002CF0 ; int * __cdecl std::_Dist_type<struct ColumnModeInfo *>(struct ColumnModeInfo *)
.text$mn:00002CF0                 public ??$_Dist_type@PAUColumnModeInfo@@@std@@YAPAHPAUColumnModeInfo@@@Z
.text$mn:00002CF0 ??$_Dist_type@PAUColumnModeInfo@@@std@@YAPAHPAUColumnModeInfo@@@Z proc near
.text$mn:00002CF0                                         ; CODE XREF: std::_Pop_heap_0<ColumnModeInfo *,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+3Cp
.text$mn:00002CF0                                         ; std::_Pop_heap_0<ColumnModeInfo *,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+3Cp ...
.text$mn:00002CF0                 push    ebp
.text$mn:00002CF1                 mov     ebp, esp
.text$mn:00002CF3                 xor     eax, eax
.text$mn:00002CF5                 pop     ebp
.text$mn:00002CF6                 retn
.text$mn:00002CF6 ??$_Dist_type@PAUColumnModeInfo@@@std@@YAPAHPAUColumnModeInfo@@@Z endp
.text$mn:00002CF6
.text$mn:00002CF6 ; ---------------------------------------------------------------------------
.text$mn:00002CF7                 align 4
.text$mn:00002CF7 _text$mn        ends
.text$mn:00002CF7
.text$mn:00002CF8 ; ===========================================================================
.text$mn:00002CF8
.text$mn:00002CF8 ; Segment type: Pure code
.text$mn:00002CF8 ; Segment permissions: Read/Execute
.text$mn:00002CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CF8                 assume cs:_text$mn
.text$mn:00002CF8                 ;org 2CF8h
.text$mn:00002CF8 ; COMDAT (pick any)
.text$mn:00002CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CF8
.text$mn:00002CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF8
.text$mn:00002CF8 ; Attributes: bp-based frame
.text$mn:00002CF8
.text$mn:00002CF8 ; void __cdecl std::_Insertion_sort1<struct ColumnModeInfo *, struct SortInPositionOrder, struct ColumnModeInfo>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder, struct ColumnModeInfo *)
.text$mn:00002CF8                 public ??$_Insertion_sort1@PAUColumnModeInfo@@USortInPositionOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z
.text$mn:00002CF8 ??$_Insertion_sort1@PAUColumnModeInfo@@USortInPositionOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z proc near
.text$mn:00002CF8                                         ; CODE XREF: std::_Insertion_sort<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+1Dp
.text$mn:00002CF8
.text$mn:00002CF8 var_24          = dword ptr -24h
.text$mn:00002CF8 var_20          = dword ptr -20h
.text$mn:00002CF8 var_1C          = dword ptr -1Ch
.text$mn:00002CF8 var_18          = dword ptr -18h
.text$mn:00002CF8 var_14          = dword ptr -14h
.text$mn:00002CF8 var_10          = dword ptr -10h
.text$mn:00002CF8 var_C           = dword ptr -0Ch
.text$mn:00002CF8 var_8           = dword ptr -8
.text$mn:00002CF8 var_4           = dword ptr -4
.text$mn:00002CF8 arg_0           = dword ptr  8
.text$mn:00002CF8 arg_4           = dword ptr  0Ch
.text$mn:00002CF8 arg_8           = byte ptr  10h
.text$mn:00002CF8
.text$mn:00002CF8                 push    ebp
.text$mn:00002CF9                 mov     ebp, esp
.text$mn:00002CFB                 sub     esp, 24h
.text$mn:00002CFE                 mov     eax, [ebp+arg_0]
.text$mn:00002D01                 cmp     eax, [ebp+arg_4]
.text$mn:00002D04                 jz      loc_2E79
.text$mn:00002D0A                 mov     ecx, [ebp+arg_0]
.text$mn:00002D0D                 mov     [ebp+var_8], ecx
.text$mn:00002D10
.text$mn:00002D10 loc_2D10:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *):loc_2E74j
.text$mn:00002D10                 mov     edx, [ebp+var_8]
.text$mn:00002D13                 add     edx, 18h
.text$mn:00002D16                 mov     [ebp+var_8], edx
.text$mn:00002D19                 mov     eax, [ebp+var_8]
.text$mn:00002D1C                 cmp     eax, [ebp+arg_4]
.text$mn:00002D1F                 jz      loc_2E79
.text$mn:00002D25                 mov     ecx, [ebp+var_8]
.text$mn:00002D28                 mov     [ebp+var_4], ecx
.text$mn:00002D2B                 mov     edx, [ebp+var_8]
.text$mn:00002D2E                 push    edx
.text$mn:00002D2F                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002D34                 add     esp, 4
.text$mn:00002D37                 mov     ecx, [eax]
.text$mn:00002D39                 mov     [ebp+var_24], ecx
.text$mn:00002D3C                 mov     edx, [eax+4]
.text$mn:00002D3F                 mov     [ebp+var_20], edx
.text$mn:00002D42                 mov     ecx, [eax+8]
.text$mn:00002D45                 mov     [ebp+var_1C], ecx
.text$mn:00002D48                 mov     edx, [eax+0Ch]
.text$mn:00002D4B                 mov     [ebp+var_18], edx
.text$mn:00002D4E                 mov     ecx, [eax+10h]
.text$mn:00002D51                 mov     [ebp+var_14], ecx
.text$mn:00002D54                 mov     edx, [eax+14h]
.text$mn:00002D57                 mov     [ebp+var_10], edx
.text$mn:00002D5A                 push    0BBEh           ; unsigned int
.text$mn:00002D5F                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002D64                 mov     eax, [ebp+arg_0]
.text$mn:00002D67                 push    eax             ; int
.text$mn:00002D68                 lea     ecx, [ebp+var_24]
.text$mn:00002D6B                 push    ecx             ; int
.text$mn:00002D6C                 movzx   edx, [ebp+arg_8]
.text$mn:00002D70                 push    edx             ; char
.text$mn:00002D71                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00002D76                 add     esp, 14h
.text$mn:00002D79                 movzx   eax, al
.text$mn:00002D7C                 test    eax, eax
.text$mn:00002D7E                 jz      short loc_2DD3
.text$mn:00002D80                 mov     ecx, [ebp+var_4]
.text$mn:00002D83                 add     ecx, 18h
.text$mn:00002D86                 mov     [ebp+var_4], ecx
.text$mn:00002D89                 mov     edx, [ebp+var_4]
.text$mn:00002D8C                 push    edx
.text$mn:00002D8D                 mov     eax, [ebp+var_8]
.text$mn:00002D90                 push    eax
.text$mn:00002D91                 mov     ecx, [ebp+arg_0]
.text$mn:00002D94                 push    ecx
.text$mn:00002D95                 call    ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00@Z ; std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00002D9A                 add     esp, 0Ch
.text$mn:00002D9D                 lea     edx, [ebp+var_24]
.text$mn:00002DA0                 push    edx
.text$mn:00002DA1                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002DA6                 add     esp, 4
.text$mn:00002DA9                 mov     ecx, [ebp+arg_0]
.text$mn:00002DAC                 mov     edx, [eax]
.text$mn:00002DAE                 mov     [ecx], edx
.text$mn:00002DB0                 mov     edx, [eax+4]
.text$mn:00002DB3                 mov     [ecx+4], edx
.text$mn:00002DB6                 mov     edx, [eax+8]
.text$mn:00002DB9                 mov     [ecx+8], edx
.text$mn:00002DBC                 mov     edx, [eax+0Ch]
.text$mn:00002DBF                 mov     [ecx+0Ch], edx
.text$mn:00002DC2                 mov     edx, [eax+10h]
.text$mn:00002DC5                 mov     [ecx+10h], edx
.text$mn:00002DC8                 mov     eax, [eax+14h]
.text$mn:00002DCB                 mov     [ecx+14h], eax
.text$mn:00002DCE                 jmp     loc_2E74
.text$mn:00002DD3 ; ---------------------------------------------------------------------------
.text$mn:00002DD3
.text$mn:00002DD3 loc_2DD3:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+86j
.text$mn:00002DD3                 mov     ecx, [ebp+var_4]
.text$mn:00002DD6                 mov     [ebp+var_C], ecx
.text$mn:00002DD9                 jmp     short loc_2DE1
.text$mn:00002DDB ; ---------------------------------------------------------------------------
.text$mn:00002DDB
.text$mn:00002DDB loc_2DDB:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+149j
.text$mn:00002DDB                 mov     edx, [ebp+var_C]
.text$mn:00002DDE                 mov     [ebp+var_4], edx
.text$mn:00002DE1
.text$mn:00002DE1 loc_2DE1:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+E1j
.text$mn:00002DE1                 mov     eax, [ebp+var_C]
.text$mn:00002DE4                 sub     eax, 18h
.text$mn:00002DE7                 mov     [ebp+var_C], eax
.text$mn:00002DEA                 push    0BC6h           ; unsigned int
.text$mn:00002DEF                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002DF4                 mov     ecx, [ebp+var_C]
.text$mn:00002DF7                 push    ecx             ; int
.text$mn:00002DF8                 lea     edx, [ebp+var_24]
.text$mn:00002DFB                 push    edx             ; int
.text$mn:00002DFC                 movzx   eax, [ebp+arg_8]
.text$mn:00002E00                 push    eax             ; char
.text$mn:00002E01                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00002E06                 add     esp, 14h
.text$mn:00002E09                 movzx   ecx, al
.text$mn:00002E0C                 test    ecx, ecx
.text$mn:00002E0E                 jz      short loc_2E43
.text$mn:00002E10                 mov     edx, [ebp+var_C]
.text$mn:00002E13                 push    edx
.text$mn:00002E14                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002E19                 add     esp, 4
.text$mn:00002E1C                 mov     ecx, [ebp+var_4]
.text$mn:00002E1F                 mov     edx, [eax]
.text$mn:00002E21                 mov     [ecx], edx
.text$mn:00002E23                 mov     edx, [eax+4]
.text$mn:00002E26                 mov     [ecx+4], edx
.text$mn:00002E29                 mov     edx, [eax+8]
.text$mn:00002E2C                 mov     [ecx+8], edx
.text$mn:00002E2F                 mov     edx, [eax+0Ch]
.text$mn:00002E32                 mov     [ecx+0Ch], edx
.text$mn:00002E35                 mov     edx, [eax+10h]
.text$mn:00002E38                 mov     [ecx+10h], edx
.text$mn:00002E3B                 mov     eax, [eax+14h]
.text$mn:00002E3E                 mov     [ecx+14h], eax
.text$mn:00002E41                 jmp     short loc_2DDB
.text$mn:00002E43 ; ---------------------------------------------------------------------------
.text$mn:00002E43
.text$mn:00002E43 loc_2E43:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+116j
.text$mn:00002E43                 lea     ecx, [ebp+var_24]
.text$mn:00002E46                 push    ecx
.text$mn:00002E47                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002E4C                 add     esp, 4
.text$mn:00002E4F                 mov     edx, [ebp+var_4]
.text$mn:00002E52                 mov     ecx, [eax]
.text$mn:00002E54                 mov     [edx], ecx
.text$mn:00002E56                 mov     ecx, [eax+4]
.text$mn:00002E59                 mov     [edx+4], ecx
.text$mn:00002E5C                 mov     ecx, [eax+8]
.text$mn:00002E5F                 mov     [edx+8], ecx
.text$mn:00002E62                 mov     ecx, [eax+0Ch]
.text$mn:00002E65                 mov     [edx+0Ch], ecx
.text$mn:00002E68                 mov     ecx, [eax+10h]
.text$mn:00002E6B                 mov     [edx+10h], ecx
.text$mn:00002E6E                 mov     eax, [eax+14h]
.text$mn:00002E71                 mov     [edx+14h], eax
.text$mn:00002E74
.text$mn:00002E74 loc_2E74:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+D6j
.text$mn:00002E74                 jmp     loc_2D10
.text$mn:00002E79 ; ---------------------------------------------------------------------------
.text$mn:00002E79
.text$mn:00002E79 loc_2E79:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+Cj
.text$mn:00002E79                                         ; std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+27j
.text$mn:00002E79                 mov     esp, ebp
.text$mn:00002E7B                 pop     ebp
.text$mn:00002E7C                 retn
.text$mn:00002E7C ??$_Insertion_sort1@PAUColumnModeInfo@@USortInPositionOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z endp
.text$mn:00002E7C
.text$mn:00002E7C ; ---------------------------------------------------------------------------
.text$mn:00002E7D                 align 10h
.text$mn:00002E7D _text$mn        ends
.text$mn:00002E7D
.text$mn:00002E80 ; ===========================================================================
.text$mn:00002E80
.text$mn:00002E80 ; Segment type: Pure code
.text$mn:00002E80 ; Segment permissions: Read/Execute
.text$mn:00002E80 _text$mn        segment para public 'CODE' use32
.text$mn:00002E80                 assume cs:_text$mn
.text$mn:00002E80                 ;org 2E80h
.text$mn:00002E80 ; COMDAT (pick any)
.text$mn:00002E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E80
.text$mn:00002E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E80
.text$mn:00002E80 ; Attributes: bp-based frame
.text$mn:00002E80
.text$mn:00002E80 ; void __cdecl std::_Insertion_sort1<struct ColumnModeInfo *, struct SortInSelectOrder, struct ColumnModeInfo>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder, struct ColumnModeInfo *)
.text$mn:00002E80                 public ??$_Insertion_sort1@PAUColumnModeInfo@@USortInSelectOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z
.text$mn:00002E80 ??$_Insertion_sort1@PAUColumnModeInfo@@USortInSelectOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z proc near
.text$mn:00002E80                                         ; CODE XREF: std::_Insertion_sort<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+1Dp
.text$mn:00002E80
.text$mn:00002E80 var_24          = dword ptr -24h
.text$mn:00002E80 var_20          = dword ptr -20h
.text$mn:00002E80 var_1C          = dword ptr -1Ch
.text$mn:00002E80 var_18          = dword ptr -18h
.text$mn:00002E80 var_14          = dword ptr -14h
.text$mn:00002E80 var_10          = dword ptr -10h
.text$mn:00002E80 var_C           = dword ptr -0Ch
.text$mn:00002E80 var_8           = dword ptr -8
.text$mn:00002E80 var_4           = dword ptr -4
.text$mn:00002E80 arg_0           = dword ptr  8
.text$mn:00002E80 arg_4           = dword ptr  0Ch
.text$mn:00002E80 arg_8           = byte ptr  10h
.text$mn:00002E80
.text$mn:00002E80                 push    ebp
.text$mn:00002E81                 mov     ebp, esp
.text$mn:00002E83                 sub     esp, 24h
.text$mn:00002E86                 mov     eax, [ebp+arg_0]
.text$mn:00002E89                 cmp     eax, [ebp+arg_4]
.text$mn:00002E8C                 jz      loc_3001
.text$mn:00002E92                 mov     ecx, [ebp+arg_0]
.text$mn:00002E95                 mov     [ebp+var_8], ecx
.text$mn:00002E98
.text$mn:00002E98 loc_2E98:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *):loc_2FFCj
.text$mn:00002E98                 mov     edx, [ebp+var_8]
.text$mn:00002E9B                 add     edx, 18h
.text$mn:00002E9E                 mov     [ebp+var_8], edx
.text$mn:00002EA1                 mov     eax, [ebp+var_8]
.text$mn:00002EA4                 cmp     eax, [ebp+arg_4]
.text$mn:00002EA7                 jz      loc_3001
.text$mn:00002EAD                 mov     ecx, [ebp+var_8]
.text$mn:00002EB0                 mov     [ebp+var_4], ecx
.text$mn:00002EB3                 mov     edx, [ebp+var_8]
.text$mn:00002EB6                 push    edx
.text$mn:00002EB7                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002EBC                 add     esp, 4
.text$mn:00002EBF                 mov     ecx, [eax]
.text$mn:00002EC1                 mov     [ebp+var_24], ecx
.text$mn:00002EC4                 mov     edx, [eax+4]
.text$mn:00002EC7                 mov     [ebp+var_20], edx
.text$mn:00002ECA                 mov     ecx, [eax+8]
.text$mn:00002ECD                 mov     [ebp+var_1C], ecx
.text$mn:00002ED0                 mov     edx, [eax+0Ch]
.text$mn:00002ED3                 mov     [ebp+var_18], edx
.text$mn:00002ED6                 mov     ecx, [eax+10h]
.text$mn:00002ED9                 mov     [ebp+var_14], ecx
.text$mn:00002EDC                 mov     edx, [eax+14h]
.text$mn:00002EDF                 mov     [ebp+var_10], edx
.text$mn:00002EE2                 push    0BBEh           ; unsigned int
.text$mn:00002EE7                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002EEC                 mov     eax, [ebp+arg_0]
.text$mn:00002EEF                 push    eax             ; int
.text$mn:00002EF0                 lea     ecx, [ebp+var_24]
.text$mn:00002EF3                 push    ecx             ; int
.text$mn:00002EF4                 movzx   edx, [ebp+arg_8]
.text$mn:00002EF8                 push    edx             ; char
.text$mn:00002EF9                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00002EFE                 add     esp, 14h
.text$mn:00002F01                 movzx   eax, al
.text$mn:00002F04                 test    eax, eax
.text$mn:00002F06                 jz      short loc_2F5B
.text$mn:00002F08                 mov     ecx, [ebp+var_4]
.text$mn:00002F0B                 add     ecx, 18h
.text$mn:00002F0E                 mov     [ebp+var_4], ecx
.text$mn:00002F11                 mov     edx, [ebp+var_4]
.text$mn:00002F14                 push    edx
.text$mn:00002F15                 mov     eax, [ebp+var_8]
.text$mn:00002F18                 push    eax
.text$mn:00002F19                 mov     ecx, [ebp+arg_0]
.text$mn:00002F1C                 push    ecx
.text$mn:00002F1D                 call    ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00@Z ; std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00002F22                 add     esp, 0Ch
.text$mn:00002F25                 lea     edx, [ebp+var_24]
.text$mn:00002F28                 push    edx
.text$mn:00002F29                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002F2E                 add     esp, 4
.text$mn:00002F31                 mov     ecx, [ebp+arg_0]
.text$mn:00002F34                 mov     edx, [eax]
.text$mn:00002F36                 mov     [ecx], edx
.text$mn:00002F38                 mov     edx, [eax+4]
.text$mn:00002F3B                 mov     [ecx+4], edx
.text$mn:00002F3E                 mov     edx, [eax+8]
.text$mn:00002F41                 mov     [ecx+8], edx
.text$mn:00002F44                 mov     edx, [eax+0Ch]
.text$mn:00002F47                 mov     [ecx+0Ch], edx
.text$mn:00002F4A                 mov     edx, [eax+10h]
.text$mn:00002F4D                 mov     [ecx+10h], edx
.text$mn:00002F50                 mov     eax, [eax+14h]
.text$mn:00002F53                 mov     [ecx+14h], eax
.text$mn:00002F56                 jmp     loc_2FFC
.text$mn:00002F5B ; ---------------------------------------------------------------------------
.text$mn:00002F5B
.text$mn:00002F5B loc_2F5B:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+86j
.text$mn:00002F5B                 mov     ecx, [ebp+var_4]
.text$mn:00002F5E                 mov     [ebp+var_C], ecx
.text$mn:00002F61                 jmp     short loc_2F69
.text$mn:00002F63 ; ---------------------------------------------------------------------------
.text$mn:00002F63
.text$mn:00002F63 loc_2F63:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+149j
.text$mn:00002F63                 mov     edx, [ebp+var_C]
.text$mn:00002F66                 mov     [ebp+var_4], edx
.text$mn:00002F69
.text$mn:00002F69 loc_2F69:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+E1j
.text$mn:00002F69                 mov     eax, [ebp+var_C]
.text$mn:00002F6C                 sub     eax, 18h
.text$mn:00002F6F                 mov     [ebp+var_C], eax
.text$mn:00002F72                 push    0BC6h           ; unsigned int
.text$mn:00002F77                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002F7C                 mov     ecx, [ebp+var_C]
.text$mn:00002F7F                 push    ecx             ; int
.text$mn:00002F80                 lea     edx, [ebp+var_24]
.text$mn:00002F83                 push    edx             ; int
.text$mn:00002F84                 movzx   eax, [ebp+arg_8]
.text$mn:00002F88                 push    eax             ; char
.text$mn:00002F89                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00002F8E                 add     esp, 14h
.text$mn:00002F91                 movzx   ecx, al
.text$mn:00002F94                 test    ecx, ecx
.text$mn:00002F96                 jz      short loc_2FCB
.text$mn:00002F98                 mov     edx, [ebp+var_C]
.text$mn:00002F9B                 push    edx
.text$mn:00002F9C                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002FA1                 add     esp, 4
.text$mn:00002FA4                 mov     ecx, [ebp+var_4]
.text$mn:00002FA7                 mov     edx, [eax]
.text$mn:00002FA9                 mov     [ecx], edx
.text$mn:00002FAB                 mov     edx, [eax+4]
.text$mn:00002FAE                 mov     [ecx+4], edx
.text$mn:00002FB1                 mov     edx, [eax+8]
.text$mn:00002FB4                 mov     [ecx+8], edx
.text$mn:00002FB7                 mov     edx, [eax+0Ch]
.text$mn:00002FBA                 mov     [ecx+0Ch], edx
.text$mn:00002FBD                 mov     edx, [eax+10h]
.text$mn:00002FC0                 mov     [ecx+10h], edx
.text$mn:00002FC3                 mov     eax, [eax+14h]
.text$mn:00002FC6                 mov     [ecx+14h], eax
.text$mn:00002FC9                 jmp     short loc_2F63
.text$mn:00002FCB ; ---------------------------------------------------------------------------
.text$mn:00002FCB
.text$mn:00002FCB loc_2FCB:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+116j
.text$mn:00002FCB                 lea     ecx, [ebp+var_24]
.text$mn:00002FCE                 push    ecx
.text$mn:00002FCF                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00002FD4                 add     esp, 4
.text$mn:00002FD7                 mov     edx, [ebp+var_4]
.text$mn:00002FDA                 mov     ecx, [eax]
.text$mn:00002FDC                 mov     [edx], ecx
.text$mn:00002FDE                 mov     ecx, [eax+4]
.text$mn:00002FE1                 mov     [edx+4], ecx
.text$mn:00002FE4                 mov     ecx, [eax+8]
.text$mn:00002FE7                 mov     [edx+8], ecx
.text$mn:00002FEA                 mov     ecx, [eax+0Ch]
.text$mn:00002FED                 mov     [edx+0Ch], ecx
.text$mn:00002FF0                 mov     ecx, [eax+10h]
.text$mn:00002FF3                 mov     [edx+10h], ecx
.text$mn:00002FF6                 mov     eax, [eax+14h]
.text$mn:00002FF9                 mov     [edx+14h], eax
.text$mn:00002FFC
.text$mn:00002FFC loc_2FFC:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+D6j
.text$mn:00002FFC                 jmp     loc_2E98
.text$mn:00003001 ; ---------------------------------------------------------------------------
.text$mn:00003001
.text$mn:00003001 loc_3001:                               ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+Cj
.text$mn:00003001                                         ; std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+27j
.text$mn:00003001                 mov     esp, ebp
.text$mn:00003003                 pop     ebp
.text$mn:00003004                 retn
.text$mn:00003004 ??$_Insertion_sort1@PAUColumnModeInfo@@USortInSelectOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z endp
.text$mn:00003004
.text$mn:00003004 ; ---------------------------------------------------------------------------
.text$mn:00003005                 align 4
.text$mn:00003005 _text$mn        ends
.text$mn:00003005
.text$mn:00003008 ; ===========================================================================
.text$mn:00003008
.text$mn:00003008 ; Segment type: Pure code
.text$mn:00003008 ; Segment permissions: Read/Execute
.text$mn:00003008 _text$mn        segment para public 'CODE' use32
.text$mn:00003008                 assume cs:_text$mn
.text$mn:00003008                 ;org 3008h
.text$mn:00003008 ; COMDAT (pick any)
.text$mn:00003008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003008
.text$mn:00003008 ; =============== S U B R O U T I N E =======================================
.text$mn:00003008
.text$mn:00003008 ; Attributes: bp-based frame
.text$mn:00003008
.text$mn:00003008 ; void __cdecl std::_Insertion_sort<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:00003008                 public ??$_Insertion_sort@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z
.text$mn:00003008 ??$_Insertion_sort@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z proc near
.text$mn:00003008                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+10Ap
.text$mn:00003008
.text$mn:00003008 arg_0           = dword ptr  8
.text$mn:00003008 arg_4           = dword ptr  0Ch
.text$mn:00003008 arg_8           = byte ptr  10h
.text$mn:00003008
.text$mn:00003008                 push    ebp
.text$mn:00003009                 mov     ebp, esp
.text$mn:0000300B                 mov     eax, [ebp+arg_0]
.text$mn:0000300E                 push    eax
.text$mn:0000300F                 call    ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Val_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00003014                 add     esp, 4
.text$mn:00003017                 push    eax
.text$mn:00003018                 movzx   ecx, [ebp+arg_8]
.text$mn:0000301C                 push    ecx
.text$mn:0000301D                 mov     edx, [ebp+arg_4]
.text$mn:00003020                 push    edx
.text$mn:00003021                 mov     eax, [ebp+arg_0]
.text$mn:00003024                 push    eax
.text$mn:00003025                 call    ??$_Insertion_sort1@PAUColumnModeInfo@@USortInPositionOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z ; std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)
.text$mn:0000302A                 add     esp, 10h
.text$mn:0000302D                 pop     ebp
.text$mn:0000302E                 retn
.text$mn:0000302E ??$_Insertion_sort@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z endp
.text$mn:0000302E
.text$mn:0000302E ; ---------------------------------------------------------------------------
.text$mn:0000302F                 align 10h
.text$mn:0000302F _text$mn        ends
.text$mn:0000302F
.text$mn:00003030 ; ===========================================================================
.text$mn:00003030
.text$mn:00003030 ; Segment type: Pure code
.text$mn:00003030 ; Segment permissions: Read/Execute
.text$mn:00003030 _text$mn        segment para public 'CODE' use32
.text$mn:00003030                 assume cs:_text$mn
.text$mn:00003030                 ;org 3030h
.text$mn:00003030 ; COMDAT (pick any)
.text$mn:00003030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003030
.text$mn:00003030 ; =============== S U B R O U T I N E =======================================
.text$mn:00003030
.text$mn:00003030 ; Attributes: bp-based frame
.text$mn:00003030
.text$mn:00003030 ; void __cdecl std::_Insertion_sort<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:00003030                 public ??$_Insertion_sort@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z
.text$mn:00003030 ??$_Insertion_sort@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z proc near
.text$mn:00003030                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+10Ap
.text$mn:00003030
.text$mn:00003030 arg_0           = dword ptr  8
.text$mn:00003030 arg_4           = dword ptr  0Ch
.text$mn:00003030 arg_8           = byte ptr  10h
.text$mn:00003030
.text$mn:00003030                 push    ebp
.text$mn:00003031                 mov     ebp, esp
.text$mn:00003033                 mov     eax, [ebp+arg_0]
.text$mn:00003036                 push    eax
.text$mn:00003037                 call    ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Val_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:0000303C                 add     esp, 4
.text$mn:0000303F                 push    eax
.text$mn:00003040                 movzx   ecx, [ebp+arg_8]
.text$mn:00003044                 push    ecx
.text$mn:00003045                 mov     edx, [ebp+arg_4]
.text$mn:00003048                 push    edx
.text$mn:00003049                 mov     eax, [ebp+arg_0]
.text$mn:0000304C                 push    eax
.text$mn:0000304D                 call    ??$_Insertion_sort1@PAUColumnModeInfo@@USortInSelectOrder@@U1@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z ; std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)
.text$mn:00003052                 add     esp, 10h
.text$mn:00003055                 pop     ebp
.text$mn:00003056                 retn
.text$mn:00003056 ??$_Insertion_sort@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z endp
.text$mn:00003056
.text$mn:00003056 ; ---------------------------------------------------------------------------
.text$mn:00003057                 align 4
.text$mn:00003057 _text$mn        ends
.text$mn:00003057
.text$mn:00003058 ; ===========================================================================
.text$mn:00003058
.text$mn:00003058 ; Segment type: Pure code
.text$mn:00003058 ; Segment permissions: Read/Execute
.text$mn:00003058 _text$mn        segment para public 'CODE' use32
.text$mn:00003058                 assume cs:_text$mn
.text$mn:00003058                 ;org 3058h
.text$mn:00003058 ; COMDAT (pick any)
.text$mn:00003058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003058
.text$mn:00003058 ; =============== S U B R O U T I N E =======================================
.text$mn:00003058
.text$mn:00003058 ; Attributes: bp-based frame
.text$mn:00003058
.text$mn:00003058 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<int *>(int * const &)
.text$mn:00003058                 public ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
.text$mn:00003058 ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z proc near
.text$mn:00003058                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+Cp
.text$mn:00003058
.text$mn:00003058 var_1           = byte ptr -1
.text$mn:00003058 arg_0           = dword ptr  8
.text$mn:00003058
.text$mn:00003058                 push    ebp
.text$mn:00003059                 mov     ebp, esp
.text$mn:0000305B                 push    ecx
.text$mn:0000305C                 mov     eax, [ebp+arg_0]
.text$mn:0000305F                 mov     cl, [ebp+var_1]
.text$mn:00003062                 mov     [eax], cl
.text$mn:00003064                 mov     eax, [ebp+arg_0]
.text$mn:00003067                 mov     esp, ebp
.text$mn:00003069                 pop     ebp
.text$mn:0000306A                 retn
.text$mn:0000306A ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z endp
.text$mn:0000306A
.text$mn:0000306A ; ---------------------------------------------------------------------------
.text$mn:0000306B                 align 4
.text$mn:0000306B _text$mn        ends
.text$mn:0000306B
.text$mn:0000306C ; ===========================================================================
.text$mn:0000306C
.text$mn:0000306C ; Segment type: Pure code
.text$mn:0000306C ; Segment permissions: Read/Execute
.text$mn:0000306C _text$mn        segment para public 'CODE' use32
.text$mn:0000306C                 assume cs:_text$mn
.text$mn:0000306C                 ;org 306Ch
.text$mn:0000306C ; COMDAT (pick any)
.text$mn:0000306C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000306C
.text$mn:0000306C ; =============== S U B R O U T I N E =======================================
.text$mn:0000306C
.text$mn:0000306C ; Attributes: bp-based frame
.text$mn:0000306C
.text$mn:0000306C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct ColumnModeInfo *>(struct ColumnModeInfo * const &)
.text$mn:0000306C                 public ??$_Iter_cat@PAUColumnModeInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUColumnModeInfo@@@Z
.text$mn:0000306C ??$_Iter_cat@PAUColumnModeInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUColumnModeInfo@@@Z proc near
.text$mn:0000306C                                         ; CODE XREF: std::_Debug_range<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint)+Cp
.text$mn:0000306C
.text$mn:0000306C var_1           = byte ptr -1
.text$mn:0000306C arg_0           = dword ptr  8
.text$mn:0000306C
.text$mn:0000306C                 push    ebp
.text$mn:0000306D                 mov     ebp, esp
.text$mn:0000306F                 push    ecx
.text$mn:00003070                 mov     eax, [ebp+arg_0]
.text$mn:00003073                 mov     cl, [ebp+var_1]
.text$mn:00003076                 mov     [eax], cl
.text$mn:00003078                 mov     eax, [ebp+arg_0]
.text$mn:0000307B                 mov     esp, ebp
.text$mn:0000307D                 pop     ebp
.text$mn:0000307E                 retn
.text$mn:0000307E ??$_Iter_cat@PAUColumnModeInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUColumnModeInfo@@@Z endp
.text$mn:0000307E
.text$mn:0000307E ; ---------------------------------------------------------------------------
.text$mn:0000307F                 align 10h
.text$mn:0000307F _text$mn        ends
.text$mn:0000307F
.text$mn:00003080 ; ===========================================================================
.text$mn:00003080
.text$mn:00003080 ; Segment type: Pure code
.text$mn:00003080 ; Segment permissions: Read/Execute
.text$mn:00003080 _text$mn        segment para public 'CODE' use32
.text$mn:00003080                 assume cs:_text$mn
.text$mn:00003080                 ;org 3080h
.text$mn:00003080 ; COMDAT (pick any)
.text$mn:00003080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003080
.text$mn:00003080 ; =============== S U B R O U T I N E =======================================
.text$mn:00003080
.text$mn:00003080 ; Attributes: bp-based frame
.text$mn:00003080
.text$mn:00003080 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>> const &)
.text$mn:00003080                 public ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z
.text$mn:00003080 ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z proc near
.text$mn:00003080                                         ; CODE XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint)+34p
.text$mn:00003080
.text$mn:00003080 var_1           = byte ptr -1
.text$mn:00003080 arg_0           = dword ptr  8
.text$mn:00003080
.text$mn:00003080                 push    ebp
.text$mn:00003081                 mov     ebp, esp
.text$mn:00003083                 push    ecx
.text$mn:00003084                 mov     eax, [ebp+arg_0]
.text$mn:00003087                 mov     cl, [ebp+var_1]
.text$mn:0000308A                 mov     [eax], cl
.text$mn:0000308C                 mov     eax, [ebp+arg_0]
.text$mn:0000308F                 mov     esp, ebp
.text$mn:00003091                 pop     ebp
.text$mn:00003092                 retn
.text$mn:00003092 ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z endp
.text$mn:00003092
.text$mn:00003092 ; ---------------------------------------------------------------------------
.text$mn:00003093                 align 4
.text$mn:00003093 _text$mn        ends
.text$mn:00003093
.text$mn:00003094 ; ===========================================================================
.text$mn:00003094
.text$mn:00003094 ; Segment type: Pure code
.text$mn:00003094 ; Segment permissions: Read/Execute
.text$mn:00003094 _text$mn        segment para public 'CODE' use32
.text$mn:00003094                 assume cs:_text$mn
.text$mn:00003094                 ;org 3094h
.text$mn:00003094 ; COMDAT (pick any)
.text$mn:00003094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003094
.text$mn:00003094 ; =============== S U B R O U T I N E =======================================
.text$mn:00003094
.text$mn:00003094 ; Attributes: bp-based frame
.text$mn:00003094
.text$mn:00003094 ; void __cdecl std::_Make_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder, int *, struct ColumnModeInfo *)
.text$mn:00003094                 public ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@PAH0@Z
.text$mn:00003094 ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@PAH0@Z proc near
.text$mn:00003094                                         ; CODE XREF: std::make_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+7Fp
.text$mn:00003094
.text$mn:00003094 var_20          = dword ptr -20h
.text$mn:00003094 var_1C          = dword ptr -1Ch
.text$mn:00003094 var_18          = dword ptr -18h
.text$mn:00003094 var_14          = dword ptr -14h
.text$mn:00003094 var_10          = dword ptr -10h
.text$mn:00003094 var_C           = dword ptr -0Ch
.text$mn:00003094 var_8           = dword ptr -8
.text$mn:00003094 var_4           = dword ptr -4
.text$mn:00003094 arg_0           = dword ptr  8
.text$mn:00003094 arg_4           = dword ptr  0Ch
.text$mn:00003094 arg_8           = byte ptr  10h
.text$mn:00003094
.text$mn:00003094                 push    ebp
.text$mn:00003095                 mov     ebp, esp
.text$mn:00003097                 sub     esp, 20h
.text$mn:0000309A                 mov     eax, [ebp+arg_4]
.text$mn:0000309D                 sub     eax, [ebp+arg_0]
.text$mn:000030A0                 cdq
.text$mn:000030A1                 mov     ecx, 18h
.text$mn:000030A6                 idiv    ecx
.text$mn:000030A8                 mov     [ebp+var_8], eax
.text$mn:000030AB                 mov     eax, [ebp+var_8]
.text$mn:000030AE                 cdq
.text$mn:000030AF                 sub     eax, edx
.text$mn:000030B1                 sar     eax, 1
.text$mn:000030B3                 mov     [ebp+var_4], eax
.text$mn:000030B6
.text$mn:000030B6 loc_30B6:                               ; CODE XREF: std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,int *,ColumnModeInfo *)+8Aj
.text$mn:000030B6                 cmp     [ebp+var_4], 0
.text$mn:000030BA                 jle     short loc_3120
.text$mn:000030BC                 mov     edx, [ebp+var_4]
.text$mn:000030BF                 sub     edx, 1
.text$mn:000030C2                 mov     [ebp+var_4], edx
.text$mn:000030C5                 imul    eax, [ebp+var_4], 18h
.text$mn:000030C9                 add     eax, [ebp+arg_0]
.text$mn:000030CC                 push    eax
.text$mn:000030CD                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000030D2                 add     esp, 4
.text$mn:000030D5                 mov     ecx, [eax]
.text$mn:000030D7                 mov     [ebp+var_20], ecx
.text$mn:000030DA                 mov     edx, [eax+4]
.text$mn:000030DD                 mov     [ebp+var_1C], edx
.text$mn:000030E0                 mov     ecx, [eax+8]
.text$mn:000030E3                 mov     [ebp+var_18], ecx
.text$mn:000030E6                 mov     edx, [eax+0Ch]
.text$mn:000030E9                 mov     [ebp+var_14], edx
.text$mn:000030EC                 mov     ecx, [eax+10h]
.text$mn:000030EF                 mov     [ebp+var_10], ecx
.text$mn:000030F2                 mov     edx, [eax+14h]
.text$mn:000030F5                 mov     [ebp+var_C], edx
.text$mn:000030F8                 movzx   eax, [ebp+arg_8]
.text$mn:000030FC                 push    eax
.text$mn:000030FD                 lea     ecx, [ebp+var_20]
.text$mn:00003100                 push    ecx
.text$mn:00003101                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003106                 add     esp, 4
.text$mn:00003109                 push    eax
.text$mn:0000310A                 mov     edx, [ebp+var_8]
.text$mn:0000310D                 push    edx
.text$mn:0000310E                 mov     eax, [ebp+var_4]
.text$mn:00003111                 push    eax
.text$mn:00003112                 mov     ecx, [ebp+arg_0]
.text$mn:00003115                 push    ecx
.text$mn:00003116                 call    ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z ; std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)
.text$mn:0000311B                 add     esp, 14h
.text$mn:0000311E                 jmp     short loc_30B6
.text$mn:00003120 ; ---------------------------------------------------------------------------
.text$mn:00003120
.text$mn:00003120 loc_3120:                               ; CODE XREF: std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,int *,ColumnModeInfo *)+26j
.text$mn:00003120                 mov     esp, ebp
.text$mn:00003122                 pop     ebp
.text$mn:00003123                 retn
.text$mn:00003123 ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@PAH0@Z endp
.text$mn:00003123
.text$mn:00003123 _text$mn        ends
.text$mn:00003123
.text$mn:00003124 ; ===========================================================================
.text$mn:00003124
.text$mn:00003124 ; Segment type: Pure code
.text$mn:00003124 ; Segment permissions: Read/Execute
.text$mn:00003124 _text$mn        segment para public 'CODE' use32
.text$mn:00003124                 assume cs:_text$mn
.text$mn:00003124                 ;org 3124h
.text$mn:00003124 ; COMDAT (pick any)
.text$mn:00003124                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003124
.text$mn:00003124 ; =============== S U B R O U T I N E =======================================
.text$mn:00003124
.text$mn:00003124 ; Attributes: bp-based frame
.text$mn:00003124
.text$mn:00003124 ; void __cdecl std::_Make_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder, int *, struct ColumnModeInfo *)
.text$mn:00003124                 public ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@PAH0@Z
.text$mn:00003124 ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@PAH0@Z proc near
.text$mn:00003124                                         ; CODE XREF: std::make_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+7Fp
.text$mn:00003124
.text$mn:00003124 var_20          = dword ptr -20h
.text$mn:00003124 var_1C          = dword ptr -1Ch
.text$mn:00003124 var_18          = dword ptr -18h
.text$mn:00003124 var_14          = dword ptr -14h
.text$mn:00003124 var_10          = dword ptr -10h
.text$mn:00003124 var_C           = dword ptr -0Ch
.text$mn:00003124 var_8           = dword ptr -8
.text$mn:00003124 var_4           = dword ptr -4
.text$mn:00003124 arg_0           = dword ptr  8
.text$mn:00003124 arg_4           = dword ptr  0Ch
.text$mn:00003124 arg_8           = byte ptr  10h
.text$mn:00003124
.text$mn:00003124                 push    ebp
.text$mn:00003125                 mov     ebp, esp
.text$mn:00003127                 sub     esp, 20h
.text$mn:0000312A                 mov     eax, [ebp+arg_4]
.text$mn:0000312D                 sub     eax, [ebp+arg_0]
.text$mn:00003130                 cdq
.text$mn:00003131                 mov     ecx, 18h
.text$mn:00003136                 idiv    ecx
.text$mn:00003138                 mov     [ebp+var_8], eax
.text$mn:0000313B                 mov     eax, [ebp+var_8]
.text$mn:0000313E                 cdq
.text$mn:0000313F                 sub     eax, edx
.text$mn:00003141                 sar     eax, 1
.text$mn:00003143                 mov     [ebp+var_4], eax
.text$mn:00003146
.text$mn:00003146 loc_3146:                               ; CODE XREF: std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,int *,ColumnModeInfo *)+8Aj
.text$mn:00003146                 cmp     [ebp+var_4], 0
.text$mn:0000314A                 jle     short loc_31B0
.text$mn:0000314C                 mov     edx, [ebp+var_4]
.text$mn:0000314F                 sub     edx, 1
.text$mn:00003152                 mov     [ebp+var_4], edx
.text$mn:00003155                 imul    eax, [ebp+var_4], 18h
.text$mn:00003159                 add     eax, [ebp+arg_0]
.text$mn:0000315C                 push    eax
.text$mn:0000315D                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003162                 add     esp, 4
.text$mn:00003165                 mov     ecx, [eax]
.text$mn:00003167                 mov     [ebp+var_20], ecx
.text$mn:0000316A                 mov     edx, [eax+4]
.text$mn:0000316D                 mov     [ebp+var_1C], edx
.text$mn:00003170                 mov     ecx, [eax+8]
.text$mn:00003173                 mov     [ebp+var_18], ecx
.text$mn:00003176                 mov     edx, [eax+0Ch]
.text$mn:00003179                 mov     [ebp+var_14], edx
.text$mn:0000317C                 mov     ecx, [eax+10h]
.text$mn:0000317F                 mov     [ebp+var_10], ecx
.text$mn:00003182                 mov     edx, [eax+14h]
.text$mn:00003185                 mov     [ebp+var_C], edx
.text$mn:00003188                 movzx   eax, [ebp+arg_8]
.text$mn:0000318C                 push    eax
.text$mn:0000318D                 lea     ecx, [ebp+var_20]
.text$mn:00003190                 push    ecx
.text$mn:00003191                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003196                 add     esp, 4
.text$mn:00003199                 push    eax
.text$mn:0000319A                 mov     edx, [ebp+var_8]
.text$mn:0000319D                 push    edx
.text$mn:0000319E                 mov     eax, [ebp+var_4]
.text$mn:000031A1                 push    eax
.text$mn:000031A2                 mov     ecx, [ebp+arg_0]
.text$mn:000031A5                 push    ecx
.text$mn:000031A6                 call    ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z ; std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)
.text$mn:000031AB                 add     esp, 14h
.text$mn:000031AE                 jmp     short loc_3146
.text$mn:000031B0 ; ---------------------------------------------------------------------------
.text$mn:000031B0
.text$mn:000031B0 loc_31B0:                               ; CODE XREF: std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,int *,ColumnModeInfo *)+26j
.text$mn:000031B0                 mov     esp, ebp
.text$mn:000031B2                 pop     ebp
.text$mn:000031B3                 retn
.text$mn:000031B3 ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@PAH0@Z endp
.text$mn:000031B3
.text$mn:000031B3 _text$mn        ends
.text$mn:000031B3
.text$mn:000031B4 ; ===========================================================================
.text$mn:000031B4
.text$mn:000031B4 ; Segment type: Pure code
.text$mn:000031B4 ; Segment permissions: Read/Execute
.text$mn:000031B4 _text$mn        segment para public 'CODE' use32
.text$mn:000031B4                 assume cs:_text$mn
.text$mn:000031B4                 ;org 31B4h
.text$mn:000031B4 ; COMDAT (pick any)
.text$mn:000031B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031B4
.text$mn:000031B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000031B4
.text$mn:000031B4 ; Attributes: bp-based frame
.text$mn:000031B4
.text$mn:000031B4 ; void __cdecl std::_Med3<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:000031B4                 public ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z
.text$mn:000031B4 ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z proc near
.text$mn:000031B4                                         ; CODE XREF: std::_Median<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+55p
.text$mn:000031B4                                         ; std::_Median<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+78p ...
.text$mn:000031B4
.text$mn:000031B4 arg_0           = dword ptr  8
.text$mn:000031B4 arg_4           = dword ptr  0Ch
.text$mn:000031B4 arg_8           = dword ptr  10h
.text$mn:000031B4 arg_C           = byte ptr  14h
.text$mn:000031B4
.text$mn:000031B4                 push    ebp
.text$mn:000031B5                 mov     ebp, esp
.text$mn:000031B7                 push    0BD9h           ; unsigned int
.text$mn:000031BC                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000031C1                 mov     eax, [ebp+arg_0]
.text$mn:000031C4                 push    eax             ; int
.text$mn:000031C5                 mov     ecx, [ebp+arg_4]
.text$mn:000031C8                 push    ecx             ; int
.text$mn:000031C9                 movzx   edx, [ebp+arg_C]
.text$mn:000031CD                 push    edx             ; char
.text$mn:000031CE                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000031D3                 add     esp, 14h
.text$mn:000031D6                 movzx   eax, al
.text$mn:000031D9                 test    eax, eax
.text$mn:000031DB                 jz      short loc_31ED
.text$mn:000031DD                 mov     ecx, [ebp+arg_0]
.text$mn:000031E0                 push    ecx
.text$mn:000031E1                 mov     edx, [ebp+arg_4]
.text$mn:000031E4                 push    edx
.text$mn:000031E5                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000031EA                 add     esp, 8
.text$mn:000031ED
.text$mn:000031ED loc_31ED:                               ; CODE XREF: std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+27j
.text$mn:000031ED                 push    0BDBh           ; unsigned int
.text$mn:000031F2                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000031F7                 mov     eax, [ebp+arg_4]
.text$mn:000031FA                 push    eax             ; int
.text$mn:000031FB                 mov     ecx, [ebp+arg_8]
.text$mn:000031FE                 push    ecx             ; int
.text$mn:000031FF                 movzx   edx, [ebp+arg_C]
.text$mn:00003203                 push    edx             ; char
.text$mn:00003204                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00003209                 add     esp, 14h
.text$mn:0000320C                 movzx   eax, al
.text$mn:0000320F                 test    eax, eax
.text$mn:00003211                 jz      short loc_3259
.text$mn:00003213                 mov     ecx, [ebp+arg_4]
.text$mn:00003216                 push    ecx
.text$mn:00003217                 mov     edx, [ebp+arg_8]
.text$mn:0000321A                 push    edx
.text$mn:0000321B                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003220                 add     esp, 8
.text$mn:00003223                 push    0BDEh           ; unsigned int
.text$mn:00003228                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000322D                 mov     eax, [ebp+arg_0]
.text$mn:00003230                 push    eax             ; int
.text$mn:00003231                 mov     ecx, [ebp+arg_4]
.text$mn:00003234                 push    ecx             ; int
.text$mn:00003235                 movzx   edx, [ebp+arg_C]
.text$mn:00003239                 push    edx             ; char
.text$mn:0000323A                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:0000323F                 add     esp, 14h
.text$mn:00003242                 movzx   eax, al
.text$mn:00003245                 test    eax, eax
.text$mn:00003247                 jz      short loc_3259
.text$mn:00003249                 mov     ecx, [ebp+arg_0]
.text$mn:0000324C                 push    ecx
.text$mn:0000324D                 mov     edx, [ebp+arg_4]
.text$mn:00003250                 push    edx
.text$mn:00003251                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003256                 add     esp, 8
.text$mn:00003259
.text$mn:00003259 loc_3259:                               ; CODE XREF: std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+5Dj
.text$mn:00003259                                         ; std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+93j
.text$mn:00003259                 pop     ebp
.text$mn:0000325A                 retn
.text$mn:0000325A ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z endp
.text$mn:0000325A
.text$mn:0000325A ; ---------------------------------------------------------------------------
.text$mn:0000325B                 align 4
.text$mn:0000325B _text$mn        ends
.text$mn:0000325B
.text$mn:0000325C ; ===========================================================================
.text$mn:0000325C
.text$mn:0000325C ; Segment type: Pure code
.text$mn:0000325C ; Segment permissions: Read/Execute
.text$mn:0000325C _text$mn        segment para public 'CODE' use32
.text$mn:0000325C                 assume cs:_text$mn
.text$mn:0000325C                 ;org 325Ch
.text$mn:0000325C ; COMDAT (pick any)
.text$mn:0000325C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000325C
.text$mn:0000325C ; =============== S U B R O U T I N E =======================================
.text$mn:0000325C
.text$mn:0000325C ; Attributes: bp-based frame
.text$mn:0000325C
.text$mn:0000325C ; void __cdecl std::_Med3<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:0000325C                 public ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z
.text$mn:0000325C ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z proc near
.text$mn:0000325C                                         ; CODE XREF: std::_Median<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+55p
.text$mn:0000325C                                         ; std::_Median<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+78p ...
.text$mn:0000325C
.text$mn:0000325C arg_0           = dword ptr  8
.text$mn:0000325C arg_4           = dword ptr  0Ch
.text$mn:0000325C arg_8           = dword ptr  10h
.text$mn:0000325C arg_C           = byte ptr  14h
.text$mn:0000325C
.text$mn:0000325C                 push    ebp
.text$mn:0000325D                 mov     ebp, esp
.text$mn:0000325F                 push    0BD9h           ; unsigned int
.text$mn:00003264                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003269                 mov     eax, [ebp+arg_0]
.text$mn:0000326C                 push    eax             ; int
.text$mn:0000326D                 mov     ecx, [ebp+arg_4]
.text$mn:00003270                 push    ecx             ; int
.text$mn:00003271                 movzx   edx, [ebp+arg_C]
.text$mn:00003275                 push    edx             ; char
.text$mn:00003276                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:0000327B                 add     esp, 14h
.text$mn:0000327E                 movzx   eax, al
.text$mn:00003281                 test    eax, eax
.text$mn:00003283                 jz      short loc_3295
.text$mn:00003285                 mov     ecx, [ebp+arg_0]
.text$mn:00003288                 push    ecx
.text$mn:00003289                 mov     edx, [ebp+arg_4]
.text$mn:0000328C                 push    edx
.text$mn:0000328D                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003292                 add     esp, 8
.text$mn:00003295
.text$mn:00003295 loc_3295:                               ; CODE XREF: std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+27j
.text$mn:00003295                 push    0BDBh           ; unsigned int
.text$mn:0000329A                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000329F                 mov     eax, [ebp+arg_4]
.text$mn:000032A2                 push    eax             ; int
.text$mn:000032A3                 mov     ecx, [ebp+arg_8]
.text$mn:000032A6                 push    ecx             ; int
.text$mn:000032A7                 movzx   edx, [ebp+arg_C]
.text$mn:000032AB                 push    edx             ; char
.text$mn:000032AC                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000032B1                 add     esp, 14h
.text$mn:000032B4                 movzx   eax, al
.text$mn:000032B7                 test    eax, eax
.text$mn:000032B9                 jz      short loc_3301
.text$mn:000032BB                 mov     ecx, [ebp+arg_4]
.text$mn:000032BE                 push    ecx
.text$mn:000032BF                 mov     edx, [ebp+arg_8]
.text$mn:000032C2                 push    edx
.text$mn:000032C3                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000032C8                 add     esp, 8
.text$mn:000032CB                 push    0BDEh           ; unsigned int
.text$mn:000032D0                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000032D5                 mov     eax, [ebp+arg_0]
.text$mn:000032D8                 push    eax             ; int
.text$mn:000032D9                 mov     ecx, [ebp+arg_4]
.text$mn:000032DC                 push    ecx             ; int
.text$mn:000032DD                 movzx   edx, [ebp+arg_C]
.text$mn:000032E1                 push    edx             ; char
.text$mn:000032E2                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000032E7                 add     esp, 14h
.text$mn:000032EA                 movzx   eax, al
.text$mn:000032ED                 test    eax, eax
.text$mn:000032EF                 jz      short loc_3301
.text$mn:000032F1                 mov     ecx, [ebp+arg_0]
.text$mn:000032F4                 push    ecx
.text$mn:000032F5                 mov     edx, [ebp+arg_4]
.text$mn:000032F8                 push    edx
.text$mn:000032F9                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000032FE                 add     esp, 8
.text$mn:00003301
.text$mn:00003301 loc_3301:                               ; CODE XREF: std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+5Dj
.text$mn:00003301                                         ; std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+93j
.text$mn:00003301                 pop     ebp
.text$mn:00003302                 retn
.text$mn:00003302 ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z endp
.text$mn:00003302
.text$mn:00003302 ; ---------------------------------------------------------------------------
.text$mn:00003303                 align 4
.text$mn:00003303 _text$mn        ends
.text$mn:00003303
.text$mn:00003304 ; ===========================================================================
.text$mn:00003304
.text$mn:00003304 ; Segment type: Pure code
.text$mn:00003304 ; Segment permissions: Read/Execute
.text$mn:00003304 _text$mn        segment para public 'CODE' use32
.text$mn:00003304                 assume cs:_text$mn
.text$mn:00003304                 ;org 3304h
.text$mn:00003304 ; COMDAT (pick any)
.text$mn:00003304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003304
.text$mn:00003304 ; =============== S U B R O U T I N E =======================================
.text$mn:00003304
.text$mn:00003304 ; Attributes: bp-based frame
.text$mn:00003304
.text$mn:00003304 ; void __cdecl std::_Median<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:00003304                 public ??$_Median@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z
.text$mn:00003304 ??$_Median@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z proc near
.text$mn:00003304                                         ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+36p
.text$mn:00003304
.text$mn:00003304 var_4           = dword ptr -4
.text$mn:00003304 arg_0           = dword ptr  8
.text$mn:00003304 arg_4           = dword ptr  0Ch
.text$mn:00003304 arg_8           = dword ptr  10h
.text$mn:00003304 arg_C           = byte ptr  14h
.text$mn:00003304
.text$mn:00003304                 push    ebp
.text$mn:00003305                 mov     ebp, esp
.text$mn:00003307                 push    ecx
.text$mn:00003308                 mov     eax, [ebp+arg_8]
.text$mn:0000330B                 sub     eax, [ebp+arg_0]
.text$mn:0000330E                 cdq
.text$mn:0000330F                 mov     ecx, 18h
.text$mn:00003314                 idiv    ecx
.text$mn:00003316                 cmp     eax, 28h ; '('
.text$mn:00003319                 jle     loc_33D2
.text$mn:0000331F                 mov     eax, [ebp+arg_8]
.text$mn:00003322                 sub     eax, [ebp+arg_0]
.text$mn:00003325                 cdq
.text$mn:00003326                 mov     ecx, 18h
.text$mn:0000332B                 idiv    ecx
.text$mn:0000332D                 add     eax, 1
.text$mn:00003330                 cdq
.text$mn:00003331                 and     edx, 7
.text$mn:00003334                 add     eax, edx
.text$mn:00003336                 sar     eax, 3
.text$mn:00003339                 mov     [ebp+var_4], eax
.text$mn:0000333C                 movzx   edx, [ebp+arg_C]
.text$mn:00003340                 push    edx
.text$mn:00003341                 mov     eax, [ebp+var_4]
.text$mn:00003344                 shl     eax, 1
.text$mn:00003346                 imul    ecx, eax, 18h
.text$mn:00003349                 add     ecx, [ebp+arg_0]
.text$mn:0000334C                 push    ecx
.text$mn:0000334D                 imul    edx, [ebp+var_4], 18h
.text$mn:00003351                 add     edx, [ebp+arg_0]
.text$mn:00003354                 push    edx
.text$mn:00003355                 mov     eax, [ebp+arg_0]
.text$mn:00003358                 push    eax
.text$mn:00003359                 call    ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:0000335E                 add     esp, 10h
.text$mn:00003361                 movzx   ecx, [ebp+arg_C]
.text$mn:00003365                 push    ecx
.text$mn:00003366                 imul    edx, [ebp+var_4], 18h
.text$mn:0000336A                 add     edx, [ebp+arg_4]
.text$mn:0000336D                 push    edx
.text$mn:0000336E                 mov     eax, [ebp+arg_4]
.text$mn:00003371                 push    eax
.text$mn:00003372                 imul    ecx, [ebp+var_4], 18h
.text$mn:00003376                 mov     edx, [ebp+arg_4]
.text$mn:00003379                 sub     edx, ecx
.text$mn:0000337B                 push    edx
.text$mn:0000337C                 call    ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00003381                 add     esp, 10h
.text$mn:00003384                 movzx   eax, [ebp+arg_C]
.text$mn:00003388                 push    eax
.text$mn:00003389                 mov     ecx, [ebp+arg_8]
.text$mn:0000338C                 push    ecx
.text$mn:0000338D                 imul    edx, [ebp+var_4], 18h
.text$mn:00003391                 mov     eax, [ebp+arg_8]
.text$mn:00003394                 sub     eax, edx
.text$mn:00003396                 push    eax
.text$mn:00003397                 mov     ecx, [ebp+var_4]
.text$mn:0000339A                 shl     ecx, 1
.text$mn:0000339C                 imul    edx, ecx, 18h
.text$mn:0000339F                 mov     eax, [ebp+arg_8]
.text$mn:000033A2                 sub     eax, edx
.text$mn:000033A4                 push    eax
.text$mn:000033A5                 call    ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:000033AA                 add     esp, 10h
.text$mn:000033AD                 movzx   ecx, [ebp+arg_C]
.text$mn:000033B1                 push    ecx
.text$mn:000033B2                 imul    edx, [ebp+var_4], 18h
.text$mn:000033B6                 mov     eax, [ebp+arg_8]
.text$mn:000033B9                 sub     eax, edx
.text$mn:000033BB                 push    eax
.text$mn:000033BC                 mov     ecx, [ebp+arg_4]
.text$mn:000033BF                 push    ecx
.text$mn:000033C0                 imul    edx, [ebp+var_4], 18h
.text$mn:000033C4                 add     edx, [ebp+arg_0]
.text$mn:000033C7                 push    edx
.text$mn:000033C8                 call    ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:000033CD                 add     esp, 10h
.text$mn:000033D0                 jmp     short loc_33EB
.text$mn:000033D2 ; ---------------------------------------------------------------------------
.text$mn:000033D2
.text$mn:000033D2 loc_33D2:                               ; CODE XREF: std::_Median<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+15j
.text$mn:000033D2                 movzx   eax, [ebp+arg_C]
.text$mn:000033D6                 push    eax
.text$mn:000033D7                 mov     ecx, [ebp+arg_8]
.text$mn:000033DA                 push    ecx
.text$mn:000033DB                 mov     edx, [ebp+arg_4]
.text$mn:000033DE                 push    edx
.text$mn:000033DF                 mov     eax, [ebp+arg_0]
.text$mn:000033E2                 push    eax
.text$mn:000033E3                 call    ??$_Med3@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:000033E8                 add     esp, 10h
.text$mn:000033EB
.text$mn:000033EB loc_33EB:                               ; CODE XREF: std::_Median<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+CCj
.text$mn:000033EB                 mov     esp, ebp
.text$mn:000033ED                 pop     ebp
.text$mn:000033EE                 retn
.text$mn:000033EE ??$_Median@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z endp
.text$mn:000033EE
.text$mn:000033EE ; ---------------------------------------------------------------------------
.text$mn:000033EF                 align 10h
.text$mn:000033EF _text$mn        ends
.text$mn:000033EF
.text$mn:000033F0 ; ===========================================================================
.text$mn:000033F0
.text$mn:000033F0 ; Segment type: Pure code
.text$mn:000033F0 ; Segment permissions: Read/Execute
.text$mn:000033F0 _text$mn        segment para public 'CODE' use32
.text$mn:000033F0                 assume cs:_text$mn
.text$mn:000033F0                 ;org 33F0h
.text$mn:000033F0 ; COMDAT (pick any)
.text$mn:000033F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033F0
.text$mn:000033F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033F0
.text$mn:000033F0 ; Attributes: bp-based frame
.text$mn:000033F0
.text$mn:000033F0 ; void __cdecl std::_Median<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:000033F0                 public ??$_Median@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z
.text$mn:000033F0 ??$_Median@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z proc near
.text$mn:000033F0                                         ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+36p
.text$mn:000033F0
.text$mn:000033F0 var_4           = dword ptr -4
.text$mn:000033F0 arg_0           = dword ptr  8
.text$mn:000033F0 arg_4           = dword ptr  0Ch
.text$mn:000033F0 arg_8           = dword ptr  10h
.text$mn:000033F0 arg_C           = byte ptr  14h
.text$mn:000033F0
.text$mn:000033F0                 push    ebp
.text$mn:000033F1                 mov     ebp, esp
.text$mn:000033F3                 push    ecx
.text$mn:000033F4                 mov     eax, [ebp+arg_8]
.text$mn:000033F7                 sub     eax, [ebp+arg_0]
.text$mn:000033FA                 cdq
.text$mn:000033FB                 mov     ecx, 18h
.text$mn:00003400                 idiv    ecx
.text$mn:00003402                 cmp     eax, 28h ; '('
.text$mn:00003405                 jle     loc_34BE
.text$mn:0000340B                 mov     eax, [ebp+arg_8]
.text$mn:0000340E                 sub     eax, [ebp+arg_0]
.text$mn:00003411                 cdq
.text$mn:00003412                 mov     ecx, 18h
.text$mn:00003417                 idiv    ecx
.text$mn:00003419                 add     eax, 1
.text$mn:0000341C                 cdq
.text$mn:0000341D                 and     edx, 7
.text$mn:00003420                 add     eax, edx
.text$mn:00003422                 sar     eax, 3
.text$mn:00003425                 mov     [ebp+var_4], eax
.text$mn:00003428                 movzx   edx, [ebp+arg_C]
.text$mn:0000342C                 push    edx
.text$mn:0000342D                 mov     eax, [ebp+var_4]
.text$mn:00003430                 shl     eax, 1
.text$mn:00003432                 imul    ecx, eax, 18h
.text$mn:00003435                 add     ecx, [ebp+arg_0]
.text$mn:00003438                 push    ecx
.text$mn:00003439                 imul    edx, [ebp+var_4], 18h
.text$mn:0000343D                 add     edx, [ebp+arg_0]
.text$mn:00003440                 push    edx
.text$mn:00003441                 mov     eax, [ebp+arg_0]
.text$mn:00003444                 push    eax
.text$mn:00003445                 call    ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:0000344A                 add     esp, 10h
.text$mn:0000344D                 movzx   ecx, [ebp+arg_C]
.text$mn:00003451                 push    ecx
.text$mn:00003452                 imul    edx, [ebp+var_4], 18h
.text$mn:00003456                 add     edx, [ebp+arg_4]
.text$mn:00003459                 push    edx
.text$mn:0000345A                 mov     eax, [ebp+arg_4]
.text$mn:0000345D                 push    eax
.text$mn:0000345E                 imul    ecx, [ebp+var_4], 18h
.text$mn:00003462                 mov     edx, [ebp+arg_4]
.text$mn:00003465                 sub     edx, ecx
.text$mn:00003467                 push    edx
.text$mn:00003468                 call    ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:0000346D                 add     esp, 10h
.text$mn:00003470                 movzx   eax, [ebp+arg_C]
.text$mn:00003474                 push    eax
.text$mn:00003475                 mov     ecx, [ebp+arg_8]
.text$mn:00003478                 push    ecx
.text$mn:00003479                 imul    edx, [ebp+var_4], 18h
.text$mn:0000347D                 mov     eax, [ebp+arg_8]
.text$mn:00003480                 sub     eax, edx
.text$mn:00003482                 push    eax
.text$mn:00003483                 mov     ecx, [ebp+var_4]
.text$mn:00003486                 shl     ecx, 1
.text$mn:00003488                 imul    edx, ecx, 18h
.text$mn:0000348B                 mov     eax, [ebp+arg_8]
.text$mn:0000348E                 sub     eax, edx
.text$mn:00003490                 push    eax
.text$mn:00003491                 call    ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00003496                 add     esp, 10h
.text$mn:00003499                 movzx   ecx, [ebp+arg_C]
.text$mn:0000349D                 push    ecx
.text$mn:0000349E                 imul    edx, [ebp+var_4], 18h
.text$mn:000034A2                 mov     eax, [ebp+arg_8]
.text$mn:000034A5                 sub     eax, edx
.text$mn:000034A7                 push    eax
.text$mn:000034A8                 mov     ecx, [ebp+arg_4]
.text$mn:000034AB                 push    ecx
.text$mn:000034AC                 imul    edx, [ebp+var_4], 18h
.text$mn:000034B0                 add     edx, [ebp+arg_0]
.text$mn:000034B3                 push    edx
.text$mn:000034B4                 call    ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:000034B9                 add     esp, 10h
.text$mn:000034BC                 jmp     short loc_34D7
.text$mn:000034BE ; ---------------------------------------------------------------------------
.text$mn:000034BE
.text$mn:000034BE loc_34BE:                               ; CODE XREF: std::_Median<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+15j
.text$mn:000034BE                 movzx   eax, [ebp+arg_C]
.text$mn:000034C2                 push    eax
.text$mn:000034C3                 mov     ecx, [ebp+arg_8]
.text$mn:000034C6                 push    ecx
.text$mn:000034C7                 mov     edx, [ebp+arg_4]
.text$mn:000034CA                 push    edx
.text$mn:000034CB                 mov     eax, [ebp+arg_0]
.text$mn:000034CE                 push    eax
.text$mn:000034CF                 call    ??$_Med3@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z ; std::_Med3<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:000034D4                 add     esp, 10h
.text$mn:000034D7
.text$mn:000034D7 loc_34D7:                               ; CODE XREF: std::_Median<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+CCj
.text$mn:000034D7                 mov     esp, ebp
.text$mn:000034D9                 pop     ebp
.text$mn:000034DA                 retn
.text$mn:000034DA ??$_Median@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z endp
.text$mn:000034DA
.text$mn:000034DA ; ---------------------------------------------------------------------------
.text$mn:000034DB                 align 4
.text$mn:000034DB _text$mn        ends
.text$mn:000034DB
.text$mn:000034DC ; ===========================================================================
.text$mn:000034DC
.text$mn:000034DC ; Segment type: Pure code
.text$mn:000034DC ; Segment permissions: Read/Execute
.text$mn:000034DC _text$mn        segment para public 'CODE' use32
.text$mn:000034DC                 assume cs:_text$mn
.text$mn:000034DC                 ;org 34DCh
.text$mn:000034DC ; COMDAT (pick any)
.text$mn:000034DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034DC
.text$mn:000034DC ; =============== S U B R O U T I N E =======================================
.text$mn:000034DC
.text$mn:000034DC ; Attributes: bp-based frame
.text$mn:000034DC
.text$mn:000034DC ; struct ColumnModeInfo && __cdecl std::_Move<struct ColumnModeInfo &>(struct ColumnModeInfo &)
.text$mn:000034DC                 public ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z
.text$mn:000034DC ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z proc near
.text$mn:000034DC                                         ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+72p
.text$mn:000034DC                                         ; std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+C3p ...
.text$mn:000034DC
.text$mn:000034DC arg_0           = dword ptr  8
.text$mn:000034DC
.text$mn:000034DC                 push    ebp
.text$mn:000034DD                 mov     ebp, esp
.text$mn:000034DF                 mov     eax, [ebp+arg_0]
.text$mn:000034E2                 pop     ebp
.text$mn:000034E3                 retn
.text$mn:000034E3 ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z endp
.text$mn:000034E3
.text$mn:000034E3 _text$mn        ends
.text$mn:000034E3
.text$mn:000034E4 ; ===========================================================================
.text$mn:000034E4
.text$mn:000034E4 ; Segment type: Pure code
.text$mn:000034E4 ; Segment permissions: Read/Execute
.text$mn:000034E4 _text$mn        segment para public 'CODE' use32
.text$mn:000034E4                 assume cs:_text$mn
.text$mn:000034E4                 ;org 34E4h
.text$mn:000034E4 ; COMDAT (pick any)
.text$mn:000034E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034E4
.text$mn:000034E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034E4
.text$mn:000034E4 ; Attributes: bp-based frame
.text$mn:000034E4
.text$mn:000034E4 ; struct ColumnModeInfo * __cdecl std::_Move_backward<struct ColumnModeInfo *, struct ColumnModeInfo *>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *)
.text$mn:000034E4                 public ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00@Z
.text$mn:000034E4 ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00@Z proc near
.text$mn:000034E4                                         ; CODE XREF: std::_Insertion_sort1<ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+9Dp
.text$mn:000034E4                                         ; std::_Insertion_sort1<ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+9Dp
.text$mn:000034E4
.text$mn:000034E4 var_1           = byte ptr -1
.text$mn:000034E4 arg_0           = dword ptr  8
.text$mn:000034E4 arg_4           = dword ptr  0Ch
.text$mn:000034E4 arg_8           = dword ptr  10h
.text$mn:000034E4
.text$mn:000034E4                 push    ebp
.text$mn:000034E5                 mov     ebp, esp
.text$mn:000034E7                 push    ecx
.text$mn:000034E8                 mov     eax, [ebp+arg_8]
.text$mn:000034EB                 push    eax
.text$mn:000034EC                 mov     ecx, [ebp+arg_0]
.text$mn:000034EF                 push    ecx
.text$mn:000034F0                 call    ??$_Ptr_cat@UColumnModeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUColumnModeInfo@@0@Z ; std::_Ptr_cat<ColumnModeInfo,ColumnModeInfo>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000034F5                 add     esp, 8
.text$mn:000034F8                 mov     [ebp+var_1], al
.text$mn:000034FB                 movzx   edx, [ebp+var_1]
.text$mn:000034FF                 push    edx
.text$mn:00003500                 mov     eax, [ebp+arg_8]
.text$mn:00003503                 push    eax
.text$mn:00003504                 mov     ecx, [ebp+arg_4]
.text$mn:00003507                 push    ecx
.text$mn:00003508                 mov     edx, [ebp+arg_0]
.text$mn:0000350B                 push    edx
.text$mn:0000350C                 call    ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003511                 add     esp, 10h
.text$mn:00003514                 mov     esp, ebp
.text$mn:00003516                 pop     ebp
.text$mn:00003517                 retn
.text$mn:00003517 ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00@Z endp
.text$mn:00003517
.text$mn:00003517 _text$mn        ends
.text$mn:00003517
.text$mn:00003518 ; ===========================================================================
.text$mn:00003518
.text$mn:00003518 ; Segment type: Pure code
.text$mn:00003518 ; Segment permissions: Read/Execute
.text$mn:00003518 _text$mn        segment para public 'CODE' use32
.text$mn:00003518                 assume cs:_text$mn
.text$mn:00003518                 ;org 3518h
.text$mn:00003518 ; COMDAT (pick any)
.text$mn:00003518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003518
.text$mn:00003518 ; =============== S U B R O U T I N E =======================================
.text$mn:00003518
.text$mn:00003518 ; Attributes: bp-based frame
.text$mn:00003518
.text$mn:00003518 ; struct ColumnModeInfo * __cdecl std::_Move_backward<struct ColumnModeInfo *, struct ColumnModeInfo *>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003518                 public ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003518 ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003518                                         ; CODE XREF: std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *)+28p
.text$mn:00003518
.text$mn:00003518 arg_0           = dword ptr  8
.text$mn:00003518 arg_4           = dword ptr  0Ch
.text$mn:00003518 arg_8           = dword ptr  10h
.text$mn:00003518
.text$mn:00003518                 push    ebp
.text$mn:00003519                 mov     ebp, esp
.text$mn:0000351B
.text$mn:0000351B loc_351B:                               ; CODE XREF: std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,std::_Nonscalar_ptr_iterator_tag)+4Ej
.text$mn:0000351B                 mov     eax, [ebp+arg_0]
.text$mn:0000351E                 cmp     eax, [ebp+arg_4]
.text$mn:00003521                 jz      short loc_3568
.text$mn:00003523                 mov     ecx, [ebp+arg_4]
.text$mn:00003526                 sub     ecx, 18h
.text$mn:00003529                 mov     [ebp+arg_4], ecx
.text$mn:0000352C                 mov     edx, [ebp+arg_8]
.text$mn:0000352F                 sub     edx, 18h
.text$mn:00003532                 mov     [ebp+arg_8], edx
.text$mn:00003535                 mov     eax, [ebp+arg_4]
.text$mn:00003538                 push    eax
.text$mn:00003539                 call    ??$move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000353E                 add     esp, 4
.text$mn:00003541                 mov     ecx, [ebp+arg_8]
.text$mn:00003544                 mov     edx, [eax]
.text$mn:00003546                 mov     [ecx], edx
.text$mn:00003548                 mov     edx, [eax+4]
.text$mn:0000354B                 mov     [ecx+4], edx
.text$mn:0000354E                 mov     edx, [eax+8]
.text$mn:00003551                 mov     [ecx+8], edx
.text$mn:00003554                 mov     edx, [eax+0Ch]
.text$mn:00003557                 mov     [ecx+0Ch], edx
.text$mn:0000355A                 mov     edx, [eax+10h]
.text$mn:0000355D                 mov     [ecx+10h], edx
.text$mn:00003560                 mov     eax, [eax+14h]
.text$mn:00003563                 mov     [ecx+14h], eax
.text$mn:00003566                 jmp     short loc_351B
.text$mn:00003568 ; ---------------------------------------------------------------------------
.text$mn:00003568
.text$mn:00003568 loc_3568:                               ; CODE XREF: std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,std::_Nonscalar_ptr_iterator_tag)+9j
.text$mn:00003568                 mov     eax, [ebp+arg_8]
.text$mn:0000356B                 pop     ebp
.text$mn:0000356C                 retn
.text$mn:0000356C ??$_Move_backward@PAUColumnModeInfo@@PAU1@@std@@YAPAUColumnModeInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000356C
.text$mn:0000356C ; ---------------------------------------------------------------------------
.text$mn:0000356D                 align 10h
.text$mn:0000356D _text$mn        ends
.text$mn:0000356D
.text$mn:00003570 ; ===========================================================================
.text$mn:00003570
.text$mn:00003570 ; Segment type: Pure code
.text$mn:00003570 ; Segment permissions: Read/Execute
.text$mn:00003570 _text$mn        segment para public 'CODE' use32
.text$mn:00003570                 assume cs:_text$mn
.text$mn:00003570                 ;org 3570h
.text$mn:00003570 ; COMDAT (pick any)
.text$mn:00003570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003570
.text$mn:00003570 ; =============== S U B R O U T I N E =======================================
.text$mn:00003570
.text$mn:00003570 ; Attributes: bp-based frame
.text$mn:00003570
.text$mn:00003570 ; void __cdecl std::_Pop_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo &&, struct SortInPositionOrder, int *)
.text$mn:00003570                 public ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInPositionOrder@@PAH@Z
.text$mn:00003570 ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInPositionOrder@@PAH@Z proc near
.text$mn:00003570                                         ; CODE XREF: std::_Pop_heap_0<ColumnModeInfo *,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)+69p
.text$mn:00003570
.text$mn:00003570 arg_0           = dword ptr  8
.text$mn:00003570 arg_4           = dword ptr  0Ch
.text$mn:00003570 arg_8           = dword ptr  10h
.text$mn:00003570 arg_C           = dword ptr  14h
.text$mn:00003570 arg_10          = byte ptr  18h
.text$mn:00003570
.text$mn:00003570                 push    ebp
.text$mn:00003571                 mov     ebp, esp
.text$mn:00003573                 mov     eax, [ebp+arg_0]
.text$mn:00003576                 push    eax
.text$mn:00003577                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000357C                 add     esp, 4
.text$mn:0000357F                 mov     ecx, [ebp+arg_8]
.text$mn:00003582                 mov     edx, [eax]
.text$mn:00003584                 mov     [ecx], edx
.text$mn:00003586                 mov     edx, [eax+4]
.text$mn:00003589                 mov     [ecx+4], edx
.text$mn:0000358C                 mov     edx, [eax+8]
.text$mn:0000358F                 mov     [ecx+8], edx
.text$mn:00003592                 mov     edx, [eax+0Ch]
.text$mn:00003595                 mov     [ecx+0Ch], edx
.text$mn:00003598                 mov     edx, [eax+10h]
.text$mn:0000359B                 mov     [ecx+10h], edx
.text$mn:0000359E                 mov     eax, [eax+14h]
.text$mn:000035A1                 mov     [ecx+14h], eax
.text$mn:000035A4                 movzx   ecx, [ebp+arg_10]
.text$mn:000035A8                 push    ecx
.text$mn:000035A9                 mov     edx, [ebp+arg_C]
.text$mn:000035AC                 push    edx
.text$mn:000035AD                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000035B2                 add     esp, 4
.text$mn:000035B5                 push    eax
.text$mn:000035B6                 mov     eax, [ebp+arg_4]
.text$mn:000035B9                 sub     eax, [ebp+arg_0]
.text$mn:000035BC                 cdq
.text$mn:000035BD                 mov     ecx, 18h
.text$mn:000035C2                 idiv    ecx
.text$mn:000035C4                 push    eax
.text$mn:000035C5                 push    0
.text$mn:000035C7                 mov     edx, [ebp+arg_0]
.text$mn:000035CA                 push    edx
.text$mn:000035CB                 call    ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z ; std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)
.text$mn:000035D0                 add     esp, 14h
.text$mn:000035D3                 pop     ebp
.text$mn:000035D4                 retn
.text$mn:000035D4 ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInPositionOrder@@PAH@Z endp
.text$mn:000035D4
.text$mn:000035D4 ; ---------------------------------------------------------------------------
.text$mn:000035D5                 align 4
.text$mn:000035D5 _text$mn        ends
.text$mn:000035D5
.text$mn:000035D8 ; ===========================================================================
.text$mn:000035D8
.text$mn:000035D8 ; Segment type: Pure code
.text$mn:000035D8 ; Segment permissions: Read/Execute
.text$mn:000035D8 _text$mn        segment para public 'CODE' use32
.text$mn:000035D8                 assume cs:_text$mn
.text$mn:000035D8                 ;org 35D8h
.text$mn:000035D8 ; COMDAT (pick any)
.text$mn:000035D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035D8
.text$mn:000035D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000035D8
.text$mn:000035D8 ; Attributes: bp-based frame
.text$mn:000035D8
.text$mn:000035D8 ; void __cdecl std::_Pop_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo *, struct ColumnModeInfo &&, struct SortInSelectOrder, int *)
.text$mn:000035D8                 public ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInSelectOrder@@PAH@Z
.text$mn:000035D8 ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInSelectOrder@@PAH@Z proc near
.text$mn:000035D8                                         ; CODE XREF: std::_Pop_heap_0<ColumnModeInfo *,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)+69p
.text$mn:000035D8
.text$mn:000035D8 arg_0           = dword ptr  8
.text$mn:000035D8 arg_4           = dword ptr  0Ch
.text$mn:000035D8 arg_8           = dword ptr  10h
.text$mn:000035D8 arg_C           = dword ptr  14h
.text$mn:000035D8 arg_10          = byte ptr  18h
.text$mn:000035D8
.text$mn:000035D8                 push    ebp
.text$mn:000035D9                 mov     ebp, esp
.text$mn:000035DB                 mov     eax, [ebp+arg_0]
.text$mn:000035DE                 push    eax
.text$mn:000035DF                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000035E4                 add     esp, 4
.text$mn:000035E7                 mov     ecx, [ebp+arg_8]
.text$mn:000035EA                 mov     edx, [eax]
.text$mn:000035EC                 mov     [ecx], edx
.text$mn:000035EE                 mov     edx, [eax+4]
.text$mn:000035F1                 mov     [ecx+4], edx
.text$mn:000035F4                 mov     edx, [eax+8]
.text$mn:000035F7                 mov     [ecx+8], edx
.text$mn:000035FA                 mov     edx, [eax+0Ch]
.text$mn:000035FD                 mov     [ecx+0Ch], edx
.text$mn:00003600                 mov     edx, [eax+10h]
.text$mn:00003603                 mov     [ecx+10h], edx
.text$mn:00003606                 mov     eax, [eax+14h]
.text$mn:00003609                 mov     [ecx+14h], eax
.text$mn:0000360C                 movzx   ecx, [ebp+arg_10]
.text$mn:00003610                 push    ecx
.text$mn:00003611                 mov     edx, [ebp+arg_C]
.text$mn:00003614                 push    edx
.text$mn:00003615                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000361A                 add     esp, 4
.text$mn:0000361D                 push    eax
.text$mn:0000361E                 mov     eax, [ebp+arg_4]
.text$mn:00003621                 sub     eax, [ebp+arg_0]
.text$mn:00003624                 cdq
.text$mn:00003625                 mov     ecx, 18h
.text$mn:0000362A                 idiv    ecx
.text$mn:0000362C                 push    eax
.text$mn:0000362D                 push    0
.text$mn:0000362F                 mov     edx, [ebp+arg_0]
.text$mn:00003632                 push    edx
.text$mn:00003633                 call    ??$_Adjust_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z ; std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)
.text$mn:00003638                 add     esp, 14h
.text$mn:0000363B                 pop     ebp
.text$mn:0000363C                 retn
.text$mn:0000363C ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInSelectOrder@@PAH@Z endp
.text$mn:0000363C
.text$mn:0000363C ; ---------------------------------------------------------------------------
.text$mn:0000363D                 align 10h
.text$mn:0000363D _text$mn        ends
.text$mn:0000363D
.text$mn:00003640 ; ===========================================================================
.text$mn:00003640
.text$mn:00003640 ; Segment type: Pure code
.text$mn:00003640 ; Segment permissions: Read/Execute
.text$mn:00003640 _text$mn        segment para public 'CODE' use32
.text$mn:00003640                 assume cs:_text$mn
.text$mn:00003640                 ;org 3640h
.text$mn:00003640 ; COMDAT (pick any)
.text$mn:00003640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003640
.text$mn:00003640 ; =============== S U B R O U T I N E =======================================
.text$mn:00003640
.text$mn:00003640 ; Attributes: bp-based frame
.text$mn:00003640
.text$mn:00003640 ; void __cdecl std::_Pop_heap<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:00003640                 public ??$_Pop_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z
.text$mn:00003640 ??$_Pop_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z proc near
.text$mn:00003640                                         ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+2Ep
.text$mn:00003640
.text$mn:00003640 arg_0           = dword ptr  8
.text$mn:00003640 arg_4           = dword ptr  0Ch
.text$mn:00003640 arg_8           = byte ptr  10h
.text$mn:00003640
.text$mn:00003640                 push    ebp
.text$mn:00003641                 mov     ebp, esp
.text$mn:00003643                 mov     eax, [ebp+arg_0]
.text$mn:00003646                 push    eax
.text$mn:00003647                 call    ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Val_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:0000364C                 add     esp, 4
.text$mn:0000364F                 push    eax
.text$mn:00003650                 movzx   ecx, [ebp+arg_8]
.text$mn:00003654                 push    ecx
.text$mn:00003655                 mov     edx, [ebp+arg_4]
.text$mn:00003658                 push    edx
.text$mn:00003659                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:0000365E                 add     esp, 4
.text$mn:00003661                 push    eax
.text$mn:00003662                 mov     eax, [ebp+arg_0]
.text$mn:00003665                 push    eax
.text$mn:00003666                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:0000366B                 add     esp, 4
.text$mn:0000366E                 push    eax
.text$mn:0000366F                 call    ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z ; std::_Pop_heap_0<ColumnModeInfo *,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,ColumnModeInfo *)
.text$mn:00003674                 add     esp, 10h
.text$mn:00003677                 pop     ebp
.text$mn:00003678                 retn
.text$mn:00003678 ??$_Pop_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z endp
.text$mn:00003678
.text$mn:00003678 ; ---------------------------------------------------------------------------
.text$mn:00003679                 align 4
.text$mn:00003679 _text$mn        ends
.text$mn:00003679
.text$mn:0000367C ; ===========================================================================
.text$mn:0000367C
.text$mn:0000367C ; Segment type: Pure code
.text$mn:0000367C ; Segment permissions: Read/Execute
.text$mn:0000367C _text$mn        segment para public 'CODE' use32
.text$mn:0000367C                 assume cs:_text$mn
.text$mn:0000367C                 ;org 367Ch
.text$mn:0000367C ; COMDAT (pick any)
.text$mn:0000367C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000367C
.text$mn:0000367C ; =============== S U B R O U T I N E =======================================
.text$mn:0000367C
.text$mn:0000367C ; Attributes: bp-based frame
.text$mn:0000367C
.text$mn:0000367C ; void __cdecl std::_Pop_heap<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:0000367C                 public ??$_Pop_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z
.text$mn:0000367C ??$_Pop_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z proc near
.text$mn:0000367C                                         ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+2Ep
.text$mn:0000367C
.text$mn:0000367C arg_0           = dword ptr  8
.text$mn:0000367C arg_4           = dword ptr  0Ch
.text$mn:0000367C arg_8           = byte ptr  10h
.text$mn:0000367C
.text$mn:0000367C                 push    ebp
.text$mn:0000367D                 mov     ebp, esp
.text$mn:0000367F                 mov     eax, [ebp+arg_0]
.text$mn:00003682                 push    eax
.text$mn:00003683                 call    ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Val_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00003688                 add     esp, 4
.text$mn:0000368B                 push    eax
.text$mn:0000368C                 movzx   ecx, [ebp+arg_8]
.text$mn:00003690                 push    ecx
.text$mn:00003691                 mov     edx, [ebp+arg_4]
.text$mn:00003694                 push    edx
.text$mn:00003695                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:0000369A                 add     esp, 4
.text$mn:0000369D                 push    eax
.text$mn:0000369E                 mov     eax, [ebp+arg_0]
.text$mn:000036A1                 push    eax
.text$mn:000036A2                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:000036A7                 add     esp, 4
.text$mn:000036AA                 push    eax
.text$mn:000036AB                 call    ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z ; std::_Pop_heap_0<ColumnModeInfo *,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,ColumnModeInfo *)
.text$mn:000036B0                 add     esp, 10h
.text$mn:000036B3                 pop     ebp
.text$mn:000036B4                 retn
.text$mn:000036B4 ??$_Pop_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z endp
.text$mn:000036B4
.text$mn:000036B4 ; ---------------------------------------------------------------------------
.text$mn:000036B5                 align 4
.text$mn:000036B5 _text$mn        ends
.text$mn:000036B5
.text$mn:000036B8 ; ===========================================================================
.text$mn:000036B8
.text$mn:000036B8 ; Segment type: Pure code
.text$mn:000036B8 ; Segment permissions: Read/Execute
.text$mn:000036B8 _text$mn        segment para public 'CODE' use32
.text$mn:000036B8                 assume cs:_text$mn
.text$mn:000036B8                 ;org 36B8h
.text$mn:000036B8 ; COMDAT (pick any)
.text$mn:000036B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036B8
.text$mn:000036B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000036B8
.text$mn:000036B8 ; Attributes: bp-based frame
.text$mn:000036B8
.text$mn:000036B8 ; void __cdecl std::_Pop_heap_0<struct ColumnModeInfo *, struct ColumnModeInfo, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder, struct ColumnModeInfo *)
.text$mn:000036B8                 public ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z
.text$mn:000036B8 ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z proc near
.text$mn:000036B8                                         ; CODE XREF: std::_Pop_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+2Fp
.text$mn:000036B8
.text$mn:000036B8 var_18          = dword ptr -18h
.text$mn:000036B8 var_14          = dword ptr -14h
.text$mn:000036B8 var_10          = dword ptr -10h
.text$mn:000036B8 var_C           = dword ptr -0Ch
.text$mn:000036B8 var_8           = dword ptr -8
.text$mn:000036B8 var_4           = dword ptr -4
.text$mn:000036B8 arg_0           = dword ptr  8
.text$mn:000036B8 arg_4           = dword ptr  0Ch
.text$mn:000036B8 arg_8           = byte ptr  10h
.text$mn:000036B8
.text$mn:000036B8                 push    ebp
.text$mn:000036B9                 mov     ebp, esp
.text$mn:000036BB                 sub     esp, 18h
.text$mn:000036BE                 mov     eax, [ebp+arg_4]
.text$mn:000036C1                 sub     eax, 18h
.text$mn:000036C4                 push    eax
.text$mn:000036C5                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000036CA                 add     esp, 4
.text$mn:000036CD                 mov     ecx, [eax]
.text$mn:000036CF                 mov     [ebp+var_18], ecx
.text$mn:000036D2                 mov     edx, [eax+4]
.text$mn:000036D5                 mov     [ebp+var_14], edx
.text$mn:000036D8                 mov     ecx, [eax+8]
.text$mn:000036DB                 mov     [ebp+var_10], ecx
.text$mn:000036DE                 mov     edx, [eax+0Ch]
.text$mn:000036E1                 mov     [ebp+var_C], edx
.text$mn:000036E4                 mov     ecx, [eax+10h]
.text$mn:000036E7                 mov     [ebp+var_8], ecx
.text$mn:000036EA                 mov     edx, [eax+14h]
.text$mn:000036ED                 mov     [ebp+var_4], edx
.text$mn:000036F0                 mov     eax, [ebp+arg_0]
.text$mn:000036F3                 push    eax
.text$mn:000036F4                 call    ??$_Dist_type@PAUColumnModeInfo@@@std@@YAPAHPAUColumnModeInfo@@@Z ; std::_Dist_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:000036F9                 add     esp, 4
.text$mn:000036FC                 push    eax
.text$mn:000036FD                 movzx   ecx, [ebp+arg_8]
.text$mn:00003701                 push    ecx
.text$mn:00003702                 lea     edx, [ebp+var_18]
.text$mn:00003705                 push    edx
.text$mn:00003706                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:0000370B                 add     esp, 4
.text$mn:0000370E                 push    eax
.text$mn:0000370F                 mov     eax, [ebp+arg_4]
.text$mn:00003712                 sub     eax, 18h
.text$mn:00003715                 push    eax
.text$mn:00003716                 mov     ecx, [ebp+arg_4]
.text$mn:00003719                 sub     ecx, 18h
.text$mn:0000371C                 push    ecx
.text$mn:0000371D                 mov     edx, [ebp+arg_0]
.text$mn:00003720                 push    edx
.text$mn:00003721                 call    ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInPositionOrder@@PAH@Z ; std::_Pop_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo &&,SortInPositionOrder,int *)
.text$mn:00003726                 add     esp, 18h
.text$mn:00003729                 mov     esp, ebp
.text$mn:0000372B                 pop     ebp
.text$mn:0000372C                 retn
.text$mn:0000372C ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@0@Z endp
.text$mn:0000372C
.text$mn:0000372C ; ---------------------------------------------------------------------------
.text$mn:0000372D                 align 10h
.text$mn:0000372D _text$mn        ends
.text$mn:0000372D
.text$mn:00003730 ; ===========================================================================
.text$mn:00003730
.text$mn:00003730 ; Segment type: Pure code
.text$mn:00003730 ; Segment permissions: Read/Execute
.text$mn:00003730 _text$mn        segment para public 'CODE' use32
.text$mn:00003730                 assume cs:_text$mn
.text$mn:00003730                 ;org 3730h
.text$mn:00003730 ; COMDAT (pick any)
.text$mn:00003730                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003730
.text$mn:00003730 ; =============== S U B R O U T I N E =======================================
.text$mn:00003730
.text$mn:00003730 ; Attributes: bp-based frame
.text$mn:00003730
.text$mn:00003730 ; void __cdecl std::_Pop_heap_0<struct ColumnModeInfo *, struct ColumnModeInfo, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder, struct ColumnModeInfo *)
.text$mn:00003730                 public ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z
.text$mn:00003730 ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z proc near
.text$mn:00003730                                         ; CODE XREF: std::_Pop_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+2Fp
.text$mn:00003730
.text$mn:00003730 var_18          = dword ptr -18h
.text$mn:00003730 var_14          = dword ptr -14h
.text$mn:00003730 var_10          = dword ptr -10h
.text$mn:00003730 var_C           = dword ptr -0Ch
.text$mn:00003730 var_8           = dword ptr -8
.text$mn:00003730 var_4           = dword ptr -4
.text$mn:00003730 arg_0           = dword ptr  8
.text$mn:00003730 arg_4           = dword ptr  0Ch
.text$mn:00003730 arg_8           = byte ptr  10h
.text$mn:00003730
.text$mn:00003730                 push    ebp
.text$mn:00003731                 mov     ebp, esp
.text$mn:00003733                 sub     esp, 18h
.text$mn:00003736                 mov     eax, [ebp+arg_4]
.text$mn:00003739                 sub     eax, 18h
.text$mn:0000373C                 push    eax
.text$mn:0000373D                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003742                 add     esp, 4
.text$mn:00003745                 mov     ecx, [eax]
.text$mn:00003747                 mov     [ebp+var_18], ecx
.text$mn:0000374A                 mov     edx, [eax+4]
.text$mn:0000374D                 mov     [ebp+var_14], edx
.text$mn:00003750                 mov     ecx, [eax+8]
.text$mn:00003753                 mov     [ebp+var_10], ecx
.text$mn:00003756                 mov     edx, [eax+0Ch]
.text$mn:00003759                 mov     [ebp+var_C], edx
.text$mn:0000375C                 mov     ecx, [eax+10h]
.text$mn:0000375F                 mov     [ebp+var_8], ecx
.text$mn:00003762                 mov     edx, [eax+14h]
.text$mn:00003765                 mov     [ebp+var_4], edx
.text$mn:00003768                 mov     eax, [ebp+arg_0]
.text$mn:0000376B                 push    eax
.text$mn:0000376C                 call    ??$_Dist_type@PAUColumnModeInfo@@@std@@YAPAHPAUColumnModeInfo@@@Z ; std::_Dist_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00003771                 add     esp, 4
.text$mn:00003774                 push    eax
.text$mn:00003775                 movzx   ecx, [ebp+arg_8]
.text$mn:00003779                 push    ecx
.text$mn:0000377A                 lea     edx, [ebp+var_18]
.text$mn:0000377D                 push    edx
.text$mn:0000377E                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003783                 add     esp, 4
.text$mn:00003786                 push    eax
.text$mn:00003787                 mov     eax, [ebp+arg_4]
.text$mn:0000378A                 sub     eax, 18h
.text$mn:0000378D                 push    eax
.text$mn:0000378E                 mov     ecx, [ebp+arg_4]
.text$mn:00003791                 sub     ecx, 18h
.text$mn:00003794                 push    ecx
.text$mn:00003795                 mov     edx, [ebp+arg_0]
.text$mn:00003798                 push    edx
.text$mn:00003799                 call    ??$_Pop_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00$$QAU1@USortInSelectOrder@@PAH@Z ; std::_Pop_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo &&,SortInSelectOrder,int *)
.text$mn:0000379E                 add     esp, 18h
.text$mn:000037A1                 mov     esp, ebp
.text$mn:000037A3                 pop     ebp
.text$mn:000037A4                 retn
.text$mn:000037A4 ??$_Pop_heap_0@PAUColumnModeInfo@@U1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@0@Z endp
.text$mn:000037A4
.text$mn:000037A4 ; ---------------------------------------------------------------------------
.text$mn:000037A5                 align 4
.text$mn:000037A5 _text$mn        ends
.text$mn:000037A5
.text$mn:000037A8 ; ===========================================================================
.text$mn:000037A8
.text$mn:000037A8 ; Segment type: Pure code
.text$mn:000037A8 ; Segment permissions: Read/Execute
.text$mn:000037A8 _text$mn        segment para public 'CODE' use32
.text$mn:000037A8                 assume cs:_text$mn
.text$mn:000037A8                 ;org 37A8h
.text$mn:000037A8 ; COMDAT (pick any)
.text$mn:000037A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037A8
.text$mn:000037A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000037A8
.text$mn:000037A8 ; Attributes: bp-based frame
.text$mn:000037A8
.text$mn:000037A8 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<int, int>(int *, int *)
.text$mn:000037A8                 public ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
.text$mn:000037A8 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z proc near
.text$mn:000037A8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Cp
.text$mn:000037A8                                         ; std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Cp
.text$mn:000037A8
.text$mn:000037A8 var_1           = byte ptr -1
.text$mn:000037A8
.text$mn:000037A8                 push    ebp
.text$mn:000037A9                 mov     ebp, esp
.text$mn:000037AB                 push    ecx
.text$mn:000037AC                 mov     al, [ebp+var_1]
.text$mn:000037AF                 mov     esp, ebp
.text$mn:000037B1                 pop     ebp
.text$mn:000037B2                 retn
.text$mn:000037B2 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z endp
.text$mn:000037B2
.text$mn:000037B2 ; ---------------------------------------------------------------------------
.text$mn:000037B3                 align 4
.text$mn:000037B3 _text$mn        ends
.text$mn:000037B3
.text$mn:000037B4 ; ===========================================================================
.text$mn:000037B4
.text$mn:000037B4 ; Segment type: Pure code
.text$mn:000037B4 ; Segment permissions: Read/Execute
.text$mn:000037B4 _text$mn        segment para public 'CODE' use32
.text$mn:000037B4                 assume cs:_text$mn
.text$mn:000037B4                 ;org 37B4h
.text$mn:000037B4 ; COMDAT (pick any)
.text$mn:000037B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037B4
.text$mn:000037B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037B4
.text$mn:000037B4 ; Attributes: bp-based frame
.text$mn:000037B4
.text$mn:000037B4 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct ColumnModeInfo, struct ColumnModeInfo>(struct ColumnModeInfo *, struct ColumnModeInfo *)
.text$mn:000037B4                 public ??$_Ptr_cat@UColumnModeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUColumnModeInfo@@0@Z
.text$mn:000037B4 ??$_Ptr_cat@UColumnModeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUColumnModeInfo@@0@Z proc near
.text$mn:000037B4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &)+Cp
.text$mn:000037B4                                         ; std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *)+Cp
.text$mn:000037B4
.text$mn:000037B4 var_1           = byte ptr -1
.text$mn:000037B4
.text$mn:000037B4                 push    ebp
.text$mn:000037B5                 mov     ebp, esp
.text$mn:000037B7                 push    ecx
.text$mn:000037B8                 mov     al, [ebp+var_1]
.text$mn:000037BB                 mov     esp, ebp
.text$mn:000037BD                 pop     ebp
.text$mn:000037BE                 retn
.text$mn:000037BE ??$_Ptr_cat@UColumnModeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUColumnModeInfo@@0@Z endp
.text$mn:000037BE
.text$mn:000037BE ; ---------------------------------------------------------------------------
.text$mn:000037BF                 align 10h
.text$mn:000037BF _text$mn        ends
.text$mn:000037BF
.text$mn:000037C0 ; ===========================================================================
.text$mn:000037C0
.text$mn:000037C0 ; Segment type: Pure code
.text$mn:000037C0 ; Segment permissions: Read/Execute
.text$mn:000037C0 _text$mn        segment para public 'CODE' use32
.text$mn:000037C0                 assume cs:_text$mn
.text$mn:000037C0                 ;org 37C0h
.text$mn:000037C0 ; COMDAT (pick any)
.text$mn:000037C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037C0
.text$mn:000037C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037C0
.text$mn:000037C0 ; Attributes: bp-based frame
.text$mn:000037C0
.text$mn:000037C0 ; void __cdecl std::_Push_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInPositionOrder>(struct ColumnModeInfo *, int, int, struct ColumnModeInfo &&, struct SortInPositionOrder)
.text$mn:000037C0                 public ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z
.text$mn:000037C0 ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z proc near
.text$mn:000037C0                                         ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+11Bp
.text$mn:000037C0
.text$mn:000037C0 var_4           = dword ptr -4
.text$mn:000037C0 arg_0           = dword ptr  8
.text$mn:000037C0 arg_4           = dword ptr  0Ch
.text$mn:000037C0 arg_8           = dword ptr  10h
.text$mn:000037C0 arg_C           = dword ptr  14h
.text$mn:000037C0 arg_10          = byte ptr  18h
.text$mn:000037C0
.text$mn:000037C0                 push    ebp
.text$mn:000037C1                 mov     ebp, esp
.text$mn:000037C3                 push    ecx
.text$mn:000037C4                 mov     eax, [ebp+arg_4]
.text$mn:000037C7                 sub     eax, 1
.text$mn:000037CA                 cdq
.text$mn:000037CB                 sub     eax, edx
.text$mn:000037CD                 sar     eax, 1
.text$mn:000037CF                 mov     [ebp+var_4], eax
.text$mn:000037D2                 jmp     short loc_37E2
.text$mn:000037D4 ; ---------------------------------------------------------------------------
.text$mn:000037D4
.text$mn:000037D4 loc_37D4:                               ; CODE XREF: std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+93j
.text$mn:000037D4                 mov     eax, [ebp+arg_4]
.text$mn:000037D7                 sub     eax, 1
.text$mn:000037DA                 cdq
.text$mn:000037DB                 sub     eax, edx
.text$mn:000037DD                 sar     eax, 1
.text$mn:000037DF                 mov     [ebp+var_4], eax
.text$mn:000037E2
.text$mn:000037E2 loc_37E2:                               ; CODE XREF: std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+12j
.text$mn:000037E2                 mov     eax, [ebp+arg_8]
.text$mn:000037E5                 cmp     eax, [ebp+arg_4]
.text$mn:000037E8                 jge     short loc_3858
.text$mn:000037EA                 push    90Bh            ; unsigned int
.text$mn:000037EF                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000037F4                 mov     ecx, [ebp+arg_C]
.text$mn:000037F7                 push    ecx             ; int
.text$mn:000037F8                 imul    edx, [ebp+var_4], 18h
.text$mn:000037FC                 add     edx, [ebp+arg_0]
.text$mn:000037FF                 push    edx             ; int
.text$mn:00003800                 movzx   eax, [ebp+arg_10]
.text$mn:00003804                 push    eax             ; char
.text$mn:00003805                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:0000380A                 add     esp, 14h
.text$mn:0000380D                 movzx   ecx, al
.text$mn:00003810                 test    ecx, ecx
.text$mn:00003812                 jz      short loc_3858
.text$mn:00003814                 imul    edx, [ebp+var_4], 18h
.text$mn:00003818                 add     edx, [ebp+arg_0]
.text$mn:0000381B                 push    edx
.text$mn:0000381C                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003821                 add     esp, 4
.text$mn:00003824                 imul    ecx, [ebp+arg_4], 18h
.text$mn:00003828                 add     ecx, [ebp+arg_0]
.text$mn:0000382B                 mov     edx, [eax]
.text$mn:0000382D                 mov     [ecx], edx
.text$mn:0000382F                 mov     edx, [eax+4]
.text$mn:00003832                 mov     [ecx+4], edx
.text$mn:00003835                 mov     edx, [eax+8]
.text$mn:00003838                 mov     [ecx+8], edx
.text$mn:0000383B                 mov     edx, [eax+0Ch]
.text$mn:0000383E                 mov     [ecx+0Ch], edx
.text$mn:00003841                 mov     edx, [eax+10h]
.text$mn:00003844                 mov     [ecx+10h], edx
.text$mn:00003847                 mov     eax, [eax+14h]
.text$mn:0000384A                 mov     [ecx+14h], eax
.text$mn:0000384D                 mov     ecx, [ebp+var_4]
.text$mn:00003850                 mov     [ebp+arg_4], ecx
.text$mn:00003853                 jmp     loc_37D4
.text$mn:00003858 ; ---------------------------------------------------------------------------
.text$mn:00003858
.text$mn:00003858 loc_3858:                               ; CODE XREF: std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+28j
.text$mn:00003858                                         ; std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+52j
.text$mn:00003858                 mov     edx, [ebp+arg_C]
.text$mn:0000385B                 push    edx
.text$mn:0000385C                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003861                 add     esp, 4
.text$mn:00003864                 imul    ecx, [ebp+arg_4], 18h
.text$mn:00003868                 add     ecx, [ebp+arg_0]
.text$mn:0000386B                 mov     edx, [eax]
.text$mn:0000386D                 mov     [ecx], edx
.text$mn:0000386F                 mov     edx, [eax+4]
.text$mn:00003872                 mov     [ecx+4], edx
.text$mn:00003875                 mov     edx, [eax+8]
.text$mn:00003878                 mov     [ecx+8], edx
.text$mn:0000387B                 mov     edx, [eax+0Ch]
.text$mn:0000387E                 mov     [ecx+0Ch], edx
.text$mn:00003881                 mov     edx, [eax+10h]
.text$mn:00003884                 mov     [ecx+10h], edx
.text$mn:00003887                 mov     eax, [eax+14h]
.text$mn:0000388A                 mov     [ecx+14h], eax
.text$mn:0000388D                 mov     esp, ebp
.text$mn:0000388F                 pop     ebp
.text$mn:00003890                 retn
.text$mn:00003890 ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInPositionOrder@@@Z endp
.text$mn:00003890
.text$mn:00003890 ; ---------------------------------------------------------------------------
.text$mn:00003891                 align 4
.text$mn:00003891 _text$mn        ends
.text$mn:00003891
.text$mn:00003894 ; ===========================================================================
.text$mn:00003894
.text$mn:00003894 ; Segment type: Pure code
.text$mn:00003894 ; Segment permissions: Read/Execute
.text$mn:00003894 _text$mn        segment para public 'CODE' use32
.text$mn:00003894                 assume cs:_text$mn
.text$mn:00003894                 ;org 3894h
.text$mn:00003894 ; COMDAT (pick any)
.text$mn:00003894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003894
.text$mn:00003894 ; =============== S U B R O U T I N E =======================================
.text$mn:00003894
.text$mn:00003894 ; Attributes: bp-based frame
.text$mn:00003894
.text$mn:00003894 ; void __cdecl std::_Push_heap<struct ColumnModeInfo *, int, struct ColumnModeInfo, struct SortInSelectOrder>(struct ColumnModeInfo *, int, int, struct ColumnModeInfo &&, struct SortInSelectOrder)
.text$mn:00003894                 public ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z
.text$mn:00003894 ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z proc near
.text$mn:00003894                                         ; CODE XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+11Bp
.text$mn:00003894
.text$mn:00003894 var_4           = dword ptr -4
.text$mn:00003894 arg_0           = dword ptr  8
.text$mn:00003894 arg_4           = dword ptr  0Ch
.text$mn:00003894 arg_8           = dword ptr  10h
.text$mn:00003894 arg_C           = dword ptr  14h
.text$mn:00003894 arg_10          = byte ptr  18h
.text$mn:00003894
.text$mn:00003894                 push    ebp
.text$mn:00003895                 mov     ebp, esp
.text$mn:00003897                 push    ecx
.text$mn:00003898                 mov     eax, [ebp+arg_4]
.text$mn:0000389B                 sub     eax, 1
.text$mn:0000389E                 cdq
.text$mn:0000389F                 sub     eax, edx
.text$mn:000038A1                 sar     eax, 1
.text$mn:000038A3                 mov     [ebp+var_4], eax
.text$mn:000038A6                 jmp     short loc_38B6
.text$mn:000038A8 ; ---------------------------------------------------------------------------
.text$mn:000038A8
.text$mn:000038A8 loc_38A8:                               ; CODE XREF: std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+93j
.text$mn:000038A8                 mov     eax, [ebp+arg_4]
.text$mn:000038AB                 sub     eax, 1
.text$mn:000038AE                 cdq
.text$mn:000038AF                 sub     eax, edx
.text$mn:000038B1                 sar     eax, 1
.text$mn:000038B3                 mov     [ebp+var_4], eax
.text$mn:000038B6
.text$mn:000038B6 loc_38B6:                               ; CODE XREF: std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+12j
.text$mn:000038B6                 mov     eax, [ebp+arg_8]
.text$mn:000038B9                 cmp     eax, [ebp+arg_4]
.text$mn:000038BC                 jge     short loc_392C
.text$mn:000038BE                 push    90Bh            ; unsigned int
.text$mn:000038C3                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000038C8                 mov     ecx, [ebp+arg_C]
.text$mn:000038CB                 push    ecx             ; int
.text$mn:000038CC                 imul    edx, [ebp+var_4], 18h
.text$mn:000038D0                 add     edx, [ebp+arg_0]
.text$mn:000038D3                 push    edx             ; int
.text$mn:000038D4                 movzx   eax, [ebp+arg_10]
.text$mn:000038D8                 push    eax             ; char
.text$mn:000038D9                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000038DE                 add     esp, 14h
.text$mn:000038E1                 movzx   ecx, al
.text$mn:000038E4                 test    ecx, ecx
.text$mn:000038E6                 jz      short loc_392C
.text$mn:000038E8                 imul    edx, [ebp+var_4], 18h
.text$mn:000038EC                 add     edx, [ebp+arg_0]
.text$mn:000038EF                 push    edx
.text$mn:000038F0                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:000038F5                 add     esp, 4
.text$mn:000038F8                 imul    ecx, [ebp+arg_4], 18h
.text$mn:000038FC                 add     ecx, [ebp+arg_0]
.text$mn:000038FF                 mov     edx, [eax]
.text$mn:00003901                 mov     [ecx], edx
.text$mn:00003903                 mov     edx, [eax+4]
.text$mn:00003906                 mov     [ecx+4], edx
.text$mn:00003909                 mov     edx, [eax+8]
.text$mn:0000390C                 mov     [ecx+8], edx
.text$mn:0000390F                 mov     edx, [eax+0Ch]
.text$mn:00003912                 mov     [ecx+0Ch], edx
.text$mn:00003915                 mov     edx, [eax+10h]
.text$mn:00003918                 mov     [ecx+10h], edx
.text$mn:0000391B                 mov     eax, [eax+14h]
.text$mn:0000391E                 mov     [ecx+14h], eax
.text$mn:00003921                 mov     ecx, [ebp+var_4]
.text$mn:00003924                 mov     [ebp+arg_4], ecx
.text$mn:00003927                 jmp     loc_38A8
.text$mn:0000392C ; ---------------------------------------------------------------------------
.text$mn:0000392C
.text$mn:0000392C loc_392C:                               ; CODE XREF: std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+28j
.text$mn:0000392C                                         ; std::_Push_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+52j
.text$mn:0000392C                 mov     edx, [ebp+arg_C]
.text$mn:0000392F                 push    edx
.text$mn:00003930                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00003935                 add     esp, 4
.text$mn:00003938                 imul    ecx, [ebp+arg_4], 18h
.text$mn:0000393C                 add     ecx, [ebp+arg_0]
.text$mn:0000393F                 mov     edx, [eax]
.text$mn:00003941                 mov     [ecx], edx
.text$mn:00003943                 mov     edx, [eax+4]
.text$mn:00003946                 mov     [ecx+4], edx
.text$mn:00003949                 mov     edx, [eax+8]
.text$mn:0000394C                 mov     [ecx+8], edx
.text$mn:0000394F                 mov     edx, [eax+0Ch]
.text$mn:00003952                 mov     [ecx+0Ch], edx
.text$mn:00003955                 mov     edx, [eax+10h]
.text$mn:00003958                 mov     [ecx+10h], edx
.text$mn:0000395B                 mov     eax, [eax+14h]
.text$mn:0000395E                 mov     [ecx+14h], eax
.text$mn:00003961                 mov     esp, ebp
.text$mn:00003963                 pop     ebp
.text$mn:00003964                 retn
.text$mn:00003964 ??$_Push_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@HH$$QAU1@USortInSelectOrder@@@Z endp
.text$mn:00003964
.text$mn:00003964 ; ---------------------------------------------------------------------------
.text$mn:00003965                 align 4
.text$mn:00003965 _text$mn        ends
.text$mn:00003965
.text$mn:00003968 ; ===========================================================================
.text$mn:00003968
.text$mn:00003968 ; Segment type: Pure code
.text$mn:00003968 ; Segment permissions: Read/Execute
.text$mn:00003968 _text$mn        segment para public 'CODE' use32
.text$mn:00003968                 assume cs:_text$mn
.text$mn:00003968                 ;org 3968h
.text$mn:00003968 ; COMDAT (pick any)
.text$mn:00003968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003968
.text$mn:00003968 ; =============== S U B R O U T I N E =======================================
.text$mn:00003968
.text$mn:00003968 ; Attributes: bp-based frame
.text$mn:00003968
.text$mn:00003968 ; int * & __cdecl std::_Rechecked<int *, int *>(int * &, int *)
.text$mn:00003968                 public ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z
.text$mn:00003968 ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z proc near
.text$mn:00003968                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+3Bp
.text$mn:00003968
.text$mn:00003968 arg_0           = dword ptr  8
.text$mn:00003968 arg_4           = dword ptr  0Ch
.text$mn:00003968
.text$mn:00003968                 push    ebp
.text$mn:00003969                 mov     ebp, esp
.text$mn:0000396B                 mov     eax, [ebp+arg_0]
.text$mn:0000396E                 mov     ecx, [ebp+arg_4]
.text$mn:00003971                 mov     [eax], ecx
.text$mn:00003973                 mov     eax, [ebp+arg_0]
.text$mn:00003976                 pop     ebp
.text$mn:00003977                 retn
.text$mn:00003977 ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z endp
.text$mn:00003977
.text$mn:00003977 _text$mn        ends
.text$mn:00003977
.text$mn:00003978 ; ===========================================================================
.text$mn:00003978
.text$mn:00003978 ; Segment type: Pure code
.text$mn:00003978 ; Segment permissions: Read/Execute
.text$mn:00003978 _text$mn        segment para public 'CODE' use32
.text$mn:00003978                 assume cs:_text$mn
.text$mn:00003978                 ;org 3978h
.text$mn:00003978 ; COMDAT (pick any)
.text$mn:00003978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003978
.text$mn:00003978 ; =============== S U B R O U T I N E =======================================
.text$mn:00003978
.text$mn:00003978 ; Attributes: bp-based frame
.text$mn:00003978
.text$mn:00003978 ; void __cdecl std::_Sort<struct ColumnModeInfo *, int, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, int, struct SortInPositionOrder)
.text$mn:00003978                 public ??$_Sort@PAUColumnModeInfo@@HUSortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInPositionOrder@@@Z
.text$mn:00003978 ??$_Sort@PAUColumnModeInfo@@HUSortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInPositionOrder@@@Z proc near
.text$mn:00003978                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+91p
.text$mn:00003978                                         ; std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+B2p ...
.text$mn:00003978
.text$mn:00003978 var_C           = dword ptr -0Ch
.text$mn:00003978 var_8           = dword ptr -8
.text$mn:00003978 var_4           = dword ptr -4
.text$mn:00003978 arg_0           = dword ptr  8
.text$mn:00003978 arg_4           = dword ptr  0Ch
.text$mn:00003978 arg_8           = dword ptr  10h
.text$mn:00003978 arg_C           = byte ptr  14h
.text$mn:00003978
.text$mn:00003978                 push    ebp
.text$mn:00003979                 mov     ebp, esp
.text$mn:0000397B                 sub     esp, 0Ch
.text$mn:0000397E                 push    esi
.text$mn:0000397F
.text$mn:0000397F loc_397F:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder):loc_3A38j
.text$mn:0000397F                 mov     eax, [ebp+arg_4]
.text$mn:00003982                 sub     eax, [ebp+arg_0]
.text$mn:00003985                 cdq
.text$mn:00003986                 mov     ecx, 18h
.text$mn:0000398B                 idiv    ecx
.text$mn:0000398D                 mov     [ebp+var_4], eax
.text$mn:00003990                 cmp     [ebp+var_4], 20h ; ' '
.text$mn:00003994                 jle     loc_3A3D
.text$mn:0000399A                 cmp     [ebp+arg_8], 0
.text$mn:0000399E                 jle     loc_3A3D
.text$mn:000039A4                 movzx   edx, [ebp+arg_C]
.text$mn:000039A8                 push    edx
.text$mn:000039A9                 mov     eax, [ebp+arg_4]
.text$mn:000039AC                 push    eax
.text$mn:000039AD                 mov     ecx, [ebp+arg_0]
.text$mn:000039B0                 push    ecx
.text$mn:000039B1                 lea     edx, [ebp+var_C]
.text$mn:000039B4                 push    edx
.text$mn:000039B5                 call    ??$_Unguarded_partition@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInPositionOrder@@@Z ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:000039BA                 add     esp, 10h
.text$mn:000039BD                 mov     eax, [ebp+arg_8]
.text$mn:000039C0                 cdq
.text$mn:000039C1                 sub     eax, edx
.text$mn:000039C3                 sar     eax, 1
.text$mn:000039C5                 mov     [ebp+arg_8], eax
.text$mn:000039C8                 mov     eax, [ebp+arg_8]
.text$mn:000039CB                 cdq
.text$mn:000039CC                 sub     eax, edx
.text$mn:000039CE                 sar     eax, 1
.text$mn:000039D0                 add     eax, [ebp+arg_8]
.text$mn:000039D3                 mov     [ebp+arg_8], eax
.text$mn:000039D6                 mov     eax, [ebp+var_C]
.text$mn:000039D9                 sub     eax, [ebp+arg_0]
.text$mn:000039DC                 cdq
.text$mn:000039DD                 mov     ecx, 18h
.text$mn:000039E2                 idiv    ecx
.text$mn:000039E4                 mov     ecx, eax
.text$mn:000039E6                 mov     eax, [ebp+arg_4]
.text$mn:000039E9                 sub     eax, [ebp+var_8]
.text$mn:000039EC                 cdq
.text$mn:000039ED                 mov     esi, 18h
.text$mn:000039F2                 idiv    esi
.text$mn:000039F4                 cmp     ecx, eax
.text$mn:000039F6                 jge     short loc_3A19
.text$mn:000039F8                 movzx   edx, [ebp+arg_C]
.text$mn:000039FC                 push    edx
.text$mn:000039FD                 mov     eax, [ebp+arg_8]
.text$mn:00003A00                 push    eax
.text$mn:00003A01                 mov     ecx, [ebp+var_C]
.text$mn:00003A04                 push    ecx
.text$mn:00003A05                 mov     edx, [ebp+arg_0]
.text$mn:00003A08                 push    edx
.text$mn:00003A09                 call    ??$_Sort@PAUColumnModeInfo@@HUSortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInPositionOrder@@@Z ; std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)
.text$mn:00003A0E                 add     esp, 10h
.text$mn:00003A11                 mov     eax, [ebp+var_8]
.text$mn:00003A14                 mov     [ebp+arg_0], eax
.text$mn:00003A17                 jmp     short loc_3A38
.text$mn:00003A19 ; ---------------------------------------------------------------------------
.text$mn:00003A19
.text$mn:00003A19 loc_3A19:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+7Ej
.text$mn:00003A19                 movzx   ecx, [ebp+arg_C]
.text$mn:00003A1D                 push    ecx
.text$mn:00003A1E                 mov     edx, [ebp+arg_8]
.text$mn:00003A21                 push    edx
.text$mn:00003A22                 mov     eax, [ebp+arg_4]
.text$mn:00003A25                 push    eax
.text$mn:00003A26                 mov     ecx, [ebp+var_8]
.text$mn:00003A29                 push    ecx
.text$mn:00003A2A                 call    ??$_Sort@PAUColumnModeInfo@@HUSortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInPositionOrder@@@Z ; std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)
.text$mn:00003A2F                 add     esp, 10h
.text$mn:00003A32                 mov     edx, [ebp+var_C]
.text$mn:00003A35                 mov     [ebp+arg_4], edx
.text$mn:00003A38
.text$mn:00003A38 loc_3A38:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+9Fj
.text$mn:00003A38                 jmp     loc_397F
.text$mn:00003A3D ; ---------------------------------------------------------------------------
.text$mn:00003A3D
.text$mn:00003A3D loc_3A3D:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+1Cj
.text$mn:00003A3D                                         ; std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+26j
.text$mn:00003A3D                 cmp     [ebp+var_4], 20h ; ' '
.text$mn:00003A41                 jle     short loc_3A6F
.text$mn:00003A43                 movzx   eax, [ebp+arg_C]
.text$mn:00003A47                 push    eax
.text$mn:00003A48                 mov     ecx, [ebp+arg_4]
.text$mn:00003A4B                 push    ecx
.text$mn:00003A4C                 mov     edx, [ebp+arg_0]
.text$mn:00003A4F                 push    edx
.text$mn:00003A50                 call    ??$make_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z ; std::make_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00003A55                 add     esp, 0Ch
.text$mn:00003A58                 movzx   eax, [ebp+arg_C]
.text$mn:00003A5C                 push    eax
.text$mn:00003A5D                 mov     ecx, [ebp+arg_4]
.text$mn:00003A60                 push    ecx
.text$mn:00003A61                 mov     edx, [ebp+arg_0]
.text$mn:00003A64                 push    edx
.text$mn:00003A65                 call    ??$sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z ; std::sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00003A6A                 add     esp, 0Ch
.text$mn:00003A6D                 jmp     short loc_3A8A
.text$mn:00003A6F ; ---------------------------------------------------------------------------
.text$mn:00003A6F
.text$mn:00003A6F loc_3A6F:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+C9j
.text$mn:00003A6F                 cmp     [ebp+var_4], 1
.text$mn:00003A73                 jle     short loc_3A8A
.text$mn:00003A75                 movzx   eax, [ebp+arg_C]
.text$mn:00003A79                 push    eax
.text$mn:00003A7A                 mov     ecx, [ebp+arg_4]
.text$mn:00003A7D                 push    ecx
.text$mn:00003A7E                 mov     edx, [ebp+arg_0]
.text$mn:00003A81                 push    edx
.text$mn:00003A82                 call    ??$_Insertion_sort@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z ; std::_Insertion_sort<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00003A87                 add     esp, 0Ch
.text$mn:00003A8A
.text$mn:00003A8A loc_3A8A:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+F5j
.text$mn:00003A8A                                         ; std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+FBj
.text$mn:00003A8A                 pop     esi
.text$mn:00003A8B                 mov     esp, ebp
.text$mn:00003A8D                 pop     ebp
.text$mn:00003A8E                 retn
.text$mn:00003A8E ??$_Sort@PAUColumnModeInfo@@HUSortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInPositionOrder@@@Z endp
.text$mn:00003A8E
.text$mn:00003A8E ; ---------------------------------------------------------------------------
.text$mn:00003A8F                 align 10h
.text$mn:00003A8F _text$mn        ends
.text$mn:00003A8F
.text$mn:00003A90 ; ===========================================================================
.text$mn:00003A90
.text$mn:00003A90 ; Segment type: Pure code
.text$mn:00003A90 ; Segment permissions: Read/Execute
.text$mn:00003A90 _text$mn        segment para public 'CODE' use32
.text$mn:00003A90                 assume cs:_text$mn
.text$mn:00003A90                 ;org 3A90h
.text$mn:00003A90 ; COMDAT (pick any)
.text$mn:00003A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A90
.text$mn:00003A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A90
.text$mn:00003A90 ; Attributes: bp-based frame
.text$mn:00003A90
.text$mn:00003A90 ; void __cdecl std::_Sort<struct ColumnModeInfo *, int, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, int, struct SortInSelectOrder)
.text$mn:00003A90                 public ??$_Sort@PAUColumnModeInfo@@HUSortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInSelectOrder@@@Z
.text$mn:00003A90 ??$_Sort@PAUColumnModeInfo@@HUSortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInSelectOrder@@@Z proc near
.text$mn:00003A90                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+91p
.text$mn:00003A90                                         ; std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+B2p ...
.text$mn:00003A90
.text$mn:00003A90 var_C           = dword ptr -0Ch
.text$mn:00003A90 var_8           = dword ptr -8
.text$mn:00003A90 var_4           = dword ptr -4
.text$mn:00003A90 arg_0           = dword ptr  8
.text$mn:00003A90 arg_4           = dword ptr  0Ch
.text$mn:00003A90 arg_8           = dword ptr  10h
.text$mn:00003A90 arg_C           = byte ptr  14h
.text$mn:00003A90
.text$mn:00003A90                 push    ebp
.text$mn:00003A91                 mov     ebp, esp
.text$mn:00003A93                 sub     esp, 0Ch
.text$mn:00003A96                 push    esi
.text$mn:00003A97
.text$mn:00003A97 loc_3A97:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder):loc_3B50j
.text$mn:00003A97                 mov     eax, [ebp+arg_4]
.text$mn:00003A9A                 sub     eax, [ebp+arg_0]
.text$mn:00003A9D                 cdq
.text$mn:00003A9E                 mov     ecx, 18h
.text$mn:00003AA3                 idiv    ecx
.text$mn:00003AA5                 mov     [ebp+var_4], eax
.text$mn:00003AA8                 cmp     [ebp+var_4], 20h ; ' '
.text$mn:00003AAC                 jle     loc_3B55
.text$mn:00003AB2                 cmp     [ebp+arg_8], 0
.text$mn:00003AB6                 jle     loc_3B55
.text$mn:00003ABC                 movzx   edx, [ebp+arg_C]
.text$mn:00003AC0                 push    edx
.text$mn:00003AC1                 mov     eax, [ebp+arg_4]
.text$mn:00003AC4                 push    eax
.text$mn:00003AC5                 mov     ecx, [ebp+arg_0]
.text$mn:00003AC8                 push    ecx
.text$mn:00003AC9                 lea     edx, [ebp+var_C]
.text$mn:00003ACC                 push    edx
.text$mn:00003ACD                 call    ??$_Unguarded_partition@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInSelectOrder@@@Z ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00003AD2                 add     esp, 10h
.text$mn:00003AD5                 mov     eax, [ebp+arg_8]
.text$mn:00003AD8                 cdq
.text$mn:00003AD9                 sub     eax, edx
.text$mn:00003ADB                 sar     eax, 1
.text$mn:00003ADD                 mov     [ebp+arg_8], eax
.text$mn:00003AE0                 mov     eax, [ebp+arg_8]
.text$mn:00003AE3                 cdq
.text$mn:00003AE4                 sub     eax, edx
.text$mn:00003AE6                 sar     eax, 1
.text$mn:00003AE8                 add     eax, [ebp+arg_8]
.text$mn:00003AEB                 mov     [ebp+arg_8], eax
.text$mn:00003AEE                 mov     eax, [ebp+var_C]
.text$mn:00003AF1                 sub     eax, [ebp+arg_0]
.text$mn:00003AF4                 cdq
.text$mn:00003AF5                 mov     ecx, 18h
.text$mn:00003AFA                 idiv    ecx
.text$mn:00003AFC                 mov     ecx, eax
.text$mn:00003AFE                 mov     eax, [ebp+arg_4]
.text$mn:00003B01                 sub     eax, [ebp+var_8]
.text$mn:00003B04                 cdq
.text$mn:00003B05                 mov     esi, 18h
.text$mn:00003B0A                 idiv    esi
.text$mn:00003B0C                 cmp     ecx, eax
.text$mn:00003B0E                 jge     short loc_3B31
.text$mn:00003B10                 movzx   edx, [ebp+arg_C]
.text$mn:00003B14                 push    edx
.text$mn:00003B15                 mov     eax, [ebp+arg_8]
.text$mn:00003B18                 push    eax
.text$mn:00003B19                 mov     ecx, [ebp+var_C]
.text$mn:00003B1C                 push    ecx
.text$mn:00003B1D                 mov     edx, [ebp+arg_0]
.text$mn:00003B20                 push    edx
.text$mn:00003B21                 call    ??$_Sort@PAUColumnModeInfo@@HUSortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInSelectOrder@@@Z ; std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)
.text$mn:00003B26                 add     esp, 10h
.text$mn:00003B29                 mov     eax, [ebp+var_8]
.text$mn:00003B2C                 mov     [ebp+arg_0], eax
.text$mn:00003B2F                 jmp     short loc_3B50
.text$mn:00003B31 ; ---------------------------------------------------------------------------
.text$mn:00003B31
.text$mn:00003B31 loc_3B31:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+7Ej
.text$mn:00003B31                 movzx   ecx, [ebp+arg_C]
.text$mn:00003B35                 push    ecx
.text$mn:00003B36                 mov     edx, [ebp+arg_8]
.text$mn:00003B39                 push    edx
.text$mn:00003B3A                 mov     eax, [ebp+arg_4]
.text$mn:00003B3D                 push    eax
.text$mn:00003B3E                 mov     ecx, [ebp+var_8]
.text$mn:00003B41                 push    ecx
.text$mn:00003B42                 call    ??$_Sort@PAUColumnModeInfo@@HUSortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInSelectOrder@@@Z ; std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)
.text$mn:00003B47                 add     esp, 10h
.text$mn:00003B4A                 mov     edx, [ebp+var_C]
.text$mn:00003B4D                 mov     [ebp+arg_4], edx
.text$mn:00003B50
.text$mn:00003B50 loc_3B50:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+9Fj
.text$mn:00003B50                 jmp     loc_3A97
.text$mn:00003B55 ; ---------------------------------------------------------------------------
.text$mn:00003B55
.text$mn:00003B55 loc_3B55:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+1Cj
.text$mn:00003B55                                         ; std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+26j
.text$mn:00003B55                 cmp     [ebp+var_4], 20h ; ' '
.text$mn:00003B59                 jle     short loc_3B87
.text$mn:00003B5B                 movzx   eax, [ebp+arg_C]
.text$mn:00003B5F                 push    eax
.text$mn:00003B60                 mov     ecx, [ebp+arg_4]
.text$mn:00003B63                 push    ecx
.text$mn:00003B64                 mov     edx, [ebp+arg_0]
.text$mn:00003B67                 push    edx
.text$mn:00003B68                 call    ??$make_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z ; std::make_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00003B6D                 add     esp, 0Ch
.text$mn:00003B70                 movzx   eax, [ebp+arg_C]
.text$mn:00003B74                 push    eax
.text$mn:00003B75                 mov     ecx, [ebp+arg_4]
.text$mn:00003B78                 push    ecx
.text$mn:00003B79                 mov     edx, [ebp+arg_0]
.text$mn:00003B7C                 push    edx
.text$mn:00003B7D                 call    ??$sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z ; std::sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00003B82                 add     esp, 0Ch
.text$mn:00003B85                 jmp     short loc_3BA2
.text$mn:00003B87 ; ---------------------------------------------------------------------------
.text$mn:00003B87
.text$mn:00003B87 loc_3B87:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+C9j
.text$mn:00003B87                 cmp     [ebp+var_4], 1
.text$mn:00003B8B                 jle     short loc_3BA2
.text$mn:00003B8D                 movzx   eax, [ebp+arg_C]
.text$mn:00003B91                 push    eax
.text$mn:00003B92                 mov     ecx, [ebp+arg_4]
.text$mn:00003B95                 push    ecx
.text$mn:00003B96                 mov     edx, [ebp+arg_0]
.text$mn:00003B99                 push    edx
.text$mn:00003B9A                 call    ??$_Insertion_sort@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z ; std::_Insertion_sort<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00003B9F                 add     esp, 0Ch
.text$mn:00003BA2
.text$mn:00003BA2 loc_3BA2:                               ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+F5j
.text$mn:00003BA2                                         ; std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+FBj
.text$mn:00003BA2                 pop     esi
.text$mn:00003BA3                 mov     esp, ebp
.text$mn:00003BA5                 pop     ebp
.text$mn:00003BA6                 retn
.text$mn:00003BA6 ??$_Sort@PAUColumnModeInfo@@HUSortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInSelectOrder@@@Z endp
.text$mn:00003BA6
.text$mn:00003BA6 ; ---------------------------------------------------------------------------
.text$mn:00003BA7                 align 4
.text$mn:00003BA7 _text$mn        ends
.text$mn:00003BA7
.text$mn:00003BA8 ; ===========================================================================
.text$mn:00003BA8
.text$mn:00003BA8 ; Segment type: Pure code
.text$mn:00003BA8 ; Segment permissions: Read/Execute
.text$mn:00003BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003BA8                 assume cs:_text$mn
.text$mn:00003BA8                 ;org 3BA8h
.text$mn:00003BA8 ; COMDAT (pick any)
.text$mn:00003BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BA8
.text$mn:00003BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BA8
.text$mn:00003BA8 ; Attributes: bp-based frame
.text$mn:00003BA8
.text$mn:00003BA8 ; void __cdecl std::_Sort_heap<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:00003BA8                 public ??$_Sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z
.text$mn:00003BA8 ??$_Sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z proc near
.text$mn:00003BA8                                         ; CODE XREF: std::sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+79p
.text$mn:00003BA8
.text$mn:00003BA8 arg_0           = dword ptr  8
.text$mn:00003BA8 arg_4           = dword ptr  0Ch
.text$mn:00003BA8 arg_8           = byte ptr  10h
.text$mn:00003BA8
.text$mn:00003BA8                 push    ebp
.text$mn:00003BA9                 mov     ebp, esp
.text$mn:00003BAB                 jmp     short loc_3BB6
.text$mn:00003BAD ; ---------------------------------------------------------------------------
.text$mn:00003BAD
.text$mn:00003BAD loc_3BAD:                               ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+36j
.text$mn:00003BAD                 mov     eax, [ebp+arg_4]
.text$mn:00003BB0                 sub     eax, 18h
.text$mn:00003BB3                 mov     [ebp+arg_4], eax
.text$mn:00003BB6
.text$mn:00003BB6 loc_3BB6:                               ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+3j
.text$mn:00003BB6                 mov     eax, [ebp+arg_4]
.text$mn:00003BB9                 sub     eax, [ebp+arg_0]
.text$mn:00003BBC                 cdq
.text$mn:00003BBD                 mov     ecx, 18h
.text$mn:00003BC2                 idiv    ecx
.text$mn:00003BC4                 cmp     eax, 1
.text$mn:00003BC7                 jle     short loc_3BE0
.text$mn:00003BC9                 movzx   edx, [ebp+arg_8]
.text$mn:00003BCD                 push    edx
.text$mn:00003BCE                 mov     eax, [ebp+arg_4]
.text$mn:00003BD1                 push    eax
.text$mn:00003BD2                 mov     ecx, [ebp+arg_0]
.text$mn:00003BD5                 push    ecx
.text$mn:00003BD6                 call    ??$_Pop_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z ; std::_Pop_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00003BDB                 add     esp, 0Ch
.text$mn:00003BDE                 jmp     short loc_3BAD
.text$mn:00003BE0 ; ---------------------------------------------------------------------------
.text$mn:00003BE0
.text$mn:00003BE0 loc_3BE0:                               ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+1Fj
.text$mn:00003BE0                 pop     ebp
.text$mn:00003BE1                 retn
.text$mn:00003BE1 ??$_Sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z endp
.text$mn:00003BE1
.text$mn:00003BE1 ; ---------------------------------------------------------------------------
.text$mn:00003BE2                 align 4
.text$mn:00003BE2 _text$mn        ends
.text$mn:00003BE2
.text$mn:00003BE4 ; ===========================================================================
.text$mn:00003BE4
.text$mn:00003BE4 ; Segment type: Pure code
.text$mn:00003BE4 ; Segment permissions: Read/Execute
.text$mn:00003BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00003BE4                 assume cs:_text$mn
.text$mn:00003BE4                 ;org 3BE4h
.text$mn:00003BE4 ; COMDAT (pick any)
.text$mn:00003BE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BE4
.text$mn:00003BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BE4
.text$mn:00003BE4 ; Attributes: bp-based frame
.text$mn:00003BE4
.text$mn:00003BE4 ; void __cdecl std::_Sort_heap<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:00003BE4                 public ??$_Sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z
.text$mn:00003BE4 ??$_Sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z proc near
.text$mn:00003BE4                                         ; CODE XREF: std::sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+79p
.text$mn:00003BE4
.text$mn:00003BE4 arg_0           = dword ptr  8
.text$mn:00003BE4 arg_4           = dword ptr  0Ch
.text$mn:00003BE4 arg_8           = byte ptr  10h
.text$mn:00003BE4
.text$mn:00003BE4                 push    ebp
.text$mn:00003BE5                 mov     ebp, esp
.text$mn:00003BE7                 jmp     short loc_3BF2
.text$mn:00003BE9 ; ---------------------------------------------------------------------------
.text$mn:00003BE9
.text$mn:00003BE9 loc_3BE9:                               ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+36j
.text$mn:00003BE9                 mov     eax, [ebp+arg_4]
.text$mn:00003BEC                 sub     eax, 18h
.text$mn:00003BEF                 mov     [ebp+arg_4], eax
.text$mn:00003BF2
.text$mn:00003BF2 loc_3BF2:                               ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+3j
.text$mn:00003BF2                 mov     eax, [ebp+arg_4]
.text$mn:00003BF5                 sub     eax, [ebp+arg_0]
.text$mn:00003BF8                 cdq
.text$mn:00003BF9                 mov     ecx, 18h
.text$mn:00003BFE                 idiv    ecx
.text$mn:00003C00                 cmp     eax, 1
.text$mn:00003C03                 jle     short loc_3C1C
.text$mn:00003C05                 movzx   edx, [ebp+arg_8]
.text$mn:00003C09                 push    edx
.text$mn:00003C0A                 mov     eax, [ebp+arg_4]
.text$mn:00003C0D                 push    eax
.text$mn:00003C0E                 mov     ecx, [ebp+arg_0]
.text$mn:00003C11                 push    ecx
.text$mn:00003C12                 call    ??$_Pop_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z ; std::_Pop_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00003C17                 add     esp, 0Ch
.text$mn:00003C1A                 jmp     short loc_3BE9
.text$mn:00003C1C ; ---------------------------------------------------------------------------
.text$mn:00003C1C
.text$mn:00003C1C loc_3C1C:                               ; CODE XREF: std::_Sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+1Fj
.text$mn:00003C1C                 pop     ebp
.text$mn:00003C1D                 retn
.text$mn:00003C1D ??$_Sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z endp
.text$mn:00003C1D
.text$mn:00003C1D ; ---------------------------------------------------------------------------
.text$mn:00003C1E                 align 10h
.text$mn:00003C1E _text$mn        ends
.text$mn:00003C1E
.text$mn:00003C20 ; ===========================================================================
.text$mn:00003C20
.text$mn:00003C20 ; Segment type: Pure code
.text$mn:00003C20 ; Segment permissions: Read/Execute
.text$mn:00003C20 _text$mn        segment para public 'CODE' use32
.text$mn:00003C20                 assume cs:_text$mn
.text$mn:00003C20                 ;org 3C20h
.text$mn:00003C20 ; COMDAT (pick any)
.text$mn:00003C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C20
.text$mn:00003C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C20
.text$mn:00003C20 ; Attributes: bp-based frame
.text$mn:00003C20
.text$mn:00003C20 ; protected: int * __thiscall std::vector<int, class std::allocator<int>>::_Umove<int *>(int *, int *, int *)
.text$mn:00003C20                 public ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
.text$mn:00003C20 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z proc near
.text$mn:00003C20                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+65p
.text$mn:00003C20
.text$mn:00003C20 var_8           = dword ptr -8
.text$mn:00003C20 var_1           = byte ptr -1
.text$mn:00003C20 arg_0           = dword ptr  8
.text$mn:00003C20 arg_4           = dword ptr  0Ch
.text$mn:00003C20 arg_8           = dword ptr  10h
.text$mn:00003C20
.text$mn:00003C20                 push    ebp
.text$mn:00003C21                 mov     ebp, esp
.text$mn:00003C23                 sub     esp, 8
.text$mn:00003C26                 mov     [ebp+var_8], ecx
.text$mn:00003C29                 lea     eax, [ebp+var_1]
.text$mn:00003C2C                 push    eax
.text$mn:00003C2D                 mov     ecx, [ebp+var_8]
.text$mn:00003C30                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00003C35                 lea     ecx, [ebp+var_1]
.text$mn:00003C38                 push    ecx
.text$mn:00003C39                 mov     edx, [ebp+arg_8]
.text$mn:00003C3C                 push    edx
.text$mn:00003C3D                 mov     eax, [ebp+arg_4]
.text$mn:00003C40                 push    eax
.text$mn:00003C41                 mov     ecx, [ebp+arg_0]
.text$mn:00003C44                 push    ecx
.text$mn:00003C45                 call    ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:00003C4A                 add     esp, 10h
.text$mn:00003C4D                 mov     esp, ebp
.text$mn:00003C4F                 pop     ebp
.text$mn:00003C50                 retn    0Ch
.text$mn:00003C50 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z endp
.text$mn:00003C50
.text$mn:00003C50 ; ---------------------------------------------------------------------------
.text$mn:00003C53                 align 4
.text$mn:00003C53 _text$mn        ends
.text$mn:00003C53
.text$mn:00003C54 ; ===========================================================================
.text$mn:00003C54
.text$mn:00003C54 ; Segment type: Pure code
.text$mn:00003C54 ; Segment permissions: Read/Execute
.text$mn:00003C54 _text$mn        segment para public 'CODE' use32
.text$mn:00003C54                 assume cs:_text$mn
.text$mn:00003C54                 ;org 3C54h
.text$mn:00003C54 ; COMDAT (pick any)
.text$mn:00003C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C54
.text$mn:00003C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C54
.text$mn:00003C54 ; Attributes: bp-based frame
.text$mn:00003C54
.text$mn:00003C54 ; int * __cdecl std::_Unchecked<int *>(int *)
.text$mn:00003C54                 public ??$_Unchecked@PAH@std@@YAPAHPAH@Z
.text$mn:00003C54 ??$_Unchecked@PAH@std@@YAPAHPAH@Z proc near
.text$mn:00003C54                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Bp
.text$mn:00003C54                                         ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+18p ...
.text$mn:00003C54
.text$mn:00003C54 arg_0           = dword ptr  8
.text$mn:00003C54
.text$mn:00003C54                 push    ebp
.text$mn:00003C55                 mov     ebp, esp
.text$mn:00003C57                 mov     eax, [ebp+arg_0]
.text$mn:00003C5A                 pop     ebp
.text$mn:00003C5B                 retn
.text$mn:00003C5B ??$_Unchecked@PAH@std@@YAPAHPAH@Z endp
.text$mn:00003C5B
.text$mn:00003C5B _text$mn        ends
.text$mn:00003C5B
.text$mn:00003C5C ; ===========================================================================
.text$mn:00003C5C
.text$mn:00003C5C ; Segment type: Pure code
.text$mn:00003C5C ; Segment permissions: Read/Execute
.text$mn:00003C5C _text$mn        segment para public 'CODE' use32
.text$mn:00003C5C                 assume cs:_text$mn
.text$mn:00003C5C                 ;org 3C5Ch
.text$mn:00003C5C ; COMDAT (pick any)
.text$mn:00003C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C5C
.text$mn:00003C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C5C
.text$mn:00003C5C ; Attributes: bp-based frame
.text$mn:00003C5C
.text$mn:00003C5C ; struct ColumnModeInfo * __cdecl std::_Unchecked<struct ColumnModeInfo *>(struct ColumnModeInfo *)
.text$mn:00003C5C                 public ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z
.text$mn:00003C5C ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z proc near
.text$mn:00003C5C                                         ; CODE XREF: std::_Pop_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+19p
.text$mn:00003C5C                                         ; std::_Pop_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+26p ...
.text$mn:00003C5C
.text$mn:00003C5C arg_0           = dword ptr  8
.text$mn:00003C5C
.text$mn:00003C5C                 push    ebp
.text$mn:00003C5D                 mov     ebp, esp
.text$mn:00003C5F                 mov     eax, [ebp+arg_0]
.text$mn:00003C62                 pop     ebp
.text$mn:00003C63                 retn
.text$mn:00003C63 ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z endp
.text$mn:00003C63
.text$mn:00003C63 _text$mn        ends
.text$mn:00003C63
.text$mn:00003C64 ; ===========================================================================
.text$mn:00003C64
.text$mn:00003C64 ; Segment type: Pure code
.text$mn:00003C64 ; Segment permissions: Read/Execute
.text$mn:00003C64 _text$mn        segment para public 'CODE' use32
.text$mn:00003C64                 assume cs:_text$mn
.text$mn:00003C64                 ;org 3C64h
.text$mn:00003C64 ; COMDAT (pick any)
.text$mn:00003C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C64
.text$mn:00003C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C64
.text$mn:00003C64 ; Attributes: bp-based frame
.text$mn:00003C64
.text$mn:00003C64 ; struct ColumnModeInfo * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>)
.text$mn:00003C64                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z
.text$mn:00003C64 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z proc near
.text$mn:00003C64                                         ; CODE XREF: std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)+C8p
.text$mn:00003C64                                         ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)+F9p ...
.text$mn:00003C64
.text$mn:00003C64 var_10          = dword ptr -10h
.text$mn:00003C64 var_C           = dword ptr -0Ch
.text$mn:00003C64 var_4           = dword ptr -4
.text$mn:00003C64 arg_0           = byte ptr  8
.text$mn:00003C64
.text$mn:00003C64                 push    ebp
.text$mn:00003C65                 mov     ebp, esp
.text$mn:00003C67                 push    0FFFFFFFFh
.text$mn:00003C69                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z
.text$mn:00003C6E                 mov     eax, large fs:0
.text$mn:00003C74                 push    eax
.text$mn:00003C75                 push    ecx
.text$mn:00003C76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C7B                 xor     eax, ebp
.text$mn:00003C7D                 push    eax
.text$mn:00003C7E                 lea     eax, [ebp+var_C]
.text$mn:00003C81                 mov     large fs:0, eax
.text$mn:00003C87                 mov     [ebp+var_4], 0
.text$mn:00003C8E                 lea     ecx, [ebp+arg_0]
.text$mn:00003C91                 call    ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEPAUColumnModeInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Unchecked(void)
.text$mn:00003C96                 mov     [ebp+var_10], eax
.text$mn:00003C99                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003CA0                 lea     ecx, [ebp+arg_0]
.text$mn:00003CA3                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00003CA8                 mov     eax, [ebp+var_10]
.text$mn:00003CAB                 mov     ecx, [ebp+var_C]
.text$mn:00003CAE                 mov     large fs:0, ecx
.text$mn:00003CB5                 pop     ecx
.text$mn:00003CB6                 mov     esp, ebp
.text$mn:00003CB8                 pop     ebp
.text$mn:00003CB9                 retn
.text$mn:00003CB9 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z endp
.text$mn:00003CB9
.text$mn:00003CB9 ; ---------------------------------------------------------------------------
.text$mn:00003CBA                 align 4
.text$mn:00003CBA _text$mn        ends
.text$mn:00003CBA
.text$x:00003CBC ; ===========================================================================
.text$x:00003CBC
.text$x:00003CBC ; Segment type: Pure code
.text$x:00003CBC ; Segment permissions: Read/Execute
.text$x:00003CBC _text$x         segment para public 'CODE' use32
.text$x:00003CBC                 assume cs:_text$x
.text$x:00003CBC                 ;org 3CBCh
.text$x:00003CBC ; COMDAT (pick associative to section at 3C64)
.text$x:00003CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003CBC
.text$x:00003CBC ; =============== S U B R O U T I N E =======================================
.text$x:00003CBC
.text$x:00003CBC
.text$x:00003CBC __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z$0 proc near
.text$x:00003CBC                                         ; DATA XREF: .xdata$x:0000AD5Co
.text$x:00003CBC                 lea     ecx, [ebp+8]
.text$x:00003CBF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00003CBF __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z$0 endp
.text$x:00003CBF
.text$x:00003CC4
.text$x:00003CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00003CC4
.text$x:00003CC4
.text$x:00003CC4 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z proc near
.text$x:00003CC4                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>)+5o
.text$x:00003CC4
.text$x:00003CC4 arg_4           = dword ptr  8
.text$x:00003CC4
.text$x:00003CC4                 mov     edx, [esp+arg_4]
.text$x:00003CC8                 lea     eax, [edx+0Ch]
.text$x:00003CCB                 mov     ecx, [edx-8]
.text$x:00003CCE                 xor     ecx, eax
.text$x:00003CD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003CD5                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z
.text$x:00003CDA                 jmp     ___CxxFrameHandler3
.text$x:00003CDA __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z endp
.text$x:00003CDA
.text$x:00003CDA ; ---------------------------------------------------------------------------
.text$x:00003CDF                 align 10h
.text$x:00003CDF _text$x         ends
.text$x:00003CDF
.text$mn:00003CE0 ; ===========================================================================
.text$mn:00003CE0
.text$mn:00003CE0 ; Segment type: Pure code
.text$mn:00003CE0 ; Segment permissions: Read/Execute
.text$mn:00003CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CE0                 assume cs:_text$mn
.text$mn:00003CE0                 ;org 3CE0h
.text$mn:00003CE0 ; COMDAT (pick any)
.text$mn:00003CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CE0
.text$mn:00003CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CE0
.text$mn:00003CE0 ; Attributes: bp-based frame
.text$mn:00003CE0
.text$mn:00003CE0 ; struct std::pair<struct ColumnModeInfo *, struct ColumnModeInfo *> __cdecl std::_Unguarded_partition<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:00003CE0                 public ??$_Unguarded_partition@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInPositionOrder@@@Z
.text$mn:00003CE0 ??$_Unguarded_partition@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInPositionOrder@@@Z proc near
.text$mn:00003CE0                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+3Dp
.text$mn:00003CE0
.text$mn:00003CE0 var_28          = dword ptr -28h
.text$mn:00003CE0 var_24          = dword ptr -24h
.text$mn:00003CE0 var_20          = dword ptr -20h
.text$mn:00003CE0 var_1C          = dword ptr -1Ch
.text$mn:00003CE0 var_18          = dword ptr -18h
.text$mn:00003CE0 var_14          = dword ptr -14h
.text$mn:00003CE0 var_10          = dword ptr -10h
.text$mn:00003CE0 var_C           = dword ptr -0Ch
.text$mn:00003CE0 var_8           = dword ptr -8
.text$mn:00003CE0 var_4           = dword ptr -4
.text$mn:00003CE0 arg_0           = dword ptr  8
.text$mn:00003CE0 arg_4           = dword ptr  0Ch
.text$mn:00003CE0 arg_8           = dword ptr  10h
.text$mn:00003CE0 arg_C           = byte ptr  14h
.text$mn:00003CE0
.text$mn:00003CE0                 push    ebp
.text$mn:00003CE1                 mov     ebp, esp
.text$mn:00003CE3                 sub     esp, 28h
.text$mn:00003CE6                 mov     eax, [ebp+arg_8]
.text$mn:00003CE9                 sub     eax, [ebp+arg_4]
.text$mn:00003CEC                 cdq
.text$mn:00003CED                 mov     ecx, 18h
.text$mn:00003CF2                 idiv    ecx
.text$mn:00003CF4                 cdq
.text$mn:00003CF5                 sub     eax, edx
.text$mn:00003CF7                 sar     eax, 1
.text$mn:00003CF9                 imul    edx, eax, 18h
.text$mn:00003CFC                 add     edx, [ebp+arg_4]
.text$mn:00003CFF                 mov     [ebp+var_14], edx
.text$mn:00003D02                 movzx   eax, [ebp+arg_C]
.text$mn:00003D06                 push    eax
.text$mn:00003D07                 mov     ecx, [ebp+arg_8]
.text$mn:00003D0A                 sub     ecx, 18h
.text$mn:00003D0D                 push    ecx
.text$mn:00003D0E                 mov     edx, [ebp+var_14]
.text$mn:00003D11                 push    edx
.text$mn:00003D12                 mov     eax, [ebp+arg_4]
.text$mn:00003D15                 push    eax
.text$mn:00003D16                 call    ??$_Median@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@00USortInPositionOrder@@@Z ; std::_Median<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00003D1B                 add     esp, 10h
.text$mn:00003D1E                 mov     ecx, [ebp+var_14]
.text$mn:00003D21                 mov     [ebp+var_4], ecx
.text$mn:00003D24                 mov     edx, [ebp+var_4]
.text$mn:00003D27                 add     edx, 18h
.text$mn:00003D2A                 mov     [ebp+var_8], edx
.text$mn:00003D2D
.text$mn:00003D2D loc_3D2D:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+A1j
.text$mn:00003D2D                 mov     eax, [ebp+arg_4]
.text$mn:00003D30                 cmp     eax, [ebp+var_4]
.text$mn:00003D33                 jnb     short loc_3D83
.text$mn:00003D35                 push    0BFEh           ; unsigned int
.text$mn:00003D3A                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D3F                 mov     ecx, [ebp+var_4]
.text$mn:00003D42                 push    ecx             ; int
.text$mn:00003D43                 mov     edx, [ebp+var_4]
.text$mn:00003D46                 sub     edx, 18h
.text$mn:00003D49                 push    edx             ; int
.text$mn:00003D4A                 movzx   eax, [ebp+arg_C]
.text$mn:00003D4E                 push    eax             ; char
.text$mn:00003D4F                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00003D54                 add     esp, 14h
.text$mn:00003D57                 movzx   ecx, al
.text$mn:00003D5A                 test    ecx, ecx
.text$mn:00003D5C                 jnz     short loc_3D83
.text$mn:00003D5E                 mov     edx, [ebp+var_4]
.text$mn:00003D61                 sub     edx, 18h
.text$mn:00003D64                 push    edx
.text$mn:00003D65                 mov     eax, [ebp+var_4]
.text$mn:00003D68                 push    eax
.text$mn:00003D69                 lea     ecx, [ebp+arg_C]
.text$mn:00003D6C                 call    ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:00003D71                 movzx   ecx, al
.text$mn:00003D74                 test    ecx, ecx
.text$mn:00003D76                 jnz     short loc_3D83
.text$mn:00003D78                 mov     edx, [ebp+var_4]
.text$mn:00003D7B                 sub     edx, 18h
.text$mn:00003D7E                 mov     [ebp+var_4], edx
.text$mn:00003D81                 jmp     short loc_3D2D
.text$mn:00003D83 ; ---------------------------------------------------------------------------
.text$mn:00003D83
.text$mn:00003D83 loc_3D83:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+53j
.text$mn:00003D83                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+7Cj ...
.text$mn:00003D83                 mov     eax, [ebp+var_8]
.text$mn:00003D86                 cmp     eax, [ebp+arg_8]
.text$mn:00003D89                 jnb     short loc_3DD3
.text$mn:00003D8B                 push    0C02h           ; unsigned int
.text$mn:00003D90                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D95                 mov     ecx, [ebp+var_4]
.text$mn:00003D98                 push    ecx             ; int
.text$mn:00003D99                 mov     edx, [ebp+var_8]
.text$mn:00003D9C                 push    edx             ; int
.text$mn:00003D9D                 movzx   eax, [ebp+arg_C]
.text$mn:00003DA1                 push    eax             ; char
.text$mn:00003DA2                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00003DA7                 add     esp, 14h
.text$mn:00003DAA                 movzx   ecx, al
.text$mn:00003DAD                 test    ecx, ecx
.text$mn:00003DAF                 jnz     short loc_3DD3
.text$mn:00003DB1                 mov     edx, [ebp+var_8]
.text$mn:00003DB4                 push    edx
.text$mn:00003DB5                 mov     eax, [ebp+var_4]
.text$mn:00003DB8                 push    eax
.text$mn:00003DB9                 lea     ecx, [ebp+arg_C]
.text$mn:00003DBC                 call    ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:00003DC1                 movzx   ecx, al
.text$mn:00003DC4                 test    ecx, ecx
.text$mn:00003DC6                 jnz     short loc_3DD3
.text$mn:00003DC8                 mov     edx, [ebp+var_8]
.text$mn:00003DCB                 add     edx, 18h
.text$mn:00003DCE                 mov     [ebp+var_8], edx
.text$mn:00003DD1                 jmp     short loc_3D83
.text$mn:00003DD3 ; ---------------------------------------------------------------------------
.text$mn:00003DD3
.text$mn:00003DD3 loc_3DD3:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+A9j
.text$mn:00003DD3                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+CFj ...
.text$mn:00003DD3                 mov     eax, [ebp+var_8]
.text$mn:00003DD6                 mov     [ebp+var_10], eax
.text$mn:00003DD9                 mov     ecx, [ebp+var_4]
.text$mn:00003DDC                 mov     [ebp+var_C], ecx
.text$mn:00003DDF
.text$mn:00003DDF loc_3DDF:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder):loc_3FE8j
.text$mn:00003DDF                 jmp     short loc_3DEA
.text$mn:00003DE1 ; ---------------------------------------------------------------------------
.text$mn:00003DE1
.text$mn:00003DE1 loc_3DE1:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder):loc_3E65j
.text$mn:00003DE1                 mov     edx, [ebp+var_10]
.text$mn:00003DE4                 add     edx, 18h
.text$mn:00003DE7                 mov     [ebp+var_10], edx
.text$mn:00003DEA
.text$mn:00003DEA loc_3DEA:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder):loc_3DDFj
.text$mn:00003DEA                 mov     eax, [ebp+var_10]
.text$mn:00003DED                 cmp     eax, [ebp+arg_8]
.text$mn:00003DF0                 jnb     short loc_3E6A
.text$mn:00003DF2                 push    0C0Ch           ; unsigned int
.text$mn:00003DF7                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003DFC                 mov     ecx, [ebp+var_10]
.text$mn:00003DFF                 push    ecx             ; int
.text$mn:00003E00                 mov     edx, [ebp+var_4]
.text$mn:00003E03                 push    edx             ; int
.text$mn:00003E04                 movzx   eax, [ebp+arg_C]
.text$mn:00003E08                 push    eax             ; char
.text$mn:00003E09                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00003E0E                 add     esp, 14h
.text$mn:00003E11                 movzx   ecx, al
.text$mn:00003E14                 test    ecx, ecx
.text$mn:00003E16                 jz      short loc_3E1A
.text$mn:00003E18                 jmp     short loc_3E65
.text$mn:00003E1A ; ---------------------------------------------------------------------------
.text$mn:00003E1A
.text$mn:00003E1A loc_3E1A:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+136j
.text$mn:00003E1A                 mov     edx, [ebp+var_4]
.text$mn:00003E1D                 push    edx
.text$mn:00003E1E                 mov     eax, [ebp+var_10]
.text$mn:00003E21                 push    eax
.text$mn:00003E22                 lea     ecx, [ebp+arg_C]
.text$mn:00003E25                 call    ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:00003E2A                 movzx   ecx, al
.text$mn:00003E2D                 test    ecx, ecx
.text$mn:00003E2F                 jz      short loc_3E35
.text$mn:00003E31                 jmp     short loc_3E6A
.text$mn:00003E33 ; ---------------------------------------------------------------------------
.text$mn:00003E33                 jmp     short loc_3E65
.text$mn:00003E35 ; ---------------------------------------------------------------------------
.text$mn:00003E35
.text$mn:00003E35 loc_3E35:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+14Fj
.text$mn:00003E35                 mov     edx, [ebp+var_8]
.text$mn:00003E38                 mov     [ebp+var_18], edx
.text$mn:00003E3B                 mov     eax, [ebp+var_10]
.text$mn:00003E3E                 mov     [ebp+var_1C], eax
.text$mn:00003E41                 mov     ecx, [ebp+var_8]
.text$mn:00003E44                 add     ecx, 18h
.text$mn:00003E47                 mov     [ebp+var_8], ecx
.text$mn:00003E4A                 mov     edx, [ebp+var_18]
.text$mn:00003E4D                 cmp     edx, [ebp+var_1C]
.text$mn:00003E50                 jz      short loc_3E65
.text$mn:00003E52                 mov     eax, [ebp+var_10]
.text$mn:00003E55                 push    eax
.text$mn:00003E56                 mov     ecx, [ebp+var_8]
.text$mn:00003E59                 sub     ecx, 18h
.text$mn:00003E5C                 push    ecx
.text$mn:00003E5D                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003E62                 add     esp, 8
.text$mn:00003E65
.text$mn:00003E65 loc_3E65:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+138j
.text$mn:00003E65                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+153j ...
.text$mn:00003E65                 jmp     loc_3DE1
.text$mn:00003E6A ; ---------------------------------------------------------------------------
.text$mn:00003E6A
.text$mn:00003E6A loc_3E6A:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+110j
.text$mn:00003E6A                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+151j
.text$mn:00003E6A                 jmp     short loc_3E75
.text$mn:00003E6C ; ---------------------------------------------------------------------------
.text$mn:00003E6C
.text$mn:00003E6C loc_3E6C:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder):loc_3EEDj
.text$mn:00003E6C                 mov     edx, [ebp+var_C]
.text$mn:00003E6F                 sub     edx, 18h
.text$mn:00003E72                 mov     [ebp+var_C], edx
.text$mn:00003E75
.text$mn:00003E75 loc_3E75:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder):loc_3E6Aj
.text$mn:00003E75                 mov     eax, [ebp+arg_4]
.text$mn:00003E78                 cmp     eax, [ebp+var_C]
.text$mn:00003E7B                 jnb     short loc_3EF2
.text$mn:00003E7D                 push    0C13h           ; unsigned int
.text$mn:00003E82                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003E87                 mov     ecx, [ebp+var_4]
.text$mn:00003E8A                 push    ecx             ; int
.text$mn:00003E8B                 mov     edx, [ebp+var_C]
.text$mn:00003E8E                 sub     edx, 18h
.text$mn:00003E91                 push    edx             ; int
.text$mn:00003E92                 movzx   eax, [ebp+arg_C]
.text$mn:00003E96                 push    eax             ; char
.text$mn:00003E97                 call    ??$_Debug_lt_pred@USortInPositionOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInPositionOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00003E9C                 add     esp, 14h
.text$mn:00003E9F                 movzx   ecx, al
.text$mn:00003EA2                 test    ecx, ecx
.text$mn:00003EA4                 jz      short loc_3EA8
.text$mn:00003EA6                 jmp     short loc_3EED
.text$mn:00003EA8 ; ---------------------------------------------------------------------------
.text$mn:00003EA8
.text$mn:00003EA8 loc_3EA8:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+1C4j
.text$mn:00003EA8                 mov     edx, [ebp+var_C]
.text$mn:00003EAB                 sub     edx, 18h
.text$mn:00003EAE                 push    edx
.text$mn:00003EAF                 mov     eax, [ebp+var_4]
.text$mn:00003EB2                 push    eax
.text$mn:00003EB3                 lea     ecx, [ebp+arg_C]
.text$mn:00003EB6                 call    ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:00003EBB                 movzx   ecx, al
.text$mn:00003EBE                 test    ecx, ecx
.text$mn:00003EC0                 jz      short loc_3EC6
.text$mn:00003EC2                 jmp     short loc_3EF2
.text$mn:00003EC4 ; ---------------------------------------------------------------------------
.text$mn:00003EC4                 jmp     short loc_3EED
.text$mn:00003EC6 ; ---------------------------------------------------------------------------
.text$mn:00003EC6
.text$mn:00003EC6 loc_3EC6:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+1E0j
.text$mn:00003EC6                 mov     edx, [ebp+var_4]
.text$mn:00003EC9                 sub     edx, 18h
.text$mn:00003ECC                 mov     [ebp+var_4], edx
.text$mn:00003ECF                 mov     eax, [ebp+var_C]
.text$mn:00003ED2                 sub     eax, 18h
.text$mn:00003ED5                 cmp     [ebp+var_4], eax
.text$mn:00003ED8                 jz      short loc_3EED
.text$mn:00003EDA                 mov     ecx, [ebp+var_C]
.text$mn:00003EDD                 sub     ecx, 18h
.text$mn:00003EE0                 push    ecx
.text$mn:00003EE1                 mov     edx, [ebp+var_4]
.text$mn:00003EE4                 push    edx
.text$mn:00003EE5                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003EEA                 add     esp, 8
.text$mn:00003EED
.text$mn:00003EED loc_3EED:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+1C6j
.text$mn:00003EED                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+1E4j ...
.text$mn:00003EED                 jmp     loc_3E6C
.text$mn:00003EF2 ; ---------------------------------------------------------------------------
.text$mn:00003EF2
.text$mn:00003EF2 loc_3EF2:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+19Bj
.text$mn:00003EF2                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+1E2j
.text$mn:00003EF2                 mov     eax, [ebp+var_C]
.text$mn:00003EF5                 cmp     eax, [ebp+arg_4]
.text$mn:00003EF8                 jnz     short loc_3F1A
.text$mn:00003EFA                 mov     ecx, [ebp+var_10]
.text$mn:00003EFD                 cmp     ecx, [ebp+arg_8]
.text$mn:00003F00                 jnz     short loc_3F1A
.text$mn:00003F02                 lea     edx, [ebp+var_8]
.text$mn:00003F05                 push    edx
.text$mn:00003F06                 lea     eax, [ebp+var_4]
.text$mn:00003F09                 push    eax
.text$mn:00003F0A                 mov     ecx, [ebp+arg_0]
.text$mn:00003F0D                 call    ??$?0AAPAUColumnModeInfo@@AAPAU0@X@?$pair@PAUColumnModeInfo@@PAU1@@std@@QAE@AAPAUColumnModeInfo@@0@Z ; std::pair<ColumnModeInfo *,ColumnModeInfo *>::pair<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo * &,ColumnModeInfo * &)
.text$mn:00003F12                 mov     eax, [ebp+arg_0]
.text$mn:00003F15                 jmp     loc_3FED
.text$mn:00003F1A ; ---------------------------------------------------------------------------
.text$mn:00003F1A
.text$mn:00003F1A loc_3F1A:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+218j
.text$mn:00003F1A                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+220j
.text$mn:00003F1A                 mov     ecx, [ebp+var_C]
.text$mn:00003F1D                 cmp     ecx, [ebp+arg_4]
.text$mn:00003F20                 jnz     short loc_3F73
.text$mn:00003F22                 mov     edx, [ebp+var_8]
.text$mn:00003F25                 cmp     edx, [ebp+var_10]
.text$mn:00003F28                 jz      short loc_3F3A
.text$mn:00003F2A                 mov     eax, [ebp+var_8]
.text$mn:00003F2D                 push    eax
.text$mn:00003F2E                 mov     ecx, [ebp+var_4]
.text$mn:00003F31                 push    ecx
.text$mn:00003F32                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003F37                 add     esp, 8
.text$mn:00003F3A
.text$mn:00003F3A loc_3F3A:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+248j
.text$mn:00003F3A                 mov     edx, [ebp+var_8]
.text$mn:00003F3D                 add     edx, 18h
.text$mn:00003F40                 mov     [ebp+var_8], edx
.text$mn:00003F43                 mov     eax, [ebp+var_10]
.text$mn:00003F46                 mov     [ebp+var_20], eax
.text$mn:00003F49                 mov     ecx, [ebp+var_4]
.text$mn:00003F4C                 mov     [ebp+var_24], ecx
.text$mn:00003F4F                 mov     edx, [ebp+var_4]
.text$mn:00003F52                 add     edx, 18h
.text$mn:00003F55                 mov     [ebp+var_4], edx
.text$mn:00003F58                 mov     eax, [ebp+var_10]
.text$mn:00003F5B                 add     eax, 18h
.text$mn:00003F5E                 mov     [ebp+var_10], eax
.text$mn:00003F61                 mov     ecx, [ebp+var_20]
.text$mn:00003F64                 push    ecx
.text$mn:00003F65                 mov     edx, [ebp+var_24]
.text$mn:00003F68                 push    edx
.text$mn:00003F69                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003F6E                 add     esp, 8
.text$mn:00003F71                 jmp     short loc_3FE8
.text$mn:00003F73 ; ---------------------------------------------------------------------------
.text$mn:00003F73
.text$mn:00003F73 loc_3F73:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+240j
.text$mn:00003F73                 mov     eax, [ebp+var_10]
.text$mn:00003F76                 cmp     eax, [ebp+arg_8]
.text$mn:00003F79                 jnz     short loc_3FC0
.text$mn:00003F7B                 mov     ecx, [ebp+var_C]
.text$mn:00003F7E                 sub     ecx, 18h
.text$mn:00003F81                 mov     [ebp+var_C], ecx
.text$mn:00003F84                 mov     edx, [ebp+var_4]
.text$mn:00003F87                 sub     edx, 18h
.text$mn:00003F8A                 mov     [ebp+var_4], edx
.text$mn:00003F8D                 mov     eax, [ebp+var_C]
.text$mn:00003F90                 cmp     eax, [ebp+var_4]
.text$mn:00003F93                 jz      short loc_3FA5
.text$mn:00003F95                 mov     ecx, [ebp+var_4]
.text$mn:00003F98                 push    ecx
.text$mn:00003F99                 mov     edx, [ebp+var_C]
.text$mn:00003F9C                 push    edx
.text$mn:00003F9D                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003FA2                 add     esp, 8
.text$mn:00003FA5
.text$mn:00003FA5 loc_3FA5:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+2B3j
.text$mn:00003FA5                 mov     eax, [ebp+var_8]
.text$mn:00003FA8                 sub     eax, 18h
.text$mn:00003FAB                 mov     [ebp+var_8], eax
.text$mn:00003FAE                 mov     ecx, [ebp+var_8]
.text$mn:00003FB1                 push    ecx
.text$mn:00003FB2                 mov     edx, [ebp+var_4]
.text$mn:00003FB5                 push    edx
.text$mn:00003FB6                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003FBB                 add     esp, 8
.text$mn:00003FBE                 jmp     short loc_3FE8
.text$mn:00003FC0 ; ---------------------------------------------------------------------------
.text$mn:00003FC0
.text$mn:00003FC0 loc_3FC0:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+299j
.text$mn:00003FC0                 mov     eax, [ebp+var_C]
.text$mn:00003FC3                 sub     eax, 18h
.text$mn:00003FC6                 mov     [ebp+var_C], eax
.text$mn:00003FC9                 mov     ecx, [ebp+var_10]
.text$mn:00003FCC                 mov     [ebp+var_28], ecx
.text$mn:00003FCF                 mov     edx, [ebp+var_C]
.text$mn:00003FD2                 push    edx
.text$mn:00003FD3                 mov     eax, [ebp+var_28]
.text$mn:00003FD6                 push    eax
.text$mn:00003FD7                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00003FDC                 add     esp, 8
.text$mn:00003FDF                 mov     ecx, [ebp+var_10]
.text$mn:00003FE2                 add     ecx, 18h
.text$mn:00003FE5                 mov     [ebp+var_10], ecx
.text$mn:00003FE8
.text$mn:00003FE8 loc_3FE8:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+291j
.text$mn:00003FE8                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+2DEj
.text$mn:00003FE8                 jmp     loc_3DDF
.text$mn:00003FED ; ---------------------------------------------------------------------------
.text$mn:00003FED
.text$mn:00003FED loc_3FED:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+235j
.text$mn:00003FED                 mov     esp, ebp
.text$mn:00003FEF                 pop     ebp
.text$mn:00003FF0                 retn
.text$mn:00003FF0 ??$_Unguarded_partition@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInPositionOrder@@@Z endp
.text$mn:00003FF0
.text$mn:00003FF0 ; ---------------------------------------------------------------------------
.text$mn:00003FF1                 align 4
.text$mn:00003FF1 _text$mn        ends
.text$mn:00003FF1
.text$mn:00003FF4 ; ===========================================================================
.text$mn:00003FF4
.text$mn:00003FF4 ; Segment type: Pure code
.text$mn:00003FF4 ; Segment permissions: Read/Execute
.text$mn:00003FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FF4                 assume cs:_text$mn
.text$mn:00003FF4                 ;org 3FF4h
.text$mn:00003FF4 ; COMDAT (pick any)
.text$mn:00003FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FF4
.text$mn:00003FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FF4
.text$mn:00003FF4 ; Attributes: bp-based frame
.text$mn:00003FF4
.text$mn:00003FF4 ; struct std::pair<struct ColumnModeInfo *, struct ColumnModeInfo *> __cdecl std::_Unguarded_partition<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:00003FF4                 public ??$_Unguarded_partition@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInSelectOrder@@@Z
.text$mn:00003FF4 ??$_Unguarded_partition@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInSelectOrder@@@Z proc near
.text$mn:00003FF4                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+3Dp
.text$mn:00003FF4
.text$mn:00003FF4 var_28          = dword ptr -28h
.text$mn:00003FF4 var_24          = dword ptr -24h
.text$mn:00003FF4 var_20          = dword ptr -20h
.text$mn:00003FF4 var_1C          = dword ptr -1Ch
.text$mn:00003FF4 var_18          = dword ptr -18h
.text$mn:00003FF4 var_14          = dword ptr -14h
.text$mn:00003FF4 var_10          = dword ptr -10h
.text$mn:00003FF4 var_C           = dword ptr -0Ch
.text$mn:00003FF4 var_8           = dword ptr -8
.text$mn:00003FF4 var_4           = dword ptr -4
.text$mn:00003FF4 arg_0           = dword ptr  8
.text$mn:00003FF4 arg_4           = dword ptr  0Ch
.text$mn:00003FF4 arg_8           = dword ptr  10h
.text$mn:00003FF4 arg_C           = byte ptr  14h
.text$mn:00003FF4
.text$mn:00003FF4                 push    ebp
.text$mn:00003FF5                 mov     ebp, esp
.text$mn:00003FF7                 sub     esp, 28h
.text$mn:00003FFA                 mov     eax, [ebp+arg_8]
.text$mn:00003FFD                 sub     eax, [ebp+arg_4]
.text$mn:00004000                 cdq
.text$mn:00004001                 mov     ecx, 18h
.text$mn:00004006                 idiv    ecx
.text$mn:00004008                 cdq
.text$mn:00004009                 sub     eax, edx
.text$mn:0000400B                 sar     eax, 1
.text$mn:0000400D                 imul    edx, eax, 18h
.text$mn:00004010                 add     edx, [ebp+arg_4]
.text$mn:00004013                 mov     [ebp+var_14], edx
.text$mn:00004016                 movzx   eax, [ebp+arg_C]
.text$mn:0000401A                 push    eax
.text$mn:0000401B                 mov     ecx, [ebp+arg_8]
.text$mn:0000401E                 sub     ecx, 18h
.text$mn:00004021                 push    ecx
.text$mn:00004022                 mov     edx, [ebp+var_14]
.text$mn:00004025                 push    edx
.text$mn:00004026                 mov     eax, [ebp+arg_4]
.text$mn:00004029                 push    eax
.text$mn:0000402A                 call    ??$_Median@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@00USortInSelectOrder@@@Z ; std::_Median<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:0000402F                 add     esp, 10h
.text$mn:00004032                 mov     ecx, [ebp+var_14]
.text$mn:00004035                 mov     [ebp+var_4], ecx
.text$mn:00004038                 mov     edx, [ebp+var_4]
.text$mn:0000403B                 add     edx, 18h
.text$mn:0000403E                 mov     [ebp+var_8], edx
.text$mn:00004041
.text$mn:00004041 loc_4041:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+A1j
.text$mn:00004041                 mov     eax, [ebp+arg_4]
.text$mn:00004044                 cmp     eax, [ebp+var_4]
.text$mn:00004047                 jnb     short loc_4097
.text$mn:00004049                 push    0BFEh           ; unsigned int
.text$mn:0000404E                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004053                 mov     ecx, [ebp+var_4]
.text$mn:00004056                 push    ecx             ; int
.text$mn:00004057                 mov     edx, [ebp+var_4]
.text$mn:0000405A                 sub     edx, 18h
.text$mn:0000405D                 push    edx             ; int
.text$mn:0000405E                 movzx   eax, [ebp+arg_C]
.text$mn:00004062                 push    eax             ; char
.text$mn:00004063                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00004068                 add     esp, 14h
.text$mn:0000406B                 movzx   ecx, al
.text$mn:0000406E                 test    ecx, ecx
.text$mn:00004070                 jnz     short loc_4097
.text$mn:00004072                 mov     edx, [ebp+var_4]
.text$mn:00004075                 sub     edx, 18h
.text$mn:00004078                 push    edx
.text$mn:00004079                 mov     eax, [ebp+var_4]
.text$mn:0000407C                 push    eax
.text$mn:0000407D                 lea     ecx, [ebp+arg_C]
.text$mn:00004080                 call    ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:00004085                 movzx   ecx, al
.text$mn:00004088                 test    ecx, ecx
.text$mn:0000408A                 jnz     short loc_4097
.text$mn:0000408C                 mov     edx, [ebp+var_4]
.text$mn:0000408F                 sub     edx, 18h
.text$mn:00004092                 mov     [ebp+var_4], edx
.text$mn:00004095                 jmp     short loc_4041
.text$mn:00004097 ; ---------------------------------------------------------------------------
.text$mn:00004097
.text$mn:00004097 loc_4097:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+53j
.text$mn:00004097                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+7Cj ...
.text$mn:00004097                 mov     eax, [ebp+var_8]
.text$mn:0000409A                 cmp     eax, [ebp+arg_8]
.text$mn:0000409D                 jnb     short loc_40E7
.text$mn:0000409F                 push    0C02h           ; unsigned int
.text$mn:000040A4                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000040A9                 mov     ecx, [ebp+var_4]
.text$mn:000040AC                 push    ecx             ; int
.text$mn:000040AD                 mov     edx, [ebp+var_8]
.text$mn:000040B0                 push    edx             ; int
.text$mn:000040B1                 movzx   eax, [ebp+arg_C]
.text$mn:000040B5                 push    eax             ; char
.text$mn:000040B6                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000040BB                 add     esp, 14h
.text$mn:000040BE                 movzx   ecx, al
.text$mn:000040C1                 test    ecx, ecx
.text$mn:000040C3                 jnz     short loc_40E7
.text$mn:000040C5                 mov     edx, [ebp+var_8]
.text$mn:000040C8                 push    edx
.text$mn:000040C9                 mov     eax, [ebp+var_4]
.text$mn:000040CC                 push    eax
.text$mn:000040CD                 lea     ecx, [ebp+arg_C]
.text$mn:000040D0                 call    ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:000040D5                 movzx   ecx, al
.text$mn:000040D8                 test    ecx, ecx
.text$mn:000040DA                 jnz     short loc_40E7
.text$mn:000040DC                 mov     edx, [ebp+var_8]
.text$mn:000040DF                 add     edx, 18h
.text$mn:000040E2                 mov     [ebp+var_8], edx
.text$mn:000040E5                 jmp     short loc_4097
.text$mn:000040E7 ; ---------------------------------------------------------------------------
.text$mn:000040E7
.text$mn:000040E7 loc_40E7:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+A9j
.text$mn:000040E7                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+CFj ...
.text$mn:000040E7                 mov     eax, [ebp+var_8]
.text$mn:000040EA                 mov     [ebp+var_10], eax
.text$mn:000040ED                 mov     ecx, [ebp+var_4]
.text$mn:000040F0                 mov     [ebp+var_C], ecx
.text$mn:000040F3
.text$mn:000040F3 loc_40F3:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder):loc_42FCj
.text$mn:000040F3                 jmp     short loc_40FE
.text$mn:000040F5 ; ---------------------------------------------------------------------------
.text$mn:000040F5
.text$mn:000040F5 loc_40F5:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder):loc_4179j
.text$mn:000040F5                 mov     edx, [ebp+var_10]
.text$mn:000040F8                 add     edx, 18h
.text$mn:000040FB                 mov     [ebp+var_10], edx
.text$mn:000040FE
.text$mn:000040FE loc_40FE:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder):loc_40F3j
.text$mn:000040FE                 mov     eax, [ebp+var_10]
.text$mn:00004101                 cmp     eax, [ebp+arg_8]
.text$mn:00004104                 jnb     short loc_417E
.text$mn:00004106                 push    0C0Ch           ; unsigned int
.text$mn:0000410B                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004110                 mov     ecx, [ebp+var_10]
.text$mn:00004113                 push    ecx             ; int
.text$mn:00004114                 mov     edx, [ebp+var_4]
.text$mn:00004117                 push    edx             ; int
.text$mn:00004118                 movzx   eax, [ebp+arg_C]
.text$mn:0000411C                 push    eax             ; char
.text$mn:0000411D                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:00004122                 add     esp, 14h
.text$mn:00004125                 movzx   ecx, al
.text$mn:00004128                 test    ecx, ecx
.text$mn:0000412A                 jz      short loc_412E
.text$mn:0000412C                 jmp     short loc_4179
.text$mn:0000412E ; ---------------------------------------------------------------------------
.text$mn:0000412E
.text$mn:0000412E loc_412E:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+136j
.text$mn:0000412E                 mov     edx, [ebp+var_4]
.text$mn:00004131                 push    edx
.text$mn:00004132                 mov     eax, [ebp+var_10]
.text$mn:00004135                 push    eax
.text$mn:00004136                 lea     ecx, [ebp+arg_C]
.text$mn:00004139                 call    ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:0000413E                 movzx   ecx, al
.text$mn:00004141                 test    ecx, ecx
.text$mn:00004143                 jz      short loc_4149
.text$mn:00004145                 jmp     short loc_417E
.text$mn:00004147 ; ---------------------------------------------------------------------------
.text$mn:00004147                 jmp     short loc_4179
.text$mn:00004149 ; ---------------------------------------------------------------------------
.text$mn:00004149
.text$mn:00004149 loc_4149:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+14Fj
.text$mn:00004149                 mov     edx, [ebp+var_8]
.text$mn:0000414C                 mov     [ebp+var_18], edx
.text$mn:0000414F                 mov     eax, [ebp+var_10]
.text$mn:00004152                 mov     [ebp+var_1C], eax
.text$mn:00004155                 mov     ecx, [ebp+var_8]
.text$mn:00004158                 add     ecx, 18h
.text$mn:0000415B                 mov     [ebp+var_8], ecx
.text$mn:0000415E                 mov     edx, [ebp+var_18]
.text$mn:00004161                 cmp     edx, [ebp+var_1C]
.text$mn:00004164                 jz      short loc_4179
.text$mn:00004166                 mov     eax, [ebp+var_10]
.text$mn:00004169                 push    eax
.text$mn:0000416A                 mov     ecx, [ebp+var_8]
.text$mn:0000416D                 sub     ecx, 18h
.text$mn:00004170                 push    ecx
.text$mn:00004171                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00004176                 add     esp, 8
.text$mn:00004179
.text$mn:00004179 loc_4179:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+138j
.text$mn:00004179                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+153j ...
.text$mn:00004179                 jmp     loc_40F5
.text$mn:0000417E ; ---------------------------------------------------------------------------
.text$mn:0000417E
.text$mn:0000417E loc_417E:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+110j
.text$mn:0000417E                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+151j
.text$mn:0000417E                 jmp     short loc_4189
.text$mn:00004180 ; ---------------------------------------------------------------------------
.text$mn:00004180
.text$mn:00004180 loc_4180:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder):loc_4201j
.text$mn:00004180                 mov     edx, [ebp+var_C]
.text$mn:00004183                 sub     edx, 18h
.text$mn:00004186                 mov     [ebp+var_C], edx
.text$mn:00004189
.text$mn:00004189 loc_4189:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder):loc_417Ej
.text$mn:00004189                 mov     eax, [ebp+arg_4]
.text$mn:0000418C                 cmp     eax, [ebp+var_C]
.text$mn:0000418F                 jnb     short loc_4206
.text$mn:00004191                 push    0C13h           ; unsigned int
.text$mn:00004196                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000419B                 mov     ecx, [ebp+var_4]
.text$mn:0000419E                 push    ecx             ; int
.text$mn:0000419F                 mov     edx, [ebp+var_C]
.text$mn:000041A2                 sub     edx, 18h
.text$mn:000041A5                 push    edx             ; int
.text$mn:000041A6                 movzx   eax, [ebp+arg_C]
.text$mn:000041AA                 push    eax             ; char
.text$mn:000041AB                 call    ??$_Debug_lt_pred@USortInSelectOrder@@AAUColumnModeInfo@@AAU2@@std@@YA_NUSortInSelectOrder@@AAUColumnModeInfo@@1PB_WI@Z ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)
.text$mn:000041B0                 add     esp, 14h
.text$mn:000041B3                 movzx   ecx, al
.text$mn:000041B6                 test    ecx, ecx
.text$mn:000041B8                 jz      short loc_41BC
.text$mn:000041BA                 jmp     short loc_4201
.text$mn:000041BC ; ---------------------------------------------------------------------------
.text$mn:000041BC
.text$mn:000041BC loc_41BC:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+1C4j
.text$mn:000041BC                 mov     edx, [ebp+var_C]
.text$mn:000041BF                 sub     edx, 18h
.text$mn:000041C2                 push    edx
.text$mn:000041C3                 mov     eax, [ebp+var_4]
.text$mn:000041C6                 push    eax
.text$mn:000041C7                 lea     ecx, [ebp+arg_C]
.text$mn:000041CA                 call    ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z ; SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:000041CF                 movzx   ecx, al
.text$mn:000041D2                 test    ecx, ecx
.text$mn:000041D4                 jz      short loc_41DA
.text$mn:000041D6                 jmp     short loc_4206
.text$mn:000041D8 ; ---------------------------------------------------------------------------
.text$mn:000041D8                 jmp     short loc_4201
.text$mn:000041DA ; ---------------------------------------------------------------------------
.text$mn:000041DA
.text$mn:000041DA loc_41DA:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+1E0j
.text$mn:000041DA                 mov     edx, [ebp+var_4]
.text$mn:000041DD                 sub     edx, 18h
.text$mn:000041E0                 mov     [ebp+var_4], edx
.text$mn:000041E3                 mov     eax, [ebp+var_C]
.text$mn:000041E6                 sub     eax, 18h
.text$mn:000041E9                 cmp     [ebp+var_4], eax
.text$mn:000041EC                 jz      short loc_4201
.text$mn:000041EE                 mov     ecx, [ebp+var_C]
.text$mn:000041F1                 sub     ecx, 18h
.text$mn:000041F4                 push    ecx
.text$mn:000041F5                 mov     edx, [ebp+var_4]
.text$mn:000041F8                 push    edx
.text$mn:000041F9                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000041FE                 add     esp, 8
.text$mn:00004201
.text$mn:00004201 loc_4201:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+1C6j
.text$mn:00004201                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+1E4j ...
.text$mn:00004201                 jmp     loc_4180
.text$mn:00004206 ; ---------------------------------------------------------------------------
.text$mn:00004206
.text$mn:00004206 loc_4206:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+19Bj
.text$mn:00004206                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+1E2j
.text$mn:00004206                 mov     eax, [ebp+var_C]
.text$mn:00004209                 cmp     eax, [ebp+arg_4]
.text$mn:0000420C                 jnz     short loc_422E
.text$mn:0000420E                 mov     ecx, [ebp+var_10]
.text$mn:00004211                 cmp     ecx, [ebp+arg_8]
.text$mn:00004214                 jnz     short loc_422E
.text$mn:00004216                 lea     edx, [ebp+var_8]
.text$mn:00004219                 push    edx
.text$mn:0000421A                 lea     eax, [ebp+var_4]
.text$mn:0000421D                 push    eax
.text$mn:0000421E                 mov     ecx, [ebp+arg_0]
.text$mn:00004221                 call    ??$?0AAPAUColumnModeInfo@@AAPAU0@X@?$pair@PAUColumnModeInfo@@PAU1@@std@@QAE@AAPAUColumnModeInfo@@0@Z ; std::pair<ColumnModeInfo *,ColumnModeInfo *>::pair<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo * &,ColumnModeInfo * &)
.text$mn:00004226                 mov     eax, [ebp+arg_0]
.text$mn:00004229                 jmp     loc_4301
.text$mn:0000422E ; ---------------------------------------------------------------------------
.text$mn:0000422E
.text$mn:0000422E loc_422E:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+218j
.text$mn:0000422E                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+220j
.text$mn:0000422E                 mov     ecx, [ebp+var_C]
.text$mn:00004231                 cmp     ecx, [ebp+arg_4]
.text$mn:00004234                 jnz     short loc_4287
.text$mn:00004236                 mov     edx, [ebp+var_8]
.text$mn:00004239                 cmp     edx, [ebp+var_10]
.text$mn:0000423C                 jz      short loc_424E
.text$mn:0000423E                 mov     eax, [ebp+var_8]
.text$mn:00004241                 push    eax
.text$mn:00004242                 mov     ecx, [ebp+var_4]
.text$mn:00004245                 push    ecx
.text$mn:00004246                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:0000424B                 add     esp, 8
.text$mn:0000424E
.text$mn:0000424E loc_424E:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+248j
.text$mn:0000424E                 mov     edx, [ebp+var_8]
.text$mn:00004251                 add     edx, 18h
.text$mn:00004254                 mov     [ebp+var_8], edx
.text$mn:00004257                 mov     eax, [ebp+var_10]
.text$mn:0000425A                 mov     [ebp+var_20], eax
.text$mn:0000425D                 mov     ecx, [ebp+var_4]
.text$mn:00004260                 mov     [ebp+var_24], ecx
.text$mn:00004263                 mov     edx, [ebp+var_4]
.text$mn:00004266                 add     edx, 18h
.text$mn:00004269                 mov     [ebp+var_4], edx
.text$mn:0000426C                 mov     eax, [ebp+var_10]
.text$mn:0000426F                 add     eax, 18h
.text$mn:00004272                 mov     [ebp+var_10], eax
.text$mn:00004275                 mov     ecx, [ebp+var_20]
.text$mn:00004278                 push    ecx
.text$mn:00004279                 mov     edx, [ebp+var_24]
.text$mn:0000427C                 push    edx
.text$mn:0000427D                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00004282                 add     esp, 8
.text$mn:00004285                 jmp     short loc_42FC
.text$mn:00004287 ; ---------------------------------------------------------------------------
.text$mn:00004287
.text$mn:00004287 loc_4287:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+240j
.text$mn:00004287                 mov     eax, [ebp+var_10]
.text$mn:0000428A                 cmp     eax, [ebp+arg_8]
.text$mn:0000428D                 jnz     short loc_42D4
.text$mn:0000428F                 mov     ecx, [ebp+var_C]
.text$mn:00004292                 sub     ecx, 18h
.text$mn:00004295                 mov     [ebp+var_C], ecx
.text$mn:00004298                 mov     edx, [ebp+var_4]
.text$mn:0000429B                 sub     edx, 18h
.text$mn:0000429E                 mov     [ebp+var_4], edx
.text$mn:000042A1                 mov     eax, [ebp+var_C]
.text$mn:000042A4                 cmp     eax, [ebp+var_4]
.text$mn:000042A7                 jz      short loc_42B9
.text$mn:000042A9                 mov     ecx, [ebp+var_4]
.text$mn:000042AC                 push    ecx
.text$mn:000042AD                 mov     edx, [ebp+var_C]
.text$mn:000042B0                 push    edx
.text$mn:000042B1                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000042B6                 add     esp, 8
.text$mn:000042B9
.text$mn:000042B9 loc_42B9:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+2B3j
.text$mn:000042B9                 mov     eax, [ebp+var_8]
.text$mn:000042BC                 sub     eax, 18h
.text$mn:000042BF                 mov     [ebp+var_8], eax
.text$mn:000042C2                 mov     ecx, [ebp+var_8]
.text$mn:000042C5                 push    ecx
.text$mn:000042C6                 mov     edx, [ebp+var_4]
.text$mn:000042C9                 push    edx
.text$mn:000042CA                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000042CF                 add     esp, 8
.text$mn:000042D2                 jmp     short loc_42FC
.text$mn:000042D4 ; ---------------------------------------------------------------------------
.text$mn:000042D4
.text$mn:000042D4 loc_42D4:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+299j
.text$mn:000042D4                 mov     eax, [ebp+var_C]
.text$mn:000042D7                 sub     eax, 18h
.text$mn:000042DA                 mov     [ebp+var_C], eax
.text$mn:000042DD                 mov     ecx, [ebp+var_10]
.text$mn:000042E0                 mov     [ebp+var_28], ecx
.text$mn:000042E3                 mov     edx, [ebp+var_C]
.text$mn:000042E6                 push    edx
.text$mn:000042E7                 mov     eax, [ebp+var_28]
.text$mn:000042EA                 push    eax
.text$mn:000042EB                 call    ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z ; std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:000042F0                 add     esp, 8
.text$mn:000042F3                 mov     ecx, [ebp+var_10]
.text$mn:000042F6                 add     ecx, 18h
.text$mn:000042F9                 mov     [ebp+var_10], ecx
.text$mn:000042FC
.text$mn:000042FC loc_42FC:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+291j
.text$mn:000042FC                                         ; std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+2DEj
.text$mn:000042FC                 jmp     loc_40F3
.text$mn:00004301 ; ---------------------------------------------------------------------------
.text$mn:00004301
.text$mn:00004301 loc_4301:                               ; CODE XREF: std::_Unguarded_partition<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+235j
.text$mn:00004301                 mov     esp, ebp
.text$mn:00004303                 pop     ebp
.text$mn:00004304                 retn
.text$mn:00004304 ??$_Unguarded_partition@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YA?AU?$pair@PAUColumnModeInfo@@PAU1@@0@PAUColumnModeInfo@@0USortInSelectOrder@@@Z endp
.text$mn:00004304
.text$mn:00004304 ; ---------------------------------------------------------------------------
.text$mn:00004305                 align 4
.text$mn:00004305 _text$mn        ends
.text$mn:00004305
.text$mn:00004308 ; ===========================================================================
.text$mn:00004308
.text$mn:00004308 ; Segment type: Pure code
.text$mn:00004308 ; Segment permissions: Read/Execute
.text$mn:00004308 _text$mn        segment para public 'CODE' use32
.text$mn:00004308                 assume cs:_text$mn
.text$mn:00004308                 ;org 4308h
.text$mn:00004308 ; COMDAT (pick any)
.text$mn:00004308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004308
.text$mn:00004308 ; =============== S U B R O U T I N E =======================================
.text$mn:00004308
.text$mn:00004308 ; Attributes: bp-based frame
.text$mn:00004308
.text$mn:00004308 ; int __cdecl std::_Uninit_move<int,int,int>(void *Src, int, void *Dst)
.text$mn:00004308                 public ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004308 ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004308                                         ; CODE XREF: std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+39p
.text$mn:00004308
.text$mn:00004308 var_4           = dword ptr -4
.text$mn:00004308 Src             = dword ptr  8
.text$mn:00004308 arg_4           = dword ptr  0Ch
.text$mn:00004308 Dst             = dword ptr  10h
.text$mn:00004308
.text$mn:00004308                 push    ebp
.text$mn:00004309                 mov     ebp, esp
.text$mn:0000430B                 push    ecx
.text$mn:0000430C                 push    1D6h            ; unsigned int
.text$mn:00004311                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004316                 mov     eax, [ebp+arg_4]
.text$mn:00004319                 push    eax             ; int
.text$mn:0000431A                 mov     ecx, [ebp+Src]
.text$mn:0000431D                 push    ecx             ; int
.text$mn:0000431E                 call    ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z ; std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)
.text$mn:00004323                 add     esp, 10h
.text$mn:00004326                 push    1D7h            ; unsigned int
.text$mn:0000432B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004330                 mov     edx, [ebp+Dst]
.text$mn:00004333                 push    edx             ; int
.text$mn:00004334                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00004339                 add     esp, 0Ch
.text$mn:0000433C                 mov     eax, [ebp+arg_4]
.text$mn:0000433F                 sub     eax, [ebp+Src]
.text$mn:00004342                 sar     eax, 2
.text$mn:00004345                 mov     [ebp+var_4], eax
.text$mn:00004348                 mov     ecx, [ebp+var_4]
.text$mn:0000434B                 shl     ecx, 2
.text$mn:0000434E                 push    ecx             ; Size
.text$mn:0000434F                 mov     edx, [ebp+Src]
.text$mn:00004352                 push    edx             ; Src
.text$mn:00004353                 mov     eax, [ebp+Dst]
.text$mn:00004356                 push    eax             ; Dst
.text$mn:00004357                 call    _memmove
.text$mn:0000435C                 add     esp, 0Ch
.text$mn:0000435F                 mov     ecx, [ebp+var_4]
.text$mn:00004362                 lea     eax, [eax+ecx*4]
.text$mn:00004365                 mov     esp, ebp
.text$mn:00004367                 pop     ebp
.text$mn:00004368                 retn
.text$mn:00004368 ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004368
.text$mn:00004368 ; ---------------------------------------------------------------------------
.text$mn:00004369                 align 4
.text$mn:00004369 _text$mn        ends
.text$mn:00004369
.text$mn:0000436C ; ===========================================================================
.text$mn:0000436C
.text$mn:0000436C ; Segment type: Pure code
.text$mn:0000436C ; Segment permissions: Read/Execute
.text$mn:0000436C _text$mn        segment para public 'CODE' use32
.text$mn:0000436C                 assume cs:_text$mn
.text$mn:0000436C                 ;org 436Ch
.text$mn:0000436C ; COMDAT (pick any)
.text$mn:0000436C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000436C
.text$mn:0000436C ; =============== S U B R O U T I N E =======================================
.text$mn:0000436C
.text$mn:0000436C ; Attributes: bp-based frame
.text$mn:0000436C
.text$mn:0000436C ; int __cdecl std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(void *Src, int, void *Dst, int)
.text$mn:0000436C                 public ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:0000436C ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:0000436C                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+2Ep
.text$mn:0000436C
.text$mn:0000436C var_1           = byte ptr -1
.text$mn:0000436C Src             = dword ptr  8
.text$mn:0000436C arg_4           = dword ptr  0Ch
.text$mn:0000436C Dst             = dword ptr  10h
.text$mn:0000436C arg_C           = dword ptr  14h
.text$mn:0000436C
.text$mn:0000436C                 push    ebp
.text$mn:0000436D                 mov     ebp, esp
.text$mn:0000436F                 push    ecx
.text$mn:00004370                 mov     eax, [ebp+Dst]
.text$mn:00004373                 push    eax
.text$mn:00004374                 mov     ecx, [ebp+Src]
.text$mn:00004377                 push    ecx
.text$mn:00004378                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:0000437D                 add     esp, 8
.text$mn:00004380                 mov     [ebp+var_1], al
.text$mn:00004383                 movzx   edx, [ebp+var_1]
.text$mn:00004387                 push    edx
.text$mn:00004388                 mov     eax, [ebp+Src]
.text$mn:0000438B                 push    eax
.text$mn:0000438C                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:00004391                 add     esp, 4
.text$mn:00004394                 push    eax
.text$mn:00004395                 mov     ecx, [ebp+arg_C]
.text$mn:00004398                 push    ecx
.text$mn:00004399                 mov     edx, [ebp+Dst]
.text$mn:0000439C                 push    edx             ; Dst
.text$mn:0000439D                 mov     eax, [ebp+arg_4]
.text$mn:000043A0                 push    eax             ; int
.text$mn:000043A1                 mov     ecx, [ebp+Src]
.text$mn:000043A4                 push    ecx             ; Src
.text$mn:000043A5                 call    ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:000043AA                 add     esp, 18h
.text$mn:000043AD                 mov     esp, ebp
.text$mn:000043AF                 pop     ebp
.text$mn:000043B0                 retn
.text$mn:000043B0 ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:000043B0
.text$mn:000043B0 ; ---------------------------------------------------------------------------
.text$mn:000043B1                 align 4
.text$mn:000043B1 _text$mn        ends
.text$mn:000043B1
.text$mn:000043B4 ; ===========================================================================
.text$mn:000043B4
.text$mn:000043B4 ; Segment type: Pure code
.text$mn:000043B4 ; Segment permissions: Read/Execute
.text$mn:000043B4 _text$mn        segment para public 'CODE' use32
.text$mn:000043B4                 assume cs:_text$mn
.text$mn:000043B4                 ;org 43B4h
.text$mn:000043B4 ; COMDAT (pick any)
.text$mn:000043B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043B4
.text$mn:000043B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000043B4
.text$mn:000043B4 ; Attributes: bp-based frame
.text$mn:000043B4
.text$mn:000043B4 ; int * __cdecl std::_Uninitialized_move<int *, int *, struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:000043B4                 public ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:000043B4 ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:000043B4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+25p
.text$mn:000043B4
.text$mn:000043B4 arg_0           = dword ptr  8
.text$mn:000043B4 arg_4           = dword ptr  0Ch
.text$mn:000043B4 arg_8           = dword ptr  10h
.text$mn:000043B4 arg_C           = dword ptr  14h
.text$mn:000043B4
.text$mn:000043B4                 push    ebp
.text$mn:000043B5                 mov     ebp, esp
.text$mn:000043B7                 mov     eax, [ebp+arg_C]
.text$mn:000043BA                 push    eax             ; int
.text$mn:000043BB                 mov     ecx, [ebp+arg_8]
.text$mn:000043BE                 push    ecx
.text$mn:000043BF                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000043C4                 add     esp, 4
.text$mn:000043C7                 push    eax             ; Dst
.text$mn:000043C8                 mov     edx, [ebp+arg_4]
.text$mn:000043CB                 push    edx
.text$mn:000043CC                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000043D1                 add     esp, 4
.text$mn:000043D4                 push    eax             ; int
.text$mn:000043D5                 mov     eax, [ebp+arg_0]
.text$mn:000043D8                 push    eax
.text$mn:000043D9                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000043DE                 add     esp, 4
.text$mn:000043E1                 push    eax             ; Src
.text$mn:000043E2                 call    ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:000043E7                 add     esp, 10h
.text$mn:000043EA                 push    eax
.text$mn:000043EB                 lea     ecx, [ebp+arg_8]
.text$mn:000043EE                 push    ecx
.text$mn:000043EF                 call    ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z ; std::_Rechecked<int *,int *>(int * &,int *)
.text$mn:000043F4                 add     esp, 8
.text$mn:000043F7                 mov     eax, [eax]
.text$mn:000043F9                 pop     ebp
.text$mn:000043FA                 retn
.text$mn:000043FA ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:000043FA
.text$mn:000043FA ; ---------------------------------------------------------------------------
.text$mn:000043FB                 align 4
.text$mn:000043FB _text$mn        ends
.text$mn:000043FB
.text$mn:000043FC ; ===========================================================================
.text$mn:000043FC
.text$mn:000043FC ; Segment type: Pure code
.text$mn:000043FC ; Segment permissions: Read/Execute
.text$mn:000043FC _text$mn        segment para public 'CODE' use32
.text$mn:000043FC                 assume cs:_text$mn
.text$mn:000043FC                 ;org 43FCh
.text$mn:000043FC ; COMDAT (pick any)
.text$mn:000043FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043FC
.text$mn:000043FC ; =============== S U B R O U T I N E =======================================
.text$mn:000043FC
.text$mn:000043FC ; Attributes: bp-based frame
.text$mn:000043FC
.text$mn:000043FC ; int * __cdecl std::_Val_type<int *>(int *)
.text$mn:000043FC                 public ??$_Val_type@PAH@std@@YAPAHPAH@Z
.text$mn:000043FC ??$_Val_type@PAH@std@@YAPAHPAH@Z proc near
.text$mn:000043FC                                         ; CODE XREF: std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+20p
.text$mn:000043FC                 push    ebp
.text$mn:000043FD                 mov     ebp, esp
.text$mn:000043FF                 xor     eax, eax
.text$mn:00004401                 pop     ebp
.text$mn:00004402                 retn
.text$mn:00004402 ??$_Val_type@PAH@std@@YAPAHPAH@Z endp
.text$mn:00004402
.text$mn:00004402 ; ---------------------------------------------------------------------------
.text$mn:00004403                 align 4
.text$mn:00004403 _text$mn        ends
.text$mn:00004403
.text$mn:00004404 ; ===========================================================================
.text$mn:00004404
.text$mn:00004404 ; Segment type: Pure code
.text$mn:00004404 ; Segment permissions: Read/Execute
.text$mn:00004404 _text$mn        segment para public 'CODE' use32
.text$mn:00004404                 assume cs:_text$mn
.text$mn:00004404                 ;org 4404h
.text$mn:00004404 ; COMDAT (pick any)
.text$mn:00004404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004404
.text$mn:00004404 ; =============== S U B R O U T I N E =======================================
.text$mn:00004404
.text$mn:00004404 ; Attributes: bp-based frame
.text$mn:00004404
.text$mn:00004404 ; struct ColumnModeInfo * __cdecl std::_Val_type<struct ColumnModeInfo *>(struct ColumnModeInfo *)
.text$mn:00004404                 public ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z
.text$mn:00004404 ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z proc near
.text$mn:00004404                                         ; CODE XREF: std::_Insertion_sort<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+7p
.text$mn:00004404                                         ; std::_Insertion_sort<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+7p ...
.text$mn:00004404                 push    ebp
.text$mn:00004405                 mov     ebp, esp
.text$mn:00004407                 xor     eax, eax
.text$mn:00004409                 pop     ebp
.text$mn:0000440A                 retn
.text$mn:0000440A ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z endp
.text$mn:0000440A
.text$mn:0000440A ; ---------------------------------------------------------------------------
.text$mn:0000440B                 align 4
.text$mn:0000440B _text$mn        ends
.text$mn:0000440B
.text$mn:0000440C ; ===========================================================================
.text$mn:0000440C
.text$mn:0000440C ; Segment type: Pure code
.text$mn:0000440C ; Segment permissions: Read/Execute
.text$mn:0000440C _text$mn        segment para public 'CODE' use32
.text$mn:0000440C                 assume cs:_text$mn
.text$mn:0000440C                 ;org 440Ch
.text$mn:0000440C ; COMDAT (pick any)
.text$mn:0000440C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000440C
.text$mn:0000440C ; =============== S U B R O U T I N E =======================================
.text$mn:0000440C
.text$mn:0000440C ; Attributes: bp-based frame
.text$mn:0000440C
.text$mn:0000440C ; int const * __cdecl std::addressof<int const>(int const &)
.text$mn:0000440C                 public ??$addressof@$$CBH@std@@YAPBHABH@Z
.text$mn:0000440C ??$addressof@$$CBH@std@@YAPBHABH@Z proc near
.text$mn:0000440C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+Dp
.text$mn:0000440C                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+29p
.text$mn:0000440C
.text$mn:0000440C arg_0           = dword ptr  8
.text$mn:0000440C
.text$mn:0000440C                 push    ebp
.text$mn:0000440D                 mov     ebp, esp
.text$mn:0000440F                 mov     eax, [ebp+arg_0]
.text$mn:00004412                 pop     ebp
.text$mn:00004413                 retn
.text$mn:00004413 ??$addressof@$$CBH@std@@YAPBHABH@Z endp
.text$mn:00004413
.text$mn:00004413 _text$mn        ends
.text$mn:00004413
.text$mn:00004414 ; ===========================================================================
.text$mn:00004414
.text$mn:00004414 ; Segment type: Pure code
.text$mn:00004414 ; Segment permissions: Read/Execute
.text$mn:00004414 _text$mn        segment para public 'CODE' use32
.text$mn:00004414                 assume cs:_text$mn
.text$mn:00004414                 ;org 4414h
.text$mn:00004414 ; COMDAT (pick any)
.text$mn:00004414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004414
.text$mn:00004414 ; =============== S U B R O U T I N E =======================================
.text$mn:00004414
.text$mn:00004414 ; Attributes: bp-based frame
.text$mn:00004414
.text$mn:00004414 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00004414                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00004414 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00004414                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00004414                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00004414
.text$mn:00004414 arg_0           = dword ptr  8
.text$mn:00004414
.text$mn:00004414                 push    ebp
.text$mn:00004415                 mov     ebp, esp
.text$mn:00004417                 mov     eax, [ebp+arg_0]
.text$mn:0000441A                 pop     ebp
.text$mn:0000441B                 retn
.text$mn:0000441B ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000441B
.text$mn:0000441B _text$mn        ends
.text$mn:0000441B
.text$mn:0000441C ; ===========================================================================
.text$mn:0000441C
.text$mn:0000441C ; Segment type: Pure code
.text$mn:0000441C ; Segment permissions: Read/Execute
.text$mn:0000441C _text$mn        segment para public 'CODE' use32
.text$mn:0000441C                 assume cs:_text$mn
.text$mn:0000441C                 ;org 441Ch
.text$mn:0000441C ; COMDAT (pick any)
.text$mn:0000441C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000441C
.text$mn:0000441C ; =============== S U B R O U T I N E =======================================
.text$mn:0000441C
.text$mn:0000441C ; Attributes: bp-based frame
.text$mn:0000441C
.text$mn:0000441C ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:0000441C                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:0000441C ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:0000441C                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:0000441C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:0000441C
.text$mn:0000441C arg_0           = dword ptr  8
.text$mn:0000441C
.text$mn:0000441C                 push    ebp
.text$mn:0000441D                 mov     ebp, esp
.text$mn:0000441F                 mov     eax, [ebp+arg_0]
.text$mn:00004422                 pop     ebp
.text$mn:00004423                 retn
.text$mn:00004423 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00004423
.text$mn:00004423 _text$mn        ends
.text$mn:00004423
.text$mn:00004424 ; ===========================================================================
.text$mn:00004424
.text$mn:00004424 ; Segment type: Pure code
.text$mn:00004424 ; Segment permissions: Read/Execute
.text$mn:00004424 _text$mn        segment para public 'CODE' use32
.text$mn:00004424                 assume cs:_text$mn
.text$mn:00004424                 ;org 4424h
.text$mn:00004424 ; COMDAT (pick any)
.text$mn:00004424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004424
.text$mn:00004424 ; =============== S U B R O U T I N E =======================================
.text$mn:00004424
.text$mn:00004424 ; Attributes: bp-based frame
.text$mn:00004424
.text$mn:00004424 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(void *, int)
.text$mn:00004424                 public ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z
.text$mn:00004424 ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z proc near
.text$mn:00004424                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+8Dp
.text$mn:00004424
.text$mn:00004424 var_4           = dword ptr -4
.text$mn:00004424 arg_0           = dword ptr  8
.text$mn:00004424 arg_4           = dword ptr  0Ch
.text$mn:00004424
.text$mn:00004424                 push    ebp
.text$mn:00004425                 mov     ebp, esp
.text$mn:00004427                 push    ecx
.text$mn:00004428                 mov     [ebp+var_4], ecx
.text$mn:0000442B                 mov     eax, [ebp+arg_4]
.text$mn:0000442E                 push    eax
.text$mn:0000442F                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:00004434                 add     esp, 4
.text$mn:00004437                 push    eax             ; int
.text$mn:00004438                 mov     ecx, [ebp+arg_0]
.text$mn:0000443B                 push    ecx             ; void *
.text$mn:0000443C                 mov     edx, [ebp+var_4]
.text$mn:0000443F                 push    edx             ; int
.text$mn:00004440                 call    ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z ; std::allocator_traits<std::allocator<int>>::construct<int,int &>(std::allocator<int> &,int *,int &)
.text$mn:00004445                 add     esp, 0Ch
.text$mn:00004448                 mov     esp, ebp
.text$mn:0000444A                 pop     ebp
.text$mn:0000444B                 retn    8
.text$mn:0000444B ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z endp
.text$mn:0000444B
.text$mn:0000444B ; ---------------------------------------------------------------------------
.text$mn:0000444E                 align 10h
.text$mn:0000444E _text$mn        ends
.text$mn:0000444E
.text$mn:00004450 ; ===========================================================================
.text$mn:00004450
.text$mn:00004450 ; Segment type: Pure code
.text$mn:00004450 ; Segment permissions: Read/Execute
.text$mn:00004450 _text$mn        segment para public 'CODE' use32
.text$mn:00004450                 assume cs:_text$mn
.text$mn:00004450                 ;org 4450h
.text$mn:00004450 ; COMDAT (pick any)
.text$mn:00004450                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004450
.text$mn:00004450 ; =============== S U B R O U T I N E =======================================
.text$mn:00004450
.text$mn:00004450 ; Attributes: bp-based frame
.text$mn:00004450
.text$mn:00004450 ; int __stdcall std::allocator<int>::construct<int,int &>(void *, int)
.text$mn:00004450                 public ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$mn:00004450 ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z proc near
.text$mn:00004450                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::construct<int,int &>(std::allocator<int> &,int *,int &)+17p
.text$mn:00004450
.text$mn:00004450 var_1C          = dword ptr -1Ch
.text$mn:00004450 var_18          = dword ptr -18h
.text$mn:00004450 var_14          = dword ptr -14h
.text$mn:00004450 var_10          = dword ptr -10h
.text$mn:00004450 var_C           = dword ptr -0Ch
.text$mn:00004450 var_4           = dword ptr -4
.text$mn:00004450 arg_0           = dword ptr  8
.text$mn:00004450 arg_4           = dword ptr  0Ch
.text$mn:00004450
.text$mn:00004450                 push    ebp
.text$mn:00004451                 mov     ebp, esp
.text$mn:00004453                 push    0FFFFFFFFh
.text$mn:00004455                 push    offset __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$mn:0000445A                 mov     eax, large fs:0
.text$mn:00004460                 push    eax
.text$mn:00004461                 sub     esp, 10h
.text$mn:00004464                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004469                 xor     eax, ebp
.text$mn:0000446B                 push    eax
.text$mn:0000446C                 lea     eax, [ebp+var_C]
.text$mn:0000446F                 mov     large fs:0, eax
.text$mn:00004475                 mov     [ebp+var_18], ecx
.text$mn:00004478                 mov     eax, [ebp+arg_0]
.text$mn:0000447B                 push    eax             ; void *
.text$mn:0000447C                 push    4               ; unsigned int
.text$mn:0000447E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004483                 add     esp, 8
.text$mn:00004486                 mov     [ebp+var_10], eax
.text$mn:00004489                 mov     [ebp+var_4], 0
.text$mn:00004490                 cmp     [ebp+var_10], 0
.text$mn:00004494                 jz      short loc_44B1
.text$mn:00004496                 mov     ecx, [ebp+arg_4]
.text$mn:00004499                 push    ecx
.text$mn:0000449A                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:0000449F                 add     esp, 4
.text$mn:000044A2                 mov     edx, [ebp+var_10]
.text$mn:000044A5                 mov     eax, [eax]
.text$mn:000044A7                 mov     [edx], eax
.text$mn:000044A9                 mov     ecx, [ebp+var_10]
.text$mn:000044AC                 mov     [ebp+var_14], ecx
.text$mn:000044AF                 jmp     short loc_44B8
.text$mn:000044B1 ; ---------------------------------------------------------------------------
.text$mn:000044B1
.text$mn:000044B1 loc_44B1:                               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+44j
.text$mn:000044B1                 mov     [ebp+var_14], 0
.text$mn:000044B8
.text$mn:000044B8 loc_44B8:                               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+5Fj
.text$mn:000044B8                 mov     edx, [ebp+var_14]
.text$mn:000044BB                 mov     [ebp+var_1C], edx
.text$mn:000044BE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044C5                 mov     ecx, [ebp+var_C]
.text$mn:000044C8                 mov     large fs:0, ecx
.text$mn:000044CF                 pop     ecx
.text$mn:000044D0                 mov     esp, ebp
.text$mn:000044D2                 pop     ebp
.text$mn:000044D3                 retn    8
.text$mn:000044D3 ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z endp
.text$mn:000044D3
.text$mn:000044D3 ; ---------------------------------------------------------------------------
.text$mn:000044D6                 align 4
.text$mn:000044D6 _text$mn        ends
.text$mn:000044D6
.text$x:000044D8 ; ===========================================================================
.text$x:000044D8
.text$x:000044D8 ; Segment type: Pure code
.text$x:000044D8 ; Segment permissions: Read/Execute
.text$x:000044D8 _text$x         segment para public 'CODE' use32
.text$x:000044D8                 assume cs:_text$x
.text$x:000044D8                 ;org 44D8h
.text$x:000044D8 ; COMDAT (pick associative to section at 4450)
.text$x:000044D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000044D8
.text$x:000044D8 ; =============== S U B R O U T I N E =======================================
.text$x:000044D8
.text$x:000044D8
.text$x:000044D8 __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0 proc near
.text$x:000044D8                                         ; DATA XREF: .xdata$x:0000ADBCo
.text$x:000044D8                 mov     eax, [ebp+8]
.text$x:000044DB                 push    eax
.text$x:000044DC                 mov     eax, [ebp-10h]
.text$x:000044DF                 push    eax             ; void *
.text$x:000044E0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000044E5                 add     esp, 8
.text$x:000044E8                 retn
.text$x:000044E8 __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0 endp
.text$x:000044E8
.text$x:000044E9
.text$x:000044E9 ; =============== S U B R O U T I N E =======================================
.text$x:000044E9
.text$x:000044E9
.text$x:000044E9 __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z proc near
.text$x:000044E9                                         ; DATA XREF: std::allocator<int>::construct<int,int &>(int *,int &)+5o
.text$x:000044E9
.text$x:000044E9 arg_4           = dword ptr  8
.text$x:000044E9
.text$x:000044E9                 mov     edx, [esp+arg_4]
.text$x:000044ED                 lea     eax, [edx+0Ch]
.text$x:000044F0                 mov     ecx, [edx-14h]
.text$x:000044F3                 xor     ecx, eax
.text$x:000044F5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000044FA                 mov     eax, offset __ehfuncinfo$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$x:000044FF                 jmp     ___CxxFrameHandler3
.text$x:000044FF __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z endp
.text$x:000044FF
.text$x:000044FF _text$x         ends
.text$x:000044FF
.text$mn:00004504 ; ===========================================================================
.text$mn:00004504
.text$mn:00004504 ; Segment type: Pure code
.text$mn:00004504 ; Segment permissions: Read/Execute
.text$mn:00004504 _text$mn        segment para public 'CODE' use32
.text$mn:00004504                 assume cs:_text$mn
.text$mn:00004504                 ;org 4504h
.text$mn:00004504 ; COMDAT (pick any)
.text$mn:00004504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004504
.text$mn:00004504 ; =============== S U B R O U T I N E =======================================
.text$mn:00004504
.text$mn:00004504 ; Attributes: bp-based frame
.text$mn:00004504
.text$mn:00004504 ; int __cdecl std::allocator_traits<std::allocator<int>>::construct<int,int &>(int, void *, int)
.text$mn:00004504                 public ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z
.text$mn:00004504 ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z proc near
.text$mn:00004504                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)+1Cp
.text$mn:00004504
.text$mn:00004504 arg_0           = dword ptr  8
.text$mn:00004504 arg_4           = dword ptr  0Ch
.text$mn:00004504 arg_8           = dword ptr  10h
.text$mn:00004504
.text$mn:00004504                 push    ebp
.text$mn:00004505                 mov     ebp, esp
.text$mn:00004507                 mov     eax, [ebp+arg_8]
.text$mn:0000450A                 push    eax
.text$mn:0000450B                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:00004510                 add     esp, 4
.text$mn:00004513                 push    eax             ; int
.text$mn:00004514                 mov     ecx, [ebp+arg_4]
.text$mn:00004517                 push    ecx             ; void *
.text$mn:00004518                 mov     ecx, [ebp+arg_0]
.text$mn:0000451B                 call    ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int,int &>(int *,int &)
.text$mn:00004520                 pop     ebp
.text$mn:00004521                 retn
.text$mn:00004521 ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z endp
.text$mn:00004521
.text$mn:00004521 ; ---------------------------------------------------------------------------
.text$mn:00004522                 align 4
.text$mn:00004522 _text$mn        ends
.text$mn:00004522
.text$mn:00004524 ; ===========================================================================
.text$mn:00004524
.text$mn:00004524 ; Segment type: Pure code
.text$mn:00004524 ; Segment permissions: Read/Execute
.text$mn:00004524 _text$mn        segment para public 'CODE' use32
.text$mn:00004524                 assume cs:_text$mn
.text$mn:00004524                 ;org 4524h
.text$mn:00004524 ; COMDAT (pick any)
.text$mn:00004524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004524
.text$mn:00004524 ; =============== S U B R O U T I N E =======================================
.text$mn:00004524
.text$mn:00004524 ; Attributes: bp-based frame
.text$mn:00004524
.text$mn:00004524 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(void *, int)
.text$mn:00004524                 public ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z
.text$mn:00004524 ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z proc near
.text$mn:00004524                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+EAp
.text$mn:00004524
.text$mn:00004524 var_4           = dword ptr -4
.text$mn:00004524 arg_0           = dword ptr  8
.text$mn:00004524 arg_4           = dword ptr  0Ch
.text$mn:00004524
.text$mn:00004524                 push    ebp
.text$mn:00004525                 mov     ebp, esp
.text$mn:00004527                 push    ecx
.text$mn:00004528                 mov     [ebp+var_4], ecx
.text$mn:0000452B                 mov     eax, [ebp+arg_4]
.text$mn:0000452E                 push    eax
.text$mn:0000452F                 call    ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>(int const &)
.text$mn:00004534                 add     esp, 4
.text$mn:00004537                 push    eax             ; int
.text$mn:00004538                 mov     ecx, [ebp+arg_0]
.text$mn:0000453B                 push    ecx             ; void *
.text$mn:0000453C                 mov     edx, [ebp+var_4]
.text$mn:0000453F                 push    edx             ; int
.text$mn:00004540                 call    ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z ; std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)
.text$mn:00004545                 add     esp, 0Ch
.text$mn:00004548                 mov     esp, ebp
.text$mn:0000454A                 pop     ebp
.text$mn:0000454B                 retn    8
.text$mn:0000454B ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z endp
.text$mn:0000454B
.text$mn:0000454B ; ---------------------------------------------------------------------------
.text$mn:0000454E                 align 10h
.text$mn:0000454E _text$mn        ends
.text$mn:0000454E
.text$mn:00004550 ; ===========================================================================
.text$mn:00004550
.text$mn:00004550 ; Segment type: Pure code
.text$mn:00004550 ; Segment permissions: Read/Execute
.text$mn:00004550 _text$mn        segment para public 'CODE' use32
.text$mn:00004550                 assume cs:_text$mn
.text$mn:00004550                 ;org 4550h
.text$mn:00004550 ; COMDAT (pick any)
.text$mn:00004550                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004550
.text$mn:00004550 ; =============== S U B R O U T I N E =======================================
.text$mn:00004550
.text$mn:00004550 ; Attributes: bp-based frame
.text$mn:00004550
.text$mn:00004550 ; int __cdecl std::allocator_traits<std::allocator<int>>::construct<int,int const &>(int, void *, int)
.text$mn:00004550                 public ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z
.text$mn:00004550 ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z proc near
.text$mn:00004550                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)+1Cp
.text$mn:00004550
.text$mn:00004550 arg_0           = dword ptr  8
.text$mn:00004550 arg_4           = dword ptr  0Ch
.text$mn:00004550 arg_8           = dword ptr  10h
.text$mn:00004550
.text$mn:00004550                 push    ebp
.text$mn:00004551                 mov     ebp, esp
.text$mn:00004553                 mov     eax, [ebp+arg_8]
.text$mn:00004556                 push    eax
.text$mn:00004557                 call    ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>(int const &)
.text$mn:0000455C                 add     esp, 4
.text$mn:0000455F                 push    eax             ; int
.text$mn:00004560                 mov     ecx, [ebp+arg_4]
.text$mn:00004563                 push    ecx             ; void *
.text$mn:00004564                 mov     ecx, [ebp+arg_0]
.text$mn:00004567                 call    ?construct@?$allocator@H@std@@QAEXPAHABH@Z ; std::allocator<int>::construct(int *,int const &)
.text$mn:0000456C                 pop     ebp
.text$mn:0000456D                 retn
.text$mn:0000456D ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z endp
.text$mn:0000456D
.text$mn:0000456D ; ---------------------------------------------------------------------------
.text$mn:0000456E                 align 10h
.text$mn:0000456E _text$mn        ends
.text$mn:0000456E
.text$mn:00004570 ; ===========================================================================
.text$mn:00004570
.text$mn:00004570 ; Segment type: Pure code
.text$mn:00004570 ; Segment permissions: Read/Execute
.text$mn:00004570 _text$mn        segment para public 'CODE' use32
.text$mn:00004570                 assume cs:_text$mn
.text$mn:00004570                 ;org 4570h
.text$mn:00004570 ; COMDAT (pick any)
.text$mn:00004570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004570
.text$mn:00004570 ; =============== S U B R O U T I N E =======================================
.text$mn:00004570
.text$mn:00004570 ; Attributes: bp-based frame
.text$mn:00004570
.text$mn:00004570 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00004570                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00004570 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00004570                                         ; CODE XREF: $LN19+4Bp
.text$mn:00004570
.text$mn:00004570 var_4           = dword ptr -4
.text$mn:00004570 arg_0           = dword ptr  8
.text$mn:00004570 arg_4           = dword ptr  0Ch
.text$mn:00004570
.text$mn:00004570                 push    ebp
.text$mn:00004571                 mov     ebp, esp
.text$mn:00004573                 push    ecx
.text$mn:00004574                 mov     [ebp+var_4], ecx
.text$mn:00004577                 mov     eax, [ebp+arg_4]
.text$mn:0000457A                 push    eax
.text$mn:0000457B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00004580                 add     esp, 4
.text$mn:00004583                 push    eax             ; int
.text$mn:00004584                 mov     ecx, [ebp+arg_0]
.text$mn:00004587                 push    ecx             ; void *
.text$mn:00004588                 mov     edx, [ebp+var_4]
.text$mn:0000458B                 push    edx             ; int
.text$mn:0000458C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00004591                 add     esp, 0Ch
.text$mn:00004594                 mov     esp, ebp
.text$mn:00004596                 pop     ebp
.text$mn:00004597                 retn    8
.text$mn:00004597 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00004597
.text$mn:00004597 ; ---------------------------------------------------------------------------
.text$mn:0000459A                 align 4
.text$mn:0000459A _text$mn        ends
.text$mn:0000459A
.text$mn:0000459C ; ===========================================================================
.text$mn:0000459C
.text$mn:0000459C ; Segment type: Pure code
.text$mn:0000459C ; Segment permissions: Read/Execute
.text$mn:0000459C _text$mn        segment para public 'CODE' use32
.text$mn:0000459C                 assume cs:_text$mn
.text$mn:0000459C                 ;org 459Ch
.text$mn:0000459C ; COMDAT (pick any)
.text$mn:0000459C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000459C
.text$mn:0000459C ; =============== S U B R O U T I N E =======================================
.text$mn:0000459C
.text$mn:0000459C ; Attributes: bp-based frame
.text$mn:0000459C
.text$mn:0000459C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000459C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000459C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000459C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000459C
.text$mn:0000459C var_1C          = dword ptr -1Ch
.text$mn:0000459C var_18          = dword ptr -18h
.text$mn:0000459C var_14          = dword ptr -14h
.text$mn:0000459C var_10          = dword ptr -10h
.text$mn:0000459C var_C           = dword ptr -0Ch
.text$mn:0000459C var_4           = dword ptr -4
.text$mn:0000459C arg_0           = dword ptr  8
.text$mn:0000459C arg_4           = dword ptr  0Ch
.text$mn:0000459C
.text$mn:0000459C                 push    ebp
.text$mn:0000459D                 mov     ebp, esp
.text$mn:0000459F                 push    0FFFFFFFFh
.text$mn:000045A1                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000045A6                 mov     eax, large fs:0
.text$mn:000045AC                 push    eax
.text$mn:000045AD                 sub     esp, 10h
.text$mn:000045B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000045B5                 xor     eax, ebp
.text$mn:000045B7                 push    eax
.text$mn:000045B8                 lea     eax, [ebp+var_C]
.text$mn:000045BB                 mov     large fs:0, eax
.text$mn:000045C1                 mov     [ebp+var_18], ecx
.text$mn:000045C4                 mov     eax, [ebp+arg_0]
.text$mn:000045C7                 push    eax             ; void *
.text$mn:000045C8                 push    4               ; unsigned int
.text$mn:000045CA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000045CF                 add     esp, 8
.text$mn:000045D2                 mov     [ebp+var_10], eax
.text$mn:000045D5                 mov     [ebp+var_4], 0
.text$mn:000045DC                 cmp     [ebp+var_10], 0
.text$mn:000045E0                 jz      short loc_45FD
.text$mn:000045E2                 mov     ecx, [ebp+arg_4]
.text$mn:000045E5                 push    ecx
.text$mn:000045E6                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000045EB                 add     esp, 4
.text$mn:000045EE                 mov     edx, [ebp+var_10]
.text$mn:000045F1                 mov     eax, [eax]
.text$mn:000045F3                 mov     [edx], eax
.text$mn:000045F5                 mov     ecx, [ebp+var_10]
.text$mn:000045F8                 mov     [ebp+var_14], ecx
.text$mn:000045FB                 jmp     short loc_4604
.text$mn:000045FD ; ---------------------------------------------------------------------------
.text$mn:000045FD
.text$mn:000045FD loc_45FD:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000045FD                 mov     [ebp+var_14], 0
.text$mn:00004604
.text$mn:00004604 loc_4604:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00004604                 mov     edx, [ebp+var_14]
.text$mn:00004607                 mov     [ebp+var_1C], edx
.text$mn:0000460A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004611                 mov     ecx, [ebp+var_C]
.text$mn:00004614                 mov     large fs:0, ecx
.text$mn:0000461B                 pop     ecx
.text$mn:0000461C                 mov     esp, ebp
.text$mn:0000461E                 pop     ebp
.text$mn:0000461F                 retn    8
.text$mn:0000461F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000461F
.text$mn:0000461F ; ---------------------------------------------------------------------------
.text$mn:00004622                 align 4
.text$mn:00004622 _text$mn        ends
.text$mn:00004622
.text$x:00004624 ; ===========================================================================
.text$x:00004624
.text$x:00004624 ; Segment type: Pure code
.text$x:00004624 ; Segment permissions: Read/Execute
.text$x:00004624 _text$x         segment para public 'CODE' use32
.text$x:00004624                 assume cs:_text$x
.text$x:00004624                 ;org 4624h
.text$x:00004624 ; COMDAT (pick associative to section at 459C)
.text$x:00004624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004624
.text$x:00004624 ; =============== S U B R O U T I N E =======================================
.text$x:00004624
.text$x:00004624
.text$x:00004624 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00004624                                         ; DATA XREF: .xdata$x:0000ADE8o
.text$x:00004624                 mov     eax, [ebp+8]
.text$x:00004627                 push    eax
.text$x:00004628                 mov     eax, [ebp-10h]
.text$x:0000462B                 push    eax             ; void *
.text$x:0000462C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004631                 add     esp, 8
.text$x:00004634                 retn
.text$x:00004634 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00004634
.text$x:00004635
.text$x:00004635 ; =============== S U B R O U T I N E =======================================
.text$x:00004635
.text$x:00004635
.text$x:00004635 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00004635                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00004635
.text$x:00004635 arg_4           = dword ptr  8
.text$x:00004635
.text$x:00004635                 mov     edx, [esp+arg_4]
.text$x:00004639                 lea     eax, [edx+0Ch]
.text$x:0000463C                 mov     ecx, [edx-14h]
.text$x:0000463F                 xor     ecx, eax
.text$x:00004641                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004646                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000464B                 jmp     ___CxxFrameHandler3
.text$x:0000464B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000464B
.text$x:0000464B _text$x         ends
.text$x:0000464B
.text$mn:00004650 ; ===========================================================================
.text$mn:00004650
.text$mn:00004650 ; Segment type: Pure code
.text$mn:00004650 ; Segment permissions: Read/Execute
.text$mn:00004650 _text$mn        segment para public 'CODE' use32
.text$mn:00004650                 assume cs:_text$mn
.text$mn:00004650                 ;org 4650h
.text$mn:00004650 ; COMDAT (pick any)
.text$mn:00004650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004650
.text$mn:00004650 ; =============== S U B R O U T I N E =======================================
.text$mn:00004650
.text$mn:00004650 ; Attributes: bp-based frame
.text$mn:00004650
.text$mn:00004650 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00004650                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00004650 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00004650                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00004650
.text$mn:00004650 arg_0           = dword ptr  8
.text$mn:00004650 arg_4           = dword ptr  0Ch
.text$mn:00004650 arg_8           = dword ptr  10h
.text$mn:00004650
.text$mn:00004650                 push    ebp
.text$mn:00004651                 mov     ebp, esp
.text$mn:00004653                 mov     eax, [ebp+arg_8]
.text$mn:00004656                 push    eax
.text$mn:00004657                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000465C                 add     esp, 4
.text$mn:0000465F                 push    eax             ; int
.text$mn:00004660                 mov     ecx, [ebp+arg_4]
.text$mn:00004663                 push    ecx             ; void *
.text$mn:00004664                 mov     ecx, [ebp+arg_0]
.text$mn:00004667                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000466C                 pop     ebp
.text$mn:0000466D                 retn
.text$mn:0000466D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000466D
.text$mn:0000466D ; ---------------------------------------------------------------------------
.text$mn:0000466E                 align 10h
.text$mn:0000466E _text$mn        ends
.text$mn:0000466E
.text$mn:00004670 ; ===========================================================================
.text$mn:00004670
.text$mn:00004670 ; Segment type: Pure code
.text$mn:00004670 ; Segment permissions: Read/Execute
.text$mn:00004670 _text$mn        segment para public 'CODE' use32
.text$mn:00004670                 assume cs:_text$mn
.text$mn:00004670                 ;org 4670h
.text$mn:00004670 ; COMDAT (pick any)
.text$mn:00004670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004670
.text$mn:00004670 ; =============== S U B R O U T I N E =======================================
.text$mn:00004670
.text$mn:00004670 ; Attributes: bp-based frame
.text$mn:00004670
.text$mn:00004670 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00004670                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00004670 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00004670                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00004670
.text$mn:00004670 var_4           = dword ptr -4
.text$mn:00004670 arg_0           = dword ptr  8
.text$mn:00004670 arg_4           = dword ptr  0Ch
.text$mn:00004670
.text$mn:00004670                 push    ebp
.text$mn:00004671                 mov     ebp, esp
.text$mn:00004673                 push    ecx
.text$mn:00004674                 mov     [ebp+var_4], ecx
.text$mn:00004677                 mov     eax, [ebp+arg_4]
.text$mn:0000467A                 push    eax
.text$mn:0000467B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00004680                 add     esp, 4
.text$mn:00004683                 push    eax             ; int
.text$mn:00004684                 mov     ecx, [ebp+arg_0]
.text$mn:00004687                 push    ecx             ; void *
.text$mn:00004688                 mov     edx, [ebp+var_4]
.text$mn:0000468B                 push    edx             ; int
.text$mn:0000468C                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00004691                 add     esp, 0Ch
.text$mn:00004694                 mov     esp, ebp
.text$mn:00004696                 pop     ebp
.text$mn:00004697                 retn    8
.text$mn:00004697 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00004697
.text$mn:00004697 ; ---------------------------------------------------------------------------
.text$mn:0000469A                 align 4
.text$mn:0000469A _text$mn        ends
.text$mn:0000469A
.text$mn:0000469C ; ===========================================================================
.text$mn:0000469C
.text$mn:0000469C ; Segment type: Pure code
.text$mn:0000469C ; Segment permissions: Read/Execute
.text$mn:0000469C _text$mn        segment para public 'CODE' use32
.text$mn:0000469C                 assume cs:_text$mn
.text$mn:0000469C                 ;org 469Ch
.text$mn:0000469C ; COMDAT (pick any)
.text$mn:0000469C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000469C
.text$mn:0000469C ; =============== S U B R O U T I N E =======================================
.text$mn:0000469C
.text$mn:0000469C ; Attributes: bp-based frame
.text$mn:0000469C
.text$mn:0000469C ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:0000469C                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000469C ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:0000469C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:0000469C
.text$mn:0000469C var_1C          = dword ptr -1Ch
.text$mn:0000469C var_18          = dword ptr -18h
.text$mn:0000469C var_14          = dword ptr -14h
.text$mn:0000469C var_10          = dword ptr -10h
.text$mn:0000469C var_C           = dword ptr -0Ch
.text$mn:0000469C var_4           = dword ptr -4
.text$mn:0000469C arg_0           = dword ptr  8
.text$mn:0000469C arg_4           = dword ptr  0Ch
.text$mn:0000469C
.text$mn:0000469C                 push    ebp
.text$mn:0000469D                 mov     ebp, esp
.text$mn:0000469F                 push    0FFFFFFFFh
.text$mn:000046A1                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000046A6                 mov     eax, large fs:0
.text$mn:000046AC                 push    eax
.text$mn:000046AD                 sub     esp, 10h
.text$mn:000046B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000046B5                 xor     eax, ebp
.text$mn:000046B7                 push    eax
.text$mn:000046B8                 lea     eax, [ebp+var_C]
.text$mn:000046BB                 mov     large fs:0, eax
.text$mn:000046C1                 mov     [ebp+var_18], ecx
.text$mn:000046C4                 mov     eax, [ebp+arg_0]
.text$mn:000046C7                 push    eax             ; void *
.text$mn:000046C8                 push    4               ; unsigned int
.text$mn:000046CA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000046CF                 add     esp, 8
.text$mn:000046D2                 mov     [ebp+var_10], eax
.text$mn:000046D5                 mov     [ebp+var_4], 0
.text$mn:000046DC                 cmp     [ebp+var_10], 0
.text$mn:000046E0                 jz      short loc_46FD
.text$mn:000046E2                 mov     ecx, [ebp+arg_4]
.text$mn:000046E5                 push    ecx
.text$mn:000046E6                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000046EB                 add     esp, 4
.text$mn:000046EE                 mov     edx, [ebp+var_10]
.text$mn:000046F1                 mov     eax, [eax]
.text$mn:000046F3                 mov     [edx], eax
.text$mn:000046F5                 mov     ecx, [ebp+var_10]
.text$mn:000046F8                 mov     [ebp+var_14], ecx
.text$mn:000046FB                 jmp     short loc_4704
.text$mn:000046FD ; ---------------------------------------------------------------------------
.text$mn:000046FD
.text$mn:000046FD loc_46FD:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:000046FD                 mov     [ebp+var_14], 0
.text$mn:00004704
.text$mn:00004704 loc_4704:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00004704                 mov     edx, [ebp+var_14]
.text$mn:00004707                 mov     [ebp+var_1C], edx
.text$mn:0000470A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004711                 mov     ecx, [ebp+var_C]
.text$mn:00004714                 mov     large fs:0, ecx
.text$mn:0000471B                 pop     ecx
.text$mn:0000471C                 mov     esp, ebp
.text$mn:0000471E                 pop     ebp
.text$mn:0000471F                 retn    8
.text$mn:0000471F ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:0000471F
.text$mn:0000471F ; ---------------------------------------------------------------------------
.text$mn:00004722                 align 4
.text$mn:00004722 _text$mn        ends
.text$mn:00004722
.text$x:00004724 ; ===========================================================================
.text$x:00004724
.text$x:00004724 ; Segment type: Pure code
.text$x:00004724 ; Segment permissions: Read/Execute
.text$x:00004724 _text$x         segment para public 'CODE' use32
.text$x:00004724                 assume cs:_text$x
.text$x:00004724                 ;org 4724h
.text$x:00004724 ; COMDAT (pick associative to section at 469C)
.text$x:00004724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004724
.text$x:00004724 ; =============== S U B R O U T I N E =======================================
.text$x:00004724
.text$x:00004724
.text$x:00004724 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00004724                                         ; DATA XREF: .xdata$x:0000AE14o
.text$x:00004724                 mov     eax, [ebp+8]
.text$x:00004727                 push    eax
.text$x:00004728                 mov     eax, [ebp-10h]
.text$x:0000472B                 push    eax             ; void *
.text$x:0000472C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004731                 add     esp, 8
.text$x:00004734                 retn
.text$x:00004734 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00004734
.text$x:00004735
.text$x:00004735 ; =============== S U B R O U T I N E =======================================
.text$x:00004735
.text$x:00004735
.text$x:00004735 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00004735                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00004735
.text$x:00004735 arg_4           = dword ptr  8
.text$x:00004735
.text$x:00004735                 mov     edx, [esp+arg_4]
.text$x:00004739                 lea     eax, [edx+0Ch]
.text$x:0000473C                 mov     ecx, [edx-14h]
.text$x:0000473F                 xor     ecx, eax
.text$x:00004741                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004746                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:0000474B                 jmp     ___CxxFrameHandler3
.text$x:0000474B __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:0000474B
.text$x:0000474B _text$x         ends
.text$x:0000474B
.text$mn:00004750 ; ===========================================================================
.text$mn:00004750
.text$mn:00004750 ; Segment type: Pure code
.text$mn:00004750 ; Segment permissions: Read/Execute
.text$mn:00004750 _text$mn        segment para public 'CODE' use32
.text$mn:00004750                 assume cs:_text$mn
.text$mn:00004750                 ;org 4750h
.text$mn:00004750 ; COMDAT (pick any)
.text$mn:00004750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004750
.text$mn:00004750 ; =============== S U B R O U T I N E =======================================
.text$mn:00004750
.text$mn:00004750 ; Attributes: bp-based frame
.text$mn:00004750
.text$mn:00004750 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00004750                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00004750 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00004750                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00004750
.text$mn:00004750 arg_0           = dword ptr  8
.text$mn:00004750 arg_4           = dword ptr  0Ch
.text$mn:00004750 arg_8           = dword ptr  10h
.text$mn:00004750
.text$mn:00004750                 push    ebp
.text$mn:00004751                 mov     ebp, esp
.text$mn:00004753                 mov     eax, [ebp+arg_8]
.text$mn:00004756                 push    eax
.text$mn:00004757                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000475C                 add     esp, 4
.text$mn:0000475F                 push    eax             ; int
.text$mn:00004760                 mov     ecx, [ebp+arg_4]
.text$mn:00004763                 push    ecx             ; void *
.text$mn:00004764                 mov     ecx, [ebp+arg_0]
.text$mn:00004767                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:0000476C                 pop     ebp
.text$mn:0000476D                 retn
.text$mn:0000476D ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:0000476D
.text$mn:0000476D ; ---------------------------------------------------------------------------
.text$mn:0000476E                 align 10h
.text$mn:0000476E _text$mn        ends
.text$mn:0000476E
.text$mn:00004770 ; ===========================================================================
.text$mn:00004770
.text$mn:00004770 ; Segment type: Pure code
.text$mn:00004770 ; Segment permissions: Read/Execute
.text$mn:00004770 _text$mn        segment para public 'CODE' use32
.text$mn:00004770                 assume cs:_text$mn
.text$mn:00004770                 ;org 4770h
.text$mn:00004770 ; COMDAT (pick any)
.text$mn:00004770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004770
.text$mn:00004770 ; =============== S U B R O U T I N E =======================================
.text$mn:00004770
.text$mn:00004770 ; Attributes: bp-based frame
.text$mn:00004770
.text$mn:00004770 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00004770                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00004770 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00004770                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+32p
.text$mn:00004770
.text$mn:00004770 var_4           = dword ptr -4
.text$mn:00004770 arg_0           = dword ptr  8
.text$mn:00004770 arg_4           = dword ptr  0Ch
.text$mn:00004770
.text$mn:00004770                 push    ebp
.text$mn:00004771                 mov     ebp, esp
.text$mn:00004773                 push    ecx
.text$mn:00004774                 mov     [ebp+var_4], ecx
.text$mn:00004777                 mov     eax, [ebp+arg_4]
.text$mn:0000477A                 push    eax
.text$mn:0000477B                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00004780                 add     esp, 4
.text$mn:00004783                 push    eax             ; int
.text$mn:00004784                 mov     ecx, [ebp+arg_0]
.text$mn:00004787                 push    ecx             ; void *
.text$mn:00004788                 mov     edx, [ebp+var_4]
.text$mn:0000478B                 push    edx             ; int
.text$mn:0000478C                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004791                 add     esp, 0Ch
.text$mn:00004794                 mov     esp, ebp
.text$mn:00004796                 pop     ebp
.text$mn:00004797                 retn    8
.text$mn:00004797 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00004797
.text$mn:00004797 ; ---------------------------------------------------------------------------
.text$mn:0000479A                 align 4
.text$mn:0000479A _text$mn        ends
.text$mn:0000479A
.text$mn:0000479C ; ===========================================================================
.text$mn:0000479C
.text$mn:0000479C ; Segment type: Pure code
.text$mn:0000479C ; Segment permissions: Read/Execute
.text$mn:0000479C _text$mn        segment para public 'CODE' use32
.text$mn:0000479C                 assume cs:_text$mn
.text$mn:0000479C                 ;org 479Ch
.text$mn:0000479C ; COMDAT (pick any)
.text$mn:0000479C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000479C
.text$mn:0000479C ; =============== S U B R O U T I N E =======================================
.text$mn:0000479C
.text$mn:0000479C ; Attributes: bp-based frame
.text$mn:0000479C
.text$mn:0000479C ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:0000479C                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000479C ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:0000479C                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:0000479C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:0000479C
.text$mn:0000479C var_1C          = dword ptr -1Ch
.text$mn:0000479C var_18          = dword ptr -18h
.text$mn:0000479C var_14          = dword ptr -14h
.text$mn:0000479C var_10          = dword ptr -10h
.text$mn:0000479C var_C           = dword ptr -0Ch
.text$mn:0000479C var_4           = dword ptr -4
.text$mn:0000479C arg_0           = dword ptr  8
.text$mn:0000479C arg_4           = dword ptr  0Ch
.text$mn:0000479C
.text$mn:0000479C                 push    ebp
.text$mn:0000479D                 mov     ebp, esp
.text$mn:0000479F                 push    0FFFFFFFFh
.text$mn:000047A1                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000047A6                 mov     eax, large fs:0
.text$mn:000047AC                 push    eax
.text$mn:000047AD                 sub     esp, 10h
.text$mn:000047B0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000047B5                 xor     eax, ebp
.text$mn:000047B7                 push    eax
.text$mn:000047B8                 lea     eax, [ebp+var_C]
.text$mn:000047BB                 mov     large fs:0, eax
.text$mn:000047C1                 mov     [ebp+var_18], ecx
.text$mn:000047C4                 mov     eax, [ebp+arg_0]
.text$mn:000047C7                 push    eax             ; void *
.text$mn:000047C8                 push    8               ; unsigned int
.text$mn:000047CA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000047CF                 add     esp, 8
.text$mn:000047D2                 mov     [ebp+var_10], eax
.text$mn:000047D5                 mov     [ebp+var_4], 0
.text$mn:000047DC                 cmp     [ebp+var_10], 0
.text$mn:000047E0                 jz      short loc_4803
.text$mn:000047E2                 mov     ecx, [ebp+arg_4]
.text$mn:000047E5                 push    ecx
.text$mn:000047E6                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000047EB                 add     esp, 4
.text$mn:000047EE                 mov     edx, [eax]
.text$mn:000047F0                 mov     eax, [eax+4]
.text$mn:000047F3                 mov     ecx, [ebp+var_10]
.text$mn:000047F6                 mov     [ecx], edx
.text$mn:000047F8                 mov     [ecx+4], eax
.text$mn:000047FB                 mov     edx, [ebp+var_10]
.text$mn:000047FE                 mov     [ebp+var_14], edx
.text$mn:00004801                 jmp     short loc_480A
.text$mn:00004803 ; ---------------------------------------------------------------------------
.text$mn:00004803
.text$mn:00004803 loc_4803:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00004803                 mov     [ebp+var_14], 0
.text$mn:0000480A
.text$mn:0000480A loc_480A:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000480A                 mov     eax, [ebp+var_14]
.text$mn:0000480D                 mov     [ebp+var_1C], eax
.text$mn:00004810                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004817                 mov     ecx, [ebp+var_C]
.text$mn:0000481A                 mov     large fs:0, ecx
.text$mn:00004821                 pop     ecx
.text$mn:00004822                 mov     esp, ebp
.text$mn:00004824                 pop     ebp
.text$mn:00004825                 retn    8
.text$mn:00004825 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00004825
.text$mn:00004825 _text$mn        ends
.text$mn:00004825
.text$x:00004828 ; ===========================================================================
.text$x:00004828
.text$x:00004828 ; Segment type: Pure code
.text$x:00004828 ; Segment permissions: Read/Execute
.text$x:00004828 _text$x         segment para public 'CODE' use32
.text$x:00004828                 assume cs:_text$x
.text$x:00004828                 ;org 4828h
.text$x:00004828 ; COMDAT (pick associative to section at 479C)
.text$x:00004828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004828
.text$x:00004828 ; =============== S U B R O U T I N E =======================================
.text$x:00004828
.text$x:00004828
.text$x:00004828 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00004828                                         ; DATA XREF: .xdata$x:0000ACECo
.text$x:00004828                 mov     eax, [ebp+8]
.text$x:0000482B                 push    eax
.text$x:0000482C                 mov     eax, [ebp-10h]
.text$x:0000482F                 push    eax             ; void *
.text$x:00004830                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004835                 add     esp, 8
.text$x:00004838                 retn
.text$x:00004838 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00004838
.text$x:00004839
.text$x:00004839 ; =============== S U B R O U T I N E =======================================
.text$x:00004839
.text$x:00004839
.text$x:00004839 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00004839                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00004839
.text$x:00004839 arg_4           = dword ptr  8
.text$x:00004839
.text$x:00004839                 mov     edx, [esp+arg_4]
.text$x:0000483D                 lea     eax, [edx+0Ch]
.text$x:00004840                 mov     ecx, [edx-14h]
.text$x:00004843                 xor     ecx, eax
.text$x:00004845                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000484A                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000484F                 jmp     ___CxxFrameHandler3
.text$x:0000484F __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000484F
.text$x:0000484F _text$x         ends
.text$x:0000484F
.text$mn:00004854 ; ===========================================================================
.text$mn:00004854
.text$mn:00004854 ; Segment type: Pure code
.text$mn:00004854 ; Segment permissions: Read/Execute
.text$mn:00004854 _text$mn        segment para public 'CODE' use32
.text$mn:00004854                 assume cs:_text$mn
.text$mn:00004854                 ;org 4854h
.text$mn:00004854 ; COMDAT (pick any)
.text$mn:00004854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004854
.text$mn:00004854 ; =============== S U B R O U T I N E =======================================
.text$mn:00004854
.text$mn:00004854 ; Attributes: bp-based frame
.text$mn:00004854
.text$mn:00004854 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00004854                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00004854 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00004854                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00004854
.text$mn:00004854 arg_0           = dword ptr  8
.text$mn:00004854 arg_4           = dword ptr  0Ch
.text$mn:00004854 arg_8           = dword ptr  10h
.text$mn:00004854
.text$mn:00004854                 push    ebp
.text$mn:00004855                 mov     ebp, esp
.text$mn:00004857                 mov     eax, [ebp+arg_8]
.text$mn:0000485A                 push    eax
.text$mn:0000485B                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00004860                 add     esp, 4
.text$mn:00004863                 push    eax             ; int
.text$mn:00004864                 mov     ecx, [ebp+arg_4]
.text$mn:00004867                 push    ecx             ; void *
.text$mn:00004868                 mov     ecx, [ebp+arg_0]
.text$mn:0000486B                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004870                 pop     ebp
.text$mn:00004871                 retn
.text$mn:00004871 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00004871
.text$mn:00004871 ; ---------------------------------------------------------------------------
.text$mn:00004872                 align 4
.text$mn:00004872 _text$mn        ends
.text$mn:00004872
.text$mn:00004874 ; ===========================================================================
.text$mn:00004874
.text$mn:00004874 ; Segment type: Pure code
.text$mn:00004874 ; Segment permissions: Read/Execute
.text$mn:00004874 _text$mn        segment para public 'CODE' use32
.text$mn:00004874                 assume cs:_text$mn
.text$mn:00004874                 ;org 4874h
.text$mn:00004874 ; COMDAT (pick any)
.text$mn:00004874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004874
.text$mn:00004874 ; =============== S U B R O U T I N E =======================================
.text$mn:00004874
.text$mn:00004874 ; Attributes: bp-based frame
.text$mn:00004874
.text$mn:00004874 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00004874                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00004874 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00004874                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00004874
.text$mn:00004874 var_4           = dword ptr -4
.text$mn:00004874 arg_0           = dword ptr  8
.text$mn:00004874
.text$mn:00004874                 push    ebp
.text$mn:00004875                 mov     ebp, esp
.text$mn:00004877                 push    ecx
.text$mn:00004878                 mov     [ebp+var_4], ecx
.text$mn:0000487B                 mov     eax, [ebp+arg_0]
.text$mn:0000487E                 push    eax
.text$mn:0000487F                 mov     ecx, [ebp+var_4]
.text$mn:00004882                 push    ecx
.text$mn:00004883                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00004888                 add     esp, 8
.text$mn:0000488B                 mov     esp, ebp
.text$mn:0000488D                 pop     ebp
.text$mn:0000488E                 retn    4
.text$mn:0000488E ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:0000488E
.text$mn:0000488E ; ---------------------------------------------------------------------------
.text$mn:00004891                 align 4
.text$mn:00004891 _text$mn        ends
.text$mn:00004891
.text$mn:00004894 ; ===========================================================================
.text$mn:00004894
.text$mn:00004894 ; Segment type: Pure code
.text$mn:00004894 ; Segment permissions: Read/Execute
.text$mn:00004894 _text$mn        segment para public 'CODE' use32
.text$mn:00004894                 assume cs:_text$mn
.text$mn:00004894                 ;org 4894h
.text$mn:00004894 ; COMDAT (pick any)
.text$mn:00004894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004894
.text$mn:00004894 ; =============== S U B R O U T I N E =======================================
.text$mn:00004894
.text$mn:00004894 ; Attributes: bp-based frame
.text$mn:00004894
.text$mn:00004894 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00004894                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00004894 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00004894                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00004894
.text$mn:00004894 var_4           = dword ptr -4
.text$mn:00004894
.text$mn:00004894                 push    ebp
.text$mn:00004895                 mov     ebp, esp
.text$mn:00004897                 push    ecx
.text$mn:00004898                 mov     [ebp+var_4], ecx
.text$mn:0000489B                 mov     esp, ebp
.text$mn:0000489D                 pop     ebp
.text$mn:0000489E                 retn    4
.text$mn:0000489E ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:0000489E
.text$mn:0000489E ; ---------------------------------------------------------------------------
.text$mn:000048A1                 align 4
.text$mn:000048A1 _text$mn        ends
.text$mn:000048A1
.text$mn:000048A4 ; ===========================================================================
.text$mn:000048A4
.text$mn:000048A4 ; Segment type: Pure code
.text$mn:000048A4 ; Segment permissions: Read/Execute
.text$mn:000048A4 _text$mn        segment para public 'CODE' use32
.text$mn:000048A4                 assume cs:_text$mn
.text$mn:000048A4                 ;org 48A4h
.text$mn:000048A4 ; COMDAT (pick any)
.text$mn:000048A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048A4
.text$mn:000048A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000048A4
.text$mn:000048A4 ; Attributes: bp-based frame
.text$mn:000048A4
.text$mn:000048A4 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000048A4                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000048A4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000048A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000048A4
.text$mn:000048A4 arg_0           = dword ptr  8
.text$mn:000048A4 arg_4           = dword ptr  0Ch
.text$mn:000048A4
.text$mn:000048A4                 push    ebp
.text$mn:000048A5                 mov     ebp, esp
.text$mn:000048A7                 mov     eax, [ebp+arg_4]
.text$mn:000048AA                 push    eax
.text$mn:000048AB                 mov     ecx, [ebp+arg_0]
.text$mn:000048AE                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000048B3                 pop     ebp
.text$mn:000048B4                 retn
.text$mn:000048B4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000048B4
.text$mn:000048B4 ; ---------------------------------------------------------------------------
.text$mn:000048B5                 align 4
.text$mn:000048B5 _text$mn        ends
.text$mn:000048B5
.text$mn:000048B8 ; ===========================================================================
.text$mn:000048B8
.text$mn:000048B8 ; Segment type: Pure code
.text$mn:000048B8 ; Segment permissions: Read/Execute
.text$mn:000048B8 _text$mn        segment para public 'CODE' use32
.text$mn:000048B8                 assume cs:_text$mn
.text$mn:000048B8                 ;org 48B8h
.text$mn:000048B8 ; COMDAT (pick any)
.text$mn:000048B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048B8
.text$mn:000048B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048B8
.text$mn:000048B8 ; Attributes: bp-based frame
.text$mn:000048B8
.text$mn:000048B8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000048B8                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:000048B8 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:000048B8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:000048B8
.text$mn:000048B8 var_4           = dword ptr -4
.text$mn:000048B8 arg_0           = dword ptr  8
.text$mn:000048B8
.text$mn:000048B8                 push    ebp
.text$mn:000048B9                 mov     ebp, esp
.text$mn:000048BB                 push    ecx
.text$mn:000048BC                 mov     [ebp+var_4], ecx
.text$mn:000048BF                 mov     eax, [ebp+arg_0]
.text$mn:000048C2                 push    eax
.text$mn:000048C3                 mov     ecx, [ebp+var_4]
.text$mn:000048C6                 push    ecx
.text$mn:000048C7                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:000048CC                 add     esp, 8
.text$mn:000048CF                 mov     esp, ebp
.text$mn:000048D1                 pop     ebp
.text$mn:000048D2                 retn    4
.text$mn:000048D2 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:000048D2
.text$mn:000048D2 ; ---------------------------------------------------------------------------
.text$mn:000048D5                 align 4
.text$mn:000048D5 _text$mn        ends
.text$mn:000048D5
.text$mn:000048D8 ; ===========================================================================
.text$mn:000048D8
.text$mn:000048D8 ; Segment type: Pure code
.text$mn:000048D8 ; Segment permissions: Read/Execute
.text$mn:000048D8 _text$mn        segment para public 'CODE' use32
.text$mn:000048D8                 assume cs:_text$mn
.text$mn:000048D8                 ;org 48D8h
.text$mn:000048D8 ; COMDAT (pick any)
.text$mn:000048D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048D8
.text$mn:000048D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048D8
.text$mn:000048D8 ; Attributes: bp-based frame
.text$mn:000048D8
.text$mn:000048D8 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000048D8                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:000048D8 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:000048D8                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:000048D8
.text$mn:000048D8 var_4           = dword ptr -4
.text$mn:000048D8
.text$mn:000048D8                 push    ebp
.text$mn:000048D9                 mov     ebp, esp
.text$mn:000048DB                 push    ecx
.text$mn:000048DC                 mov     [ebp+var_4], ecx
.text$mn:000048DF                 mov     esp, ebp
.text$mn:000048E1                 pop     ebp
.text$mn:000048E2                 retn    4
.text$mn:000048E2 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:000048E2
.text$mn:000048E2 ; ---------------------------------------------------------------------------
.text$mn:000048E5                 align 4
.text$mn:000048E5 _text$mn        ends
.text$mn:000048E5
.text$mn:000048E8 ; ===========================================================================
.text$mn:000048E8
.text$mn:000048E8 ; Segment type: Pure code
.text$mn:000048E8 ; Segment permissions: Read/Execute
.text$mn:000048E8 _text$mn        segment para public 'CODE' use32
.text$mn:000048E8                 assume cs:_text$mn
.text$mn:000048E8                 ;org 48E8h
.text$mn:000048E8 ; COMDAT (pick any)
.text$mn:000048E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048E8
.text$mn:000048E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048E8
.text$mn:000048E8 ; Attributes: bp-based frame
.text$mn:000048E8
.text$mn:000048E8 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:000048E8                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:000048E8 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:000048E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:000048E8
.text$mn:000048E8 arg_0           = dword ptr  8
.text$mn:000048E8 arg_4           = dword ptr  0Ch
.text$mn:000048E8
.text$mn:000048E8                 push    ebp
.text$mn:000048E9                 mov     ebp, esp
.text$mn:000048EB                 mov     eax, [ebp+arg_4]
.text$mn:000048EE                 push    eax
.text$mn:000048EF                 mov     ecx, [ebp+arg_0]
.text$mn:000048F2                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000048F7                 pop     ebp
.text$mn:000048F8                 retn
.text$mn:000048F8 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:000048F8
.text$mn:000048F8 ; ---------------------------------------------------------------------------
.text$mn:000048F9                 align 4
.text$mn:000048F9 _text$mn        ends
.text$mn:000048F9
.text$mn:000048FC ; ===========================================================================
.text$mn:000048FC
.text$mn:000048FC ; Segment type: Pure code
.text$mn:000048FC ; Segment permissions: Read/Execute
.text$mn:000048FC _text$mn        segment para public 'CODE' use32
.text$mn:000048FC                 assume cs:_text$mn
.text$mn:000048FC                 ;org 48FCh
.text$mn:000048FC ; COMDAT (pick any)
.text$mn:000048FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048FC
.text$mn:000048FC ; =============== S U B R O U T I N E =======================================
.text$mn:000048FC
.text$mn:000048FC ; Attributes: bp-based frame
.text$mn:000048FC
.text$mn:000048FC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>>::destroy<struct ColumnModeInfo>(struct ColumnModeInfo *)
.text$mn:000048FC                 public ??$destroy@UColumnModeInfo@@@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@@Z
.text$mn:000048FC ??$destroy@UColumnModeInfo@@@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@@Z proc near
.text$mn:000048FC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:000048FC
.text$mn:000048FC var_4           = dword ptr -4
.text$mn:000048FC arg_0           = dword ptr  8
.text$mn:000048FC
.text$mn:000048FC                 push    ebp
.text$mn:000048FD                 mov     ebp, esp
.text$mn:000048FF                 push    ecx
.text$mn:00004900                 mov     [ebp+var_4], ecx
.text$mn:00004903                 mov     eax, [ebp+arg_0]
.text$mn:00004906                 push    eax
.text$mn:00004907                 mov     ecx, [ebp+var_4]
.text$mn:0000490A                 push    ecx
.text$mn:0000490B                 call    ??$destroy@UColumnModeInfo@@@?$allocator_traits@V?$allocator@UColumnModeInfo@@@std@@@std@@SAXAAV?$allocator@UColumnModeInfo@@@1@PAUColumnModeInfo@@@Z ; std::allocator_traits<std::allocator<ColumnModeInfo>>::destroy<ColumnModeInfo>(std::allocator<ColumnModeInfo> &,ColumnModeInfo *)
.text$mn:00004910                 add     esp, 8
.text$mn:00004913                 mov     esp, ebp
.text$mn:00004915                 pop     ebp
.text$mn:00004916                 retn    4
.text$mn:00004916 ??$destroy@UColumnModeInfo@@@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@@Z endp
.text$mn:00004916
.text$mn:00004916 ; ---------------------------------------------------------------------------
.text$mn:00004919                 align 4
.text$mn:00004919 _text$mn        ends
.text$mn:00004919
.text$mn:0000491C ; ===========================================================================
.text$mn:0000491C
.text$mn:0000491C ; Segment type: Pure code
.text$mn:0000491C ; Segment permissions: Read/Execute
.text$mn:0000491C _text$mn        segment para public 'CODE' use32
.text$mn:0000491C                 assume cs:_text$mn
.text$mn:0000491C                 ;org 491Ch
.text$mn:0000491C ; COMDAT (pick any)
.text$mn:0000491C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000491C
.text$mn:0000491C ; =============== S U B R O U T I N E =======================================
.text$mn:0000491C
.text$mn:0000491C ; Attributes: bp-based frame
.text$mn:0000491C
.text$mn:0000491C ; public: void __thiscall std::allocator<struct ColumnModeInfo>::destroy<struct ColumnModeInfo>(struct ColumnModeInfo *)
.text$mn:0000491C                 public ??$destroy@UColumnModeInfo@@@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@@Z
.text$mn:0000491C ??$destroy@UColumnModeInfo@@@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@@Z proc near
.text$mn:0000491C                                         ; CODE XREF: std::allocator_traits<std::allocator<ColumnModeInfo>>::destroy<ColumnModeInfo>(std::allocator<ColumnModeInfo> &,ColumnModeInfo *)+Ap
.text$mn:0000491C
.text$mn:0000491C var_4           = dword ptr -4
.text$mn:0000491C
.text$mn:0000491C                 push    ebp
.text$mn:0000491D                 mov     ebp, esp
.text$mn:0000491F                 push    ecx
.text$mn:00004920                 mov     [ebp+var_4], ecx
.text$mn:00004923                 mov     esp, ebp
.text$mn:00004925                 pop     ebp
.text$mn:00004926                 retn    4
.text$mn:00004926 ??$destroy@UColumnModeInfo@@@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@@Z endp
.text$mn:00004926
.text$mn:00004926 ; ---------------------------------------------------------------------------
.text$mn:00004929                 align 4
.text$mn:00004929 _text$mn        ends
.text$mn:00004929
.text$mn:0000492C ; ===========================================================================
.text$mn:0000492C
.text$mn:0000492C ; Segment type: Pure code
.text$mn:0000492C ; Segment permissions: Read/Execute
.text$mn:0000492C _text$mn        segment para public 'CODE' use32
.text$mn:0000492C                 assume cs:_text$mn
.text$mn:0000492C                 ;org 492Ch
.text$mn:0000492C ; COMDAT (pick any)
.text$mn:0000492C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000492C
.text$mn:0000492C ; =============== S U B R O U T I N E =======================================
.text$mn:0000492C
.text$mn:0000492C ; Attributes: bp-based frame
.text$mn:0000492C
.text$mn:0000492C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct ColumnModeInfo>>::destroy<struct ColumnModeInfo>(class std::allocator<struct ColumnModeInfo> &, struct ColumnModeInfo *)
.text$mn:0000492C                 public ??$destroy@UColumnModeInfo@@@?$allocator_traits@V?$allocator@UColumnModeInfo@@@std@@@std@@SAXAAV?$allocator@UColumnModeInfo@@@1@PAUColumnModeInfo@@@Z
.text$mn:0000492C ??$destroy@UColumnModeInfo@@@?$allocator_traits@V?$allocator@UColumnModeInfo@@@std@@@std@@SAXAAV?$allocator@UColumnModeInfo@@@1@PAUColumnModeInfo@@@Z proc near
.text$mn:0000492C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ColumnModeInfo>>::destroy<ColumnModeInfo>(ColumnModeInfo *)+Fp
.text$mn:0000492C
.text$mn:0000492C arg_0           = dword ptr  8
.text$mn:0000492C arg_4           = dword ptr  0Ch
.text$mn:0000492C
.text$mn:0000492C                 push    ebp
.text$mn:0000492D                 mov     ebp, esp
.text$mn:0000492F                 mov     eax, [ebp+arg_4]
.text$mn:00004932                 push    eax
.text$mn:00004933                 mov     ecx, [ebp+arg_0]
.text$mn:00004936                 call    ??$destroy@UColumnModeInfo@@@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@@Z ; std::allocator<ColumnModeInfo>::destroy<ColumnModeInfo>(ColumnModeInfo *)
.text$mn:0000493B                 pop     ebp
.text$mn:0000493C                 retn
.text$mn:0000493C ??$destroy@UColumnModeInfo@@@?$allocator_traits@V?$allocator@UColumnModeInfo@@@std@@@std@@SAXAAV?$allocator@UColumnModeInfo@@@1@PAUColumnModeInfo@@@Z endp
.text$mn:0000493C
.text$mn:0000493C ; ---------------------------------------------------------------------------
.text$mn:0000493D                 align 10h
.text$mn:0000493D _text$mn        ends
.text$mn:0000493D
.text$mn:00004940 ; ===========================================================================
.text$mn:00004940
.text$mn:00004940 ; Segment type: Pure code
.text$mn:00004940 ; Segment permissions: Read/Execute
.text$mn:00004940 _text$mn        segment para public 'CODE' use32
.text$mn:00004940                 assume cs:_text$mn
.text$mn:00004940                 ;org 4940h
.text$mn:00004940 ; COMDAT (pick any)
.text$mn:00004940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004940
.text$mn:00004940 ; =============== S U B R O U T I N E =======================================
.text$mn:00004940
.text$mn:00004940 ; Attributes: bp-based frame
.text$mn:00004940
.text$mn:00004940 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00004940                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00004940 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00004940                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)+22p
.text$mn:00004940                                         ; std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::_Free_proxy(void)+22p
.text$mn:00004940
.text$mn:00004940 var_4           = dword ptr -4
.text$mn:00004940 arg_0           = dword ptr  8
.text$mn:00004940
.text$mn:00004940                 push    ebp
.text$mn:00004941                 mov     ebp, esp
.text$mn:00004943                 push    ecx
.text$mn:00004944                 mov     [ebp+var_4], ecx
.text$mn:00004947                 mov     eax, [ebp+arg_0]
.text$mn:0000494A                 push    eax
.text$mn:0000494B                 mov     ecx, [ebp+var_4]
.text$mn:0000494E                 push    ecx
.text$mn:0000494F                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00004954                 add     esp, 8
.text$mn:00004957                 mov     esp, ebp
.text$mn:00004959                 pop     ebp
.text$mn:0000495A                 retn    4
.text$mn:0000495A ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000495A
.text$mn:0000495A ; ---------------------------------------------------------------------------
.text$mn:0000495D                 align 10h
.text$mn:0000495D _text$mn        ends
.text$mn:0000495D
.text$mn:00004960 ; ===========================================================================
.text$mn:00004960
.text$mn:00004960 ; Segment type: Pure code
.text$mn:00004960 ; Segment permissions: Read/Execute
.text$mn:00004960 _text$mn        segment para public 'CODE' use32
.text$mn:00004960                 assume cs:_text$mn
.text$mn:00004960                 ;org 4960h
.text$mn:00004960 ; COMDAT (pick any)
.text$mn:00004960                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004960
.text$mn:00004960 ; =============== S U B R O U T I N E =======================================
.text$mn:00004960
.text$mn:00004960 ; Attributes: bp-based frame
.text$mn:00004960
.text$mn:00004960 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00004960                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00004960 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00004960                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00004960                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00004960
.text$mn:00004960 var_4           = dword ptr -4
.text$mn:00004960
.text$mn:00004960                 push    ebp
.text$mn:00004961                 mov     ebp, esp
.text$mn:00004963                 push    ecx
.text$mn:00004964                 mov     [ebp+var_4], ecx
.text$mn:00004967                 mov     esp, ebp
.text$mn:00004969                 pop     ebp
.text$mn:0000496A                 retn    4
.text$mn:0000496A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000496A
.text$mn:0000496A ; ---------------------------------------------------------------------------
.text$mn:0000496D                 align 10h
.text$mn:0000496D _text$mn        ends
.text$mn:0000496D
.text$mn:00004970 ; ===========================================================================
.text$mn:00004970
.text$mn:00004970 ; Segment type: Pure code
.text$mn:00004970 ; Segment permissions: Read/Execute
.text$mn:00004970 _text$mn        segment para public 'CODE' use32
.text$mn:00004970                 assume cs:_text$mn
.text$mn:00004970                 ;org 4970h
.text$mn:00004970 ; COMDAT (pick any)
.text$mn:00004970                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004970
.text$mn:00004970 ; =============== S U B R O U T I N E =======================================
.text$mn:00004970
.text$mn:00004970 ; Attributes: bp-based frame
.text$mn:00004970
.text$mn:00004970 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00004970                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00004970 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00004970                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00004970
.text$mn:00004970 arg_0           = dword ptr  8
.text$mn:00004970 arg_4           = dword ptr  0Ch
.text$mn:00004970
.text$mn:00004970                 push    ebp
.text$mn:00004971                 mov     ebp, esp
.text$mn:00004973                 mov     eax, [ebp+arg_4]
.text$mn:00004976                 push    eax
.text$mn:00004977                 mov     ecx, [ebp+arg_0]
.text$mn:0000497A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000497F                 pop     ebp
.text$mn:00004980                 retn
.text$mn:00004980 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00004980
.text$mn:00004980 ; ---------------------------------------------------------------------------
.text$mn:00004981                 align 4
.text$mn:00004981 _text$mn        ends
.text$mn:00004981
.text$mn:00004984 ; ===========================================================================
.text$mn:00004984
.text$mn:00004984 ; Segment type: Pure code
.text$mn:00004984 ; Segment permissions: Read/Execute
.text$mn:00004984 _text$mn        segment para public 'CODE' use32
.text$mn:00004984                 assume cs:_text$mn
.text$mn:00004984                 ;org 4984h
.text$mn:00004984 ; COMDAT (pick any)
.text$mn:00004984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004984
.text$mn:00004984 ; =============== S U B R O U T I N E =======================================
.text$mn:00004984
.text$mn:00004984 ; Attributes: bp-based frame
.text$mn:00004984
.text$mn:00004984 ; int & __cdecl std::forward<int &>(int &)
.text$mn:00004984                 public ??$forward@AAH@std@@YAAAHAAH@Z
.text$mn:00004984 ??$forward@AAH@std@@YAAAHAAH@Z proc near
.text$mn:00004984                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)+Bp
.text$mn:00004984                                         ; std::allocator<int>::construct<int,int &>(int *,int &)+4Ap ...
.text$mn:00004984
.text$mn:00004984 arg_0           = dword ptr  8
.text$mn:00004984
.text$mn:00004984                 push    ebp
.text$mn:00004985                 mov     ebp, esp
.text$mn:00004987                 mov     eax, [ebp+arg_0]
.text$mn:0000498A                 pop     ebp
.text$mn:0000498B                 retn
.text$mn:0000498B ??$forward@AAH@std@@YAAAHAAH@Z endp
.text$mn:0000498B
.text$mn:0000498B _text$mn        ends
.text$mn:0000498B
.text$mn:0000498C ; ===========================================================================
.text$mn:0000498C
.text$mn:0000498C ; Segment type: Pure code
.text$mn:0000498C ; Segment permissions: Read/Execute
.text$mn:0000498C _text$mn        segment para public 'CODE' use32
.text$mn:0000498C                 assume cs:_text$mn
.text$mn:0000498C                 ;org 498Ch
.text$mn:0000498C ; COMDAT (pick any)
.text$mn:0000498C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000498C
.text$mn:0000498C ; =============== S U B R O U T I N E =======================================
.text$mn:0000498C
.text$mn:0000498C ; Attributes: bp-based frame
.text$mn:0000498C
.text$mn:0000498C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:0000498C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:0000498C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:0000498C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:0000498C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:0000498C
.text$mn:0000498C arg_0           = dword ptr  8
.text$mn:0000498C
.text$mn:0000498C                 push    ebp
.text$mn:0000498D                 mov     ebp, esp
.text$mn:0000498F                 mov     eax, [ebp+arg_0]
.text$mn:00004992                 pop     ebp
.text$mn:00004993                 retn
.text$mn:00004993 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00004993
.text$mn:00004993 _text$mn        ends
.text$mn:00004993
.text$mn:00004994 ; ===========================================================================
.text$mn:00004994
.text$mn:00004994 ; Segment type: Pure code
.text$mn:00004994 ; Segment permissions: Read/Execute
.text$mn:00004994 _text$mn        segment para public 'CODE' use32
.text$mn:00004994                 assume cs:_text$mn
.text$mn:00004994                 ;org 4994h
.text$mn:00004994 ; COMDAT (pick any)
.text$mn:00004994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004994
.text$mn:00004994 ; =============== S U B R O U T I N E =======================================
.text$mn:00004994
.text$mn:00004994 ; Attributes: bp-based frame
.text$mn:00004994
.text$mn:00004994 ; struct ColumnModeInfo * & __cdecl std::forward<struct ColumnModeInfo * &>(struct ColumnModeInfo * &)
.text$mn:00004994                 public ??$forward@AAPAUColumnModeInfo@@@std@@YAAAPAUColumnModeInfo@@AAPAU1@@Z
.text$mn:00004994 ??$forward@AAPAUColumnModeInfo@@@std@@YAAAPAUColumnModeInfo@@AAPAU1@@Z proc near
.text$mn:00004994                                         ; CODE XREF: std::pair<ColumnModeInfo *,ColumnModeInfo *>::pair<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo * &,ColumnModeInfo * &)+Bp
.text$mn:00004994                                         ; std::pair<ColumnModeInfo *,ColumnModeInfo *>::pair<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo * &,ColumnModeInfo * &)+1Ep
.text$mn:00004994
.text$mn:00004994 arg_0           = dword ptr  8
.text$mn:00004994
.text$mn:00004994                 push    ebp
.text$mn:00004995                 mov     ebp, esp
.text$mn:00004997                 mov     eax, [ebp+arg_0]
.text$mn:0000499A                 pop     ebp
.text$mn:0000499B                 retn
.text$mn:0000499B ??$forward@AAPAUColumnModeInfo@@@std@@YAAAPAUColumnModeInfo@@AAPAU1@@Z endp
.text$mn:0000499B
.text$mn:0000499B _text$mn        ends
.text$mn:0000499B
.text$mn:0000499C ; ===========================================================================
.text$mn:0000499C
.text$mn:0000499C ; Segment type: Pure code
.text$mn:0000499C ; Segment permissions: Read/Execute
.text$mn:0000499C _text$mn        segment para public 'CODE' use32
.text$mn:0000499C                 assume cs:_text$mn
.text$mn:0000499C                 ;org 499Ch
.text$mn:0000499C ; COMDAT (pick any)
.text$mn:0000499C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000499C
.text$mn:0000499C ; =============== S U B R O U T I N E =======================================
.text$mn:0000499C
.text$mn:0000499C ; Attributes: bp-based frame
.text$mn:0000499C
.text$mn:0000499C ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000499C                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:0000499C ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:0000499C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:0000499C                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:0000499C
.text$mn:0000499C arg_0           = dword ptr  8
.text$mn:0000499C
.text$mn:0000499C                 push    ebp
.text$mn:0000499D                 mov     ebp, esp
.text$mn:0000499F                 mov     eax, [ebp+arg_0]
.text$mn:000049A2                 pop     ebp
.text$mn:000049A3                 retn
.text$mn:000049A3 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:000049A3
.text$mn:000049A3 _text$mn        ends
.text$mn:000049A3
.text$mn:000049A4 ; ===========================================================================
.text$mn:000049A4
.text$mn:000049A4 ; Segment type: Pure code
.text$mn:000049A4 ; Segment permissions: Read/Execute
.text$mn:000049A4 _text$mn        segment para public 'CODE' use32
.text$mn:000049A4                 assume cs:_text$mn
.text$mn:000049A4                 ;org 49A4h
.text$mn:000049A4 ; COMDAT (pick any)
.text$mn:000049A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049A4
.text$mn:000049A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000049A4
.text$mn:000049A4 ; Attributes: bp-based frame
.text$mn:000049A4
.text$mn:000049A4 ; struct ColumnModeInfo & __cdecl std::forward<struct ColumnModeInfo &>(struct ColumnModeInfo &)
.text$mn:000049A4                 public ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z
.text$mn:000049A4 ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z proc near
.text$mn:000049A4                                         ; CODE XREF: std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+7p
.text$mn:000049A4                                         ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+14p ...
.text$mn:000049A4
.text$mn:000049A4 arg_0           = dword ptr  8
.text$mn:000049A4
.text$mn:000049A4                 push    ebp
.text$mn:000049A5                 mov     ebp, esp
.text$mn:000049A7                 mov     eax, [ebp+arg_0]
.text$mn:000049AA                 pop     ebp
.text$mn:000049AB                 retn
.text$mn:000049AB ??$forward@AAUColumnModeInfo@@@std@@YAAAUColumnModeInfo@@AAU1@@Z endp
.text$mn:000049AB
.text$mn:000049AB _text$mn        ends
.text$mn:000049AB
.text$mn:000049AC ; ===========================================================================
.text$mn:000049AC
.text$mn:000049AC ; Segment type: Pure code
.text$mn:000049AC ; Segment permissions: Read/Execute
.text$mn:000049AC _text$mn        segment para public 'CODE' use32
.text$mn:000049AC                 assume cs:_text$mn
.text$mn:000049AC                 ;org 49ACh
.text$mn:000049AC ; COMDAT (pick any)
.text$mn:000049AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049AC
.text$mn:000049AC ; =============== S U B R O U T I N E =======================================
.text$mn:000049AC
.text$mn:000049AC ; Attributes: bp-based frame
.text$mn:000049AC
.text$mn:000049AC ; int const & __cdecl std::forward<int const &>(int const &)
.text$mn:000049AC                 public ??$forward@ABH@std@@YAABHABH@Z
.text$mn:000049AC ??$forward@ABH@std@@YAABHABH@Z proc near
.text$mn:000049AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)+Bp
.text$mn:000049AC                                         ; std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)+7p
.text$mn:000049AC
.text$mn:000049AC arg_0           = dword ptr  8
.text$mn:000049AC
.text$mn:000049AC                 push    ebp
.text$mn:000049AD                 mov     ebp, esp
.text$mn:000049AF                 mov     eax, [ebp+arg_0]
.text$mn:000049B2                 pop     ebp
.text$mn:000049B3                 retn
.text$mn:000049B3 ??$forward@ABH@std@@YAABHABH@Z endp
.text$mn:000049B3
.text$mn:000049B3 _text$mn        ends
.text$mn:000049B3
.text$mn:000049B4 ; ===========================================================================
.text$mn:000049B4
.text$mn:000049B4 ; Segment type: Pure code
.text$mn:000049B4 ; Segment permissions: Read/Execute
.text$mn:000049B4 _text$mn        segment para public 'CODE' use32
.text$mn:000049B4                 assume cs:_text$mn
.text$mn:000049B4                 ;org 49B4h
.text$mn:000049B4 ; COMDAT (pick any)
.text$mn:000049B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049B4
.text$mn:000049B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000049B4
.text$mn:000049B4 ; Attributes: bp-based frame
.text$mn:000049B4
.text$mn:000049B4 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000049B4                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000049B4 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000049B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:000049B4                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:000049B4
.text$mn:000049B4 arg_0           = dword ptr  8
.text$mn:000049B4
.text$mn:000049B4                 push    ebp
.text$mn:000049B5                 mov     ebp, esp
.text$mn:000049B7                 mov     eax, [ebp+arg_0]
.text$mn:000049BA                 pop     ebp
.text$mn:000049BB                 retn
.text$mn:000049BB ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000049BB
.text$mn:000049BB _text$mn        ends
.text$mn:000049BB
.text$mn:000049BC ; ===========================================================================
.text$mn:000049BC
.text$mn:000049BC ; Segment type: Pure code
.text$mn:000049BC ; Segment permissions: Read/Execute
.text$mn:000049BC _text$mn        segment para public 'CODE' use32
.text$mn:000049BC                 assume cs:_text$mn
.text$mn:000049BC                 ;org 49BCh
.text$mn:000049BC ; COMDAT (pick any)
.text$mn:000049BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049BC
.text$mn:000049BC ; =============== S U B R O U T I N E =======================================
.text$mn:000049BC
.text$mn:000049BC ; Attributes: bp-based frame
.text$mn:000049BC
.text$mn:000049BC ; void __cdecl std::iter_swap<struct ColumnModeInfo *, struct ColumnModeInfo *>(struct ColumnModeInfo *, struct ColumnModeInfo *)
.text$mn:000049BC                 public ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z
.text$mn:000049BC ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z proc near
.text$mn:000049BC                                         ; CODE XREF: std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+31p
.text$mn:000049BC                                         ; std::_Med3<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+67p ...
.text$mn:000049BC
.text$mn:000049BC arg_0           = dword ptr  8
.text$mn:000049BC arg_4           = dword ptr  0Ch
.text$mn:000049BC
.text$mn:000049BC                 push    ebp
.text$mn:000049BD                 mov     ebp, esp
.text$mn:000049BF                 mov     eax, [ebp+arg_4]
.text$mn:000049C2                 push    eax
.text$mn:000049C3                 mov     ecx, [ebp+arg_0]
.text$mn:000049C6                 push    ecx
.text$mn:000049C7                 call    ??$swap@UColumnModeInfo@@@std@@YAXAAUColumnModeInfo@@0@Z ; std::swap<ColumnModeInfo>(ColumnModeInfo &,ColumnModeInfo &)
.text$mn:000049CC                 add     esp, 8
.text$mn:000049CF                 pop     ebp
.text$mn:000049D0                 retn
.text$mn:000049D0 ??$iter_swap@PAUColumnModeInfo@@PAU1@@std@@YAXPAUColumnModeInfo@@0@Z endp
.text$mn:000049D0
.text$mn:000049D0 ; ---------------------------------------------------------------------------
.text$mn:000049D1                 align 4
.text$mn:000049D1 _text$mn        ends
.text$mn:000049D1
.text$mn:000049D4 ; ===========================================================================
.text$mn:000049D4
.text$mn:000049D4 ; Segment type: Pure code
.text$mn:000049D4 ; Segment permissions: Read/Execute
.text$mn:000049D4 _text$mn        segment para public 'CODE' use32
.text$mn:000049D4                 assume cs:_text$mn
.text$mn:000049D4                 ;org 49D4h
.text$mn:000049D4 ; COMDAT (pick any)
.text$mn:000049D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049D4
.text$mn:000049D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000049D4
.text$mn:000049D4 ; Attributes: bp-based frame
.text$mn:000049D4
.text$mn:000049D4 ; void __cdecl std::make_heap<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:000049D4                 public ??$make_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z
.text$mn:000049D4 ??$make_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z proc near
.text$mn:000049D4                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+D8p
.text$mn:000049D4
.text$mn:000049D4 arg_0           = dword ptr  8
.text$mn:000049D4 arg_4           = dword ptr  0Ch
.text$mn:000049D4 arg_8           = byte ptr  10h
.text$mn:000049D4
.text$mn:000049D4                 push    ebp
.text$mn:000049D5                 mov     ebp, esp
.text$mn:000049D7                 push    999h            ; unsigned int
.text$mn:000049DC                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000049E1                 mov     eax, [ebp+arg_4]
.text$mn:000049E4                 push    eax             ; int
.text$mn:000049E5                 mov     ecx, [ebp+arg_0]
.text$mn:000049E8                 push    ecx             ; int
.text$mn:000049E9                 call    ??$_Debug_range@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WI@Z ; std::_Debug_range<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint)
.text$mn:000049EE                 add     esp, 10h
.text$mn:000049F1                 push    99Ah
.text$mn:000049F6                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000049FB                 lea     edx, [ebp+arg_8]
.text$mn:000049FE                 push    edx
.text$mn:000049FF                 call    ??$_Debug_pointer@USortInPositionOrder@@@std@@YAXAAUSortInPositionOrder@@PB_WI@Z ; std::_Debug_pointer<SortInPositionOrder>(SortInPositionOrder &,wchar_t const *,uint)
.text$mn:00004A04                 add     esp, 0Ch
.text$mn:00004A07                 mov     eax, [ebp+arg_4]
.text$mn:00004A0A                 sub     eax, [ebp+arg_0]
.text$mn:00004A0D                 cdq
.text$mn:00004A0E                 mov     ecx, 18h
.text$mn:00004A13                 idiv    ecx
.text$mn:00004A15                 cmp     eax, 1
.text$mn:00004A18                 jle     short loc_4A5B
.text$mn:00004A1A                 mov     edx, [ebp+arg_0]
.text$mn:00004A1D                 push    edx
.text$mn:00004A1E                 call    ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Val_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004A23                 add     esp, 4
.text$mn:00004A26                 push    eax
.text$mn:00004A27                 mov     eax, [ebp+arg_0]
.text$mn:00004A2A                 push    eax
.text$mn:00004A2B                 call    ??$_Dist_type@PAUColumnModeInfo@@@std@@YAPAHPAUColumnModeInfo@@@Z ; std::_Dist_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004A30                 add     esp, 4
.text$mn:00004A33                 push    eax
.text$mn:00004A34                 movzx   ecx, [ebp+arg_8]
.text$mn:00004A38                 push    ecx
.text$mn:00004A39                 mov     edx, [ebp+arg_4]
.text$mn:00004A3C                 push    edx
.text$mn:00004A3D                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004A42                 add     esp, 4
.text$mn:00004A45                 push    eax
.text$mn:00004A46                 mov     eax, [ebp+arg_0]
.text$mn:00004A49                 push    eax
.text$mn:00004A4A                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004A4F                 add     esp, 4
.text$mn:00004A52                 push    eax
.text$mn:00004A53                 call    ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@PAH0@Z ; std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder,int *,ColumnModeInfo *)
.text$mn:00004A58                 add     esp, 14h
.text$mn:00004A5B
.text$mn:00004A5B loc_4A5B:                               ; CODE XREF: std::make_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+44j
.text$mn:00004A5B                 pop     ebp
.text$mn:00004A5C                 retn
.text$mn:00004A5C ??$make_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z endp
.text$mn:00004A5C
.text$mn:00004A5C ; ---------------------------------------------------------------------------
.text$mn:00004A5D                 align 10h
.text$mn:00004A5D _text$mn        ends
.text$mn:00004A5D
.text$mn:00004A60 ; ===========================================================================
.text$mn:00004A60
.text$mn:00004A60 ; Segment type: Pure code
.text$mn:00004A60 ; Segment permissions: Read/Execute
.text$mn:00004A60 _text$mn        segment para public 'CODE' use32
.text$mn:00004A60                 assume cs:_text$mn
.text$mn:00004A60                 ;org 4A60h
.text$mn:00004A60 ; COMDAT (pick any)
.text$mn:00004A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A60
.text$mn:00004A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A60
.text$mn:00004A60 ; Attributes: bp-based frame
.text$mn:00004A60
.text$mn:00004A60 ; void __cdecl std::make_heap<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:00004A60                 public ??$make_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z
.text$mn:00004A60 ??$make_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z proc near
.text$mn:00004A60                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+D8p
.text$mn:00004A60
.text$mn:00004A60 arg_0           = dword ptr  8
.text$mn:00004A60 arg_4           = dword ptr  0Ch
.text$mn:00004A60 arg_8           = byte ptr  10h
.text$mn:00004A60
.text$mn:00004A60                 push    ebp
.text$mn:00004A61                 mov     ebp, esp
.text$mn:00004A63                 push    999h            ; unsigned int
.text$mn:00004A68                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004A6D                 mov     eax, [ebp+arg_4]
.text$mn:00004A70                 push    eax             ; int
.text$mn:00004A71                 mov     ecx, [ebp+arg_0]
.text$mn:00004A74                 push    ecx             ; int
.text$mn:00004A75                 call    ??$_Debug_range@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WI@Z ; std::_Debug_range<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint)
.text$mn:00004A7A                 add     esp, 10h
.text$mn:00004A7D                 push    99Ah
.text$mn:00004A82                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004A87                 lea     edx, [ebp+arg_8]
.text$mn:00004A8A                 push    edx
.text$mn:00004A8B                 call    ??$_Debug_pointer@USortInSelectOrder@@@std@@YAXAAUSortInSelectOrder@@PB_WI@Z ; std::_Debug_pointer<SortInSelectOrder>(SortInSelectOrder &,wchar_t const *,uint)
.text$mn:00004A90                 add     esp, 0Ch
.text$mn:00004A93                 mov     eax, [ebp+arg_4]
.text$mn:00004A96                 sub     eax, [ebp+arg_0]
.text$mn:00004A99                 cdq
.text$mn:00004A9A                 mov     ecx, 18h
.text$mn:00004A9F                 idiv    ecx
.text$mn:00004AA1                 cmp     eax, 1
.text$mn:00004AA4                 jle     short loc_4AE7
.text$mn:00004AA6                 mov     edx, [ebp+arg_0]
.text$mn:00004AA9                 push    edx
.text$mn:00004AAA                 call    ??$_Val_type@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Val_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004AAF                 add     esp, 4
.text$mn:00004AB2                 push    eax
.text$mn:00004AB3                 mov     eax, [ebp+arg_0]
.text$mn:00004AB6                 push    eax
.text$mn:00004AB7                 call    ??$_Dist_type@PAUColumnModeInfo@@@std@@YAPAHPAUColumnModeInfo@@@Z ; std::_Dist_type<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004ABC                 add     esp, 4
.text$mn:00004ABF                 push    eax
.text$mn:00004AC0                 movzx   ecx, [ebp+arg_8]
.text$mn:00004AC4                 push    ecx
.text$mn:00004AC5                 mov     edx, [ebp+arg_4]
.text$mn:00004AC8                 push    edx
.text$mn:00004AC9                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004ACE                 add     esp, 4
.text$mn:00004AD1                 push    eax
.text$mn:00004AD2                 mov     eax, [ebp+arg_0]
.text$mn:00004AD5                 push    eax
.text$mn:00004AD6                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004ADB                 add     esp, 4
.text$mn:00004ADE                 push    eax
.text$mn:00004ADF                 call    ??$_Make_heap@PAUColumnModeInfo@@HU1@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@PAH0@Z ; std::_Make_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder,int *,ColumnModeInfo *)
.text$mn:00004AE4                 add     esp, 14h
.text$mn:00004AE7
.text$mn:00004AE7 loc_4AE7:                               ; CODE XREF: std::make_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)+44j
.text$mn:00004AE7                 pop     ebp
.text$mn:00004AE8                 retn
.text$mn:00004AE8 ??$make_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z endp
.text$mn:00004AE8
.text$mn:00004AE8 ; ---------------------------------------------------------------------------
.text$mn:00004AE9                 align 4
.text$mn:00004AE9 _text$mn        ends
.text$mn:00004AE9
.text$mn:00004AEC ; ===========================================================================
.text$mn:00004AEC
.text$mn:00004AEC ; Segment type: Pure code
.text$mn:00004AEC ; Segment permissions: Read/Execute
.text$mn:00004AEC _text$mn        segment para public 'CODE' use32
.text$mn:00004AEC                 assume cs:_text$mn
.text$mn:00004AEC                 ;org 4AECh
.text$mn:00004AEC ; COMDAT (pick any)
.text$mn:00004AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AEC
.text$mn:00004AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00004AEC
.text$mn:00004AEC ; Attributes: bp-based frame
.text$mn:00004AEC
.text$mn:00004AEC ; struct ColumnModeInfo && __cdecl std::move<struct ColumnModeInfo &>(struct ColumnModeInfo &)
.text$mn:00004AEC                 public ??$move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z
.text$mn:00004AEC ??$move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z proc near
.text$mn:00004AEC                                         ; CODE XREF: std::_Move_backward<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,ColumnModeInfo *,std::_Nonscalar_ptr_iterator_tag)+21p
.text$mn:00004AEC
.text$mn:00004AEC arg_0           = dword ptr  8
.text$mn:00004AEC
.text$mn:00004AEC                 push    ebp
.text$mn:00004AED                 mov     ebp, esp
.text$mn:00004AEF                 mov     eax, [ebp+arg_0]
.text$mn:00004AF2                 pop     ebp
.text$mn:00004AF3                 retn
.text$mn:00004AF3 ??$move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z endp
.text$mn:00004AF3
.text$mn:00004AF3 _text$mn        ends
.text$mn:00004AF3
.text$mn:00004AF4 ; ===========================================================================
.text$mn:00004AF4
.text$mn:00004AF4 ; Segment type: Pure code
.text$mn:00004AF4 ; Segment permissions: Read/Execute
.text$mn:00004AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AF4                 assume cs:_text$mn
.text$mn:00004AF4                 ;org 4AF4h
.text$mn:00004AF4 ; COMDAT (pick any)
.text$mn:00004AF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AF4
.text$mn:00004AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AF4
.text$mn:00004AF4 ; Attributes: bp-based frame
.text$mn:00004AF4
.text$mn:00004AF4 ; void __cdecl std::sort<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>, struct SortInPositionOrder>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>, struct SortInPositionOrder)
.text$mn:00004AF4                 public ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z
.text$mn:00004AF4 ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z proc near
.text$mn:00004AF4                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+294p
.text$mn:00004AF4                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+7C7p
.text$mn:00004AF4
.text$mn:00004AF4 var_44          = dword ptr -44h
.text$mn:00004AF4 var_40          = dword ptr -40h
.text$mn:00004AF4 var_3C          = dword ptr -3Ch
.text$mn:00004AF4 var_38          = dword ptr -38h
.text$mn:00004AF4 var_34          = dword ptr -34h
.text$mn:00004AF4 var_30          = dword ptr -30h
.text$mn:00004AF4 var_2C          = dword ptr -2Ch
.text$mn:00004AF4 var_28          = dword ptr -28h
.text$mn:00004AF4 var_24          = dword ptr -24h
.text$mn:00004AF4 var_20          = dword ptr -20h
.text$mn:00004AF4 var_1C          = dword ptr -1Ch
.text$mn:00004AF4 var_18          = dword ptr -18h
.text$mn:00004AF4 var_14          = dword ptr -14h
.text$mn:00004AF4 var_10          = dword ptr -10h
.text$mn:00004AF4 var_C           = dword ptr -0Ch
.text$mn:00004AF4 var_4           = dword ptr -4
.text$mn:00004AF4 arg_0           = byte ptr  8
.text$mn:00004AF4 arg_C           = dword ptr  14h
.text$mn:00004AF4 arg_18          = byte ptr  20h
.text$mn:00004AF4
.text$mn:00004AF4                 push    ebp
.text$mn:00004AF5                 mov     ebp, esp
.text$mn:00004AF7                 push    0FFFFFFFFh
.text$mn:00004AF9                 push    offset __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z
.text$mn:00004AFE                 mov     eax, large fs:0
.text$mn:00004B04                 push    eax
.text$mn:00004B05                 sub     esp, 38h
.text$mn:00004B08                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B0D                 xor     eax, ebp
.text$mn:00004B0F                 push    eax
.text$mn:00004B10                 lea     eax, [ebp+var_C]
.text$mn:00004B13                 mov     large fs:0, eax
.text$mn:00004B19                 mov     [ebp+var_4], 1
.text$mn:00004B20                 push    0C53h           ; unsigned int
.text$mn:00004B25                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004B2A                 sub     esp, 0Ch
.text$mn:00004B2D                 mov     ecx, esp
.text$mn:00004B2F                 mov     [ebp+var_28], esp
.text$mn:00004B32                 lea     eax, [ebp+arg_C]
.text$mn:00004B35                 push    eax             ; int
.text$mn:00004B36                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004B3B                 mov     [ebp+var_10], eax
.text$mn:00004B3E                 mov     ecx, [ebp+var_10]
.text$mn:00004B41                 mov     [ebp+var_2C], ecx
.text$mn:00004B44                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004B48                 sub     esp, 0Ch
.text$mn:00004B4B                 mov     ecx, esp
.text$mn:00004B4D                 mov     [ebp+var_30], esp
.text$mn:00004B50                 lea     edx, [ebp+arg_0]
.text$mn:00004B53                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004B54                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004B59                 mov     [ebp+var_14], eax
.text$mn:00004B5C                 mov     eax, [ebp+var_14]
.text$mn:00004B5F                 mov     [ebp+var_34], eax
.text$mn:00004B62                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004B66                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004B6A                 call    ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint)
.text$mn:00004B6F                 add     esp, 20h
.text$mn:00004B72                 push    0C54h
.text$mn:00004B77                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004B7C                 lea     ecx, [ebp+arg_18]
.text$mn:00004B7F                 push    ecx
.text$mn:00004B80                 call    ??$_Debug_pointer@USortInPositionOrder@@@std@@YAXAAUSortInPositionOrder@@PB_WI@Z ; std::_Debug_pointer<SortInPositionOrder>(SortInPositionOrder &,wchar_t const *,uint)
.text$mn:00004B85                 add     esp, 0Ch
.text$mn:00004B88                 movzx   edx, [ebp+arg_18]
.text$mn:00004B8C                 push    edx
.text$mn:00004B8D                 lea     eax, [ebp+arg_0]
.text$mn:00004B90                 push    eax             ; std::_Iterator_base12 *
.text$mn:00004B91                 lea     ecx, [ebp+arg_C]
.text$mn:00004B94                 call    ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004B99                 push    eax
.text$mn:00004B9A                 sub     esp, 0Ch
.text$mn:00004B9D                 mov     ecx, esp
.text$mn:00004B9F                 mov     [ebp+var_38], esp
.text$mn:00004BA2                 lea     edx, [ebp+arg_C]
.text$mn:00004BA5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004BA6                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004BAB                 mov     [ebp+var_18], eax
.text$mn:00004BAE                 mov     eax, [ebp+var_18]
.text$mn:00004BB1                 mov     [ebp+var_3C], eax
.text$mn:00004BB4                 mov     byte ptr [ebp+var_4], 4
.text$mn:00004BB8                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004BBC                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>)
.text$mn:00004BC1                 add     esp, 0Ch
.text$mn:00004BC4                 mov     [ebp+var_1C], eax
.text$mn:00004BC7                 mov     ecx, [ebp+var_1C]
.text$mn:00004BCA                 push    ecx
.text$mn:00004BCB                 sub     esp, 0Ch
.text$mn:00004BCE                 mov     ecx, esp
.text$mn:00004BD0                 mov     [ebp+var_40], esp
.text$mn:00004BD3                 lea     edx, [ebp+arg_0]
.text$mn:00004BD6                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004BD7                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004BDC                 mov     [ebp+var_20], eax
.text$mn:00004BDF                 mov     eax, [ebp+var_20]
.text$mn:00004BE2                 mov     [ebp+var_44], eax
.text$mn:00004BE5                 mov     byte ptr [ebp+var_4], 5
.text$mn:00004BE9                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004BED                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>)
.text$mn:00004BF2                 add     esp, 0Ch
.text$mn:00004BF5                 mov     [ebp+var_24], eax
.text$mn:00004BF8                 mov     ecx, [ebp+var_24]
.text$mn:00004BFB                 push    ecx
.text$mn:00004BFC                 call    ??$_Sort@PAUColumnModeInfo@@HUSortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInPositionOrder@@@Z ; std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)
.text$mn:00004C01                 add     esp, 10h
.text$mn:00004C04                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004C08                 lea     ecx, [ebp+arg_0]
.text$mn:00004C0B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00004C10                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C17                 lea     ecx, [ebp+arg_C]
.text$mn:00004C1A                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00004C1F                 mov     ecx, [ebp+var_C]
.text$mn:00004C22                 mov     large fs:0, ecx
.text$mn:00004C29                 pop     ecx
.text$mn:00004C2A                 mov     esp, ebp
.text$mn:00004C2C                 pop     ebp
.text$mn:00004C2D                 retn
.text$mn:00004C2D ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z endp
.text$mn:00004C2D
.text$mn:00004C2D ; ---------------------------------------------------------------------------
.text$mn:00004C2E                 align 10h
.text$mn:00004C2E _text$mn        ends
.text$mn:00004C2E
.text$x:00004C30 ; ===========================================================================
.text$x:00004C30
.text$x:00004C30 ; Segment type: Pure code
.text$x:00004C30 ; Segment permissions: Read/Execute
.text$x:00004C30 _text$x         segment para public 'CODE' use32
.text$x:00004C30                 assume cs:_text$x
.text$x:00004C30                 ;org 4C30h
.text$x:00004C30 ; COMDAT (pick associative to section at 4AF4)
.text$x:00004C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004C30
.text$x:00004C30 ; =============== S U B R O U T I N E =======================================
.text$x:00004C30
.text$x:00004C30
.text$x:00004C30 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$0 proc near
.text$x:00004C30                                         ; DATA XREF: .xdata$x:0000A990o
.text$x:00004C30                 lea     ecx, [ebp+14h]
.text$x:00004C33                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004C33 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$0 endp
.text$x:00004C33
.text$x:00004C38
.text$x:00004C38 ; =============== S U B R O U T I N E =======================================
.text$x:00004C38
.text$x:00004C38
.text$x:00004C38 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$1 proc near
.text$x:00004C38                                         ; DATA XREF: .xdata$x:0000A998o
.text$x:00004C38                 lea     ecx, [ebp+8]
.text$x:00004C3B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004C3B __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$1 endp
.text$x:00004C3B
.text$x:00004C40
.text$x:00004C40 ; =============== S U B R O U T I N E =======================================
.text$x:00004C40
.text$x:00004C40
.text$x:00004C40 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$2 proc near
.text$x:00004C40                                         ; DATA XREF: .xdata$x:0000A9A0o
.text$x:00004C40                 mov     ecx, [ebp-28h]
.text$x:00004C43                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004C43 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$2 endp
.text$x:00004C43
.text$x:00004C48
.text$x:00004C48 ; =============== S U B R O U T I N E =======================================
.text$x:00004C48
.text$x:00004C48
.text$x:00004C48 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$3 proc near
.text$x:00004C48                                         ; DATA XREF: .xdata$x:0000A9A8o
.text$x:00004C48                 mov     ecx, [ebp-30h]
.text$x:00004C4B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004C4B __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$3 endp
.text$x:00004C4B
.text$x:00004C50
.text$x:00004C50 ; =============== S U B R O U T I N E =======================================
.text$x:00004C50
.text$x:00004C50
.text$x:00004C50 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$4 proc near
.text$x:00004C50                                         ; DATA XREF: .xdata$x:0000A9B0o
.text$x:00004C50                 mov     ecx, [ebp-38h]
.text$x:00004C53                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004C53 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$4 endp
.text$x:00004C53
.text$x:00004C58
.text$x:00004C58 ; =============== S U B R O U T I N E =======================================
.text$x:00004C58
.text$x:00004C58
.text$x:00004C58 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$5 proc near
.text$x:00004C58                                         ; DATA XREF: .xdata$x:0000A9B8o
.text$x:00004C58                 mov     ecx, [ebp-40h]
.text$x:00004C5B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004C5B __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$5 endp
.text$x:00004C5B
.text$x:00004C60
.text$x:00004C60 ; =============== S U B R O U T I N E =======================================
.text$x:00004C60
.text$x:00004C60
.text$x:00004C60 __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z proc near
.text$x:00004C60                                         ; DATA XREF: std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)+5o
.text$x:00004C60
.text$x:00004C60 arg_4           = dword ptr  8
.text$x:00004C60
.text$x:00004C60                 mov     edx, [esp+arg_4]
.text$x:00004C64                 lea     eax, [edx+0Ch]
.text$x:00004C67                 mov     ecx, [edx-3Ch]
.text$x:00004C6A                 xor     ecx, eax
.text$x:00004C6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C71                 mov     eax, offset __ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z
.text$x:00004C76                 jmp     ___CxxFrameHandler3
.text$x:00004C76 __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z endp
.text$x:00004C76
.text$x:00004C76 ; ---------------------------------------------------------------------------
.text$x:00004C7B                 align 4
.text$x:00004C7B _text$x         ends
.text$x:00004C7B
.text$mn:00004C7C ; ===========================================================================
.text$mn:00004C7C
.text$mn:00004C7C ; Segment type: Pure code
.text$mn:00004C7C ; Segment permissions: Read/Execute
.text$mn:00004C7C _text$mn        segment para public 'CODE' use32
.text$mn:00004C7C                 assume cs:_text$mn
.text$mn:00004C7C                 ;org 4C7Ch
.text$mn:00004C7C ; COMDAT (pick any)
.text$mn:00004C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C7C
.text$mn:00004C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C7C
.text$mn:00004C7C ; Attributes: bp-based frame
.text$mn:00004C7C
.text$mn:00004C7C ; void __cdecl std::sort<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>, struct SortInSelectOrder>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>, struct SortInSelectOrder)
.text$mn:00004C7C                 public ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z
.text$mn:00004C7C ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z proc near
.text$mn:00004C7C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+325p
.text$mn:00004C7C                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+86Ep
.text$mn:00004C7C
.text$mn:00004C7C var_44          = dword ptr -44h
.text$mn:00004C7C var_40          = dword ptr -40h
.text$mn:00004C7C var_3C          = dword ptr -3Ch
.text$mn:00004C7C var_38          = dword ptr -38h
.text$mn:00004C7C var_34          = dword ptr -34h
.text$mn:00004C7C var_30          = dword ptr -30h
.text$mn:00004C7C var_2C          = dword ptr -2Ch
.text$mn:00004C7C var_28          = dword ptr -28h
.text$mn:00004C7C var_24          = dword ptr -24h
.text$mn:00004C7C var_20          = dword ptr -20h
.text$mn:00004C7C var_1C          = dword ptr -1Ch
.text$mn:00004C7C var_18          = dword ptr -18h
.text$mn:00004C7C var_14          = dword ptr -14h
.text$mn:00004C7C var_10          = dword ptr -10h
.text$mn:00004C7C var_C           = dword ptr -0Ch
.text$mn:00004C7C var_4           = dword ptr -4
.text$mn:00004C7C arg_0           = byte ptr  8
.text$mn:00004C7C arg_C           = dword ptr  14h
.text$mn:00004C7C arg_18          = byte ptr  20h
.text$mn:00004C7C
.text$mn:00004C7C                 push    ebp
.text$mn:00004C7D                 mov     ebp, esp
.text$mn:00004C7F                 push    0FFFFFFFFh
.text$mn:00004C81                 push    offset __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z
.text$mn:00004C86                 mov     eax, large fs:0
.text$mn:00004C8C                 push    eax
.text$mn:00004C8D                 sub     esp, 38h
.text$mn:00004C90                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C95                 xor     eax, ebp
.text$mn:00004C97                 push    eax
.text$mn:00004C98                 lea     eax, [ebp+var_C]
.text$mn:00004C9B                 mov     large fs:0, eax
.text$mn:00004CA1                 mov     [ebp+var_4], 1
.text$mn:00004CA8                 push    0C53h           ; unsigned int
.text$mn:00004CAD                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004CB2                 sub     esp, 0Ch
.text$mn:00004CB5                 mov     ecx, esp
.text$mn:00004CB7                 mov     [ebp+var_28], esp
.text$mn:00004CBA                 lea     eax, [ebp+arg_C]
.text$mn:00004CBD                 push    eax             ; int
.text$mn:00004CBE                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004CC3                 mov     [ebp+var_10], eax
.text$mn:00004CC6                 mov     ecx, [ebp+var_10]
.text$mn:00004CC9                 mov     [ebp+var_2C], ecx
.text$mn:00004CCC                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004CD0                 sub     esp, 0Ch
.text$mn:00004CD3                 mov     ecx, esp
.text$mn:00004CD5                 mov     [ebp+var_30], esp
.text$mn:00004CD8                 lea     edx, [ebp+arg_0]
.text$mn:00004CDB                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004CDC                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004CE1                 mov     [ebp+var_14], eax
.text$mn:00004CE4                 mov     eax, [ebp+var_14]
.text$mn:00004CE7                 mov     [ebp+var_34], eax
.text$mn:00004CEA                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004CEE                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004CF2                 call    ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint)
.text$mn:00004CF7                 add     esp, 20h
.text$mn:00004CFA                 push    0C54h
.text$mn:00004CFF                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004D04                 lea     ecx, [ebp+arg_18]
.text$mn:00004D07                 push    ecx
.text$mn:00004D08                 call    ??$_Debug_pointer@USortInSelectOrder@@@std@@YAXAAUSortInSelectOrder@@PB_WI@Z ; std::_Debug_pointer<SortInSelectOrder>(SortInSelectOrder &,wchar_t const *,uint)
.text$mn:00004D0D                 add     esp, 0Ch
.text$mn:00004D10                 movzx   edx, [ebp+arg_18]
.text$mn:00004D14                 push    edx
.text$mn:00004D15                 lea     eax, [ebp+arg_0]
.text$mn:00004D18                 push    eax             ; std::_Iterator_base12 *
.text$mn:00004D19                 lea     ecx, [ebp+arg_C]
.text$mn:00004D1C                 call    ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004D21                 push    eax
.text$mn:00004D22                 sub     esp, 0Ch
.text$mn:00004D25                 mov     ecx, esp
.text$mn:00004D27                 mov     [ebp+var_38], esp
.text$mn:00004D2A                 lea     edx, [ebp+arg_C]
.text$mn:00004D2D                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004D2E                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004D33                 mov     [ebp+var_18], eax
.text$mn:00004D36                 mov     eax, [ebp+var_18]
.text$mn:00004D39                 mov     [ebp+var_3C], eax
.text$mn:00004D3C                 mov     byte ptr [ebp+var_4], 4
.text$mn:00004D40                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004D44                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>)
.text$mn:00004D49                 add     esp, 0Ch
.text$mn:00004D4C                 mov     [ebp+var_1C], eax
.text$mn:00004D4F                 mov     ecx, [ebp+var_1C]
.text$mn:00004D52                 push    ecx
.text$mn:00004D53                 sub     esp, 0Ch
.text$mn:00004D56                 mov     ecx, esp
.text$mn:00004D58                 mov     [ebp+var_40], esp
.text$mn:00004D5B                 lea     edx, [ebp+arg_0]
.text$mn:00004D5E                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00004D5F                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00004D64                 mov     [ebp+var_20], eax
.text$mn:00004D67                 mov     eax, [ebp+var_20]
.text$mn:00004D6A                 mov     [ebp+var_44], eax
.text$mn:00004D6D                 mov     byte ptr [ebp+var_4], 5
.text$mn:00004D71                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004D75                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>)
.text$mn:00004D7A                 add     esp, 0Ch
.text$mn:00004D7D                 mov     [ebp+var_24], eax
.text$mn:00004D80                 mov     ecx, [ebp+var_24]
.text$mn:00004D83                 push    ecx
.text$mn:00004D84                 call    ??$_Sort@PAUColumnModeInfo@@HUSortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0HUSortInSelectOrder@@@Z ; std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)
.text$mn:00004D89                 add     esp, 10h
.text$mn:00004D8C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004D90                 lea     ecx, [ebp+arg_0]
.text$mn:00004D93                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00004D98                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D9F                 lea     ecx, [ebp+arg_C]
.text$mn:00004DA2                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:00004DA7                 mov     ecx, [ebp+var_C]
.text$mn:00004DAA                 mov     large fs:0, ecx
.text$mn:00004DB1                 pop     ecx
.text$mn:00004DB2                 mov     esp, ebp
.text$mn:00004DB4                 pop     ebp
.text$mn:00004DB5                 retn
.text$mn:00004DB5 ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z endp
.text$mn:00004DB5
.text$mn:00004DB5 ; ---------------------------------------------------------------------------
.text$mn:00004DB6                 align 4
.text$mn:00004DB6 _text$mn        ends
.text$mn:00004DB6
.text$x:00004DB8 ; ===========================================================================
.text$x:00004DB8
.text$x:00004DB8 ; Segment type: Pure code
.text$x:00004DB8 ; Segment permissions: Read/Execute
.text$x:00004DB8 _text$x         segment para public 'CODE' use32
.text$x:00004DB8                 assume cs:_text$x
.text$x:00004DB8                 ;org 4DB8h
.text$x:00004DB8 ; COMDAT (pick associative to section at 4C7C)
.text$x:00004DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004DB8
.text$x:00004DB8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DB8
.text$x:00004DB8
.text$x:00004DB8 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$0 proc near
.text$x:00004DB8                                         ; DATA XREF: .xdata$x:0000A9E4o
.text$x:00004DB8                 lea     ecx, [ebp+14h]
.text$x:00004DBB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004DBB __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$0 endp
.text$x:00004DBB
.text$x:00004DC0
.text$x:00004DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00004DC0
.text$x:00004DC0
.text$x:00004DC0 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$1 proc near
.text$x:00004DC0                                         ; DATA XREF: .xdata$x:0000A9ECo
.text$x:00004DC0                 lea     ecx, [ebp+8]
.text$x:00004DC3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004DC3 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$1 endp
.text$x:00004DC3
.text$x:00004DC8
.text$x:00004DC8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DC8
.text$x:00004DC8
.text$x:00004DC8 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$2 proc near
.text$x:00004DC8                                         ; DATA XREF: .xdata$x:0000A9F4o
.text$x:00004DC8                 mov     ecx, [ebp-28h]
.text$x:00004DCB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004DCB __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$2 endp
.text$x:00004DCB
.text$x:00004DD0
.text$x:00004DD0 ; =============== S U B R O U T I N E =======================================
.text$x:00004DD0
.text$x:00004DD0
.text$x:00004DD0 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$3 proc near
.text$x:00004DD0                                         ; DATA XREF: .xdata$x:0000A9FCo
.text$x:00004DD0                 mov     ecx, [ebp-30h]
.text$x:00004DD3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004DD3 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$3 endp
.text$x:00004DD3
.text$x:00004DD8
.text$x:00004DD8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DD8
.text$x:00004DD8
.text$x:00004DD8 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$4 proc near
.text$x:00004DD8                                         ; DATA XREF: .xdata$x:0000AA04o
.text$x:00004DD8                 mov     ecx, [ebp-38h]
.text$x:00004DDB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004DDB __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$4 endp
.text$x:00004DDB
.text$x:00004DE0
.text$x:00004DE0 ; =============== S U B R O U T I N E =======================================
.text$x:00004DE0
.text$x:00004DE0
.text$x:00004DE0 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$5 proc near
.text$x:00004DE0                                         ; DATA XREF: .xdata$x:0000AA0Co
.text$x:00004DE0                 mov     ecx, [ebp-40h]
.text$x:00004DE3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00004DE3 __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$5 endp
.text$x:00004DE3
.text$x:00004DE8
.text$x:00004DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DE8
.text$x:00004DE8
.text$x:00004DE8 __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z proc near
.text$x:00004DE8                                         ; DATA XREF: std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder)+5o
.text$x:00004DE8
.text$x:00004DE8 arg_4           = dword ptr  8
.text$x:00004DE8
.text$x:00004DE8                 mov     edx, [esp+arg_4]
.text$x:00004DEC                 lea     eax, [edx+0Ch]
.text$x:00004DEF                 mov     ecx, [edx-3Ch]
.text$x:00004DF2                 xor     ecx, eax
.text$x:00004DF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004DF9                 mov     eax, offset __ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z
.text$x:00004DFE                 jmp     ___CxxFrameHandler3
.text$x:00004DFE __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z endp
.text$x:00004DFE
.text$x:00004DFE ; ---------------------------------------------------------------------------
.text$x:00004E03                 align 4
.text$x:00004E03 _text$x         ends
.text$x:00004E03
.text$mn:00004E04 ; ===========================================================================
.text$mn:00004E04
.text$mn:00004E04 ; Segment type: Pure code
.text$mn:00004E04 ; Segment permissions: Read/Execute
.text$mn:00004E04 _text$mn        segment para public 'CODE' use32
.text$mn:00004E04                 assume cs:_text$mn
.text$mn:00004E04                 ;org 4E04h
.text$mn:00004E04 ; COMDAT (pick any)
.text$mn:00004E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E04
.text$mn:00004E04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E04
.text$mn:00004E04 ; Attributes: bp-based frame
.text$mn:00004E04
.text$mn:00004E04 ; void __cdecl std::sort_heap<struct ColumnModeInfo *, struct SortInPositionOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInPositionOrder)
.text$mn:00004E04                 public ??$sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z
.text$mn:00004E04 ??$sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z proc near
.text$mn:00004E04                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInPositionOrder)+EDp
.text$mn:00004E04
.text$mn:00004E04 arg_0           = dword ptr  8
.text$mn:00004E04 arg_4           = dword ptr  0Ch
.text$mn:00004E04 arg_8           = byte ptr  10h
.text$mn:00004E04
.text$mn:00004E04                 push    ebp
.text$mn:00004E05                 mov     ebp, esp
.text$mn:00004E07                 push    9B4h            ; unsigned int
.text$mn:00004E0C                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004E11                 mov     eax, [ebp+arg_4]
.text$mn:00004E14                 push    eax             ; int
.text$mn:00004E15                 mov     ecx, [ebp+arg_0]
.text$mn:00004E18                 push    ecx             ; int
.text$mn:00004E19                 call    ??$_Debug_range@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WI@Z ; std::_Debug_range<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint)
.text$mn:00004E1E                 add     esp, 10h
.text$mn:00004E21                 push    9B5h
.text$mn:00004E26                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004E2B                 lea     edx, [ebp+arg_8]
.text$mn:00004E2E                 push    edx
.text$mn:00004E2F                 call    ??$_Debug_pointer@USortInPositionOrder@@@std@@YAXAAUSortInPositionOrder@@PB_WI@Z ; std::_Debug_pointer<SortInPositionOrder>(SortInPositionOrder &,wchar_t const *,uint)
.text$mn:00004E34                 add     esp, 0Ch
.text$mn:00004E37                 movzx   eax, [ebp+arg_8]
.text$mn:00004E3B                 push    eax
.text$mn:00004E3C                 mov     ecx, [ebp+arg_4]
.text$mn:00004E3F                 push    ecx
.text$mn:00004E40                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004E45                 add     esp, 4
.text$mn:00004E48                 push    eax
.text$mn:00004E49                 mov     edx, [ebp+arg_0]
.text$mn:00004E4C                 push    edx
.text$mn:00004E4D                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004E52                 add     esp, 4
.text$mn:00004E55                 push    eax
.text$mn:00004E56                 call    ??$_Debug_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z ; std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00004E5B                 add     esp, 0Ch
.text$mn:00004E5E                 movzx   eax, [ebp+arg_8]
.text$mn:00004E62                 push    eax
.text$mn:00004E63                 mov     ecx, [ebp+arg_4]
.text$mn:00004E66                 push    ecx
.text$mn:00004E67                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004E6C                 add     esp, 4
.text$mn:00004E6F                 push    eax
.text$mn:00004E70                 mov     edx, [ebp+arg_0]
.text$mn:00004E73                 push    edx
.text$mn:00004E74                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004E79                 add     esp, 4
.text$mn:00004E7C                 push    eax
.text$mn:00004E7D                 call    ??$_Sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z ; std::_Sort_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)
.text$mn:00004E82                 add     esp, 0Ch
.text$mn:00004E85                 pop     ebp
.text$mn:00004E86                 retn
.text$mn:00004E86 ??$sort_heap@PAUColumnModeInfo@@USortInPositionOrder@@@std@@YAXPAUColumnModeInfo@@0USortInPositionOrder@@@Z endp
.text$mn:00004E86
.text$mn:00004E86 ; ---------------------------------------------------------------------------
.text$mn:00004E87                 align 4
.text$mn:00004E87 _text$mn        ends
.text$mn:00004E87
.text$mn:00004E88 ; ===========================================================================
.text$mn:00004E88
.text$mn:00004E88 ; Segment type: Pure code
.text$mn:00004E88 ; Segment permissions: Read/Execute
.text$mn:00004E88 _text$mn        segment para public 'CODE' use32
.text$mn:00004E88                 assume cs:_text$mn
.text$mn:00004E88                 ;org 4E88h
.text$mn:00004E88 ; COMDAT (pick any)
.text$mn:00004E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E88
.text$mn:00004E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E88
.text$mn:00004E88 ; Attributes: bp-based frame
.text$mn:00004E88
.text$mn:00004E88 ; void __cdecl std::sort_heap<struct ColumnModeInfo *, struct SortInSelectOrder>(struct ColumnModeInfo *, struct ColumnModeInfo *, struct SortInSelectOrder)
.text$mn:00004E88                 public ??$sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z
.text$mn:00004E88 ??$sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z proc near
.text$mn:00004E88                                         ; CODE XREF: std::_Sort<ColumnModeInfo *,int,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,int,SortInSelectOrder)+EDp
.text$mn:00004E88
.text$mn:00004E88 arg_0           = dword ptr  8
.text$mn:00004E88 arg_4           = dword ptr  0Ch
.text$mn:00004E88 arg_8           = byte ptr  10h
.text$mn:00004E88
.text$mn:00004E88                 push    ebp
.text$mn:00004E89                 mov     ebp, esp
.text$mn:00004E8B                 push    9B4h            ; unsigned int
.text$mn:00004E90                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004E95                 mov     eax, [ebp+arg_4]
.text$mn:00004E98                 push    eax             ; int
.text$mn:00004E99                 mov     ecx, [ebp+arg_0]
.text$mn:00004E9C                 push    ecx             ; int
.text$mn:00004E9D                 call    ??$_Debug_range@PAUColumnModeInfo@@@std@@YAXPAUColumnModeInfo@@0PB_WI@Z ; std::_Debug_range<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint)
.text$mn:00004EA2                 add     esp, 10h
.text$mn:00004EA5                 push    9B5h
.text$mn:00004EAA                 push    offset ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004EAF                 lea     edx, [ebp+arg_8]
.text$mn:00004EB2                 push    edx
.text$mn:00004EB3                 call    ??$_Debug_pointer@USortInSelectOrder@@@std@@YAXAAUSortInSelectOrder@@PB_WI@Z ; std::_Debug_pointer<SortInSelectOrder>(SortInSelectOrder &,wchar_t const *,uint)
.text$mn:00004EB8                 add     esp, 0Ch
.text$mn:00004EBB                 movzx   eax, [ebp+arg_8]
.text$mn:00004EBF                 push    eax
.text$mn:00004EC0                 mov     ecx, [ebp+arg_4]
.text$mn:00004EC3                 push    ecx
.text$mn:00004EC4                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004EC9                 add     esp, 4
.text$mn:00004ECC                 push    eax
.text$mn:00004ECD                 mov     edx, [ebp+arg_0]
.text$mn:00004ED0                 push    edx
.text$mn:00004ED1                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004ED6                 add     esp, 4
.text$mn:00004ED9                 push    eax
.text$mn:00004EDA                 call    ??$_Debug_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z ; std::_Debug_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00004EDF                 add     esp, 0Ch
.text$mn:00004EE2                 movzx   eax, [ebp+arg_8]
.text$mn:00004EE6                 push    eax
.text$mn:00004EE7                 mov     ecx, [ebp+arg_4]
.text$mn:00004EEA                 push    ecx
.text$mn:00004EEB                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004EF0                 add     esp, 4
.text$mn:00004EF3                 push    eax
.text$mn:00004EF4                 mov     edx, [ebp+arg_0]
.text$mn:00004EF7                 push    edx
.text$mn:00004EF8                 call    ??$_Unchecked@PAUColumnModeInfo@@@std@@YAPAUColumnModeInfo@@PAU1@@Z ; std::_Unchecked<ColumnModeInfo *>(ColumnModeInfo *)
.text$mn:00004EFD                 add     esp, 4
.text$mn:00004F00                 push    eax
.text$mn:00004F01                 call    ??$_Sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z ; std::_Sort_heap<ColumnModeInfo *,SortInSelectOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInSelectOrder)
.text$mn:00004F06                 add     esp, 0Ch
.text$mn:00004F09                 pop     ebp
.text$mn:00004F0A                 retn
.text$mn:00004F0A ??$sort_heap@PAUColumnModeInfo@@USortInSelectOrder@@@std@@YAXPAUColumnModeInfo@@0USortInSelectOrder@@@Z endp
.text$mn:00004F0A
.text$mn:00004F0A ; ---------------------------------------------------------------------------
.text$mn:00004F0B                 align 4
.text$mn:00004F0B _text$mn        ends
.text$mn:00004F0B
.text$mn:00004F0C ; ===========================================================================
.text$mn:00004F0C
.text$mn:00004F0C ; Segment type: Pure code
.text$mn:00004F0C ; Segment permissions: Read/Execute
.text$mn:00004F0C _text$mn        segment para public 'CODE' use32
.text$mn:00004F0C                 assume cs:_text$mn
.text$mn:00004F0C                 ;org 4F0Ch
.text$mn:00004F0C ; COMDAT (pick any)
.text$mn:00004F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F0C
.text$mn:00004F0C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F0C
.text$mn:00004F0C ; Attributes: bp-based frame
.text$mn:00004F0C
.text$mn:00004F0C ; void __cdecl std::swap<struct ColumnModeInfo>(struct ColumnModeInfo &, struct ColumnModeInfo &)
.text$mn:00004F0C                 public ??$swap@UColumnModeInfo@@@std@@YAXAAUColumnModeInfo@@0@Z
.text$mn:00004F0C ??$swap@UColumnModeInfo@@@std@@YAXAAUColumnModeInfo@@0@Z proc near
.text$mn:00004F0C                                         ; CODE XREF: std::iter_swap<ColumnModeInfo *,ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *)+Bp
.text$mn:00004F0C
.text$mn:00004F0C var_18          = dword ptr -18h
.text$mn:00004F0C var_14          = dword ptr -14h
.text$mn:00004F0C var_10          = dword ptr -10h
.text$mn:00004F0C var_C           = dword ptr -0Ch
.text$mn:00004F0C var_8           = dword ptr -8
.text$mn:00004F0C var_4           = dword ptr -4
.text$mn:00004F0C arg_0           = dword ptr  8
.text$mn:00004F0C arg_4           = dword ptr  0Ch
.text$mn:00004F0C
.text$mn:00004F0C                 push    ebp
.text$mn:00004F0D                 mov     ebp, esp
.text$mn:00004F0F                 sub     esp, 18h
.text$mn:00004F12                 mov     eax, [ebp+arg_0]
.text$mn:00004F15                 push    eax
.text$mn:00004F16                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00004F1B                 add     esp, 4
.text$mn:00004F1E                 mov     ecx, [eax]
.text$mn:00004F20                 mov     [ebp+var_18], ecx
.text$mn:00004F23                 mov     edx, [eax+4]
.text$mn:00004F26                 mov     [ebp+var_14], edx
.text$mn:00004F29                 mov     ecx, [eax+8]
.text$mn:00004F2C                 mov     [ebp+var_10], ecx
.text$mn:00004F2F                 mov     edx, [eax+0Ch]
.text$mn:00004F32                 mov     [ebp+var_C], edx
.text$mn:00004F35                 mov     ecx, [eax+10h]
.text$mn:00004F38                 mov     [ebp+var_8], ecx
.text$mn:00004F3B                 mov     edx, [eax+14h]
.text$mn:00004F3E                 mov     [ebp+var_4], edx
.text$mn:00004F41                 mov     eax, [ebp+arg_4]
.text$mn:00004F44                 push    eax
.text$mn:00004F45                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00004F4A                 add     esp, 4
.text$mn:00004F4D                 mov     ecx, [ebp+arg_0]
.text$mn:00004F50                 mov     edx, [eax]
.text$mn:00004F52                 mov     [ecx], edx
.text$mn:00004F54                 mov     edx, [eax+4]
.text$mn:00004F57                 mov     [ecx+4], edx
.text$mn:00004F5A                 mov     edx, [eax+8]
.text$mn:00004F5D                 mov     [ecx+8], edx
.text$mn:00004F60                 mov     edx, [eax+0Ch]
.text$mn:00004F63                 mov     [ecx+0Ch], edx
.text$mn:00004F66                 mov     edx, [eax+10h]
.text$mn:00004F69                 mov     [ecx+10h], edx
.text$mn:00004F6C                 mov     eax, [eax+14h]
.text$mn:00004F6F                 mov     [ecx+14h], eax
.text$mn:00004F72                 lea     ecx, [ebp+var_18]
.text$mn:00004F75                 push    ecx
.text$mn:00004F76                 call    ??$_Move@AAUColumnModeInfo@@@std@@YA$$QAUColumnModeInfo@@AAU1@@Z ; std::_Move<ColumnModeInfo &>(ColumnModeInfo &)
.text$mn:00004F7B                 add     esp, 4
.text$mn:00004F7E                 mov     edx, [ebp+arg_4]
.text$mn:00004F81                 mov     ecx, [eax]
.text$mn:00004F83                 mov     [edx], ecx
.text$mn:00004F85                 mov     ecx, [eax+4]
.text$mn:00004F88                 mov     [edx+4], ecx
.text$mn:00004F8B                 mov     ecx, [eax+8]
.text$mn:00004F8E                 mov     [edx+8], ecx
.text$mn:00004F91                 mov     ecx, [eax+0Ch]
.text$mn:00004F94                 mov     [edx+0Ch], ecx
.text$mn:00004F97                 mov     ecx, [eax+10h]
.text$mn:00004F9A                 mov     [edx+10h], ecx
.text$mn:00004F9D                 mov     eax, [eax+14h]
.text$mn:00004FA0                 mov     [edx+14h], eax
.text$mn:00004FA3                 mov     esp, ebp
.text$mn:00004FA5                 pop     ebp
.text$mn:00004FA6                 retn
.text$mn:00004FA6 ??$swap@UColumnModeInfo@@@std@@YAXAAUColumnModeInfo@@0@Z endp
.text$mn:00004FA6
.text$mn:00004FA6 ; ---------------------------------------------------------------------------
.text$mn:00004FA7                 align 4
.text$mn:00004FA7 _text$mn        ends
.text$mn:00004FA7
.text$mn:00004FA8 ; ===========================================================================
.text$mn:00004FA8
.text$mn:00004FA8 ; Segment type: Pure code
.text$mn:00004FA8 ; Segment permissions: Read/Execute
.text$mn:00004FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00004FA8                 assume cs:_text$mn
.text$mn:00004FA8                 ;org 4FA8h
.text$mn:00004FA8 ; COMDAT (pick any)
.text$mn:00004FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FA8
.text$mn:00004FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FA8
.text$mn:00004FA8 ; Attributes: bp-based frame
.text$mn:00004FA8
.text$mn:00004FA8 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00004FA8                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004FA8 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00004FA8                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Dp
.text$mn:00004FA8
.text$mn:00004FA8 var_10          = dword ptr -10h
.text$mn:00004FA8 var_C           = dword ptr -0Ch
.text$mn:00004FA8 var_4           = dword ptr -4
.text$mn:00004FA8 arg_0           = dword ptr  8
.text$mn:00004FA8
.text$mn:00004FA8                 push    ebp
.text$mn:00004FA9                 mov     ebp, esp
.text$mn:00004FAB                 push    0FFFFFFFFh
.text$mn:00004FAD                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00004FB2                 mov     eax, large fs:0
.text$mn:00004FB8                 push    eax
.text$mn:00004FB9                 push    ecx
.text$mn:00004FBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004FBF                 xor     eax, ebp
.text$mn:00004FC1                 push    eax
.text$mn:00004FC2                 lea     eax, [ebp+var_C]
.text$mn:00004FC5                 mov     large fs:0, eax
.text$mn:00004FCB                 mov     [ebp+var_10], ecx
.text$mn:00004FCE                 mov     eax, [ebp+arg_0]
.text$mn:00004FD1                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004FD2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004FD5                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00004FDA                 mov     [ebp+var_4], 0
.text$mn:00004FE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FE8                 mov     eax, [ebp+var_10]
.text$mn:00004FEB                 mov     ecx, [ebp+var_C]
.text$mn:00004FEE                 mov     large fs:0, ecx
.text$mn:00004FF5                 pop     ecx
.text$mn:00004FF6                 mov     esp, ebp
.text$mn:00004FF8                 pop     ebp
.text$mn:00004FF9                 retn    4
.text$mn:00004FF9 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00004FF9
.text$mn:00004FF9 _text$mn        ends
.text$mn:00004FF9
.text$x:00004FFC ; ===========================================================================
.text$x:00004FFC
.text$x:00004FFC ; Segment type: Pure code
.text$x:00004FFC ; Segment permissions: Read/Execute
.text$x:00004FFC _text$x         segment para public 'CODE' use32
.text$x:00004FFC                 assume cs:_text$x
.text$x:00004FFC                 ;org 4FFCh
.text$x:00004FFC ; COMDAT (pick associative to section at 4FA8)
.text$x:00004FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004FFC
.text$x:00004FFC ; =============== S U B R O U T I N E =======================================
.text$x:00004FFC
.text$x:00004FFC
.text$x:00004FFC __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00004FFC                                         ; DATA XREF: .xdata$x:0000AA6Co
.text$x:00004FFC                 mov     ecx, [ebp-10h]  ; this
.text$x:00004FFF                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004FFF __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00004FFF
.text$x:00005004
.text$x:00005004 ; =============== S U B R O U T I N E =======================================
.text$x:00005004
.text$x:00005004
.text$x:00005004 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00005004                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)+5o
.text$x:00005004
.text$x:00005004 arg_4           = dword ptr  8
.text$x:00005004
.text$x:00005004                 mov     edx, [esp+arg_4]
.text$x:00005008                 lea     eax, [edx+0Ch]
.text$x:0000500B                 mov     ecx, [edx-8]
.text$x:0000500E                 xor     ecx, eax
.text$x:00005010                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005015                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:0000501A                 jmp     ___CxxFrameHandler3
.text$x:0000501A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:0000501A
.text$x:0000501A ; ---------------------------------------------------------------------------
.text$x:0000501F                 align 10h
.text$x:0000501F _text$x         ends
.text$x:0000501F
.text$mn:00005020 ; ===========================================================================
.text$mn:00005020
.text$mn:00005020 ; Segment type: Pure code
.text$mn:00005020 ; Segment permissions: Read/Execute
.text$mn:00005020 _text$mn        segment para public 'CODE' use32
.text$mn:00005020                 assume cs:_text$mn
.text$mn:00005020                 ;org 5020h
.text$mn:00005020 ; COMDAT (pick any)
.text$mn:00005020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005020
.text$mn:00005020 ; =============== S U B R O U T I N E =======================================
.text$mn:00005020
.text$mn:00005020 ; Attributes: bp-based frame
.text$mn:00005020
.text$mn:00005020 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:00005020                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00005020 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00005020                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+29p
.text$mn:00005020
.text$mn:00005020 var_10          = dword ptr -10h
.text$mn:00005020 var_C           = dword ptr -0Ch
.text$mn:00005020 var_4           = dword ptr -4
.text$mn:00005020
.text$mn:00005020                 push    ebp
.text$mn:00005021                 mov     ebp, esp
.text$mn:00005023                 push    0FFFFFFFFh
.text$mn:00005025                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000502A                 mov     eax, large fs:0
.text$mn:00005030                 push    eax
.text$mn:00005031                 push    ecx
.text$mn:00005032                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005037                 xor     eax, ebp
.text$mn:00005039                 push    eax
.text$mn:0000503A                 lea     eax, [ebp+var_C]
.text$mn:0000503D                 mov     large fs:0, eax
.text$mn:00005043                 mov     [ebp+var_10], ecx
.text$mn:00005046                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005049                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:0000504E                 mov     [ebp+var_4], 0
.text$mn:00005055                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000505C                 mov     eax, [ebp+var_10]
.text$mn:0000505F                 mov     ecx, [ebp+var_C]
.text$mn:00005062                 mov     large fs:0, ecx
.text$mn:00005069                 pop     ecx
.text$mn:0000506A                 mov     esp, ebp
.text$mn:0000506C                 pop     ebp
.text$mn:0000506D                 retn
.text$mn:0000506D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000506D
.text$mn:0000506D ; ---------------------------------------------------------------------------
.text$mn:0000506E                 align 10h
.text$mn:0000506E _text$mn        ends
.text$mn:0000506E
.text$x:00005070 ; ===========================================================================
.text$x:00005070
.text$x:00005070 ; Segment type: Pure code
.text$x:00005070 ; Segment permissions: Read/Execute
.text$x:00005070 _text$x         segment para public 'CODE' use32
.text$x:00005070                 assume cs:_text$x
.text$x:00005070                 ;org 5070h
.text$x:00005070 ; COMDAT (pick associative to section at 5020)
.text$x:00005070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005070
.text$x:00005070 ; =============== S U B R O U T I N E =======================================
.text$x:00005070
.text$x:00005070
.text$x:00005070 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00005070                                         ; DATA XREF: .xdata$x:0000AA14o
.text$x:00005070                 mov     ecx, [ebp-10h]  ; this
.text$x:00005073                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00005073 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00005073
.text$x:00005078
.text$x:00005078 ; =============== S U B R O U T I N E =======================================
.text$x:00005078
.text$x:00005078
.text$x:00005078 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00005078                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:00005078
.text$x:00005078 arg_4           = dword ptr  8
.text$x:00005078
.text$x:00005078                 mov     edx, [esp+arg_4]
.text$x:0000507C                 lea     eax, [edx+0Ch]
.text$x:0000507F                 mov     ecx, [edx-8]
.text$x:00005082                 xor     ecx, eax
.text$x:00005084                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005089                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000508E                 jmp     ___CxxFrameHandler3
.text$x:0000508E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000508E
.text$x:0000508E ; ---------------------------------------------------------------------------
.text$x:00005093                 align 4
.text$x:00005093 _text$x         ends
.text$x:00005093
.text$mn:00005094 ; ===========================================================================
.text$mn:00005094
.text$mn:00005094 ; Segment type: Pure code
.text$mn:00005094 ; Segment permissions: Read/Execute
.text$mn:00005094 _text$mn        segment para public 'CODE' use32
.text$mn:00005094                 assume cs:_text$mn
.text$mn:00005094                 ;org 5094h
.text$mn:00005094 ; COMDAT (pick any)
.text$mn:00005094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005094
.text$mn:00005094 ; =============== S U B R O U T I N E =======================================
.text$mn:00005094
.text$mn:00005094 ; Attributes: bp-based frame
.text$mn:00005094
.text$mn:00005094 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00005094                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00005094 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00005094                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+2Dp
.text$mn:00005094
.text$mn:00005094 var_10          = dword ptr -10h
.text$mn:00005094 var_C           = dword ptr -0Ch
.text$mn:00005094 var_4           = dword ptr -4
.text$mn:00005094 arg_0           = dword ptr  8
.text$mn:00005094
.text$mn:00005094                 push    ebp
.text$mn:00005095                 mov     ebp, esp
.text$mn:00005097                 push    0FFFFFFFFh
.text$mn:00005099                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:0000509E                 mov     eax, large fs:0
.text$mn:000050A4                 push    eax
.text$mn:000050A5                 push    ecx
.text$mn:000050A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000050AB                 xor     eax, ebp
.text$mn:000050AD                 push    eax
.text$mn:000050AE                 lea     eax, [ebp+var_C]
.text$mn:000050B1                 mov     large fs:0, eax
.text$mn:000050B7                 mov     [ebp+var_10], ecx
.text$mn:000050BA                 mov     eax, [ebp+arg_0]
.text$mn:000050BD                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000050BE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000050C1                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:000050C6                 mov     [ebp+var_4], 0
.text$mn:000050CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050D4                 mov     eax, [ebp+var_10]
.text$mn:000050D7                 mov     ecx, [ebp+var_C]
.text$mn:000050DA                 mov     large fs:0, ecx
.text$mn:000050E1                 pop     ecx
.text$mn:000050E2                 mov     esp, ebp
.text$mn:000050E4                 pop     ebp
.text$mn:000050E5                 retn    4
.text$mn:000050E5 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000050E5
.text$mn:000050E5 _text$mn        ends
.text$mn:000050E5
.text$x:000050E8 ; ===========================================================================
.text$x:000050E8
.text$x:000050E8 ; Segment type: Pure code
.text$x:000050E8 ; Segment permissions: Read/Execute
.text$x:000050E8 _text$x         segment para public 'CODE' use32
.text$x:000050E8                 assume cs:_text$x
.text$x:000050E8                 ;org 50E8h
.text$x:000050E8 ; COMDAT (pick associative to section at 5094)
.text$x:000050E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000050E8
.text$x:000050E8 ; =============== S U B R O U T I N E =======================================
.text$x:000050E8
.text$x:000050E8
.text$x:000050E8 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000050E8                                         ; DATA XREF: .xdata$x:0000A838o
.text$x:000050E8                 mov     ecx, [ebp-10h]  ; this
.text$x:000050EB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000050EB __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000050EB
.text$x:000050F0
.text$x:000050F0 ; =============== S U B R O U T I N E =======================================
.text$x:000050F0
.text$x:000050F0
.text$x:000050F0 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000050F0                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12> const &)+5o
.text$x:000050F0
.text$x:000050F0 arg_4           = dword ptr  8
.text$x:000050F0
.text$x:000050F0                 mov     edx, [esp+arg_4]
.text$x:000050F4                 lea     eax, [edx+0Ch]
.text$x:000050F7                 mov     ecx, [edx-8]
.text$x:000050FA                 xor     ecx, eax
.text$x:000050FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005101                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00005106                 jmp     ___CxxFrameHandler3
.text$x:00005106 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00005106
.text$x:00005106 ; ---------------------------------------------------------------------------
.text$x:0000510B                 align 4
.text$x:0000510B _text$x         ends
.text$x:0000510B
.text$mn:0000510C ; ===========================================================================
.text$mn:0000510C
.text$mn:0000510C ; Segment type: Pure code
.text$mn:0000510C ; Segment permissions: Read/Execute
.text$mn:0000510C _text$mn        segment para public 'CODE' use32
.text$mn:0000510C                 assume cs:_text$mn
.text$mn:0000510C                 ;org 510Ch
.text$mn:0000510C ; COMDAT (pick any)
.text$mn:0000510C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000510C
.text$mn:0000510C ; =============== S U B R O U T I N E =======================================
.text$mn:0000510C
.text$mn:0000510C ; Attributes: bp-based frame
.text$mn:0000510C
.text$mn:0000510C ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct ColumnModeInfo, int, struct ColumnModeInfo const *, struct ColumnModeInfo const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct ColumnModeInfo, int, struct ColumnModeInfo const *, struct ColumnModeInfo const &, struct std::_Iterator_base12>(void)
.text$mn:0000510C                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000510C ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:0000510C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)+29p
.text$mn:0000510C
.text$mn:0000510C var_10          = dword ptr -10h
.text$mn:0000510C var_C           = dword ptr -0Ch
.text$mn:0000510C var_4           = dword ptr -4
.text$mn:0000510C
.text$mn:0000510C                 push    ebp
.text$mn:0000510D                 mov     ebp, esp
.text$mn:0000510F                 push    0FFFFFFFFh
.text$mn:00005111                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00005116                 mov     eax, large fs:0
.text$mn:0000511C                 push    eax
.text$mn:0000511D                 push    ecx
.text$mn:0000511E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005123                 xor     eax, ebp
.text$mn:00005125                 push    eax
.text$mn:00005126                 lea     eax, [ebp+var_C]
.text$mn:00005129                 mov     large fs:0, eax
.text$mn:0000512F                 mov     [ebp+var_10], ecx
.text$mn:00005132                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005135                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:0000513A                 mov     [ebp+var_4], 0
.text$mn:00005141                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005148                 mov     eax, [ebp+var_10]
.text$mn:0000514B                 mov     ecx, [ebp+var_C]
.text$mn:0000514E                 mov     large fs:0, ecx
.text$mn:00005155                 pop     ecx
.text$mn:00005156                 mov     esp, ebp
.text$mn:00005158                 pop     ebp
.text$mn:00005159                 retn
.text$mn:00005159 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00005159
.text$mn:00005159 ; ---------------------------------------------------------------------------
.text$mn:0000515A                 align 4
.text$mn:0000515A _text$mn        ends
.text$mn:0000515A
.text$x:0000515C ; ===========================================================================
.text$x:0000515C
.text$x:0000515C ; Segment type: Pure code
.text$x:0000515C ; Segment permissions: Read/Execute
.text$x:0000515C _text$x         segment para public 'CODE' use32
.text$x:0000515C                 assume cs:_text$x
.text$x:0000515C                 ;org 515Ch
.text$x:0000515C ; COMDAT (pick associative to section at 510C)
.text$x:0000515C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000515C
.text$x:0000515C ; =============== S U B R O U T I N E =======================================
.text$x:0000515C
.text$x:0000515C
.text$x:0000515C __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000515C                                         ; DATA XREF: .xdata$x:0000A7E0o
.text$x:0000515C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000515F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000515F __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000515F
.text$x:00005164
.text$x:00005164 ; =============== S U B R O U T I N E =======================================
.text$x:00005164
.text$x:00005164
.text$x:00005164 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00005164                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)+5o
.text$x:00005164
.text$x:00005164 arg_4           = dword ptr  8
.text$x:00005164
.text$x:00005164                 mov     edx, [esp+arg_4]
.text$x:00005168                 lea     eax, [edx+0Ch]
.text$x:0000516B                 mov     ecx, [edx-8]
.text$x:0000516E                 xor     ecx, eax
.text$x:00005170                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005175                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000517A                 jmp     ___CxxFrameHandler3
.text$x:0000517A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000517A
.text$x:0000517A ; ---------------------------------------------------------------------------
.text$x:0000517F                 align 10h
.text$x:0000517F _text$x         ends
.text$x:0000517F
.text$mn:00005180 ; ===========================================================================
.text$mn:00005180
.text$mn:00005180 ; Segment type: Pure code
.text$mn:00005180 ; Segment permissions: Read/Execute
.text$mn:00005180 _text$mn        segment para public 'CODE' use32
.text$mn:00005180                 assume cs:_text$mn
.text$mn:00005180                 ;org 5180h
.text$mn:00005180 ; COMDAT (pick any)
.text$mn:00005180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005180
.text$mn:00005180 ; =============== S U B R O U T I N E =======================================
.text$mn:00005180
.text$mn:00005180 ; Attributes: bp-based frame
.text$mn:00005180
.text$mn:00005180 ; int __stdcall std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(struct std::_Iterator_base12 *)
.text$mn:00005180                 public ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z
.text$mn:00005180 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z proc near
.text$mn:00005180                                         ; CODE XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>> const &)+2Dp
.text$mn:00005180
.text$mn:00005180 var_10          = dword ptr -10h
.text$mn:00005180 var_C           = dword ptr -0Ch
.text$mn:00005180 var_4           = dword ptr -4
.text$mn:00005180 arg_0           = dword ptr  8
.text$mn:00005180
.text$mn:00005180                 push    ebp
.text$mn:00005181                 mov     ebp, esp
.text$mn:00005183                 push    0FFFFFFFFh
.text$mn:00005185                 push    offset __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z
.text$mn:0000518A                 mov     eax, large fs:0
.text$mn:00005190                 push    eax
.text$mn:00005191                 push    ecx
.text$mn:00005192                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005197                 xor     eax, ebp
.text$mn:00005199                 push    eax
.text$mn:0000519A                 lea     eax, [ebp+var_C]
.text$mn:0000519D                 mov     large fs:0, eax
.text$mn:000051A3                 mov     [ebp+var_10], ecx
.text$mn:000051A6                 mov     eax, [ebp+arg_0]
.text$mn:000051A9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000051AA                 mov     ecx, [ebp+var_10]
.text$mn:000051AD                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000051B2                 mov     [ebp+var_4], 0
.text$mn:000051B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051C0                 mov     eax, [ebp+var_10]
.text$mn:000051C3                 mov     ecx, [ebp+var_C]
.text$mn:000051C6                 mov     large fs:0, ecx
.text$mn:000051CD                 pop     ecx
.text$mn:000051CE                 mov     esp, ebp
.text$mn:000051D0                 pop     ebp
.text$mn:000051D1                 retn    4
.text$mn:000051D1 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z endp
.text$mn:000051D1
.text$mn:000051D1 _text$mn        ends
.text$mn:000051D1
.text$x:000051D4 ; ===========================================================================
.text$x:000051D4
.text$x:000051D4 ; Segment type: Pure code
.text$x:000051D4 ; Segment permissions: Read/Execute
.text$x:000051D4 _text$x         segment para public 'CODE' use32
.text$x:000051D4                 assume cs:_text$x
.text$x:000051D4                 ;org 51D4h
.text$x:000051D4 ; COMDAT (pick associative to section at 5180)
.text$x:000051D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000051D4
.text$x:000051D4 ; =============== S U B R O U T I N E =======================================
.text$x:000051D4
.text$x:000051D4
.text$x:000051D4 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000051D4                                         ; DATA XREF: .xdata$x:0000AC2Co
.text$x:000051D4                 mov     ecx, [ebp-10h]
.text$x:000051D7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000051D7 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:000051D7
.text$x:000051DC
.text$x:000051DC ; =============== S U B R O U T I N E =======================================
.text$x:000051DC
.text$x:000051DC
.text$x:000051DC __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z proc near
.text$x:000051DC                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>> const &)+5o
.text$x:000051DC
.text$x:000051DC arg_4           = dword ptr  8
.text$x:000051DC
.text$x:000051DC                 mov     edx, [esp+arg_4]
.text$x:000051E0                 lea     eax, [edx+0Ch]
.text$x:000051E3                 mov     ecx, [edx-8]
.text$x:000051E6                 xor     ecx, eax
.text$x:000051E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000051ED                 mov     eax, offset __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z
.text$x:000051F2                 jmp     ___CxxFrameHandler3
.text$x:000051F2 __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z endp
.text$x:000051F2
.text$x:000051F2 ; ---------------------------------------------------------------------------
.text$x:000051F7                 align 4
.text$x:000051F7 _text$x         ends
.text$x:000051F7
.text$mn:000051F8 ; ===========================================================================
.text$mn:000051F8
.text$mn:000051F8 ; Segment type: Pure code
.text$mn:000051F8 ; Segment permissions: Read/Execute
.text$mn:000051F8 _text$mn        segment para public 'CODE' use32
.text$mn:000051F8                 assume cs:_text$mn
.text$mn:000051F8                 ;org 51F8h
.text$mn:000051F8 ; COMDAT (pick any)
.text$mn:000051F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051F8
.text$mn:000051F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000051F8
.text$mn:000051F8 ; Attributes: bp-based frame
.text$mn:000051F8
.text$mn:000051F8 ; public: __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, struct std::iterator<struct std::random_access_iterator_tag, int, int, int *, int &>>::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, struct std::iterator<struct std::random_access_iterator_tag, int, int, int *, int &>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)
.text$mn:000051F8                 public ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.text$mn:000051F8 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z proc near
.text$mn:000051F8                                         ; CODE XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+54p
.text$mn:000051F8
.text$mn:000051F8 var_10          = dword ptr -10h
.text$mn:000051F8 var_C           = dword ptr -0Ch
.text$mn:000051F8 var_4           = dword ptr -4
.text$mn:000051F8 arg_0           = byte ptr  8
.text$mn:000051F8
.text$mn:000051F8                 push    ebp
.text$mn:000051F9                 mov     ebp, esp
.text$mn:000051FB                 push    0FFFFFFFFh
.text$mn:000051FD                 push    offset __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.text$mn:00005202                 mov     eax, large fs:0
.text$mn:00005208                 push    eax
.text$mn:00005209                 push    ecx
.text$mn:0000520A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000520F                 xor     eax, ebp
.text$mn:00005211                 push    eax
.text$mn:00005212                 lea     eax, [ebp+var_C]
.text$mn:00005215                 mov     large fs:0, eax
.text$mn:0000521B                 mov     [ebp+var_10], ecx
.text$mn:0000521E                 mov     [ebp+var_4], 0
.text$mn:00005225                 lea     eax, [ebp+arg_0]
.text$mn:00005228                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005229                 mov     ecx, [ebp+var_10]
.text$mn:0000522C                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005231                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005235                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000523C                 lea     ecx, [ebp+arg_0]
.text$mn:0000523F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005244                 mov     eax, [ebp+var_10]
.text$mn:00005247                 mov     ecx, [ebp+var_C]
.text$mn:0000524A                 mov     large fs:0, ecx
.text$mn:00005251                 pop     ecx
.text$mn:00005252                 mov     esp, ebp
.text$mn:00005254                 pop     ebp
.text$mn:00005255                 retn    0Ch
.text$mn:00005255 ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z endp
.text$mn:00005255
.text$mn:00005255 _text$mn        ends
.text$mn:00005255
.text$x:00005258 ; ===========================================================================
.text$x:00005258
.text$x:00005258 ; Segment type: Pure code
.text$x:00005258 ; Segment permissions: Read/Execute
.text$x:00005258 _text$x         segment para public 'CODE' use32
.text$x:00005258                 assume cs:_text$x
.text$x:00005258                 ;org 5258h
.text$x:00005258 ; COMDAT (pick associative to section at 51F8)
.text$x:00005258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005258
.text$x:00005258 ; =============== S U B R O U T I N E =======================================
.text$x:00005258
.text$x:00005258
.text$x:00005258 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$0 proc near
.text$x:00005258                                         ; DATA XREF: .xdata$x:0000ABA0o
.text$x:00005258                 lea     ecx, [ebp+8]
.text$x:0000525B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000525B __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$0 endp
.text$x:0000525B
.text$x:00005260
.text$x:00005260 ; =============== S U B R O U T I N E =======================================
.text$x:00005260
.text$x:00005260
.text$x:00005260 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$1 proc near
.text$x:00005260                                         ; DATA XREF: .xdata$x:0000ABA8o
.text$x:00005260                 mov     ecx, [ebp-10h]
.text$x:00005263                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005263 __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$1 endp
.text$x:00005263
.text$x:00005268
.text$x:00005268 ; =============== S U B R O U T I N E =======================================
.text$x:00005268
.text$x:00005268
.text$x:00005268 __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z proc near
.text$x:00005268                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00005268
.text$x:00005268 arg_4           = dword ptr  8
.text$x:00005268
.text$x:00005268                 mov     edx, [esp+arg_4]
.text$x:0000526C                 lea     eax, [edx+0Ch]
.text$x:0000526F                 mov     ecx, [edx-8]
.text$x:00005272                 xor     ecx, eax
.text$x:00005274                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005279                 mov     eax, offset __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.text$x:0000527E                 jmp     ___CxxFrameHandler3
.text$x:0000527E __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z endp
.text$x:0000527E
.text$x:0000527E ; ---------------------------------------------------------------------------
.text$x:00005283                 align 4
.text$x:00005283 _text$x         ends
.text$x:00005283
.text$mn:00005284 ; ===========================================================================
.text$mn:00005284
.text$mn:00005284 ; Segment type: Pure code
.text$mn:00005284 ; Segment permissions: Read/Execute
.text$mn:00005284 _text$mn        segment para public 'CODE' use32
.text$mn:00005284                 assume cs:_text$mn
.text$mn:00005284                 ;org 5284h
.text$mn:00005284 ; COMDAT (pick any)
.text$mn:00005284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005284
.text$mn:00005284 ; =============== S U B R O U T I N E =======================================
.text$mn:00005284
.text$mn:00005284 ; Attributes: bp-based frame
.text$mn:00005284
.text$mn:00005284 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00005284                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00005284 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00005284                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00005284
.text$mn:00005284 var_10          = dword ptr -10h
.text$mn:00005284 var_C           = dword ptr -0Ch
.text$mn:00005284 var_4           = dword ptr -4
.text$mn:00005284
.text$mn:00005284                 push    ebp
.text$mn:00005285                 mov     ebp, esp
.text$mn:00005287                 push    0FFFFFFFFh
.text$mn:00005289                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000528E                 mov     eax, large fs:0
.text$mn:00005294                 push    eax
.text$mn:00005295                 push    ecx
.text$mn:00005296                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000529B                 xor     eax, ebp
.text$mn:0000529D                 push    eax
.text$mn:0000529E                 lea     eax, [ebp+var_C]
.text$mn:000052A1                 mov     large fs:0, eax
.text$mn:000052A7                 mov     [ebp+var_10], ecx
.text$mn:000052AA                 mov     ecx, [ebp+var_10]
.text$mn:000052AD                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000052B2                 mov     [ebp+var_4], 0
.text$mn:000052B9                 mov     ecx, [ebp+var_10]
.text$mn:000052BC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000052C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000052C8                 mov     eax, [ebp+var_10]
.text$mn:000052CB                 mov     ecx, [ebp+var_C]
.text$mn:000052CE                 mov     large fs:0, ecx
.text$mn:000052D5                 pop     ecx
.text$mn:000052D6                 mov     esp, ebp
.text$mn:000052D8                 pop     ebp
.text$mn:000052D9                 retn    4
.text$mn:000052D9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000052D9
.text$mn:000052D9 _text$mn        ends
.text$mn:000052D9
.text$x:000052DC ; ===========================================================================
.text$x:000052DC
.text$x:000052DC ; Segment type: Pure code
.text$x:000052DC ; Segment permissions: Read/Execute
.text$x:000052DC _text$x         segment para public 'CODE' use32
.text$x:000052DC                 assume cs:_text$x
.text$x:000052DC                 ;org 52DCh
.text$x:000052DC ; COMDAT (pick associative to section at 5284)
.text$x:000052DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000052DC
.text$x:000052DC ; =============== S U B R O U T I N E =======================================
.text$x:000052DC
.text$x:000052DC
.text$x:000052DC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000052DC                                         ; DATA XREF: .xdata$x:00009F60o
.text$x:000052DC                 mov     ecx, [ebp-10h]
.text$x:000052DF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000052DF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000052DF
.text$x:000052E4
.text$x:000052E4 ; =============== S U B R O U T I N E =======================================
.text$x:000052E4
.text$x:000052E4
.text$x:000052E4 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000052E4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000052E4
.text$x:000052E4 arg_4           = dword ptr  8
.text$x:000052E4
.text$x:000052E4                 mov     edx, [esp+arg_4]
.text$x:000052E8                 lea     eax, [edx+0Ch]
.text$x:000052EB                 mov     ecx, [edx-8]
.text$x:000052EE                 xor     ecx, eax
.text$x:000052F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000052F5                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000052FA                 jmp     ___CxxFrameHandler3
.text$x:000052FA __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000052FA
.text$x:000052FA ; ---------------------------------------------------------------------------
.text$x:000052FF                 align 10h
.text$x:000052FF _text$x         ends
.text$x:000052FF
.text$mn:00005300 ; ===========================================================================
.text$mn:00005300
.text$mn:00005300 ; Segment type: Pure code
.text$mn:00005300 ; Segment permissions: Read/Execute
.text$mn:00005300 _text$mn        segment para public 'CODE' use32
.text$mn:00005300                 assume cs:_text$mn
.text$mn:00005300                 ;org 5300h
.text$mn:00005300 ; COMDAT (pick any)
.text$mn:00005300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005300
.text$mn:00005300 ; =============== S U B R O U T I N E =======================================
.text$mn:00005300
.text$mn:00005300 ; Attributes: bp-based frame
.text$mn:00005300
.text$mn:00005300 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00005300                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005300 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005300                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(uint,wchar_t)+34p
.text$mn:00005300                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:00005300
.text$mn:00005300 var_10          = dword ptr -10h
.text$mn:00005300 var_C           = dword ptr -0Ch
.text$mn:00005300 var_4           = dword ptr -4
.text$mn:00005300
.text$mn:00005300                 push    ebp
.text$mn:00005301                 mov     ebp, esp
.text$mn:00005303                 push    0FFFFFFFFh
.text$mn:00005305                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000530A                 mov     eax, large fs:0
.text$mn:00005310                 push    eax
.text$mn:00005311                 push    ecx
.text$mn:00005312                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005317                 xor     eax, ebp
.text$mn:00005319                 push    eax
.text$mn:0000531A                 lea     eax, [ebp+var_C]
.text$mn:0000531D                 mov     large fs:0, eax
.text$mn:00005323                 mov     [ebp+var_10], ecx
.text$mn:00005326                 mov     ecx, [ebp+var_10]
.text$mn:00005329                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:0000532E                 mov     [ebp+var_4], 0
.text$mn:00005335                 mov     ecx, [ebp+var_10]
.text$mn:00005338                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:0000533D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005344                 mov     eax, [ebp+var_10]
.text$mn:00005347                 mov     ecx, [ebp+var_C]
.text$mn:0000534A                 mov     large fs:0, ecx
.text$mn:00005351                 pop     ecx
.text$mn:00005352                 mov     esp, ebp
.text$mn:00005354                 pop     ebp
.text$mn:00005355                 retn    4
.text$mn:00005355 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00005355
.text$mn:00005355 _text$mn        ends
.text$mn:00005355
.text$x:00005358 ; ===========================================================================
.text$x:00005358
.text$x:00005358 ; Segment type: Pure code
.text$x:00005358 ; Segment permissions: Read/Execute
.text$x:00005358 _text$x         segment para public 'CODE' use32
.text$x:00005358                 assume cs:_text$x
.text$x:00005358                 ;org 5358h
.text$x:00005358 ; COMDAT (pick associative to section at 5300)
.text$x:00005358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005358
.text$x:00005358 ; =============== S U B R O U T I N E =======================================
.text$x:00005358
.text$x:00005358
.text$x:00005358 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00005358                                         ; DATA XREF: .xdata$x:0000A3A8o
.text$x:00005358                 mov     ecx, [ebp-10h]
.text$x:0000535B                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000535B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:0000535B
.text$x:00005360
.text$x:00005360 ; =============== S U B R O U T I N E =======================================
.text$x:00005360
.text$x:00005360
.text$x:00005360 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00005360                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00005360
.text$x:00005360 arg_4           = dword ptr  8
.text$x:00005360
.text$x:00005360                 mov     edx, [esp+arg_4]
.text$x:00005364                 lea     eax, [edx+0Ch]
.text$x:00005367                 mov     ecx, [edx-8]
.text$x:0000536A                 xor     ecx, eax
.text$x:0000536C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005371                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00005376                 jmp     ___CxxFrameHandler3
.text$x:00005376 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00005376
.text$x:00005376 ; ---------------------------------------------------------------------------
.text$x:0000537B                 align 4
.text$x:0000537B _text$x         ends
.text$x:0000537B
.text$mn:0000537C ; ===========================================================================
.text$mn:0000537C
.text$mn:0000537C ; Segment type: Pure code
.text$mn:0000537C ; Segment permissions: Read/Execute
.text$mn:0000537C _text$mn        segment para public 'CODE' use32
.text$mn:0000537C                 assume cs:_text$mn
.text$mn:0000537C                 ;org 537Ch
.text$mn:0000537C ; COMDAT (pick any)
.text$mn:0000537C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000537C
.text$mn:0000537C ; =============== S U B R O U T I N E =======================================
.text$mn:0000537C
.text$mn:0000537C ; Attributes: bp-based frame
.text$mn:0000537C
.text$mn:0000537C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000537C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000537C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000537C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:0000537C
.text$mn:0000537C var_10          = dword ptr -10h
.text$mn:0000537C var_C           = dword ptr -0Ch
.text$mn:0000537C var_4           = dword ptr -4
.text$mn:0000537C
.text$mn:0000537C                 push    ebp
.text$mn:0000537D                 mov     ebp, esp
.text$mn:0000537F                 push    0FFFFFFFFh
.text$mn:00005381                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005386                 mov     eax, large fs:0
.text$mn:0000538C                 push    eax
.text$mn:0000538D                 push    ecx
.text$mn:0000538E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005393                 xor     eax, ebp
.text$mn:00005395                 push    eax
.text$mn:00005396                 lea     eax, [ebp+var_C]
.text$mn:00005399                 mov     large fs:0, eax
.text$mn:0000539F                 mov     [ebp+var_10], ecx
.text$mn:000053A2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000053A5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000053AA                 mov     [ebp+var_4], 0
.text$mn:000053B1                 mov     eax, [ebp+var_10]
.text$mn:000053B4                 mov     dword ptr [eax+14h], 0
.text$mn:000053BB                 mov     ecx, [ebp+var_10]
.text$mn:000053BE                 mov     dword ptr [ecx+18h], 0
.text$mn:000053C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000053CC                 mov     eax, [ebp+var_10]
.text$mn:000053CF                 mov     ecx, [ebp+var_C]
.text$mn:000053D2                 mov     large fs:0, ecx
.text$mn:000053D9                 pop     ecx
.text$mn:000053DA                 mov     esp, ebp
.text$mn:000053DC                 pop     ebp
.text$mn:000053DD                 retn
.text$mn:000053DD ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000053DD
.text$mn:000053DD ; ---------------------------------------------------------------------------
.text$mn:000053DE                 align 10h
.text$mn:000053DE _text$mn        ends
.text$mn:000053DE
.text$x:000053E0 ; ===========================================================================
.text$x:000053E0
.text$x:000053E0 ; Segment type: Pure code
.text$x:000053E0 ; Segment permissions: Read/Execute
.text$x:000053E0 _text$x         segment para public 'CODE' use32
.text$x:000053E0                 assume cs:_text$x
.text$x:000053E0                 ;org 53E0h
.text$x:000053E0 ; COMDAT (pick associative to section at 537C)
.text$x:000053E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000053E0
.text$x:000053E0 ; =============== S U B R O U T I N E =======================================
.text$x:000053E0
.text$x:000053E0
.text$x:000053E0 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000053E0                                         ; DATA XREF: .xdata$x:00009F08o
.text$x:000053E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000053E3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000053E3 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000053E3
.text$x:000053E8
.text$x:000053E8 ; =============== S U B R O U T I N E =======================================
.text$x:000053E8
.text$x:000053E8
.text$x:000053E8 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000053E8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000053E8
.text$x:000053E8 arg_4           = dword ptr  8
.text$x:000053E8
.text$x:000053E8                 mov     edx, [esp+arg_4]
.text$x:000053EC                 lea     eax, [edx+0Ch]
.text$x:000053EF                 mov     ecx, [edx-8]
.text$x:000053F2                 xor     ecx, eax
.text$x:000053F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000053F9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000053FE                 jmp     ___CxxFrameHandler3
.text$x:000053FE __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000053FE
.text$x:000053FE ; ---------------------------------------------------------------------------
.text$x:00005403                 align 4
.text$x:00005403 _text$x         ends
.text$x:00005403
.text$mn:00005404 ; ===========================================================================
.text$mn:00005404
.text$mn:00005404 ; Segment type: Pure code
.text$mn:00005404 ; Segment permissions: Read/Execute
.text$mn:00005404 _text$mn        segment para public 'CODE' use32
.text$mn:00005404                 assume cs:_text$mn
.text$mn:00005404                 ;org 5404h
.text$mn:00005404 ; COMDAT (pick any)
.text$mn:00005404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005404
.text$mn:00005404 ; =============== S U B R O U T I N E =======================================
.text$mn:00005404
.text$mn:00005404 ; Attributes: bp-based frame
.text$mn:00005404
.text$mn:00005404 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00005404                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00005404 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005404                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00005404
.text$mn:00005404 var_10          = dword ptr -10h
.text$mn:00005404 var_C           = dword ptr -0Ch
.text$mn:00005404 var_4           = dword ptr -4
.text$mn:00005404
.text$mn:00005404                 push    ebp
.text$mn:00005405                 mov     ebp, esp
.text$mn:00005407                 push    0FFFFFFFFh
.text$mn:00005409                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000540E                 mov     eax, large fs:0
.text$mn:00005414                 push    eax
.text$mn:00005415                 push    ecx
.text$mn:00005416                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000541B                 xor     eax, ebp
.text$mn:0000541D                 push    eax
.text$mn:0000541E                 lea     eax, [ebp+var_C]
.text$mn:00005421                 mov     large fs:0, eax
.text$mn:00005427                 mov     [ebp+var_10], ecx
.text$mn:0000542A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000542D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005432                 mov     [ebp+var_4], 0
.text$mn:00005439                 mov     eax, [ebp+var_10]
.text$mn:0000543C                 mov     dword ptr [eax+14h], 0
.text$mn:00005443                 mov     ecx, [ebp+var_10]
.text$mn:00005446                 mov     dword ptr [ecx+18h], 0
.text$mn:0000544D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005454                 mov     eax, [ebp+var_10]
.text$mn:00005457                 mov     ecx, [ebp+var_C]
.text$mn:0000545A                 mov     large fs:0, ecx
.text$mn:00005461                 pop     ecx
.text$mn:00005462                 mov     esp, ebp
.text$mn:00005464                 pop     ebp
.text$mn:00005465                 retn
.text$mn:00005465 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00005465
.text$mn:00005465 ; ---------------------------------------------------------------------------
.text$mn:00005466                 align 4
.text$mn:00005466 _text$mn        ends
.text$mn:00005466
.text$x:00005468 ; ===========================================================================
.text$x:00005468
.text$x:00005468 ; Segment type: Pure code
.text$x:00005468 ; Segment permissions: Read/Execute
.text$x:00005468 _text$x         segment para public 'CODE' use32
.text$x:00005468                 assume cs:_text$x
.text$x:00005468                 ;org 5468h
.text$x:00005468 ; COMDAT (pick associative to section at 5404)
.text$x:00005468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005468
.text$x:00005468 ; =============== S U B R O U T I N E =======================================
.text$x:00005468
.text$x:00005468
.text$x:00005468 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00005468                                         ; DATA XREF: .xdata$x:0000A350o
.text$x:00005468                 mov     ecx, [ebp-10h]  ; this
.text$x:0000546B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000546B __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000546B
.text$x:00005470
.text$x:00005470 ; =============== S U B R O U T I N E =======================================
.text$x:00005470
.text$x:00005470
.text$x:00005470 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00005470                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00005470
.text$x:00005470 arg_4           = dword ptr  8
.text$x:00005470
.text$x:00005470                 mov     edx, [esp+arg_4]
.text$x:00005474                 lea     eax, [edx+0Ch]
.text$x:00005477                 mov     ecx, [edx-8]
.text$x:0000547A                 xor     ecx, eax
.text$x:0000547C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005481                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00005486                 jmp     ___CxxFrameHandler3
.text$x:00005486 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00005486
.text$x:00005486 ; ---------------------------------------------------------------------------
.text$x:0000548B                 align 4
.text$x:0000548B _text$x         ends
.text$x:0000548B
.text$mn:0000548C ; ===========================================================================
.text$mn:0000548C
.text$mn:0000548C ; Segment type: Pure code
.text$mn:0000548C ; Segment permissions: Read/Execute
.text$mn:0000548C _text$mn        segment para public 'CODE' use32
.text$mn:0000548C                 assume cs:_text$mn
.text$mn:0000548C                 ;org 548Ch
.text$mn:0000548C ; COMDAT (pick any)
.text$mn:0000548C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000548C
.text$mn:0000548C ; =============== S U B R O U T I N E =======================================
.text$mn:0000548C
.text$mn:0000548C ; Attributes: bp-based frame
.text$mn:0000548C
.text$mn:0000548C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>(class std::allocator<int> const &)
.text$mn:0000548C                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:0000548C ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$mn:0000548C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+34p
.text$mn:0000548C
.text$mn:0000548C var_10          = dword ptr -10h
.text$mn:0000548C var_C           = dword ptr -0Ch
.text$mn:0000548C var_4           = dword ptr -4
.text$mn:0000548C
.text$mn:0000548C                 push    ebp
.text$mn:0000548D                 mov     ebp, esp
.text$mn:0000548F                 push    0FFFFFFFFh
.text$mn:00005491                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$mn:00005496                 mov     eax, large fs:0
.text$mn:0000549C                 push    eax
.text$mn:0000549D                 push    ecx
.text$mn:0000549E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000054A3                 xor     eax, ebp
.text$mn:000054A5                 push    eax
.text$mn:000054A6                 lea     eax, [ebp+var_C]
.text$mn:000054A9                 mov     large fs:0, eax
.text$mn:000054AF                 mov     [ebp+var_10], ecx
.text$mn:000054B2                 mov     ecx, [ebp+var_10]
.text$mn:000054B5                 call    ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::_Vector_val<std::_Simple_types<int>>(void)
.text$mn:000054BA                 mov     [ebp+var_4], 0
.text$mn:000054C1                 mov     ecx, [ebp+var_10]
.text$mn:000054C4                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)
.text$mn:000054C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000054D0                 mov     eax, [ebp+var_10]
.text$mn:000054D3                 mov     ecx, [ebp+var_C]
.text$mn:000054D6                 mov     large fs:0, ecx
.text$mn:000054DD                 pop     ecx
.text$mn:000054DE                 mov     esp, ebp
.text$mn:000054E0                 pop     ebp
.text$mn:000054E1                 retn    4
.text$mn:000054E1 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$mn:000054E1
.text$mn:000054E1 _text$mn        ends
.text$mn:000054E1
.text$x:000054E4 ; ===========================================================================
.text$x:000054E4
.text$x:000054E4 ; Segment type: Pure code
.text$x:000054E4 ; Segment permissions: Read/Execute
.text$x:000054E4 _text$x         segment para public 'CODE' use32
.text$x:000054E4                 assume cs:_text$x
.text$x:000054E4                 ;org 54E4h
.text$x:000054E4 ; COMDAT (pick associative to section at 548C)
.text$x:000054E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000054E4
.text$x:000054E4 ; =============== S U B R O U T I N E =======================================
.text$x:000054E4
.text$x:000054E4
.text$x:000054E4 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0 proc near
.text$x:000054E4                                         ; DATA XREF: .xdata$x:0000A568o
.text$x:000054E4                 mov     ecx, [ebp-10h]
.text$x:000054E7                 jmp     ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$x:000054E7 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0 endp
.text$x:000054E7
.text$x:000054EC
.text$x:000054EC ; =============== S U B R O U T I N E =======================================
.text$x:000054EC
.text$x:000054EC
.text$x:000054EC __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z proc near
.text$x:000054EC                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+5o
.text$x:000054EC
.text$x:000054EC arg_4           = dword ptr  8
.text$x:000054EC
.text$x:000054EC                 mov     edx, [esp+arg_4]
.text$x:000054F0                 lea     eax, [edx+0Ch]
.text$x:000054F3                 mov     ecx, [edx-8]
.text$x:000054F6                 xor     ecx, eax
.text$x:000054F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000054FD                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.text$x:00005502                 jmp     ___CxxFrameHandler3
.text$x:00005502 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z endp
.text$x:00005502
.text$x:00005502 ; ---------------------------------------------------------------------------
.text$x:00005507                 align 4
.text$x:00005507 _text$x         ends
.text$x:00005507
.text$mn:00005508 ; ===========================================================================
.text$mn:00005508
.text$mn:00005508 ; Segment type: Pure code
.text$mn:00005508 ; Segment permissions: Read/Execute
.text$mn:00005508 _text$mn        segment para public 'CODE' use32
.text$mn:00005508                 assume cs:_text$mn
.text$mn:00005508                 ;org 5508h
.text$mn:00005508 ; COMDAT (pick any)
.text$mn:00005508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005508
.text$mn:00005508 ; =============== S U B R O U T I N E =======================================
.text$mn:00005508
.text$mn:00005508 ; Attributes: bp-based frame
.text$mn:00005508
.text$mn:00005508 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(struct std::_Iterator_base12 *)
.text$mn:00005508                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005508 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005508                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Dp
.text$mn:00005508
.text$mn:00005508 var_10          = dword ptr -10h
.text$mn:00005508 var_C           = dword ptr -0Ch
.text$mn:00005508 var_4           = dword ptr -4
.text$mn:00005508 arg_0           = dword ptr  8
.text$mn:00005508
.text$mn:00005508                 push    ebp
.text$mn:00005509                 mov     ebp, esp
.text$mn:0000550B                 push    0FFFFFFFFh
.text$mn:0000550D                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005512                 mov     eax, large fs:0
.text$mn:00005518                 push    eax
.text$mn:00005519                 push    ecx
.text$mn:0000551A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000551F                 xor     eax, ebp
.text$mn:00005521                 push    eax
.text$mn:00005522                 lea     eax, [ebp+var_C]
.text$mn:00005525                 mov     large fs:0, eax
.text$mn:0000552B                 mov     [ebp+var_10], ecx
.text$mn:0000552E                 mov     eax, [ebp+arg_0]
.text$mn:00005531                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005532                 mov     ecx, [ebp+var_10]
.text$mn:00005535                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)
.text$mn:0000553A                 mov     [ebp+var_4], 0
.text$mn:00005541                 mov     ecx, [ebp+var_10]
.text$mn:00005544                 mov     edx, [ebp+arg_0]
.text$mn:00005547                 mov     eax, [edx+8]
.text$mn:0000554A                 mov     [ecx+8], eax
.text$mn:0000554D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005554                 mov     eax, [ebp+var_10]
.text$mn:00005557                 mov     ecx, [ebp+var_C]
.text$mn:0000555A                 mov     large fs:0, ecx
.text$mn:00005561                 pop     ecx
.text$mn:00005562                 mov     esp, ebp
.text$mn:00005564                 pop     ebp
.text$mn:00005565                 retn    4
.text$mn:00005565 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005565
.text$mn:00005565 _text$mn        ends
.text$mn:00005565
.text$x:00005568 ; ===========================================================================
.text$x:00005568
.text$x:00005568 ; Segment type: Pure code
.text$x:00005568 ; Segment permissions: Read/Execute
.text$x:00005568 _text$x         segment para public 'CODE' use32
.text$x:00005568                 assume cs:_text$x
.text$x:00005568                 ;org 5568h
.text$x:00005568 ; COMDAT (pick associative to section at 5508)
.text$x:00005568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005568
.text$x:00005568 ; =============== S U B R O U T I N E =======================================
.text$x:00005568
.text$x:00005568
.text$x:00005568 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005568                                         ; DATA XREF: .xdata$x:0000AAF0o
.text$x:00005568                 mov     ecx, [ebp-10h]
.text$x:0000556B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:0000556B __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000556B
.text$x:00005570
.text$x:00005570 ; =============== S U B R O U T I N E =======================================
.text$x:00005570
.text$x:00005570
.text$x:00005570 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005570                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+5o
.text$x:00005570
.text$x:00005570 arg_4           = dword ptr  8
.text$x:00005570
.text$x:00005570                 mov     edx, [esp+arg_4]
.text$x:00005574                 lea     eax, [edx+0Ch]
.text$x:00005577                 mov     ecx, [edx-8]
.text$x:0000557A                 xor     ecx, eax
.text$x:0000557C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005581                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005586                 jmp     ___CxxFrameHandler3
.text$x:00005586 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005586
.text$x:00005586 ; ---------------------------------------------------------------------------
.text$x:0000558B                 align 4
.text$x:0000558B _text$x         ends
.text$x:0000558B
.text$mn:0000558C ; ===========================================================================
.text$mn:0000558C
.text$mn:0000558C ; Segment type: Pure code
.text$mn:0000558C ; Segment permissions: Read/Execute
.text$mn:0000558C _text$mn        segment para public 'CODE' use32
.text$mn:0000558C                 assume cs:_text$mn
.text$mn:0000558C                 ;org 558Ch
.text$mn:0000558C ; COMDAT (pick any)
.text$mn:0000558C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000558C
.text$mn:0000558C ; =============== S U B R O U T I N E =======================================
.text$mn:0000558C
.text$mn:0000558C ; Attributes: bp-based frame
.text$mn:0000558C
.text$mn:0000558C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int, struct std::_Container_base12 *)
.text$mn:0000558C                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:0000558C ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$mn:0000558C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+31p
.text$mn:0000558C
.text$mn:0000558C var_10          = dword ptr -10h
.text$mn:0000558C var_C           = dword ptr -0Ch
.text$mn:0000558C var_4           = dword ptr -4
.text$mn:0000558C arg_0           = dword ptr  8
.text$mn:0000558C arg_4           = dword ptr  0Ch
.text$mn:0000558C
.text$mn:0000558C                 push    ebp
.text$mn:0000558D                 mov     ebp, esp
.text$mn:0000558F                 push    0FFFFFFFFh
.text$mn:00005591                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00005596                 mov     eax, large fs:0
.text$mn:0000559C                 push    eax
.text$mn:0000559D                 push    ecx
.text$mn:0000559E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055A3                 xor     eax, ebp
.text$mn:000055A5                 push    eax
.text$mn:000055A6                 lea     eax, [ebp+var_C]
.text$mn:000055A9                 mov     large fs:0, eax
.text$mn:000055AF                 mov     [ebp+var_10], ecx
.text$mn:000055B2                 mov     ecx, [ebp+var_10]
.text$mn:000055B5                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:000055BA                 mov     [ebp+var_4], 0
.text$mn:000055C1                 mov     eax, [ebp+var_10]
.text$mn:000055C4                 mov     ecx, [ebp+arg_0]
.text$mn:000055C7                 mov     [eax+8], ecx
.text$mn:000055CA                 mov     edx, [ebp+arg_4]
.text$mn:000055CD                 push    edx             ; struct std::_Container_base12 *
.text$mn:000055CE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000055D1                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000055D6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055DD                 mov     eax, [ebp+var_10]
.text$mn:000055E0                 mov     ecx, [ebp+var_C]
.text$mn:000055E3                 mov     large fs:0, ecx
.text$mn:000055EA                 pop     ecx
.text$mn:000055EB                 mov     esp, ebp
.text$mn:000055ED                 pop     ebp
.text$mn:000055EE                 retn    8
.text$mn:000055EE ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$mn:000055EE
.text$mn:000055EE ; ---------------------------------------------------------------------------
.text$mn:000055F1                 align 4
.text$mn:000055F1 _text$mn        ends
.text$mn:000055F1
.text$x:000055F4 ; ===========================================================================
.text$x:000055F4
.text$x:000055F4 ; Segment type: Pure code
.text$x:000055F4 ; Segment permissions: Read/Execute
.text$x:000055F4 _text$x         segment para public 'CODE' use32
.text$x:000055F4                 assume cs:_text$x
.text$x:000055F4                 ;org 55F4h
.text$x:000055F4 ; COMDAT (pick associative to section at 558C)
.text$x:000055F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000055F4
.text$x:000055F4 ; =============== S U B R O U T I N E =======================================
.text$x:000055F4
.text$x:000055F4
.text$x:000055F4 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 proc near
.text$x:000055F4                                         ; DATA XREF: .xdata$x:0000AA98o
.text$x:000055F4                 mov     ecx, [ebp-10h]
.text$x:000055F7                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:000055F7 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 endp
.text$x:000055F7
.text$x:000055FC
.text$x:000055FC ; =============== S U B R O U T I N E =======================================
.text$x:000055FC
.text$x:000055FC
.text$x:000055FC __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$x:000055FC                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+5o
.text$x:000055FC
.text$x:000055FC arg_4           = dword ptr  8
.text$x:000055FC
.text$x:000055FC                 mov     edx, [esp+arg_4]
.text$x:00005600                 lea     eax, [edx+0Ch]
.text$x:00005603                 mov     ecx, [edx-8]
.text$x:00005606                 xor     ecx, eax
.text$x:00005608                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000560D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$x:00005612                 jmp     ___CxxFrameHandler3
.text$x:00005612 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$x:00005612
.text$x:00005612 ; ---------------------------------------------------------------------------
.text$x:00005617                 align 4
.text$x:00005617 _text$x         ends
.text$x:00005617
.text$mn:00005618 ; ===========================================================================
.text$mn:00005618
.text$mn:00005618 ; Segment type: Pure code
.text$mn:00005618 ; Segment permissions: Read/Execute
.text$mn:00005618 _text$mn        segment para public 'CODE' use32
.text$mn:00005618                 assume cs:_text$mn
.text$mn:00005618                 ;org 5618h
.text$mn:00005618 ; COMDAT (pick any)
.text$mn:00005618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005618
.text$mn:00005618 ; =============== S U B R O U T I N E =======================================
.text$mn:00005618
.text$mn:00005618 ; Attributes: bp-based frame
.text$mn:00005618
.text$mn:00005618 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(struct std::_Iterator_base12 *)
.text$mn:00005618                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005618 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005618                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+2Dp
.text$mn:00005618
.text$mn:00005618 var_10          = dword ptr -10h
.text$mn:00005618 var_C           = dword ptr -0Ch
.text$mn:00005618 var_4           = dword ptr -4
.text$mn:00005618 arg_0           = dword ptr  8
.text$mn:00005618
.text$mn:00005618                 push    ebp
.text$mn:00005619                 mov     ebp, esp
.text$mn:0000561B                 push    0FFFFFFFFh
.text$mn:0000561D                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005622                 mov     eax, large fs:0
.text$mn:00005628                 push    eax
.text$mn:00005629                 push    ecx
.text$mn:0000562A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000562F                 xor     eax, ebp
.text$mn:00005631                 push    eax
.text$mn:00005632                 lea     eax, [ebp+var_C]
.text$mn:00005635                 mov     large fs:0, eax
.text$mn:0000563B                 mov     [ebp+var_10], ecx
.text$mn:0000563E                 mov     eax, [ebp+arg_0]
.text$mn:00005641                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005642                 mov     ecx, [ebp+var_10]
.text$mn:00005645                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12> const &)
.text$mn:0000564A                 mov     [ebp+var_4], 0
.text$mn:00005651                 mov     ecx, [ebp+var_10]
.text$mn:00005654                 mov     edx, [ebp+arg_0]
.text$mn:00005657                 mov     eax, [edx+8]
.text$mn:0000565A                 mov     [ecx+8], eax
.text$mn:0000565D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005664                 mov     eax, [ebp+var_10]
.text$mn:00005667                 mov     ecx, [ebp+var_C]
.text$mn:0000566A                 mov     large fs:0, ecx
.text$mn:00005671                 pop     ecx
.text$mn:00005672                 mov     esp, ebp
.text$mn:00005674                 pop     ebp
.text$mn:00005675                 retn    4
.text$mn:00005675 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005675
.text$mn:00005675 _text$mn        ends
.text$mn:00005675
.text$x:00005678 ; ===========================================================================
.text$x:00005678
.text$x:00005678 ; Segment type: Pure code
.text$x:00005678 ; Segment permissions: Read/Execute
.text$x:00005678 _text$x         segment para public 'CODE' use32
.text$x:00005678                 assume cs:_text$x
.text$x:00005678                 ;org 5678h
.text$x:00005678 ; COMDAT (pick associative to section at 5618)
.text$x:00005678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005678
.text$x:00005678 ; =============== S U B R O U T I N E =======================================
.text$x:00005678
.text$x:00005678
.text$x:00005678 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005678                                         ; DATA XREF: .xdata$x:0000A8BCo
.text$x:00005678                 mov     ecx, [ebp-10h]
.text$x:0000567B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)
.text$x:0000567B __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000567B
.text$x:00005680
.text$x:00005680 ; =============== S U B R O U T I N E =======================================
.text$x:00005680
.text$x:00005680
.text$x:00005680 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005680                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+5o
.text$x:00005680
.text$x:00005680 arg_4           = dword ptr  8
.text$x:00005680
.text$x:00005680                 mov     edx, [esp+arg_4]
.text$x:00005684                 lea     eax, [edx+0Ch]
.text$x:00005687                 mov     ecx, [edx-8]
.text$x:0000568A                 xor     ecx, eax
.text$x:0000568C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005691                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005696                 jmp     ___CxxFrameHandler3
.text$x:00005696 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005696
.text$x:00005696 ; ---------------------------------------------------------------------------
.text$x:0000569B                 align 4
.text$x:0000569B _text$x         ends
.text$x:0000569B
.text$mn:0000569C ; ===========================================================================
.text$mn:0000569C
.text$mn:0000569C ; Segment type: Pure code
.text$mn:0000569C ; Segment permissions: Read/Execute
.text$mn:0000569C _text$mn        segment para public 'CODE' use32
.text$mn:0000569C                 assume cs:_text$mn
.text$mn:0000569C                 ;org 569Ch
.text$mn:0000569C ; COMDAT (pick any)
.text$mn:0000569C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000569C
.text$mn:0000569C ; =============== S U B R O U T I N E =======================================
.text$mn:0000569C
.text$mn:0000569C ; Attributes: bp-based frame
.text$mn:0000569C
.text$mn:0000569C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(int, struct std::_Container_base12 *)
.text$mn:0000569C                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.text$mn:0000569C ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z proc near
.text$mn:0000569C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)+31p
.text$mn:0000569C
.text$mn:0000569C var_10          = dword ptr -10h
.text$mn:0000569C var_C           = dword ptr -0Ch
.text$mn:0000569C var_4           = dword ptr -4
.text$mn:0000569C arg_0           = dword ptr  8
.text$mn:0000569C arg_4           = dword ptr  0Ch
.text$mn:0000569C
.text$mn:0000569C                 push    ebp
.text$mn:0000569D                 mov     ebp, esp
.text$mn:0000569F                 push    0FFFFFFFFh
.text$mn:000056A1                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.text$mn:000056A6                 mov     eax, large fs:0
.text$mn:000056AC                 push    eax
.text$mn:000056AD                 push    ecx
.text$mn:000056AE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000056B3                 xor     eax, ebp
.text$mn:000056B5                 push    eax
.text$mn:000056B6                 lea     eax, [ebp+var_C]
.text$mn:000056B9                 mov     large fs:0, eax
.text$mn:000056BF                 mov     [ebp+var_10], ecx
.text$mn:000056C2                 mov     ecx, [ebp+var_10]
.text$mn:000056C5                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)
.text$mn:000056CA                 mov     [ebp+var_4], 0
.text$mn:000056D1                 mov     eax, [ebp+var_10]
.text$mn:000056D4                 mov     ecx, [ebp+arg_0]
.text$mn:000056D7                 mov     [eax+8], ecx
.text$mn:000056DA                 mov     edx, [ebp+arg_4]
.text$mn:000056DD                 push    edx             ; struct std::_Container_base12 *
.text$mn:000056DE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000056E1                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000056E6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056ED                 mov     eax, [ebp+var_10]
.text$mn:000056F0                 mov     ecx, [ebp+var_C]
.text$mn:000056F3                 mov     large fs:0, ecx
.text$mn:000056FA                 pop     ecx
.text$mn:000056FB                 mov     esp, ebp
.text$mn:000056FD                 pop     ebp
.text$mn:000056FE                 retn    8
.text$mn:000056FE ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z endp
.text$mn:000056FE
.text$mn:000056FE ; ---------------------------------------------------------------------------
.text$mn:00005701                 align 4
.text$mn:00005701 _text$mn        ends
.text$mn:00005701
.text$x:00005704 ; ===========================================================================
.text$x:00005704
.text$x:00005704 ; Segment type: Pure code
.text$x:00005704 ; Segment permissions: Read/Execute
.text$x:00005704 _text$x         segment para public 'CODE' use32
.text$x:00005704                 assume cs:_text$x
.text$x:00005704                 ;org 5704h
.text$x:00005704 ; COMDAT (pick associative to section at 569C)
.text$x:00005704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005704
.text$x:00005704 ; =============== S U B R O U T I N E =======================================
.text$x:00005704
.text$x:00005704
.text$x:00005704 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0 proc near
.text$x:00005704                                         ; DATA XREF: .xdata$x:0000A864o
.text$x:00005704                 mov     ecx, [ebp-10h]
.text$x:00005707                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)
.text$x:00005707 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0 endp
.text$x:00005707
.text$x:0000570C
.text$x:0000570C ; =============== S U B R O U T I N E =======================================
.text$x:0000570C
.text$x:0000570C
.text$x:0000570C __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z proc near
.text$x:0000570C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)+5o
.text$x:0000570C
.text$x:0000570C arg_4           = dword ptr  8
.text$x:0000570C
.text$x:0000570C                 mov     edx, [esp+arg_4]
.text$x:00005710                 lea     eax, [edx+0Ch]
.text$x:00005713                 mov     ecx, [edx-8]
.text$x:00005716                 xor     ecx, eax
.text$x:00005718                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000571D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.text$x:00005722                 jmp     ___CxxFrameHandler3
.text$x:00005722 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z endp
.text$x:00005722
.text$x:00005722 ; ---------------------------------------------------------------------------
.text$x:00005727                 align 4
.text$x:00005727 _text$x         ends
.text$x:00005727
.text$mn:00005728 ; ===========================================================================
.text$mn:00005728
.text$mn:00005728 ; Segment type: Pure code
.text$mn:00005728 ; Segment permissions: Read/Execute
.text$mn:00005728 _text$mn        segment para public 'CODE' use32
.text$mn:00005728                 assume cs:_text$mn
.text$mn:00005728                 ;org 5728h
.text$mn:00005728 ; COMDAT (pick any)
.text$mn:00005728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005728
.text$mn:00005728 ; =============== S U B R O U T I N E =======================================
.text$mn:00005728
.text$mn:00005728 ; Attributes: bp-based frame
.text$mn:00005728
.text$mn:00005728 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(struct std::_Iterator_base12 *)
.text$mn:00005728                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005728 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005728                                         ; CODE XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>> const &)+2Dp
.text$mn:00005728                                         ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+34p ...
.text$mn:00005728
.text$mn:00005728 var_10          = dword ptr -10h
.text$mn:00005728 var_C           = dword ptr -0Ch
.text$mn:00005728 var_4           = dword ptr -4
.text$mn:00005728 arg_0           = dword ptr  8
.text$mn:00005728
.text$mn:00005728                 push    ebp
.text$mn:00005729                 mov     ebp, esp
.text$mn:0000572B                 push    0FFFFFFFFh
.text$mn:0000572D                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005732                 mov     eax, large fs:0
.text$mn:00005738                 push    eax
.text$mn:00005739                 push    ecx
.text$mn:0000573A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000573F                 xor     eax, ebp
.text$mn:00005741                 push    eax
.text$mn:00005742                 lea     eax, [ebp+var_C]
.text$mn:00005745                 mov     large fs:0, eax
.text$mn:0000574B                 mov     [ebp+var_10], ecx
.text$mn:0000574E                 mov     eax, [ebp+arg_0]
.text$mn:00005751                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005752                 mov     ecx, [ebp+var_10]
.text$mn:00005755                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000575A                 mov     [ebp+var_4], 0
.text$mn:00005761                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005768                 mov     eax, [ebp+var_10]
.text$mn:0000576B                 mov     ecx, [ebp+var_C]
.text$mn:0000576E                 mov     large fs:0, ecx
.text$mn:00005775                 pop     ecx
.text$mn:00005776                 mov     esp, ebp
.text$mn:00005778                 pop     ebp
.text$mn:00005779                 retn    4
.text$mn:00005779 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005779
.text$mn:00005779 _text$mn        ends
.text$mn:00005779
.text$x:0000577C ; ===========================================================================
.text$x:0000577C
.text$x:0000577C ; Segment type: Pure code
.text$x:0000577C ; Segment permissions: Read/Execute
.text$x:0000577C _text$x         segment para public 'CODE' use32
.text$x:0000577C                 assume cs:_text$x
.text$x:0000577C                 ;org 577Ch
.text$x:0000577C ; COMDAT (pick associative to section at 5728)
.text$x:0000577C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000577C
.text$x:0000577C ; =============== S U B R O U T I N E =======================================
.text$x:0000577C
.text$x:0000577C
.text$x:0000577C __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000577C                                         ; DATA XREF: .xdata$x:0000AB74o
.text$x:0000577C                 mov     ecx, [ebp-10h]
.text$x:0000577F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000577F __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000577F
.text$x:00005784
.text$x:00005784 ; =============== S U B R O U T I N E =======================================
.text$x:00005784
.text$x:00005784
.text$x:00005784 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005784                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+5o
.text$x:00005784
.text$x:00005784 arg_4           = dword ptr  8
.text$x:00005784
.text$x:00005784                 mov     edx, [esp+arg_4]
.text$x:00005788                 lea     eax, [edx+0Ch]
.text$x:0000578B                 mov     ecx, [edx-8]
.text$x:0000578E                 xor     ecx, eax
.text$x:00005790                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005795                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000579A                 jmp     ___CxxFrameHandler3
.text$x:0000579A __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000579A
.text$x:0000579A ; ---------------------------------------------------------------------------
.text$x:0000579F                 align 10h
.text$x:0000579F _text$x         ends
.text$x:0000579F
.text$mn:000057A0 ; ===========================================================================
.text$mn:000057A0
.text$mn:000057A0 ; Segment type: Pure code
.text$mn:000057A0 ; Segment permissions: Read/Execute
.text$mn:000057A0 _text$mn        segment para public 'CODE' use32
.text$mn:000057A0                 assume cs:_text$mn
.text$mn:000057A0                 ;org 57A0h
.text$mn:000057A0 ; COMDAT (pick any)
.text$mn:000057A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057A0
.text$mn:000057A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000057A0
.text$mn:000057A0 ; Attributes: bp-based frame
.text$mn:000057A0
.text$mn:000057A0 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int, struct std::_Container_base12 *)
.text$mn:000057A0                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:000057A0 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$mn:000057A0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::end(void)+3Dp
.text$mn:000057A0
.text$mn:000057A0 var_10          = dword ptr -10h
.text$mn:000057A0 var_C           = dword ptr -0Ch
.text$mn:000057A0 var_4           = dword ptr -4
.text$mn:000057A0 arg_0           = dword ptr  8
.text$mn:000057A0 arg_4           = dword ptr  0Ch
.text$mn:000057A0
.text$mn:000057A0                 push    ebp
.text$mn:000057A1                 mov     ebp, esp
.text$mn:000057A3                 push    0FFFFFFFFh
.text$mn:000057A5                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:000057AA                 mov     eax, large fs:0
.text$mn:000057B0                 push    eax
.text$mn:000057B1                 push    ecx
.text$mn:000057B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000057B7                 xor     eax, ebp
.text$mn:000057B9                 push    eax
.text$mn:000057BA                 lea     eax, [ebp+var_C]
.text$mn:000057BD                 mov     large fs:0, eax
.text$mn:000057C3                 mov     [ebp+var_10], ecx
.text$mn:000057C6                 mov     eax, [ebp+arg_4]
.text$mn:000057C9                 push    eax             ; struct std::_Container_base12 *
.text$mn:000057CA                 mov     ecx, [ebp+arg_0]
.text$mn:000057CD                 push    ecx             ; int
.text$mn:000057CE                 mov     ecx, [ebp+var_10]
.text$mn:000057D1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:000057D6                 mov     [ebp+var_4], 0
.text$mn:000057DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000057E4                 mov     eax, [ebp+var_10]
.text$mn:000057E7                 mov     ecx, [ebp+var_C]
.text$mn:000057EA                 mov     large fs:0, ecx
.text$mn:000057F1                 pop     ecx
.text$mn:000057F2                 mov     esp, ebp
.text$mn:000057F4                 pop     ebp
.text$mn:000057F5                 retn    8
.text$mn:000057F5 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$mn:000057F5
.text$mn:000057F5 _text$mn        ends
.text$mn:000057F5
.text$x:000057F8 ; ===========================================================================
.text$x:000057F8
.text$x:000057F8 ; Segment type: Pure code
.text$x:000057F8 ; Segment permissions: Read/Execute
.text$x:000057F8 _text$x         segment para public 'CODE' use32
.text$x:000057F8                 assume cs:_text$x
.text$x:000057F8                 ;org 57F8h
.text$x:000057F8 ; COMDAT (pick associative to section at 57A0)
.text$x:000057F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000057F8
.text$x:000057F8 ; =============== S U B R O U T I N E =======================================
.text$x:000057F8
.text$x:000057F8
.text$x:000057F8 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 proc near
.text$x:000057F8                                         ; DATA XREF: .xdata$x:0000AB1Co
.text$x:000057F8                 mov     ecx, [ebp-10h]
.text$x:000057FB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000057FB __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 endp
.text$x:000057FB
.text$x:00005800
.text$x:00005800 ; =============== S U B R O U T I N E =======================================
.text$x:00005800
.text$x:00005800
.text$x:00005800 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$x:00005800                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+5o
.text$x:00005800
.text$x:00005800 arg_4           = dword ptr  8
.text$x:00005800
.text$x:00005800                 mov     edx, [esp+arg_4]
.text$x:00005804                 lea     eax, [edx+0Ch]
.text$x:00005807                 mov     ecx, [edx-8]
.text$x:0000580A                 xor     ecx, eax
.text$x:0000580C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005811                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$x:00005816                 jmp     ___CxxFrameHandler3
.text$x:00005816 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$x:00005816
.text$x:00005816 ; ---------------------------------------------------------------------------
.text$x:0000581B                 align 4
.text$x:0000581B _text$x         ends
.text$x:0000581B
.text$mn:0000581C ; ===========================================================================
.text$mn:0000581C
.text$mn:0000581C ; Segment type: Pure code
.text$mn:0000581C ; Segment permissions: Read/Execute
.text$mn:0000581C _text$mn        segment para public 'CODE' use32
.text$mn:0000581C                 assume cs:_text$mn
.text$mn:0000581C                 ;org 581Ch
.text$mn:0000581C ; COMDAT (pick any)
.text$mn:0000581C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000581C
.text$mn:0000581C ; =============== S U B R O U T I N E =======================================
.text$mn:0000581C
.text$mn:0000581C ; Attributes: bp-based frame
.text$mn:0000581C
.text$mn:0000581C ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(struct std::_Iterator_base12 *)
.text$mn:0000581C                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000581C ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000581C                                         ; CODE XREF: std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint)+56p
.text$mn:0000581C                                         ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint)+74p ...
.text$mn:0000581C
.text$mn:0000581C var_10          = dword ptr -10h
.text$mn:0000581C var_C           = dword ptr -0Ch
.text$mn:0000581C var_4           = dword ptr -4
.text$mn:0000581C arg_0           = dword ptr  8
.text$mn:0000581C
.text$mn:0000581C                 push    ebp
.text$mn:0000581D                 mov     ebp, esp
.text$mn:0000581F                 push    0FFFFFFFFh
.text$mn:00005821                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005826                 mov     eax, large fs:0
.text$mn:0000582C                 push    eax
.text$mn:0000582D                 push    ecx
.text$mn:0000582E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005833                 xor     eax, ebp
.text$mn:00005835                 push    eax
.text$mn:00005836                 lea     eax, [ebp+var_C]
.text$mn:00005839                 mov     large fs:0, eax
.text$mn:0000583F                 mov     [ebp+var_10], ecx
.text$mn:00005842                 mov     eax, [ebp+arg_0]
.text$mn:00005845                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005846                 mov     ecx, [ebp+var_10]
.text$mn:00005849                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:0000584E                 mov     [ebp+var_4], 0
.text$mn:00005855                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000585C                 mov     eax, [ebp+var_10]
.text$mn:0000585F                 mov     ecx, [ebp+var_C]
.text$mn:00005862                 mov     large fs:0, ecx
.text$mn:00005869                 pop     ecx
.text$mn:0000586A                 mov     esp, ebp
.text$mn:0000586C                 pop     ebp
.text$mn:0000586D                 retn    4
.text$mn:0000586D ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:0000586D
.text$mn:0000586D _text$mn        ends
.text$mn:0000586D
.text$x:00005870 ; ===========================================================================
.text$x:00005870
.text$x:00005870 ; Segment type: Pure code
.text$x:00005870 ; Segment permissions: Read/Execute
.text$x:00005870 _text$x         segment para public 'CODE' use32
.text$x:00005870                 assume cs:_text$x
.text$x:00005870                 ;org 5870h
.text$x:00005870 ; COMDAT (pick associative to section at 581C)
.text$x:00005870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005870
.text$x:00005870 ; =============== S U B R O U T I N E =======================================
.text$x:00005870
.text$x:00005870
.text$x:00005870 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005870                                         ; DATA XREF: .xdata$x:0000A940o
.text$x:00005870                 mov     ecx, [ebp-10h]
.text$x:00005873                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00005873 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005873
.text$x:00005878
.text$x:00005878 ; =============== S U B R O U T I N E =======================================
.text$x:00005878
.text$x:00005878
.text$x:00005878 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005878                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+5o
.text$x:00005878
.text$x:00005878 arg_4           = dword ptr  8
.text$x:00005878
.text$x:00005878                 mov     edx, [esp+arg_4]
.text$x:0000587C                 lea     eax, [edx+0Ch]
.text$x:0000587F                 mov     ecx, [edx-8]
.text$x:00005882                 xor     ecx, eax
.text$x:00005884                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005889                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000588E                 jmp     ___CxxFrameHandler3
.text$x:0000588E __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000588E
.text$x:0000588E ; ---------------------------------------------------------------------------
.text$x:00005893                 align 4
.text$x:00005893 _text$x         ends
.text$x:00005893
.text$mn:00005894 ; ===========================================================================
.text$mn:00005894
.text$mn:00005894 ; Segment type: Pure code
.text$mn:00005894 ; Segment permissions: Read/Execute
.text$mn:00005894 _text$mn        segment para public 'CODE' use32
.text$mn:00005894                 assume cs:_text$mn
.text$mn:00005894                 ;org 5894h
.text$mn:00005894 ; COMDAT (pick any)
.text$mn:00005894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005894
.text$mn:00005894 ; =============== S U B R O U T I N E =======================================
.text$mn:00005894
.text$mn:00005894 ; Attributes: bp-based frame
.text$mn:00005894
.text$mn:00005894 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(int, struct std::_Container_base12 *)
.text$mn:00005894                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.text$mn:00005894 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z proc near
.text$mn:00005894                                         ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::begin(void)+3Dp
.text$mn:00005894                                         ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::end(void)+3Dp
.text$mn:00005894
.text$mn:00005894 var_10          = dword ptr -10h
.text$mn:00005894 var_C           = dword ptr -0Ch
.text$mn:00005894 var_4           = dword ptr -4
.text$mn:00005894 arg_0           = dword ptr  8
.text$mn:00005894 arg_4           = dword ptr  0Ch
.text$mn:00005894
.text$mn:00005894                 push    ebp
.text$mn:00005895                 mov     ebp, esp
.text$mn:00005897                 push    0FFFFFFFFh
.text$mn:00005899                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.text$mn:0000589E                 mov     eax, large fs:0
.text$mn:000058A4                 push    eax
.text$mn:000058A5                 push    ecx
.text$mn:000058A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000058AB                 xor     eax, ebp
.text$mn:000058AD                 push    eax
.text$mn:000058AE                 lea     eax, [ebp+var_C]
.text$mn:000058B1                 mov     large fs:0, eax
.text$mn:000058B7                 mov     [ebp+var_10], ecx
.text$mn:000058BA                 mov     eax, [ebp+arg_4]
.text$mn:000058BD                 push    eax             ; struct std::_Container_base12 *
.text$mn:000058BE                 mov     ecx, [ebp+arg_0]
.text$mn:000058C1                 push    ecx             ; int
.text$mn:000058C2                 mov     ecx, [ebp+var_10]
.text$mn:000058C5                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)
.text$mn:000058CA                 mov     [ebp+var_4], 0
.text$mn:000058D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000058D8                 mov     eax, [ebp+var_10]
.text$mn:000058DB                 mov     ecx, [ebp+var_C]
.text$mn:000058DE                 mov     large fs:0, ecx
.text$mn:000058E5                 pop     ecx
.text$mn:000058E6                 mov     esp, ebp
.text$mn:000058E8                 pop     ebp
.text$mn:000058E9                 retn    8
.text$mn:000058E9 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z endp
.text$mn:000058E9
.text$mn:000058E9 _text$mn        ends
.text$mn:000058E9
.text$x:000058EC ; ===========================================================================
.text$x:000058EC
.text$x:000058EC ; Segment type: Pure code
.text$x:000058EC ; Segment permissions: Read/Execute
.text$x:000058EC _text$x         segment para public 'CODE' use32
.text$x:000058EC                 assume cs:_text$x
.text$x:000058EC                 ;org 58ECh
.text$x:000058EC ; COMDAT (pick associative to section at 5894)
.text$x:000058EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000058EC
.text$x:000058EC ; =============== S U B R O U T I N E =======================================
.text$x:000058EC
.text$x:000058EC
.text$x:000058EC __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0 proc near
.text$x:000058EC                                         ; DATA XREF: .xdata$x:0000A8E8o
.text$x:000058EC                 mov     ecx, [ebp-10h]
.text$x:000058EF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:000058EF __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0 endp
.text$x:000058EF
.text$x:000058F4
.text$x:000058F4 ; =============== S U B R O U T I N E =======================================
.text$x:000058F4
.text$x:000058F4
.text$x:000058F4 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z proc near
.text$x:000058F4                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)+5o
.text$x:000058F4
.text$x:000058F4 arg_4           = dword ptr  8
.text$x:000058F4
.text$x:000058F4                 mov     edx, [esp+arg_4]
.text$x:000058F8                 lea     eax, [edx+0Ch]
.text$x:000058FB                 mov     ecx, [edx-8]
.text$x:000058FE                 xor     ecx, eax
.text$x:00005900                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005905                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.text$x:0000590A                 jmp     ___CxxFrameHandler3
.text$x:0000590A __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z endp
.text$x:0000590A
.text$x:0000590A ; ---------------------------------------------------------------------------
.text$x:0000590F                 align 10h
.text$x:0000590F _text$x         ends
.text$x:0000590F
.text$mn:00005910 ; ===========================================================================
.text$mn:00005910
.text$mn:00005910 ; Segment type: Pure code
.text$mn:00005910 ; Segment permissions: Read/Execute
.text$mn:00005910 _text$mn        segment para public 'CODE' use32
.text$mn:00005910                 assume cs:_text$mn
.text$mn:00005910                 ;org 5910h
.text$mn:00005910 ; COMDAT (pick any)
.text$mn:00005910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005910
.text$mn:00005910 ; =============== S U B R O U T I N E =======================================
.text$mn:00005910
.text$mn:00005910 ; Attributes: bp-based frame
.text$mn:00005910
.text$mn:00005910 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<int>>::_Vector_val<struct std::_Simple_types<int>>(void)
.text$mn:00005910                 public ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:00005910 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$mn:00005910                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+29p
.text$mn:00005910
.text$mn:00005910 var_10          = dword ptr -10h
.text$mn:00005910 var_C           = dword ptr -0Ch
.text$mn:00005910 var_4           = dword ptr -4
.text$mn:00005910
.text$mn:00005910                 push    ebp
.text$mn:00005911                 mov     ebp, esp
.text$mn:00005913                 push    0FFFFFFFFh
.text$mn:00005915                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:0000591A                 mov     eax, large fs:0
.text$mn:00005920                 push    eax
.text$mn:00005921                 push    ecx
.text$mn:00005922                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005927                 xor     eax, ebp
.text$mn:00005929                 push    eax
.text$mn:0000592A                 lea     eax, [ebp+var_C]
.text$mn:0000592D                 mov     large fs:0, eax
.text$mn:00005933                 mov     [ebp+var_10], ecx
.text$mn:00005936                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005939                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000593E                 mov     [ebp+var_4], 0
.text$mn:00005945                 mov     eax, [ebp+var_10]
.text$mn:00005948                 mov     dword ptr [eax+4], 0
.text$mn:0000594F                 mov     ecx, [ebp+var_10]
.text$mn:00005952                 mov     dword ptr [ecx+8], 0
.text$mn:00005959                 mov     edx, [ebp+var_10]
.text$mn:0000595C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005963                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000596A                 mov     eax, [ebp+var_10]
.text$mn:0000596D                 mov     ecx, [ebp+var_C]
.text$mn:00005970                 mov     large fs:0, ecx
.text$mn:00005977                 pop     ecx
.text$mn:00005978                 mov     esp, ebp
.text$mn:0000597A                 pop     ebp
.text$mn:0000597B                 retn
.text$mn:0000597B ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$mn:0000597B
.text$mn:0000597B _text$mn        ends
.text$mn:0000597B
.text$x:0000597C ; ===========================================================================
.text$x:0000597C
.text$x:0000597C ; Segment type: Pure code
.text$x:0000597C ; Segment permissions: Read/Execute
.text$x:0000597C _text$x         segment para public 'CODE' use32
.text$x:0000597C                 assume cs:_text$x
.text$x:0000597C                 ;org 597Ch
.text$x:0000597C ; COMDAT (pick associative to section at 5910)
.text$x:0000597C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000597C
.text$x:0000597C ; =============== S U B R O U T I N E =======================================
.text$x:0000597C
.text$x:0000597C
.text$x:0000597C __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 proc near
.text$x:0000597C                                         ; DATA XREF: .xdata$x:0000A510o
.text$x:0000597C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000597F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000597F __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 endp
.text$x:0000597F
.text$x:00005984
.text$x:00005984 ; =============== S U B R O U T I N E =======================================
.text$x:00005984
.text$x:00005984
.text$x:00005984 __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$x:00005984                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<int>>::_Vector_val<std::_Simple_types<int>>(void)+5o
.text$x:00005984
.text$x:00005984 arg_4           = dword ptr  8
.text$x:00005984
.text$x:00005984                 mov     edx, [esp+arg_4]
.text$x:00005988                 lea     eax, [edx+0Ch]
.text$x:0000598B                 mov     ecx, [edx-8]
.text$x:0000598E                 xor     ecx, eax
.text$x:00005990                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005995                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$x:0000599A                 jmp     ___CxxFrameHandler3
.text$x:0000599A __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$x:0000599A
.text$x:0000599A ; ---------------------------------------------------------------------------
.text$x:0000599F                 align 10h
.text$x:0000599F _text$x         ends
.text$x:0000599F
.text$mn:000059A0 ; ===========================================================================
.text$mn:000059A0
.text$mn:000059A0 ; Segment type: Pure code
.text$mn:000059A0 ; Segment permissions: Read/Execute
.text$mn:000059A0 _text$mn        segment para public 'CODE' use32
.text$mn:000059A0                 assume cs:_text$mn
.text$mn:000059A0                 ;org 59A0h
.text$mn:000059A0 ; COMDAT (pick any)
.text$mn:000059A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000059A0
.text$mn:000059A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000059A0
.text$mn:000059A0 ; Attributes: bp-based frame
.text$mn:000059A0
.text$mn:000059A0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000059A0                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000059A0 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000059A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000059A0
.text$mn:000059A0 var_4           = dword ptr -4
.text$mn:000059A0
.text$mn:000059A0                 push    ebp
.text$mn:000059A1                 mov     ebp, esp
.text$mn:000059A3                 push    ecx
.text$mn:000059A4                 mov     [ebp+var_4], ecx
.text$mn:000059A7                 mov     ecx, [ebp+var_4]
.text$mn:000059AA                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000059AF                 mov     eax, [ebp+var_4]
.text$mn:000059B2                 mov     esp, ebp
.text$mn:000059B4                 pop     ebp
.text$mn:000059B5                 retn
.text$mn:000059B5 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000059B5
.text$mn:000059B5 ; ---------------------------------------------------------------------------
.text$mn:000059B6                 align 4
.text$mn:000059B6 _text$mn        ends
.text$mn:000059B6
.text$mn:000059B8 ; ===========================================================================
.text$mn:000059B8
.text$mn:000059B8 ; Segment type: Pure code
.text$mn:000059B8 ; Segment permissions: Read/Execute
.text$mn:000059B8 _text$mn        segment para public 'CODE' use32
.text$mn:000059B8                 assume cs:_text$mn
.text$mn:000059B8                 ;org 59B8h
.text$mn:000059B8 ; COMDAT (pick any)
.text$mn:000059B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000059B8
.text$mn:000059B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000059B8
.text$mn:000059B8 ; Attributes: bp-based frame
.text$mn:000059B8
.text$mn:000059B8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<int>>::_Wrap_alloc<class std::allocator<int>>(void)
.text$mn:000059B8                 public ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ
.text$mn:000059B8 ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:000059B8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)+Ap
.text$mn:000059B8
.text$mn:000059B8 var_4           = dword ptr -4
.text$mn:000059B8
.text$mn:000059B8                 push    ebp
.text$mn:000059B9                 mov     ebp, esp
.text$mn:000059BB                 push    ecx
.text$mn:000059BC                 mov     [ebp+var_4], ecx
.text$mn:000059BF                 mov     ecx, [ebp+var_4]
.text$mn:000059C2                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:000059C7                 mov     eax, [ebp+var_4]
.text$mn:000059CA                 mov     esp, ebp
.text$mn:000059CC                 pop     ebp
.text$mn:000059CD                 retn
.text$mn:000059CD ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:000059CD
.text$mn:000059CD ; ---------------------------------------------------------------------------
.text$mn:000059CE                 align 10h
.text$mn:000059CE _text$mn        ends
.text$mn:000059CE
.text$mn:000059D0 ; ===========================================================================
.text$mn:000059D0
.text$mn:000059D0 ; Segment type: Pure code
.text$mn:000059D0 ; Segment permissions: Read/Execute
.text$mn:000059D0 _text$mn        segment para public 'CODE' use32
.text$mn:000059D0                 assume cs:_text$mn
.text$mn:000059D0                 ;org 59D0h
.text$mn:000059D0 ; COMDAT (pick any)
.text$mn:000059D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000059D0
.text$mn:000059D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000059D0
.text$mn:000059D0 ; Attributes: bp-based frame
.text$mn:000059D0
.text$mn:000059D0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>>::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>>(void)
.text$mn:000059D0                 public ??0?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ
.text$mn:000059D0 ??0?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:000059D0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::_Getal(void)+Ap
.text$mn:000059D0
.text$mn:000059D0 var_4           = dword ptr -4
.text$mn:000059D0
.text$mn:000059D0                 push    ebp
.text$mn:000059D1                 mov     ebp, esp
.text$mn:000059D3                 push    ecx
.text$mn:000059D4                 mov     [ebp+var_4], ecx
.text$mn:000059D7                 mov     ecx, [ebp+var_4]
.text$mn:000059DA                 call    ??0?$allocator@UColumnModeInfo@@@std@@QAE@XZ ; std::allocator<ColumnModeInfo>::allocator<ColumnModeInfo>(void)
.text$mn:000059DF                 mov     eax, [ebp+var_4]
.text$mn:000059E2                 mov     esp, ebp
.text$mn:000059E4                 pop     ebp
.text$mn:000059E5                 retn
.text$mn:000059E5 ??0?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ endp
.text$mn:000059E5
.text$mn:000059E5 ; ---------------------------------------------------------------------------
.text$mn:000059E6                 align 4
.text$mn:000059E6 _text$mn        ends
.text$mn:000059E6
.text$mn:000059E8 ; ===========================================================================
.text$mn:000059E8
.text$mn:000059E8 ; Segment type: Pure code
.text$mn:000059E8 ; Segment permissions: Read/Execute
.text$mn:000059E8 _text$mn        segment para public 'CODE' use32
.text$mn:000059E8                 assume cs:_text$mn
.text$mn:000059E8                 ;org 59E8h
.text$mn:000059E8 ; COMDAT (pick any)
.text$mn:000059E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000059E8
.text$mn:000059E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000059E8
.text$mn:000059E8 ; Attributes: bp-based frame
.text$mn:000059E8
.text$mn:000059E8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000059E8                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000059E8 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000059E8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+Cp
.text$mn:000059E8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)+Cp ...
.text$mn:000059E8
.text$mn:000059E8 var_4           = dword ptr -4
.text$mn:000059E8
.text$mn:000059E8                 push    ebp
.text$mn:000059E9                 mov     ebp, esp
.text$mn:000059EB                 push    ecx
.text$mn:000059EC                 mov     [ebp+var_4], ecx
.text$mn:000059EF                 mov     ecx, [ebp+var_4]
.text$mn:000059F2                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000059F7                 mov     eax, [ebp+var_4]
.text$mn:000059FA                 mov     esp, ebp
.text$mn:000059FC                 pop     ebp
.text$mn:000059FD                 retn
.text$mn:000059FD ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:000059FD
.text$mn:000059FD ; ---------------------------------------------------------------------------
.text$mn:000059FE                 align 10h
.text$mn:000059FE _text$mn        ends
.text$mn:000059FE
.text$mn:00005A00 ; ===========================================================================
.text$mn:00005A00
.text$mn:00005A00 ; Segment type: Pure code
.text$mn:00005A00 ; Segment permissions: Read/Execute
.text$mn:00005A00 _text$mn        segment para public 'CODE' use32
.text$mn:00005A00                 assume cs:_text$mn
.text$mn:00005A00                 ;org 5A00h
.text$mn:00005A00 ; COMDAT (pick any)
.text$mn:00005A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A00
.text$mn:00005A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A00
.text$mn:00005A00 ; Attributes: bp-based frame
.text$mn:00005A00
.text$mn:00005A00 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00005A00                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00005A00 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005A00                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00005A00
.text$mn:00005A00 var_4           = dword ptr -4
.text$mn:00005A00
.text$mn:00005A00                 push    ebp
.text$mn:00005A01                 mov     ebp, esp
.text$mn:00005A03                 push    ecx
.text$mn:00005A04                 mov     [ebp+var_4], ecx
.text$mn:00005A07                 mov     ecx, [ebp+var_4]
.text$mn:00005A0A                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005A0F                 mov     eax, [ebp+var_4]
.text$mn:00005A12                 mov     esp, ebp
.text$mn:00005A14                 pop     ebp
.text$mn:00005A15                 retn
.text$mn:00005A15 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00005A15
.text$mn:00005A15 ; ---------------------------------------------------------------------------
.text$mn:00005A16                 align 4
.text$mn:00005A16 _text$mn        ends
.text$mn:00005A16
.text$mn:00005A18 ; ===========================================================================
.text$mn:00005A18
.text$mn:00005A18 ; Segment type: Pure code
.text$mn:00005A18 ; Segment permissions: Read/Execute
.text$mn:00005A18 _text$mn        segment para public 'CODE' use32
.text$mn:00005A18                 assume cs:_text$mn
.text$mn:00005A18                 ;org 5A18h
.text$mn:00005A18 ; COMDAT (pick any)
.text$mn:00005A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A18
.text$mn:00005A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A18
.text$mn:00005A18 ; Attributes: bp-based frame
.text$mn:00005A18
.text$mn:00005A18 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00005A18                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00005A18 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00005A18                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00005A18
.text$mn:00005A18 var_4           = dword ptr -4
.text$mn:00005A18
.text$mn:00005A18                 push    ebp
.text$mn:00005A19                 mov     ebp, esp
.text$mn:00005A1B                 push    ecx
.text$mn:00005A1C                 mov     [ebp+var_4], ecx
.text$mn:00005A1F                 mov     eax, [ebp+var_4]
.text$mn:00005A22                 mov     esp, ebp
.text$mn:00005A24                 pop     ebp
.text$mn:00005A25                 retn
.text$mn:00005A25 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00005A25
.text$mn:00005A25 ; ---------------------------------------------------------------------------
.text$mn:00005A26                 align 4
.text$mn:00005A26 _text$mn        ends
.text$mn:00005A26
.text$mn:00005A28 ; ===========================================================================
.text$mn:00005A28
.text$mn:00005A28 ; Segment type: Pure code
.text$mn:00005A28 ; Segment permissions: Read/Execute
.text$mn:00005A28 _text$mn        segment para public 'CODE' use32
.text$mn:00005A28                 assume cs:_text$mn
.text$mn:00005A28                 ;org 5A28h
.text$mn:00005A28 ; COMDAT (pick any)
.text$mn:00005A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A28
.text$mn:00005A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A28
.text$mn:00005A28 ; Attributes: bp-based frame
.text$mn:00005A28
.text$mn:00005A28 ; public: __thiscall std::allocator<int>::allocator<int>(void)
.text$mn:00005A28                 public ??0?$allocator@H@std@@QAE@XZ
.text$mn:00005A28 ??0?$allocator@H@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)+Ap
.text$mn:00005A28                                         ; std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+2Bp
.text$mn:00005A28
.text$mn:00005A28 var_4           = dword ptr -4
.text$mn:00005A28
.text$mn:00005A28                 push    ebp
.text$mn:00005A29                 mov     ebp, esp
.text$mn:00005A2B                 push    ecx
.text$mn:00005A2C                 mov     [ebp+var_4], ecx
.text$mn:00005A2F                 mov     eax, [ebp+var_4]
.text$mn:00005A32                 mov     esp, ebp
.text$mn:00005A34                 pop     ebp
.text$mn:00005A35                 retn
.text$mn:00005A35 ??0?$allocator@H@std@@QAE@XZ endp
.text$mn:00005A35
.text$mn:00005A35 ; ---------------------------------------------------------------------------
.text$mn:00005A36                 align 4
.text$mn:00005A36 _text$mn        ends
.text$mn:00005A36
.text$mn:00005A38 ; ===========================================================================
.text$mn:00005A38
.text$mn:00005A38 ; Segment type: Pure code
.text$mn:00005A38 ; Segment permissions: Read/Execute
.text$mn:00005A38 _text$mn        segment para public 'CODE' use32
.text$mn:00005A38                 assume cs:_text$mn
.text$mn:00005A38                 ;org 5A38h
.text$mn:00005A38 ; COMDAT (pick any)
.text$mn:00005A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A38
.text$mn:00005A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A38
.text$mn:00005A38 ; Attributes: bp-based frame
.text$mn:00005A38
.text$mn:00005A38 ; public: __thiscall std::allocator<struct ColumnModeInfo>::allocator<struct ColumnModeInfo>(void)
.text$mn:00005A38                 public ??0?$allocator@UColumnModeInfo@@@std@@QAE@XZ
.text$mn:00005A38 ??0?$allocator@UColumnModeInfo@@@std@@QAE@XZ proc near
.text$mn:00005A38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ColumnModeInfo>>::_Wrap_alloc<std::allocator<ColumnModeInfo>>(void)+Ap
.text$mn:00005A38
.text$mn:00005A38 var_4           = dword ptr -4
.text$mn:00005A38
.text$mn:00005A38                 push    ebp
.text$mn:00005A39                 mov     ebp, esp
.text$mn:00005A3B                 push    ecx
.text$mn:00005A3C                 mov     [ebp+var_4], ecx
.text$mn:00005A3F                 mov     eax, [ebp+var_4]
.text$mn:00005A42                 mov     esp, ebp
.text$mn:00005A44                 pop     ebp
.text$mn:00005A45                 retn
.text$mn:00005A45 ??0?$allocator@UColumnModeInfo@@@std@@QAE@XZ endp
.text$mn:00005A45
.text$mn:00005A45 ; ---------------------------------------------------------------------------
.text$mn:00005A46                 align 4
.text$mn:00005A46 _text$mn        ends
.text$mn:00005A46
.text$mn:00005A48 ; ===========================================================================
.text$mn:00005A48
.text$mn:00005A48 ; Segment type: Pure code
.text$mn:00005A48 ; Segment permissions: Read/Execute
.text$mn:00005A48 _text$mn        segment para public 'CODE' use32
.text$mn:00005A48                 assume cs:_text$mn
.text$mn:00005A48                 ;org 5A48h
.text$mn:00005A48 ; COMDAT (pick any)
.text$mn:00005A48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A48
.text$mn:00005A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A48
.text$mn:00005A48 ; Attributes: bp-based frame
.text$mn:00005A48
.text$mn:00005A48 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00005A48                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00005A48 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00005A48                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00005A48                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00005A48
.text$mn:00005A48 var_4           = dword ptr -4
.text$mn:00005A48
.text$mn:00005A48                 push    ebp
.text$mn:00005A49                 mov     ebp, esp
.text$mn:00005A4B                 push    ecx
.text$mn:00005A4C                 mov     [ebp+var_4], ecx
.text$mn:00005A4F                 mov     eax, [ebp+var_4]
.text$mn:00005A52                 mov     esp, ebp
.text$mn:00005A54                 pop     ebp
.text$mn:00005A55                 retn
.text$mn:00005A55 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00005A55
.text$mn:00005A55 ; ---------------------------------------------------------------------------
.text$mn:00005A56                 align 4
.text$mn:00005A56 _text$mn        ends
.text$mn:00005A56
.text$mn:00005A58 ; ===========================================================================
.text$mn:00005A58
.text$mn:00005A58 ; Segment type: Pure code
.text$mn:00005A58 ; Segment permissions: Read/Execute
.text$mn:00005A58 _text$mn        segment para public 'CODE' use32
.text$mn:00005A58                 assume cs:_text$mn
.text$mn:00005A58                 ;org 5A58h
.text$mn:00005A58 ; COMDAT (pick any)
.text$mn:00005A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A58
.text$mn:00005A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A58
.text$mn:00005A58 ; Attributes: bp-based frame
.text$mn:00005A58
.text$mn:00005A58 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005A58                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00005A58 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00005A58                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(uint,wchar_t)+2Bp ...
.text$mn:00005A58
.text$mn:00005A58 var_4           = dword ptr -4
.text$mn:00005A58
.text$mn:00005A58                 push    ebp
.text$mn:00005A59                 mov     ebp, esp
.text$mn:00005A5B                 push    ecx
.text$mn:00005A5C                 mov     [ebp+var_4], ecx
.text$mn:00005A5F                 mov     eax, [ebp+var_4]
.text$mn:00005A62                 mov     esp, ebp
.text$mn:00005A64                 pop     ebp
.text$mn:00005A65                 retn
.text$mn:00005A65 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00005A65
.text$mn:00005A65 ; ---------------------------------------------------------------------------
.text$mn:00005A66                 align 4
.text$mn:00005A66 _text$mn        ends
.text$mn:00005A66
.text$mn:00005A68 ; ===========================================================================
.text$mn:00005A68
.text$mn:00005A68 ; Segment type: Pure code
.text$mn:00005A68 ; Segment permissions: Read/Execute
.text$mn:00005A68 _text$mn        segment para public 'CODE' use32
.text$mn:00005A68                 assume cs:_text$mn
.text$mn:00005A68                 ;org 5A68h
.text$mn:00005A68 ; COMDAT (pick any)
.text$mn:00005A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A68
.text$mn:00005A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A68
.text$mn:00005A68 ; Attributes: bp-based frame
.text$mn:00005A68
.text$mn:00005A68 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00005A68                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00005A68 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00005A68                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00005A68                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00005A68
.text$mn:00005A68 var_14          = dword ptr -14h
.text$mn:00005A68 var_D           = byte ptr -0Dh
.text$mn:00005A68 var_C           = dword ptr -0Ch
.text$mn:00005A68 var_4           = dword ptr -4
.text$mn:00005A68 Str             = dword ptr  8
.text$mn:00005A68
.text$mn:00005A68                 push    ebp
.text$mn:00005A69                 mov     ebp, esp
.text$mn:00005A6B                 push    0FFFFFFFFh
.text$mn:00005A6D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00005A72                 mov     eax, large fs:0
.text$mn:00005A78                 push    eax
.text$mn:00005A79                 sub     esp, 8
.text$mn:00005A7C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005A81                 xor     eax, ebp
.text$mn:00005A83                 push    eax
.text$mn:00005A84                 lea     eax, [ebp+var_C]
.text$mn:00005A87                 mov     large fs:0, eax
.text$mn:00005A8D                 mov     [ebp+var_14], ecx
.text$mn:00005A90                 lea     ecx, [ebp+var_D]
.text$mn:00005A93                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00005A98                 push    eax
.text$mn:00005A99                 mov     ecx, [ebp+var_14]
.text$mn:00005A9C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00005AA1                 mov     [ebp+var_4], 0
.text$mn:00005AA8                 push    0               ; Size
.text$mn:00005AAA                 push    0               ; char
.text$mn:00005AAC                 mov     ecx, [ebp+var_14]
.text$mn:00005AAF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005AB4                 mov     eax, [ebp+Str]
.text$mn:00005AB7                 push    eax             ; Str
.text$mn:00005AB8                 mov     ecx, [ebp+var_14]
.text$mn:00005ABB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00005AC0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005AC7                 mov     eax, [ebp+var_14]
.text$mn:00005ACA                 mov     ecx, [ebp+var_C]
.text$mn:00005ACD                 mov     large fs:0, ecx
.text$mn:00005AD4                 pop     ecx
.text$mn:00005AD5                 mov     esp, ebp
.text$mn:00005AD7                 pop     ebp
.text$mn:00005AD8                 retn    4
.text$mn:00005AD8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00005AD8
.text$mn:00005AD8 ; ---------------------------------------------------------------------------
.text$mn:00005ADB                 align 4
.text$mn:00005ADB _text$mn        ends
.text$mn:00005ADB
.text$x:00005ADC ; ===========================================================================
.text$x:00005ADC
.text$x:00005ADC ; Segment type: Pure code
.text$x:00005ADC ; Segment permissions: Read/Execute
.text$x:00005ADC _text$x         segment para public 'CODE' use32
.text$x:00005ADC                 assume cs:_text$x
.text$x:00005ADC                 ;org 5ADCh
.text$x:00005ADC ; COMDAT (pick associative to section at 5A68)
.text$x:00005ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005ADC
.text$x:00005ADC ; =============== S U B R O U T I N E =======================================
.text$x:00005ADC
.text$x:00005ADC
.text$x:00005ADC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00005ADC                                         ; DATA XREF: .xdata$x:00009FB8o
.text$x:00005ADC                 mov     ecx, [ebp-14h]
.text$x:00005ADF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00005ADF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00005ADF
.text$x:00005AE4
.text$x:00005AE4 ; =============== S U B R O U T I N E =======================================
.text$x:00005AE4
.text$x:00005AE4
.text$x:00005AE4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00005AE4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00005AE4
.text$x:00005AE4 arg_4           = dword ptr  8
.text$x:00005AE4
.text$x:00005AE4                 mov     edx, [esp+arg_4]
.text$x:00005AE8                 lea     eax, [edx+0Ch]
.text$x:00005AEB                 mov     ecx, [edx-0Ch]
.text$x:00005AEE                 xor     ecx, eax
.text$x:00005AF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005AF5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00005AFA                 jmp     ___CxxFrameHandler3
.text$x:00005AFA __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00005AFA
.text$x:00005AFA ; ---------------------------------------------------------------------------
.text$x:00005AFF                 align 10h
.text$x:00005AFF _text$x         ends
.text$x:00005AFF
.text$mn:00005B00 ; ===========================================================================
.text$mn:00005B00
.text$mn:00005B00 ; Segment type: Pure code
.text$mn:00005B00 ; Segment permissions: Read/Execute
.text$mn:00005B00 _text$mn        segment para public 'CODE' use32
.text$mn:00005B00                 assume cs:_text$mn
.text$mn:00005B00                 ;org 5B00h
.text$mn:00005B00 ; COMDAT (pick any)
.text$mn:00005B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B00
.text$mn:00005B00 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B00
.text$mn:00005B00 ; Attributes: bp-based frame
.text$mn:00005B00
.text$mn:00005B00 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(unsigned int, wchar_t)
.text$mn:00005B00                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
.text$mn:00005B00 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z proc near
.text$mn:00005B00                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+594p
.text$mn:00005B00                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+D35p
.text$mn:00005B00
.text$mn:00005B00 var_14          = dword ptr -14h
.text$mn:00005B00 var_D           = byte ptr -0Dh
.text$mn:00005B00 var_C           = dword ptr -0Ch
.text$mn:00005B00 var_4           = dword ptr -4
.text$mn:00005B00 arg_0           = dword ptr  8
.text$mn:00005B00 arg_4           = word ptr  0Ch
.text$mn:00005B00
.text$mn:00005B00                 push    ebp
.text$mn:00005B01                 mov     ebp, esp
.text$mn:00005B03                 push    0FFFFFFFFh
.text$mn:00005B05                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
.text$mn:00005B0A                 mov     eax, large fs:0
.text$mn:00005B10                 push    eax
.text$mn:00005B11                 sub     esp, 8
.text$mn:00005B14                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005B19                 xor     eax, ebp
.text$mn:00005B1B                 push    eax
.text$mn:00005B1C                 lea     eax, [ebp+var_C]
.text$mn:00005B1F                 mov     large fs:0, eax
.text$mn:00005B25                 mov     [ebp+var_14], ecx
.text$mn:00005B28                 lea     ecx, [ebp+var_D]
.text$mn:00005B2B                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005B30                 push    eax
.text$mn:00005B31                 mov     ecx, [ebp+var_14]
.text$mn:00005B34                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00005B39                 mov     [ebp+var_4], 0
.text$mn:00005B40                 push    0
.text$mn:00005B42                 push    0
.text$mn:00005B44                 mov     ecx, [ebp+var_14]
.text$mn:00005B47                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005B4C                 movzx   eax, [ebp+arg_4]
.text$mn:00005B50                 push    eax
.text$mn:00005B51                 mov     ecx, [ebp+arg_0]
.text$mn:00005B54                 push    ecx
.text$mn:00005B55                 mov     ecx, [ebp+var_14]
.text$mn:00005B58                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(uint,wchar_t)
.text$mn:00005B5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005B64                 mov     eax, [ebp+var_14]
.text$mn:00005B67                 mov     ecx, [ebp+var_C]
.text$mn:00005B6A                 mov     large fs:0, ecx
.text$mn:00005B71                 pop     ecx
.text$mn:00005B72                 mov     esp, ebp
.text$mn:00005B74                 pop     ebp
.text$mn:00005B75                 retn    8
.text$mn:00005B75 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z endp
.text$mn:00005B75
.text$mn:00005B75 _text$mn        ends
.text$mn:00005B75
.text$x:00005B78 ; ===========================================================================
.text$x:00005B78
.text$x:00005B78 ; Segment type: Pure code
.text$x:00005B78 ; Segment permissions: Read/Execute
.text$x:00005B78 _text$x         segment para public 'CODE' use32
.text$x:00005B78                 assume cs:_text$x
.text$x:00005B78                 ;org 5B78h
.text$x:00005B78 ; COMDAT (pick associative to section at 5B00)
.text$x:00005B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B78
.text$x:00005B78 ; =============== S U B R O U T I N E =======================================
.text$x:00005B78
.text$x:00005B78
.text$x:00005B78 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z$0 proc near
.text$x:00005B78                                         ; DATA XREF: .xdata$x:0000A42Co
.text$x:00005B78                 mov     ecx, [ebp-14h]
.text$x:00005B7B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00005B7B __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z$0 endp
.text$x:00005B7B
.text$x:00005B80
.text$x:00005B80 ; =============== S U B R O U T I N E =======================================
.text$x:00005B80
.text$x:00005B80
.text$x:00005B80 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z proc near
.text$x:00005B80                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(uint,wchar_t)+5o
.text$x:00005B80
.text$x:00005B80 arg_4           = dword ptr  8
.text$x:00005B80
.text$x:00005B80                 mov     edx, [esp+arg_4]
.text$x:00005B84                 lea     eax, [edx+0Ch]
.text$x:00005B87                 mov     ecx, [edx-0Ch]
.text$x:00005B8A                 xor     ecx, eax
.text$x:00005B8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B91                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
.text$x:00005B96                 jmp     ___CxxFrameHandler3
.text$x:00005B96 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z endp
.text$x:00005B96
.text$x:00005B96 ; ---------------------------------------------------------------------------
.text$x:00005B9B                 align 4
.text$x:00005B9B _text$x         ends
.text$x:00005B9B
.text$mn:00005B9C ; ===========================================================================
.text$mn:00005B9C
.text$mn:00005B9C ; Segment type: Pure code
.text$mn:00005B9C ; Segment permissions: Read/Execute
.text$mn:00005B9C _text$mn        segment para public 'CODE' use32
.text$mn:00005B9C                 assume cs:_text$mn
.text$mn:00005B9C                 ;org 5B9Ch
.text$mn:00005B9C ; COMDAT (pick any)
.text$mn:00005B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B9C
.text$mn:00005B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B9C
.text$mn:00005B9C ; Attributes: bp-based frame
.text$mn:00005B9C
.text$mn:00005B9C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:00005B9C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00005B9C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:00005B9C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+565p
.text$mn:00005B9C                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+CC4p
.text$mn:00005B9C
.text$mn:00005B9C var_14          = dword ptr -14h
.text$mn:00005B9C var_D           = byte ptr -0Dh
.text$mn:00005B9C var_C           = dword ptr -0Ch
.text$mn:00005B9C var_4           = dword ptr -4
.text$mn:00005B9C Str             = dword ptr  8
.text$mn:00005B9C
.text$mn:00005B9C                 push    ebp
.text$mn:00005B9D                 mov     ebp, esp
.text$mn:00005B9F                 push    0FFFFFFFFh
.text$mn:00005BA1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00005BA6                 mov     eax, large fs:0
.text$mn:00005BAC                 push    eax
.text$mn:00005BAD                 sub     esp, 8
.text$mn:00005BB0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005BB5                 xor     eax, ebp
.text$mn:00005BB7                 push    eax
.text$mn:00005BB8                 lea     eax, [ebp+var_C]
.text$mn:00005BBB                 mov     large fs:0, eax
.text$mn:00005BC1                 mov     [ebp+var_14], ecx
.text$mn:00005BC4                 lea     ecx, [ebp+var_D]
.text$mn:00005BC7                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005BCC                 push    eax
.text$mn:00005BCD                 mov     ecx, [ebp+var_14]
.text$mn:00005BD0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00005BD5                 mov     [ebp+var_4], 0
.text$mn:00005BDC                 push    0
.text$mn:00005BDE                 push    0
.text$mn:00005BE0                 mov     ecx, [ebp+var_14]
.text$mn:00005BE3                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005BE8                 mov     eax, [ebp+Str]
.text$mn:00005BEB                 push    eax             ; Str
.text$mn:00005BEC                 mov     ecx, [ebp+var_14]
.text$mn:00005BEF                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00005BF4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005BFB                 mov     eax, [ebp+var_14]
.text$mn:00005BFE                 mov     ecx, [ebp+var_C]
.text$mn:00005C01                 mov     large fs:0, ecx
.text$mn:00005C08                 pop     ecx
.text$mn:00005C09                 mov     esp, ebp
.text$mn:00005C0B                 pop     ebp
.text$mn:00005C0C                 retn    4
.text$mn:00005C0C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00005C0C
.text$mn:00005C0C ; ---------------------------------------------------------------------------
.text$mn:00005C0F                 align 10h
.text$mn:00005C0F _text$mn        ends
.text$mn:00005C0F
.text$x:00005C10 ; ===========================================================================
.text$x:00005C10
.text$x:00005C10 ; Segment type: Pure code
.text$x:00005C10 ; Segment permissions: Read/Execute
.text$x:00005C10 _text$x         segment para public 'CODE' use32
.text$x:00005C10                 assume cs:_text$x
.text$x:00005C10                 ;org 5C10h
.text$x:00005C10 ; COMDAT (pick associative to section at 5B9C)
.text$x:00005C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005C10
.text$x:00005C10 ; =============== S U B R O U T I N E =======================================
.text$x:00005C10
.text$x:00005C10
.text$x:00005C10 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00005C10                                         ; DATA XREF: .xdata$x:0000A400o
.text$x:00005C10                 mov     ecx, [ebp-14h]
.text$x:00005C13                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00005C13 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00005C13
.text$x:00005C18
.text$x:00005C18 ; =============== S U B R O U T I N E =======================================
.text$x:00005C18
.text$x:00005C18
.text$x:00005C18 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00005C18                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00005C18
.text$x:00005C18 arg_4           = dword ptr  8
.text$x:00005C18
.text$x:00005C18                 mov     edx, [esp+arg_4]
.text$x:00005C1C                 lea     eax, [edx+0Ch]
.text$x:00005C1F                 mov     ecx, [edx-0Ch]
.text$x:00005C22                 xor     ecx, eax
.text$x:00005C24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005C29                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00005C2E                 jmp     ___CxxFrameHandler3
.text$x:00005C2E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00005C2E
.text$x:00005C2E ; ---------------------------------------------------------------------------
.text$x:00005C33                 align 4
.text$x:00005C33 _text$x         ends
.text$x:00005C33
.text$mn:00005C34 ; ===========================================================================
.text$mn:00005C34
.text$mn:00005C34 ; Segment type: Pure code
.text$mn:00005C34 ; Segment permissions: Read/Execute
.text$mn:00005C34 _text$mn        segment para public 'CODE' use32
.text$mn:00005C34                 assume cs:_text$mn
.text$mn:00005C34                 ;org 5C34h
.text$mn:00005C34 ; COMDAT (pick any)
.text$mn:00005C34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C34
.text$mn:00005C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C34
.text$mn:00005C34 ; Attributes: bp-based frame
.text$mn:00005C34
.text$mn:00005C34 ; int __stdcall std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(struct std::_Iterator_base12 *)
.text$mn:00005C34                 public ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005C34 ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005C34                                         ; CODE XREF: std::vector<int,std::allocator<int>>::rbegin(void)+73p
.text$mn:00005C34
.text$mn:00005C34 var_10          = dword ptr -10h
.text$mn:00005C34 var_C           = dword ptr -0Ch
.text$mn:00005C34 var_4           = dword ptr -4
.text$mn:00005C34 arg_0           = dword ptr  8
.text$mn:00005C34
.text$mn:00005C34                 push    ebp
.text$mn:00005C35                 mov     ebp, esp
.text$mn:00005C37                 push    0FFFFFFFFh
.text$mn:00005C39                 push    offset __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005C3E                 mov     eax, large fs:0
.text$mn:00005C44                 push    eax
.text$mn:00005C45                 push    ecx
.text$mn:00005C46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005C4B                 xor     eax, ebp
.text$mn:00005C4D                 push    eax
.text$mn:00005C4E                 lea     eax, [ebp+var_C]
.text$mn:00005C51                 mov     large fs:0, eax
.text$mn:00005C57                 mov     [ebp+var_10], ecx
.text$mn:00005C5A                 mov     eax, [ebp+arg_0]
.text$mn:00005C5D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005C5E                 mov     ecx, [ebp+var_10]
.text$mn:00005C61                 call    ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>> const &)
.text$mn:00005C66                 mov     [ebp+var_4], 0
.text$mn:00005C6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005C74                 mov     eax, [ebp+var_10]
.text$mn:00005C77                 mov     ecx, [ebp+var_C]
.text$mn:00005C7A                 mov     large fs:0, ecx
.text$mn:00005C81                 pop     ecx
.text$mn:00005C82                 mov     esp, ebp
.text$mn:00005C84                 pop     ebp
.text$mn:00005C85                 retn    4
.text$mn:00005C85 ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005C85
.text$mn:00005C85 _text$mn        ends
.text$mn:00005C85
.text$x:00005C88 ; ===========================================================================
.text$x:00005C88
.text$x:00005C88 ; Segment type: Pure code
.text$x:00005C88 ; Segment permissions: Read/Execute
.text$x:00005C88 _text$x         segment para public 'CODE' use32
.text$x:00005C88                 assume cs:_text$x
.text$x:00005C88                 ;org 5C88h
.text$x:00005C88 ; COMDAT (pick associative to section at 5C34)
.text$x:00005C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005C88
.text$x:00005C88 ; =============== S U B R O U T I N E =======================================
.text$x:00005C88
.text$x:00005C88
.text$x:00005C88 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005C88                                         ; DATA XREF: .xdata$x:0000ACC0o
.text$x:00005C88                 mov     ecx, [ebp-10h]
.text$x:00005C8B                 jmp     ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(void)
.text$x:00005C8B __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005C8B
.text$x:00005C90
.text$x:00005C90 ; =============== S U B R O U T I N E =======================================
.text$x:00005C90
.text$x:00005C90
.text$x:00005C90 __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005C90                                         ; DATA XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>> const &)+5o
.text$x:00005C90
.text$x:00005C90 arg_4           = dword ptr  8
.text$x:00005C90
.text$x:00005C90                 mov     edx, [esp+arg_4]
.text$x:00005C94                 lea     eax, [edx+0Ch]
.text$x:00005C97                 mov     ecx, [edx-8]
.text$x:00005C9A                 xor     ecx, eax
.text$x:00005C9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005CA1                 mov     eax, offset __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005CA6                 jmp     ___CxxFrameHandler3
.text$x:00005CA6 __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005CA6
.text$x:00005CA6 ; ---------------------------------------------------------------------------
.text$x:00005CAB                 align 4
.text$x:00005CAB _text$x         ends
.text$x:00005CAB
.text$mn:00005CAC ; ===========================================================================
.text$mn:00005CAC
.text$mn:00005CAC ; Segment type: Pure code
.text$mn:00005CAC ; Segment permissions: Read/Execute
.text$mn:00005CAC _text$mn        segment para public 'CODE' use32
.text$mn:00005CAC                 assume cs:_text$mn
.text$mn:00005CAC                 ;org 5CACh
.text$mn:00005CAC ; COMDAT (pick any)
.text$mn:00005CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CAC
.text$mn:00005CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005CAC
.text$mn:00005CAC ; Attributes: bp-based frame
.text$mn:00005CAC
.text$mn:00005CAC ; public: __thiscall std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)
.text$mn:00005CAC                 public ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.text$mn:00005CAC ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z proc near
.text$mn:00005CAC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::rbegin(void)+57p
.text$mn:00005CAC
.text$mn:00005CAC var_20          = dword ptr -20h
.text$mn:00005CAC var_1C          = dword ptr -1Ch
.text$mn:00005CAC var_18          = dword ptr -18h
.text$mn:00005CAC var_14          = dword ptr -14h
.text$mn:00005CAC var_10          = dword ptr -10h
.text$mn:00005CAC var_C           = dword ptr -0Ch
.text$mn:00005CAC var_4           = dword ptr -4
.text$mn:00005CAC arg_0           = byte ptr  8
.text$mn:00005CAC
.text$mn:00005CAC                 push    ebp
.text$mn:00005CAD                 mov     ebp, esp
.text$mn:00005CAF                 push    0FFFFFFFFh
.text$mn:00005CB1                 push    offset __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.text$mn:00005CB6                 mov     eax, large fs:0
.text$mn:00005CBC                 push    eax
.text$mn:00005CBD                 sub     esp, 14h
.text$mn:00005CC0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005CC5                 xor     eax, ebp
.text$mn:00005CC7                 push    eax
.text$mn:00005CC8                 lea     eax, [ebp+var_C]
.text$mn:00005CCB                 mov     large fs:0, eax
.text$mn:00005CD1                 mov     [ebp+var_10], ecx
.text$mn:00005CD4                 mov     [ebp+var_4], 0
.text$mn:00005CDB                 sub     esp, 0Ch
.text$mn:00005CDE                 mov     ecx, esp
.text$mn:00005CE0                 mov     [ebp+var_18], esp
.text$mn:00005CE3                 lea     eax, [ebp+arg_0]
.text$mn:00005CE6                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005CE7                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00005CEC                 mov     [ebp+var_14], eax
.text$mn:00005CEF                 mov     ecx, [ebp+var_14]
.text$mn:00005CF2                 mov     [ebp+var_1C], ecx
.text$mn:00005CF5                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005CF9                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005CFD                 mov     ecx, [ebp+var_10]
.text$mn:00005D00                 call    ??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00005D05                 mov     [ebp+var_20], eax
.text$mn:00005D08                 mov     byte ptr [ebp+var_4], 2
.text$mn:00005D0C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005D13                 lea     ecx, [ebp+arg_0]
.text$mn:00005D16                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00005D1B                 mov     eax, [ebp+var_10]
.text$mn:00005D1E                 mov     ecx, [ebp+var_C]
.text$mn:00005D21                 mov     large fs:0, ecx
.text$mn:00005D28                 pop     ecx
.text$mn:00005D29                 mov     esp, ebp
.text$mn:00005D2B                 pop     ebp
.text$mn:00005D2C                 retn    0Ch
.text$mn:00005D2C ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z endp
.text$mn:00005D2C
.text$mn:00005D2C ; ---------------------------------------------------------------------------
.text$mn:00005D2F                 align 10h
.text$mn:00005D2F _text$mn        ends
.text$mn:00005D2F
.text$x:00005D30 ; ===========================================================================
.text$x:00005D30
.text$x:00005D30 ; Segment type: Pure code
.text$x:00005D30 ; Segment permissions: Read/Execute
.text$x:00005D30 _text$x         segment para public 'CODE' use32
.text$x:00005D30                 assume cs:_text$x
.text$x:00005D30                 ;org 5D30h
.text$x:00005D30 ; COMDAT (pick associative to section at 5CAC)
.text$x:00005D30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005D30
.text$x:00005D30 ; =============== S U B R O U T I N E =======================================
.text$x:00005D30
.text$x:00005D30
.text$x:00005D30 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$0 proc near
.text$x:00005D30                                         ; DATA XREF: .xdata$x:0000AC58o
.text$x:00005D30                 lea     ecx, [ebp+8]
.text$x:00005D33                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005D33 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$0 endp
.text$x:00005D33
.text$x:00005D38
.text$x:00005D38 ; =============== S U B R O U T I N E =======================================
.text$x:00005D38
.text$x:00005D38
.text$x:00005D38 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$1 proc near
.text$x:00005D38                                         ; DATA XREF: .xdata$x:0000AC60o
.text$x:00005D38                 mov     ecx, [ebp-18h]
.text$x:00005D3B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005D3B __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$1 endp
.text$x:00005D3B
.text$x:00005D40
.text$x:00005D40 ; =============== S U B R O U T I N E =======================================
.text$x:00005D40
.text$x:00005D40
.text$x:00005D40 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$2 proc near
.text$x:00005D40                                         ; DATA XREF: .xdata$x:0000AC68o
.text$x:00005D40                 mov     ecx, [ebp-10h]
.text$x:00005D43                 jmp     ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(void)
.text$x:00005D43 __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$2 endp
.text$x:00005D43
.text$x:00005D48
.text$x:00005D48 ; =============== S U B R O U T I N E =======================================
.text$x:00005D48
.text$x:00005D48
.text$x:00005D48 __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z proc near
.text$x:00005D48                                         ; DATA XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00005D48
.text$x:00005D48 arg_4           = dword ptr  8
.text$x:00005D48
.text$x:00005D48                 mov     edx, [esp+arg_4]
.text$x:00005D4C                 lea     eax, [edx+0Ch]
.text$x:00005D4F                 mov     ecx, [edx-18h]
.text$x:00005D52                 xor     ecx, eax
.text$x:00005D54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005D59                 mov     eax, offset __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.text$x:00005D5E                 jmp     ___CxxFrameHandler3
.text$x:00005D5E __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z endp
.text$x:00005D5E
.text$x:00005D5E ; ---------------------------------------------------------------------------
.text$x:00005D63                 align 4
.text$x:00005D63 _text$x         ends
.text$x:00005D63
.text$mn:00005D64 ; ===========================================================================
.text$mn:00005D64
.text$mn:00005D64 ; Segment type: Pure code
.text$mn:00005D64 ; Segment permissions: Read/Execute
.text$mn:00005D64 _text$mn        segment para public 'CODE' use32
.text$mn:00005D64                 assume cs:_text$mn
.text$mn:00005D64                 ;org 5D64h
.text$mn:00005D64 ; COMDAT (pick any)
.text$mn:00005D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D64
.text$mn:00005D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D64
.text$mn:00005D64 ; Attributes: bp-based frame
.text$mn:00005D64
.text$mn:00005D64 ; public: __thiscall std::vector<int, class std::allocator<int>>::vector<int, class std::allocator<int>>(void)
.text$mn:00005D64                 public ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00005D64 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:00005D64                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+942p
.text$mn:00005D64
.text$mn:00005D64 var_14          = dword ptr -14h
.text$mn:00005D64 var_D           = byte ptr -0Dh
.text$mn:00005D64 var_C           = dword ptr -0Ch
.text$mn:00005D64 var_4           = dword ptr -4
.text$mn:00005D64
.text$mn:00005D64                 push    ebp
.text$mn:00005D65                 mov     ebp, esp
.text$mn:00005D67                 push    0FFFFFFFFh
.text$mn:00005D69                 push    offset __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00005D6E                 mov     eax, large fs:0
.text$mn:00005D74                 push    eax
.text$mn:00005D75                 sub     esp, 8
.text$mn:00005D78                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005D7D                 xor     eax, ebp
.text$mn:00005D7F                 push    eax
.text$mn:00005D80                 lea     eax, [ebp+var_C]
.text$mn:00005D83                 mov     large fs:0, eax
.text$mn:00005D89                 mov     [ebp+var_14], ecx
.text$mn:00005D8C                 lea     ecx, [ebp+var_D]
.text$mn:00005D8F                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:00005D94                 push    eax
.text$mn:00005D95                 mov     ecx, [ebp+var_14]
.text$mn:00005D98                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)
.text$mn:00005D9D                 mov     [ebp+var_4], 0
.text$mn:00005DA4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005DAB                 mov     eax, [ebp+var_14]
.text$mn:00005DAE                 mov     ecx, [ebp+var_C]
.text$mn:00005DB1                 mov     large fs:0, ecx
.text$mn:00005DB8                 pop     ecx
.text$mn:00005DB9                 mov     esp, ebp
.text$mn:00005DBB                 pop     ebp
.text$mn:00005DBC                 retn
.text$mn:00005DBC ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:00005DBC
.text$mn:00005DBC ; ---------------------------------------------------------------------------
.text$mn:00005DBD                 align 10h
.text$mn:00005DBD _text$mn        ends
.text$mn:00005DBD
.text$x:00005DC0 ; ===========================================================================
.text$x:00005DC0
.text$x:00005DC0 ; Segment type: Pure code
.text$x:00005DC0 ; Segment permissions: Read/Execute
.text$x:00005DC0 _text$x         segment para public 'CODE' use32
.text$x:00005DC0                 assume cs:_text$x
.text$x:00005DC0                 ;org 5DC0h
.text$x:00005DC0 ; COMDAT (pick associative to section at 5D64)
.text$x:00005DC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005DC0
.text$x:00005DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00005DC0
.text$x:00005DC0
.text$x:00005DC0 __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 proc near
.text$x:00005DC0                                         ; DATA XREF: .xdata$x:0000A5C0o
.text$x:00005DC0                 mov     ecx, [ebp-14h]
.text$x:00005DC3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$x:00005DC3 __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 endp
.text$x:00005DC3
.text$x:00005DC8
.text$x:00005DC8 ; =============== S U B R O U T I N E =======================================
.text$x:00005DC8
.text$x:00005DC8
.text$x:00005DC8 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$x:00005DC8                                         ; DATA XREF: std::vector<int,std::allocator<int>>::vector<int,std::allocator<int>>(void)+5o
.text$x:00005DC8
.text$x:00005DC8 arg_4           = dword ptr  8
.text$x:00005DC8
.text$x:00005DC8                 mov     edx, [esp+arg_4]
.text$x:00005DCC                 lea     eax, [edx+0Ch]
.text$x:00005DCF                 mov     ecx, [edx-0Ch]
.text$x:00005DD2                 xor     ecx, eax
.text$x:00005DD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005DD9                 mov     eax, offset __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$x:00005DDE                 jmp     ___CxxFrameHandler3
.text$x:00005DDE __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$x:00005DDE
.text$x:00005DDE ; ---------------------------------------------------------------------------
.text$x:00005DE3                 align 4
.text$x:00005DE3 _text$x         ends
.text$x:00005DE3
.text$mn:00005DE4 ; ===========================================================================
.text$mn:00005DE4
.text$mn:00005DE4 ; Segment type: Pure code
.text$mn:00005DE4 ; Segment permissions: Read/Execute
.text$mn:00005DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00005DE4                 assume cs:_text$mn
.text$mn:00005DE4                 ;org 5DE4h
.text$mn:00005DE4 ; COMDAT (pick any)
.text$mn:00005DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DE4
.text$mn:00005DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DE4
.text$mn:00005DE4 ; Attributes: bp-based frame
.text$mn:00005DE4
.text$mn:00005DE4 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00005DE4                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00005DE4 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00005DE4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00005DE4                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:00005DE4
.text$mn:00005DE4 var_4           = dword ptr -4
.text$mn:00005DE4
.text$mn:00005DE4                 push    ebp
.text$mn:00005DE5                 mov     ebp, esp
.text$mn:00005DE7                 push    ecx
.text$mn:00005DE8                 mov     [ebp+var_4], ecx
.text$mn:00005DEB                 mov     eax, [ebp+var_4]
.text$mn:00005DEE                 mov     dword ptr [eax], 0
.text$mn:00005DF4                 mov     eax, [ebp+var_4]
.text$mn:00005DF7                 mov     esp, ebp
.text$mn:00005DF9                 pop     ebp
.text$mn:00005DFA                 retn
.text$mn:00005DFA ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00005DFA
.text$mn:00005DFA ; ---------------------------------------------------------------------------
.text$mn:00005DFB                 align 4
.text$mn:00005DFB _text$mn        ends
.text$mn:00005DFB
.text$mn:00005DFC ; ===========================================================================
.text$mn:00005DFC
.text$mn:00005DFC ; Segment type: Pure code
.text$mn:00005DFC ; Segment permissions: Read/Execute
.text$mn:00005DFC _text$mn        segment para public 'CODE' use32
.text$mn:00005DFC                 assume cs:_text$mn
.text$mn:00005DFC                 ;org 5DFCh
.text$mn:00005DFC ; COMDAT (pick any)
.text$mn:00005DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DFC
.text$mn:00005DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DFC
.text$mn:00005DFC ; Attributes: bp-based frame
.text$mn:00005DFC
.text$mn:00005DFC ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00005DFC                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00005DFC ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00005DFC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00005DFC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:00005DFC
.text$mn:00005DFC var_4           = dword ptr -4
.text$mn:00005DFC
.text$mn:00005DFC                 push    ebp
.text$mn:00005DFD                 mov     ebp, esp
.text$mn:00005DFF                 push    ecx
.text$mn:00005E00                 mov     [ebp+var_4], ecx
.text$mn:00005E03                 mov     eax, [ebp+var_4]
.text$mn:00005E06                 mov     dword ptr [eax], 0
.text$mn:00005E0C                 mov     ecx, [ebp+var_4]
.text$mn:00005E0F                 mov     dword ptr [ecx+4], 0
.text$mn:00005E16                 mov     eax, [ebp+var_4]
.text$mn:00005E19                 mov     esp, ebp
.text$mn:00005E1B                 pop     ebp
.text$mn:00005E1C                 retn
.text$mn:00005E1C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00005E1C
.text$mn:00005E1C ; ---------------------------------------------------------------------------
.text$mn:00005E1D                 align 10h
.text$mn:00005E1D _text$mn        ends
.text$mn:00005E1D
.text$mn:00005E20 ; ===========================================================================
.text$mn:00005E20
.text$mn:00005E20 ; Segment type: Pure code
.text$mn:00005E20 ; Segment permissions: Read/Execute
.text$mn:00005E20 _text$mn        segment para public 'CODE' use32
.text$mn:00005E20                 assume cs:_text$mn
.text$mn:00005E20                 ;org 5E20h
.text$mn:00005E20 ; COMDAT (pick any)
.text$mn:00005E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E20
.text$mn:00005E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E20
.text$mn:00005E20 ; Attributes: bp-based frame
.text$mn:00005E20
.text$mn:00005E20 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00005E20                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00005E20 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00005E20                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00005E20                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00005E20
.text$mn:00005E20 var_10          = dword ptr -10h
.text$mn:00005E20 var_C           = dword ptr -0Ch
.text$mn:00005E20 var_4           = dword ptr -4
.text$mn:00005E20
.text$mn:00005E20                 push    ebp
.text$mn:00005E21                 mov     ebp, esp
.text$mn:00005E23                 push    0FFFFFFFFh
.text$mn:00005E25                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00005E2A                 mov     eax, large fs:0
.text$mn:00005E30                 push    eax
.text$mn:00005E31                 push    ecx
.text$mn:00005E32                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E37                 xor     eax, ebp
.text$mn:00005E39                 push    eax
.text$mn:00005E3A                 lea     eax, [ebp+var_C]
.text$mn:00005E3D                 mov     large fs:0, eax
.text$mn:00005E43                 mov     [ebp+var_10], ecx
.text$mn:00005E46                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005E49                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00005E4E                 mov     [ebp+var_4], 0
.text$mn:00005E55                 mov     eax, [ebp+var_10]
.text$mn:00005E58                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00005E5E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005E65                 mov     eax, [ebp+var_10]
.text$mn:00005E68                 mov     ecx, [ebp+var_C]
.text$mn:00005E6B                 mov     large fs:0, ecx
.text$mn:00005E72                 pop     ecx
.text$mn:00005E73                 mov     esp, ebp
.text$mn:00005E75                 pop     ebp
.text$mn:00005E76                 retn
.text$mn:00005E76 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00005E76
.text$mn:00005E76 ; ---------------------------------------------------------------------------
.text$mn:00005E77                 align 4
.text$mn:00005E77 _text$mn        ends
.text$mn:00005E77
.text$x:00005E78 ; ===========================================================================
.text$x:00005E78
.text$x:00005E78 ; Segment type: Pure code
.text$x:00005E78 ; Segment permissions: Read/Execute
.text$x:00005E78 _text$x         segment para public 'CODE' use32
.text$x:00005E78                 assume cs:_text$x
.text$x:00005E78                 ;org 5E78h
.text$x:00005E78 ; COMDAT (pick associative to section at 5E20)
.text$x:00005E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005E78
.text$x:00005E78 ; =============== S U B R O U T I N E =======================================
.text$x:00005E78
.text$x:00005E78
.text$x:00005E78 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00005E78                                         ; DATA XREF: .xdata$x:0000A1C4o
.text$x:00005E78                 mov     ecx, [ebp-10h]  ; this
.text$x:00005E7B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00005E7B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00005E7B
.text$x:00005E80
.text$x:00005E80 ; =============== S U B R O U T I N E =======================================
.text$x:00005E80
.text$x:00005E80
.text$x:00005E80 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00005E80                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00005E80
.text$x:00005E80 arg_4           = dword ptr  8
.text$x:00005E80
.text$x:00005E80                 mov     edx, [esp+arg_4]
.text$x:00005E84                 lea     eax, [edx+0Ch]
.text$x:00005E87                 mov     ecx, [edx-8]
.text$x:00005E8A                 xor     ecx, eax
.text$x:00005E8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005E91                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00005E96                 jmp     ___CxxFrameHandler3
.text$x:00005E96 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00005E96
.text$x:00005E96 ; ---------------------------------------------------------------------------
.text$x:00005E9B                 align 4
.text$x:00005E9B _text$x         ends
.text$x:00005E9B
.text$mn:00005E9C ; ===========================================================================
.text$mn:00005E9C
.text$mn:00005E9C ; Segment type: Pure code
.text$mn:00005E9C ; Segment permissions: Read/Execute
.text$mn:00005E9C _text$mn        segment para public 'CODE' use32
.text$mn:00005E9C                 assume cs:_text$mn
.text$mn:00005E9C                 ;org 5E9Ch
.text$mn:00005E9C ; COMDAT (pick any)
.text$mn:00005E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E9C
.text$mn:00005E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E9C
.text$mn:00005E9C ; Attributes: bp-based frame
.text$mn:00005E9C
.text$mn:00005E9C ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00005E9C                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00005E9C ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00005E9C
.text$mn:00005E9C var_4           = dword ptr -4
.text$mn:00005E9C
.text$mn:00005E9C                 push    ebp
.text$mn:00005E9D                 mov     ebp, esp
.text$mn:00005E9F                 push    ecx
.text$mn:00005EA0                 mov     [ebp+var_4], ecx
.text$mn:00005EA3                 mov     eax, [ebp+var_4]
.text$mn:00005EA6                 mov     esp, ebp
.text$mn:00005EA8                 pop     ebp
.text$mn:00005EA9                 retn
.text$mn:00005EA9 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00005EA9
.text$mn:00005EA9 ; ---------------------------------------------------------------------------
.text$mn:00005EAA                 align 4
.text$mn:00005EAA _text$mn        ends
.text$mn:00005EAA
.text$mn:00005EAC ; ===========================================================================
.text$mn:00005EAC
.text$mn:00005EAC ; Segment type: Pure code
.text$mn:00005EAC ; Segment permissions: Read/Execute
.text$mn:00005EAC _text$mn        segment para public 'CODE' use32
.text$mn:00005EAC                 assume cs:_text$mn
.text$mn:00005EAC                 ;org 5EACh
.text$mn:00005EAC ; COMDAT (pick any)
.text$mn:00005EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EAC
.text$mn:00005EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005EAC
.text$mn:00005EAC ; Attributes: bp-based frame
.text$mn:00005EAC
.text$mn:00005EAC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00005EAC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00005EAC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00005EAC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00005EAC
.text$mn:00005EAC var_10          = dword ptr -10h
.text$mn:00005EAC var_C           = dword ptr -0Ch
.text$mn:00005EAC var_4           = dword ptr -4
.text$mn:00005EAC
.text$mn:00005EAC                 push    ebp
.text$mn:00005EAD                 mov     ebp, esp
.text$mn:00005EAF                 push    0FFFFFFFFh
.text$mn:00005EB1                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00005EB6                 mov     eax, large fs:0
.text$mn:00005EBC                 push    eax
.text$mn:00005EBD                 push    ecx
.text$mn:00005EBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005EC3                 xor     eax, ebp
.text$mn:00005EC5                 push    eax
.text$mn:00005EC6                 lea     eax, [ebp+var_C]
.text$mn:00005EC9                 mov     large fs:0, eax
.text$mn:00005ECF                 mov     [ebp+var_10], ecx
.text$mn:00005ED2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005ED5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00005EDA                 mov     [ebp+var_4], 0
.text$mn:00005EE1                 mov     eax, [ebp+var_10]
.text$mn:00005EE4                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00005EEA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005EF1                 mov     eax, [ebp+var_10]
.text$mn:00005EF4                 mov     ecx, [ebp+var_C]
.text$mn:00005EF7                 mov     large fs:0, ecx
.text$mn:00005EFE                 pop     ecx
.text$mn:00005EFF                 mov     esp, ebp
.text$mn:00005F01                 pop     ebp
.text$mn:00005F02                 retn
.text$mn:00005F02 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00005F02
.text$mn:00005F02 ; ---------------------------------------------------------------------------
.text$mn:00005F03                 align 4
.text$mn:00005F03 _text$mn        ends
.text$mn:00005F03
.text$x:00005F04 ; ===========================================================================
.text$x:00005F04
.text$x:00005F04 ; Segment type: Pure code
.text$x:00005F04 ; Segment permissions: Read/Execute
.text$x:00005F04 _text$x         segment para public 'CODE' use32
.text$x:00005F04                 assume cs:_text$x
.text$x:00005F04                 ;org 5F04h
.text$x:00005F04 ; COMDAT (pick associative to section at 5EAC)
.text$x:00005F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005F04
.text$x:00005F04 ; =============== S U B R O U T I N E =======================================
.text$x:00005F04
.text$x:00005F04
.text$x:00005F04 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00005F04                                         ; DATA XREF: .xdata$x:0000A248o
.text$x:00005F04                 mov     ecx, [ebp-10h]  ; this
.text$x:00005F07                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00005F07 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00005F07
.text$x:00005F0C
.text$x:00005F0C ; =============== S U B R O U T I N E =======================================
.text$x:00005F0C
.text$x:00005F0C
.text$x:00005F0C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00005F0C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00005F0C
.text$x:00005F0C arg_4           = dword ptr  8
.text$x:00005F0C
.text$x:00005F0C                 mov     edx, [esp+arg_4]
.text$x:00005F10                 lea     eax, [edx+0Ch]
.text$x:00005F13                 mov     ecx, [edx-8]
.text$x:00005F16                 xor     ecx, eax
.text$x:00005F18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005F1D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00005F22                 jmp     ___CxxFrameHandler3
.text$x:00005F22 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00005F22
.text$x:00005F22 ; ---------------------------------------------------------------------------
.text$x:00005F27                 align 4
.text$x:00005F27 _text$x         ends
.text$x:00005F27
.text$mn:00005F28 ; ===========================================================================
.text$mn:00005F28
.text$mn:00005F28 ; Segment type: Pure code
.text$mn:00005F28 ; Segment permissions: Read/Execute
.text$mn:00005F28 _text$mn        segment para public 'CODE' use32
.text$mn:00005F28                 assume cs:_text$mn
.text$mn:00005F28                 ;org 5F28h
.text$mn:00005F28 ; COMDAT (pick any)
.text$mn:00005F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F28
.text$mn:00005F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F28
.text$mn:00005F28 ; Attributes: bp-based frame
.text$mn:00005F28
.text$mn:00005F28 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00005F28                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00005F28 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00005F28                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00005F28                                         ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00005F28
.text$mn:00005F28 var_4           = dword ptr -4
.text$mn:00005F28 arg_0           = dword ptr  8
.text$mn:00005F28
.text$mn:00005F28                 push    ebp
.text$mn:00005F29                 mov     ebp, esp
.text$mn:00005F2B                 push    ecx
.text$mn:00005F2C                 mov     [ebp+var_4], ecx
.text$mn:00005F2F                 mov     eax, [ebp+var_4]
.text$mn:00005F32                 mov     dword ptr [eax], 0
.text$mn:00005F38                 mov     ecx, [ebp+var_4]
.text$mn:00005F3B                 mov     dword ptr [ecx+4], 0
.text$mn:00005F42                 mov     edx, [ebp+arg_0]
.text$mn:00005F45                 push    edx
.text$mn:00005F46                 mov     ecx, [ebp+var_4]
.text$mn:00005F49                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00005F4E                 mov     eax, [ebp+var_4]
.text$mn:00005F51                 mov     esp, ebp
.text$mn:00005F53                 pop     ebp
.text$mn:00005F54                 retn    4
.text$mn:00005F54 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00005F54
.text$mn:00005F54 ; ---------------------------------------------------------------------------
.text$mn:00005F57                 align 4
.text$mn:00005F57 _text$mn        ends
.text$mn:00005F57
.text$mn:00005F58 ; ===========================================================================
.text$mn:00005F58
.text$mn:00005F58 ; Segment type: Pure code
.text$mn:00005F58 ; Segment permissions: Read/Execute
.text$mn:00005F58 _text$mn        segment para public 'CODE' use32
.text$mn:00005F58                 assume cs:_text$mn
.text$mn:00005F58                 ;org 5F58h
.text$mn:00005F58 ; COMDAT (pick any)
.text$mn:00005F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F58
.text$mn:00005F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F58
.text$mn:00005F58 ; Attributes: bp-based frame
.text$mn:00005F58
.text$mn:00005F58 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00005F58                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00005F58 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00005F58                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+29p
.text$mn:00005F58                                         ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)+29p
.text$mn:00005F58
.text$mn:00005F58 var_4           = dword ptr -4
.text$mn:00005F58
.text$mn:00005F58                 push    ebp
.text$mn:00005F59                 mov     ebp, esp
.text$mn:00005F5B                 push    ecx
.text$mn:00005F5C                 mov     [ebp+var_4], ecx
.text$mn:00005F5F                 mov     eax, [ebp+var_4]
.text$mn:00005F62                 mov     dword ptr [eax], 0
.text$mn:00005F68                 mov     ecx, [ebp+var_4]
.text$mn:00005F6B                 mov     dword ptr [ecx+4], 0
.text$mn:00005F72                 mov     eax, [ebp+var_4]
.text$mn:00005F75                 mov     esp, ebp
.text$mn:00005F77                 pop     ebp
.text$mn:00005F78                 retn
.text$mn:00005F78 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00005F78
.text$mn:00005F78 ; ---------------------------------------------------------------------------
.text$mn:00005F79                 align 4
.text$mn:00005F79 _text$mn        ends
.text$mn:00005F79
.text$mn:00005F7C ; ===========================================================================
.text$mn:00005F7C
.text$mn:00005F7C ; Segment type: Pure code
.text$mn:00005F7C ; Segment permissions: Read/Execute
.text$mn:00005F7C _text$mn        segment para public 'CODE' use32
.text$mn:00005F7C                 assume cs:_text$mn
.text$mn:00005F7C                 ;org 5F7Ch
.text$mn:00005F7C ; COMDAT (pick any)
.text$mn:00005F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F7C
.text$mn:00005F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F7C
.text$mn:00005F7C ; Attributes: bp-based frame
.text$mn:00005F7C
.text$mn:00005F7C ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00005F7C                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00005F7C ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00005F7C                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00005F7C
.text$mn:00005F7C var_10          = dword ptr -10h
.text$mn:00005F7C var_C           = dword ptr -0Ch
.text$mn:00005F7C var_4           = dword ptr -4
.text$mn:00005F7C
.text$mn:00005F7C                 push    ebp
.text$mn:00005F7D                 mov     ebp, esp
.text$mn:00005F7F                 push    0FFFFFFFFh
.text$mn:00005F81                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00005F86                 mov     eax, large fs:0
.text$mn:00005F8C                 push    eax
.text$mn:00005F8D                 push    ecx
.text$mn:00005F8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005F93                 xor     eax, ebp
.text$mn:00005F95                 push    eax
.text$mn:00005F96                 lea     eax, [ebp+var_C]
.text$mn:00005F99                 mov     large fs:0, eax
.text$mn:00005F9F                 mov     [ebp+var_10], ecx
.text$mn:00005FA2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005FA5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00005FAA                 mov     [ebp+var_4], 0
.text$mn:00005FB1                 mov     eax, [ebp+var_10]
.text$mn:00005FB4                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00005FBA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005FC1                 mov     eax, [ebp+var_10]
.text$mn:00005FC4                 mov     ecx, [ebp+var_C]
.text$mn:00005FC7                 mov     large fs:0, ecx
.text$mn:00005FCE                 pop     ecx
.text$mn:00005FCF                 mov     esp, ebp
.text$mn:00005FD1                 pop     ebp
.text$mn:00005FD2                 retn
.text$mn:00005FD2 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00005FD2
.text$mn:00005FD2 ; ---------------------------------------------------------------------------
.text$mn:00005FD3                 align 4
.text$mn:00005FD3 _text$mn        ends
.text$mn:00005FD3
.text$x:00005FD4 ; ===========================================================================
.text$x:00005FD4
.text$x:00005FD4 ; Segment type: Pure code
.text$x:00005FD4 ; Segment permissions: Read/Execute
.text$x:00005FD4 _text$x         segment para public 'CODE' use32
.text$x:00005FD4                 assume cs:_text$x
.text$x:00005FD4                 ;org 5FD4h
.text$x:00005FD4 ; COMDAT (pick associative to section at 5F7C)
.text$x:00005FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005FD4
.text$x:00005FD4 ; =============== S U B R O U T I N E =======================================
.text$x:00005FD4
.text$x:00005FD4
.text$x:00005FD4 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00005FD4                                         ; DATA XREF: .xdata$x:0000A2CCo
.text$x:00005FD4                 mov     ecx, [ebp-10h]  ; this
.text$x:00005FD7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00005FD7 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00005FD7
.text$x:00005FDC
.text$x:00005FDC ; =============== S U B R O U T I N E =======================================
.text$x:00005FDC
.text$x:00005FDC
.text$x:00005FDC __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00005FDC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00005FDC
.text$x:00005FDC arg_4           = dword ptr  8
.text$x:00005FDC
.text$x:00005FDC                 mov     edx, [esp+arg_4]
.text$x:00005FE0                 lea     eax, [edx+0Ch]
.text$x:00005FE3                 mov     ecx, [edx-8]
.text$x:00005FE6                 xor     ecx, eax
.text$x:00005FE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005FED                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00005FF2                 jmp     ___CxxFrameHandler3
.text$x:00005FF2 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00005FF2
.text$x:00005FF2 ; ---------------------------------------------------------------------------
.text$x:00005FF7                 align 4
.text$x:00005FF7 _text$x         ends
.text$x:00005FF7
.text$mn:00005FF8 ; ===========================================================================
.text$mn:00005FF8
.text$mn:00005FF8 ; Segment type: Pure code
.text$mn:00005FF8 ; Segment permissions: Read/Execute
.text$mn:00005FF8 _text$mn        segment para public 'CODE' use32
.text$mn:00005FF8                 assume cs:_text$mn
.text$mn:00005FF8                 ;org 5FF8h
.text$mn:00005FF8 ; COMDAT (pick any)
.text$mn:00005FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FF8
.text$mn:00005FF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FF8
.text$mn:00005FF8 ; Attributes: bp-based frame
.text$mn:00005FF8
.text$mn:00005FF8 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00005FF8                 public ??0error_category@std@@QAE@XZ
.text$mn:00005FF8 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00005FF8
.text$mn:00005FF8 var_4           = dword ptr -4
.text$mn:00005FF8
.text$mn:00005FF8                 push    ebp
.text$mn:00005FF9                 mov     ebp, esp
.text$mn:00005FFB                 push    ecx
.text$mn:00005FFC                 mov     [ebp+var_4], ecx
.text$mn:00005FFF                 mov     eax, [ebp+var_4]
.text$mn:00006002                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00006008                 mov     eax, [ebp+var_4]
.text$mn:0000600B                 mov     esp, ebp
.text$mn:0000600D                 pop     ebp
.text$mn:0000600E                 retn
.text$mn:0000600E ??0error_category@std@@QAE@XZ endp
.text$mn:0000600E
.text$mn:0000600E ; ---------------------------------------------------------------------------
.text$mn:0000600F                 align 10h
.text$mn:0000600F _text$mn        ends
.text$mn:0000600F
.text$mn:00006010 ; ===========================================================================
.text$mn:00006010
.text$mn:00006010 ; Segment type: Pure code
.text$mn:00006010 ; Segment permissions: Read/Execute
.text$mn:00006010 _text$mn        segment para public 'CODE' use32
.text$mn:00006010                 assume cs:_text$mn
.text$mn:00006010                 ;org 6010h
.text$mn:00006010 ; COMDAT (pick any)
.text$mn:00006010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006010
.text$mn:00006010 ; =============== S U B R O U T I N E =======================================
.text$mn:00006010
.text$mn:00006010 ; Attributes: bp-based frame
.text$mn:00006010
.text$mn:00006010 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00006010                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00006010 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00006010                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00006010                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00006010
.text$mn:00006010 var_4           = dword ptr -4
.text$mn:00006010 arg_0           = dword ptr  8
.text$mn:00006010 arg_4           = dword ptr  0Ch
.text$mn:00006010
.text$mn:00006010                 push    ebp
.text$mn:00006011                 mov     ebp, esp
.text$mn:00006013                 push    ecx
.text$mn:00006014                 mov     [ebp+var_4], ecx
.text$mn:00006017                 mov     eax, [ebp+var_4]
.text$mn:0000601A                 mov     ecx, [ebp+arg_0]
.text$mn:0000601D                 mov     [eax], ecx
.text$mn:0000601F                 mov     edx, [ebp+var_4]
.text$mn:00006022                 mov     eax, [ebp+arg_4]
.text$mn:00006025                 mov     [edx+4], eax
.text$mn:00006028                 mov     eax, [ebp+var_4]
.text$mn:0000602B                 mov     esp, ebp
.text$mn:0000602D                 pop     ebp
.text$mn:0000602E                 retn    8
.text$mn:0000602E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000602E
.text$mn:0000602E ; ---------------------------------------------------------------------------
.text$mn:00006031                 align 4
.text$mn:00006031 _text$mn        ends
.text$mn:00006031
.text$mn:00006034 ; ===========================================================================
.text$mn:00006034
.text$mn:00006034 ; Segment type: Pure code
.text$mn:00006034 ; Segment permissions: Read/Execute
.text$mn:00006034 _text$mn        segment para public 'CODE' use32
.text$mn:00006034                 assume cs:_text$mn
.text$mn:00006034                 ;org 6034h
.text$mn:00006034 ; COMDAT (pick any)
.text$mn:00006034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006034
.text$mn:00006034 ; =============== S U B R O U T I N E =======================================
.text$mn:00006034
.text$mn:00006034 ; Attributes: bp-based frame
.text$mn:00006034
.text$mn:00006034 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00006034                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00006034 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00006034                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00006034
.text$mn:00006034 var_4           = dword ptr -4
.text$mn:00006034 arg_0           = dword ptr  8
.text$mn:00006034
.text$mn:00006034                 push    ebp
.text$mn:00006035                 mov     ebp, esp
.text$mn:00006037                 push    ecx
.text$mn:00006038                 mov     [ebp+var_4], ecx
.text$mn:0000603B                 mov     eax, [ebp+var_4]
.text$mn:0000603E                 mov     ecx, [ebp+arg_0]
.text$mn:00006041                 mov     [eax], ecx
.text$mn:00006043                 mov     eax, [ebp+var_4]
.text$mn:00006046                 mov     esp, ebp
.text$mn:00006048                 pop     ebp
.text$mn:00006049                 retn    4
.text$mn:00006049 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00006049
.text$mn:00006049 _text$mn        ends
.text$mn:00006049
.text$mn:0000604C ; ===========================================================================
.text$mn:0000604C
.text$mn:0000604C ; Segment type: Pure code
.text$mn:0000604C ; Segment permissions: Read/Execute
.text$mn:0000604C _text$mn        segment para public 'CODE' use32
.text$mn:0000604C                 assume cs:_text$mn
.text$mn:0000604C                 ;org 604Ch
.text$mn:0000604C ; COMDAT (pick any)
.text$mn:0000604C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000604C
.text$mn:0000604C ; =============== S U B R O U T I N E =======================================
.text$mn:0000604C
.text$mn:0000604C ; Attributes: bp-based frame
.text$mn:0000604C
.text$mn:0000604C ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:0000604C                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:0000604C ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:0000604C                                         ; DATA XREF: .xdata$x:0000AF64o
.text$mn:0000604C
.text$mn:0000604C var_10          = dword ptr -10h
.text$mn:0000604C var_C           = dword ptr -0Ch
.text$mn:0000604C var_4           = dword ptr -4
.text$mn:0000604C arg_0           = dword ptr  8
.text$mn:0000604C
.text$mn:0000604C                 push    ebp
.text$mn:0000604D                 mov     ebp, esp
.text$mn:0000604F                 push    0FFFFFFFFh
.text$mn:00006051                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00006056                 mov     eax, large fs:0
.text$mn:0000605C                 push    eax
.text$mn:0000605D                 push    ecx
.text$mn:0000605E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006063                 xor     eax, ebp
.text$mn:00006065                 push    eax
.text$mn:00006066                 lea     eax, [ebp+var_C]
.text$mn:00006069                 mov     large fs:0, eax
.text$mn:0000606F                 mov     [ebp+var_10], ecx
.text$mn:00006072                 mov     eax, [ebp+arg_0]
.text$mn:00006075                 push    eax             ; struct std::exception *
.text$mn:00006076                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006079                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:0000607E                 mov     [ebp+var_4], 0
.text$mn:00006085                 mov     ecx, [ebp+var_10]
.text$mn:00006088                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:0000608E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006095                 mov     eax, [ebp+var_10]
.text$mn:00006098                 mov     ecx, [ebp+var_C]
.text$mn:0000609B                 mov     large fs:0, ecx
.text$mn:000060A2                 pop     ecx
.text$mn:000060A3                 mov     esp, ebp
.text$mn:000060A5                 pop     ebp
.text$mn:000060A6                 retn    4
.text$mn:000060A6 ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:000060A6
.text$mn:000060A6 ; ---------------------------------------------------------------------------
.text$mn:000060A9                 align 4
.text$mn:000060A9 _text$mn        ends
.text$mn:000060A9
.text$x:000060AC ; ===========================================================================
.text$x:000060AC
.text$x:000060AC ; Segment type: Pure code
.text$x:000060AC ; Segment permissions: Read/Execute
.text$x:000060AC _text$x         segment para public 'CODE' use32
.text$x:000060AC                 assume cs:_text$x
.text$x:000060AC                 ;org 60ACh
.text$x:000060AC ; COMDAT (pick associative to section at 604C)
.text$x:000060AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000060AC
.text$x:000060AC ; =============== S U B R O U T I N E =======================================
.text$x:000060AC
.text$x:000060AC
.text$x:000060AC __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:000060AC                                         ; DATA XREF: .xdata$x:0000A0F4o
.text$x:000060AC                 mov     ecx, [ebp-10h]  ; this
.text$x:000060AF                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000060AF __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:000060AF
.text$x:000060B4
.text$x:000060B4 ; =============== S U B R O U T I N E =======================================
.text$x:000060B4
.text$x:000060B4
.text$x:000060B4 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:000060B4                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:000060B4
.text$x:000060B4 arg_4           = dword ptr  8
.text$x:000060B4
.text$x:000060B4                 mov     edx, [esp+arg_4]
.text$x:000060B8                 lea     eax, [edx+0Ch]
.text$x:000060BB                 mov     ecx, [edx-8]
.text$x:000060BE                 xor     ecx, eax
.text$x:000060C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000060C5                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:000060CA                 jmp     ___CxxFrameHandler3
.text$x:000060CA __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:000060CA
.text$x:000060CA ; ---------------------------------------------------------------------------
.text$x:000060CF                 align 10h
.text$x:000060CF _text$x         ends
.text$x:000060CF
.text$mn:000060D0 ; ===========================================================================
.text$mn:000060D0
.text$mn:000060D0 ; Segment type: Pure code
.text$mn:000060D0 ; Segment permissions: Read/Execute
.text$mn:000060D0 _text$mn        segment para public 'CODE' use32
.text$mn:000060D0                 assume cs:_text$mn
.text$mn:000060D0                 ;org 60D0h
.text$mn:000060D0 ; COMDAT (pick any)
.text$mn:000060D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060D0
.text$mn:000060D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060D0
.text$mn:000060D0 ; Attributes: bp-based frame
.text$mn:000060D0
.text$mn:000060D0 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:000060D0                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:000060D0 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:000060D0                                         ; CODE XREF: ColumnEditorDlg::init(HINSTANCE__ *,HWND__ *,ScintillaEditView * *)+27p
.text$mn:000060D0
.text$mn:000060D0 var_10          = dword ptr -10h
.text$mn:000060D0 var_C           = dword ptr -0Ch
.text$mn:000060D0 var_4           = dword ptr -4
.text$mn:000060D0 arg_0           = dword ptr  8
.text$mn:000060D0
.text$mn:000060D0                 push    ebp
.text$mn:000060D1                 mov     ebp, esp
.text$mn:000060D3                 push    0FFFFFFFFh
.text$mn:000060D5                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:000060DA                 mov     eax, large fs:0
.text$mn:000060E0                 push    eax
.text$mn:000060E1                 push    ecx
.text$mn:000060E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000060E7                 xor     eax, ebp
.text$mn:000060E9                 push    eax
.text$mn:000060EA                 lea     eax, [ebp+var_C]
.text$mn:000060ED                 mov     large fs:0, eax
.text$mn:000060F3                 mov     [ebp+var_10], ecx
.text$mn:000060F6                 lea     eax, [ebp+arg_0]
.text$mn:000060F9                 push    eax             ; char **
.text$mn:000060FA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000060FD                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00006102                 mov     [ebp+var_4], 0
.text$mn:00006109                 mov     ecx, [ebp+var_10]
.text$mn:0000610C                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00006112                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006119                 mov     eax, [ebp+var_10]
.text$mn:0000611C                 mov     ecx, [ebp+var_C]
.text$mn:0000611F                 mov     large fs:0, ecx
.text$mn:00006126                 pop     ecx
.text$mn:00006127                 mov     esp, ebp
.text$mn:00006129                 pop     ebp
.text$mn:0000612A                 retn    4
.text$mn:0000612A ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:0000612A
.text$mn:0000612A ; ---------------------------------------------------------------------------
.text$mn:0000612D                 align 10h
.text$mn:0000612D _text$mn        ends
.text$mn:0000612D
.text$x:00006130 ; ===========================================================================
.text$x:00006130
.text$x:00006130 ; Segment type: Pure code
.text$x:00006130 ; Segment permissions: Read/Execute
.text$x:00006130 _text$x         segment para public 'CODE' use32
.text$x:00006130                 assume cs:_text$x
.text$x:00006130                 ;org 6130h
.text$x:00006130 ; COMDAT (pick associative to section at 60D0)
.text$x:00006130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006130
.text$x:00006130 ; =============== S U B R O U T I N E =======================================
.text$x:00006130
.text$x:00006130
.text$x:00006130 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00006130                                         ; DATA XREF: .xdata$x:0000A09Co
.text$x:00006130                 mov     ecx, [ebp-10h]  ; this
.text$x:00006133                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00006133 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00006133
.text$x:00006138
.text$x:00006138 ; =============== S U B R O U T I N E =======================================
.text$x:00006138
.text$x:00006138
.text$x:00006138 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00006138                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00006138
.text$x:00006138 arg_4           = dword ptr  8
.text$x:00006138
.text$x:00006138                 mov     edx, [esp+arg_4]
.text$x:0000613C                 lea     eax, [edx+0Ch]
.text$x:0000613F                 mov     ecx, [edx-8]
.text$x:00006142                 xor     ecx, eax
.text$x:00006144                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006149                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:0000614E                 jmp     ___CxxFrameHandler3
.text$x:0000614E __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:0000614E
.text$x:0000614E ; ---------------------------------------------------------------------------
.text$x:00006153                 align 4
.text$x:00006153 _text$x         ends
.text$x:00006153
.text$mn:00006154 ; ===========================================================================
.text$mn:00006154
.text$mn:00006154 ; Segment type: Pure code
.text$mn:00006154 ; Segment permissions: Read/Execute
.text$mn:00006154 _text$mn        segment para public 'CODE' use32
.text$mn:00006154                 assume cs:_text$mn
.text$mn:00006154                 ;org 6154h
.text$mn:00006154 ; COMDAT (pick any)
.text$mn:00006154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006154
.text$mn:00006154 ; =============== S U B R O U T I N E =======================================
.text$mn:00006154
.text$mn:00006154 ; Attributes: bp-based frame
.text$mn:00006154
.text$mn:00006154 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:00006154                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00006154 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00006154                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006154                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006154
.text$mn:00006154 var_10          = dword ptr -10h
.text$mn:00006154 var_C           = dword ptr -0Ch
.text$mn:00006154 var_4           = dword ptr -4
.text$mn:00006154
.text$mn:00006154                 push    ebp
.text$mn:00006155                 mov     ebp, esp
.text$mn:00006157                 push    0FFFFFFFFh
.text$mn:00006159                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000615E                 mov     eax, large fs:0
.text$mn:00006164                 push    eax
.text$mn:00006165                 push    ecx
.text$mn:00006166                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000616B                 xor     eax, ebp
.text$mn:0000616D                 push    eax
.text$mn:0000616E                 lea     eax, [ebp+var_C]
.text$mn:00006171                 mov     large fs:0, eax
.text$mn:00006177                 mov     [ebp+var_10], ecx
.text$mn:0000617A                 mov     [ebp+var_4], 0
.text$mn:00006181                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006188                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000618B                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006190                 mov     ecx, [ebp+var_C]
.text$mn:00006193                 mov     large fs:0, ecx
.text$mn:0000619A                 pop     ecx
.text$mn:0000619B                 mov     esp, ebp
.text$mn:0000619D                 pop     ebp
.text$mn:0000619E                 retn
.text$mn:0000619E ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000619E
.text$mn:0000619E ; ---------------------------------------------------------------------------
.text$mn:0000619F                 align 10h
.text$mn:0000619F _text$mn        ends
.text$mn:0000619F
.text$x:000061A0 ; ===========================================================================
.text$x:000061A0
.text$x:000061A0 ; Segment type: Pure code
.text$x:000061A0 ; Segment permissions: Read/Execute
.text$x:000061A0 _text$x         segment para public 'CODE' use32
.text$x:000061A0                 assume cs:_text$x
.text$x:000061A0                 ;org 61A0h
.text$x:000061A0 ; COMDAT (pick associative to section at 6154)
.text$x:000061A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000061A0
.text$x:000061A0 ; =============== S U B R O U T I N E =======================================
.text$x:000061A0
.text$x:000061A0
.text$x:000061A0 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000061A0                                         ; DATA XREF: .xdata$x:0000AA40o
.text$x:000061A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000061A3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000061A3 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000061A3
.text$x:000061A8
.text$x:000061A8 ; =============== S U B R O U T I N E =======================================
.text$x:000061A8
.text$x:000061A8
.text$x:000061A8 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:000061A8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:000061A8
.text$x:000061A8 arg_4           = dword ptr  8
.text$x:000061A8
.text$x:000061A8                 mov     edx, [esp+arg_4]
.text$x:000061AC                 lea     eax, [edx+0Ch]
.text$x:000061AF                 mov     ecx, [edx-8]
.text$x:000061B2                 xor     ecx, eax
.text$x:000061B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000061B9                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:000061BE                 jmp     ___CxxFrameHandler3
.text$x:000061BE __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000061BE
.text$x:000061BE ; ---------------------------------------------------------------------------
.text$x:000061C3                 align 4
.text$x:000061C3 _text$x         ends
.text$x:000061C3
.text$mn:000061C4 ; ===========================================================================
.text$mn:000061C4
.text$mn:000061C4 ; Segment type: Pure code
.text$mn:000061C4 ; Segment permissions: Read/Execute
.text$mn:000061C4 _text$mn        segment para public 'CODE' use32
.text$mn:000061C4                 assume cs:_text$mn
.text$mn:000061C4                 ;org 61C4h
.text$mn:000061C4 ; COMDAT (pick any)
.text$mn:000061C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061C4
.text$mn:000061C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000061C4
.text$mn:000061C4 ; Attributes: bp-based frame
.text$mn:000061C4
.text$mn:000061C4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct ColumnModeInfo, int, struct ColumnModeInfo const *, struct ColumnModeInfo const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct ColumnModeInfo, int, struct ColumnModeInfo const *, struct ColumnModeInfo const &, struct std::_Iterator_base12>(void)
.text$mn:000061C4                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000061C4 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000061C4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:000061C4                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:000061C4
.text$mn:000061C4 var_10          = dword ptr -10h
.text$mn:000061C4 var_C           = dword ptr -0Ch
.text$mn:000061C4 var_4           = dword ptr -4
.text$mn:000061C4
.text$mn:000061C4                 push    ebp
.text$mn:000061C5                 mov     ebp, esp
.text$mn:000061C7                 push    0FFFFFFFFh
.text$mn:000061C9                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000061CE                 mov     eax, large fs:0
.text$mn:000061D4                 push    eax
.text$mn:000061D5                 push    ecx
.text$mn:000061D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000061DB                 xor     eax, ebp
.text$mn:000061DD                 push    eax
.text$mn:000061DE                 lea     eax, [ebp+var_C]
.text$mn:000061E1                 mov     large fs:0, eax
.text$mn:000061E7                 mov     [ebp+var_10], ecx
.text$mn:000061EA                 mov     [ebp+var_4], 0
.text$mn:000061F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000061F8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000061FB                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006200                 mov     ecx, [ebp+var_C]
.text$mn:00006203                 mov     large fs:0, ecx
.text$mn:0000620A                 pop     ecx
.text$mn:0000620B                 mov     esp, ebp
.text$mn:0000620D                 pop     ebp
.text$mn:0000620E                 retn
.text$mn:0000620E ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000620E
.text$mn:0000620E ; ---------------------------------------------------------------------------
.text$mn:0000620F                 align 10h
.text$mn:0000620F _text$mn        ends
.text$mn:0000620F
.text$x:00006210 ; ===========================================================================
.text$x:00006210
.text$x:00006210 ; Segment type: Pure code
.text$x:00006210 ; Segment permissions: Read/Execute
.text$x:00006210 _text$x         segment para public 'CODE' use32
.text$x:00006210                 assume cs:_text$x
.text$x:00006210                 ;org 6210h
.text$x:00006210 ; COMDAT (pick associative to section at 61C4)
.text$x:00006210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006210
.text$x:00006210 ; =============== S U B R O U T I N E =======================================
.text$x:00006210
.text$x:00006210
.text$x:00006210 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00006210                                         ; DATA XREF: .xdata$x:0000A80Co
.text$x:00006210                 mov     ecx, [ebp-10h]  ; this
.text$x:00006213                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006213 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00006213
.text$x:00006218
.text$x:00006218 ; =============== S U B R O U T I N E =======================================
.text$x:00006218
.text$x:00006218
.text$x:00006218 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00006218                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)+5o
.text$x:00006218
.text$x:00006218 arg_4           = dword ptr  8
.text$x:00006218
.text$x:00006218                 mov     edx, [esp+arg_4]
.text$x:0000621C                 lea     eax, [edx+0Ch]
.text$x:0000621F                 mov     ecx, [edx-8]
.text$x:00006222                 xor     ecx, eax
.text$x:00006224                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006229                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000622E                 jmp     ___CxxFrameHandler3
.text$x:0000622E __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000622E
.text$x:0000622E ; ---------------------------------------------------------------------------
.text$x:00006233                 align 4
.text$x:00006233 _text$x         ends
.text$x:00006233
.text$mn:00006234 ; ===========================================================================
.text$mn:00006234
.text$mn:00006234 ; Segment type: Pure code
.text$mn:00006234 ; Segment permissions: Read/Execute
.text$mn:00006234 _text$mn        segment para public 'CODE' use32
.text$mn:00006234                 assume cs:_text$mn
.text$mn:00006234                 ;org 6234h
.text$mn:00006234 ; COMDAT (pick any)
.text$mn:00006234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006234
.text$mn:00006234 ; =============== S U B R O U T I N E =======================================
.text$mn:00006234
.text$mn:00006234 ; Attributes: bp-based frame
.text$mn:00006234
.text$mn:00006234 ; public: __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, struct std::iterator<struct std::random_access_iterator_tag, int, int, int *, int &>>::~_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, struct std::iterator<struct std::random_access_iterator_tag, int, int, int *, int &>>(void)
.text$mn:00006234                 public ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ
.text$mn:00006234 ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ proc near
.text$mn:00006234                                         ; CODE XREF: __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006234                                         ; __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$2+3j ...
.text$mn:00006234
.text$mn:00006234 var_10          = dword ptr -10h
.text$mn:00006234 var_C           = dword ptr -0Ch
.text$mn:00006234 var_4           = dword ptr -4
.text$mn:00006234
.text$mn:00006234                 push    ebp
.text$mn:00006235                 mov     ebp, esp
.text$mn:00006237                 push    0FFFFFFFFh
.text$mn:00006239                 push    offset __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ
.text$mn:0000623E                 mov     eax, large fs:0
.text$mn:00006244                 push    eax
.text$mn:00006245                 push    ecx
.text$mn:00006246                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000624B                 xor     eax, ebp
.text$mn:0000624D                 push    eax
.text$mn:0000624E                 lea     eax, [ebp+var_C]
.text$mn:00006251                 mov     large fs:0, eax
.text$mn:00006257                 mov     [ebp+var_10], ecx
.text$mn:0000625A                 mov     [ebp+var_4], 0
.text$mn:00006261                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006268                 mov     ecx, [ebp+var_10]
.text$mn:0000626B                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00006270                 mov     ecx, [ebp+var_C]
.text$mn:00006273                 mov     large fs:0, ecx
.text$mn:0000627A                 pop     ecx
.text$mn:0000627B                 mov     esp, ebp
.text$mn:0000627D                 pop     ebp
.text$mn:0000627E                 retn
.text$mn:0000627E ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ endp
.text$mn:0000627E
.text$mn:0000627E ; ---------------------------------------------------------------------------
.text$mn:0000627F                 align 10h
.text$mn:0000627F _text$mn        ends
.text$mn:0000627F
.text$x:00006280 ; ===========================================================================
.text$x:00006280
.text$x:00006280 ; Segment type: Pure code
.text$x:00006280 ; Segment permissions: Read/Execute
.text$x:00006280 _text$x         segment para public 'CODE' use32
.text$x:00006280                 assume cs:_text$x
.text$x:00006280                 ;org 6280h
.text$x:00006280 ; COMDAT (pick associative to section at 6234)
.text$x:00006280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006280
.text$x:00006280 ; =============== S U B R O U T I N E =======================================
.text$x:00006280
.text$x:00006280
.text$x:00006280 __unwindfunclet$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ$0 proc near
.text$x:00006280                                         ; DATA XREF: .xdata$x:0000AC00o
.text$x:00006280                 mov     ecx, [ebp-10h]
.text$x:00006283                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006283 __unwindfunclet$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ$0 endp
.text$x:00006283
.text$x:00006288
.text$x:00006288 ; =============== S U B R O U T I N E =======================================
.text$x:00006288
.text$x:00006288
.text$x:00006288 __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ proc near
.text$x:00006288                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(void)+5o
.text$x:00006288
.text$x:00006288 arg_4           = dword ptr  8
.text$x:00006288
.text$x:00006288                 mov     edx, [esp+arg_4]
.text$x:0000628C                 lea     eax, [edx+0Ch]
.text$x:0000628F                 mov     ecx, [edx-8]
.text$x:00006292                 xor     ecx, eax
.text$x:00006294                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006299                 mov     eax, offset __ehfuncinfo$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ
.text$x:0000629E                 jmp     ___CxxFrameHandler3
.text$x:0000629E __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ endp
.text$x:0000629E
.text$x:0000629E ; ---------------------------------------------------------------------------
.text$x:000062A3                 align 4
.text$x:000062A3 _text$x         ends
.text$x:000062A3
.text$mn:000062A4 ; ===========================================================================
.text$mn:000062A4
.text$mn:000062A4 ; Segment type: Pure code
.text$mn:000062A4 ; Segment permissions: Read/Execute
.text$mn:000062A4 _text$mn        segment para public 'CODE' use32
.text$mn:000062A4                 assume cs:_text$mn
.text$mn:000062A4                 ;org 62A4h
.text$mn:000062A4 ; COMDAT (pick any)
.text$mn:000062A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000062A4
.text$mn:000062A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000062A4
.text$mn:000062A4 ; Attributes: bp-based frame
.text$mn:000062A4
.text$mn:000062A4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000062A4                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000062A4 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000062A4                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000062A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000062A4
.text$mn:000062A4 var_10          = dword ptr -10h
.text$mn:000062A4 var_C           = dword ptr -0Ch
.text$mn:000062A4 var_4           = dword ptr -4
.text$mn:000062A4
.text$mn:000062A4                 push    ebp
.text$mn:000062A5                 mov     ebp, esp
.text$mn:000062A7                 push    0FFFFFFFFh
.text$mn:000062A9                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000062AE                 mov     eax, large fs:0
.text$mn:000062B4                 push    eax
.text$mn:000062B5                 push    ecx
.text$mn:000062B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000062BB                 xor     eax, ebp
.text$mn:000062BD                 push    eax
.text$mn:000062BE                 lea     eax, [ebp+var_C]
.text$mn:000062C1                 mov     large fs:0, eax
.text$mn:000062C7                 mov     [ebp+var_10], ecx
.text$mn:000062CA                 mov     [ebp+var_4], 0
.text$mn:000062D1                 mov     ecx, [ebp+var_10]
.text$mn:000062D4                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:000062D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000062E0                 mov     ecx, [ebp+var_10]
.text$mn:000062E3                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:000062E8                 mov     ecx, [ebp+var_C]
.text$mn:000062EB                 mov     large fs:0, ecx
.text$mn:000062F2                 pop     ecx
.text$mn:000062F3                 mov     esp, ebp
.text$mn:000062F5                 pop     ebp
.text$mn:000062F6                 retn
.text$mn:000062F6 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:000062F6
.text$mn:000062F6 ; ---------------------------------------------------------------------------
.text$mn:000062F7                 align 4
.text$mn:000062F7 _text$mn        ends
.text$mn:000062F7
.text$x:000062F8 ; ===========================================================================
.text$x:000062F8
.text$x:000062F8 ; Segment type: Pure code
.text$x:000062F8 ; Segment permissions: Read/Execute
.text$x:000062F8 _text$x         segment para public 'CODE' use32
.text$x:000062F8                 assume cs:_text$x
.text$x:000062F8                 ;org 62F8h
.text$x:000062F8 ; COMDAT (pick associative to section at 62A4)
.text$x:000062F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000062F8
.text$x:000062F8 ; =============== S U B R O U T I N E =======================================
.text$x:000062F8
.text$x:000062F8
.text$x:000062F8 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000062F8                                         ; DATA XREF: .xdata$x:00009F8Co
.text$x:000062F8                 mov     ecx, [ebp-10h]
.text$x:000062FB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000062FB __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000062FB
.text$x:00006300
.text$x:00006300 ; =============== S U B R O U T I N E =======================================
.text$x:00006300
.text$x:00006300
.text$x:00006300 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006300                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00006300
.text$x:00006300 arg_4           = dword ptr  8
.text$x:00006300
.text$x:00006300                 mov     edx, [esp+arg_4]
.text$x:00006304                 lea     eax, [edx+0Ch]
.text$x:00006307                 mov     ecx, [edx-8]
.text$x:0000630A                 xor     ecx, eax
.text$x:0000630C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006311                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00006316                 jmp     ___CxxFrameHandler3
.text$x:00006316 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00006316
.text$x:00006316 ; ---------------------------------------------------------------------------
.text$x:0000631B                 align 4
.text$x:0000631B _text$x         ends
.text$x:0000631B
.text$mn:0000631C ; ===========================================================================
.text$mn:0000631C
.text$mn:0000631C ; Segment type: Pure code
.text$mn:0000631C ; Segment permissions: Read/Execute
.text$mn:0000631C _text$mn        segment para public 'CODE' use32
.text$mn:0000631C                 assume cs:_text$mn
.text$mn:0000631C                 ;org 631Ch
.text$mn:0000631C ; COMDAT (pick any)
.text$mn:0000631C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000631C
.text$mn:0000631C ; =============== S U B R O U T I N E =======================================
.text$mn:0000631C
.text$mn:0000631C ; Attributes: bp-based frame
.text$mn:0000631C
.text$mn:0000631C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:0000631C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:0000631C ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000631C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z$0+3j
.text$mn:0000631C                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j ...
.text$mn:0000631C
.text$mn:0000631C var_10          = dword ptr -10h
.text$mn:0000631C var_C           = dword ptr -0Ch
.text$mn:0000631C var_4           = dword ptr -4
.text$mn:0000631C
.text$mn:0000631C                 push    ebp
.text$mn:0000631D                 mov     ebp, esp
.text$mn:0000631F                 push    0FFFFFFFFh
.text$mn:00006321                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006326                 mov     eax, large fs:0
.text$mn:0000632C                 push    eax
.text$mn:0000632D                 push    ecx
.text$mn:0000632E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006333                 xor     eax, ebp
.text$mn:00006335                 push    eax
.text$mn:00006336                 lea     eax, [ebp+var_C]
.text$mn:00006339                 mov     large fs:0, eax
.text$mn:0000633F                 mov     [ebp+var_10], ecx
.text$mn:00006342                 mov     [ebp+var_4], 0
.text$mn:00006349                 mov     ecx, [ebp+var_10]
.text$mn:0000634C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00006351                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006358                 mov     ecx, [ebp+var_10]
.text$mn:0000635B                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00006360                 mov     ecx, [ebp+var_C]
.text$mn:00006363                 mov     large fs:0, ecx
.text$mn:0000636A                 pop     ecx
.text$mn:0000636B                 mov     esp, ebp
.text$mn:0000636D                 pop     ebp
.text$mn:0000636E                 retn
.text$mn:0000636E ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000636E
.text$mn:0000636E ; ---------------------------------------------------------------------------
.text$mn:0000636F                 align 10h
.text$mn:0000636F _text$mn        ends
.text$mn:0000636F
.text$x:00006370 ; ===========================================================================
.text$x:00006370
.text$x:00006370 ; Segment type: Pure code
.text$x:00006370 ; Segment permissions: Read/Execute
.text$x:00006370 _text$x         segment para public 'CODE' use32
.text$x:00006370                 assume cs:_text$x
.text$x:00006370                 ;org 6370h
.text$x:00006370 ; COMDAT (pick associative to section at 631C)
.text$x:00006370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006370
.text$x:00006370 ; =============== S U B R O U T I N E =======================================
.text$x:00006370
.text$x:00006370
.text$x:00006370 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006370                                         ; DATA XREF: .xdata$x:0000A3D4o
.text$x:00006370                 mov     ecx, [ebp-10h]
.text$x:00006373                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00006373 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006373
.text$x:00006378
.text$x:00006378 ; =============== S U B R O U T I N E =======================================
.text$x:00006378
.text$x:00006378
.text$x:00006378 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006378                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00006378
.text$x:00006378 arg_4           = dword ptr  8
.text$x:00006378
.text$x:00006378                 mov     edx, [esp+arg_4]
.text$x:0000637C                 lea     eax, [edx+0Ch]
.text$x:0000637F                 mov     ecx, [edx-8]
.text$x:00006382                 xor     ecx, eax
.text$x:00006384                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006389                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000638E                 jmp     ___CxxFrameHandler3
.text$x:0000638E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000638E
.text$x:0000638E ; ---------------------------------------------------------------------------
.text$x:00006393                 align 4
.text$x:00006393 _text$x         ends
.text$x:00006393
.text$mn:00006394 ; ===========================================================================
.text$mn:00006394
.text$mn:00006394 ; Segment type: Pure code
.text$mn:00006394 ; Segment permissions: Read/Execute
.text$mn:00006394 _text$mn        segment para public 'CODE' use32
.text$mn:00006394                 assume cs:_text$mn
.text$mn:00006394                 ;org 6394h
.text$mn:00006394 ; COMDAT (pick any)
.text$mn:00006394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006394
.text$mn:00006394 ; =============== S U B R O U T I N E =======================================
.text$mn:00006394
.text$mn:00006394 ; Attributes: bp-based frame
.text$mn:00006394
.text$mn:00006394 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00006394                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006394 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00006394                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00006394                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00006394
.text$mn:00006394 var_10          = dword ptr -10h
.text$mn:00006394 var_C           = dword ptr -0Ch
.text$mn:00006394 var_4           = dword ptr -4
.text$mn:00006394
.text$mn:00006394                 push    ebp
.text$mn:00006395                 mov     ebp, esp
.text$mn:00006397                 push    0FFFFFFFFh
.text$mn:00006399                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000639E                 mov     eax, large fs:0
.text$mn:000063A4                 push    eax
.text$mn:000063A5                 push    ecx
.text$mn:000063A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000063AB                 xor     eax, ebp
.text$mn:000063AD                 push    eax
.text$mn:000063AE                 lea     eax, [ebp+var_C]
.text$mn:000063B1                 mov     large fs:0, eax
.text$mn:000063B7                 mov     [ebp+var_10], ecx
.text$mn:000063BA                 mov     [ebp+var_4], 0
.text$mn:000063C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000063C8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000063CB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000063D0                 mov     ecx, [ebp+var_C]
.text$mn:000063D3                 mov     large fs:0, ecx
.text$mn:000063DA                 pop     ecx
.text$mn:000063DB                 mov     esp, ebp
.text$mn:000063DD                 pop     ebp
.text$mn:000063DE                 retn
.text$mn:000063DE ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000063DE
.text$mn:000063DE ; ---------------------------------------------------------------------------
.text$mn:000063DF                 align 10h
.text$mn:000063DF _text$mn        ends
.text$mn:000063DF
.text$x:000063E0 ; ===========================================================================
.text$x:000063E0
.text$x:000063E0 ; Segment type: Pure code
.text$x:000063E0 ; Segment permissions: Read/Execute
.text$x:000063E0 _text$x         segment para public 'CODE' use32
.text$x:000063E0                 assume cs:_text$x
.text$x:000063E0                 ;org 63E0h
.text$x:000063E0 ; COMDAT (pick associative to section at 6394)
.text$x:000063E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000063E0
.text$x:000063E0 ; =============== S U B R O U T I N E =======================================
.text$x:000063E0
.text$x:000063E0
.text$x:000063E0 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000063E0                                         ; DATA XREF: .xdata$x:00009F34o
.text$x:000063E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000063E3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000063E3 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000063E3
.text$x:000063E8
.text$x:000063E8 ; =============== S U B R O U T I N E =======================================
.text$x:000063E8
.text$x:000063E8
.text$x:000063E8 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000063E8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000063E8
.text$x:000063E8 arg_4           = dword ptr  8
.text$x:000063E8
.text$x:000063E8                 mov     edx, [esp+arg_4]
.text$x:000063EC                 lea     eax, [edx+0Ch]
.text$x:000063EF                 mov     ecx, [edx-8]
.text$x:000063F2                 xor     ecx, eax
.text$x:000063F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000063F9                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000063FE                 jmp     ___CxxFrameHandler3
.text$x:000063FE __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000063FE
.text$x:000063FE ; ---------------------------------------------------------------------------
.text$x:00006403                 align 4
.text$x:00006403 _text$x         ends
.text$x:00006403
.text$mn:00006404 ; ===========================================================================
.text$mn:00006404
.text$mn:00006404 ; Segment type: Pure code
.text$mn:00006404 ; Segment permissions: Read/Execute
.text$mn:00006404 _text$mn        segment para public 'CODE' use32
.text$mn:00006404                 assume cs:_text$mn
.text$mn:00006404                 ;org 6404h
.text$mn:00006404 ; COMDAT (pick any)
.text$mn:00006404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006404
.text$mn:00006404 ; =============== S U B R O U T I N E =======================================
.text$mn:00006404
.text$mn:00006404 ; Attributes: bp-based frame
.text$mn:00006404
.text$mn:00006404 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00006404                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006404 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006404                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00006404                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00006404
.text$mn:00006404 var_10          = dword ptr -10h
.text$mn:00006404 var_C           = dword ptr -0Ch
.text$mn:00006404 var_4           = dword ptr -4
.text$mn:00006404
.text$mn:00006404                 push    ebp
.text$mn:00006405                 mov     ebp, esp
.text$mn:00006407                 push    0FFFFFFFFh
.text$mn:00006409                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000640E                 mov     eax, large fs:0
.text$mn:00006414                 push    eax
.text$mn:00006415                 push    ecx
.text$mn:00006416                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000641B                 xor     eax, ebp
.text$mn:0000641D                 push    eax
.text$mn:0000641E                 lea     eax, [ebp+var_C]
.text$mn:00006421                 mov     large fs:0, eax
.text$mn:00006427                 mov     [ebp+var_10], ecx
.text$mn:0000642A                 mov     [ebp+var_4], 0
.text$mn:00006431                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006438                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000643B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006440                 mov     ecx, [ebp+var_C]
.text$mn:00006443                 mov     large fs:0, ecx
.text$mn:0000644A                 pop     ecx
.text$mn:0000644B                 mov     esp, ebp
.text$mn:0000644D                 pop     ebp
.text$mn:0000644E                 retn
.text$mn:0000644E ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000644E
.text$mn:0000644E ; ---------------------------------------------------------------------------
.text$mn:0000644F                 align 10h
.text$mn:0000644F _text$mn        ends
.text$mn:0000644F
.text$x:00006450 ; ===========================================================================
.text$x:00006450
.text$x:00006450 ; Segment type: Pure code
.text$x:00006450 ; Segment permissions: Read/Execute
.text$x:00006450 _text$x         segment para public 'CODE' use32
.text$x:00006450                 assume cs:_text$x
.text$x:00006450                 ;org 6450h
.text$x:00006450 ; COMDAT (pick associative to section at 6404)
.text$x:00006450                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006450
.text$x:00006450 ; =============== S U B R O U T I N E =======================================
.text$x:00006450
.text$x:00006450
.text$x:00006450 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00006450                                         ; DATA XREF: .xdata$x:0000A37Co
.text$x:00006450                 mov     ecx, [ebp-10h]  ; this
.text$x:00006453                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006453 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00006453
.text$x:00006458
.text$x:00006458 ; =============== S U B R O U T I N E =======================================
.text$x:00006458
.text$x:00006458
.text$x:00006458 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00006458                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00006458
.text$x:00006458 arg_4           = dword ptr  8
.text$x:00006458
.text$x:00006458                 mov     edx, [esp+arg_4]
.text$x:0000645C                 lea     eax, [edx+0Ch]
.text$x:0000645F                 mov     ecx, [edx-8]
.text$x:00006462                 xor     ecx, eax
.text$x:00006464                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006469                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000646E                 jmp     ___CxxFrameHandler3
.text$x:0000646E __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000646E
.text$x:0000646E ; ---------------------------------------------------------------------------
.text$x:00006473                 align 4
.text$x:00006473 _text$x         ends
.text$x:00006473
.text$mn:00006474 ; ===========================================================================
.text$mn:00006474
.text$mn:00006474 ; Segment type: Pure code
.text$mn:00006474 ; Segment permissions: Read/Execute
.text$mn:00006474 _text$mn        segment para public 'CODE' use32
.text$mn:00006474                 assume cs:_text$mn
.text$mn:00006474                 ;org 6474h
.text$mn:00006474 ; COMDAT (pick any)
.text$mn:00006474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006474
.text$mn:00006474 ; =============== S U B R O U T I N E =======================================
.text$mn:00006474
.text$mn:00006474 ; Attributes: bp-based frame
.text$mn:00006474
.text$mn:00006474 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::~_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>(void)
.text$mn:00006474                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$mn:00006474 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006474                                         ; CODE XREF: __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0+3j
.text$mn:00006474                                         ; std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+3Fp ...
.text$mn:00006474
.text$mn:00006474 var_10          = dword ptr -10h
.text$mn:00006474 var_C           = dword ptr -0Ch
.text$mn:00006474 var_4           = dword ptr -4
.text$mn:00006474
.text$mn:00006474                 push    ebp
.text$mn:00006475                 mov     ebp, esp
.text$mn:00006477                 push    0FFFFFFFFh
.text$mn:00006479                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000647E                 mov     eax, large fs:0
.text$mn:00006484                 push    eax
.text$mn:00006485                 push    ecx
.text$mn:00006486                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000648B                 xor     eax, ebp
.text$mn:0000648D                 push    eax
.text$mn:0000648E                 lea     eax, [ebp+var_C]
.text$mn:00006491                 mov     large fs:0, eax
.text$mn:00006497                 mov     [ebp+var_10], ecx
.text$mn:0000649A                 mov     [ebp+var_4], 0
.text$mn:000064A1                 mov     ecx, [ebp+var_10]
.text$mn:000064A4                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)
.text$mn:000064A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000064B0                 mov     ecx, [ebp+var_10]
.text$mn:000064B3                 call    ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$mn:000064B8                 mov     ecx, [ebp+var_C]
.text$mn:000064BB                 mov     large fs:0, ecx
.text$mn:000064C2                 pop     ecx
.text$mn:000064C3                 mov     esp, ebp
.text$mn:000064C5                 pop     ebp
.text$mn:000064C6                 retn
.text$mn:000064C6 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:000064C6
.text$mn:000064C6 ; ---------------------------------------------------------------------------
.text$mn:000064C7                 align 4
.text$mn:000064C7 _text$mn        ends
.text$mn:000064C7
.text$x:000064C8 ; ===========================================================================
.text$x:000064C8
.text$x:000064C8 ; Segment type: Pure code
.text$x:000064C8 ; Segment permissions: Read/Execute
.text$x:000064C8 _text$x         segment para public 'CODE' use32
.text$x:000064C8                 assume cs:_text$x
.text$x:000064C8                 ;org 64C8h
.text$x:000064C8 ; COMDAT (pick associative to section at 6474)
.text$x:000064C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000064C8
.text$x:000064C8 ; =============== S U B R O U T I N E =======================================
.text$x:000064C8
.text$x:000064C8
.text$x:000064C8 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000064C8                                         ; DATA XREF: .xdata$x:0000A594o
.text$x:000064C8                 mov     ecx, [ebp-10h]
.text$x:000064CB                 jmp     ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)
.text$x:000064CB __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000064CB
.text$x:000064D0
.text$x:000064D0 ; =============== S U B R O U T I N E =======================================
.text$x:000064D0
.text$x:000064D0
.text$x:000064D0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:000064D0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+5o
.text$x:000064D0
.text$x:000064D0 arg_4           = dword ptr  8
.text$x:000064D0
.text$x:000064D0                 mov     edx, [esp+arg_4]
.text$x:000064D4                 lea     eax, [edx+0Ch]
.text$x:000064D7                 mov     ecx, [edx-8]
.text$x:000064DA                 xor     ecx, eax
.text$x:000064DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000064E1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.text$x:000064E6                 jmp     ___CxxFrameHandler3
.text$x:000064E6 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ endp
.text$x:000064E6
.text$x:000064E6 ; ---------------------------------------------------------------------------
.text$x:000064EB                 align 4
.text$x:000064EB _text$x         ends
.text$x:000064EB
.text$mn:000064EC ; ===========================================================================
.text$mn:000064EC
.text$mn:000064EC ; Segment type: Pure code
.text$mn:000064EC ; Segment permissions: Read/Execute
.text$mn:000064EC _text$mn        segment para public 'CODE' use32
.text$mn:000064EC                 assume cs:_text$mn
.text$mn:000064EC                 ;org 64ECh
.text$mn:000064EC ; COMDAT (pick any)
.text$mn:000064EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064EC
.text$mn:000064EC ; =============== S U B R O U T I N E =======================================
.text$mn:000064EC
.text$mn:000064EC ; Attributes: bp-based frame
.text$mn:000064EC
.text$mn:000064EC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>>(void)
.text$mn:000064EC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:000064EC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000064EC                                         ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::~vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>(void)+3Fp
.text$mn:000064EC                                         ; __unwindfunclet$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ$0+3j
.text$mn:000064EC
.text$mn:000064EC var_10          = dword ptr -10h
.text$mn:000064EC var_C           = dword ptr -0Ch
.text$mn:000064EC var_4           = dword ptr -4
.text$mn:000064EC
.text$mn:000064EC                 push    ebp
.text$mn:000064ED                 mov     ebp, esp
.text$mn:000064EF                 push    0FFFFFFFFh
.text$mn:000064F1                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:000064F6                 mov     eax, large fs:0
.text$mn:000064FC                 push    eax
.text$mn:000064FD                 push    ecx
.text$mn:000064FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006503                 xor     eax, ebp
.text$mn:00006505                 push    eax
.text$mn:00006506                 lea     eax, [ebp+var_C]
.text$mn:00006509                 mov     large fs:0, eax
.text$mn:0000650F                 mov     [ebp+var_10], ecx
.text$mn:00006512                 mov     [ebp+var_4], 0
.text$mn:00006519                 mov     ecx, [ebp+var_10]
.text$mn:0000651C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::_Free_proxy(void)
.text$mn:00006521                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006528                 mov     ecx, [ebp+var_10]
.text$mn:0000652B                 call    ??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<ColumnModeInfo>>::~_Vector_val<std::_Simple_types<ColumnModeInfo>>(void)
.text$mn:00006530                 mov     ecx, [ebp+var_C]
.text$mn:00006533                 mov     large fs:0, ecx
.text$mn:0000653A                 pop     ecx
.text$mn:0000653B                 mov     esp, ebp
.text$mn:0000653D                 pop     ebp
.text$mn:0000653E                 retn
.text$mn:0000653E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000653E
.text$mn:0000653E ; ---------------------------------------------------------------------------
.text$mn:0000653F                 align 10h
.text$mn:0000653F _text$mn        ends
.text$mn:0000653F
.text$x:00006540 ; ===========================================================================
.text$x:00006540
.text$x:00006540 ; Segment type: Pure code
.text$x:00006540 ; Segment permissions: Read/Execute
.text$x:00006540 _text$x         segment para public 'CODE' use32
.text$x:00006540                 assume cs:_text$x
.text$x:00006540                 ;org 6540h
.text$x:00006540 ; COMDAT (pick associative to section at 64EC)
.text$x:00006540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006540
.text$x:00006540 ; =============== S U B R O U T I N E =======================================
.text$x:00006540
.text$x:00006540
.text$x:00006540 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006540                                         ; DATA XREF: .xdata$x:0000A730o
.text$x:00006540                 mov     ecx, [ebp-10h]
.text$x:00006543                 jmp     ??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<ColumnModeInfo>>::~_Vector_val<std::_Simple_types<ColumnModeInfo>>(void)
.text$x:00006543 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006543
.text$x:00006548
.text$x:00006548 ; =============== S U B R O U T I N E =======================================
.text$x:00006548
.text$x:00006548
.text$x:00006548 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006548                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>(void)+5o
.text$x:00006548
.text$x:00006548 arg_4           = dword ptr  8
.text$x:00006548
.text$x:00006548                 mov     edx, [esp+arg_4]
.text$x:0000654C                 lea     eax, [edx+0Ch]
.text$x:0000654F                 mov     ecx, [edx-8]
.text$x:00006552                 xor     ecx, eax
.text$x:00006554                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006559                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$x:0000655E                 jmp     ___CxxFrameHandler3
.text$x:0000655E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000655E
.text$x:0000655E ; ---------------------------------------------------------------------------
.text$x:00006563                 align 4
.text$x:00006563 _text$x         ends
.text$x:00006563
.text$mn:00006564 ; ===========================================================================
.text$mn:00006564
.text$mn:00006564 ; Segment type: Pure code
.text$mn:00006564 ; Segment permissions: Read/Execute
.text$mn:00006564 _text$mn        segment para public 'CODE' use32
.text$mn:00006564                 assume cs:_text$mn
.text$mn:00006564                 ;org 6564h
.text$mn:00006564 ; COMDAT (pick any)
.text$mn:00006564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006564
.text$mn:00006564 ; =============== S U B R O U T I N E =======================================
.text$mn:00006564
.text$mn:00006564 ; Attributes: bp-based frame
.text$mn:00006564
.text$mn:00006564 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>(void)
.text$mn:00006564                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:00006564 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006564                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006564                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006564
.text$mn:00006564 var_10          = dword ptr -10h
.text$mn:00006564 var_C           = dword ptr -0Ch
.text$mn:00006564 var_4           = dword ptr -4
.text$mn:00006564
.text$mn:00006564                 push    ebp
.text$mn:00006565                 mov     ebp, esp
.text$mn:00006567                 push    0FFFFFFFFh
.text$mn:00006569                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000656E                 mov     eax, large fs:0
.text$mn:00006574                 push    eax
.text$mn:00006575                 push    ecx
.text$mn:00006576                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000657B                 xor     eax, ebp
.text$mn:0000657D                 push    eax
.text$mn:0000657E                 lea     eax, [ebp+var_C]
.text$mn:00006581                 mov     large fs:0, eax
.text$mn:00006587                 mov     [ebp+var_10], ecx
.text$mn:0000658A                 mov     [ebp+var_4], 0
.text$mn:00006591                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006598                 mov     ecx, [ebp+var_10]
.text$mn:0000659B                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:000065A0                 mov     ecx, [ebp+var_C]
.text$mn:000065A3                 mov     large fs:0, ecx
.text$mn:000065AA                 pop     ecx
.text$mn:000065AB                 mov     esp, ebp
.text$mn:000065AD                 pop     ebp
.text$mn:000065AE                 retn
.text$mn:000065AE ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:000065AE
.text$mn:000065AE ; ---------------------------------------------------------------------------
.text$mn:000065AF                 align 10h
.text$mn:000065AF _text$mn        ends
.text$mn:000065AF
.text$x:000065B0 ; ===========================================================================
.text$x:000065B0
.text$x:000065B0 ; Segment type: Pure code
.text$x:000065B0 ; Segment permissions: Read/Execute
.text$x:000065B0 _text$x         segment para public 'CODE' use32
.text$x:000065B0                 assume cs:_text$x
.text$x:000065B0                 ;org 65B0h
.text$x:000065B0 ; COMDAT (pick associative to section at 6564)
.text$x:000065B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000065B0
.text$x:000065B0 ; =============== S U B R O U T I N E =======================================
.text$x:000065B0
.text$x:000065B0
.text$x:000065B0 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000065B0                                         ; DATA XREF: .xdata$x:0000AAC4o
.text$x:000065B0                 mov     ecx, [ebp-10h]
.text$x:000065B3                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:000065B3 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000065B3
.text$x:000065B8
.text$x:000065B8 ; =============== S U B R O U T I N E =======================================
.text$x:000065B8
.text$x:000065B8
.text$x:000065B8 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:000065B8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+5o
.text$x:000065B8
.text$x:000065B8 arg_4           = dword ptr  8
.text$x:000065B8
.text$x:000065B8                 mov     edx, [esp+arg_4]
.text$x:000065BC                 lea     eax, [edx+0Ch]
.text$x:000065BF                 mov     ecx, [edx-8]
.text$x:000065C2                 xor     ecx, eax
.text$x:000065C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000065C9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$x:000065CE                 jmp     ___CxxFrameHandler3
.text$x:000065CE __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$x:000065CE
.text$x:000065CE ; ---------------------------------------------------------------------------
.text$x:000065D3                 align 4
.text$x:000065D3 _text$x         ends
.text$x:000065D3
.text$mn:000065D4 ; ===========================================================================
.text$mn:000065D4
.text$mn:000065D4 ; Segment type: Pure code
.text$mn:000065D4 ; Segment permissions: Read/Execute
.text$mn:000065D4 _text$mn        segment para public 'CODE' use32
.text$mn:000065D4                 assume cs:_text$mn
.text$mn:000065D4                 ;org 65D4h
.text$mn:000065D4 ; COMDAT (pick any)
.text$mn:000065D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065D4
.text$mn:000065D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000065D4
.text$mn:000065D4 ; Attributes: bp-based frame
.text$mn:000065D4
.text$mn:000065D4 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>(void)
.text$mn:000065D4                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:000065D4 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000065D4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:000065D4                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:000065D4
.text$mn:000065D4 var_10          = dword ptr -10h
.text$mn:000065D4 var_C           = dword ptr -0Ch
.text$mn:000065D4 var_4           = dword ptr -4
.text$mn:000065D4
.text$mn:000065D4                 push    ebp
.text$mn:000065D5                 mov     ebp, esp
.text$mn:000065D7                 push    0FFFFFFFFh
.text$mn:000065D9                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:000065DE                 mov     eax, large fs:0
.text$mn:000065E4                 push    eax
.text$mn:000065E5                 push    ecx
.text$mn:000065E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000065EB                 xor     eax, ebp
.text$mn:000065ED                 push    eax
.text$mn:000065EE                 lea     eax, [ebp+var_C]
.text$mn:000065F1                 mov     large fs:0, eax
.text$mn:000065F7                 mov     [ebp+var_10], ecx
.text$mn:000065FA                 mov     [ebp+var_4], 0
.text$mn:00006601                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006608                 mov     ecx, [ebp+var_10]
.text$mn:0000660B                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)
.text$mn:00006610                 mov     ecx, [ebp+var_C]
.text$mn:00006613                 mov     large fs:0, ecx
.text$mn:0000661A                 pop     ecx
.text$mn:0000661B                 mov     esp, ebp
.text$mn:0000661D                 pop     ebp
.text$mn:0000661E                 retn
.text$mn:0000661E ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000661E
.text$mn:0000661E ; ---------------------------------------------------------------------------
.text$mn:0000661F                 align 10h
.text$mn:0000661F _text$mn        ends
.text$mn:0000661F
.text$x:00006620 ; ===========================================================================
.text$x:00006620
.text$x:00006620 ; Segment type: Pure code
.text$x:00006620 ; Segment permissions: Read/Execute
.text$x:00006620 _text$x         segment para public 'CODE' use32
.text$x:00006620                 assume cs:_text$x
.text$x:00006620                 ;org 6620h
.text$x:00006620 ; COMDAT (pick associative to section at 65D4)
.text$x:00006620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006620
.text$x:00006620 ; =============== S U B R O U T I N E =======================================
.text$x:00006620
.text$x:00006620
.text$x:00006620 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006620                                         ; DATA XREF: .xdata$x:0000A890o
.text$x:00006620                 mov     ecx, [ebp-10h]
.text$x:00006623                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ColumnModeInfo,int,ColumnModeInfo const *,ColumnModeInfo const &,std::_Iterator_base12>(void)
.text$x:00006623 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006623
.text$x:00006628
.text$x:00006628 ; =============== S U B R O U T I N E =======================================
.text$x:00006628
.text$x:00006628
.text$x:00006628 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006628                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)+5o
.text$x:00006628
.text$x:00006628 arg_4           = dword ptr  8
.text$x:00006628
.text$x:00006628                 mov     edx, [esp+arg_4]
.text$x:0000662C                 lea     eax, [edx+0Ch]
.text$x:0000662F                 mov     ecx, [edx-8]
.text$x:00006632                 xor     ecx, eax
.text$x:00006634                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006639                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$x:0000663E                 jmp     ___CxxFrameHandler3
.text$x:0000663E __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000663E
.text$x:0000663E ; ---------------------------------------------------------------------------
.text$x:00006643                 align 4
.text$x:00006643 _text$x         ends
.text$x:00006643
.text$mn:00006644 ; ===========================================================================
.text$mn:00006644
.text$mn:00006644 ; Segment type: Pure code
.text$mn:00006644 ; Segment permissions: Read/Execute
.text$mn:00006644 _text$mn        segment para public 'CODE' use32
.text$mn:00006644                 assume cs:_text$mn
.text$mn:00006644                 ;org 6644h
.text$mn:00006644 ; COMDAT (pick any)
.text$mn:00006644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006644
.text$mn:00006644 ; =============== S U B R O U T I N E =======================================
.text$mn:00006644
.text$mn:00006644 ; Attributes: bp-based frame
.text$mn:00006644
.text$mn:00006644 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>(void)
.text$mn:00006644                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:00006644 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006644                                         ; CODE XREF: __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006644                                         ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)+47p ...
.text$mn:00006644
.text$mn:00006644 var_10          = dword ptr -10h
.text$mn:00006644 var_C           = dword ptr -0Ch
.text$mn:00006644 var_4           = dword ptr -4
.text$mn:00006644
.text$mn:00006644                 push    ebp
.text$mn:00006645                 mov     ebp, esp
.text$mn:00006647                 push    0FFFFFFFFh
.text$mn:00006649                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:0000664E                 mov     eax, large fs:0
.text$mn:00006654                 push    eax
.text$mn:00006655                 push    ecx
.text$mn:00006656                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000665B                 xor     eax, ebp
.text$mn:0000665D                 push    eax
.text$mn:0000665E                 lea     eax, [ebp+var_C]
.text$mn:00006661                 mov     large fs:0, eax
.text$mn:00006667                 mov     [ebp+var_10], ecx
.text$mn:0000666A                 mov     [ebp+var_4], 0
.text$mn:00006671                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006678                 mov     ecx, [ebp+var_10]
.text$mn:0000667B                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00006680                 mov     ecx, [ebp+var_C]
.text$mn:00006683                 mov     large fs:0, ecx
.text$mn:0000668A                 pop     ecx
.text$mn:0000668B                 mov     esp, ebp
.text$mn:0000668D                 pop     ebp
.text$mn:0000668E                 retn
.text$mn:0000668E ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000668E
.text$mn:0000668E ; ---------------------------------------------------------------------------
.text$mn:0000668F                 align 10h
.text$mn:0000668F _text$mn        ends
.text$mn:0000668F
.text$x:00006690 ; ===========================================================================
.text$x:00006690
.text$x:00006690 ; Segment type: Pure code
.text$x:00006690 ; Segment permissions: Read/Execute
.text$x:00006690 _text$x         segment para public 'CODE' use32
.text$x:00006690                 assume cs:_text$x
.text$x:00006690                 ;org 6690h
.text$x:00006690 ; COMDAT (pick associative to section at 6644)
.text$x:00006690                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006690
.text$x:00006690 ; =============== S U B R O U T I N E =======================================
.text$x:00006690
.text$x:00006690
.text$x:00006690 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006690                                         ; DATA XREF: .xdata$x:0000AB48o
.text$x:00006690                 mov     ecx, [ebp-10h]
.text$x:00006693                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006693 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006693
.text$x:00006698
.text$x:00006698 ; =============== S U B R O U T I N E =======================================
.text$x:00006698
.text$x:00006698
.text$x:00006698 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006698                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+5o
.text$x:00006698
.text$x:00006698 arg_4           = dword ptr  8
.text$x:00006698
.text$x:00006698                 mov     edx, [esp+arg_4]
.text$x:0000669C                 lea     eax, [edx+0Ch]
.text$x:0000669F                 mov     ecx, [edx-8]
.text$x:000066A2                 xor     ecx, eax
.text$x:000066A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000066A9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$x:000066AE                 jmp     ___CxxFrameHandler3
.text$x:000066AE __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$x:000066AE
.text$x:000066AE ; ---------------------------------------------------------------------------
.text$x:000066B3                 align 4
.text$x:000066B3 _text$x         ends
.text$x:000066B3
.text$mn:000066B4 ; ===========================================================================
.text$mn:000066B4
.text$mn:000066B4 ; Segment type: Pure code
.text$mn:000066B4 ; Segment permissions: Read/Execute
.text$mn:000066B4 _text$mn        segment para public 'CODE' use32
.text$mn:000066B4                 assume cs:_text$mn
.text$mn:000066B4                 ;org 66B4h
.text$mn:000066B4 ; COMDAT (pick any)
.text$mn:000066B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066B4
.text$mn:000066B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000066B4
.text$mn:000066B4 ; Attributes: bp-based frame
.text$mn:000066B4
.text$mn:000066B4 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>(void)
.text$mn:000066B4                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:000066B4 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000066B4                                         ; CODE XREF: __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$1+6j
.text$mn:000066B4                                         ; __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$2+6j ...
.text$mn:000066B4
.text$mn:000066B4 var_10          = dword ptr -10h
.text$mn:000066B4 var_C           = dword ptr -0Ch
.text$mn:000066B4 var_4           = dword ptr -4
.text$mn:000066B4
.text$mn:000066B4                 push    ebp
.text$mn:000066B5                 mov     ebp, esp
.text$mn:000066B7                 push    0FFFFFFFFh
.text$mn:000066B9                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$mn:000066BE                 mov     eax, large fs:0
.text$mn:000066C4                 push    eax
.text$mn:000066C5                 push    ecx
.text$mn:000066C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066CB                 xor     eax, ebp
.text$mn:000066CD                 push    eax
.text$mn:000066CE                 lea     eax, [ebp+var_C]
.text$mn:000066D1                 mov     large fs:0, eax
.text$mn:000066D7                 mov     [ebp+var_10], ecx
.text$mn:000066DA                 mov     [ebp+var_4], 0
.text$mn:000066E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000066E8                 mov     ecx, [ebp+var_10]
.text$mn:000066EB                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$mn:000066F0                 mov     ecx, [ebp+var_C]
.text$mn:000066F3                 mov     large fs:0, ecx
.text$mn:000066FA                 pop     ecx
.text$mn:000066FB                 mov     esp, ebp
.text$mn:000066FD                 pop     ebp
.text$mn:000066FE                 retn
.text$mn:000066FE ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000066FE
.text$mn:000066FE ; ---------------------------------------------------------------------------
.text$mn:000066FF                 align 10h
.text$mn:000066FF _text$mn        ends
.text$mn:000066FF
.text$x:00006700 ; ===========================================================================
.text$x:00006700
.text$x:00006700 ; Segment type: Pure code
.text$x:00006700 ; Segment permissions: Read/Execute
.text$x:00006700 _text$x         segment para public 'CODE' use32
.text$x:00006700                 assume cs:_text$x
.text$x:00006700                 ;org 6700h
.text$x:00006700 ; COMDAT (pick associative to section at 66B4)
.text$x:00006700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006700
.text$x:00006700 ; =============== S U B R O U T I N E =======================================
.text$x:00006700
.text$x:00006700
.text$x:00006700 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006700                                         ; DATA XREF: .xdata$x:0000A914o
.text$x:00006700                 mov     ecx, [ebp-10h]
.text$x:00006703                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00006703 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006703
.text$x:00006708
.text$x:00006708 ; =============== S U B R O U T I N E =======================================
.text$x:00006708
.text$x:00006708
.text$x:00006708 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006708                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)+5o
.text$x:00006708
.text$x:00006708 arg_4           = dword ptr  8
.text$x:00006708
.text$x:00006708                 mov     edx, [esp+arg_4]
.text$x:0000670C                 lea     eax, [edx+0Ch]
.text$x:0000670F                 mov     ecx, [edx-8]
.text$x:00006712                 xor     ecx, eax
.text$x:00006714                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006719                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.text$x:0000671E                 jmp     ___CxxFrameHandler3
.text$x:0000671E __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000671E
.text$x:0000671E ; ---------------------------------------------------------------------------
.text$x:00006723                 align 4
.text$x:00006723 _text$x         ends
.text$x:00006723
.text$mn:00006724 ; ===========================================================================
.text$mn:00006724
.text$mn:00006724 ; Segment type: Pure code
.text$mn:00006724 ; Segment permissions: Read/Execute
.text$mn:00006724 _text$mn        segment para public 'CODE' use32
.text$mn:00006724                 assume cs:_text$mn
.text$mn:00006724                 ;org 6724h
.text$mn:00006724 ; COMDAT (pick any)
.text$mn:00006724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006724
.text$mn:00006724 ; =============== S U B R O U T I N E =======================================
.text$mn:00006724
.text$mn:00006724 ; Attributes: bp-based frame
.text$mn:00006724
.text$mn:00006724 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<int>>::~_Vector_val<struct std::_Simple_types<int>>(void)
.text$mn:00006724                 public ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:00006724 ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$mn:00006724                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0+3j
.text$mn:00006724                                         ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+3Fp ...
.text$mn:00006724
.text$mn:00006724 var_10          = dword ptr -10h
.text$mn:00006724 var_C           = dword ptr -0Ch
.text$mn:00006724 var_4           = dword ptr -4
.text$mn:00006724
.text$mn:00006724                 push    ebp
.text$mn:00006725                 mov     ebp, esp
.text$mn:00006727                 push    0FFFFFFFFh
.text$mn:00006729                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$mn:0000672E                 mov     eax, large fs:0
.text$mn:00006734                 push    eax
.text$mn:00006735                 push    ecx
.text$mn:00006736                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000673B                 xor     eax, ebp
.text$mn:0000673D                 push    eax
.text$mn:0000673E                 lea     eax, [ebp+var_C]
.text$mn:00006741                 mov     large fs:0, eax
.text$mn:00006747                 mov     [ebp+var_10], ecx
.text$mn:0000674A                 mov     [ebp+var_4], 0
.text$mn:00006751                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006758                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000675B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006760                 mov     ecx, [ebp+var_C]
.text$mn:00006763                 mov     large fs:0, ecx
.text$mn:0000676A                 pop     ecx
.text$mn:0000676B                 mov     esp, ebp
.text$mn:0000676D                 pop     ebp
.text$mn:0000676E                 retn
.text$mn:0000676E ??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$mn:0000676E
.text$mn:0000676E ; ---------------------------------------------------------------------------
.text$mn:0000676F                 align 10h
.text$mn:0000676F _text$mn        ends
.text$mn:0000676F
.text$x:00006770 ; ===========================================================================
.text$x:00006770
.text$x:00006770 ; Segment type: Pure code
.text$x:00006770 ; Segment permissions: Read/Execute
.text$x:00006770 _text$x         segment para public 'CODE' use32
.text$x:00006770                 assume cs:_text$x
.text$x:00006770                 ;org 6770h
.text$x:00006770 ; COMDAT (pick associative to section at 6724)
.text$x:00006770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006770
.text$x:00006770 ; =============== S U B R O U T I N E =======================================
.text$x:00006770
.text$x:00006770
.text$x:00006770 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 proc near
.text$x:00006770                                         ; DATA XREF: .xdata$x:0000A53Co
.text$x:00006770                 mov     ecx, [ebp-10h]  ; this
.text$x:00006773                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006773 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0 endp
.text$x:00006773
.text$x:00006778
.text$x:00006778 ; =============== S U B R O U T I N E =======================================
.text$x:00006778
.text$x:00006778
.text$x:00006778 __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ proc near
.text$x:00006778                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<int>>::~_Vector_val<std::_Simple_types<int>>(void)+5o
.text$x:00006778
.text$x:00006778 arg_4           = dword ptr  8
.text$x:00006778
.text$x:00006778                 mov     edx, [esp+arg_4]
.text$x:0000677C                 lea     eax, [edx+0Ch]
.text$x:0000677F                 mov     ecx, [edx-8]
.text$x:00006782                 xor     ecx, eax
.text$x:00006784                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006789                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.text$x:0000678E                 jmp     ___CxxFrameHandler3
.text$x:0000678E __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ endp
.text$x:0000678E
.text$x:0000678E ; ---------------------------------------------------------------------------
.text$x:00006793                 align 4
.text$x:00006793 _text$x         ends
.text$x:00006793
.text$mn:00006794 ; ===========================================================================
.text$mn:00006794
.text$mn:00006794 ; Segment type: Pure code
.text$mn:00006794 ; Segment permissions: Read/Execute
.text$mn:00006794 _text$mn        segment para public 'CODE' use32
.text$mn:00006794                 assume cs:_text$mn
.text$mn:00006794                 ;org 6794h
.text$mn:00006794 ; COMDAT (pick any)
.text$mn:00006794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006794
.text$mn:00006794 ; =============== S U B R O U T I N E =======================================
.text$mn:00006794
.text$mn:00006794 ; Attributes: bp-based frame
.text$mn:00006794
.text$mn:00006794 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>::~_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>(void)
.text$mn:00006794                 public ??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ
.text$mn:00006794 ??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:00006794                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>(void)+3Fp
.text$mn:00006794                                         ; __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00006794
.text$mn:00006794 var_10          = dword ptr -10h
.text$mn:00006794 var_C           = dword ptr -0Ch
.text$mn:00006794 var_4           = dword ptr -4
.text$mn:00006794
.text$mn:00006794                 push    ebp
.text$mn:00006795                 mov     ebp, esp
.text$mn:00006797                 push    0FFFFFFFFh
.text$mn:00006799                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ
.text$mn:0000679E                 mov     eax, large fs:0
.text$mn:000067A4                 push    eax
.text$mn:000067A5                 push    ecx
.text$mn:000067A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000067AB                 xor     eax, ebp
.text$mn:000067AD                 push    eax
.text$mn:000067AE                 lea     eax, [ebp+var_C]
.text$mn:000067B1                 mov     large fs:0, eax
.text$mn:000067B7                 mov     [ebp+var_10], ecx
.text$mn:000067BA                 mov     [ebp+var_4], 0
.text$mn:000067C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000067C8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000067CB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000067D0                 mov     ecx, [ebp+var_C]
.text$mn:000067D3                 mov     large fs:0, ecx
.text$mn:000067DA                 pop     ecx
.text$mn:000067DB                 mov     esp, ebp
.text$mn:000067DD                 pop     ebp
.text$mn:000067DE                 retn
.text$mn:000067DE ??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ endp
.text$mn:000067DE
.text$mn:000067DE ; ---------------------------------------------------------------------------
.text$mn:000067DF                 align 10h
.text$mn:000067DF _text$mn        ends
.text$mn:000067DF
.text$x:000067E0 ; ===========================================================================
.text$x:000067E0
.text$x:000067E0 ; Segment type: Pure code
.text$x:000067E0 ; Segment permissions: Read/Execute
.text$x:000067E0 _text$x         segment para public 'CODE' use32
.text$x:000067E0                 assume cs:_text$x
.text$x:000067E0                 ;org 67E0h
.text$x:000067E0 ; COMDAT (pick associative to section at 6794)
.text$x:000067E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000067E0
.text$x:000067E0 ; =============== S U B R O U T I N E =======================================
.text$x:000067E0
.text$x:000067E0
.text$x:000067E0 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000067E0                                         ; DATA XREF: .xdata$x:0000A704o
.text$x:000067E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000067E3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000067E3 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:000067E3
.text$x:000067E8
.text$x:000067E8 ; =============== S U B R O U T I N E =======================================
.text$x:000067E8
.text$x:000067E8
.text$x:000067E8 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ proc near
.text$x:000067E8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<ColumnModeInfo>>::~_Vector_val<std::_Simple_types<ColumnModeInfo>>(void)+5o
.text$x:000067E8
.text$x:000067E8 arg_4           = dword ptr  8
.text$x:000067E8
.text$x:000067E8                 mov     edx, [esp+arg_4]
.text$x:000067EC                 lea     eax, [edx+0Ch]
.text$x:000067EF                 mov     ecx, [edx-8]
.text$x:000067F2                 xor     ecx, eax
.text$x:000067F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067F9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ
.text$x:000067FE                 jmp     ___CxxFrameHandler3
.text$x:000067FE __ehhandler$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ endp
.text$x:000067FE
.text$x:000067FE ; ---------------------------------------------------------------------------
.text$x:00006803                 align 4
.text$x:00006803 _text$x         ends
.text$x:00006803
.text$mn:00006804 ; ===========================================================================
.text$mn:00006804
.text$mn:00006804 ; Segment type: Pure code
.text$mn:00006804 ; Segment permissions: Read/Execute
.text$mn:00006804 _text$mn        segment para public 'CODE' use32
.text$mn:00006804                 assume cs:_text$mn
.text$mn:00006804                 ;org 6804h
.text$mn:00006804 ; COMDAT (pick any)
.text$mn:00006804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006804
.text$mn:00006804 ; =============== S U B R O U T I N E =======================================
.text$mn:00006804
.text$mn:00006804 ; Attributes: bp-based frame
.text$mn:00006804
.text$mn:00006804 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00006804                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00006804 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00006804                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00006804                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00006804
.text$mn:00006804 var_10          = dword ptr -10h
.text$mn:00006804 var_C           = dword ptr -0Ch
.text$mn:00006804 var_4           = dword ptr -4
.text$mn:00006804
.text$mn:00006804                 push    ebp
.text$mn:00006805                 mov     ebp, esp
.text$mn:00006807                 push    0FFFFFFFFh
.text$mn:00006809                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000680E                 mov     eax, large fs:0
.text$mn:00006814                 push    eax
.text$mn:00006815                 push    ecx
.text$mn:00006816                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000681B                 xor     eax, ebp
.text$mn:0000681D                 push    eax
.text$mn:0000681E                 lea     eax, [ebp+var_C]
.text$mn:00006821                 mov     large fs:0, eax
.text$mn:00006827                 mov     [ebp+var_10], ecx
.text$mn:0000682A                 mov     [ebp+var_4], 0
.text$mn:00006831                 push    0               ; Size
.text$mn:00006833                 push    1               ; char
.text$mn:00006835                 mov     ecx, [ebp+var_10]
.text$mn:00006838                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000683D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006844                 mov     ecx, [ebp+var_10]
.text$mn:00006847                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:0000684C                 mov     ecx, [ebp+var_C]
.text$mn:0000684F                 mov     large fs:0, ecx
.text$mn:00006856                 pop     ecx
.text$mn:00006857                 mov     esp, ebp
.text$mn:00006859                 pop     ebp
.text$mn:0000685A                 retn
.text$mn:0000685A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000685A
.text$mn:0000685A ; ---------------------------------------------------------------------------
.text$mn:0000685B                 align 4
.text$mn:0000685B _text$mn        ends
.text$mn:0000685B
.text$x:0000685C ; ===========================================================================
.text$x:0000685C
.text$x:0000685C ; Segment type: Pure code
.text$x:0000685C ; Segment permissions: Read/Execute
.text$x:0000685C _text$x         segment para public 'CODE' use32
.text$x:0000685C                 assume cs:_text$x
.text$x:0000685C                 ;org 685Ch
.text$x:0000685C ; COMDAT (pick associative to section at 6804)
.text$x:0000685C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000685C
.text$x:0000685C ; =============== S U B R O U T I N E =======================================
.text$x:0000685C
.text$x:0000685C
.text$x:0000685C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:0000685C                                         ; DATA XREF: .xdata$x:00009FE4o
.text$x:0000685C                 mov     ecx, [ebp-10h]
.text$x:0000685F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000685F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000685F
.text$x:00006864
.text$x:00006864 ; =============== S U B R O U T I N E =======================================
.text$x:00006864
.text$x:00006864
.text$x:00006864 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00006864                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00006864
.text$x:00006864 arg_4           = dword ptr  8
.text$x:00006864
.text$x:00006864                 mov     edx, [esp+arg_4]
.text$x:00006868                 lea     eax, [edx+0Ch]
.text$x:0000686B                 mov     ecx, [edx-8]
.text$x:0000686E                 xor     ecx, eax
.text$x:00006870                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006875                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000687A                 jmp     ___CxxFrameHandler3
.text$x:0000687A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000687A
.text$x:0000687A ; ---------------------------------------------------------------------------
.text$x:0000687F                 align 10h
.text$x:0000687F _text$x         ends
.text$x:0000687F
.text$mn:00006880 ; ===========================================================================
.text$mn:00006880
.text$mn:00006880 ; Segment type: Pure code
.text$mn:00006880 ; Segment permissions: Read/Execute
.text$mn:00006880 _text$mn        segment para public 'CODE' use32
.text$mn:00006880                 assume cs:_text$mn
.text$mn:00006880                 ;org 6880h
.text$mn:00006880 ; COMDAT (pick any)
.text$mn:00006880                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006880
.text$mn:00006880 ; =============== S U B R O U T I N E =======================================
.text$mn:00006880
.text$mn:00006880 ; Attributes: bp-based frame
.text$mn:00006880
.text$mn:00006880 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00006880                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00006880 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00006880                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+5CBp
.text$mn:00006880                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+657p ...
.text$mn:00006880
.text$mn:00006880 var_10          = dword ptr -10h
.text$mn:00006880 var_C           = dword ptr -0Ch
.text$mn:00006880 var_4           = dword ptr -4
.text$mn:00006880
.text$mn:00006880                 push    ebp
.text$mn:00006881                 mov     ebp, esp
.text$mn:00006883                 push    0FFFFFFFFh
.text$mn:00006885                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000688A                 mov     eax, large fs:0
.text$mn:00006890                 push    eax
.text$mn:00006891                 push    ecx
.text$mn:00006892                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006897                 xor     eax, ebp
.text$mn:00006899                 push    eax
.text$mn:0000689A                 lea     eax, [ebp+var_C]
.text$mn:0000689D                 mov     large fs:0, eax
.text$mn:000068A3                 mov     [ebp+var_10], ecx
.text$mn:000068A6                 mov     [ebp+var_4], 0
.text$mn:000068AD                 push    0
.text$mn:000068AF                 push    1
.text$mn:000068B1                 mov     ecx, [ebp+var_10]
.text$mn:000068B4                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000068B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000068C0                 mov     ecx, [ebp+var_10]
.text$mn:000068C3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:000068C8                 mov     ecx, [ebp+var_C]
.text$mn:000068CB                 mov     large fs:0, ecx
.text$mn:000068D2                 pop     ecx
.text$mn:000068D3                 mov     esp, ebp
.text$mn:000068D5                 pop     ebp
.text$mn:000068D6                 retn
.text$mn:000068D6 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000068D6
.text$mn:000068D6 ; ---------------------------------------------------------------------------
.text$mn:000068D7                 align 4
.text$mn:000068D7 _text$mn        ends
.text$mn:000068D7
.text$x:000068D8 ; ===========================================================================
.text$x:000068D8
.text$x:000068D8 ; Segment type: Pure code
.text$x:000068D8 ; Segment permissions: Read/Execute
.text$x:000068D8 _text$x         segment para public 'CODE' use32
.text$x:000068D8                 assume cs:_text$x
.text$x:000068D8                 ;org 68D8h
.text$x:000068D8 ; COMDAT (pick associative to section at 6880)
.text$x:000068D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000068D8
.text$x:000068D8 ; =============== S U B R O U T I N E =======================================
.text$x:000068D8
.text$x:000068D8
.text$x:000068D8 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000068D8                                         ; DATA XREF: .xdata$x:0000A458o
.text$x:000068D8                 mov     ecx, [ebp-10h]
.text$x:000068DB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000068DB __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000068DB
.text$x:000068E0
.text$x:000068E0 ; =============== S U B R O U T I N E =======================================
.text$x:000068E0
.text$x:000068E0
.text$x:000068E0 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000068E0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000068E0
.text$x:000068E0 arg_4           = dword ptr  8
.text$x:000068E0
.text$x:000068E0                 mov     edx, [esp+arg_4]
.text$x:000068E4                 lea     eax, [edx+0Ch]
.text$x:000068E7                 mov     ecx, [edx-8]
.text$x:000068EA                 xor     ecx, eax
.text$x:000068EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000068F1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:000068F6                 jmp     ___CxxFrameHandler3
.text$x:000068F6 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:000068F6
.text$x:000068F6 ; ---------------------------------------------------------------------------
.text$x:000068FB                 align 4
.text$x:000068FB _text$x         ends
.text$x:000068FB
.text$mn:000068FC ; ===========================================================================
.text$mn:000068FC
.text$mn:000068FC ; Segment type: Pure code
.text$mn:000068FC ; Segment permissions: Read/Execute
.text$mn:000068FC _text$mn        segment para public 'CODE' use32
.text$mn:000068FC                 assume cs:_text$mn
.text$mn:000068FC                 ;org 68FCh
.text$mn:000068FC ; COMDAT (pick any)
.text$mn:000068FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068FC
.text$mn:000068FC ; =============== S U B R O U T I N E =======================================
.text$mn:000068FC
.text$mn:000068FC ; Attributes: bp-based frame
.text$mn:000068FC
.text$mn:000068FC ; public: __thiscall std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>::~reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>>(void)
.text$mn:000068FC                 public ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000068FC ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000068FC                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+B1Cp
.text$mn:000068FC                                         ; __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$13+6j ...
.text$mn:000068FC
.text$mn:000068FC var_10          = dword ptr -10h
.text$mn:000068FC var_C           = dword ptr -0Ch
.text$mn:000068FC var_4           = dword ptr -4
.text$mn:000068FC
.text$mn:000068FC                 push    ebp
.text$mn:000068FD                 mov     ebp, esp
.text$mn:000068FF                 push    0FFFFFFFFh
.text$mn:00006901                 push    offset __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006906                 mov     eax, large fs:0
.text$mn:0000690C                 push    eax
.text$mn:0000690D                 push    ecx
.text$mn:0000690E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006913                 xor     eax, ebp
.text$mn:00006915                 push    eax
.text$mn:00006916                 lea     eax, [ebp+var_C]
.text$mn:00006919                 mov     large fs:0, eax
.text$mn:0000691F                 mov     [ebp+var_10], ecx
.text$mn:00006922                 mov     [ebp+var_4], 0
.text$mn:00006929                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006930                 mov     ecx, [ebp+var_10]
.text$mn:00006933                 call    ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(void)
.text$mn:00006938                 mov     ecx, [ebp+var_C]
.text$mn:0000693B                 mov     large fs:0, ecx
.text$mn:00006942                 pop     ecx
.text$mn:00006943                 mov     esp, ebp
.text$mn:00006945                 pop     ebp
.text$mn:00006946                 retn
.text$mn:00006946 ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006946
.text$mn:00006946 ; ---------------------------------------------------------------------------
.text$mn:00006947                 align 4
.text$mn:00006947 _text$mn        ends
.text$mn:00006947
.text$x:00006948 ; ===========================================================================
.text$x:00006948
.text$x:00006948 ; Segment type: Pure code
.text$x:00006948 ; Segment permissions: Read/Execute
.text$x:00006948 _text$x         segment para public 'CODE' use32
.text$x:00006948                 assume cs:_text$x
.text$x:00006948                 ;org 6948h
.text$x:00006948 ; COMDAT (pick associative to section at 68FC)
.text$x:00006948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006948
.text$x:00006948 ; =============== S U B R O U T I N E =======================================
.text$x:00006948
.text$x:00006948
.text$x:00006948 __unwindfunclet$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006948                                         ; DATA XREF: .xdata$x:0000AC94o
.text$x:00006948                 mov     ecx, [ebp-10h]
.text$x:0000694B                 jmp     ??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ ; std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::~_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>(void)
.text$x:0000694B __unwindfunclet$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000694B
.text$x:00006950
.text$x:00006950 ; =============== S U B R O U T I N E =======================================
.text$x:00006950
.text$x:00006950
.text$x:00006950 __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006950                                         ; DATA XREF: std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(void)+5o
.text$x:00006950
.text$x:00006950 arg_4           = dword ptr  8
.text$x:00006950
.text$x:00006950                 mov     edx, [esp+arg_4]
.text$x:00006954                 lea     eax, [edx+0Ch]
.text$x:00006957                 mov     ecx, [edx-8]
.text$x:0000695A                 xor     ecx, eax
.text$x:0000695C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006961                 mov     eax, offset __ehfuncinfo$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00006966                 jmp     ___CxxFrameHandler3
.text$x:00006966 __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00006966
.text$x:00006966 ; ---------------------------------------------------------------------------
.text$x:0000696B                 align 4
.text$x:0000696B _text$x         ends
.text$x:0000696B
.text$mn:0000696C ; ===========================================================================
.text$mn:0000696C
.text$mn:0000696C ; Segment type: Pure code
.text$mn:0000696C ; Segment permissions: Read/Execute
.text$mn:0000696C _text$mn        segment para public 'CODE' use32
.text$mn:0000696C                 assume cs:_text$mn
.text$mn:0000696C                 ;org 696Ch
.text$mn:0000696C ; COMDAT (pick any)
.text$mn:0000696C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000696C
.text$mn:0000696C ; =============== S U B R O U T I N E =======================================
.text$mn:0000696C
.text$mn:0000696C ; Attributes: bp-based frame
.text$mn:0000696C
.text$mn:0000696C ; public: __thiscall std::vector<int, class std::allocator<int>>::~vector<int, class std::allocator<int>>(void)
.text$mn:0000696C                 public ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:0000696C ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:0000696C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+E27p
.text$mn:0000696C                                         ; __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$12+6j
.text$mn:0000696C
.text$mn:0000696C var_10          = dword ptr -10h
.text$mn:0000696C var_C           = dword ptr -0Ch
.text$mn:0000696C var_4           = dword ptr -4
.text$mn:0000696C
.text$mn:0000696C                 push    ebp
.text$mn:0000696D                 mov     ebp, esp
.text$mn:0000696F                 push    0FFFFFFFFh
.text$mn:00006971                 push    offset __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00006976                 mov     eax, large fs:0
.text$mn:0000697C                 push    eax
.text$mn:0000697D                 push    ecx
.text$mn:0000697E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006983                 xor     eax, ebp
.text$mn:00006985                 push    eax
.text$mn:00006986                 lea     eax, [ebp+var_C]
.text$mn:00006989                 mov     large fs:0, eax
.text$mn:0000698F                 mov     [ebp+var_10], ecx
.text$mn:00006992                 mov     [ebp+var_4], 0
.text$mn:00006999                 mov     ecx, [ebp+var_10]
.text$mn:0000699C                 call    ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int>>::_Tidy(void)
.text$mn:000069A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000069A8                 mov     ecx, [ebp+var_10]
.text$mn:000069AB                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$mn:000069B0                 mov     ecx, [ebp+var_C]
.text$mn:000069B3                 mov     large fs:0, ecx
.text$mn:000069BA                 pop     ecx
.text$mn:000069BB                 mov     esp, ebp
.text$mn:000069BD                 pop     ebp
.text$mn:000069BE                 retn
.text$mn:000069BE ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:000069BE
.text$mn:000069BE ; ---------------------------------------------------------------------------
.text$mn:000069BF                 align 10h
.text$mn:000069BF _text$mn        ends
.text$mn:000069BF
.text$x:000069C0 ; ===========================================================================
.text$x:000069C0
.text$x:000069C0 ; Segment type: Pure code
.text$x:000069C0 ; Segment permissions: Read/Execute
.text$x:000069C0 _text$x         segment para public 'CODE' use32
.text$x:000069C0                 assume cs:_text$x
.text$x:000069C0                 ;org 69C0h
.text$x:000069C0 ; COMDAT (pick associative to section at 696C)
.text$x:000069C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000069C0
.text$x:000069C0 ; =============== S U B R O U T I N E =======================================
.text$x:000069C0
.text$x:000069C0
.text$x:000069C0 __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 proc near
.text$x:000069C0                                         ; DATA XREF: .xdata$x:0000A5ECo
.text$x:000069C0                 mov     ecx, [ebp-10h]
.text$x:000069C3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)
.text$x:000069C3 __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0 endp
.text$x:000069C3
.text$x:000069C8
.text$x:000069C8 ; =============== S U B R O U T I N E =======================================
.text$x:000069C8
.text$x:000069C8
.text$x:000069C8 __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ proc near
.text$x:000069C8                                         ; DATA XREF: std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+5o
.text$x:000069C8
.text$x:000069C8 arg_4           = dword ptr  8
.text$x:000069C8
.text$x:000069C8                 mov     edx, [esp+arg_4]
.text$x:000069CC                 lea     eax, [edx+0Ch]
.text$x:000069CF                 mov     ecx, [edx-8]
.text$x:000069D2                 xor     ecx, eax
.text$x:000069D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000069D9                 mov     eax, offset __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.text$x:000069DE                 jmp     ___CxxFrameHandler3
.text$x:000069DE __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ endp
.text$x:000069DE
.text$x:000069DE ; ---------------------------------------------------------------------------
.text$x:000069E3                 align 4
.text$x:000069E3 _text$x         ends
.text$x:000069E3
.text$mn:000069E4 ; ===========================================================================
.text$mn:000069E4
.text$mn:000069E4 ; Segment type: Pure code
.text$mn:000069E4 ; Segment permissions: Read/Execute
.text$mn:000069E4 _text$mn        segment para public 'CODE' use32
.text$mn:000069E4                 assume cs:_text$mn
.text$mn:000069E4                 ;org 69E4h
.text$mn:000069E4 ; COMDAT (pick any)
.text$mn:000069E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069E4
.text$mn:000069E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000069E4
.text$mn:000069E4 ; Attributes: bp-based frame
.text$mn:000069E4
.text$mn:000069E4 ; public: __thiscall std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>::~vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>(void)
.text$mn:000069E4                 public ??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ
.text$mn:000069E4 ??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:000069E4                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+34Ep
.text$mn:000069E4                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+897p ...
.text$mn:000069E4
.text$mn:000069E4 var_10          = dword ptr -10h
.text$mn:000069E4 var_C           = dword ptr -0Ch
.text$mn:000069E4 var_4           = dword ptr -4
.text$mn:000069E4
.text$mn:000069E4                 push    ebp
.text$mn:000069E5                 mov     ebp, esp
.text$mn:000069E7                 push    0FFFFFFFFh
.text$mn:000069E9                 push    offset __ehhandler$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ
.text$mn:000069EE                 mov     eax, large fs:0
.text$mn:000069F4                 push    eax
.text$mn:000069F5                 push    ecx
.text$mn:000069F6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069FB                 xor     eax, ebp
.text$mn:000069FD                 push    eax
.text$mn:000069FE                 lea     eax, [ebp+var_C]
.text$mn:00006A01                 mov     large fs:0, eax
.text$mn:00006A07                 mov     [ebp+var_10], ecx
.text$mn:00006A0A                 mov     [ebp+var_4], 0
.text$mn:00006A11                 mov     ecx, [ebp+var_10]
.text$mn:00006A14                 call    ?_Tidy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXXZ ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Tidy(void)
.text$mn:00006A19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A20                 mov     ecx, [ebp+var_10]
.text$mn:00006A23                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>(void)
.text$mn:00006A28                 mov     ecx, [ebp+var_C]
.text$mn:00006A2B                 mov     large fs:0, ecx
.text$mn:00006A32                 pop     ecx
.text$mn:00006A33                 mov     esp, ebp
.text$mn:00006A35                 pop     ebp
.text$mn:00006A36                 retn
.text$mn:00006A36 ??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ endp
.text$mn:00006A36
.text$mn:00006A36 ; ---------------------------------------------------------------------------
.text$mn:00006A37                 align 4
.text$mn:00006A37 _text$mn        ends
.text$mn:00006A37
.text$x:00006A38 ; ===========================================================================
.text$x:00006A38
.text$x:00006A38 ; Segment type: Pure code
.text$x:00006A38 ; Segment permissions: Read/Execute
.text$x:00006A38 _text$x         segment para public 'CODE' use32
.text$x:00006A38                 assume cs:_text$x
.text$x:00006A38                 ;org 6A38h
.text$x:00006A38 ; COMDAT (pick associative to section at 69E4)
.text$x:00006A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006A38
.text$x:00006A38 ; =============== S U B R O U T I N E =======================================
.text$x:00006A38
.text$x:00006A38
.text$x:00006A38 __unwindfunclet$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006A38                                         ; DATA XREF: .xdata$x:0000A75Co
.text$x:00006A38                 mov     ecx, [ebp-10h]
.text$x:00006A3B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>(void)
.text$x:00006A3B __unwindfunclet$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006A3B
.text$x:00006A40
.text$x:00006A40 ; =============== S U B R O U T I N E =======================================
.text$x:00006A40
.text$x:00006A40
.text$x:00006A40 __ehhandler$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ proc near
.text$x:00006A40                                         ; DATA XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::~vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>(void)+5o
.text$x:00006A40
.text$x:00006A40 arg_4           = dword ptr  8
.text$x:00006A40
.text$x:00006A40                 mov     edx, [esp+arg_4]
.text$x:00006A44                 lea     eax, [edx+0Ch]
.text$x:00006A47                 mov     ecx, [edx-8]
.text$x:00006A4A                 xor     ecx, eax
.text$x:00006A4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A51                 mov     eax, offset __ehfuncinfo$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ
.text$x:00006A56                 jmp     ___CxxFrameHandler3
.text$x:00006A56 __ehhandler$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ endp
.text$x:00006A56
.text$x:00006A56 ; ---------------------------------------------------------------------------
.text$x:00006A5B                 align 4
.text$x:00006A5B _text$x         ends
.text$x:00006A5B
.text$mn:00006A5C ; ===========================================================================
.text$mn:00006A5C
.text$mn:00006A5C ; Segment type: Pure code
.text$mn:00006A5C ; Segment permissions: Read/Execute
.text$mn:00006A5C _text$mn        segment para public 'CODE' use32
.text$mn:00006A5C                 assume cs:_text$mn
.text$mn:00006A5C                 ;org 6A5Ch
.text$mn:00006A5C ; COMDAT (pick any)
.text$mn:00006A5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A5C
.text$mn:00006A5C ; =============== S U B R O U T I N E =======================================
.text$mn:00006A5C
.text$mn:00006A5C ; Attributes: bp-based frame
.text$mn:00006A5C
.text$mn:00006A5C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00006A5C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00006A5C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00006A5C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00006A5C                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00006A5C
.text$mn:00006A5C var_4           = dword ptr -4
.text$mn:00006A5C
.text$mn:00006A5C                 push    ebp
.text$mn:00006A5D                 mov     ebp, esp
.text$mn:00006A5F                 push    ecx
.text$mn:00006A60                 mov     [ebp+var_4], ecx
.text$mn:00006A63                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006A66                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006A6B                 mov     esp, ebp
.text$mn:00006A6D                 pop     ebp
.text$mn:00006A6E                 retn
.text$mn:00006A6E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00006A6E
.text$mn:00006A6E ; ---------------------------------------------------------------------------
.text$mn:00006A6F                 align 10h
.text$mn:00006A6F _text$mn        ends
.text$mn:00006A6F
.text$mn:00006A70 ; ===========================================================================
.text$mn:00006A70
.text$mn:00006A70 ; Segment type: Pure code
.text$mn:00006A70 ; Segment permissions: Read/Execute
.text$mn:00006A70 _text$mn        segment para public 'CODE' use32
.text$mn:00006A70                 assume cs:_text$mn
.text$mn:00006A70                 ;org 6A70h
.text$mn:00006A70 ; COMDAT (pick any)
.text$mn:00006A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A70
.text$mn:00006A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A70
.text$mn:00006A70 ; Attributes: bp-based frame
.text$mn:00006A70
.text$mn:00006A70 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00006A70                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00006A70 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00006A70                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00006A70                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00006A70
.text$mn:00006A70 var_10          = dword ptr -10h
.text$mn:00006A70 var_C           = dword ptr -0Ch
.text$mn:00006A70 var_4           = dword ptr -4
.text$mn:00006A70
.text$mn:00006A70                 push    ebp
.text$mn:00006A71                 mov     ebp, esp
.text$mn:00006A73                 push    0FFFFFFFFh
.text$mn:00006A75                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00006A7A                 mov     eax, large fs:0
.text$mn:00006A80                 push    eax
.text$mn:00006A81                 push    ecx
.text$mn:00006A82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006A87                 xor     eax, ebp
.text$mn:00006A89                 push    eax
.text$mn:00006A8A                 lea     eax, [ebp+var_C]
.text$mn:00006A8D                 mov     large fs:0, eax
.text$mn:00006A93                 mov     [ebp+var_10], ecx
.text$mn:00006A96                 mov     [ebp+var_4], 0
.text$mn:00006A9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006AA4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006AA7                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00006AAC                 mov     ecx, [ebp+var_C]
.text$mn:00006AAF                 mov     large fs:0, ecx
.text$mn:00006AB6                 pop     ecx
.text$mn:00006AB7                 mov     esp, ebp
.text$mn:00006AB9                 pop     ebp
.text$mn:00006ABA                 retn
.text$mn:00006ABA ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00006ABA
.text$mn:00006ABA ; ---------------------------------------------------------------------------
.text$mn:00006ABB                 align 4
.text$mn:00006ABB _text$mn        ends
.text$mn:00006ABB
.text$x:00006ABC ; ===========================================================================
.text$x:00006ABC
.text$x:00006ABC ; Segment type: Pure code
.text$x:00006ABC ; Segment permissions: Read/Execute
.text$x:00006ABC _text$x         segment para public 'CODE' use32
.text$x:00006ABC                 assume cs:_text$x
.text$x:00006ABC                 ;org 6ABCh
.text$x:00006ABC ; COMDAT (pick associative to section at 6A70)
.text$x:00006ABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006ABC
.text$x:00006ABC ; =============== S U B R O U T I N E =======================================
.text$x:00006ABC
.text$x:00006ABC
.text$x:00006ABC __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00006ABC                                         ; DATA XREF: .xdata$x:0000A21Co
.text$x:00006ABC                 mov     ecx, [ebp-10h]  ; this
.text$x:00006ABF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00006ABF __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00006ABF
.text$x:00006AC4
.text$x:00006AC4 ; =============== S U B R O U T I N E =======================================
.text$x:00006AC4
.text$x:00006AC4
.text$x:00006AC4 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00006AC4                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00006AC4
.text$x:00006AC4 arg_4           = dword ptr  8
.text$x:00006AC4
.text$x:00006AC4                 mov     edx, [esp+arg_4]
.text$x:00006AC8                 lea     eax, [edx+0Ch]
.text$x:00006ACB                 mov     ecx, [edx-8]
.text$x:00006ACE                 xor     ecx, eax
.text$x:00006AD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AD5                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00006ADA                 jmp     ___CxxFrameHandler3
.text$x:00006ADA __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00006ADA
.text$x:00006ADA ; ---------------------------------------------------------------------------
.text$x:00006ADF                 align 10h
.text$x:00006ADF _text$x         ends
.text$x:00006ADF
.text$mn:00006AE0 ; ===========================================================================
.text$mn:00006AE0
.text$mn:00006AE0 ; Segment type: Pure code
.text$mn:00006AE0 ; Segment permissions: Read/Execute
.text$mn:00006AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00006AE0                 assume cs:_text$mn
.text$mn:00006AE0                 ;org 6AE0h
.text$mn:00006AE0 ; COMDAT (pick any)
.text$mn:00006AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AE0
.text$mn:00006AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AE0
.text$mn:00006AE0 ; Attributes: bp-based frame
.text$mn:00006AE0
.text$mn:00006AE0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00006AE0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00006AE0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00006AE0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00006AE0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00006AE0
.text$mn:00006AE0 var_10          = dword ptr -10h
.text$mn:00006AE0 var_C           = dword ptr -0Ch
.text$mn:00006AE0 var_4           = dword ptr -4
.text$mn:00006AE0
.text$mn:00006AE0                 push    ebp
.text$mn:00006AE1                 mov     ebp, esp
.text$mn:00006AE3                 push    0FFFFFFFFh
.text$mn:00006AE5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00006AEA                 mov     eax, large fs:0
.text$mn:00006AF0                 push    eax
.text$mn:00006AF1                 push    ecx
.text$mn:00006AF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006AF7                 xor     eax, ebp
.text$mn:00006AF9                 push    eax
.text$mn:00006AFA                 lea     eax, [ebp+var_C]
.text$mn:00006AFD                 mov     large fs:0, eax
.text$mn:00006B03                 mov     [ebp+var_10], ecx
.text$mn:00006B06                 mov     [ebp+var_4], 0
.text$mn:00006B0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B14                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006B17                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00006B1C                 mov     ecx, [ebp+var_C]
.text$mn:00006B1F                 mov     large fs:0, ecx
.text$mn:00006B26                 pop     ecx
.text$mn:00006B27                 mov     esp, ebp
.text$mn:00006B29                 pop     ebp
.text$mn:00006B2A                 retn
.text$mn:00006B2A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00006B2A
.text$mn:00006B2A ; ---------------------------------------------------------------------------
.text$mn:00006B2B                 align 4
.text$mn:00006B2B _text$mn        ends
.text$mn:00006B2B
.text$x:00006B2C ; ===========================================================================
.text$x:00006B2C
.text$x:00006B2C ; Segment type: Pure code
.text$x:00006B2C ; Segment permissions: Read/Execute
.text$x:00006B2C _text$x         segment para public 'CODE' use32
.text$x:00006B2C                 assume cs:_text$x
.text$x:00006B2C                 ;org 6B2Ch
.text$x:00006B2C ; COMDAT (pick associative to section at 6AE0)
.text$x:00006B2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006B2C
.text$x:00006B2C ; =============== S U B R O U T I N E =======================================
.text$x:00006B2C
.text$x:00006B2C
.text$x:00006B2C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00006B2C                                         ; DATA XREF: .xdata$x:0000A2A0o
.text$x:00006B2C                 mov     ecx, [ebp-10h]  ; this
.text$x:00006B2F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006B2F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00006B2F
.text$x:00006B34
.text$x:00006B34 ; =============== S U B R O U T I N E =======================================
.text$x:00006B34
.text$x:00006B34
.text$x:00006B34 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00006B34                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00006B34
.text$x:00006B34 arg_4           = dword ptr  8
.text$x:00006B34
.text$x:00006B34                 mov     edx, [esp+arg_4]
.text$x:00006B38                 lea     eax, [edx+0Ch]
.text$x:00006B3B                 mov     ecx, [edx-8]
.text$x:00006B3E                 xor     ecx, eax
.text$x:00006B40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B45                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00006B4A                 jmp     ___CxxFrameHandler3
.text$x:00006B4A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00006B4A
.text$x:00006B4A ; ---------------------------------------------------------------------------
.text$x:00006B4F                 align 10h
.text$x:00006B4F _text$x         ends
.text$x:00006B4F
.text$mn:00006B50 ; ===========================================================================
.text$mn:00006B50
.text$mn:00006B50 ; Segment type: Pure code
.text$mn:00006B50 ; Segment permissions: Read/Execute
.text$mn:00006B50 _text$mn        segment para public 'CODE' use32
.text$mn:00006B50                 assume cs:_text$mn
.text$mn:00006B50                 ;org 6B50h
.text$mn:00006B50 ; COMDAT (pick any)
.text$mn:00006B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B50
.text$mn:00006B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B50
.text$mn:00006B50 ; Attributes: bp-based frame
.text$mn:00006B50
.text$mn:00006B50 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00006B50                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00006B50 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00006B50                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00006B50                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00006B50
.text$mn:00006B50 var_14          = byte ptr -14h
.text$mn:00006B50 var_10          = dword ptr -10h
.text$mn:00006B50 var_C           = dword ptr -0Ch
.text$mn:00006B50 var_4           = dword ptr -4
.text$mn:00006B50
.text$mn:00006B50                 push    ebp
.text$mn:00006B51                 mov     ebp, esp
.text$mn:00006B53                 push    0FFFFFFFFh
.text$mn:00006B55                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00006B5A                 mov     eax, large fs:0
.text$mn:00006B60                 push    eax
.text$mn:00006B61                 sub     esp, 8
.text$mn:00006B64                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B69                 xor     eax, ebp
.text$mn:00006B6B                 push    eax
.text$mn:00006B6C                 lea     eax, [ebp+var_C]
.text$mn:00006B6F                 mov     large fs:0, eax
.text$mn:00006B75                 mov     [ebp+var_10], ecx
.text$mn:00006B78                 push    3               ; int
.text$mn:00006B7A                 lea     ecx, [ebp+var_14] ; this
.text$mn:00006B7D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006B82                 mov     [ebp+var_4], 0
.text$mn:00006B89                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006B8C                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00006B91                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B98                 lea     ecx, [ebp+var_14] ; this
.text$mn:00006B9B                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006BA0                 mov     ecx, [ebp+var_C]
.text$mn:00006BA3                 mov     large fs:0, ecx
.text$mn:00006BAA                 pop     ecx
.text$mn:00006BAB                 mov     esp, ebp
.text$mn:00006BAD                 pop     ebp
.text$mn:00006BAE                 retn
.text$mn:00006BAE ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00006BAE
.text$mn:00006BAE ; ---------------------------------------------------------------------------
.text$mn:00006BAF                 align 10h
.text$mn:00006BAF _text$mn        ends
.text$mn:00006BAF
.text$x:00006BB0 ; ===========================================================================
.text$x:00006BB0
.text$x:00006BB0 ; Segment type: Pure code
.text$x:00006BB0 ; Segment permissions: Read/Execute
.text$x:00006BB0 _text$x         segment para public 'CODE' use32
.text$x:00006BB0                 assume cs:_text$x
.text$x:00006BB0                 ;org 6BB0h
.text$x:00006BB0 ; COMDAT (pick associative to section at 6B50)
.text$x:00006BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006BB0
.text$x:00006BB0 ; =============== S U B R O U T I N E =======================================
.text$x:00006BB0
.text$x:00006BB0
.text$x:00006BB0 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00006BB0                                         ; DATA XREF: .xdata$x:00009EA8o
.text$x:00006BB0                 lea     ecx, [ebp-14h]  ; this
.text$x:00006BB3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006BB3 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00006BB3
.text$x:00006BB8
.text$x:00006BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00006BB8
.text$x:00006BB8
.text$x:00006BB8 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00006BB8                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00006BB8
.text$x:00006BB8 arg_4           = dword ptr  8
.text$x:00006BB8
.text$x:00006BB8                 mov     edx, [esp+arg_4]
.text$x:00006BBC                 lea     eax, [edx+0Ch]
.text$x:00006BBF                 mov     ecx, [edx-0Ch]
.text$x:00006BC2                 xor     ecx, eax
.text$x:00006BC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BC9                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00006BCE                 jmp     ___CxxFrameHandler3
.text$x:00006BCE __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00006BCE
.text$x:00006BCE ; ---------------------------------------------------------------------------
.text$x:00006BD3                 align 4
.text$x:00006BD3 _text$x         ends
.text$x:00006BD3
.text$mn:00006BD4 ; ===========================================================================
.text$mn:00006BD4
.text$mn:00006BD4 ; Segment type: Pure code
.text$mn:00006BD4 ; Segment permissions: Read/Execute
.text$mn:00006BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00006BD4                 assume cs:_text$mn
.text$mn:00006BD4                 ;org 6BD4h
.text$mn:00006BD4 ; COMDAT (pick any)
.text$mn:00006BD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BD4
.text$mn:00006BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BD4
.text$mn:00006BD4 ; Attributes: bp-based frame
.text$mn:00006BD4
.text$mn:00006BD4 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00006BD4                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00006BD4 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00006BD4                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00006BD4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00006BD4
.text$mn:00006BD4 var_10          = dword ptr -10h
.text$mn:00006BD4 var_C           = dword ptr -0Ch
.text$mn:00006BD4 var_4           = dword ptr -4
.text$mn:00006BD4
.text$mn:00006BD4                 push    ebp
.text$mn:00006BD5                 mov     ebp, esp
.text$mn:00006BD7                 push    0FFFFFFFFh
.text$mn:00006BD9                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00006BDE                 mov     eax, large fs:0
.text$mn:00006BE4                 push    eax
.text$mn:00006BE5                 push    ecx
.text$mn:00006BE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006BEB                 xor     eax, ebp
.text$mn:00006BED                 push    eax
.text$mn:00006BEE                 lea     eax, [ebp+var_C]
.text$mn:00006BF1                 mov     large fs:0, eax
.text$mn:00006BF7                 mov     [ebp+var_10], ecx
.text$mn:00006BFA                 mov     [ebp+var_4], 0
.text$mn:00006C01                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C08                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006C0B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00006C10                 mov     ecx, [ebp+var_C]
.text$mn:00006C13                 mov     large fs:0, ecx
.text$mn:00006C1A                 pop     ecx
.text$mn:00006C1B                 mov     esp, ebp
.text$mn:00006C1D                 pop     ebp
.text$mn:00006C1E                 retn
.text$mn:00006C1E ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00006C1E
.text$mn:00006C1E ; ---------------------------------------------------------------------------
.text$mn:00006C1F                 align 10h
.text$mn:00006C1F _text$mn        ends
.text$mn:00006C1F
.text$x:00006C20 ; ===========================================================================
.text$x:00006C20
.text$x:00006C20 ; Segment type: Pure code
.text$x:00006C20 ; Segment permissions: Read/Execute
.text$x:00006C20 _text$x         segment para public 'CODE' use32
.text$x:00006C20                 assume cs:_text$x
.text$x:00006C20                 ;org 6C20h
.text$x:00006C20 ; COMDAT (pick associative to section at 6BD4)
.text$x:00006C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006C20
.text$x:00006C20 ; =============== S U B R O U T I N E =======================================
.text$x:00006C20
.text$x:00006C20
.text$x:00006C20 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00006C20                                         ; DATA XREF: .xdata$x:0000A324o
.text$x:00006C20                 mov     ecx, [ebp-10h]  ; this
.text$x:00006C23                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006C23 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00006C23
.text$x:00006C28
.text$x:00006C28 ; =============== S U B R O U T I N E =======================================
.text$x:00006C28
.text$x:00006C28
.text$x:00006C28 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00006C28                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00006C28
.text$x:00006C28 arg_4           = dword ptr  8
.text$x:00006C28
.text$x:00006C28                 mov     edx, [esp+arg_4]
.text$x:00006C2C                 lea     eax, [edx+0Ch]
.text$x:00006C2F                 mov     ecx, [edx-8]
.text$x:00006C32                 xor     ecx, eax
.text$x:00006C34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C39                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00006C3E                 jmp     ___CxxFrameHandler3
.text$x:00006C3E __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00006C3E
.text$x:00006C3E ; ---------------------------------------------------------------------------
.text$x:00006C43                 align 4
.text$x:00006C43 _text$x         ends
.text$x:00006C43
.text$mn:00006C44 ; ===========================================================================
.text$mn:00006C44
.text$mn:00006C44 ; Segment type: Pure code
.text$mn:00006C44 ; Segment permissions: Read/Execute
.text$mn:00006C44 _text$mn        segment para public 'CODE' use32
.text$mn:00006C44                 assume cs:_text$mn
.text$mn:00006C44                 ;org 6C44h
.text$mn:00006C44 ; COMDAT (pick any)
.text$mn:00006C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C44
.text$mn:00006C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C44
.text$mn:00006C44 ; Attributes: bp-based frame
.text$mn:00006C44
.text$mn:00006C44 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00006C44                 public ??1error_category@std@@UAE@XZ
.text$mn:00006C44 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00006C44                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00006C44
.text$mn:00006C44 var_4           = dword ptr -4
.text$mn:00006C44
.text$mn:00006C44                 push    ebp
.text$mn:00006C45                 mov     ebp, esp
.text$mn:00006C47                 push    ecx
.text$mn:00006C48                 mov     [ebp+var_4], ecx
.text$mn:00006C4B                 mov     eax, [ebp+var_4]
.text$mn:00006C4E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00006C54                 mov     esp, ebp
.text$mn:00006C56                 pop     ebp
.text$mn:00006C57                 retn
.text$mn:00006C57 ??1error_category@std@@UAE@XZ endp
.text$mn:00006C57
.text$mn:00006C57 _text$mn        ends
.text$mn:00006C57
.text$mn:00006C58 ; ===========================================================================
.text$mn:00006C58
.text$mn:00006C58 ; Segment type: Pure code
.text$mn:00006C58 ; Segment permissions: Read/Execute
.text$mn:00006C58 _text$mn        segment para public 'CODE' use32
.text$mn:00006C58                 assume cs:_text$mn
.text$mn:00006C58                 ;org 6C58h
.text$mn:00006C58 ; COMDAT (pick any)
.text$mn:00006C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C58
.text$mn:00006C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C58
.text$mn:00006C58 ; Attributes: bp-based frame
.text$mn:00006C58
.text$mn:00006C58 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00006C58                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00006C58 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00006C58                                         ; DATA XREF: .xdata$x:0000AF14o
.text$mn:00006C58
.text$mn:00006C58 var_10          = dword ptr -10h
.text$mn:00006C58 var_C           = dword ptr -0Ch
.text$mn:00006C58 var_4           = dword ptr -4
.text$mn:00006C58
.text$mn:00006C58                 push    ebp
.text$mn:00006C59                 mov     ebp, esp
.text$mn:00006C5B                 push    0FFFFFFFFh
.text$mn:00006C5D                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:00006C62                 mov     eax, large fs:0
.text$mn:00006C68                 push    eax
.text$mn:00006C69                 push    ecx
.text$mn:00006C6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006C6F                 xor     eax, ebp
.text$mn:00006C71                 push    eax
.text$mn:00006C72                 lea     eax, [ebp+var_C]
.text$mn:00006C75                 mov     large fs:0, eax
.text$mn:00006C7B                 mov     [ebp+var_10], ecx
.text$mn:00006C7E                 mov     [ebp+var_4], 0
.text$mn:00006C85                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C8C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006C8F                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00006C94                 mov     ecx, [ebp+var_C]
.text$mn:00006C97                 mov     large fs:0, ecx
.text$mn:00006C9E                 pop     ecx
.text$mn:00006C9F                 mov     esp, ebp
.text$mn:00006CA1                 pop     ebp
.text$mn:00006CA2                 retn
.text$mn:00006CA2 ??1runtime_error@std@@UAE@XZ endp
.text$mn:00006CA2
.text$mn:00006CA2 ; ---------------------------------------------------------------------------
.text$mn:00006CA3                 align 4
.text$mn:00006CA3 _text$mn        ends
.text$mn:00006CA3
.text$x:00006CA4 ; ===========================================================================
.text$x:00006CA4
.text$x:00006CA4 ; Segment type: Pure code
.text$x:00006CA4 ; Segment permissions: Read/Execute
.text$x:00006CA4 _text$x         segment para public 'CODE' use32
.text$x:00006CA4                 assume cs:_text$x
.text$x:00006CA4                 ;org 6CA4h
.text$x:00006CA4 ; COMDAT (pick associative to section at 6C58)
.text$x:00006CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006CA4
.text$x:00006CA4 ; =============== S U B R O U T I N E =======================================
.text$x:00006CA4
.text$x:00006CA4
.text$x:00006CA4 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00006CA4                                         ; DATA XREF: .xdata$x:0000A0C8o
.text$x:00006CA4                 mov     ecx, [ebp-10h]  ; this
.text$x:00006CA7                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00006CA7 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00006CA7
.text$x:00006CAC
.text$x:00006CAC ; =============== S U B R O U T I N E =======================================
.text$x:00006CAC
.text$x:00006CAC
.text$x:00006CAC __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00006CAC                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00006CAC
.text$x:00006CAC arg_4           = dword ptr  8
.text$x:00006CAC
.text$x:00006CAC                 mov     edx, [esp+arg_4]
.text$x:00006CB0                 lea     eax, [edx+0Ch]
.text$x:00006CB3                 mov     ecx, [edx-8]
.text$x:00006CB6                 xor     ecx, eax
.text$x:00006CB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CBD                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00006CC2                 jmp     ___CxxFrameHandler3
.text$x:00006CC2 __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00006CC2
.text$x:00006CC2 ; ---------------------------------------------------------------------------
.text$x:00006CC7                 align 4
.text$x:00006CC7 _text$x         ends
.text$x:00006CC7
.text$mn:00006CC8 ; ===========================================================================
.text$mn:00006CC8
.text$mn:00006CC8 ; Segment type: Pure code
.text$mn:00006CC8 ; Segment permissions: Read/Execute
.text$mn:00006CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00006CC8                 assume cs:_text$mn
.text$mn:00006CC8                 ;org 6CC8h
.text$mn:00006CC8 ; COMDAT (pick any)
.text$mn:00006CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CC8
.text$mn:00006CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CC8
.text$mn:00006CC8 ; Attributes: bp-based frame
.text$mn:00006CC8
.text$mn:00006CC8 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00006CC8                 public ??2@YAPAXIPAX@Z
.text$mn:00006CC8 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+2Ep
.text$mn:00006CC8                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep ...
.text$mn:00006CC8
.text$mn:00006CC8 arg_4           = dword ptr  0Ch
.text$mn:00006CC8
.text$mn:00006CC8                 push    ebp
.text$mn:00006CC9                 mov     ebp, esp
.text$mn:00006CCB                 mov     eax, [ebp+arg_4]
.text$mn:00006CCE                 pop     ebp
.text$mn:00006CCF                 retn
.text$mn:00006CCF ??2@YAPAXIPAX@Z endp
.text$mn:00006CCF
.text$mn:00006CCF _text$mn        ends
.text$mn:00006CCF
.text$mn:00006CD0 ; ===========================================================================
.text$mn:00006CD0
.text$mn:00006CD0 ; Segment type: Pure code
.text$mn:00006CD0 ; Segment permissions: Read/Execute
.text$mn:00006CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00006CD0                 assume cs:_text$mn
.text$mn:00006CD0                 ;org 6CD0h
.text$mn:00006CD0 ; COMDAT (pick any)
.text$mn:00006CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CD0
.text$mn:00006CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CD0
.text$mn:00006CD0 ; Attributes: bp-based frame
.text$mn:00006CD0
.text$mn:00006CD0 ; void __cdecl operator delete(void *)
.text$mn:00006CD0                 public ??3@YAXPAX0@Z
.text$mn:00006CD0 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0+8p
.text$mn:00006CD0                                         ; __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p ...
.text$mn:00006CD0                 push    ebp
.text$mn:00006CD1                 mov     ebp, esp
.text$mn:00006CD3                 pop     ebp
.text$mn:00006CD4                 retn
.text$mn:00006CD4 ??3@YAXPAX0@Z   endp
.text$mn:00006CD4
.text$mn:00006CD4 ; ---------------------------------------------------------------------------
.text$mn:00006CD5                 align 4
.text$mn:00006CD5 _text$mn        ends
.text$mn:00006CD5
.text$mn:00006CD8 ; ===========================================================================
.text$mn:00006CD8
.text$mn:00006CD8 ; Segment type: Pure code
.text$mn:00006CD8 ; Segment permissions: Read/Execute
.text$mn:00006CD8 _text$mn        segment para public 'CODE' use32
.text$mn:00006CD8                 assume cs:_text$mn
.text$mn:00006CD8                 ;org 6CD8h
.text$mn:00006CD8 ; COMDAT (pick any)
.text$mn:00006CD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CD8
.text$mn:00006CD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CD8
.text$mn:00006CD8 ; Attributes: bp-based frame
.text$mn:00006CD8
.text$mn:00006CD8 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00006CD8                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00006CD8 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00006CD8                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00006CD8
.text$mn:00006CD8 var_14          = byte ptr -14h
.text$mn:00006CD8 var_10          = dword ptr -10h
.text$mn:00006CD8 var_C           = dword ptr -0Ch
.text$mn:00006CD8 var_4           = dword ptr -4
.text$mn:00006CD8 arg_0           = dword ptr  8
.text$mn:00006CD8
.text$mn:00006CD8                 push    ebp
.text$mn:00006CD9                 mov     ebp, esp
.text$mn:00006CDB                 push    0FFFFFFFFh
.text$mn:00006CDD                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00006CE2                 mov     eax, large fs:0
.text$mn:00006CE8                 push    eax
.text$mn:00006CE9                 sub     esp, 8
.text$mn:00006CEC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CF1                 xor     eax, ebp
.text$mn:00006CF3                 push    eax
.text$mn:00006CF4                 lea     eax, [ebp+var_C]
.text$mn:00006CF7                 mov     large fs:0, eax
.text$mn:00006CFD                 mov     [ebp+var_10], ecx
.text$mn:00006D00                 mov     eax, [ebp+var_10]
.text$mn:00006D03                 mov     ecx, [ebp+arg_0]
.text$mn:00006D06                 mov     edx, [eax]
.text$mn:00006D08                 cmp     edx, [ecx]
.text$mn:00006D0A                 jnz     short loc_6D0E
.text$mn:00006D0C                 jmp     short loc_6D50
.text$mn:00006D0E ; ---------------------------------------------------------------------------
.text$mn:00006D0E
.text$mn:00006D0E loc_6D0E:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00006D0E                 mov     eax, [ebp+arg_0]
.text$mn:00006D11                 cmp     dword ptr [eax], 0
.text$mn:00006D14                 jz      short loc_6D28
.text$mn:00006D16                 mov     ecx, [ebp+arg_0]
.text$mn:00006D19                 mov     edx, [ecx]
.text$mn:00006D1B                 mov     eax, [edx]
.text$mn:00006D1D                 push    eax             ; struct std::_Container_base12 *
.text$mn:00006D1E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006D21                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00006D26                 jmp     short loc_6D50
.text$mn:00006D28 ; ---------------------------------------------------------------------------
.text$mn:00006D28
.text$mn:00006D28 loc_6D28:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00006D28                 push    3               ; int
.text$mn:00006D2A                 lea     ecx, [ebp+var_14] ; this
.text$mn:00006D2D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006D32                 mov     [ebp+var_4], 0
.text$mn:00006D39                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006D3C                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00006D41                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006D48                 lea     ecx, [ebp+var_14] ; this
.text$mn:00006D4B                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006D50
.text$mn:00006D50 loc_6D50:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00006D50                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00006D50                 mov     eax, [ebp+var_10]
.text$mn:00006D53                 mov     ecx, [ebp+var_C]
.text$mn:00006D56                 mov     large fs:0, ecx
.text$mn:00006D5D                 pop     ecx
.text$mn:00006D5E                 mov     esp, ebp
.text$mn:00006D60                 pop     ebp
.text$mn:00006D61                 retn    4
.text$mn:00006D61 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00006D61
.text$mn:00006D61 _text$mn        ends
.text$mn:00006D61
.text$x:00006D64 ; ===========================================================================
.text$x:00006D64
.text$x:00006D64 ; Segment type: Pure code
.text$x:00006D64 ; Segment permissions: Read/Execute
.text$x:00006D64 _text$x         segment para public 'CODE' use32
.text$x:00006D64                 assume cs:_text$x
.text$x:00006D64                 ;org 6D64h
.text$x:00006D64 ; COMDAT (pick associative to section at 6CD8)
.text$x:00006D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006D64
.text$x:00006D64 ; =============== S U B R O U T I N E =======================================
.text$x:00006D64
.text$x:00006D64
.text$x:00006D64 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00006D64                                         ; DATA XREF: .xdata$x:00009E7Co
.text$x:00006D64                 lea     ecx, [ebp-14h]  ; this
.text$x:00006D67                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006D67 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00006D67
.text$x:00006D6C
.text$x:00006D6C ; =============== S U B R O U T I N E =======================================
.text$x:00006D6C
.text$x:00006D6C
.text$x:00006D6C __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00006D6C                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00006D6C
.text$x:00006D6C arg_4           = dword ptr  8
.text$x:00006D6C
.text$x:00006D6C                 mov     edx, [esp+arg_4]
.text$x:00006D70                 lea     eax, [edx+0Ch]
.text$x:00006D73                 mov     ecx, [edx-0Ch]
.text$x:00006D76                 xor     ecx, eax
.text$x:00006D78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D7D                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00006D82                 jmp     ___CxxFrameHandler3
.text$x:00006D82 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00006D82
.text$x:00006D82 ; ---------------------------------------------------------------------------
.text$x:00006D87                 align 4
.text$x:00006D87 _text$x         ends
.text$x:00006D87
.text$mn:00006D88 ; ===========================================================================
.text$mn:00006D88
.text$mn:00006D88 ; Segment type: Pure code
.text$mn:00006D88 ; Segment permissions: Read/Execute
.text$mn:00006D88 _text$mn        segment para public 'CODE' use32
.text$mn:00006D88                 assume cs:_text$mn
.text$mn:00006D88                 ;org 6D88h
.text$mn:00006D88 ; COMDAT (pick any)
.text$mn:00006D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D88
.text$mn:00006D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D88
.text$mn:00006D88 ; Attributes: bp-based frame
.text$mn:00006D88
.text$mn:00006D88 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator==(std::_Iterator_base12 *)
.text$mn:00006D88                 public ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00006D88 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00006D88                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+10p
.text$mn:00006D88
.text$mn:00006D88 var_8           = dword ptr -8
.text$mn:00006D88 var_4           = dword ptr -4
.text$mn:00006D88 arg_0           = dword ptr  8
.text$mn:00006D88
.text$mn:00006D88                 push    ebp
.text$mn:00006D89                 mov     ebp, esp
.text$mn:00006D8B                 sub     esp, 8
.text$mn:00006D8E                 mov     [ebp+var_4], ecx
.text$mn:00006D91                 mov     eax, [ebp+arg_0]
.text$mn:00006D94                 push    eax             ; std::_Iterator_base12 *
.text$mn:00006D95                 mov     ecx, [ebp+var_4]
.text$mn:00006D98                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00006D9D                 mov     ecx, [ebp+var_4]
.text$mn:00006DA0                 mov     edx, [ebp+arg_0]
.text$mn:00006DA3                 mov     eax, [ecx+8]
.text$mn:00006DA6                 cmp     eax, [edx+8]
.text$mn:00006DA9                 jnz     short loc_6DB4
.text$mn:00006DAB                 mov     [ebp+var_8], 1
.text$mn:00006DB2                 jmp     short loc_6DBB
.text$mn:00006DB4 ; ---------------------------------------------------------------------------
.text$mn:00006DB4
.text$mn:00006DB4 loc_6DB4:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+21j
.text$mn:00006DB4                 mov     [ebp+var_8], 0
.text$mn:00006DBB
.text$mn:00006DBB loc_6DBB:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+2Aj
.text$mn:00006DBB                 mov     al, byte ptr [ebp+var_8]
.text$mn:00006DBE                 mov     esp, ebp
.text$mn:00006DC0                 pop     ebp
.text$mn:00006DC1                 retn    4
.text$mn:00006DC1 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00006DC1
.text$mn:00006DC1 _text$mn        ends
.text$mn:00006DC1
.text$mn:00006DC4 ; ===========================================================================
.text$mn:00006DC4
.text$mn:00006DC4 ; Segment type: Pure code
.text$mn:00006DC4 ; Segment permissions: Read/Execute
.text$mn:00006DC4 _text$mn        segment para public 'CODE' use32
.text$mn:00006DC4                 assume cs:_text$mn
.text$mn:00006DC4                 ;org 6DC4h
.text$mn:00006DC4 ; COMDAT (pick any)
.text$mn:00006DC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DC4
.text$mn:00006DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006DC4
.text$mn:00006DC4 ; Attributes: bp-based frame
.text$mn:00006DC4
.text$mn:00006DC4 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00006DC4                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00006DC4 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00006DC4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00006DC4                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00006DC4
.text$mn:00006DC4 var_8           = dword ptr -8
.text$mn:00006DC4 var_4           = dword ptr -4
.text$mn:00006DC4 arg_0           = dword ptr  8
.text$mn:00006DC4
.text$mn:00006DC4                 push    ebp
.text$mn:00006DC5                 mov     ebp, esp
.text$mn:00006DC7                 sub     esp, 8
.text$mn:00006DCA                 mov     [ebp+var_8], ecx
.text$mn:00006DCD                 mov     eax, [ebp+var_8]
.text$mn:00006DD0                 cmp     eax, [ebp+arg_0]
.text$mn:00006DD3                 jnz     short loc_6DDE
.text$mn:00006DD5                 mov     [ebp+var_4], 1
.text$mn:00006DDC                 jmp     short loc_6DE5
.text$mn:00006DDE ; ---------------------------------------------------------------------------
.text$mn:00006DDE
.text$mn:00006DDE loc_6DDE:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00006DDE                 mov     [ebp+var_4], 0
.text$mn:00006DE5
.text$mn:00006DE5 loc_6DE5:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00006DE5                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006DE8                 mov     esp, ebp
.text$mn:00006DEA                 pop     ebp
.text$mn:00006DEB                 retn    4
.text$mn:00006DEB ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00006DEB
.text$mn:00006DEB ; ---------------------------------------------------------------------------
.text$mn:00006DEE                 align 10h
.text$mn:00006DEE _text$mn        ends
.text$mn:00006DEE
.text$mn:00006DF0 ; ===========================================================================
.text$mn:00006DF0
.text$mn:00006DF0 ; Segment type: Pure code
.text$mn:00006DF0 ; Segment permissions: Read/Execute
.text$mn:00006DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00006DF0                 assume cs:_text$mn
.text$mn:00006DF0                 ;org 6DF0h
.text$mn:00006DF0 ; COMDAT (pick any)
.text$mn:00006DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DF0
.text$mn:00006DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006DF0
.text$mn:00006DF0 ; Attributes: bp-based frame
.text$mn:00006DF0
.text$mn:00006DF0 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00006DF0                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00006DF0 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00006DF0                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00006DF0
.text$mn:00006DF0 var_8           = dword ptr -8
.text$mn:00006DF0 var_4           = dword ptr -4
.text$mn:00006DF0 arg_0           = dword ptr  8
.text$mn:00006DF0
.text$mn:00006DF0                 push    ebp
.text$mn:00006DF1                 mov     ebp, esp
.text$mn:00006DF3                 sub     esp, 8
.text$mn:00006DF6                 push    esi
.text$mn:00006DF7                 mov     [ebp+var_4], ecx
.text$mn:00006DFA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006DFD                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00006E02                 push    eax
.text$mn:00006E03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006E06                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00006E0B                 mov     ecx, eax
.text$mn:00006E0D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00006E12                 movzx   eax, al
.text$mn:00006E15                 test    eax, eax
.text$mn:00006E17                 jz      short loc_6E38
.text$mn:00006E19                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006E1C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00006E21                 mov     esi, eax
.text$mn:00006E23                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006E26                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00006E2B                 cmp     esi, eax
.text$mn:00006E2D                 jnz     short loc_6E38
.text$mn:00006E2F                 mov     [ebp+var_8], 1
.text$mn:00006E36                 jmp     short loc_6E3F
.text$mn:00006E38 ; ---------------------------------------------------------------------------
.text$mn:00006E38
.text$mn:00006E38 loc_6E38:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00006E38                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00006E38                 mov     [ebp+var_8], 0
.text$mn:00006E3F
.text$mn:00006E3F loc_6E3F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00006E3F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00006E42                 pop     esi
.text$mn:00006E43                 mov     esp, ebp
.text$mn:00006E45                 pop     ebp
.text$mn:00006E46                 retn    4
.text$mn:00006E46 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00006E46
.text$mn:00006E46 ; ---------------------------------------------------------------------------
.text$mn:00006E49                 align 4
.text$mn:00006E49 _text$mn        ends
.text$mn:00006E49
.text$mn:00006E4C ; ===========================================================================
.text$mn:00006E4C
.text$mn:00006E4C ; Segment type: Pure code
.text$mn:00006E4C ; Segment permissions: Read/Execute
.text$mn:00006E4C _text$mn        segment para public 'CODE' use32
.text$mn:00006E4C                 assume cs:_text$mn
.text$mn:00006E4C                 ;org 6E4Ch
.text$mn:00006E4C ; COMDAT (pick any)
.text$mn:00006E4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E4C
.text$mn:00006E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E4C
.text$mn:00006E4C ; Attributes: bp-based frame
.text$mn:00006E4C
.text$mn:00006E4C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator!=(std::_Iterator_base12 *)
.text$mn:00006E4C                 public ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00006E4C ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00006E4C                                         ; CODE XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+30p
.text$mn:00006E4C
.text$mn:00006E4C var_8           = dword ptr -8
.text$mn:00006E4C var_4           = dword ptr -4
.text$mn:00006E4C arg_0           = dword ptr  8
.text$mn:00006E4C
.text$mn:00006E4C                 push    ebp
.text$mn:00006E4D                 mov     ebp, esp
.text$mn:00006E4F                 sub     esp, 8
.text$mn:00006E52                 mov     [ebp+var_8], ecx
.text$mn:00006E55                 mov     eax, [ebp+arg_0]
.text$mn:00006E58                 push    eax             ; std::_Iterator_base12 *
.text$mn:00006E59                 mov     ecx, [ebp+var_8]
.text$mn:00006E5C                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00006E61                 movzx   ecx, al
.text$mn:00006E64                 test    ecx, ecx
.text$mn:00006E66                 jnz     short loc_6E71
.text$mn:00006E68                 mov     [ebp+var_4], 1
.text$mn:00006E6F                 jmp     short loc_6E78
.text$mn:00006E71 ; ---------------------------------------------------------------------------
.text$mn:00006E71
.text$mn:00006E71 loc_6E71:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+1Aj
.text$mn:00006E71                 mov     [ebp+var_4], 0
.text$mn:00006E78
.text$mn:00006E78 loc_6E78:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator!=(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+23j
.text$mn:00006E78                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006E7B                 mov     esp, ebp
.text$mn:00006E7D                 pop     ebp
.text$mn:00006E7E                 retn    4
.text$mn:00006E7E ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00006E7E
.text$mn:00006E7E ; ---------------------------------------------------------------------------
.text$mn:00006E81                 align 4
.text$mn:00006E81 _text$mn        ends
.text$mn:00006E81
.text$mn:00006E84 ; ===========================================================================
.text$mn:00006E84
.text$mn:00006E84 ; Segment type: Pure code
.text$mn:00006E84 ; Segment permissions: Read/Execute
.text$mn:00006E84 _text$mn        segment para public 'CODE' use32
.text$mn:00006E84                 assume cs:_text$mn
.text$mn:00006E84                 ;org 6E84h
.text$mn:00006E84 ; COMDAT (pick any)
.text$mn:00006E84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E84
.text$mn:00006E84 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E84
.text$mn:00006E84 ; Attributes: bp-based frame
.text$mn:00006E84
.text$mn:00006E84 ; public: int & __thiscall std::_Revranit<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>, struct std::iterator<struct std::random_access_iterator_tag, int, int, int *, int &>>::operator*(void)const
.text$mn:00006E84                 public ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ
.text$mn:00006E84 ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ proc near
.text$mn:00006E84                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+B05p
.text$mn:00006E84
.text$mn:00006E84 var_20          = byte ptr -20h
.text$mn:00006E84 var_14          = dword ptr -14h
.text$mn:00006E84 var_10          = dword ptr -10h
.text$mn:00006E84 var_C           = dword ptr -0Ch
.text$mn:00006E84 var_4           = dword ptr -4
.text$mn:00006E84
.text$mn:00006E84                 push    ebp
.text$mn:00006E85                 mov     ebp, esp
.text$mn:00006E87                 push    0FFFFFFFFh
.text$mn:00006E89                 push    offset __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ
.text$mn:00006E8E                 mov     eax, large fs:0
.text$mn:00006E94                 push    eax
.text$mn:00006E95                 sub     esp, 14h
.text$mn:00006E98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E9D                 xor     eax, ebp
.text$mn:00006E9F                 push    eax
.text$mn:00006EA0                 lea     eax, [ebp+var_C]
.text$mn:00006EA3                 mov     large fs:0, eax
.text$mn:00006EA9                 mov     [ebp+var_10], ecx
.text$mn:00006EAC                 mov     eax, [ebp+var_10]
.text$mn:00006EAF                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006EB0                 lea     ecx, [ebp+var_20]
.text$mn:00006EB3                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00006EB8                 mov     [ebp+var_4], 0
.text$mn:00006EBF                 lea     ecx, [ebp+var_20]
.text$mn:00006EC2                 call    ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)
.text$mn:00006EC7                 mov     ecx, eax
.text$mn:00006EC9                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:00006ECE                 mov     [ebp+var_14], eax
.text$mn:00006ED1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006ED8                 lea     ecx, [ebp+var_20]
.text$mn:00006EDB                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00006EE0                 mov     eax, [ebp+var_14]
.text$mn:00006EE3                 mov     ecx, [ebp+var_C]
.text$mn:00006EE6                 mov     large fs:0, ecx
.text$mn:00006EED                 pop     ecx
.text$mn:00006EEE                 mov     esp, ebp
.text$mn:00006EF0                 pop     ebp
.text$mn:00006EF1                 retn
.text$mn:00006EF1 ??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ endp
.text$mn:00006EF1
.text$mn:00006EF1 ; ---------------------------------------------------------------------------
.text$mn:00006EF2                 align 4
.text$mn:00006EF2 _text$mn        ends
.text$mn:00006EF2
.text$x:00006EF4 ; ===========================================================================
.text$x:00006EF4
.text$x:00006EF4 ; Segment type: Pure code
.text$x:00006EF4 ; Segment permissions: Read/Execute
.text$x:00006EF4 _text$x         segment para public 'CODE' use32
.text$x:00006EF4                 assume cs:_text$x
.text$x:00006EF4                 ;org 6EF4h
.text$x:00006EF4 ; COMDAT (pick associative to section at 6E84)
.text$x:00006EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006EF4
.text$x:00006EF4 ; =============== S U B R O U T I N E =======================================
.text$x:00006EF4
.text$x:00006EF4
.text$x:00006EF4 __unwindfunclet$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ$0 proc near
.text$x:00006EF4                                         ; DATA XREF: .xdata$x:0000ABD4o
.text$x:00006EF4                 lea     ecx, [ebp-20h]
.text$x:00006EF7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006EF7 __unwindfunclet$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ$0 endp
.text$x:00006EF7
.text$x:00006EFC
.text$x:00006EFC ; =============== S U B R O U T I N E =======================================
.text$x:00006EFC
.text$x:00006EFC
.text$x:00006EFC __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ proc near
.text$x:00006EFC                                         ; DATA XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::operator*(void)+5o
.text$x:00006EFC
.text$x:00006EFC arg_4           = dword ptr  8
.text$x:00006EFC
.text$x:00006EFC                 mov     edx, [esp+arg_4]
.text$x:00006F00                 lea     eax, [edx+0Ch]
.text$x:00006F03                 mov     ecx, [edx-18h]
.text$x:00006F06                 xor     ecx, eax
.text$x:00006F08                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F0D                 mov     eax, offset __ehfuncinfo$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ
.text$x:00006F12                 jmp     ___CxxFrameHandler3
.text$x:00006F12 __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ endp
.text$x:00006F12
.text$x:00006F12 ; ---------------------------------------------------------------------------
.text$x:00006F17                 align 4
.text$x:00006F17 _text$x         ends
.text$x:00006F17
.text$mn:00006F18 ; ===========================================================================
.text$mn:00006F18
.text$mn:00006F18 ; Segment type: Pure code
.text$mn:00006F18 ; Segment permissions: Read/Execute
.text$mn:00006F18 _text$mn        segment para public 'CODE' use32
.text$mn:00006F18                 assume cs:_text$mn
.text$mn:00006F18                 ;org 6F18h
.text$mn:00006F18 ; COMDAT (pick any)
.text$mn:00006F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F18
.text$mn:00006F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F18
.text$mn:00006F18 ; Attributes: bp-based frame
.text$mn:00006F18
.text$mn:00006F18 ; public: int const & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator*(void)const
.text$mn:00006F18                 public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ
.text$mn:00006F18 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ proc near
.text$mn:00006F18                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+Ap
.text$mn:00006F18
.text$mn:00006F18 var_4           = dword ptr -4
.text$mn:00006F18
.text$mn:00006F18                 push    ebp
.text$mn:00006F19                 mov     ebp, esp
.text$mn:00006F1B                 push    ecx
.text$mn:00006F1C                 mov     [ebp+var_4], ecx
.text$mn:00006F1F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006F22                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006F27                 test    eax, eax
.text$mn:00006F29                 jz      short loc_6F5A
.text$mn:00006F2B                 mov     eax, [ebp+var_4]
.text$mn:00006F2E                 cmp     dword ptr [eax+8], 0
.text$mn:00006F32                 jz      short loc_6F5A
.text$mn:00006F34                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006F37                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006F3C                 mov     ecx, [ebp+var_4]
.text$mn:00006F3F                 mov     edx, [ecx+8]
.text$mn:00006F42                 cmp     edx, [eax+4]
.text$mn:00006F45                 jb      short loc_6F5A
.text$mn:00006F47                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006F4A                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006F4F                 mov     ecx, [ebp+var_4]
.text$mn:00006F52                 mov     edx, [eax+8]
.text$mn:00006F55                 cmp     edx, [ecx+8]
.text$mn:00006F58                 ja      short loc_6FB9
.text$mn:00006F5A
.text$mn:00006F5A loc_6F5A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+11j
.text$mn:00006F5A                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+1Aj ...
.text$mn:00006F5A                 push    48h ; 'H'       ; unsigned int
.text$mn:00006F5C                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006F61                 push    offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
.text$mn:00006F66                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00006F6B                 add     esp, 0Ch
.text$mn:00006F6E                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00006F73                 test    eax, eax
.text$mn:00006F75                 jz      short loc_6F7B
.text$mn:00006F77                 xor     ecx, ecx
.text$mn:00006F79                 jnz     short loc_6F9E
.text$mn:00006F7B
.text$mn:00006F7B loc_6F7B:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+5Dj
.text$mn:00006F7B                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00006F80                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00006F85                 push    0
.text$mn:00006F87                 push    49h ; 'I'
.text$mn:00006F89                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006F8E                 push    2
.text$mn:00006F90                 call    __CrtDbgReportW
.text$mn:00006F95                 add     esp, 18h
.text$mn:00006F98                 cmp     eax, 1
.text$mn:00006F9B                 jnz     short loc_6F9E
.text$mn:00006F9D                 int     3               ; Trap to Debugger
.text$mn:00006F9E
.text$mn:00006F9E loc_6F9E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+61j
.text$mn:00006F9E                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+83j
.text$mn:00006F9E                 push    0
.text$mn:00006FA0                 push    49h ; 'I'
.text$mn:00006FA2                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006FA7                 push    offset ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00006FAC                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00006FB1                 call    __invalid_parameter
.text$mn:00006FB6                 add     esp, 14h
.text$mn:00006FB9
.text$mn:00006FB9 loc_6FB9:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+40j
.text$mn:00006FB9                 mov     eax, [ebp+var_4]
.text$mn:00006FBC                 mov     eax, [eax+8]
.text$mn:00006FBF                 mov     esp, ebp
.text$mn:00006FC1                 pop     ebp
.text$mn:00006FC2                 retn
.text$mn:00006FC2 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ endp
.text$mn:00006FC2
.text$mn:00006FC2 ; ---------------------------------------------------------------------------
.text$mn:00006FC3                 align 4
.text$mn:00006FC3 _text$mn        ends
.text$mn:00006FC3
.text$mn:00006FC4 ; ===========================================================================
.text$mn:00006FC4
.text$mn:00006FC4 ; Segment type: Pure code
.text$mn:00006FC4 ; Segment permissions: Read/Execute
.text$mn:00006FC4 _text$mn        segment para public 'CODE' use32
.text$mn:00006FC4                 assume cs:_text$mn
.text$mn:00006FC4                 ;org 6FC4h
.text$mn:00006FC4 ; COMDAT (pick any)
.text$mn:00006FC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FC4
.text$mn:00006FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FC4
.text$mn:00006FC4 ; Attributes: bp-based frame
.text$mn:00006FC4
.text$mn:00006FC4 ; public: int & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator*(void)const
.text$mn:00006FC4                 public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ
.text$mn:00006FC4 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ proc near
.text$mn:00006FC4                                         ; CODE XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::operator*(void)+45p
.text$mn:00006FC4
.text$mn:00006FC4 var_4           = dword ptr -4
.text$mn:00006FC4
.text$mn:00006FC4                 push    ebp
.text$mn:00006FC5                 mov     ebp, esp
.text$mn:00006FC7                 push    ecx
.text$mn:00006FC8                 mov     [ebp+var_4], ecx
.text$mn:00006FCB                 mov     ecx, [ebp+var_4]
.text$mn:00006FCE                 call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)
.text$mn:00006FD3                 mov     esp, ebp
.text$mn:00006FD5                 pop     ebp
.text$mn:00006FD6                 retn
.text$mn:00006FD6 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ endp
.text$mn:00006FD6
.text$mn:00006FD6 ; ---------------------------------------------------------------------------
.text$mn:00006FD7                 align 4
.text$mn:00006FD7 _text$mn        ends
.text$mn:00006FD7
.text$mn:00006FD8 ; ===========================================================================
.text$mn:00006FD8
.text$mn:00006FD8 ; Segment type: Pure code
.text$mn:00006FD8 ; Segment permissions: Read/Execute
.text$mn:00006FD8 _text$mn        segment para public 'CODE' use32
.text$mn:00006FD8                 assume cs:_text$mn
.text$mn:00006FD8                 ;org 6FD8h
.text$mn:00006FD8 ; COMDAT (pick any)
.text$mn:00006FD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FD8
.text$mn:00006FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FD8
.text$mn:00006FD8 ; Attributes: bp-based frame
.text$mn:00006FD8
.text$mn:00006FD8 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator--(void)
.text$mn:00006FD8                 public ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00006FD8 ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00006FD8                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+Ap
.text$mn:00006FD8
.text$mn:00006FD8 var_4           = dword ptr -4
.text$mn:00006FD8
.text$mn:00006FD8                 push    ebp
.text$mn:00006FD9                 mov     ebp, esp
.text$mn:00006FDB                 push    ecx
.text$mn:00006FDC                 mov     [ebp+var_4], ecx
.text$mn:00006FDF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006FE2                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006FE7                 test    eax, eax
.text$mn:00006FE9                 jz      short loc_7007
.text$mn:00006FEB                 mov     eax, [ebp+var_4]
.text$mn:00006FEE                 cmp     dword ptr [eax+8], 0
.text$mn:00006FF2                 jz      short loc_7007
.text$mn:00006FF4                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006FF7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006FFC                 mov     ecx, [ebp+var_4]
.text$mn:00006FFF                 mov     edx, [ecx+8]
.text$mn:00007002                 cmp     edx, [eax+4]
.text$mn:00007005                 ja      short loc_706F
.text$mn:00007007
.text$mn:00007007 loc_7007:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+11j
.text$mn:00007007                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+1Aj
.text$mn:00007007                 push    82h ; 'é'       ; unsigned int
.text$mn:0000700C                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007011                 push    offset ??_C@_1EE@OEIJAKGE@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; "vector iterator not decrementable"
.text$mn:00007016                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000701B                 add     esp, 0Ch
.text$mn:0000701E                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00007023                 test    eax, eax
.text$mn:00007025                 jz      short loc_702B
.text$mn:00007027                 xor     ecx, ecx
.text$mn:00007029                 jnz     short loc_7051
.text$mn:0000702B
.text$mn:0000702B loc_702B:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+4Dj
.text$mn:0000702B                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00007030                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00007035                 push    0
.text$mn:00007037                 push    83h ; 'â'
.text$mn:0000703C                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007041                 push    2
.text$mn:00007043                 call    __CrtDbgReportW
.text$mn:00007048                 add     esp, 18h
.text$mn:0000704B                 cmp     eax, 1
.text$mn:0000704E                 jnz     short loc_7051
.text$mn:00007050                 int     3               ; Trap to Debugger
.text$mn:00007051
.text$mn:00007051 loc_7051:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+51j
.text$mn:00007051                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+76j
.text$mn:00007051                 push    0
.text$mn:00007053                 push    83h ; 'â'
.text$mn:00007058                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000705D                 push    offset ??_C@_1MG@BMOEGPOA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00007062                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00007067                 call    __invalid_parameter
.text$mn:0000706C                 add     esp, 14h
.text$mn:0000706F
.text$mn:0000706F loc_706F:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+2Dj
.text$mn:0000706F                 mov     eax, [ebp+var_4]
.text$mn:00007072                 mov     ecx, [eax+8]
.text$mn:00007075                 sub     ecx, 4
.text$mn:00007078                 mov     edx, [ebp+var_4]
.text$mn:0000707B                 mov     [edx+8], ecx
.text$mn:0000707E                 mov     eax, [ebp+var_4]
.text$mn:00007081                 mov     esp, ebp
.text$mn:00007083                 pop     ebp
.text$mn:00007084                 retn
.text$mn:00007084 ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00007084
.text$mn:00007084 ; ---------------------------------------------------------------------------
.text$mn:00007085                 align 4
.text$mn:00007085 _text$mn        ends
.text$mn:00007085
.text$mn:00007088 ; ===========================================================================
.text$mn:00007088
.text$mn:00007088 ; Segment type: Pure code
.text$mn:00007088 ; Segment permissions: Read/Execute
.text$mn:00007088 _text$mn        segment para public 'CODE' use32
.text$mn:00007088                 assume cs:_text$mn
.text$mn:00007088                 ;org 7088h
.text$mn:00007088 ; COMDAT (pick any)
.text$mn:00007088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007088
.text$mn:00007088 ; =============== S U B R O U T I N E =======================================
.text$mn:00007088
.text$mn:00007088 ; Attributes: bp-based frame
.text$mn:00007088
.text$mn:00007088 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator--(void)
.text$mn:00007088                 public ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00007088 ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00007088                                         ; CODE XREF: std::_Revranit<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>,std::iterator<std::random_access_iterator_tag,int,int,int *,int &>>::operator*(void)+3Ep
.text$mn:00007088
.text$mn:00007088 var_4           = dword ptr -4
.text$mn:00007088
.text$mn:00007088                 push    ebp
.text$mn:00007089                 mov     ebp, esp
.text$mn:0000708B                 push    ecx
.text$mn:0000708C                 mov     [ebp+var_4], ecx
.text$mn:0000708F                 mov     ecx, [ebp+var_4]
.text$mn:00007092                 call    ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)
.text$mn:00007097                 mov     eax, [ebp+var_4]
.text$mn:0000709A                 mov     esp, ebp
.text$mn:0000709C                 pop     ebp
.text$mn:0000709D                 retn
.text$mn:0000709D ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:0000709D
.text$mn:0000709D ; ---------------------------------------------------------------------------
.text$mn:0000709E                 align 10h
.text$mn:0000709E _text$mn        ends
.text$mn:0000709E
.text$mn:000070A0 ; ===========================================================================
.text$mn:000070A0
.text$mn:000070A0 ; Segment type: Pure code
.text$mn:000070A0 ; Segment permissions: Read/Execute
.text$mn:000070A0 _text$mn        segment para public 'CODE' use32
.text$mn:000070A0                 assume cs:_text$mn
.text$mn:000070A0                 ;org 70A0h
.text$mn:000070A0 ; COMDAT (pick any)
.text$mn:000070A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070A0
.text$mn:000070A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070A0
.text$mn:000070A0 ; Attributes: bp-based frame
.text$mn:000070A0
.text$mn:000070A0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator-(std::_Iterator_base12 *)
.text$mn:000070A0                 public ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:000070A0 ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:000070A0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+Ep
.text$mn:000070A0
.text$mn:000070A0 var_4           = dword ptr -4
.text$mn:000070A0 arg_0           = dword ptr  8
.text$mn:000070A0
.text$mn:000070A0                 push    ebp
.text$mn:000070A1                 mov     ebp, esp
.text$mn:000070A3                 push    ecx
.text$mn:000070A4                 mov     [ebp+var_4], ecx
.text$mn:000070A7                 mov     eax, [ebp+arg_0]
.text$mn:000070AA                 push    eax             ; std::_Iterator_base12 *
.text$mn:000070AB                 mov     ecx, [ebp+var_4]
.text$mn:000070AE                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:000070B3                 mov     ecx, [ebp+var_4]
.text$mn:000070B6                 mov     edx, [ebp+arg_0]
.text$mn:000070B9                 mov     eax, [ecx+8]
.text$mn:000070BC                 sub     eax, [edx+8]
.text$mn:000070BF                 cdq
.text$mn:000070C0                 mov     ecx, 18h
.text$mn:000070C5                 idiv    ecx
.text$mn:000070C7                 mov     esp, ebp
.text$mn:000070C9                 pop     ebp
.text$mn:000070CA                 retn    4
.text$mn:000070CA ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:000070CA
.text$mn:000070CA ; ---------------------------------------------------------------------------
.text$mn:000070CD                 align 10h
.text$mn:000070CD _text$mn        ends
.text$mn:000070CD
.text$mn:000070D0 ; ===========================================================================
.text$mn:000070D0
.text$mn:000070D0 ; Segment type: Pure code
.text$mn:000070D0 ; Segment permissions: Read/Execute
.text$mn:000070D0 _text$mn        segment para public 'CODE' use32
.text$mn:000070D0                 assume cs:_text$mn
.text$mn:000070D0                 ;org 70D0h
.text$mn:000070D0 ; COMDAT (pick any)
.text$mn:000070D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070D0
.text$mn:000070D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070D0
.text$mn:000070D0 ; Attributes: bp-based frame
.text$mn:000070D0
.text$mn:000070D0 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator-(std::_Iterator_base12 *)
.text$mn:000070D0                 public ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@1@@Z
.text$mn:000070D0 ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@1@@Z proc near
.text$mn:000070D0                                         ; CODE XREF: std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInPositionOrder)+A0p
.text$mn:000070D0                                         ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,SortInSelectOrder)+A0p
.text$mn:000070D0
.text$mn:000070D0 var_4           = dword ptr -4
.text$mn:000070D0 arg_0           = dword ptr  8
.text$mn:000070D0
.text$mn:000070D0                 push    ebp
.text$mn:000070D1                 mov     ebp, esp
.text$mn:000070D3                 push    ecx
.text$mn:000070D4                 mov     [ebp+var_4], ecx
.text$mn:000070D7                 mov     eax, [ebp+arg_0]
.text$mn:000070DA                 push    eax             ; std::_Iterator_base12 *
.text$mn:000070DB                 mov     ecx, [ebp+var_4]
.text$mn:000070DE                 call    ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:000070E3                 mov     esp, ebp
.text$mn:000070E5                 pop     ebp
.text$mn:000070E6                 retn    4
.text$mn:000070E6 ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@1@@Z endp
.text$mn:000070E6
.text$mn:000070E6 ; ---------------------------------------------------------------------------
.text$mn:000070E9                 align 4
.text$mn:000070E9 _text$mn        ends
.text$mn:000070E9
.text$mn:000070EC ; ===========================================================================
.text$mn:000070EC
.text$mn:000070EC ; Segment type: Pure code
.text$mn:000070EC ; Segment permissions: Read/Execute
.text$mn:000070EC _text$mn        segment para public 'CODE' use32
.text$mn:000070EC                 assume cs:_text$mn
.text$mn:000070EC                 ;org 70ECh
.text$mn:000070EC ; COMDAT (pick any)
.text$mn:000070EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070EC
.text$mn:000070EC ; =============== S U B R O U T I N E =======================================
.text$mn:000070EC
.text$mn:000070EC ; Attributes: bp-based frame
.text$mn:000070EC
.text$mn:000070EC ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator<(std::_Iterator_base12 *)
.text$mn:000070EC                 public ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:000070EC ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:000070EC                                         ; CODE XREF: std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+6Bp
.text$mn:000070EC
.text$mn:000070EC var_8           = dword ptr -8
.text$mn:000070EC var_4           = dword ptr -4
.text$mn:000070EC arg_0           = dword ptr  8
.text$mn:000070EC
.text$mn:000070EC                 push    ebp
.text$mn:000070ED                 mov     ebp, esp
.text$mn:000070EF                 sub     esp, 8
.text$mn:000070F2                 mov     [ebp+var_4], ecx
.text$mn:000070F5                 mov     eax, [ebp+arg_0]
.text$mn:000070F8                 push    eax             ; std::_Iterator_base12 *
.text$mn:000070F9                 mov     ecx, [ebp+var_4]
.text$mn:000070FC                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)
.text$mn:00007101                 mov     ecx, [ebp+var_4]
.text$mn:00007104                 mov     edx, [ebp+arg_0]
.text$mn:00007107                 mov     eax, [ecx+8]
.text$mn:0000710A                 cmp     eax, [edx+8]
.text$mn:0000710D                 jnb     short loc_7118
.text$mn:0000710F                 mov     [ebp+var_8], 1
.text$mn:00007116                 jmp     short loc_711F
.text$mn:00007118 ; ---------------------------------------------------------------------------
.text$mn:00007118
.text$mn:00007118 loc_7118:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+21j
.text$mn:00007118                 mov     [ebp+var_8], 0
.text$mn:0000711F
.text$mn:0000711F loc_711F:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+2Aj
.text$mn:0000711F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007122                 mov     esp, ebp
.text$mn:00007124                 pop     ebp
.text$mn:00007125                 retn    4
.text$mn:00007125 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00007125
.text$mn:00007125 _text$mn        ends
.text$mn:00007125
.text$mn:00007128 ; ===========================================================================
.text$mn:00007128
.text$mn:00007128 ; Segment type: Pure code
.text$mn:00007128 ; Segment permissions: Read/Execute
.text$mn:00007128 _text$mn        segment para public 'CODE' use32
.text$mn:00007128                 assume cs:_text$mn
.text$mn:00007128                 ;org 7128h
.text$mn:00007128 ; COMDAT (pick any)
.text$mn:00007128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007128
.text$mn:00007128 ; =============== S U B R O U T I N E =======================================
.text$mn:00007128
.text$mn:00007128 ; Attributes: bp-based frame
.text$mn:00007128
.text$mn:00007128 ; public: bool __thiscall SortInPositionOrder::operator()(struct ColumnModeInfo &, struct ColumnModeInfo &)
.text$mn:00007128                 public ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z
.text$mn:00007128 ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z proc near
.text$mn:00007128                                         ; CODE XREF: std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+20p
.text$mn:00007128                                         ; std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+4Fp ...
.text$mn:00007128
.text$mn:00007128 var_8           = dword ptr -8
.text$mn:00007128 var_4           = dword ptr -4
.text$mn:00007128 arg_0           = dword ptr  8
.text$mn:00007128 arg_4           = dword ptr  0Ch
.text$mn:00007128
.text$mn:00007128                 push    ebp
.text$mn:00007129                 mov     ebp, esp
.text$mn:0000712B                 sub     esp, 8
.text$mn:0000712E                 mov     [ebp+var_8], ecx
.text$mn:00007131                 mov     eax, [ebp+arg_0]
.text$mn:00007134                 mov     ecx, [ebp+arg_4]
.text$mn:00007137                 mov     edx, [eax]
.text$mn:00007139                 cmp     edx, [ecx]
.text$mn:0000713B                 jge     short loc_7146
.text$mn:0000713D                 mov     [ebp+var_4], 1
.text$mn:00007144                 jmp     short loc_714D
.text$mn:00007146 ; ---------------------------------------------------------------------------
.text$mn:00007146
.text$mn:00007146 loc_7146:                               ; CODE XREF: SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)+13j
.text$mn:00007146                 mov     [ebp+var_4], 0
.text$mn:0000714D
.text$mn:0000714D loc_714D:                               ; CODE XREF: SortInPositionOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)+1Cj
.text$mn:0000714D                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007150                 mov     esp, ebp
.text$mn:00007152                 pop     ebp
.text$mn:00007153                 retn    8
.text$mn:00007153 ??RSortInPositionOrder@@QAE_NAAUColumnModeInfo@@0@Z endp
.text$mn:00007153
.text$mn:00007153 ; ---------------------------------------------------------------------------
.text$mn:00007156                 align 4
.text$mn:00007156 _text$mn        ends
.text$mn:00007156
.text$mn:00007158 ; ===========================================================================
.text$mn:00007158
.text$mn:00007158 ; Segment type: Pure code
.text$mn:00007158 ; Segment permissions: Read/Execute
.text$mn:00007158 _text$mn        segment para public 'CODE' use32
.text$mn:00007158                 assume cs:_text$mn
.text$mn:00007158                 ;org 7158h
.text$mn:00007158 ; COMDAT (pick any)
.text$mn:00007158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007158
.text$mn:00007158 ; =============== S U B R O U T I N E =======================================
.text$mn:00007158
.text$mn:00007158 ; Attributes: bp-based frame
.text$mn:00007158
.text$mn:00007158 ; public: bool __thiscall SortInSelectOrder::operator()(struct ColumnModeInfo &, struct ColumnModeInfo &)
.text$mn:00007158                 public ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z
.text$mn:00007158 ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z proc near
.text$mn:00007158                                         ; CODE XREF: std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+20p
.text$mn:00007158                                         ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+4Fp ...
.text$mn:00007158
.text$mn:00007158 var_8           = dword ptr -8
.text$mn:00007158 var_4           = dword ptr -4
.text$mn:00007158 arg_0           = dword ptr  8
.text$mn:00007158 arg_4           = dword ptr  0Ch
.text$mn:00007158
.text$mn:00007158                 push    ebp
.text$mn:00007159                 mov     ebp, esp
.text$mn:0000715B                 sub     esp, 8
.text$mn:0000715E                 mov     [ebp+var_8], ecx
.text$mn:00007161                 mov     eax, [ebp+arg_0]
.text$mn:00007164                 mov     ecx, [ebp+arg_4]
.text$mn:00007167                 mov     edx, [eax+8]
.text$mn:0000716A                 cmp     edx, [ecx+8]
.text$mn:0000716D                 jge     short loc_7178
.text$mn:0000716F                 mov     [ebp+var_4], 1
.text$mn:00007176                 jmp     short loc_717F
.text$mn:00007178 ; ---------------------------------------------------------------------------
.text$mn:00007178
.text$mn:00007178 loc_7178:                               ; CODE XREF: SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)+15j
.text$mn:00007178                 mov     [ebp+var_4], 0
.text$mn:0000717F
.text$mn:0000717F loc_717F:                               ; CODE XREF: SortInSelectOrder::operator()(ColumnModeInfo &,ColumnModeInfo &)+1Ej
.text$mn:0000717F                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007182                 mov     esp, ebp
.text$mn:00007184                 pop     ebp
.text$mn:00007185                 retn    8
.text$mn:00007185 ??RSortInSelectOrder@@QAE_NAAUColumnModeInfo@@0@Z endp
.text$mn:00007185
.text$mn:00007185 _text$mn        ends
.text$mn:00007185
.text$mn:00007188 ; ===========================================================================
.text$mn:00007188
.text$mn:00007188 ; Segment type: Pure code
.text$mn:00007188 ; Segment permissions: Read/Execute
.text$mn:00007188 _text$mn        segment para public 'CODE' use32
.text$mn:00007188                 assume cs:_text$mn
.text$mn:00007188                 ;org 7188h
.text$mn:00007188 ; COMDAT (pick any)
.text$mn:00007188                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007188
.text$mn:00007188 ; =============== S U B R O U T I N E =======================================
.text$mn:00007188
.text$mn:00007188 ; Attributes: bp-based frame
.text$mn:00007188
.text$mn:00007188 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00007188                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00007188 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00007188
.text$mn:00007188 var_4           = dword ptr -4
.text$mn:00007188 arg_0           = dword ptr  8
.text$mn:00007188
.text$mn:00007188                 push    ebp
.text$mn:00007189                 mov     ebp, esp
.text$mn:0000718B                 push    ecx
.text$mn:0000718C                 mov     [ebp+var_4], ecx
.text$mn:0000718F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007192                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007197                 mov     eax, [ebp+arg_0]
.text$mn:0000719A                 and     eax, 1
.text$mn:0000719D                 jz      short loc_71AB
.text$mn:0000719F                 mov     ecx, [ebp+var_4]
.text$mn:000071A2                 push    ecx             ; void *
.text$mn:000071A3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000071A8                 add     esp, 4
.text$mn:000071AB
.text$mn:000071AB loc_71AB:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000071AB                 mov     eax, [ebp+var_4]
.text$mn:000071AE                 mov     esp, ebp
.text$mn:000071B0                 pop     ebp
.text$mn:000071B1                 retn    4
.text$mn:000071B1 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000071B1
.text$mn:000071B1 _text$mn        ends
.text$mn:000071B1
.text$mn:000071B4 ; ===========================================================================
.text$mn:000071B4
.text$mn:000071B4 ; Segment type: Pure code
.text$mn:000071B4 ; Segment permissions: Read/Execute
.text$mn:000071B4 _text$mn        segment para public 'CODE' use32
.text$mn:000071B4                 assume cs:_text$mn
.text$mn:000071B4                 ;org 71B4h
.text$mn:000071B4 ; COMDAT (pick any)
.text$mn:000071B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000071B4
.text$mn:000071B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000071B4
.text$mn:000071B4 ; Attributes: bp-based frame
.text$mn:000071B4
.text$mn:000071B4 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000071B4                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:000071B4 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:000071B4
.text$mn:000071B4 var_4           = dword ptr -4
.text$mn:000071B4 arg_0           = dword ptr  8
.text$mn:000071B4
.text$mn:000071B4                 push    ebp
.text$mn:000071B5                 mov     ebp, esp
.text$mn:000071B7                 push    ecx
.text$mn:000071B8                 mov     [ebp+var_4], ecx
.text$mn:000071BB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000071BE                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:000071C3                 mov     eax, [ebp+arg_0]
.text$mn:000071C6                 and     eax, 1
.text$mn:000071C9                 jz      short loc_71D7
.text$mn:000071CB                 mov     ecx, [ebp+var_4]
.text$mn:000071CE                 push    ecx             ; void *
.text$mn:000071CF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000071D4                 add     esp, 4
.text$mn:000071D7
.text$mn:000071D7 loc_71D7:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000071D7                 mov     eax, [ebp+var_4]
.text$mn:000071DA                 mov     esp, ebp
.text$mn:000071DC                 pop     ebp
.text$mn:000071DD                 retn    4
.text$mn:000071DD ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:000071DD
.text$mn:000071DD _text$mn        ends
.text$mn:000071DD
.text$mn:000071E0 ; ===========================================================================
.text$mn:000071E0
.text$mn:000071E0 ; Segment type: Pure code
.text$mn:000071E0 ; Segment permissions: Read/Execute
.text$mn:000071E0 _text$mn        segment para public 'CODE' use32
.text$mn:000071E0                 assume cs:_text$mn
.text$mn:000071E0                 ;org 71E0h
.text$mn:000071E0 ; COMDAT (pick any)
.text$mn:000071E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000071E0
.text$mn:000071E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000071E0
.text$mn:000071E0 ; Attributes: bp-based frame
.text$mn:000071E0
.text$mn:000071E0 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000071E0                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:000071E0 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:000071E0
.text$mn:000071E0 var_4           = dword ptr -4
.text$mn:000071E0 arg_0           = dword ptr  8
.text$mn:000071E0
.text$mn:000071E0                 push    ebp
.text$mn:000071E1                 mov     ebp, esp
.text$mn:000071E3                 push    ecx
.text$mn:000071E4                 mov     [ebp+var_4], ecx
.text$mn:000071E7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000071EA                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000071EF                 mov     eax, [ebp+arg_0]
.text$mn:000071F2                 and     eax, 1
.text$mn:000071F5                 jz      short loc_7203
.text$mn:000071F7                 mov     ecx, [ebp+var_4]
.text$mn:000071FA                 push    ecx             ; void *
.text$mn:000071FB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007200                 add     esp, 4
.text$mn:00007203
.text$mn:00007203 loc_7203:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00007203                 mov     eax, [ebp+var_4]
.text$mn:00007206                 mov     esp, ebp
.text$mn:00007208                 pop     ebp
.text$mn:00007209                 retn    4
.text$mn:00007209 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00007209
.text$mn:00007209 _text$mn        ends
.text$mn:00007209
.text$mn:0000720C ; ===========================================================================
.text$mn:0000720C
.text$mn:0000720C ; Segment type: Pure code
.text$mn:0000720C ; Segment permissions: Read/Execute
.text$mn:0000720C _text$mn        segment para public 'CODE' use32
.text$mn:0000720C                 assume cs:_text$mn
.text$mn:0000720C                 ;org 720Ch
.text$mn:0000720C ; COMDAT (pick any)
.text$mn:0000720C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000720C
.text$mn:0000720C ; =============== S U B R O U T I N E =======================================
.text$mn:0000720C
.text$mn:0000720C ; Attributes: bp-based frame
.text$mn:0000720C
.text$mn:0000720C ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000720C                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:0000720C ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:0000720C
.text$mn:0000720C var_4           = dword ptr -4
.text$mn:0000720C arg_0           = dword ptr  8
.text$mn:0000720C
.text$mn:0000720C                 push    ebp
.text$mn:0000720D                 mov     ebp, esp
.text$mn:0000720F                 push    ecx
.text$mn:00007210                 mov     [ebp+var_4], ecx
.text$mn:00007213                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007216                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000721B                 mov     eax, [ebp+arg_0]
.text$mn:0000721E                 and     eax, 1
.text$mn:00007221                 jz      short loc_722F
.text$mn:00007223                 mov     ecx, [ebp+var_4]
.text$mn:00007226                 push    ecx             ; void *
.text$mn:00007227                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000722C                 add     esp, 4
.text$mn:0000722F
.text$mn:0000722F loc_722F:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000722F                 mov     eax, [ebp+var_4]
.text$mn:00007232                 mov     esp, ebp
.text$mn:00007234                 pop     ebp
.text$mn:00007235                 retn    4
.text$mn:00007235 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00007235
.text$mn:00007235 _text$mn        ends
.text$mn:00007235
.text$mn:00007238 ; ===========================================================================
.text$mn:00007238
.text$mn:00007238 ; Segment type: Pure code
.text$mn:00007238 ; Segment permissions: Read/Execute
.text$mn:00007238 _text$mn        segment para public 'CODE' use32
.text$mn:00007238                 assume cs:_text$mn
.text$mn:00007238                 ;org 7238h
.text$mn:00007238 ; COMDAT (pick any)
.text$mn:00007238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007238
.text$mn:00007238 ; =============== S U B R O U T I N E =======================================
.text$mn:00007238
.text$mn:00007238 ; Attributes: bp-based frame
.text$mn:00007238
.text$mn:00007238 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:00007238                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:00007238 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:00007238
.text$mn:00007238 var_4           = dword ptr -4
.text$mn:00007238 arg_0           = dword ptr  8
.text$mn:00007238
.text$mn:00007238                 push    ebp
.text$mn:00007239                 mov     ebp, esp
.text$mn:0000723B                 push    ecx
.text$mn:0000723C                 mov     [ebp+var_4], ecx
.text$mn:0000723F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007242                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:00007247                 mov     eax, [ebp+arg_0]
.text$mn:0000724A                 and     eax, 1
.text$mn:0000724D                 jz      short loc_725B
.text$mn:0000724F                 mov     ecx, [ebp+var_4]
.text$mn:00007252                 push    ecx             ; void *
.text$mn:00007253                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007258                 add     esp, 4
.text$mn:0000725B
.text$mn:0000725B loc_725B:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:0000725B                 mov     eax, [ebp+var_4]
.text$mn:0000725E                 mov     esp, ebp
.text$mn:00007260                 pop     ebp
.text$mn:00007261                 retn    4
.text$mn:00007261 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00007261
.text$mn:00007261 _text$mn        ends
.text$mn:00007261
.text$di:00007264 ; ===========================================================================
.text$di:00007264
.text$di:00007264 ; Segment type: Pure code
.text$di:00007264 ; Segment permissions: Read/Execute
.text$di:00007264 _text$di        segment para public 'CODE' use32
.text$di:00007264                 assume cs:_text$di
.text$di:00007264                 ;org 7264h
.text$di:00007264 ; COMDAT (pick any)
.text$di:00007264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00007264
.text$di:00007264 ; =============== S U B R O U T I N E =======================================
.text$di:00007264
.text$di:00007264 ; Attributes: bp-based frame
.text$di:00007264
.text$di:00007264 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00007264 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00007264                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00007264                 push    ebp
.text$di:00007265                 mov     ebp, esp
.text$di:00007267                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:0000726C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00007271                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00007276                 call    _atexit
.text$di:0000727B                 add     esp, 4
.text$di:0000727E                 pop     ebp
.text$di:0000727F                 retn
.text$di:0000727F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:0000727F
.text$di:0000727F _text$di        ends
.text$di:0000727F
.text$di:00007280 ; ===========================================================================
.text$di:00007280
.text$di:00007280 ; Segment type: Pure code
.text$di:00007280 ; Segment permissions: Read/Execute
.text$di:00007280 _text$di        segment para public 'CODE' use32
.text$di:00007280                 assume cs:_text$di
.text$di:00007280                 ;org 7280h
.text$di:00007280 ; COMDAT (pick any)
.text$di:00007280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00007280
.text$di:00007280 ; =============== S U B R O U T I N E =======================================
.text$di:00007280
.text$di:00007280 ; Attributes: bp-based frame
.text$di:00007280
.text$di:00007280 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00007280 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00007280                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00007280                 push    ebp
.text$di:00007281                 mov     ebp, esp
.text$di:00007283                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00007288                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:0000728D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00007292                 call    _atexit
.text$di:00007297                 add     esp, 4
.text$di:0000729A                 pop     ebp
.text$di:0000729B                 retn
.text$di:0000729B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:0000729B
.text$di:0000729B _text$di        ends
.text$di:0000729B
.text$di:0000729C ; ===========================================================================
.text$di:0000729C
.text$di:0000729C ; Segment type: Pure code
.text$di:0000729C ; Segment permissions: Read/Execute
.text$di:0000729C _text$di        segment para public 'CODE' use32
.text$di:0000729C                 assume cs:_text$di
.text$di:0000729C                 ;org 729Ch
.text$di:0000729C ; COMDAT (pick any)
.text$di:0000729C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000729C
.text$di:0000729C ; =============== S U B R O U T I N E =======================================
.text$di:0000729C
.text$di:0000729C ; Attributes: bp-based frame
.text$di:0000729C
.text$di:0000729C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:0000729C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:0000729C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:0000729C                 push    ebp
.text$di:0000729D                 mov     ebp, esp
.text$di:0000729F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000072A4                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000072A9                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000072AE                 call    _atexit
.text$di:000072B3                 add     esp, 4
.text$di:000072B6                 pop     ebp
.text$di:000072B7                 retn
.text$di:000072B7 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000072B7
.text$di:000072B7 _text$di        ends
.text$di:000072B7
.text$di:000072B8 ; ===========================================================================
.text$di:000072B8
.text$di:000072B8 ; Segment type: Pure code
.text$di:000072B8 ; Segment permissions: Read/Execute
.text$di:000072B8 _text$di        segment para public 'CODE' use32
.text$di:000072B8                 assume cs:_text$di
.text$di:000072B8                 ;org 72B8h
.text$di:000072B8 ; COMDAT (pick any)
.text$di:000072B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000072B8
.text$di:000072B8 ; =============== S U B R O U T I N E =======================================
.text$di:000072B8
.text$di:000072B8 ; Attributes: bp-based frame
.text$di:000072B8
.text$di:000072B8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:000072B8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000072B8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:000072B8                 push    ebp
.text$di:000072B9                 mov     ebp, esp
.text$di:000072BB                 push    0               ; unsigned int
.text$di:000072BD                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000072C2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000072C7                 pop     ebp
.text$di:000072C8                 retn
.text$di:000072C8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000072C8
.text$di:000072C8 ; ---------------------------------------------------------------------------
.text$di:000072C9                 align 4
.text$di:000072C9 _text$di        ends
.text$di:000072C9
.text$di:000072CC ; ===========================================================================
.text$di:000072CC
.text$di:000072CC ; Segment type: Pure code
.text$di:000072CC ; Segment permissions: Read/Execute
.text$di:000072CC _text$di        segment para public 'CODE' use32
.text$di:000072CC                 assume cs:_text$di
.text$di:000072CC                 ;org 72CCh
.text$di:000072CC ; COMDAT (pick any)
.text$di:000072CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000072CC
.text$di:000072CC ; =============== S U B R O U T I N E =======================================
.text$di:000072CC
.text$di:000072CC ; Attributes: bp-based frame
.text$di:000072CC
.text$di:000072CC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000072CC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000072CC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000072CC                 push    ebp
.text$di:000072CD                 mov     ebp, esp
.text$di:000072CF                 push    0               ; unsigned int
.text$di:000072D1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000072D6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000072DB                 pop     ebp
.text$di:000072DC                 retn
.text$di:000072DC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000072DC
.text$di:000072DC ; ---------------------------------------------------------------------------
.text$di:000072DD                 align 10h
.text$di:000072DD _text$di        ends
.text$di:000072DD
.text$di:000072E0 ; ===========================================================================
.text$di:000072E0
.text$di:000072E0 ; Segment type: Pure code
.text$di:000072E0 ; Segment permissions: Read/Execute
.text$di:000072E0 _text$di        segment para public 'CODE' use32
.text$di:000072E0                 assume cs:_text$di
.text$di:000072E0                 ;org 72E0h
.text$di:000072E0 ; COMDAT (pick any)
.text$di:000072E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000072E0
.text$di:000072E0 ; =============== S U B R O U T I N E =======================================
.text$di:000072E0
.text$di:000072E0 ; Attributes: bp-based frame
.text$di:000072E0
.text$di:000072E0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:000072E0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000072E0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:000072E0                 push    ebp
.text$di:000072E1                 mov     ebp, esp
.text$di:000072E3                 push    0               ; unsigned int
.text$di:000072E5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:000072EA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000072EF                 pop     ebp
.text$di:000072F0                 retn
.text$di:000072F0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000072F0
.text$di:000072F0 ; ---------------------------------------------------------------------------
.text$di:000072F1                 align 4
.text$di:000072F1 _text$di        ends
.text$di:000072F1
.text$di:000072F4 ; ===========================================================================
.text$di:000072F4
.text$di:000072F4 ; Segment type: Pure code
.text$di:000072F4 ; Segment permissions: Read/Execute
.text$di:000072F4 _text$di        segment para public 'CODE' use32
.text$di:000072F4                 assume cs:_text$di
.text$di:000072F4                 ;org 72F4h
.text$di:000072F4 ; COMDAT (pick any)
.text$di:000072F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000072F4
.text$di:000072F4 ; =============== S U B R O U T I N E =======================================
.text$di:000072F4
.text$di:000072F4 ; Attributes: bp-based frame
.text$di:000072F4
.text$di:000072F4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:000072F4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000072F4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:000072F4                 push    ebp
.text$di:000072F5                 mov     ebp, esp
.text$di:000072F7                 push    0               ; unsigned int
.text$di:000072F9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:000072FE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00007303                 pop     ebp
.text$di:00007304                 retn
.text$di:00007304 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00007304
.text$di:00007304 ; ---------------------------------------------------------------------------
.text$di:00007305                 align 4
.text$di:00007305 _text$di        ends
.text$di:00007305
.text$di:00007308 ; ===========================================================================
.text$di:00007308
.text$di:00007308 ; Segment type: Pure code
.text$di:00007308 ; Segment permissions: Read/Execute
.text$di:00007308 _text$di        segment para public 'CODE' use32
.text$di:00007308                 assume cs:_text$di
.text$di:00007308                 ;org 7308h
.text$di:00007308 ; COMDAT (pick any)
.text$di:00007308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00007308
.text$di:00007308 ; =============== S U B R O U T I N E =======================================
.text$di:00007308
.text$di:00007308 ; Attributes: bp-based frame
.text$di:00007308
.text$di:00007308 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00007308 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00007308
.text$di:00007308 var_1           = byte ptr -1
.text$di:00007308
.text$di:00007308                 push    ebp
.text$di:00007309                 mov     ebp, esp
.text$di:0000730B                 push    ecx
.text$di:0000730C                 xor     eax, eax
.text$di:0000730E                 mov     [ebp+var_1], al
.text$di:00007311                 mov     esp, ebp
.text$di:00007313                 pop     ebp
.text$di:00007314                 retn
.text$di:00007314 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00007314
.text$di:00007314 ; ---------------------------------------------------------------------------
.text$di:00007315                 align 4
.text$di:00007315 _text$di        ends
.text$di:00007315
.text$di:00007318 ; ===========================================================================
.text$di:00007318
.text$di:00007318 ; Segment type: Pure code
.text$di:00007318 ; Segment permissions: Read/Execute
.text$di:00007318 _text$di        segment para public 'CODE' use32
.text$di:00007318                 assume cs:_text$di
.text$di:00007318                 ;org 7318h
.text$di:00007318 ; COMDAT (pick any)
.text$di:00007318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00007318
.text$di:00007318 ; =============== S U B R O U T I N E =======================================
.text$di:00007318
.text$di:00007318 ; Attributes: bp-based frame
.text$di:00007318
.text$di:00007318 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00007318 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00007318
.text$di:00007318 var_1           = byte ptr -1
.text$di:00007318
.text$di:00007318                 push    ebp
.text$di:00007319                 mov     ebp, esp
.text$di:0000731B                 push    ecx
.text$di:0000731C                 xor     eax, eax
.text$di:0000731E                 mov     [ebp+var_1], al
.text$di:00007321                 mov     esp, ebp
.text$di:00007323                 pop     ebp
.text$di:00007324                 retn
.text$di:00007324 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00007324
.text$di:00007324 ; ---------------------------------------------------------------------------
.text$di:00007325                 align 4
.text$di:00007325 _text$di        ends
.text$di:00007325
.text$di:00007328 ; ===========================================================================
.text$di:00007328
.text$di:00007328 ; Segment type: Pure code
.text$di:00007328 ; Segment permissions: Read/Execute
.text$di:00007328 _text$di        segment para public 'CODE' use32
.text$di:00007328                 assume cs:_text$di
.text$di:00007328                 ;org 7328h
.text$di:00007328 ; COMDAT (pick any)
.text$di:00007328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00007328
.text$di:00007328 ; =============== S U B R O U T I N E =======================================
.text$di:00007328
.text$di:00007328 ; Attributes: bp-based frame
.text$di:00007328
.text$di:00007328 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00007328 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00007328                 push    ebp
.text$di:00007329                 mov     ebp, esp
.text$di:0000732B                 mov     ecx, offset _ignore ; this
.text$di:00007330                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00007335                 pop     ebp
.text$di:00007336                 retn
.text$di:00007336 ??__Eignore@std@@YAXXZ endp
.text$di:00007336
.text$di:00007336 ; ---------------------------------------------------------------------------
.text$di:00007337                 align 4
.text$di:00007337 _text$di        ends
.text$di:00007337
.text$di:00007338 ; ===========================================================================
.text$di:00007338
.text$di:00007338 ; Segment type: Pure code
.text$di:00007338 ; Segment permissions: Read/Execute
.text$di:00007338 _text$di        segment para public 'CODE' use32
.text$di:00007338                 assume cs:_text$di
.text$di:00007338                 ;org 7338h
.text$di:00007338 ; COMDAT (pick any)
.text$di:00007338                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00007338
.text$di:00007338 ; =============== S U B R O U T I N E =======================================
.text$di:00007338
.text$di:00007338 ; Attributes: bp-based frame
.text$di:00007338
.text$di:00007338 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00007338 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00007338                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00007338
.text$di:00007338 var_1           = byte ptr -1
.text$di:00007338
.text$di:00007338                 push    ebp
.text$di:00007339                 mov     ebp, esp
.text$di:0000733B                 push    ecx
.text$di:0000733C                 xor     eax, eax
.text$di:0000733E                 mov     [ebp+var_1], al
.text$di:00007341                 mov     esp, ebp
.text$di:00007343                 pop     ebp
.text$di:00007344                 retn
.text$di:00007344 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00007344
.text$di:00007344 ; ---------------------------------------------------------------------------
.text$di:00007345                 align 4
.text$di:00007345 _text$di        ends
.text$di:00007345
.text$yd:00007348 ; ===========================================================================
.text$yd:00007348
.text$yd:00007348 ; Segment type: Pure code
.text$yd:00007348 ; Segment permissions: Read/Execute
.text$yd:00007348 _text$yd        segment para public 'CODE' use32
.text$yd:00007348                 assume cs:_text$yd
.text$yd:00007348                 ;org 7348h
.text$yd:00007348 ; COMDAT (pick any)
.text$yd:00007348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00007348
.text$yd:00007348 ; =============== S U B R O U T I N E =======================================
.text$yd:00007348
.text$yd:00007348 ; Attributes: bp-based frame
.text$yd:00007348
.text$yd:00007348 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00007348 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00007348                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00007348                 push    ebp
.text$yd:00007349                 mov     ebp, esp
.text$yd:0000734B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00007350                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00007355                 pop     ebp
.text$yd:00007356                 retn
.text$yd:00007356 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00007356
.text$yd:00007356 ; ---------------------------------------------------------------------------
.text$yd:00007357                 align 4
.text$yd:00007357 _text$yd        ends
.text$yd:00007357
.text$yd:00007358 ; ===========================================================================
.text$yd:00007358
.text$yd:00007358 ; Segment type: Pure code
.text$yd:00007358 ; Segment permissions: Read/Execute
.text$yd:00007358 _text$yd        segment para public 'CODE' use32
.text$yd:00007358                 assume cs:_text$yd
.text$yd:00007358                 ;org 7358h
.text$yd:00007358 ; COMDAT (pick any)
.text$yd:00007358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00007358
.text$yd:00007358 ; =============== S U B R O U T I N E =======================================
.text$yd:00007358
.text$yd:00007358 ; Attributes: bp-based frame
.text$yd:00007358
.text$yd:00007358 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00007358 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00007358                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00007358                 push    ebp
.text$yd:00007359                 mov     ebp, esp
.text$yd:0000735B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00007360                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00007365                 pop     ebp
.text$yd:00007366                 retn
.text$yd:00007366 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00007366
.text$yd:00007366 ; ---------------------------------------------------------------------------
.text$yd:00007367                 align 4
.text$yd:00007367 _text$yd        ends
.text$yd:00007367
.text$yd:00007368 ; ===========================================================================
.text$yd:00007368
.text$yd:00007368 ; Segment type: Pure code
.text$yd:00007368 ; Segment permissions: Read/Execute
.text$yd:00007368 _text$yd        segment para public 'CODE' use32
.text$yd:00007368                 assume cs:_text$yd
.text$yd:00007368                 ;org 7368h
.text$yd:00007368 ; COMDAT (pick any)
.text$yd:00007368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00007368
.text$yd:00007368 ; =============== S U B R O U T I N E =======================================
.text$yd:00007368
.text$yd:00007368 ; Attributes: bp-based frame
.text$yd:00007368
.text$yd:00007368 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00007368 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00007368                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00007368                 push    ebp
.text$yd:00007369                 mov     ebp, esp
.text$yd:0000736B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00007370                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00007375                 pop     ebp
.text$yd:00007376                 retn
.text$yd:00007376 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00007376
.text$yd:00007376 ; ---------------------------------------------------------------------------
.text$yd:00007377                 align 4
.text$yd:00007377 _text$yd        ends
.text$yd:00007377
.text$mn:00007378 ; ===========================================================================
.text$mn:00007378
.text$mn:00007378 ; Segment type: Pure code
.text$mn:00007378 ; Segment permissions: Read/Execute
.text$mn:00007378 _text$mn        segment para public 'CODE' use32
.text$mn:00007378                 assume cs:_text$mn
.text$mn:00007378                 ;org 7378h
.text$mn:00007378 ; COMDAT (pick any)
.text$mn:00007378                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007378
.text$mn:00007378 ; =============== S U B R O U T I N E =======================================
.text$mn:00007378
.text$mn:00007378 ; Attributes: bp-based frame
.text$mn:00007378
.text$mn:00007378 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00007378                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00007378 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00007378                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+45p
.text$mn:00007378                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)+45p ...
.text$mn:00007378
.text$mn:00007378 var_1C          = byte ptr -1Ch
.text$mn:00007378 var_18          = byte ptr -18h
.text$mn:00007378 var_14          = dword ptr -14h
.text$mn:00007378 var_10          = dword ptr -10h
.text$mn:00007378 var_C           = dword ptr -0Ch
.text$mn:00007378 var_4           = dword ptr -4
.text$mn:00007378 arg_0           = dword ptr  8
.text$mn:00007378
.text$mn:00007378                 push    ebp
.text$mn:00007379                 mov     ebp, esp
.text$mn:0000737B                 push    0FFFFFFFFh
.text$mn:0000737D                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00007382                 mov     eax, large fs:0
.text$mn:00007388                 push    eax
.text$mn:00007389                 sub     esp, 10h
.text$mn:0000738C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007391                 xor     eax, ebp
.text$mn:00007393                 push    eax
.text$mn:00007394                 lea     eax, [ebp+var_C]
.text$mn:00007397                 mov     large fs:0, eax
.text$mn:0000739D                 mov     [ebp+var_10], ecx
.text$mn:000073A0                 cmp     [ebp+arg_0], 0
.text$mn:000073A4                 jnz     short loc_73D0
.text$mn:000073A6                 push    3               ; int
.text$mn:000073A8                 lea     ecx, [ebp+var_18] ; this
.text$mn:000073AB                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000073B0                 mov     [ebp+var_4], 0
.text$mn:000073B7                 mov     ecx, [ebp+var_10] ; this
.text$mn:000073BA                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000073BF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000073C6                 lea     ecx, [ebp+var_18] ; this
.text$mn:000073C9                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000073CE                 jmp     short loc_7427
.text$mn:000073D0 ; ---------------------------------------------------------------------------
.text$mn:000073D0
.text$mn:000073D0 loc_73D0:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:000073D0                 mov     eax, [ebp+arg_0]
.text$mn:000073D3                 mov     ecx, [eax]
.text$mn:000073D5                 mov     [ebp+var_14], ecx
.text$mn:000073D8                 mov     edx, [ebp+var_10]
.text$mn:000073DB                 mov     eax, [edx]
.text$mn:000073DD                 cmp     eax, [ebp+var_14]
.text$mn:000073E0                 jz      short loc_7427
.text$mn:000073E2                 push    3               ; int
.text$mn:000073E4                 lea     ecx, [ebp+var_1C] ; this
.text$mn:000073E7                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000073EC                 mov     [ebp+var_4], 1
.text$mn:000073F3                 mov     ecx, [ebp+var_10] ; this
.text$mn:000073F6                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000073FB                 mov     ecx, [ebp+var_10]
.text$mn:000073FE                 mov     edx, [ebp+var_14]
.text$mn:00007401                 mov     eax, [edx+4]
.text$mn:00007404                 mov     [ecx+4], eax
.text$mn:00007407                 mov     ecx, [ebp+var_14]
.text$mn:0000740A                 mov     edx, [ebp+var_10]
.text$mn:0000740D                 mov     [ecx+4], edx
.text$mn:00007410                 mov     eax, [ebp+var_10]
.text$mn:00007413                 mov     ecx, [ebp+var_14]
.text$mn:00007416                 mov     [eax], ecx
.text$mn:00007418                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000741F                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00007422                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007427
.text$mn:00007427 loc_7427:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00007427                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00007427                 mov     ecx, [ebp+var_C]
.text$mn:0000742A                 mov     large fs:0, ecx
.text$mn:00007431                 pop     ecx
.text$mn:00007432                 mov     esp, ebp
.text$mn:00007434                 pop     ebp
.text$mn:00007435                 retn    4
.text$mn:00007435 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00007435
.text$mn:00007435 _text$mn        ends
.text$mn:00007435
.text$x:00007438 ; ===========================================================================
.text$x:00007438
.text$x:00007438 ; Segment type: Pure code
.text$x:00007438 ; Segment permissions: Read/Execute
.text$x:00007438 _text$x         segment para public 'CODE' use32
.text$x:00007438                 assume cs:_text$x
.text$x:00007438                 ;org 7438h
.text$x:00007438 ; COMDAT (pick associative to section at 7378)
.text$x:00007438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007438
.text$x:00007438 ; =============== S U B R O U T I N E =======================================
.text$x:00007438
.text$x:00007438
.text$x:00007438 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00007438                                         ; DATA XREF: .xdata$x:00009ED4o
.text$x:00007438                 lea     ecx, [ebp-18h]  ; this
.text$x:0000743B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000743B __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:0000743B
.text$x:00007440
.text$x:00007440 ; =============== S U B R O U T I N E =======================================
.text$x:00007440
.text$x:00007440
.text$x:00007440 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00007440                                         ; DATA XREF: .xdata$x:00009EDCo
.text$x:00007440                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00007443                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007443 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00007443
.text$x:00007448
.text$x:00007448 ; =============== S U B R O U T I N E =======================================
.text$x:00007448
.text$x:00007448
.text$x:00007448 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00007448                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00007448
.text$x:00007448 arg_4           = dword ptr  8
.text$x:00007448
.text$x:00007448                 mov     edx, [esp+arg_4]
.text$x:0000744C                 lea     eax, [edx+0Ch]
.text$x:0000744F                 mov     ecx, [edx-14h]
.text$x:00007452                 xor     ecx, eax
.text$x:00007454                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007459                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:0000745E                 jmp     ___CxxFrameHandler3
.text$x:0000745E __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:0000745E
.text$x:0000745E ; ---------------------------------------------------------------------------
.text$x:00007463                 align 4
.text$x:00007463 _text$x         ends
.text$x:00007463
.text$mn:00007464 ; ===========================================================================
.text$mn:00007464
.text$mn:00007464 ; Segment type: Pure code
.text$mn:00007464 ; Segment permissions: Read/Execute
.text$mn:00007464 _text$mn        segment para public 'CODE' use32
.text$mn:00007464                 assume cs:_text$mn
.text$mn:00007464                 ;org 7464h
.text$mn:00007464 ; COMDAT (pick any)
.text$mn:00007464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007464
.text$mn:00007464 ; =============== S U B R O U T I N E =======================================
.text$mn:00007464
.text$mn:00007464 ; Attributes: bp-based frame
.text$mn:00007464
.text$mn:00007464 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00007464                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00007464 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007464                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00007464
.text$mn:00007464 var_10          = byte ptr -10h
.text$mn:00007464 var_8           = dword ptr -8
.text$mn:00007464 var_1           = byte ptr -1
.text$mn:00007464
.text$mn:00007464                 push    ebp
.text$mn:00007465                 mov     ebp, esp
.text$mn:00007467                 sub     esp, 10h
.text$mn:0000746A                 mov     [ebp+var_8], ecx
.text$mn:0000746D                 lea     ecx, [ebp+var_1]
.text$mn:00007470                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00007475                 push    1
.text$mn:00007477                 lea     ecx, [ebp+var_1]
.text$mn:0000747A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000747F                 mov     ecx, [ebp+var_8]
.text$mn:00007482                 mov     [ecx], eax
.text$mn:00007484                 lea     ecx, [ebp+var_10] ; this
.text$mn:00007487                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000748C                 push    eax             ; int
.text$mn:0000748D                 mov     edx, [ebp+var_8]
.text$mn:00007490                 mov     eax, [edx]
.text$mn:00007492                 push    eax             ; void *
.text$mn:00007493                 lea     ecx, [ebp+var_1]
.text$mn:00007496                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000749B                 mov     ecx, [ebp+var_8]
.text$mn:0000749E                 mov     edx, [ecx]
.text$mn:000074A0                 mov     eax, [ebp+var_8]
.text$mn:000074A3                 mov     [edx], eax
.text$mn:000074A5                 mov     esp, ebp
.text$mn:000074A7                 pop     ebp
.text$mn:000074A8                 retn
.text$mn:000074A8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000074A8
.text$mn:000074A8 ; ---------------------------------------------------------------------------
.text$mn:000074A9                 align 4
.text$mn:000074A9 _text$mn        ends
.text$mn:000074A9
.text$mn:000074AC ; ===========================================================================
.text$mn:000074AC
.text$mn:000074AC ; Segment type: Pure code
.text$mn:000074AC ; Segment permissions: Read/Execute
.text$mn:000074AC _text$mn        segment para public 'CODE' use32
.text$mn:000074AC                 assume cs:_text$mn
.text$mn:000074AC                 ;org 74ACh
.text$mn:000074AC ; COMDAT (pick any)
.text$mn:000074AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074AC
.text$mn:000074AC ; =============== S U B R O U T I N E =======================================
.text$mn:000074AC
.text$mn:000074AC ; Attributes: bp-based frame
.text$mn:000074AC
.text$mn:000074AC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000074AC                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000074AC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000074AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:000074AC
.text$mn:000074AC var_10          = byte ptr -10h
.text$mn:000074AC var_8           = dword ptr -8
.text$mn:000074AC var_1           = byte ptr -1
.text$mn:000074AC
.text$mn:000074AC                 push    ebp
.text$mn:000074AD                 mov     ebp, esp
.text$mn:000074AF                 sub     esp, 10h
.text$mn:000074B2                 mov     [ebp+var_8], ecx
.text$mn:000074B5                 lea     ecx, [ebp+var_1]
.text$mn:000074B8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000074BD                 push    1
.text$mn:000074BF                 lea     ecx, [ebp+var_1]
.text$mn:000074C2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000074C7                 mov     ecx, [ebp+var_8]
.text$mn:000074CA                 mov     [ecx], eax
.text$mn:000074CC                 lea     ecx, [ebp+var_10] ; this
.text$mn:000074CF                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000074D4                 push    eax             ; int
.text$mn:000074D5                 mov     edx, [ebp+var_8]
.text$mn:000074D8                 mov     eax, [edx]
.text$mn:000074DA                 push    eax             ; void *
.text$mn:000074DB                 lea     ecx, [ebp+var_1]
.text$mn:000074DE                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000074E3                 mov     ecx, [ebp+var_8]
.text$mn:000074E6                 mov     edx, [ecx]
.text$mn:000074E8                 mov     eax, [ebp+var_8]
.text$mn:000074EB                 mov     [edx], eax
.text$mn:000074ED                 mov     esp, ebp
.text$mn:000074EF                 pop     ebp
.text$mn:000074F0                 retn
.text$mn:000074F0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000074F0
.text$mn:000074F0 ; ---------------------------------------------------------------------------
.text$mn:000074F1                 align 4
.text$mn:000074F1 _text$mn        ends
.text$mn:000074F1
.text$mn:000074F4 ; ===========================================================================
.text$mn:000074F4
.text$mn:000074F4 ; Segment type: Pure code
.text$mn:000074F4 ; Segment permissions: Read/Execute
.text$mn:000074F4 _text$mn        segment para public 'CODE' use32
.text$mn:000074F4                 assume cs:_text$mn
.text$mn:000074F4                 ;org 74F4h
.text$mn:000074F4 ; COMDAT (pick any)
.text$mn:000074F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074F4
.text$mn:000074F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000074F4
.text$mn:000074F4 ; Attributes: bp-based frame
.text$mn:000074F4
.text$mn:000074F4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Alloc_proxy(void)
.text$mn:000074F4                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
.text$mn:000074F4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000074F4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(std::allocator<int> const &)+38p
.text$mn:000074F4
.text$mn:000074F4 var_10          = byte ptr -10h
.text$mn:000074F4 var_8           = dword ptr -8
.text$mn:000074F4 var_1           = byte ptr -1
.text$mn:000074F4
.text$mn:000074F4                 push    ebp
.text$mn:000074F5                 mov     ebp, esp
.text$mn:000074F7                 sub     esp, 10h
.text$mn:000074FA                 mov     [ebp+var_8], ecx
.text$mn:000074FD                 lea     ecx, [ebp+var_1]
.text$mn:00007500                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00007505                 push    1
.text$mn:00007507                 lea     ecx, [ebp+var_1]
.text$mn:0000750A                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000750F                 mov     ecx, [ebp+var_8]
.text$mn:00007512                 mov     [ecx], eax
.text$mn:00007514                 lea     ecx, [ebp+var_10] ; this
.text$mn:00007517                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000751C                 push    eax             ; int
.text$mn:0000751D                 mov     edx, [ebp+var_8]
.text$mn:00007520                 mov     eax, [edx]
.text$mn:00007522                 push    eax             ; void *
.text$mn:00007523                 lea     ecx, [ebp+var_1]
.text$mn:00007526                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000752B                 mov     ecx, [ebp+var_8]
.text$mn:0000752E                 mov     edx, [ecx]
.text$mn:00007530                 mov     eax, [ebp+var_8]
.text$mn:00007533                 mov     [edx], eax
.text$mn:00007535                 mov     esp, ebp
.text$mn:00007537                 pop     ebp
.text$mn:00007538                 retn
.text$mn:00007538 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007538
.text$mn:00007538 ; ---------------------------------------------------------------------------
.text$mn:00007539                 align 4
.text$mn:00007539 _text$mn        ends
.text$mn:00007539
.text$mn:0000753C ; ===========================================================================
.text$mn:0000753C
.text$mn:0000753C ; Segment type: Pure code
.text$mn:0000753C ; Segment permissions: Read/Execute
.text$mn:0000753C _text$mn        segment para public 'CODE' use32
.text$mn:0000753C                 assume cs:_text$mn
.text$mn:0000753C                 ;org 753Ch
.text$mn:0000753C ; COMDAT (pick any)
.text$mn:0000753C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000753C
.text$mn:0000753C ; =============== S U B R O U T I N E =======================================
.text$mn:0000753C
.text$mn:0000753C ; Attributes: bp-based frame
.text$mn:0000753C
.text$mn:0000753C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Chassign(unsigned int, unsigned int, wchar_t)
.text$mn:0000753C                 public ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z
.text$mn:0000753C ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z proc near
.text$mn:0000753C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(uint,wchar_t)+3Dp
.text$mn:0000753C
.text$mn:0000753C var_4           = dword ptr -4
.text$mn:0000753C arg_0           = dword ptr  8
.text$mn:0000753C arg_4           = dword ptr  0Ch
.text$mn:0000753C arg_8           = word ptr  10h
.text$mn:0000753C
.text$mn:0000753C                 push    ebp
.text$mn:0000753D                 mov     ebp, esp
.text$mn:0000753F                 push    ecx
.text$mn:00007540                 mov     [ebp+var_4], ecx
.text$mn:00007543                 cmp     [ebp+arg_4], 1
.text$mn:00007547                 jnz     short loc_7566
.text$mn:00007549                 lea     eax, [ebp+arg_8]
.text$mn:0000754C                 push    eax
.text$mn:0000754D                 mov     ecx, [ebp+var_4]
.text$mn:00007550                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007555                 mov     ecx, [ebp+arg_0]
.text$mn:00007558                 lea     edx, [eax+ecx*2]
.text$mn:0000755B                 push    edx
.text$mn:0000755C                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00007561                 add     esp, 8
.text$mn:00007564                 jmp     short loc_7586
.text$mn:00007566 ; ---------------------------------------------------------------------------
.text$mn:00007566
.text$mn:00007566 loc_7566:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+Bj
.text$mn:00007566                 movzx   eax, [ebp+arg_8]
.text$mn:0000756A                 push    eax
.text$mn:0000756B                 mov     ecx, [ebp+arg_4]
.text$mn:0000756E                 push    ecx
.text$mn:0000756F                 mov     ecx, [ebp+var_4]
.text$mn:00007572                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007577                 mov     edx, [ebp+arg_0]
.text$mn:0000757A                 lea     eax, [eax+edx*2]
.text$mn:0000757D                 push    eax
.text$mn:0000757E                 call    ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z ; std::char_traits<wchar_t>::assign(wchar_t *,uint,wchar_t)
.text$mn:00007583                 add     esp, 0Ch
.text$mn:00007586
.text$mn:00007586 loc_7586:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+28j
.text$mn:00007586                 mov     esp, ebp
.text$mn:00007588                 pop     ebp
.text$mn:00007589                 retn    0Ch
.text$mn:00007589 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z endp
.text$mn:00007589
.text$mn:00007589 _text$mn        ends
.text$mn:00007589
.text$mn:0000758C ; ===========================================================================
.text$mn:0000758C
.text$mn:0000758C ; Segment type: Pure code
.text$mn:0000758C ; Segment permissions: Read/Execute
.text$mn:0000758C _text$mn        segment para public 'CODE' use32
.text$mn:0000758C                 assume cs:_text$mn
.text$mn:0000758C                 ;org 758Ch
.text$mn:0000758C ; COMDAT (pick any)
.text$mn:0000758C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000758C
.text$mn:0000758C ; =============== S U B R O U T I N E =======================================
.text$mn:0000758C
.text$mn:0000758C ; Attributes: bp-based frame
.text$mn:0000758C
.text$mn:0000758C ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:0000758C                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:0000758C ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000758C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+80p
.text$mn:0000758C
.text$mn:0000758C var_4           = dword ptr -4
.text$mn:0000758C
.text$mn:0000758C                 push    ebp
.text$mn:0000758D                 mov     ebp, esp
.text$mn:0000758F                 push    ecx
.text$mn:00007590                 mov     [ebp+var_4], ecx
.text$mn:00007593                 mov     eax, [ebp+var_4]
.text$mn:00007596                 mov     dword ptr [eax], 0
.text$mn:0000759C                 mov     esp, ebp
.text$mn:0000759E                 pop     ebp
.text$mn:0000759F                 retn
.text$mn:0000759F ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000759F
.text$mn:0000759F _text$mn        ends
.text$mn:0000759F
.text$mn:000075A0 ; ===========================================================================
.text$mn:000075A0
.text$mn:000075A0 ; Segment type: Pure code
.text$mn:000075A0 ; Segment permissions: Read/Execute
.text$mn:000075A0 _text$mn        segment para public 'CODE' use32
.text$mn:000075A0                 assume cs:_text$mn
.text$mn:000075A0                 ;org 75A0h
.text$mn:000075A0 ; COMDAT (pick any)
.text$mn:000075A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075A0
.text$mn:000075A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000075A0
.text$mn:000075A0 ; Attributes: bp-based frame
.text$mn:000075A0
.text$mn:000075A0 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Iterator_base12 *)
.text$mn:000075A0                 public ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:000075A0 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:000075A0                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+10p
.text$mn:000075A0                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+Ep ...
.text$mn:000075A0
.text$mn:000075A0 var_4           = dword ptr -4
.text$mn:000075A0 arg_0           = dword ptr  8
.text$mn:000075A0
.text$mn:000075A0                 push    ebp
.text$mn:000075A1                 mov     ebp, esp
.text$mn:000075A3                 push    ecx
.text$mn:000075A4                 push    esi
.text$mn:000075A5                 mov     [ebp+var_4], ecx
.text$mn:000075A8                 mov     ecx, [ebp+var_4] ; this
.text$mn:000075AB                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000075B0                 test    eax, eax
.text$mn:000075B2                 jz      short loc_75CA
.text$mn:000075B4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000075B7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000075BC                 mov     esi, eax
.text$mn:000075BE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000075C1                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000075C6                 cmp     esi, eax
.text$mn:000075C8                 jz      short loc_7632
.text$mn:000075CA
.text$mn:000075CA loc_75CA:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+12j
.text$mn:000075CA                 push    0F0h ; '='      ; unsigned int
.text$mn:000075CF                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000075D4                 push    offset ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "vector iterators incompatible"
.text$mn:000075D9                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000075DE                 add     esp, 0Ch
.text$mn:000075E1                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:000075E6                 test    eax, eax
.text$mn:000075E8                 jz      short loc_75EE
.text$mn:000075EA                 xor     ecx, ecx
.text$mn:000075EC                 jnz     short loc_7614
.text$mn:000075EE
.text$mn:000075EE loc_75EE:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+48j
.text$mn:000075EE                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:000075F3                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000075F8                 push    0
.text$mn:000075FA                 push    0F1h ; '±'
.text$mn:000075FF                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007604                 push    2
.text$mn:00007606                 call    __CrtDbgReportW
.text$mn:0000760B                 add     esp, 18h
.text$mn:0000760E                 cmp     eax, 1
.text$mn:00007611                 jnz     short loc_7614
.text$mn:00007613                 int     3               ; Trap to Debugger
.text$mn:00007614
.text$mn:00007614 loc_7614:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+4Cj
.text$mn:00007614                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+71j
.text$mn:00007614                 push    0
.text$mn:00007616                 push    0F1h ; '±'
.text$mn:0000761B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007620                 push    offset ??_C@_1OC@LDKFIGAP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00007625                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:0000762A                 call    __invalid_parameter
.text$mn:0000762F                 add     esp, 14h
.text$mn:00007632
.text$mn:00007632 loc_7632:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+28j
.text$mn:00007632                 pop     esi
.text$mn:00007633                 mov     esp, ebp
.text$mn:00007635                 pop     ebp
.text$mn:00007636                 retn    4
.text$mn:00007636 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00007636
.text$mn:00007636 ; ---------------------------------------------------------------------------
.text$mn:00007639                 align 4
.text$mn:00007639 _text$mn        ends
.text$mn:00007639
.text$mn:0000763C ; ===========================================================================
.text$mn:0000763C
.text$mn:0000763C ; Segment type: Pure code
.text$mn:0000763C ; Segment permissions: Read/Execute
.text$mn:0000763C _text$mn        segment para public 'CODE' use32
.text$mn:0000763C                 assume cs:_text$mn
.text$mn:0000763C                 ;org 763Ch
.text$mn:0000763C ; COMDAT (pick any)
.text$mn:0000763C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000763C
.text$mn:0000763C ; =============== S U B R O U T I N E =======================================
.text$mn:0000763C
.text$mn:0000763C ; Attributes: bp-based frame
.text$mn:0000763C
.text$mn:0000763C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:0000763C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000763C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:0000763C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:0000763C
.text$mn:0000763C var_20          = dword ptr -20h
.text$mn:0000763C var_1C          = dword ptr -1Ch
.text$mn:0000763C var_18          = dword ptr -18h
.text$mn:0000763C var_11          = byte ptr -11h
.text$mn:0000763C var_10          = dword ptr -10h
.text$mn:0000763C var_C           = byte ptr -0Ch
.text$mn:0000763C var_4           = dword ptr -4
.text$mn:0000763C arg_0           = dword ptr  8
.text$mn:0000763C
.text$mn:0000763C ; FUNCTION CHUNK AT .text$mn:0000775E SIZE 00000009 BYTES
.text$mn:0000763C
.text$mn:0000763C                 push    ebp
.text$mn:0000763D                 mov     ebp, esp
.text$mn:0000763F                 push    0FFFFFFFFh
.text$mn:00007641                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007646                 mov     eax, large fs:0
.text$mn:0000764C                 push    eax
.text$mn:0000764D                 push    ecx
.text$mn:0000764E                 sub     esp, 10h
.text$mn:00007651                 push    ebx
.text$mn:00007652                 push    esi
.text$mn:00007653                 push    edi
.text$mn:00007654                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007659                 xor     eax, ebp
.text$mn:0000765B                 push    eax
.text$mn:0000765C                 lea     eax, [ebp+var_C]
.text$mn:0000765F                 mov     large fs:0, eax
.text$mn:00007665                 mov     [ebp+var_10], esp
.text$mn:00007668                 mov     [ebp+var_18], ecx
.text$mn:0000766B                 mov     eax, [ebp+arg_0]
.text$mn:0000766E                 or      eax, 0Fh
.text$mn:00007671                 mov     [ebp+var_1C], eax
.text$mn:00007674                 mov     ecx, [ebp+var_18]
.text$mn:00007677                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000767C                 cmp     eax, [ebp+var_1C]
.text$mn:0000767F                 jnb     short loc_7689
.text$mn:00007681                 mov     ecx, [ebp+arg_0]
.text$mn:00007684                 mov     [ebp+var_1C], ecx
.text$mn:00007687                 jmp     short loc_76DB
.text$mn:00007689 ; ---------------------------------------------------------------------------
.text$mn:00007689
.text$mn:00007689 loc_7689:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00007689                 mov     edx, [ebp+var_18]
.text$mn:0000768C                 mov     ecx, [edx+18h]
.text$mn:0000768F                 shr     ecx, 1
.text$mn:00007691                 mov     eax, [ebp+var_1C]
.text$mn:00007694                 xor     edx, edx
.text$mn:00007696                 mov     esi, 3
.text$mn:0000769B                 div     esi
.text$mn:0000769D                 cmp     ecx, eax
.text$mn:0000769F                 ja      short loc_76A3
.text$mn:000076A1                 jmp     short loc_76DB
.text$mn:000076A3 ; ---------------------------------------------------------------------------
.text$mn:000076A3
.text$mn:000076A3 loc_76A3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000076A3                 mov     ecx, [ebp+var_18]
.text$mn:000076A6                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000076AB                 mov     edx, [ebp+var_18]
.text$mn:000076AE                 mov     ecx, [edx+18h]
.text$mn:000076B1                 shr     ecx, 1
.text$mn:000076B3                 sub     eax, ecx
.text$mn:000076B5                 mov     edx, [ebp+var_18]
.text$mn:000076B8                 cmp     [edx+18h], eax
.text$mn:000076BB                 ja      short loc_76D0
.text$mn:000076BD                 mov     eax, [ebp+var_18]
.text$mn:000076C0                 mov     ecx, [eax+18h]
.text$mn:000076C3                 shr     ecx, 1
.text$mn:000076C5                 mov     edx, [ebp+var_18]
.text$mn:000076C8                 add     ecx, [edx+18h]
.text$mn:000076CB                 mov     [ebp+var_1C], ecx
.text$mn:000076CE                 jmp     short loc_76DB
.text$mn:000076D0 ; ---------------------------------------------------------------------------
.text$mn:000076D0
.text$mn:000076D0 loc_76D0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000076D0                 mov     ecx, [ebp+var_18]
.text$mn:000076D3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000076D8                 mov     [ebp+var_1C], eax
.text$mn:000076DB
.text$mn:000076DB loc_76DB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000076DB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000076DB                 mov     [ebp+var_4], 0
.text$mn:000076E2                 mov     eax, [ebp+var_1C]
.text$mn:000076E5                 add     eax, 1
.text$mn:000076E8                 push    eax
.text$mn:000076E9                 lea     ecx, [ebp+var_11]
.text$mn:000076EC                 push    ecx
.text$mn:000076ED                 mov     ecx, [ebp+var_18]
.text$mn:000076F0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000076F5                 mov     ecx, eax
.text$mn:000076F7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000076FC                 mov     [ebp+var_20], eax
.text$mn:000076FF                 jmp     short loc_775E
.text$mn:000076FF ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000076FF
.text$mn:00007701
.text$mn:00007701 ; =============== S U B R O U T I N E =======================================
.text$mn:00007701
.text$mn:00007701
.text$mn:00007701 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00007701                                         ; DATA XREF: .xdata$x:0000A018o
.text$mn:00007701
.text$mn:00007701 ; FUNCTION CHUNK AT .text$mn:00007748 SIZE 00000009 BYTES
.text$mn:00007701 ; FUNCTION CHUNK AT .text$mn:00007758 SIZE 00000006 BYTES
.text$mn:00007701
.text$mn:00007701                 mov     [ebp-10h], esp
.text$mn:00007704                 mov     edx, [ebp+8]
.text$mn:00007707                 mov     [ebp-1Ch], edx
.text$mn:0000770A                 mov     byte ptr [ebp-4], 2
.text$mn:0000770E                 mov     eax, [ebp-1Ch]
.text$mn:00007711                 add     eax, 1
.text$mn:00007714                 push    eax
.text$mn:00007715                 lea     ecx, [ebp-12h]
.text$mn:00007718                 push    ecx
.text$mn:00007719                 mov     ecx, [ebp-18h]
.text$mn:0000771C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007721                 mov     ecx, eax
.text$mn:00007723                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00007728                 mov     [ebp-20h], eax
.text$mn:0000772B                 jmp     short loc_7748
.text$mn:0000772B __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000772B
.text$mn:0000772D
.text$mn:0000772D ; =============== S U B R O U T I N E =======================================
.text$mn:0000772D
.text$mn:0000772D ; Attributes: noreturn
.text$mn:0000772D
.text$mn:0000772D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:0000772D                                         ; DATA XREF: .xdata$x:0000A028o
.text$mn:0000772D                 push    0               ; Size
.text$mn:0000772F                 push    1               ; char
.text$mn:00007731                 mov     ecx, [ebp-18h]
.text$mn:00007734                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00007739                 push    0
.text$mn:0000773B                 push    0
.text$mn:0000773D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000773D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:0000773D
.text$mn:00007742 ; ---------------------------------------------------------------------------
.text$mn:00007742                 mov     eax, offset $LN17
.text$mn:00007747                 retn
.text$mn:00007748 ; ---------------------------------------------------------------------------
.text$mn:00007748 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007748
.text$mn:00007748 loc_7748:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00007748                 mov     dword ptr [ebp-4], 1
.text$mn:0000774F                 jmp     short loc_7758
.text$mn:0000774F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007751
.text$mn:00007751 ; =============== S U B R O U T I N E =======================================
.text$mn:00007751
.text$mn:00007751
.text$mn:00007751 $LN17           proc near               ; DATA XREF: .text$mn:00007742o
.text$mn:00007751                 mov     dword ptr [ebp-4], 1
.text$mn:00007751 $LN17           endp ; sp-analysis failed
.text$mn:00007751
.text$mn:00007758 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007758
.text$mn:00007758 loc_7758:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00007758                 mov     eax, offset $LN19
.text$mn:0000775D                 retn
.text$mn:0000775D ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000775E ; ---------------------------------------------------------------------------
.text$mn:0000775E ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000775E
.text$mn:0000775E loc_775E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000775E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007765                 jmp     short loc_776E
.text$mn:00007765 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007767
.text$mn:00007767 ; =============== S U B R O U T I N E =======================================
.text$mn:00007767
.text$mn:00007767
.text$mn:00007767 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_7758o
.text$mn:00007767                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000776E
.text$mn:0000776E loc_776E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000776E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00007772                 jbe     short loc_778D
.text$mn:00007774                 mov     edx, [ebp+0Ch]
.text$mn:00007777                 push    edx             ; Size
.text$mn:00007778                 mov     ecx, [ebp-18h]
.text$mn:0000777B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007780                 push    eax             ; Src
.text$mn:00007781                 mov     eax, [ebp-20h]
.text$mn:00007784                 push    eax             ; Dst
.text$mn:00007785                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000778A                 add     esp, 0Ch
.text$mn:0000778D
.text$mn:0000778D loc_778D:                               ; CODE XREF: $LN19+Bj
.text$mn:0000778D                 push    0               ; Size
.text$mn:0000778F                 push    1               ; char
.text$mn:00007791                 mov     ecx, [ebp-18h]
.text$mn:00007794                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00007799                 lea     ecx, [ebp-20h]
.text$mn:0000779C                 push    ecx             ; int
.text$mn:0000779D                 mov     edx, [ebp-18h]
.text$mn:000077A0                 add     edx, 4
.text$mn:000077A3                 push    edx             ; void *
.text$mn:000077A4                 lea     eax, [ebp-13h]
.text$mn:000077A7                 push    eax
.text$mn:000077A8                 mov     ecx, [ebp-18h]
.text$mn:000077AB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000077B0                 mov     ecx, eax
.text$mn:000077B2                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000077B7                 mov     ecx, [ebp-18h]
.text$mn:000077BA                 mov     edx, [ebp-1Ch]
.text$mn:000077BD                 mov     [ecx+18h], edx
.text$mn:000077C0                 mov     eax, [ebp+0Ch]
.text$mn:000077C3                 push    eax
.text$mn:000077C4                 mov     ecx, [ebp-18h]
.text$mn:000077C7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000077CC                 mov     ecx, [ebp-0Ch]
.text$mn:000077CF                 mov     large fs:0, ecx
.text$mn:000077D6                 pop     ecx
.text$mn:000077D7                 pop     edi
.text$mn:000077D8                 pop     esi
.text$mn:000077D9                 pop     ebx
.text$mn:000077DA                 mov     esp, ebp
.text$mn:000077DC                 pop     ebp
.text$mn:000077DD                 retn    8
.text$mn:000077DD $LN19           endp ; sp-analysis failed
.text$mn:000077DD
.text$mn:000077DD _text$mn        ends
.text$mn:000077DD
.text$x:000077E0 ; ===========================================================================
.text$x:000077E0
.text$x:000077E0 ; Segment type: Pure code
.text$x:000077E0 ; Segment permissions: Read/Execute
.text$x:000077E0 _text$x         segment para public 'CODE' use32
.text$x:000077E0                 assume cs:_text$x
.text$x:000077E0                 ;org 77E0h
.text$x:000077E0 ; COMDAT (pick associative to section at 763C)
.text$x:000077E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000077E0
.text$x:000077E0 ; =============== S U B R O U T I N E =======================================
.text$x:000077E0
.text$x:000077E0
.text$x:000077E0 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000077E0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000077E0
.text$x:000077E0 arg_4           = dword ptr  8
.text$x:000077E0
.text$x:000077E0                 mov     edx, [esp+arg_4]
.text$x:000077E4                 lea     eax, [edx+0Ch]
.text$x:000077E7                 mov     ecx, [edx-24h]
.text$x:000077EA                 xor     ecx, eax
.text$x:000077EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000077F1                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000077F6                 jmp     ___CxxFrameHandler3
.text$x:000077F6 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000077F6
.text$x:000077F6 ; ---------------------------------------------------------------------------
.text$x:000077FB                 align 4
.text$x:000077FB _text$x         ends
.text$x:000077FB
.text$mn:000077FC ; ===========================================================================
.text$mn:000077FC
.text$mn:000077FC ; Segment type: Pure code
.text$mn:000077FC ; Segment permissions: Read/Execute
.text$mn:000077FC _text$mn        segment para public 'CODE' use32
.text$mn:000077FC                 assume cs:_text$mn
.text$mn:000077FC                 ;org 77FCh
.text$mn:000077FC ; COMDAT (pick any)
.text$mn:000077FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077FC
.text$mn:000077FC ; =============== S U B R O U T I N E =======================================
.text$mn:000077FC
.text$mn:000077FC ; Attributes: bp-based frame
.text$mn:000077FC
.text$mn:000077FC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:000077FC                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000077FC ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:000077FC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:000077FC
.text$mn:000077FC var_20          = dword ptr -20h
.text$mn:000077FC var_1C          = dword ptr -1Ch
.text$mn:000077FC var_18          = dword ptr -18h
.text$mn:000077FC var_11          = byte ptr -11h
.text$mn:000077FC var_10          = dword ptr -10h
.text$mn:000077FC var_C           = byte ptr -0Ch
.text$mn:000077FC var_4           = dword ptr -4
.text$mn:000077FC arg_0           = dword ptr  8
.text$mn:000077FC
.text$mn:000077FC ; FUNCTION CHUNK AT .text$mn:0000791E SIZE 00000009 BYTES
.text$mn:000077FC
.text$mn:000077FC                 push    ebp
.text$mn:000077FD                 mov     ebp, esp
.text$mn:000077FF                 push    0FFFFFFFFh
.text$mn:00007801                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007806                 mov     eax, large fs:0
.text$mn:0000780C                 push    eax
.text$mn:0000780D                 push    ecx
.text$mn:0000780E                 sub     esp, 10h
.text$mn:00007811                 push    ebx
.text$mn:00007812                 push    esi
.text$mn:00007813                 push    edi
.text$mn:00007814                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007819                 xor     eax, ebp
.text$mn:0000781B                 push    eax
.text$mn:0000781C                 lea     eax, [ebp+var_C]
.text$mn:0000781F                 mov     large fs:0, eax
.text$mn:00007825                 mov     [ebp+var_10], esp
.text$mn:00007828                 mov     [ebp+var_18], ecx
.text$mn:0000782B                 mov     eax, [ebp+arg_0]
.text$mn:0000782E                 or      eax, 7
.text$mn:00007831                 mov     [ebp+var_1C], eax
.text$mn:00007834                 mov     ecx, [ebp+var_18]
.text$mn:00007837                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000783C                 cmp     eax, [ebp+var_1C]
.text$mn:0000783F                 jnb     short loc_7849
.text$mn:00007841                 mov     ecx, [ebp+arg_0]
.text$mn:00007844                 mov     [ebp+var_1C], ecx
.text$mn:00007847                 jmp     short loc_789B
.text$mn:00007849 ; ---------------------------------------------------------------------------
.text$mn:00007849
.text$mn:00007849 loc_7849:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00007849                 mov     edx, [ebp+var_18]
.text$mn:0000784C                 mov     ecx, [edx+18h]
.text$mn:0000784F                 shr     ecx, 1
.text$mn:00007851                 mov     eax, [ebp+var_1C]
.text$mn:00007854                 xor     edx, edx
.text$mn:00007856                 mov     esi, 3
.text$mn:0000785B                 div     esi
.text$mn:0000785D                 cmp     ecx, eax
.text$mn:0000785F                 ja      short loc_7863
.text$mn:00007861                 jmp     short loc_789B
.text$mn:00007863 ; ---------------------------------------------------------------------------
.text$mn:00007863
.text$mn:00007863 loc_7863:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00007863                 mov     ecx, [ebp+var_18]
.text$mn:00007866                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000786B                 mov     edx, [ebp+var_18]
.text$mn:0000786E                 mov     ecx, [edx+18h]
.text$mn:00007871                 shr     ecx, 1
.text$mn:00007873                 sub     eax, ecx
.text$mn:00007875                 mov     edx, [ebp+var_18]
.text$mn:00007878                 cmp     [edx+18h], eax
.text$mn:0000787B                 ja      short loc_7890
.text$mn:0000787D                 mov     eax, [ebp+var_18]
.text$mn:00007880                 mov     ecx, [eax+18h]
.text$mn:00007883                 shr     ecx, 1
.text$mn:00007885                 mov     edx, [ebp+var_18]
.text$mn:00007888                 add     ecx, [edx+18h]
.text$mn:0000788B                 mov     [ebp+var_1C], ecx
.text$mn:0000788E                 jmp     short loc_789B
.text$mn:00007890 ; ---------------------------------------------------------------------------
.text$mn:00007890
.text$mn:00007890 loc_7890:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00007890                 mov     ecx, [ebp+var_18]
.text$mn:00007893                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007898                 mov     [ebp+var_1C], eax
.text$mn:0000789B
.text$mn:0000789B loc_789B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:0000789B                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:0000789B                 mov     [ebp+var_4], 0
.text$mn:000078A2                 mov     eax, [ebp+var_1C]
.text$mn:000078A5                 add     eax, 1
.text$mn:000078A8                 push    eax
.text$mn:000078A9                 lea     ecx, [ebp+var_11]
.text$mn:000078AC                 push    ecx
.text$mn:000078AD                 mov     ecx, [ebp+var_18]
.text$mn:000078B0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000078B5                 mov     ecx, eax
.text$mn:000078B7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000078BC                 mov     [ebp+var_20], eax
.text$mn:000078BF                 jmp     short loc_791E
.text$mn:000078BF ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:000078BF
.text$mn:000078C1
.text$mn:000078C1 ; =============== S U B R O U T I N E =======================================
.text$mn:000078C1
.text$mn:000078C1
.text$mn:000078C1 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:000078C1                                         ; DATA XREF: .xdata$x:0000A48Co
.text$mn:000078C1
.text$mn:000078C1 ; FUNCTION CHUNK AT .text$mn:00007908 SIZE 00000009 BYTES
.text$mn:000078C1 ; FUNCTION CHUNK AT .text$mn:00007918 SIZE 00000006 BYTES
.text$mn:000078C1
.text$mn:000078C1                 mov     [ebp-10h], esp
.text$mn:000078C4                 mov     edx, [ebp+8]
.text$mn:000078C7                 mov     [ebp-1Ch], edx
.text$mn:000078CA                 mov     byte ptr [ebp-4], 2
.text$mn:000078CE                 mov     eax, [ebp-1Ch]
.text$mn:000078D1                 add     eax, 1
.text$mn:000078D4                 push    eax
.text$mn:000078D5                 lea     ecx, [ebp-12h]
.text$mn:000078D8                 push    ecx
.text$mn:000078D9                 mov     ecx, [ebp-18h]
.text$mn:000078DC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000078E1                 mov     ecx, eax
.text$mn:000078E3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000078E8                 mov     [ebp-20h], eax
.text$mn:000078EB                 jmp     short loc_7908
.text$mn:000078EB __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:000078EB
.text$mn:000078ED
.text$mn:000078ED ; =============== S U B R O U T I N E =======================================
.text$mn:000078ED
.text$mn:000078ED ; Attributes: noreturn
.text$mn:000078ED
.text$mn:000078ED __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:000078ED                                         ; DATA XREF: .xdata$x:0000A49Co
.text$mn:000078ED                 push    0
.text$mn:000078EF                 push    1
.text$mn:000078F1                 mov     ecx, [ebp-18h]
.text$mn:000078F4                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000078F9                 push    0
.text$mn:000078FB                 push    0
.text$mn:000078FD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000078FD __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:000078FD
.text$mn:00007902 ; ---------------------------------------------------------------------------
.text$mn:00007902                 mov     eax, offset $LN17_0
.text$mn:00007907                 retn
.text$mn:00007908 ; ---------------------------------------------------------------------------
.text$mn:00007908 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00007908
.text$mn:00007908 loc_7908:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00007908                 mov     dword ptr [ebp-4], 1
.text$mn:0000790F                 jmp     short loc_7918
.text$mn:0000790F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00007911
.text$mn:00007911 ; =============== S U B R O U T I N E =======================================
.text$mn:00007911
.text$mn:00007911
.text$mn:00007911 $LN17_0         proc near               ; DATA XREF: .text$mn:00007902o
.text$mn:00007911                 mov     dword ptr [ebp-4], 1
.text$mn:00007911 $LN17_0         endp ; sp-analysis failed
.text$mn:00007911
.text$mn:00007918 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00007918
.text$mn:00007918 loc_7918:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00007918                 mov     eax, offset $LN19_0
.text$mn:0000791D                 retn
.text$mn:0000791D ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000791E ; ---------------------------------------------------------------------------
.text$mn:0000791E ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000791E
.text$mn:0000791E loc_791E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:0000791E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007925                 jmp     short loc_792E
.text$mn:00007925 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007927
.text$mn:00007927 ; =============== S U B R O U T I N E =======================================
.text$mn:00007927
.text$mn:00007927
.text$mn:00007927 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_7918o
.text$mn:00007927                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000792E
.text$mn:0000792E loc_792E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:0000792E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00007932                 jbe     short loc_794D
.text$mn:00007934                 mov     edx, [ebp+0Ch]
.text$mn:00007937                 push    edx             ; int
.text$mn:00007938                 mov     ecx, [ebp-18h]
.text$mn:0000793B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007940                 push    eax             ; Src
.text$mn:00007941                 mov     eax, [ebp-20h]
.text$mn:00007944                 push    eax             ; Dst
.text$mn:00007945                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000794A                 add     esp, 0Ch
.text$mn:0000794D
.text$mn:0000794D loc_794D:                               ; CODE XREF: $LN19_0+Bj
.text$mn:0000794D                 push    0
.text$mn:0000794F                 push    1
.text$mn:00007951                 mov     ecx, [ebp-18h]
.text$mn:00007954                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007959                 lea     ecx, [ebp-20h]
.text$mn:0000795C                 push    ecx             ; int
.text$mn:0000795D                 mov     edx, [ebp-18h]
.text$mn:00007960                 add     edx, 4
.text$mn:00007963                 push    edx             ; void *
.text$mn:00007964                 lea     eax, [ebp-13h]
.text$mn:00007967                 push    eax
.text$mn:00007968                 mov     ecx, [ebp-18h]
.text$mn:0000796B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007970                 mov     ecx, eax
.text$mn:00007972                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00007977                 mov     ecx, [ebp-18h]
.text$mn:0000797A                 mov     edx, [ebp-1Ch]
.text$mn:0000797D                 mov     [ecx+18h], edx
.text$mn:00007980                 mov     eax, [ebp+0Ch]
.text$mn:00007983                 push    eax
.text$mn:00007984                 mov     ecx, [ebp-18h]
.text$mn:00007987                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000798C                 mov     ecx, [ebp-0Ch]
.text$mn:0000798F                 mov     large fs:0, ecx
.text$mn:00007996                 pop     ecx
.text$mn:00007997                 pop     edi
.text$mn:00007998                 pop     esi
.text$mn:00007999                 pop     ebx
.text$mn:0000799A                 mov     esp, ebp
.text$mn:0000799C                 pop     ebp
.text$mn:0000799D                 retn    8
.text$mn:0000799D $LN19_0         endp ; sp-analysis failed
.text$mn:0000799D
.text$mn:0000799D _text$mn        ends
.text$mn:0000799D
.text$x:000079A0 ; ===========================================================================
.text$x:000079A0
.text$x:000079A0 ; Segment type: Pure code
.text$x:000079A0 ; Segment permissions: Read/Execute
.text$x:000079A0 _text$x         segment para public 'CODE' use32
.text$x:000079A0                 assume cs:_text$x
.text$x:000079A0                 ;org 79A0h
.text$x:000079A0 ; COMDAT (pick associative to section at 77FC)
.text$x:000079A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000079A0
.text$x:000079A0 ; =============== S U B R O U T I N E =======================================
.text$x:000079A0
.text$x:000079A0
.text$x:000079A0 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:000079A0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:000079A0
.text$x:000079A0 arg_4           = dword ptr  8
.text$x:000079A0
.text$x:000079A0                 mov     edx, [esp+arg_4]
.text$x:000079A4                 lea     eax, [edx+0Ch]
.text$x:000079A7                 mov     ecx, [edx-24h]
.text$x:000079AA                 xor     ecx, eax
.text$x:000079AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000079B1                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:000079B6                 jmp     ___CxxFrameHandler3
.text$x:000079B6 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:000079B6
.text$x:000079B6 ; ---------------------------------------------------------------------------
.text$x:000079BB                 align 4
.text$x:000079BB _text$x         ends
.text$x:000079BB
.text$mn:000079BC ; ===========================================================================
.text$mn:000079BC
.text$mn:000079BC ; Segment type: Pure code
.text$mn:000079BC ; Segment permissions: Read/Execute
.text$mn:000079BC _text$mn        segment para public 'CODE' use32
.text$mn:000079BC                 assume cs:_text$mn
.text$mn:000079BC                 ;org 79BCh
.text$mn:000079BC ; COMDAT (pick any)
.text$mn:000079BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079BC
.text$mn:000079BC ; =============== S U B R O U T I N E =======================================
.text$mn:000079BC
.text$mn:000079BC ; Attributes: bp-based frame
.text$mn:000079BC
.text$mn:000079BC ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Destroy(int *, int *)
.text$mn:000079BC                 public ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
.text$mn:000079BC ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z proc near
.text$mn:000079BC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+CBp
.text$mn:000079BC                                         ; std::vector<int,std::allocator<int>>::_Tidy(void)+2Bp
.text$mn:000079BC
.text$mn:000079BC var_8           = dword ptr -8
.text$mn:000079BC var_1           = byte ptr -1
.text$mn:000079BC arg_0           = dword ptr  8
.text$mn:000079BC arg_4           = dword ptr  0Ch
.text$mn:000079BC
.text$mn:000079BC                 push    ebp
.text$mn:000079BD                 mov     ebp, esp
.text$mn:000079BF                 sub     esp, 8
.text$mn:000079C2                 mov     [ebp+var_8], ecx
.text$mn:000079C5                 lea     eax, [ebp+var_1]
.text$mn:000079C8                 push    eax
.text$mn:000079C9                 mov     ecx, [ebp+var_8]
.text$mn:000079CC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:000079D1                 lea     ecx, [ebp+var_1]
.text$mn:000079D4                 push    ecx
.text$mn:000079D5                 mov     edx, [ebp+arg_4]
.text$mn:000079D8                 push    edx
.text$mn:000079D9                 mov     eax, [ebp+arg_0]
.text$mn:000079DC                 push    eax
.text$mn:000079DD                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:000079E2                 add     esp, 0Ch
.text$mn:000079E5                 mov     esp, ebp
.text$mn:000079E7                 pop     ebp
.text$mn:000079E8                 retn    8
.text$mn:000079E8 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z endp
.text$mn:000079E8
.text$mn:000079E8 ; ---------------------------------------------------------------------------
.text$mn:000079EB                 align 4
.text$mn:000079EB _text$mn        ends
.text$mn:000079EB
.text$mn:000079EC ; ===========================================================================
.text$mn:000079EC
.text$mn:000079EC ; Segment type: Pure code
.text$mn:000079EC ; Segment permissions: Read/Execute
.text$mn:000079EC _text$mn        segment para public 'CODE' use32
.text$mn:000079EC                 assume cs:_text$mn
.text$mn:000079EC                 ;org 79ECh
.text$mn:000079EC ; COMDAT (pick any)
.text$mn:000079EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079EC
.text$mn:000079EC ; =============== S U B R O U T I N E =======================================
.text$mn:000079EC
.text$mn:000079EC ; Attributes: bp-based frame
.text$mn:000079EC
.text$mn:000079EC ; protected: void __thiscall std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>::_Destroy(struct ColumnModeInfo *, struct ColumnModeInfo *)
.text$mn:000079EC                 public ?_Destroy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXPAUColumnModeInfo@@0@Z
.text$mn:000079EC ?_Destroy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXPAUColumnModeInfo@@0@Z proc near
.text$mn:000079EC                                         ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Tidy(void)+2Bp
.text$mn:000079EC
.text$mn:000079EC var_8           = dword ptr -8
.text$mn:000079EC var_1           = byte ptr -1
.text$mn:000079EC arg_0           = dword ptr  8
.text$mn:000079EC arg_4           = dword ptr  0Ch
.text$mn:000079EC
.text$mn:000079EC                 push    ebp
.text$mn:000079ED                 mov     ebp, esp
.text$mn:000079EF                 sub     esp, 8
.text$mn:000079F2                 mov     [ebp+var_8], ecx
.text$mn:000079F5                 lea     eax, [ebp+var_1]
.text$mn:000079F8                 push    eax
.text$mn:000079F9                 mov     ecx, [ebp+var_8]
.text$mn:000079FC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::_Getal(void)
.text$mn:00007A01                 lea     ecx, [ebp+var_1]
.text$mn:00007A04                 push    ecx
.text$mn:00007A05                 mov     edx, [ebp+arg_4]
.text$mn:00007A08                 push    edx
.text$mn:00007A09                 mov     eax, [ebp+arg_0]
.text$mn:00007A0C                 push    eax
.text$mn:00007A0D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@YAXPAUColumnModeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ColumnModeInfo>>>(ColumnModeInfo *,ColumnModeInfo *,std::_Wrap_alloc<std::allocator<ColumnModeInfo>> &)
.text$mn:00007A12                 add     esp, 0Ch
.text$mn:00007A15                 mov     esp, ebp
.text$mn:00007A17                 pop     ebp
.text$mn:00007A18                 retn    8
.text$mn:00007A18 ?_Destroy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXPAUColumnModeInfo@@0@Z endp
.text$mn:00007A18
.text$mn:00007A18 ; ---------------------------------------------------------------------------
.text$mn:00007A1B                 align 4
.text$mn:00007A1B _text$mn        ends
.text$mn:00007A1B
.text$mn:00007A1C ; ===========================================================================
.text$mn:00007A1C
.text$mn:00007A1C ; Segment type: Pure code
.text$mn:00007A1C ; Segment permissions: Read/Execute
.text$mn:00007A1C _text$mn        segment para public 'CODE' use32
.text$mn:00007A1C                 assume cs:_text$mn
.text$mn:00007A1C                 ;org 7A1Ch
.text$mn:00007A1C ; COMDAT (pick any)
.text$mn:00007A1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A1C
.text$mn:00007A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00007A1C
.text$mn:00007A1C ; Attributes: bp-based frame
.text$mn:00007A1C
.text$mn:00007A1C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00007A1C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00007A1C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00007A1C                                         ; CODE XREF: $LN19+60p
.text$mn:00007A1C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00007A1C
.text$mn:00007A1C var_8           = dword ptr -8
.text$mn:00007A1C var_1           = byte ptr -1
.text$mn:00007A1C arg_0           = dword ptr  8
.text$mn:00007A1C
.text$mn:00007A1C                 push    ebp
.text$mn:00007A1D                 mov     ebp, esp
.text$mn:00007A1F                 sub     esp, 8
.text$mn:00007A22                 mov     [ebp+var_8], ecx
.text$mn:00007A25                 mov     [ebp+var_1], 0
.text$mn:00007A29                 mov     eax, [ebp+var_8]
.text$mn:00007A2C                 mov     ecx, [ebp+arg_0]
.text$mn:00007A2F                 mov     [eax+14h], ecx
.text$mn:00007A32                 lea     edx, [ebp+var_1]
.text$mn:00007A35                 push    edx
.text$mn:00007A36                 mov     ecx, [ebp+var_8]
.text$mn:00007A39                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007A3E                 add     eax, [ebp+arg_0]
.text$mn:00007A41                 push    eax
.text$mn:00007A42                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00007A47                 add     esp, 8
.text$mn:00007A4A                 mov     esp, ebp
.text$mn:00007A4C                 pop     ebp
.text$mn:00007A4D                 retn    4
.text$mn:00007A4D ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00007A4D
.text$mn:00007A4D _text$mn        ends
.text$mn:00007A4D
.text$mn:00007A50 ; ===========================================================================
.text$mn:00007A50
.text$mn:00007A50 ; Segment type: Pure code
.text$mn:00007A50 ; Segment permissions: Read/Execute
.text$mn:00007A50 _text$mn        segment para public 'CODE' use32
.text$mn:00007A50                 assume cs:_text$mn
.text$mn:00007A50                 ;org 7A50h
.text$mn:00007A50 ; COMDAT (pick any)
.text$mn:00007A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A50
.text$mn:00007A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A50
.text$mn:00007A50 ; Attributes: bp-based frame
.text$mn:00007A50
.text$mn:00007A50 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00007A50                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00007A50 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00007A50                                         ; CODE XREF: $LN19_0+60p
.text$mn:00007A50                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00007A50
.text$mn:00007A50 var_8           = dword ptr -8
.text$mn:00007A50 var_2           = word ptr -2
.text$mn:00007A50 arg_0           = dword ptr  8
.text$mn:00007A50
.text$mn:00007A50                 push    ebp
.text$mn:00007A51                 mov     ebp, esp
.text$mn:00007A53                 sub     esp, 8
.text$mn:00007A56                 mov     [ebp+var_8], ecx
.text$mn:00007A59                 xor     eax, eax
.text$mn:00007A5B                 mov     [ebp+var_2], ax
.text$mn:00007A5F                 mov     ecx, [ebp+var_8]
.text$mn:00007A62                 mov     edx, [ebp+arg_0]
.text$mn:00007A65                 mov     [ecx+14h], edx
.text$mn:00007A68                 lea     eax, [ebp+var_2]
.text$mn:00007A6B                 push    eax
.text$mn:00007A6C                 mov     ecx, [ebp+var_8]
.text$mn:00007A6F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007A74                 mov     ecx, [ebp+arg_0]
.text$mn:00007A77                 lea     edx, [eax+ecx*2]
.text$mn:00007A7A                 push    edx
.text$mn:00007A7B                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00007A80                 add     esp, 8
.text$mn:00007A83                 mov     esp, ebp
.text$mn:00007A85                 pop     ebp
.text$mn:00007A86                 retn    4
.text$mn:00007A86 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00007A86
.text$mn:00007A86 ; ---------------------------------------------------------------------------
.text$mn:00007A89                 align 4
.text$mn:00007A89 _text$mn        ends
.text$mn:00007A89
.text$mn:00007A8C ; ===========================================================================
.text$mn:00007A8C
.text$mn:00007A8C ; Segment type: Pure code
.text$mn:00007A8C ; Segment permissions: Read/Execute
.text$mn:00007A8C _text$mn        segment para public 'CODE' use32
.text$mn:00007A8C                 assume cs:_text$mn
.text$mn:00007A8C                 ;org 7A8Ch
.text$mn:00007A8C ; COMDAT (pick any)
.text$mn:00007A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A8C
.text$mn:00007A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00007A8C
.text$mn:00007A8C ; Attributes: bp-based frame
.text$mn:00007A8C
.text$mn:00007A8C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00007A8C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00007A8C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007A8C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00007A8C
.text$mn:00007A8C var_8           = dword ptr -8
.text$mn:00007A8C var_1           = byte ptr -1
.text$mn:00007A8C
.text$mn:00007A8C                 push    ebp
.text$mn:00007A8D                 mov     ebp, esp
.text$mn:00007A8F                 sub     esp, 8
.text$mn:00007A92                 mov     [ebp+var_8], ecx
.text$mn:00007A95                 lea     ecx, [ebp+var_1]
.text$mn:00007A98                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00007A9D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007AA0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007AA5                 mov     eax, [ebp+var_8]
.text$mn:00007AA8                 mov     ecx, [eax]
.text$mn:00007AAA                 push    ecx
.text$mn:00007AAB                 lea     ecx, [ebp+var_1]
.text$mn:00007AAE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00007AB3                 push    1               ; int
.text$mn:00007AB5                 mov     edx, [ebp+var_8]
.text$mn:00007AB8                 mov     eax, [edx]
.text$mn:00007ABA                 push    eax             ; void *
.text$mn:00007ABB                 lea     ecx, [ebp+var_1]
.text$mn:00007ABE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007AC3                 mov     ecx, [ebp+var_8]
.text$mn:00007AC6                 mov     dword ptr [ecx], 0
.text$mn:00007ACC                 mov     esp, ebp
.text$mn:00007ACE                 pop     ebp
.text$mn:00007ACF                 retn
.text$mn:00007ACF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007ACF
.text$mn:00007ACF _text$mn        ends
.text$mn:00007ACF
.text$mn:00007AD0 ; ===========================================================================
.text$mn:00007AD0
.text$mn:00007AD0 ; Segment type: Pure code
.text$mn:00007AD0 ; Segment permissions: Read/Execute
.text$mn:00007AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00007AD0                 assume cs:_text$mn
.text$mn:00007AD0                 ;org 7AD0h
.text$mn:00007AD0 ; COMDAT (pick any)
.text$mn:00007AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AD0
.text$mn:00007AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AD0
.text$mn:00007AD0 ; Attributes: bp-based frame
.text$mn:00007AD0
.text$mn:00007AD0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00007AD0                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00007AD0 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007AD0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00007AD0
.text$mn:00007AD0 var_8           = dword ptr -8
.text$mn:00007AD0 var_1           = byte ptr -1
.text$mn:00007AD0
.text$mn:00007AD0                 push    ebp
.text$mn:00007AD1                 mov     ebp, esp
.text$mn:00007AD3                 sub     esp, 8
.text$mn:00007AD6                 mov     [ebp+var_8], ecx
.text$mn:00007AD9                 lea     ecx, [ebp+var_1]
.text$mn:00007ADC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00007AE1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007AE4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007AE9                 mov     eax, [ebp+var_8]
.text$mn:00007AEC                 mov     ecx, [eax]
.text$mn:00007AEE                 push    ecx
.text$mn:00007AEF                 lea     ecx, [ebp+var_1]
.text$mn:00007AF2                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00007AF7                 push    1               ; int
.text$mn:00007AF9                 mov     edx, [ebp+var_8]
.text$mn:00007AFC                 mov     eax, [edx]
.text$mn:00007AFE                 push    eax             ; void *
.text$mn:00007AFF                 lea     ecx, [ebp+var_1]
.text$mn:00007B02                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007B07                 mov     ecx, [ebp+var_8]
.text$mn:00007B0A                 mov     dword ptr [ecx], 0
.text$mn:00007B10                 mov     esp, ebp
.text$mn:00007B12                 pop     ebp
.text$mn:00007B13                 retn
.text$mn:00007B13 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007B13
.text$mn:00007B13 _text$mn        ends
.text$mn:00007B13
.text$mn:00007B14 ; ===========================================================================
.text$mn:00007B14
.text$mn:00007B14 ; Segment type: Pure code
.text$mn:00007B14 ; Segment permissions: Read/Execute
.text$mn:00007B14 _text$mn        segment para public 'CODE' use32
.text$mn:00007B14                 assume cs:_text$mn
.text$mn:00007B14                 ;org 7B14h
.text$mn:00007B14 ; COMDAT (pick any)
.text$mn:00007B14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B14
.text$mn:00007B14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B14
.text$mn:00007B14 ; Attributes: bp-based frame
.text$mn:00007B14
.text$mn:00007B14 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Free_proxy(void)
.text$mn:00007B14                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
.text$mn:00007B14 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007B14                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::~_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>(void)+30p
.text$mn:00007B14
.text$mn:00007B14 var_8           = dword ptr -8
.text$mn:00007B14 var_1           = byte ptr -1
.text$mn:00007B14
.text$mn:00007B14                 push    ebp
.text$mn:00007B15                 mov     ebp, esp
.text$mn:00007B17                 sub     esp, 8
.text$mn:00007B1A                 mov     [ebp+var_8], ecx
.text$mn:00007B1D                 lea     ecx, [ebp+var_1]
.text$mn:00007B20                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00007B25                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007B28                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007B2D                 mov     eax, [ebp+var_8]
.text$mn:00007B30                 mov     ecx, [eax]
.text$mn:00007B32                 push    ecx
.text$mn:00007B33                 lea     ecx, [ebp+var_1]
.text$mn:00007B36                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00007B3B                 push    1               ; int
.text$mn:00007B3D                 mov     edx, [ebp+var_8]
.text$mn:00007B40                 mov     eax, [edx]
.text$mn:00007B42                 push    eax             ; void *
.text$mn:00007B43                 lea     ecx, [ebp+var_1]
.text$mn:00007B46                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007B4B                 mov     ecx, [ebp+var_8]
.text$mn:00007B4E                 mov     dword ptr [ecx], 0
.text$mn:00007B54                 mov     esp, ebp
.text$mn:00007B56                 pop     ebp
.text$mn:00007B57                 retn
.text$mn:00007B57 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007B57
.text$mn:00007B57 _text$mn        ends
.text$mn:00007B57
.text$mn:00007B58 ; ===========================================================================
.text$mn:00007B58
.text$mn:00007B58 ; Segment type: Pure code
.text$mn:00007B58 ; Segment permissions: Read/Execute
.text$mn:00007B58 _text$mn        segment para public 'CODE' use32
.text$mn:00007B58                 assume cs:_text$mn
.text$mn:00007B58                 ;org 7B58h
.text$mn:00007B58 ; COMDAT (pick any)
.text$mn:00007B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B58
.text$mn:00007B58 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B58
.text$mn:00007B58 ; Attributes: bp-based frame
.text$mn:00007B58
.text$mn:00007B58 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>>::_Free_proxy(void)
.text$mn:00007B58                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAEXXZ
.text$mn:00007B58 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007B58                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::~_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>(void)+30p
.text$mn:00007B58
.text$mn:00007B58 var_8           = dword ptr -8
.text$mn:00007B58 var_1           = byte ptr -1
.text$mn:00007B58
.text$mn:00007B58                 push    ebp
.text$mn:00007B59                 mov     ebp, esp
.text$mn:00007B5B                 sub     esp, 8
.text$mn:00007B5E                 mov     [ebp+var_8], ecx
.text$mn:00007B61                 lea     ecx, [ebp+var_1]
.text$mn:00007B64                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00007B69                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007B6C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007B71                 mov     eax, [ebp+var_8]
.text$mn:00007B74                 mov     ecx, [eax]
.text$mn:00007B76                 push    ecx
.text$mn:00007B77                 lea     ecx, [ebp+var_1]
.text$mn:00007B7A                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00007B7F                 push    1               ; int
.text$mn:00007B81                 mov     edx, [ebp+var_8]
.text$mn:00007B84                 mov     eax, [edx]
.text$mn:00007B86                 push    eax             ; void *
.text$mn:00007B87                 lea     ecx, [ebp+var_1]
.text$mn:00007B8A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007B8F                 mov     ecx, [ebp+var_8]
.text$mn:00007B92                 mov     dword ptr [ecx], 0
.text$mn:00007B98                 mov     esp, ebp
.text$mn:00007B9A                 pop     ebp
.text$mn:00007B9B                 retn
.text$mn:00007B9B ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007B9B
.text$mn:00007B9B _text$mn        ends
.text$mn:00007B9B
.text$mn:00007B9C ; ===========================================================================
.text$mn:00007B9C
.text$mn:00007B9C ; Segment type: Pure code
.text$mn:00007B9C ; Segment permissions: Read/Execute
.text$mn:00007B9C _text$mn        segment para public 'CODE' use32
.text$mn:00007B9C                 assume cs:_text$mn
.text$mn:00007B9C                 ;org 7B9Ch
.text$mn:00007B9C ; COMDAT (pick any)
.text$mn:00007B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B9C
.text$mn:00007B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B9C
.text$mn:00007B9C ; Attributes: bp-based frame
.text$mn:00007B9C
.text$mn:00007B9C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00007B9C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00007B9C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00007B9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00007B9C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00007B9C
.text$mn:00007B9C var_4           = dword ptr -4
.text$mn:00007B9C arg_0           = dword ptr  8
.text$mn:00007B9C
.text$mn:00007B9C                 push    ebp
.text$mn:00007B9D                 mov     ebp, esp
.text$mn:00007B9F                 push    ecx
.text$mn:00007BA0                 mov     [ebp+var_4], ecx
.text$mn:00007BA3                 mov     ecx, [ebp+arg_0]
.text$mn:00007BA6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00007BAB                 mov     eax, [ebp+arg_0]
.text$mn:00007BAE                 mov     esp, ebp
.text$mn:00007BB0                 pop     ebp
.text$mn:00007BB1                 retn    4
.text$mn:00007BB1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00007BB1
.text$mn:00007BB1 _text$mn        ends
.text$mn:00007BB1
.text$mn:00007BB4 ; ===========================================================================
.text$mn:00007BB4
.text$mn:00007BB4 ; Segment type: Pure code
.text$mn:00007BB4 ; Segment permissions: Read/Execute
.text$mn:00007BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00007BB4                 assume cs:_text$mn
.text$mn:00007BB4                 ;org 7BB4h
.text$mn:00007BB4 ; COMDAT (pick any)
.text$mn:00007BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BB4
.text$mn:00007BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BB4
.text$mn:00007BB4 ; Attributes: bp-based frame
.text$mn:00007BB4
.text$mn:00007BB4 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00007BB4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00007BB4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00007BB4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:00007BB4                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00007BB4
.text$mn:00007BB4 var_4           = dword ptr -4
.text$mn:00007BB4 arg_0           = dword ptr  8
.text$mn:00007BB4
.text$mn:00007BB4                 push    ebp
.text$mn:00007BB5                 mov     ebp, esp
.text$mn:00007BB7                 push    ecx
.text$mn:00007BB8                 mov     [ebp+var_4], ecx
.text$mn:00007BBB                 mov     ecx, [ebp+arg_0]
.text$mn:00007BBE                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00007BC3                 mov     eax, [ebp+arg_0]
.text$mn:00007BC6                 mov     esp, ebp
.text$mn:00007BC8                 pop     ebp
.text$mn:00007BC9                 retn    4
.text$mn:00007BC9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00007BC9
.text$mn:00007BC9 _text$mn        ends
.text$mn:00007BC9
.text$mn:00007BCC ; ===========================================================================
.text$mn:00007BCC
.text$mn:00007BCC ; Segment type: Pure code
.text$mn:00007BCC ; Segment permissions: Read/Execute
.text$mn:00007BCC _text$mn        segment para public 'CODE' use32
.text$mn:00007BCC                 assume cs:_text$mn
.text$mn:00007BCC                 ;org 7BCCh
.text$mn:00007BCC ; COMDAT (pick any)
.text$mn:00007BCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BCC
.text$mn:00007BCC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BCC
.text$mn:00007BCC ; Attributes: bp-based frame
.text$mn:00007BCC
.text$mn:00007BCC ; public: struct std::_Wrap_alloc<class std::allocator<int>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Getal(void)const
.text$mn:00007BCC                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
.text$mn:00007BCC ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ proc near
.text$mn:00007BCC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+10p
.text$mn:00007BCC                                         ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+10p ...
.text$mn:00007BCC
.text$mn:00007BCC var_4           = dword ptr -4
.text$mn:00007BCC arg_0           = dword ptr  8
.text$mn:00007BCC
.text$mn:00007BCC                 push    ebp
.text$mn:00007BCD                 mov     ebp, esp
.text$mn:00007BCF                 push    ecx
.text$mn:00007BD0                 mov     [ebp+var_4], ecx
.text$mn:00007BD3                 mov     ecx, [ebp+arg_0]
.text$mn:00007BD6                 call    ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)
.text$mn:00007BDB                 mov     eax, [ebp+arg_0]
.text$mn:00007BDE                 mov     esp, ebp
.text$mn:00007BE0                 pop     ebp
.text$mn:00007BE1                 retn    4
.text$mn:00007BE1 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ endp
.text$mn:00007BE1
.text$mn:00007BE1 _text$mn        ends
.text$mn:00007BE1
.text$mn:00007BE4 ; ===========================================================================
.text$mn:00007BE4
.text$mn:00007BE4 ; Segment type: Pure code
.text$mn:00007BE4 ; Segment permissions: Read/Execute
.text$mn:00007BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00007BE4                 assume cs:_text$mn
.text$mn:00007BE4                 ;org 7BE4h
.text$mn:00007BE4 ; COMDAT (pick any)
.text$mn:00007BE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BE4
.text$mn:00007BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BE4
.text$mn:00007BE4 ; Attributes: bp-based frame
.text$mn:00007BE4
.text$mn:00007BE4 ; public: struct std::_Wrap_alloc<class std::allocator<struct ColumnModeInfo>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>>::_Getal(void)const
.text$mn:00007BE4                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@2@XZ
.text$mn:00007BE4 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@2@XZ proc near
.text$mn:00007BE4                                         ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Destroy(ColumnModeInfo *,ColumnModeInfo *)+10p
.text$mn:00007BE4                                         ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Tidy(void)+55p
.text$mn:00007BE4
.text$mn:00007BE4 var_4           = dword ptr -4
.text$mn:00007BE4 arg_0           = dword ptr  8
.text$mn:00007BE4
.text$mn:00007BE4                 push    ebp
.text$mn:00007BE5                 mov     ebp, esp
.text$mn:00007BE7                 push    ecx
.text$mn:00007BE8                 mov     [ebp+var_4], ecx
.text$mn:00007BEB                 mov     ecx, [ebp+arg_0]
.text$mn:00007BEE                 call    ??0?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<ColumnModeInfo>>::_Wrap_alloc<std::allocator<ColumnModeInfo>>(void)
.text$mn:00007BF3                 mov     eax, [ebp+arg_0]
.text$mn:00007BF6                 mov     esp, ebp
.text$mn:00007BF8                 pop     ebp
.text$mn:00007BF9                 retn    4
.text$mn:00007BF9 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@2@XZ endp
.text$mn:00007BF9
.text$mn:00007BF9 _text$mn        ends
.text$mn:00007BF9
.text$mn:00007BFC ; ===========================================================================
.text$mn:00007BFC
.text$mn:00007BFC ; Segment type: Pure code
.text$mn:00007BFC ; Segment permissions: Read/Execute
.text$mn:00007BFC _text$mn        segment para public 'CODE' use32
.text$mn:00007BFC                 assume cs:_text$mn
.text$mn:00007BFC                 ;org 7BFCh
.text$mn:00007BFC ; COMDAT (pick any)
.text$mn:00007BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BFC
.text$mn:00007BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BFC
.text$mn:00007BFC ; Attributes: bp-based frame
.text$mn:00007BFC
.text$mn:00007BFC ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00007BFC                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00007BFC ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00007BFC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+Ap
.text$mn:00007BFC                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+1Fp ...
.text$mn:00007BFC
.text$mn:00007BFC var_8           = dword ptr -8
.text$mn:00007BFC var_4           = dword ptr -4
.text$mn:00007BFC
.text$mn:00007BFC                 push    ebp
.text$mn:00007BFD                 mov     ebp, esp
.text$mn:00007BFF                 sub     esp, 8
.text$mn:00007C02                 mov     [ebp+var_4], ecx
.text$mn:00007C05                 mov     eax, [ebp+var_4]
.text$mn:00007C08                 cmp     dword ptr [eax], 0
.text$mn:00007C0B                 jnz     short loc_7C16
.text$mn:00007C0D                 mov     [ebp+var_8], 0
.text$mn:00007C14                 jmp     short loc_7C20
.text$mn:00007C16 ; ---------------------------------------------------------------------------
.text$mn:00007C16
.text$mn:00007C16 loc_7C16:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:00007C16                 mov     ecx, [ebp+var_4]
.text$mn:00007C19                 mov     edx, [ecx]
.text$mn:00007C1B                 mov     eax, [edx]
.text$mn:00007C1D                 mov     [ebp+var_8], eax
.text$mn:00007C20
.text$mn:00007C20 loc_7C20:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00007C20                 mov     eax, [ebp+var_8]
.text$mn:00007C23                 mov     esp, ebp
.text$mn:00007C25                 pop     ebp
.text$mn:00007C26                 retn
.text$mn:00007C26 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:00007C26
.text$mn:00007C26 ; ---------------------------------------------------------------------------
.text$mn:00007C27                 align 4
.text$mn:00007C27 _text$mn        ends
.text$mn:00007C27
.text$mn:00007C28 ; ===========================================================================
.text$mn:00007C28
.text$mn:00007C28 ; Segment type: Pure code
.text$mn:00007C28 ; Segment permissions: Read/Execute
.text$mn:00007C28 _text$mn        segment para public 'CODE' use32
.text$mn:00007C28                 assume cs:_text$mn
.text$mn:00007C28                 ;org 7C28h
.text$mn:00007C28 ; COMDAT (pick any)
.text$mn:00007C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C28
.text$mn:00007C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C28
.text$mn:00007C28 ; Attributes: bp-based frame
.text$mn:00007C28
.text$mn:00007C28 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00007C28                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00007C28 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00007C28                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+3Cp
.text$mn:00007C28
.text$mn:00007C28 var_8           = dword ptr -8
.text$mn:00007C28 var_4           = dword ptr -4
.text$mn:00007C28
.text$mn:00007C28                 push    ebp
.text$mn:00007C29                 mov     ebp, esp
.text$mn:00007C2B                 sub     esp, 8
.text$mn:00007C2E                 mov     [ebp+var_4], ecx
.text$mn:00007C31                 mov     eax, [ebp+var_4]
.text$mn:00007C34                 cmp     dword ptr [eax], 0
.text$mn:00007C37                 jnz     short loc_7C42
.text$mn:00007C39                 mov     [ebp+var_8], 0
.text$mn:00007C40                 jmp     short loc_7C4D
.text$mn:00007C42 ; ---------------------------------------------------------------------------
.text$mn:00007C42
.text$mn:00007C42 loc_7C42:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00007C42                 mov     ecx, [ebp+var_4]
.text$mn:00007C45                 mov     edx, [ecx]
.text$mn:00007C47                 add     edx, 4
.text$mn:00007C4A                 mov     [ebp+var_8], edx
.text$mn:00007C4D
.text$mn:00007C4D loc_7C4D:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00007C4D                 mov     eax, [ebp+var_8]
.text$mn:00007C50                 mov     esp, ebp
.text$mn:00007C52                 pop     ebp
.text$mn:00007C53                 retn
.text$mn:00007C53 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00007C53
.text$mn:00007C53 _text$mn        ends
.text$mn:00007C53
.text$mn:00007C54 ; ===========================================================================
.text$mn:00007C54
.text$mn:00007C54 ; Segment type: Pure code
.text$mn:00007C54 ; Segment permissions: Read/Execute
.text$mn:00007C54 _text$mn        segment para public 'CODE' use32
.text$mn:00007C54                 assume cs:_text$mn
.text$mn:00007C54                 ;org 7C54h
.text$mn:00007C54 ; COMDAT (pick any)
.text$mn:00007C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C54
.text$mn:00007C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C54
.text$mn:00007C54 ; Attributes: bp-based frame
.text$mn:00007C54
.text$mn:00007C54 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00007C54                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00007C54 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00007C54                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+71p
.text$mn:00007C54                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+8Ap
.text$mn:00007C54
.text$mn:00007C54 var_4           = dword ptr -4
.text$mn:00007C54
.text$mn:00007C54                 push    ebp
.text$mn:00007C55                 mov     ebp, esp
.text$mn:00007C57                 push    ecx
.text$mn:00007C58                 mov     [ebp+var_4], ecx
.text$mn:00007C5B                 mov     eax, [ebp+var_4]
.text$mn:00007C5E                 add     eax, 4
.text$mn:00007C61                 mov     esp, ebp
.text$mn:00007C63                 pop     ebp
.text$mn:00007C64                 retn
.text$mn:00007C64 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00007C64
.text$mn:00007C64 ; ---------------------------------------------------------------------------
.text$mn:00007C65                 align 4
.text$mn:00007C65 _text$mn        ends
.text$mn:00007C65
.text$mn:00007C68 ; ===========================================================================
.text$mn:00007C68
.text$mn:00007C68 ; Segment type: Pure code
.text$mn:00007C68 ; Segment permissions: Read/Execute
.text$mn:00007C68 _text$mn        segment para public 'CODE' use32
.text$mn:00007C68                 assume cs:_text$mn
.text$mn:00007C68                 ;org 7C68h
.text$mn:00007C68 ; COMDAT (pick any)
.text$mn:00007C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C68
.text$mn:00007C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C68
.text$mn:00007C68 ; Attributes: bp-based frame
.text$mn:00007C68
.text$mn:00007C68 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00007C68                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00007C68 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00007C68                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00007C68                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00007C68
.text$mn:00007C68 var_C           = dword ptr -0Ch
.text$mn:00007C68 Size            = dword ptr -8
.text$mn:00007C68 var_4           = dword ptr -4
.text$mn:00007C68 arg_0           = dword ptr  8
.text$mn:00007C68 arg_4           = byte ptr  0Ch
.text$mn:00007C68
.text$mn:00007C68                 push    ebp
.text$mn:00007C69                 mov     ebp, esp
.text$mn:00007C6B                 sub     esp, 0Ch
.text$mn:00007C6E                 mov     [ebp+var_4], ecx
.text$mn:00007C71                 mov     ecx, [ebp+var_4]
.text$mn:00007C74                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00007C79                 cmp     eax, [ebp+arg_0]
.text$mn:00007C7C                 jnb     short loc_7C86
.text$mn:00007C7E                 mov     ecx, [ebp+var_4]
.text$mn:00007C81                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00007C86
.text$mn:00007C86 loc_7C86:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00007C86                 mov     eax, [ebp+var_4]
.text$mn:00007C89                 mov     ecx, [eax+18h]
.text$mn:00007C8C                 cmp     ecx, [ebp+arg_0]
.text$mn:00007C8F                 jnb     short loc_7CA6
.text$mn:00007C91                 mov     edx, [ebp+var_4]
.text$mn:00007C94                 mov     eax, [edx+14h]
.text$mn:00007C97                 push    eax
.text$mn:00007C98                 mov     ecx, [ebp+arg_0]
.text$mn:00007C9B                 push    ecx
.text$mn:00007C9C                 mov     ecx, [ebp+var_4]
.text$mn:00007C9F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00007CA4                 jmp     short loc_7CF0
.text$mn:00007CA6 ; ---------------------------------------------------------------------------
.text$mn:00007CA6
.text$mn:00007CA6 loc_7CA6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00007CA6                 movzx   edx, [ebp+arg_4]
.text$mn:00007CAA                 test    edx, edx
.text$mn:00007CAC                 jz      short loc_7CE0
.text$mn:00007CAE                 cmp     [ebp+arg_0], 10h
.text$mn:00007CB2                 jnb     short loc_7CE0
.text$mn:00007CB4                 mov     eax, [ebp+var_4]
.text$mn:00007CB7                 mov     ecx, [ebp+arg_0]
.text$mn:00007CBA                 cmp     ecx, [eax+14h]
.text$mn:00007CBD                 jnb     short loc_7CC7
.text$mn:00007CBF                 mov     edx, [ebp+arg_0]
.text$mn:00007CC2                 mov     [ebp+Size], edx
.text$mn:00007CC5                 jmp     short loc_7CD0
.text$mn:00007CC7 ; ---------------------------------------------------------------------------
.text$mn:00007CC7
.text$mn:00007CC7 loc_7CC7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00007CC7                 mov     eax, [ebp+var_4]
.text$mn:00007CCA                 mov     ecx, [eax+14h]
.text$mn:00007CCD                 mov     [ebp+Size], ecx
.text$mn:00007CD0
.text$mn:00007CD0 loc_7CD0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00007CD0                 mov     edx, [ebp+Size]
.text$mn:00007CD3                 push    edx             ; Size
.text$mn:00007CD4                 push    1               ; char
.text$mn:00007CD6                 mov     ecx, [ebp+var_4]
.text$mn:00007CD9                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00007CDE                 jmp     short loc_7CF0
.text$mn:00007CE0 ; ---------------------------------------------------------------------------
.text$mn:00007CE0
.text$mn:00007CE0 loc_7CE0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00007CE0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00007CE0                 cmp     [ebp+arg_0], 0
.text$mn:00007CE4                 jnz     short loc_7CF0
.text$mn:00007CE6                 push    0
.text$mn:00007CE8                 mov     ecx, [ebp+var_4]
.text$mn:00007CEB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007CF0
.text$mn:00007CF0 loc_7CF0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00007CF0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00007CF0                 cmp     [ebp+arg_0], 0
.text$mn:00007CF4                 jbe     short loc_7CFF
.text$mn:00007CF6                 mov     [ebp+var_C], 1
.text$mn:00007CFD                 jmp     short loc_7D06
.text$mn:00007CFF ; ---------------------------------------------------------------------------
.text$mn:00007CFF
.text$mn:00007CFF loc_7CFF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00007CFF                 mov     [ebp+var_C], 0
.text$mn:00007D06
.text$mn:00007D06 loc_7D06:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00007D06                 mov     al, byte ptr [ebp+var_C]
.text$mn:00007D09                 mov     esp, ebp
.text$mn:00007D0B                 pop     ebp
.text$mn:00007D0C                 retn    8
.text$mn:00007D0C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00007D0C
.text$mn:00007D0C ; ---------------------------------------------------------------------------
.text$mn:00007D0F                 align 10h
.text$mn:00007D0F _text$mn        ends
.text$mn:00007D0F
.text$mn:00007D10 ; ===========================================================================
.text$mn:00007D10
.text$mn:00007D10 ; Segment type: Pure code
.text$mn:00007D10 ; Segment permissions: Read/Execute
.text$mn:00007D10 _text$mn        segment para public 'CODE' use32
.text$mn:00007D10                 assume cs:_text$mn
.text$mn:00007D10                 ;org 7D10h
.text$mn:00007D10 ; COMDAT (pick any)
.text$mn:00007D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D10
.text$mn:00007D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D10
.text$mn:00007D10 ; Attributes: bp-based frame
.text$mn:00007D10
.text$mn:00007D10 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00007D10                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00007D10 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00007D10                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:00007D10                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:00007D10
.text$mn:00007D10 var_C           = dword ptr -0Ch
.text$mn:00007D10 var_8           = dword ptr -8
.text$mn:00007D10 var_4           = dword ptr -4
.text$mn:00007D10 arg_0           = dword ptr  8
.text$mn:00007D10 arg_4           = byte ptr  0Ch
.text$mn:00007D10
.text$mn:00007D10                 push    ebp
.text$mn:00007D11                 mov     ebp, esp
.text$mn:00007D13                 sub     esp, 0Ch
.text$mn:00007D16                 mov     [ebp+var_4], ecx
.text$mn:00007D19                 mov     ecx, [ebp+var_4]
.text$mn:00007D1C                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007D21                 cmp     eax, [ebp+arg_0]
.text$mn:00007D24                 jnb     short loc_7D2E
.text$mn:00007D26                 mov     ecx, [ebp+var_4]
.text$mn:00007D29                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00007D2E
.text$mn:00007D2E loc_7D2E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00007D2E                 mov     eax, [ebp+var_4]
.text$mn:00007D31                 mov     ecx, [eax+18h]
.text$mn:00007D34                 cmp     ecx, [ebp+arg_0]
.text$mn:00007D37                 jnb     short loc_7D4E
.text$mn:00007D39                 mov     edx, [ebp+var_4]
.text$mn:00007D3C                 mov     eax, [edx+14h]
.text$mn:00007D3F                 push    eax
.text$mn:00007D40                 mov     ecx, [ebp+arg_0]
.text$mn:00007D43                 push    ecx
.text$mn:00007D44                 mov     ecx, [ebp+var_4]
.text$mn:00007D47                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00007D4C                 jmp     short loc_7D98
.text$mn:00007D4E ; ---------------------------------------------------------------------------
.text$mn:00007D4E
.text$mn:00007D4E loc_7D4E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00007D4E                 movzx   edx, [ebp+arg_4]
.text$mn:00007D52                 test    edx, edx
.text$mn:00007D54                 jz      short loc_7D88
.text$mn:00007D56                 cmp     [ebp+arg_0], 8
.text$mn:00007D5A                 jnb     short loc_7D88
.text$mn:00007D5C                 mov     eax, [ebp+var_4]
.text$mn:00007D5F                 mov     ecx, [ebp+arg_0]
.text$mn:00007D62                 cmp     ecx, [eax+14h]
.text$mn:00007D65                 jnb     short loc_7D6F
.text$mn:00007D67                 mov     edx, [ebp+arg_0]
.text$mn:00007D6A                 mov     [ebp+var_8], edx
.text$mn:00007D6D                 jmp     short loc_7D78
.text$mn:00007D6F ; ---------------------------------------------------------------------------
.text$mn:00007D6F
.text$mn:00007D6F loc_7D6F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00007D6F                 mov     eax, [ebp+var_4]
.text$mn:00007D72                 mov     ecx, [eax+14h]
.text$mn:00007D75                 mov     [ebp+var_8], ecx
.text$mn:00007D78
.text$mn:00007D78 loc_7D78:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00007D78                 mov     edx, [ebp+var_8]
.text$mn:00007D7B                 push    edx
.text$mn:00007D7C                 push    1
.text$mn:00007D7E                 mov     ecx, [ebp+var_4]
.text$mn:00007D81                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007D86                 jmp     short loc_7D98
.text$mn:00007D88 ; ---------------------------------------------------------------------------
.text$mn:00007D88
.text$mn:00007D88 loc_7D88:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00007D88                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00007D88                 cmp     [ebp+arg_0], 0
.text$mn:00007D8C                 jnz     short loc_7D98
.text$mn:00007D8E                 push    0
.text$mn:00007D90                 mov     ecx, [ebp+var_4]
.text$mn:00007D93                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00007D98
.text$mn:00007D98 loc_7D98:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00007D98                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00007D98                 cmp     [ebp+arg_0], 0
.text$mn:00007D9C                 jbe     short loc_7DA7
.text$mn:00007D9E                 mov     [ebp+var_C], 1
.text$mn:00007DA5                 jmp     short loc_7DAE
.text$mn:00007DA7 ; ---------------------------------------------------------------------------
.text$mn:00007DA7
.text$mn:00007DA7 loc_7DA7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00007DA7                 mov     [ebp+var_C], 0
.text$mn:00007DAE
.text$mn:00007DAE loc_7DAE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00007DAE                 mov     al, byte ptr [ebp+var_C]
.text$mn:00007DB1                 mov     esp, ebp
.text$mn:00007DB3                 pop     ebp
.text$mn:00007DB4                 retn    8
.text$mn:00007DB4 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00007DB4
.text$mn:00007DB4 ; ---------------------------------------------------------------------------
.text$mn:00007DB7                 align 4
.text$mn:00007DB7 _text$mn        ends
.text$mn:00007DB7
.text$mn:00007DB8 ; ===========================================================================
.text$mn:00007DB8
.text$mn:00007DB8 ; Segment type: Pure code
.text$mn:00007DB8 ; Segment permissions: Read/Execute
.text$mn:00007DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00007DB8                 assume cs:_text$mn
.text$mn:00007DB8                 ;org 7DB8h
.text$mn:00007DB8 ; COMDAT (pick any)
.text$mn:00007DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DB8
.text$mn:00007DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DB8
.text$mn:00007DB8 ; Attributes: bp-based frame
.text$mn:00007DB8
.text$mn:00007DB8 ; protected: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Grow_to(unsigned int)const
.text$mn:00007DB8                 public ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
.text$mn:00007DB8 ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z proc near
.text$mn:00007DB8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+45p
.text$mn:00007DB8
.text$mn:00007DB8 var_C           = dword ptr -0Ch
.text$mn:00007DB8 var_8           = dword ptr -8
.text$mn:00007DB8 var_4           = dword ptr -4
.text$mn:00007DB8 arg_0           = dword ptr  8
.text$mn:00007DB8
.text$mn:00007DB8                 push    ebp
.text$mn:00007DB9                 mov     ebp, esp
.text$mn:00007DBB                 sub     esp, 0Ch
.text$mn:00007DBE                 mov     [ebp+var_8], ecx
.text$mn:00007DC1                 mov     ecx, [ebp+var_8]
.text$mn:00007DC4                 call    ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::capacity(void)
.text$mn:00007DC9                 mov     [ebp+var_4], eax
.text$mn:00007DCC                 mov     ecx, [ebp+var_8]
.text$mn:00007DCF                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:00007DD4                 mov     ecx, [ebp+var_4]
.text$mn:00007DD7                 shr     ecx, 1
.text$mn:00007DD9                 sub     eax, ecx
.text$mn:00007DDB                 cmp     eax, [ebp+var_4]
.text$mn:00007DDE                 jnb     short loc_7DE9
.text$mn:00007DE0                 mov     [ebp+var_C], 0
.text$mn:00007DE7                 jmp     short loc_7DF4
.text$mn:00007DE9 ; ---------------------------------------------------------------------------
.text$mn:00007DE9
.text$mn:00007DE9 loc_7DE9:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+26j
.text$mn:00007DE9                 mov     edx, [ebp+var_4]
.text$mn:00007DEC                 shr     edx, 1
.text$mn:00007DEE                 add     edx, [ebp+var_4]
.text$mn:00007DF1                 mov     [ebp+var_C], edx
.text$mn:00007DF4
.text$mn:00007DF4 loc_7DF4:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+2Fj
.text$mn:00007DF4                 mov     eax, [ebp+var_C]
.text$mn:00007DF7                 mov     [ebp+var_4], eax
.text$mn:00007DFA                 mov     ecx, [ebp+var_4]
.text$mn:00007DFD                 cmp     ecx, [ebp+arg_0]
.text$mn:00007E00                 jnb     short loc_7E08
.text$mn:00007E02                 mov     edx, [ebp+arg_0]
.text$mn:00007E05                 mov     [ebp+var_4], edx
.text$mn:00007E08
.text$mn:00007E08 loc_7E08:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+48j
.text$mn:00007E08                 mov     eax, [ebp+var_4]
.text$mn:00007E0B                 mov     esp, ebp
.text$mn:00007E0D                 pop     ebp
.text$mn:00007E0E                 retn    4
.text$mn:00007E0E ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z endp
.text$mn:00007E0E
.text$mn:00007E0E ; ---------------------------------------------------------------------------
.text$mn:00007E11                 align 4
.text$mn:00007E11 _text$mn        ends
.text$mn:00007E11
.text$mn:00007E14 ; ===========================================================================
.text$mn:00007E14
.text$mn:00007E14 ; Segment type: Pure code
.text$mn:00007E14 ; Segment permissions: Read/Execute
.text$mn:00007E14 _text$mn        segment para public 'CODE' use32
.text$mn:00007E14                 assume cs:_text$mn
.text$mn:00007E14                 ;org 7E14h
.text$mn:00007E14 ; COMDAT (pick any)
.text$mn:00007E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E14
.text$mn:00007E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E14
.text$mn:00007E14 ; Attributes: bp-based frame
.text$mn:00007E14
.text$mn:00007E14 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00007E14                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00007E14 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00007E14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00007E14
.text$mn:00007E14 var_4           = dword ptr -4
.text$mn:00007E14 arg_0           = dword ptr  8
.text$mn:00007E14
.text$mn:00007E14                 push    ebp
.text$mn:00007E15                 mov     ebp, esp
.text$mn:00007E17                 push    ecx
.text$mn:00007E18                 mov     [ebp+var_4], ecx
.text$mn:00007E1B                 cmp     [ebp+arg_0], 0
.text$mn:00007E1F                 jz      short loc_7E41
.text$mn:00007E21                 mov     ecx, [ebp+var_4]
.text$mn:00007E24                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007E29                 cmp     [ebp+arg_0], eax
.text$mn:00007E2C                 jb      short loc_7E41
.text$mn:00007E2E                 mov     ecx, [ebp+var_4]
.text$mn:00007E31                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007E36                 mov     ecx, [ebp+var_4]
.text$mn:00007E39                 add     eax, [ecx+14h]
.text$mn:00007E3C                 cmp     eax, [ebp+arg_0]
.text$mn:00007E3F                 ja      short loc_7E47
.text$mn:00007E41
.text$mn:00007E41 loc_7E41:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00007E41                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00007E41                 xor     al, al
.text$mn:00007E43                 jmp     short loc_7E49
.text$mn:00007E45 ; ---------------------------------------------------------------------------
.text$mn:00007E45                 jmp     short loc_7E49
.text$mn:00007E47 ; ---------------------------------------------------------------------------
.text$mn:00007E47
.text$mn:00007E47 loc_7E47:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00007E47                 mov     al, 1
.text$mn:00007E49
.text$mn:00007E49 loc_7E49:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00007E49                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00007E49                 mov     esp, ebp
.text$mn:00007E4B                 pop     ebp
.text$mn:00007E4C                 retn    4
.text$mn:00007E4C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00007E4C
.text$mn:00007E4C ; ---------------------------------------------------------------------------
.text$mn:00007E4F                 align 10h
.text$mn:00007E4F _text$mn        ends
.text$mn:00007E4F
.text$mn:00007E50 ; ===========================================================================
.text$mn:00007E50
.text$mn:00007E50 ; Segment type: Pure code
.text$mn:00007E50 ; Segment permissions: Read/Execute
.text$mn:00007E50 _text$mn        segment para public 'CODE' use32
.text$mn:00007E50                 assume cs:_text$mn
.text$mn:00007E50                 ;org 7E50h
.text$mn:00007E50 ; COMDAT (pick any)
.text$mn:00007E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E50
.text$mn:00007E50 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E50
.text$mn:00007E50 ; Attributes: bp-based frame
.text$mn:00007E50
.text$mn:00007E50 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00007E50                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00007E50 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00007E50                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:00007E50                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap ...
.text$mn:00007E50
.text$mn:00007E50 var_4           = dword ptr -4
.text$mn:00007E50 arg_0           = dword ptr  8
.text$mn:00007E50
.text$mn:00007E50                 push    ebp
.text$mn:00007E51                 mov     ebp, esp
.text$mn:00007E53                 push    ecx
.text$mn:00007E54                 mov     [ebp+var_4], ecx
.text$mn:00007E57                 cmp     [ebp+arg_0], 0
.text$mn:00007E5B                 jz      short loc_7E80
.text$mn:00007E5D                 mov     ecx, [ebp+var_4]
.text$mn:00007E60                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007E65                 cmp     [ebp+arg_0], eax
.text$mn:00007E68                 jb      short loc_7E80
.text$mn:00007E6A                 mov     ecx, [ebp+var_4]
.text$mn:00007E6D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007E72                 mov     ecx, [ebp+var_4]
.text$mn:00007E75                 mov     edx, [ecx+14h]
.text$mn:00007E78                 lea     eax, [eax+edx*2]
.text$mn:00007E7B                 cmp     eax, [ebp+arg_0]
.text$mn:00007E7E                 ja      short loc_7E86
.text$mn:00007E80
.text$mn:00007E80 loc_7E80:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00007E80                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00007E80                 xor     al, al
.text$mn:00007E82                 jmp     short loc_7E88
.text$mn:00007E84 ; ---------------------------------------------------------------------------
.text$mn:00007E84                 jmp     short loc_7E88
.text$mn:00007E86 ; ---------------------------------------------------------------------------
.text$mn:00007E86
.text$mn:00007E86 loc_7E86:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00007E86                 mov     al, 1
.text$mn:00007E88
.text$mn:00007E88 loc_7E88:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00007E88                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00007E88                 mov     esp, ebp
.text$mn:00007E8A                 pop     ebp
.text$mn:00007E8B                 retn    4
.text$mn:00007E8B ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00007E8B
.text$mn:00007E8B ; ---------------------------------------------------------------------------
.text$mn:00007E8E                 align 10h
.text$mn:00007E8E _text$mn        ends
.text$mn:00007E8E
.text$mn:00007E90 ; ===========================================================================
.text$mn:00007E90
.text$mn:00007E90 ; Segment type: Pure code
.text$mn:00007E90 ; Segment permissions: Read/Execute
.text$mn:00007E90 _text$mn        segment para public 'CODE' use32
.text$mn:00007E90                 assume cs:_text$mn
.text$mn:00007E90                 ;org 7E90h
.text$mn:00007E90 ; COMDAT (pick any)
.text$mn:00007E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E90
.text$mn:00007E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E90
.text$mn:00007E90 ; Attributes: bp-based frame
.text$mn:00007E90
.text$mn:00007E90 ; protected: bool __thiscall std::vector<int, class std::allocator<int>>::_Inside(int const *)const
.text$mn:00007E90                 public ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
.text$mn:00007E90 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z proc near
.text$mn:00007E90                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+19p
.text$mn:00007E90
.text$mn:00007E90 var_8           = dword ptr -8
.text$mn:00007E90 var_4           = dword ptr -4
.text$mn:00007E90 arg_0           = dword ptr  8
.text$mn:00007E90
.text$mn:00007E90                 push    ebp
.text$mn:00007E91                 mov     ebp, esp
.text$mn:00007E93                 sub     esp, 8
.text$mn:00007E96                 mov     [ebp+var_4], ecx
.text$mn:00007E99                 mov     eax, [ebp+var_4]
.text$mn:00007E9C                 mov     ecx, [ebp+arg_0]
.text$mn:00007E9F                 cmp     ecx, [eax+8]
.text$mn:00007EA2                 jnb     short loc_7EB8
.text$mn:00007EA4                 mov     edx, [ebp+var_4]
.text$mn:00007EA7                 mov     eax, [edx+4]
.text$mn:00007EAA                 cmp     eax, [ebp+arg_0]
.text$mn:00007EAD                 ja      short loc_7EB8
.text$mn:00007EAF                 mov     [ebp+var_8], 1
.text$mn:00007EB6                 jmp     short loc_7EBF
.text$mn:00007EB8 ; ---------------------------------------------------------------------------
.text$mn:00007EB8
.text$mn:00007EB8 loc_7EB8:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+12j
.text$mn:00007EB8                                         ; std::vector<int,std::allocator<int>>::_Inside(int const *)+1Dj
.text$mn:00007EB8                 mov     [ebp+var_8], 0
.text$mn:00007EBF
.text$mn:00007EBF loc_7EBF:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+26j
.text$mn:00007EBF                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007EC2                 mov     esp, ebp
.text$mn:00007EC4                 pop     ebp
.text$mn:00007EC5                 retn    4
.text$mn:00007EC5 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z endp
.text$mn:00007EC5
.text$mn:00007EC5 _text$mn        ends
.text$mn:00007EC5
.text$mn:00007EC8 ; ===========================================================================
.text$mn:00007EC8
.text$mn:00007EC8 ; Segment type: Pure code
.text$mn:00007EC8 ; Segment permissions: Read/Execute
.text$mn:00007EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00007EC8                 assume cs:_text$mn
.text$mn:00007EC8                 ;org 7EC8h
.text$mn:00007EC8 ; COMDAT (pick any)
.text$mn:00007EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007EC8
.text$mn:00007EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EC8
.text$mn:00007EC8 ; Attributes: bp-based frame
.text$mn:00007EC8
.text$mn:00007EC8 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007EC8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00007EC8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00007EC8                                         ; CODE XREF: $LN19+14p
.text$mn:00007EC8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00007EC8
.text$mn:00007EC8 var_8           = dword ptr -8
.text$mn:00007EC8 var_4           = dword ptr -4
.text$mn:00007EC8
.text$mn:00007EC8                 push    ebp
.text$mn:00007EC9                 mov     ebp, esp
.text$mn:00007ECB                 sub     esp, 8
.text$mn:00007ECE                 mov     [ebp+var_4], ecx
.text$mn:00007ED1                 mov     eax, [ebp+var_4]
.text$mn:00007ED4                 cmp     dword ptr [eax+18h], 10h
.text$mn:00007ED8                 jb      short loc_7EEE
.text$mn:00007EDA                 mov     ecx, [ebp+var_4]
.text$mn:00007EDD                 mov     edx, [ecx+4]
.text$mn:00007EE0                 push    edx
.text$mn:00007EE1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00007EE6                 add     esp, 4
.text$mn:00007EE9                 mov     [ebp+var_8], eax
.text$mn:00007EEC                 jmp     short loc_7EF7
.text$mn:00007EEE ; ---------------------------------------------------------------------------
.text$mn:00007EEE
.text$mn:00007EEE loc_7EEE:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00007EEE                 mov     eax, [ebp+var_4]
.text$mn:00007EF1                 add     eax, 4
.text$mn:00007EF4                 mov     [ebp+var_8], eax
.text$mn:00007EF7
.text$mn:00007EF7 loc_7EF7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00007EF7                 mov     eax, [ebp+var_8]
.text$mn:00007EFA                 mov     esp, ebp
.text$mn:00007EFC                 pop     ebp
.text$mn:00007EFD                 retn
.text$mn:00007EFD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00007EFD
.text$mn:00007EFD ; ---------------------------------------------------------------------------
.text$mn:00007EFE                 align 10h
.text$mn:00007EFE _text$mn        ends
.text$mn:00007EFE
.text$mn:00007F00 ; ===========================================================================
.text$mn:00007F00
.text$mn:00007F00 ; Segment type: Pure code
.text$mn:00007F00 ; Segment permissions: Read/Execute
.text$mn:00007F00 _text$mn        segment para public 'CODE' use32
.text$mn:00007F00                 assume cs:_text$mn
.text$mn:00007F00                 ;org 7F00h
.text$mn:00007F00 ; COMDAT (pick any)
.text$mn:00007F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F00
.text$mn:00007F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F00
.text$mn:00007F00 ; Attributes: bp-based frame
.text$mn:00007F00
.text$mn:00007F00 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00007F00                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00007F00 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00007F00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00007F00
.text$mn:00007F00 var_8           = dword ptr -8
.text$mn:00007F00 var_4           = dword ptr -4
.text$mn:00007F00
.text$mn:00007F00                 push    ebp
.text$mn:00007F01                 mov     ebp, esp
.text$mn:00007F03                 sub     esp, 8
.text$mn:00007F06                 mov     [ebp+var_4], ecx
.text$mn:00007F09                 mov     eax, [ebp+var_4]
.text$mn:00007F0C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00007F10                 jb      short loc_7F26
.text$mn:00007F12                 mov     ecx, [ebp+var_4]
.text$mn:00007F15                 mov     edx, [ecx+4]
.text$mn:00007F18                 push    edx
.text$mn:00007F19                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00007F1E                 add     esp, 4
.text$mn:00007F21                 mov     [ebp+var_8], eax
.text$mn:00007F24                 jmp     short loc_7F2F
.text$mn:00007F26 ; ---------------------------------------------------------------------------
.text$mn:00007F26
.text$mn:00007F26 loc_7F26:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00007F26                 mov     eax, [ebp+var_4]
.text$mn:00007F29                 add     eax, 4
.text$mn:00007F2C                 mov     [ebp+var_8], eax
.text$mn:00007F2F
.text$mn:00007F2F loc_7F2F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00007F2F                 mov     eax, [ebp+var_8]
.text$mn:00007F32                 mov     esp, ebp
.text$mn:00007F34                 pop     ebp
.text$mn:00007F35                 retn
.text$mn:00007F35 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00007F35
.text$mn:00007F35 ; ---------------------------------------------------------------------------
.text$mn:00007F36                 align 4
.text$mn:00007F36 _text$mn        ends
.text$mn:00007F36
.text$mn:00007F38 ; ===========================================================================
.text$mn:00007F38
.text$mn:00007F38 ; Segment type: Pure code
.text$mn:00007F38 ; Segment permissions: Read/Execute
.text$mn:00007F38 _text$mn        segment para public 'CODE' use32
.text$mn:00007F38                 assume cs:_text$mn
.text$mn:00007F38                 ;org 7F38h
.text$mn:00007F38 ; COMDAT (pick any)
.text$mn:00007F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F38
.text$mn:00007F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F38
.text$mn:00007F38 ; Attributes: bp-based frame
.text$mn:00007F38
.text$mn:00007F38 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007F38                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00007F38 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00007F38                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+14p
.text$mn:00007F38                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+36p ...
.text$mn:00007F38
.text$mn:00007F38 var_8           = dword ptr -8
.text$mn:00007F38 var_4           = dword ptr -4
.text$mn:00007F38
.text$mn:00007F38                 push    ebp
.text$mn:00007F39                 mov     ebp, esp
.text$mn:00007F3B                 sub     esp, 8
.text$mn:00007F3E                 mov     [ebp+var_4], ecx
.text$mn:00007F41                 mov     eax, [ebp+var_4]
.text$mn:00007F44                 cmp     dword ptr [eax+18h], 8
.text$mn:00007F48                 jb      short loc_7F5E
.text$mn:00007F4A                 mov     ecx, [ebp+var_4]
.text$mn:00007F4D                 mov     edx, [ecx+4]
.text$mn:00007F50                 push    edx
.text$mn:00007F51                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00007F56                 add     esp, 4
.text$mn:00007F59                 mov     [ebp+var_8], eax
.text$mn:00007F5C                 jmp     short loc_7F67
.text$mn:00007F5E ; ---------------------------------------------------------------------------
.text$mn:00007F5E
.text$mn:00007F5E loc_7F5E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00007F5E                 mov     eax, [ebp+var_4]
.text$mn:00007F61                 add     eax, 4
.text$mn:00007F64                 mov     [ebp+var_8], eax
.text$mn:00007F67
.text$mn:00007F67 loc_7F67:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00007F67                 mov     eax, [ebp+var_8]
.text$mn:00007F6A                 mov     esp, ebp
.text$mn:00007F6C                 pop     ebp
.text$mn:00007F6D                 retn
.text$mn:00007F6D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00007F6D
.text$mn:00007F6D ; ---------------------------------------------------------------------------
.text$mn:00007F6E                 align 10h
.text$mn:00007F6E _text$mn        ends
.text$mn:00007F6E
.text$mn:00007F70 ; ===========================================================================
.text$mn:00007F70
.text$mn:00007F70 ; Segment type: Pure code
.text$mn:00007F70 ; Segment permissions: Read/Execute
.text$mn:00007F70 _text$mn        segment para public 'CODE' use32
.text$mn:00007F70                 assume cs:_text$mn
.text$mn:00007F70                 ;org 7F70h
.text$mn:00007F70 ; COMDAT (pick any)
.text$mn:00007F70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F70
.text$mn:00007F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F70
.text$mn:00007F70 ; Attributes: bp-based frame
.text$mn:00007F70
.text$mn:00007F70 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00007F70                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00007F70 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00007F70                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p
.text$mn:00007F70                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:00007F70
.text$mn:00007F70 var_8           = dword ptr -8
.text$mn:00007F70 var_4           = dword ptr -4
.text$mn:00007F70
.text$mn:00007F70                 push    ebp
.text$mn:00007F71                 mov     ebp, esp
.text$mn:00007F73                 sub     esp, 8
.text$mn:00007F76                 mov     [ebp+var_4], ecx
.text$mn:00007F79                 mov     eax, [ebp+var_4]
.text$mn:00007F7C                 cmp     dword ptr [eax+18h], 8
.text$mn:00007F80                 jb      short loc_7F96
.text$mn:00007F82                 mov     ecx, [ebp+var_4]
.text$mn:00007F85                 mov     edx, [ecx+4]
.text$mn:00007F88                 push    edx
.text$mn:00007F89                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00007F8E                 add     esp, 4
.text$mn:00007F91                 mov     [ebp+var_8], eax
.text$mn:00007F94                 jmp     short loc_7F9F
.text$mn:00007F96 ; ---------------------------------------------------------------------------
.text$mn:00007F96
.text$mn:00007F96 loc_7F96:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00007F96                 mov     eax, [ebp+var_4]
.text$mn:00007F99                 add     eax, 4
.text$mn:00007F9C                 mov     [ebp+var_8], eax
.text$mn:00007F9F
.text$mn:00007F9F loc_7F9F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00007F9F                 mov     eax, [ebp+var_8]
.text$mn:00007FA2                 mov     esp, ebp
.text$mn:00007FA4                 pop     ebp
.text$mn:00007FA5                 retn
.text$mn:00007FA5 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00007FA5
.text$mn:00007FA5 ; ---------------------------------------------------------------------------
.text$mn:00007FA6                 align 4
.text$mn:00007FA6 _text$mn        ends
.text$mn:00007FA6
.text$mn:00007FA8 ; ===========================================================================
.text$mn:00007FA8
.text$mn:00007FA8 ; Segment type: Pure code
.text$mn:00007FA8 ; Segment permissions: Read/Execute
.text$mn:00007FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00007FA8                 assume cs:_text$mn
.text$mn:00007FA8                 ;org 7FA8h
.text$mn:00007FA8 ; COMDAT (pick any)
.text$mn:00007FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FA8
.text$mn:00007FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FA8
.text$mn:00007FA8 ; Attributes: bp-based frame
.text$mn:00007FA8
.text$mn:00007FA8 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00007FA8                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00007FA8 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00007FA8                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00007FA8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00007FA8
.text$mn:00007FA8 var_18          = byte ptr -18h
.text$mn:00007FA8 var_14          = dword ptr -14h
.text$mn:00007FA8 var_10          = dword ptr -10h
.text$mn:00007FA8 var_C           = dword ptr -0Ch
.text$mn:00007FA8 var_4           = dword ptr -4
.text$mn:00007FA8
.text$mn:00007FA8                 push    ebp
.text$mn:00007FA9                 mov     ebp, esp
.text$mn:00007FAB                 push    0FFFFFFFFh
.text$mn:00007FAD                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00007FB2                 mov     eax, large fs:0
.text$mn:00007FB8                 push    eax
.text$mn:00007FB9                 sub     esp, 0Ch
.text$mn:00007FBC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007FC1                 xor     eax, ebp
.text$mn:00007FC3                 push    eax
.text$mn:00007FC4                 lea     eax, [ebp+var_C]
.text$mn:00007FC7                 mov     large fs:0, eax
.text$mn:00007FCD                 mov     [ebp+var_14], ecx
.text$mn:00007FD0                 mov     eax, [ebp+var_14]
.text$mn:00007FD3                 cmp     dword ptr [eax], 0
.text$mn:00007FD6                 jz      short loc_8033
.text$mn:00007FD8                 push    3               ; int
.text$mn:00007FDA                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007FDD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007FE2                 mov     [ebp+var_4], 0
.text$mn:00007FE9                 mov     ecx, [ebp+var_14]
.text$mn:00007FEC                 mov     edx, [ecx]
.text$mn:00007FEE                 add     edx, 4
.text$mn:00007FF1                 mov     [ebp+var_10], edx
.text$mn:00007FF4                 jmp     short loc_8003
.text$mn:00007FF6 ; ---------------------------------------------------------------------------
.text$mn:00007FF6
.text$mn:00007FF6 loc_7FF6:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00007FF6                 mov     eax, [ebp+var_10]
.text$mn:00007FF9                 mov     ecx, [eax]
.text$mn:00007FFB                 mov     edx, [ebp+var_10]
.text$mn:00007FFE                 mov     eax, [ecx+4]
.text$mn:00008001                 mov     [edx], eax
.text$mn:00008003
.text$mn:00008003 loc_8003:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00008003                 mov     ecx, [ebp+var_10]
.text$mn:00008006                 cmp     dword ptr [ecx], 0
.text$mn:00008009                 jz      short loc_8018
.text$mn:0000800B                 mov     edx, [ebp+var_10]
.text$mn:0000800E                 mov     eax, [edx]
.text$mn:00008010                 mov     dword ptr [eax], 0
.text$mn:00008016                 jmp     short loc_7FF6
.text$mn:00008018 ; ---------------------------------------------------------------------------
.text$mn:00008018
.text$mn:00008018 loc_8018:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00008018                 mov     ecx, [ebp+var_14]
.text$mn:0000801B                 mov     edx, [ecx]
.text$mn:0000801D                 mov     dword ptr [edx+4], 0
.text$mn:00008024                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000802B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000802E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008033
.text$mn:00008033 loc_8033:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00008033                 mov     ecx, [ebp+var_C]
.text$mn:00008036                 mov     large fs:0, ecx
.text$mn:0000803D                 pop     ecx
.text$mn:0000803E                 mov     esp, ebp
.text$mn:00008040                 pop     ebp
.text$mn:00008041                 retn
.text$mn:00008041 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00008041
.text$mn:00008041 ; ---------------------------------------------------------------------------
.text$mn:00008042                 align 4
.text$mn:00008042 _text$mn        ends
.text$mn:00008042
.text$x:00008044 ; ===========================================================================
.text$x:00008044
.text$x:00008044 ; Segment type: Pure code
.text$x:00008044 ; Segment permissions: Read/Execute
.text$x:00008044 _text$x         segment para public 'CODE' use32
.text$x:00008044                 assume cs:_text$x
.text$x:00008044                 ;org 8044h
.text$x:00008044 ; COMDAT (pick associative to section at 7FA8)
.text$x:00008044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008044
.text$x:00008044 ; =============== S U B R O U T I N E =======================================
.text$x:00008044
.text$x:00008044
.text$x:00008044 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00008044                                         ; DATA XREF: .xdata$x:00009E50o
.text$x:00008044                 lea     ecx, [ebp-18h]  ; this
.text$x:00008047                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008047 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00008047
.text$x:0000804C
.text$x:0000804C ; =============== S U B R O U T I N E =======================================
.text$x:0000804C
.text$x:0000804C
.text$x:0000804C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:0000804C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:0000804C
.text$x:0000804C arg_4           = dword ptr  8
.text$x:0000804C
.text$x:0000804C                 mov     edx, [esp+arg_4]
.text$x:00008050                 lea     eax, [edx+0Ch]
.text$x:00008053                 mov     ecx, [edx-10h]
.text$x:00008056                 xor     ecx, eax
.text$x:00008058                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000805D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00008062                 jmp     ___CxxFrameHandler3
.text$x:00008062 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00008062
.text$x:00008062 ; ---------------------------------------------------------------------------
.text$x:00008067                 align 4
.text$x:00008067 _text$x         ends
.text$x:00008067
.text$mn:00008068 ; ===========================================================================
.text$mn:00008068
.text$mn:00008068 ; Segment type: Pure code
.text$mn:00008068 ; Segment permissions: Read/Execute
.text$mn:00008068 _text$mn        segment para public 'CODE' use32
.text$mn:00008068                 assume cs:_text$mn
.text$mn:00008068                 ;org 8068h
.text$mn:00008068 ; COMDAT (pick any)
.text$mn:00008068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008068
.text$mn:00008068 ; =============== S U B R O U T I N E =======================================
.text$mn:00008068
.text$mn:00008068 ; Attributes: bp-based frame
.text$mn:00008068
.text$mn:00008068 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00008068                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00008068 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00008068                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00008068                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00008068
.text$mn:00008068 var_8           = dword ptr -8
.text$mn:00008068 var_4           = dword ptr -4
.text$mn:00008068
.text$mn:00008068                 push    ebp
.text$mn:00008069                 mov     ebp, esp
.text$mn:0000806B                 sub     esp, 8
.text$mn:0000806E                 mov     [ebp+var_8], ecx
.text$mn:00008071                 mov     eax, [ebp+var_8]
.text$mn:00008074                 cmp     dword ptr [eax], 0
.text$mn:00008077                 jz      short loc_80D6
.text$mn:00008079                 mov     ecx, [ebp+var_8]
.text$mn:0000807C                 mov     edx, [ecx]
.text$mn:0000807E                 add     edx, 4
.text$mn:00008081                 mov     [ebp+var_4], edx
.text$mn:00008084
.text$mn:00008084 loc_8084:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:00008084                 mov     eax, [ebp+var_4]
.text$mn:00008087                 cmp     dword ptr [eax], 0
.text$mn:0000808A                 jz      short loc_80A3
.text$mn:0000808C                 mov     ecx, [ebp+var_4]
.text$mn:0000808F                 mov     edx, [ecx]
.text$mn:00008091                 cmp     edx, [ebp+var_8]
.text$mn:00008094                 jz      short loc_80A3
.text$mn:00008096                 mov     eax, [ebp+var_4]
.text$mn:00008099                 mov     ecx, [eax]
.text$mn:0000809B                 add     ecx, 4
.text$mn:0000809E                 mov     [ebp+var_4], ecx
.text$mn:000080A1                 jmp     short loc_8084
.text$mn:000080A3 ; ---------------------------------------------------------------------------
.text$mn:000080A3
.text$mn:000080A3 loc_80A3:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:000080A3                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:000080A3                 mov     edx, [ebp+var_4]
.text$mn:000080A6                 cmp     dword ptr [edx], 0
.text$mn:000080A9                 jnz     short loc_80C2
.text$mn:000080AB                 push    0C9h ; '+'      ; unsigned int
.text$mn:000080B0                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000080B5                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:000080BA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000080BF                 add     esp, 0Ch
.text$mn:000080C2
.text$mn:000080C2 loc_80C2:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:000080C2                 mov     eax, [ebp+var_4]
.text$mn:000080C5                 mov     ecx, [ebp+var_8]
.text$mn:000080C8                 mov     edx, [ecx+4]
.text$mn:000080CB                 mov     [eax], edx
.text$mn:000080CD                 mov     eax, [ebp+var_8]
.text$mn:000080D0                 mov     dword ptr [eax], 0
.text$mn:000080D6
.text$mn:000080D6 loc_80D6:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:000080D6                 mov     esp, ebp
.text$mn:000080D8                 pop     ebp
.text$mn:000080D9                 retn
.text$mn:000080D9 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:000080D9
.text$mn:000080D9 ; ---------------------------------------------------------------------------
.text$mn:000080DA                 align 4
.text$mn:000080DA _text$mn        ends
.text$mn:000080DA
.text$mn:000080DC ; ===========================================================================
.text$mn:000080DC
.text$mn:000080DC ; Segment type: Pure code
.text$mn:000080DC ; Segment permissions: Read/Execute
.text$mn:000080DC _text$mn        segment para public 'CODE' use32
.text$mn:000080DC                 assume cs:_text$mn
.text$mn:000080DC                 ;org 80DCh
.text$mn:000080DC ; COMDAT (pick any)
.text$mn:000080DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000080DC
.text$mn:000080DC ; =============== S U B R O U T I N E =======================================
.text$mn:000080DC
.text$mn:000080DC ; Attributes: bp-based frame
.text$mn:000080DC
.text$mn:000080DC ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Orphan_range(int *, int *)const
.text$mn:000080DC                 public ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:000080DC ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$mn:000080DC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+66p
.text$mn:000080DC                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+CCp
.text$mn:000080DC
.text$mn:000080DC var_18          = byte ptr -18h
.text$mn:000080DC var_14          = dword ptr -14h
.text$mn:000080DC var_10          = dword ptr -10h
.text$mn:000080DC var_C           = dword ptr -0Ch
.text$mn:000080DC var_4           = dword ptr -4
.text$mn:000080DC arg_0           = dword ptr  8
.text$mn:000080DC arg_4           = dword ptr  0Ch
.text$mn:000080DC
.text$mn:000080DC                 push    ebp
.text$mn:000080DD                 mov     ebp, esp
.text$mn:000080DF                 push    0FFFFFFFFh
.text$mn:000080E1                 push    offset __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:000080E6                 mov     eax, large fs:0
.text$mn:000080EC                 push    eax
.text$mn:000080ED                 sub     esp, 0Ch
.text$mn:000080F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000080F5                 xor     eax, ebp
.text$mn:000080F7                 push    eax
.text$mn:000080F8                 lea     eax, [ebp+var_C]
.text$mn:000080FB                 mov     large fs:0, eax
.text$mn:00008101                 mov     [ebp+var_14], ecx
.text$mn:00008104                 push    3               ; int
.text$mn:00008106                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008109                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000810E                 mov     [ebp+var_4], 0
.text$mn:00008115                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008118                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000811D                 mov     [ebp+var_10], eax
.text$mn:00008120                 cmp     [ebp+var_10], 0
.text$mn:00008124                 jz      short loc_8174
.text$mn:00008126
.text$mn:00008126 loc_8126:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *):loc_8172j
.text$mn:00008126                 mov     eax, [ebp+var_10]
.text$mn:00008129                 cmp     dword ptr [eax], 0
.text$mn:0000812C                 jz      short loc_8174
.text$mn:0000812E                 mov     ecx, [ebp+var_10]
.text$mn:00008131                 mov     edx, [ecx]
.text$mn:00008133                 mov     eax, [edx+8]
.text$mn:00008136                 cmp     eax, [ebp+arg_0]
.text$mn:00008139                 jb      short loc_8148
.text$mn:0000813B                 mov     ecx, [ebp+var_10]
.text$mn:0000813E                 mov     edx, [ecx]
.text$mn:00008140                 mov     eax, [ebp+arg_4]
.text$mn:00008143                 cmp     eax, [edx+8]
.text$mn:00008146                 jnb     short loc_8157
.text$mn:00008148
.text$mn:00008148 loc_8148:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5Dj
.text$mn:00008148                 mov     ecx, [ebp+var_10]
.text$mn:0000814B                 mov     ecx, [ecx]      ; this
.text$mn:0000814D                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008152                 mov     [ebp+var_10], eax
.text$mn:00008155                 jmp     short loc_8172
.text$mn:00008157 ; ---------------------------------------------------------------------------
.text$mn:00008157
.text$mn:00008157 loc_8157:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+6Aj
.text$mn:00008157                 mov     edx, [ebp+var_10]
.text$mn:0000815A                 mov     ecx, [edx]      ; this
.text$mn:0000815C                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008161                 mov     eax, [ebp+var_10]
.text$mn:00008164                 mov     ecx, [eax]      ; this
.text$mn:00008166                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000816B                 mov     ecx, [ebp+var_10]
.text$mn:0000816E                 mov     edx, [eax]
.text$mn:00008170                 mov     [ecx], edx
.text$mn:00008172
.text$mn:00008172 loc_8172:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+79j
.text$mn:00008172                 jmp     short loc_8126
.text$mn:00008174 ; ---------------------------------------------------------------------------
.text$mn:00008174
.text$mn:00008174 loc_8174:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+48j
.text$mn:00008174                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+50j
.text$mn:00008174                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000817B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000817E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008183                 mov     ecx, [ebp+var_C]
.text$mn:00008186                 mov     large fs:0, ecx
.text$mn:0000818D                 pop     ecx
.text$mn:0000818E                 mov     esp, ebp
.text$mn:00008190                 pop     ebp
.text$mn:00008191                 retn    8
.text$mn:00008191 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$mn:00008191
.text$mn:00008191 _text$mn        ends
.text$mn:00008191
.text$x:00008194 ; ===========================================================================
.text$x:00008194
.text$x:00008194 ; Segment type: Pure code
.text$x:00008194 ; Segment permissions: Read/Execute
.text$x:00008194 _text$x         segment para public 'CODE' use32
.text$x:00008194                 assume cs:_text$x
.text$x:00008194                 ;org 8194h
.text$x:00008194 ; COMDAT (pick associative to section at 80DC)
.text$x:00008194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008194
.text$x:00008194 ; =============== S U B R O U T I N E =======================================
.text$x:00008194
.text$x:00008194
.text$x:00008194 __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 proc near
.text$x:00008194                                         ; DATA XREF: .xdata$x:0000A6D8o
.text$x:00008194                 lea     ecx, [ebp-18h]  ; this
.text$x:00008197                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008197 __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 endp
.text$x:00008197
.text$x:0000819C
.text$x:0000819C ; =============== S U B R O U T I N E =======================================
.text$x:0000819C
.text$x:0000819C
.text$x:0000819C __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$x:0000819C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5o
.text$x:0000819C
.text$x:0000819C arg_4           = dword ptr  8
.text$x:0000819C
.text$x:0000819C                 mov     edx, [esp+arg_4]
.text$x:000081A0                 lea     eax, [edx+0Ch]
.text$x:000081A3                 mov     ecx, [edx-10h]
.text$x:000081A6                 xor     ecx, eax
.text$x:000081A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000081AD                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$x:000081B2                 jmp     ___CxxFrameHandler3
.text$x:000081B2 __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$x:000081B2
.text$x:000081B2 ; ---------------------------------------------------------------------------
.text$x:000081B7                 align 4
.text$x:000081B7 _text$x         ends
.text$x:000081B7
.text$mn:000081B8 ; ===========================================================================
.text$mn:000081B8
.text$mn:000081B8 ; Segment type: Pure code
.text$mn:000081B8 ; Segment permissions: Read/Execute
.text$mn:000081B8 _text$mn        segment para public 'CODE' use32
.text$mn:000081B8                 assume cs:_text$mn
.text$mn:000081B8                 ;org 81B8h
.text$mn:000081B8 ; COMDAT (pick any)
.text$mn:000081B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081B8
.text$mn:000081B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000081B8
.text$mn:000081B8 ; Attributes: bp-based frame
.text$mn:000081B8
.text$mn:000081B8 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reallocate(unsigned int)
.text$mn:000081B8                 public ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:000081B8 ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:000081B8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+4Ep
.text$mn:000081B8
.text$mn:000081B8 var_20          = dword ptr -20h
.text$mn:000081B8 var_1C          = dword ptr -1Ch
.text$mn:000081B8 var_18          = dword ptr -18h
.text$mn:000081B8 var_13          = byte ptr -13h
.text$mn:000081B8 var_11          = byte ptr -11h
.text$mn:000081B8 var_10          = dword ptr -10h
.text$mn:000081B8 var_C           = dword ptr -0Ch
.text$mn:000081B8 var_4           = dword ptr -4
.text$mn:000081B8 arg_0           = dword ptr  8
.text$mn:000081B8
.text$mn:000081B8 ; FUNCTION CHUNK AT .text$mn:0000824E SIZE 00000009 BYTES
.text$mn:000081B8 ; FUNCTION CHUNK AT .text$mn:0000825E SIZE 00000097 BYTES
.text$mn:000081B8
.text$mn:000081B8                 push    ebp
.text$mn:000081B9                 mov     ebp, esp
.text$mn:000081BB                 push    0FFFFFFFFh
.text$mn:000081BD                 push    offset __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:000081C2                 mov     eax, large fs:0
.text$mn:000081C8                 push    eax
.text$mn:000081C9                 push    ecx
.text$mn:000081CA                 sub     esp, 10h
.text$mn:000081CD                 push    ebx
.text$mn:000081CE                 push    esi
.text$mn:000081CF                 push    edi
.text$mn:000081D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000081D5                 xor     eax, ebp
.text$mn:000081D7                 push    eax
.text$mn:000081D8                 lea     eax, [ebp+var_C]
.text$mn:000081DB                 mov     large fs:0, eax
.text$mn:000081E1                 mov     [ebp+var_10], esp
.text$mn:000081E4                 mov     [ebp+var_18], ecx
.text$mn:000081E7                 mov     eax, [ebp+arg_0]
.text$mn:000081EA                 push    eax
.text$mn:000081EB                 lea     ecx, [ebp+var_11]
.text$mn:000081EE                 push    ecx
.text$mn:000081EF                 mov     ecx, [ebp+var_18]
.text$mn:000081F2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:000081F7                 mov     ecx, eax
.text$mn:000081F9                 call    ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::allocate(uint)
.text$mn:000081FE                 mov     [ebp+var_1C], eax
.text$mn:00008201                 mov     [ebp+var_4], 0
.text$mn:00008208                 mov     edx, [ebp+var_1C]
.text$mn:0000820B                 push    edx
.text$mn:0000820C                 mov     eax, [ebp+var_18]
.text$mn:0000820F                 mov     ecx, [eax+8]
.text$mn:00008212                 push    ecx
.text$mn:00008213                 mov     edx, [ebp+var_18]
.text$mn:00008216                 mov     eax, [edx+4]
.text$mn:00008219                 push    eax
.text$mn:0000821A                 mov     ecx, [ebp+var_18]
.text$mn:0000821D                 call    ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)
.text$mn:00008222                 jmp     short loc_824E
.text$mn:00008222 ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:00008222
.text$mn:00008224
.text$mn:00008224 ; =============== S U B R O U T I N E =======================================
.text$mn:00008224
.text$mn:00008224 ; Attributes: noreturn
.text$mn:00008224
.text$mn:00008224 __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00008224                                         ; DATA XREF: .xdata$x:0000A688o
.text$mn:00008224                 mov     ecx, [ebp+8]
.text$mn:00008227                 push    ecx             ; int
.text$mn:00008228                 mov     edx, [ebp-1Ch]
.text$mn:0000822B                 push    edx             ; void *
.text$mn:0000822C                 lea     eax, [ebp-12h]
.text$mn:0000822F                 push    eax
.text$mn:00008230                 mov     ecx, [ebp-18h]
.text$mn:00008233                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00008238                 mov     ecx, eax
.text$mn:0000823A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:0000823F                 push    0
.text$mn:00008241                 push    0
.text$mn:00008243                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008243 __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 endp
.text$mn:00008243
.text$mn:00008248 ; ---------------------------------------------------------------------------
.text$mn:00008248                 mov     eax, offset $LN8
.text$mn:0000824D                 retn
.text$mn:0000824E ; ---------------------------------------------------------------------------
.text$mn:0000824E ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000824E
.text$mn:0000824E loc_824E:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+6Aj
.text$mn:0000824E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008255                 jmp     short loc_825E
.text$mn:00008255 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00008257
.text$mn:00008257 ; =============== S U B R O U T I N E =======================================
.text$mn:00008257
.text$mn:00008257
.text$mn:00008257 $LN8            proc near               ; DATA XREF: .text$mn:00008248o
.text$mn:00008257                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00008257 $LN8            endp ; sp-analysis failed
.text$mn:00008257
.text$mn:0000825E ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000825E
.text$mn:0000825E loc_825E:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+9Dj
.text$mn:0000825E                 mov     ecx, [ebp+var_18]
.text$mn:00008261                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00008266                 mov     [ebp+var_20], eax
.text$mn:00008269                 mov     ecx, [ebp+var_18]
.text$mn:0000826C                 cmp     dword ptr [ecx+4], 0
.text$mn:00008270                 jz      short loc_82B2
.text$mn:00008272                 mov     edx, [ebp+var_18]
.text$mn:00008275                 mov     eax, [edx+8]
.text$mn:00008278                 push    eax
.text$mn:00008279                 mov     ecx, [ebp+var_18]
.text$mn:0000827C                 mov     edx, [ecx+4]
.text$mn:0000827F                 push    edx
.text$mn:00008280                 mov     ecx, [ebp+var_18]
.text$mn:00008283                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:00008288                 mov     eax, [ebp+var_18]
.text$mn:0000828B                 mov     ecx, [ebp+var_18]
.text$mn:0000828E                 mov     edx, [eax+0Ch]
.text$mn:00008291                 sub     edx, [ecx+4]
.text$mn:00008294                 sar     edx, 2
.text$mn:00008297                 push    edx             ; int
.text$mn:00008298                 mov     eax, [ebp+var_18]
.text$mn:0000829B                 mov     ecx, [eax+4]
.text$mn:0000829E                 push    ecx             ; void *
.text$mn:0000829F                 lea     edx, [ebp+var_13]
.text$mn:000082A2                 push    edx
.text$mn:000082A3                 mov     ecx, [ebp+var_18]
.text$mn:000082A6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:000082AB                 mov     ecx, eax
.text$mn:000082AD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:000082B2
.text$mn:000082B2 loc_82B2:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+B8j
.text$mn:000082B2                 mov     ecx, [ebp+var_18] ; this
.text$mn:000082B5                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000082BA                 mov     eax, [ebp+arg_0]
.text$mn:000082BD                 mov     ecx, [ebp+var_1C]
.text$mn:000082C0                 lea     edx, [ecx+eax*4]
.text$mn:000082C3                 mov     eax, [ebp+var_18]
.text$mn:000082C6                 mov     [eax+0Ch], edx
.text$mn:000082C9                 mov     ecx, [ebp+var_20]
.text$mn:000082CC                 mov     edx, [ebp+var_1C]
.text$mn:000082CF                 lea     eax, [edx+ecx*4]
.text$mn:000082D2                 mov     ecx, [ebp+var_18]
.text$mn:000082D5                 mov     [ecx+8], eax
.text$mn:000082D8                 mov     edx, [ebp+var_18]
.text$mn:000082DB                 mov     eax, [ebp+var_1C]
.text$mn:000082DE                 mov     [edx+4], eax
.text$mn:000082E1                 mov     ecx, [ebp+var_C]
.text$mn:000082E4                 mov     large fs:0, ecx
.text$mn:000082EB                 pop     ecx
.text$mn:000082EC                 pop     edi
.text$mn:000082ED                 pop     esi
.text$mn:000082EE                 pop     ebx
.text$mn:000082EF                 mov     esp, ebp
.text$mn:000082F1                 pop     ebp
.text$mn:000082F2                 retn    4
.text$mn:000082F2 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:000082F2 ; ---------------------------------------------------------------------------
.text$mn:000082F5                 align 4
.text$mn:000082F5 _text$mn        ends
.text$mn:000082F5
.text$x:000082F8 ; ===========================================================================
.text$x:000082F8
.text$x:000082F8 ; Segment type: Pure code
.text$x:000082F8 ; Segment permissions: Read/Execute
.text$x:000082F8 _text$x         segment para public 'CODE' use32
.text$x:000082F8                 assume cs:_text$x
.text$x:000082F8                 ;org 82F8h
.text$x:000082F8 ; COMDAT (pick associative to section at 81B8)
.text$x:000082F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000082F8
.text$x:000082F8 ; =============== S U B R O U T I N E =======================================
.text$x:000082F8
.text$x:000082F8
.text$x:000082F8 __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$x:000082F8                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+5o
.text$x:000082F8
.text$x:000082F8 arg_4           = dword ptr  8
.text$x:000082F8
.text$x:000082F8                 mov     edx, [esp+arg_4]
.text$x:000082FC                 lea     eax, [edx+0Ch]
.text$x:000082FF                 mov     ecx, [edx-24h]
.text$x:00008302                 xor     ecx, eax
.text$x:00008304                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008309                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$x:0000830E                 jmp     ___CxxFrameHandler3
.text$x:0000830E __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$x:0000830E
.text$x:0000830E ; ---------------------------------------------------------------------------
.text$x:00008313                 align 4
.text$x:00008313 _text$x         ends
.text$x:00008313
.text$mn:00008314 ; ===========================================================================
.text$mn:00008314
.text$mn:00008314 ; Segment type: Pure code
.text$mn:00008314 ; Segment permissions: Read/Execute
.text$mn:00008314 _text$mn        segment para public 'CODE' use32
.text$mn:00008314                 assume cs:_text$mn
.text$mn:00008314                 ;org 8314h
.text$mn:00008314 ; COMDAT (pick any)
.text$mn:00008314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008314
.text$mn:00008314 ; =============== S U B R O U T I N E =======================================
.text$mn:00008314
.text$mn:00008314 ; Attributes: bp-based frame
.text$mn:00008314
.text$mn:00008314 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reserve(unsigned int)
.text$mn:00008314                 public ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00008314 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:00008314                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+50p
.text$mn:00008314                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+B6p
.text$mn:00008314
.text$mn:00008314 var_4           = dword ptr -4
.text$mn:00008314 arg_0           = dword ptr  8
.text$mn:00008314
.text$mn:00008314                 push    ebp
.text$mn:00008315                 mov     ebp, esp
.text$mn:00008317                 push    ecx
.text$mn:00008318                 push    esi
.text$mn:00008319                 mov     [ebp+var_4], ecx
.text$mn:0000831C                 mov     ecx, [ebp+var_4]
.text$mn:0000831F                 call    ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::_Unused_capacity(void)
.text$mn:00008324                 cmp     eax, [ebp+arg_0]
.text$mn:00008327                 jnb     short loc_8367
.text$mn:00008329                 mov     ecx, [ebp+var_4]
.text$mn:0000832C                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:00008331                 mov     esi, eax
.text$mn:00008333                 mov     ecx, [ebp+var_4]
.text$mn:00008336                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:0000833B                 sub     esi, eax
.text$mn:0000833D                 cmp     esi, [ebp+arg_0]
.text$mn:00008340                 jnb     short loc_834A
.text$mn:00008342                 mov     ecx, [ebp+var_4]
.text$mn:00008345                 call    ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int>>::_Xlen(void)
.text$mn:0000834A
.text$mn:0000834A loc_834A:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+2Cj
.text$mn:0000834A                 mov     ecx, [ebp+var_4]
.text$mn:0000834D                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00008352                 add     eax, [ebp+arg_0]
.text$mn:00008355                 push    eax
.text$mn:00008356                 mov     ecx, [ebp+var_4]
.text$mn:00008359                 call    ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int>>::_Grow_to(uint)
.text$mn:0000835E                 push    eax
.text$mn:0000835F                 mov     ecx, [ebp+var_4]
.text$mn:00008362                 call    ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reallocate(uint)
.text$mn:00008367
.text$mn:00008367 loc_8367:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+13j
.text$mn:00008367                 pop     esi
.text$mn:00008368                 mov     esp, ebp
.text$mn:0000836A                 pop     ebp
.text$mn:0000836B                 retn    4
.text$mn:0000836B ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:0000836B
.text$mn:0000836B ; ---------------------------------------------------------------------------
.text$mn:0000836E                 align 10h
.text$mn:0000836E _text$mn        ends
.text$mn:0000836E
.text$mn:00008370 ; ===========================================================================
.text$mn:00008370
.text$mn:00008370 ; Segment type: Pure code
.text$mn:00008370 ; Segment permissions: Read/Execute
.text$mn:00008370 _text$mn        segment para public 'CODE' use32
.text$mn:00008370                 assume cs:_text$mn
.text$mn:00008370                 ;org 8370h
.text$mn:00008370 ; COMDAT (pick any)
.text$mn:00008370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008370
.text$mn:00008370 ; =============== S U B R O U T I N E =======================================
.text$mn:00008370
.text$mn:00008370 ; Attributes: bp-based frame
.text$mn:00008370
.text$mn:00008370 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00008370                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00008370 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00008370                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00008370                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00008370
.text$mn:00008370 var_C           = dword ptr -0Ch
.text$mn:00008370 var_8           = dword ptr -8
.text$mn:00008370 var_2           = byte ptr -2
.text$mn:00008370 var_1           = byte ptr -1
.text$mn:00008370 arg_0           = byte ptr  8
.text$mn:00008370 Size            = dword ptr  0Ch
.text$mn:00008370
.text$mn:00008370                 push    ebp
.text$mn:00008371                 mov     ebp, esp
.text$mn:00008373                 sub     esp, 0Ch
.text$mn:00008376                 mov     [ebp+var_8], ecx
.text$mn:00008379                 movzx   eax, [ebp+arg_0]
.text$mn:0000837D                 test    eax, eax
.text$mn:0000837F                 jnz     short loc_8383
.text$mn:00008381                 jmp     short loc_83F6
.text$mn:00008383 ; ---------------------------------------------------------------------------
.text$mn:00008383
.text$mn:00008383 loc_8383:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00008383                 mov     ecx, [ebp+var_8]
.text$mn:00008386                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000838A                 jb      short loc_83F6
.text$mn:0000838C                 mov     edx, [ebp+var_8]
.text$mn:0000838F                 mov     eax, [edx+4]
.text$mn:00008392                 mov     [ebp+var_C], eax
.text$mn:00008395                 mov     ecx, [ebp+var_8]
.text$mn:00008398                 add     ecx, 4
.text$mn:0000839B                 push    ecx
.text$mn:0000839C                 lea     edx, [ebp+var_1]
.text$mn:0000839F                 push    edx
.text$mn:000083A0                 mov     ecx, [ebp+var_8]
.text$mn:000083A3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000083A8                 mov     ecx, eax
.text$mn:000083AA                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000083AF                 cmp     [ebp+Size], 0
.text$mn:000083B3                 jbe     short loc_83D5
.text$mn:000083B5                 mov     eax, [ebp+Size]
.text$mn:000083B8                 push    eax             ; Size
.text$mn:000083B9                 mov     ecx, [ebp+var_C]
.text$mn:000083BC                 push    ecx
.text$mn:000083BD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000083C2                 add     esp, 4
.text$mn:000083C5                 push    eax             ; Src
.text$mn:000083C6                 mov     edx, [ebp+var_8]
.text$mn:000083C9                 add     edx, 4
.text$mn:000083CC                 push    edx             ; Dst
.text$mn:000083CD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000083D2                 add     esp, 0Ch
.text$mn:000083D5
.text$mn:000083D5 loc_83D5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000083D5                 mov     eax, [ebp+var_8]
.text$mn:000083D8                 mov     ecx, [eax+18h]
.text$mn:000083DB                 add     ecx, 1
.text$mn:000083DE                 push    ecx             ; int
.text$mn:000083DF                 mov     edx, [ebp+var_C]
.text$mn:000083E2                 push    edx             ; void *
.text$mn:000083E3                 lea     eax, [ebp+var_2]
.text$mn:000083E6                 push    eax
.text$mn:000083E7                 mov     ecx, [ebp+var_8]
.text$mn:000083EA                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000083EF                 mov     ecx, eax
.text$mn:000083F1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000083F6
.text$mn:000083F6 loc_83F6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000083F6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000083F6                 mov     ecx, [ebp+var_8]
.text$mn:000083F9                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00008400                 mov     edx, [ebp+Size]
.text$mn:00008403                 push    edx
.text$mn:00008404                 mov     ecx, [ebp+var_8]
.text$mn:00008407                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000840C                 mov     esp, ebp
.text$mn:0000840E                 pop     ebp
.text$mn:0000840F                 retn    8
.text$mn:0000840F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000840F
.text$mn:0000840F ; ---------------------------------------------------------------------------
.text$mn:00008412                 align 4
.text$mn:00008412 _text$mn        ends
.text$mn:00008412
.text$mn:00008414 ; ===========================================================================
.text$mn:00008414
.text$mn:00008414 ; Segment type: Pure code
.text$mn:00008414 ; Segment permissions: Read/Execute
.text$mn:00008414 _text$mn        segment para public 'CODE' use32
.text$mn:00008414                 assume cs:_text$mn
.text$mn:00008414                 ;org 8414h
.text$mn:00008414 ; COMDAT (pick any)
.text$mn:00008414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008414
.text$mn:00008414 ; =============== S U B R O U T I N E =======================================
.text$mn:00008414
.text$mn:00008414 ; Attributes: bp-based frame
.text$mn:00008414
.text$mn:00008414 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00008414                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00008414 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00008414                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(uint,wchar_t)+47p
.text$mn:00008414                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p ...
.text$mn:00008414
.text$mn:00008414 var_C           = dword ptr -0Ch
.text$mn:00008414 var_8           = dword ptr -8
.text$mn:00008414 var_2           = byte ptr -2
.text$mn:00008414 var_1           = byte ptr -1
.text$mn:00008414 arg_0           = byte ptr  8
.text$mn:00008414 arg_4           = dword ptr  0Ch
.text$mn:00008414
.text$mn:00008414                 push    ebp
.text$mn:00008415                 mov     ebp, esp
.text$mn:00008417                 sub     esp, 0Ch
.text$mn:0000841A                 mov     [ebp+var_8], ecx
.text$mn:0000841D                 movzx   eax, [ebp+arg_0]
.text$mn:00008421                 test    eax, eax
.text$mn:00008423                 jnz     short loc_8427
.text$mn:00008425                 jmp     short loc_849A
.text$mn:00008427 ; ---------------------------------------------------------------------------
.text$mn:00008427
.text$mn:00008427 loc_8427:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00008427                 mov     ecx, [ebp+var_8]
.text$mn:0000842A                 cmp     dword ptr [ecx+18h], 8
.text$mn:0000842E                 jb      short loc_849A
.text$mn:00008430                 mov     edx, [ebp+var_8]
.text$mn:00008433                 mov     eax, [edx+4]
.text$mn:00008436                 mov     [ebp+var_C], eax
.text$mn:00008439                 mov     ecx, [ebp+var_8]
.text$mn:0000843C                 add     ecx, 4
.text$mn:0000843F                 push    ecx
.text$mn:00008440                 lea     edx, [ebp+var_1]
.text$mn:00008443                 push    edx
.text$mn:00008444                 mov     ecx, [ebp+var_8]
.text$mn:00008447                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000844C                 mov     ecx, eax
.text$mn:0000844E                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00008453                 cmp     [ebp+arg_4], 0
.text$mn:00008457                 jbe     short loc_8479
.text$mn:00008459                 mov     eax, [ebp+arg_4]
.text$mn:0000845C                 push    eax             ; int
.text$mn:0000845D                 mov     ecx, [ebp+var_C]
.text$mn:00008460                 push    ecx
.text$mn:00008461                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00008466                 add     esp, 4
.text$mn:00008469                 push    eax             ; Src
.text$mn:0000846A                 mov     edx, [ebp+var_8]
.text$mn:0000846D                 add     edx, 4
.text$mn:00008470                 push    edx             ; Dst
.text$mn:00008471                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00008476                 add     esp, 0Ch
.text$mn:00008479
.text$mn:00008479 loc_8479:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00008479                 mov     eax, [ebp+var_8]
.text$mn:0000847C                 mov     ecx, [eax+18h]
.text$mn:0000847F                 add     ecx, 1
.text$mn:00008482                 push    ecx             ; int
.text$mn:00008483                 mov     edx, [ebp+var_C]
.text$mn:00008486                 push    edx             ; void *
.text$mn:00008487                 lea     eax, [ebp+var_2]
.text$mn:0000848A                 push    eax
.text$mn:0000848B                 mov     ecx, [ebp+var_8]
.text$mn:0000848E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00008493                 mov     ecx, eax
.text$mn:00008495                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000849A
.text$mn:0000849A loc_849A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:0000849A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:0000849A                 mov     ecx, [ebp+var_8]
.text$mn:0000849D                 mov     dword ptr [ecx+18h], 7
.text$mn:000084A4                 mov     edx, [ebp+arg_4]
.text$mn:000084A7                 push    edx
.text$mn:000084A8                 mov     ecx, [ebp+var_8]
.text$mn:000084AB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000084B0                 mov     esp, ebp
.text$mn:000084B2                 pop     ebp
.text$mn:000084B3                 retn    8
.text$mn:000084B3 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:000084B3
.text$mn:000084B3 ; ---------------------------------------------------------------------------
.text$mn:000084B6                 align 4
.text$mn:000084B6 _text$mn        ends
.text$mn:000084B6
.text$mn:000084B8 ; ===========================================================================
.text$mn:000084B8
.text$mn:000084B8 ; Segment type: Pure code
.text$mn:000084B8 ; Segment permissions: Read/Execute
.text$mn:000084B8 _text$mn        segment para public 'CODE' use32
.text$mn:000084B8                 assume cs:_text$mn
.text$mn:000084B8                 ;org 84B8h
.text$mn:000084B8 ; COMDAT (pick any)
.text$mn:000084B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000084B8
.text$mn:000084B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000084B8
.text$mn:000084B8 ; Attributes: bp-based frame
.text$mn:000084B8
.text$mn:000084B8 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Tidy(void)
.text$mn:000084B8                 public ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
.text$mn:000084B8 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ proc near
.text$mn:000084B8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::~vector<int,std::allocator<int>>(void)+30p
.text$mn:000084B8
.text$mn:000084B8 var_8           = dword ptr -8
.text$mn:000084B8 var_1           = byte ptr -1
.text$mn:000084B8
.text$mn:000084B8                 push    ebp
.text$mn:000084B9                 mov     ebp, esp
.text$mn:000084BB                 sub     esp, 8
.text$mn:000084BE                 mov     [ebp+var_8], ecx
.text$mn:000084C1                 mov     eax, [ebp+var_8]
.text$mn:000084C4                 cmp     dword ptr [eax+4], 0
.text$mn:000084C8                 jz      short loc_8530
.text$mn:000084CA                 mov     ecx, [ebp+var_8] ; this
.text$mn:000084CD                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000084D2                 mov     ecx, [ebp+var_8]
.text$mn:000084D5                 mov     edx, [ecx+8]
.text$mn:000084D8                 push    edx
.text$mn:000084D9                 mov     eax, [ebp+var_8]
.text$mn:000084DC                 mov     ecx, [eax+4]
.text$mn:000084DF                 push    ecx
.text$mn:000084E0                 mov     ecx, [ebp+var_8]
.text$mn:000084E3                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:000084E8                 mov     edx, [ebp+var_8]
.text$mn:000084EB                 mov     eax, [ebp+var_8]
.text$mn:000084EE                 mov     ecx, [edx+0Ch]
.text$mn:000084F1                 sub     ecx, [eax+4]
.text$mn:000084F4                 sar     ecx, 2
.text$mn:000084F7                 push    ecx             ; int
.text$mn:000084F8                 mov     edx, [ebp+var_8]
.text$mn:000084FB                 mov     eax, [edx+4]
.text$mn:000084FE                 push    eax             ; void *
.text$mn:000084FF                 lea     ecx, [ebp+var_1]
.text$mn:00008502                 push    ecx
.text$mn:00008503                 mov     ecx, [ebp+var_8]
.text$mn:00008506                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000850B                 mov     ecx, eax
.text$mn:0000850D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:00008512                 mov     edx, [ebp+var_8]
.text$mn:00008515                 mov     dword ptr [edx+4], 0
.text$mn:0000851C                 mov     eax, [ebp+var_8]
.text$mn:0000851F                 mov     dword ptr [eax+8], 0
.text$mn:00008526                 mov     ecx, [ebp+var_8]
.text$mn:00008529                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00008530
.text$mn:00008530 loc_8530:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Tidy(void)+10j
.text$mn:00008530                 mov     esp, ebp
.text$mn:00008532                 pop     ebp
.text$mn:00008533                 retn
.text$mn:00008533 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ endp
.text$mn:00008533
.text$mn:00008533 _text$mn        ends
.text$mn:00008533
.text$mn:00008534 ; ===========================================================================
.text$mn:00008534
.text$mn:00008534 ; Segment type: Pure code
.text$mn:00008534 ; Segment permissions: Read/Execute
.text$mn:00008534 _text$mn        segment para public 'CODE' use32
.text$mn:00008534                 assume cs:_text$mn
.text$mn:00008534                 ;org 8534h
.text$mn:00008534 ; COMDAT (pick any)
.text$mn:00008534                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008534
.text$mn:00008534 ; =============== S U B R O U T I N E =======================================
.text$mn:00008534
.text$mn:00008534 ; Attributes: bp-based frame
.text$mn:00008534
.text$mn:00008534 ; protected: void __thiscall std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>::_Tidy(void)
.text$mn:00008534                 public ?_Tidy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXXZ
.text$mn:00008534 ?_Tidy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXXZ proc near
.text$mn:00008534                                         ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::~vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>(void)+30p
.text$mn:00008534
.text$mn:00008534 var_8           = dword ptr -8
.text$mn:00008534 var_1           = byte ptr -1
.text$mn:00008534
.text$mn:00008534                 push    ebp
.text$mn:00008535                 mov     ebp, esp
.text$mn:00008537                 sub     esp, 8
.text$mn:0000853A                 mov     [ebp+var_8], ecx
.text$mn:0000853D                 mov     eax, [ebp+var_8]
.text$mn:00008540                 cmp     dword ptr [eax+4], 0
.text$mn:00008544                 jz      short loc_85B3
.text$mn:00008546                 mov     ecx, [ebp+var_8] ; this
.text$mn:00008549                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000854E                 mov     ecx, [ebp+var_8]
.text$mn:00008551                 mov     edx, [ecx+8]
.text$mn:00008554                 push    edx
.text$mn:00008555                 mov     eax, [ebp+var_8]
.text$mn:00008558                 mov     ecx, [eax+4]
.text$mn:0000855B                 push    ecx
.text$mn:0000855C                 mov     ecx, [ebp+var_8]
.text$mn:0000855F                 call    ?_Destroy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXPAUColumnModeInfo@@0@Z ; std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Destroy(ColumnModeInfo *,ColumnModeInfo *)
.text$mn:00008564                 mov     edx, [ebp+var_8]
.text$mn:00008567                 mov     eax, [ebp+var_8]
.text$mn:0000856A                 mov     ecx, [edx+0Ch]
.text$mn:0000856D                 sub     ecx, [eax+4]
.text$mn:00008570                 mov     eax, ecx
.text$mn:00008572                 cdq
.text$mn:00008573                 mov     ecx, 18h
.text$mn:00008578                 idiv    ecx
.text$mn:0000857A                 push    eax             ; int
.text$mn:0000857B                 mov     edx, [ebp+var_8]
.text$mn:0000857E                 mov     eax, [edx+4]
.text$mn:00008581                 push    eax             ; void *
.text$mn:00008582                 lea     ecx, [ebp+var_1]
.text$mn:00008585                 push    ecx
.text$mn:00008586                 mov     ecx, [ebp+var_8]
.text$mn:00008589                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::_Getal(void)
.text$mn:0000858E                 mov     ecx, eax
.text$mn:00008590                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@I@Z ; std::_Wrap_alloc<std::allocator<ColumnModeInfo>>::deallocate(ColumnModeInfo *,uint)
.text$mn:00008595                 mov     edx, [ebp+var_8]
.text$mn:00008598                 mov     dword ptr [edx+4], 0
.text$mn:0000859F                 mov     eax, [ebp+var_8]
.text$mn:000085A2                 mov     dword ptr [eax+8], 0
.text$mn:000085A9                 mov     ecx, [ebp+var_8]
.text$mn:000085AC                 mov     dword ptr [ecx+0Ch], 0
.text$mn:000085B3
.text$mn:000085B3 loc_85B3:                               ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Tidy(void)+10j
.text$mn:000085B3                 mov     esp, ebp
.text$mn:000085B5                 pop     ebp
.text$mn:000085B6                 retn
.text$mn:000085B6 ?_Tidy@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@IAEXXZ endp
.text$mn:000085B6
.text$mn:000085B6 ; ---------------------------------------------------------------------------
.text$mn:000085B7                 align 4
.text$mn:000085B7 _text$mn        ends
.text$mn:000085B7
.text$mn:000085B8 ; ===========================================================================
.text$mn:000085B8
.text$mn:000085B8 ; Segment type: Pure code
.text$mn:000085B8 ; Segment permissions: Read/Execute
.text$mn:000085B8 _text$mn        segment para public 'CODE' use32
.text$mn:000085B8                 assume cs:_text$mn
.text$mn:000085B8                 ;org 85B8h
.text$mn:000085B8 ; COMDAT (pick any)
.text$mn:000085B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000085B8
.text$mn:000085B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000085B8
.text$mn:000085B8 ; Attributes: bp-based frame
.text$mn:000085B8
.text$mn:000085B8 ; public: struct ColumnModeInfo * __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>>::_Unchecked(void)const
.text$mn:000085B8                 public ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEPAUColumnModeInfo@@XZ
.text$mn:000085B8 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEPAUColumnModeInfo@@XZ proc near
.text$mn:000085B8                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>)+2Dp
.text$mn:000085B8
.text$mn:000085B8 var_4           = dword ptr -4
.text$mn:000085B8
.text$mn:000085B8                 push    ebp
.text$mn:000085B9                 mov     ebp, esp
.text$mn:000085BB                 push    ecx
.text$mn:000085BC                 mov     [ebp+var_4], ecx
.text$mn:000085BF                 mov     eax, [ebp+var_4]
.text$mn:000085C2                 mov     eax, [eax+8]
.text$mn:000085C5                 mov     esp, ebp
.text$mn:000085C7                 pop     ebp
.text$mn:000085C8                 retn
.text$mn:000085C8 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QBEPAUColumnModeInfo@@XZ endp
.text$mn:000085C8
.text$mn:000085C8 ; ---------------------------------------------------------------------------
.text$mn:000085C9                 align 4
.text$mn:000085C9 _text$mn        ends
.text$mn:000085C9
.text$mn:000085CC ; ===========================================================================
.text$mn:000085CC
.text$mn:000085CC ; Segment type: Pure code
.text$mn:000085CC ; Segment permissions: Read/Execute
.text$mn:000085CC _text$mn        segment para public 'CODE' use32
.text$mn:000085CC                 assume cs:_text$mn
.text$mn:000085CC                 ;org 85CCh
.text$mn:000085CC ; COMDAT (pick any)
.text$mn:000085CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000085CC
.text$mn:000085CC ; =============== S U B R O U T I N E =======================================
.text$mn:000085CC
.text$mn:000085CC ; Attributes: bp-based frame
.text$mn:000085CC
.text$mn:000085CC ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Unused_capacity(void)const
.text$mn:000085CC                 public ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:000085CC ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:000085CC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+Bp
.text$mn:000085CC
.text$mn:000085CC var_4           = dword ptr -4
.text$mn:000085CC
.text$mn:000085CC                 push    ebp
.text$mn:000085CD                 mov     ebp, esp
.text$mn:000085CF                 push    ecx
.text$mn:000085D0                 mov     [ebp+var_4], ecx
.text$mn:000085D3                 mov     eax, [ebp+var_4]
.text$mn:000085D6                 mov     ecx, [ebp+var_4]
.text$mn:000085D9                 mov     eax, [eax+0Ch]
.text$mn:000085DC                 sub     eax, [ecx+8]
.text$mn:000085DF                 sar     eax, 2
.text$mn:000085E2                 mov     esp, ebp
.text$mn:000085E4                 pop     ebp
.text$mn:000085E5                 retn
.text$mn:000085E5 ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:000085E5
.text$mn:000085E5 ; ---------------------------------------------------------------------------
.text$mn:000085E6                 align 4
.text$mn:000085E6 _text$mn        ends
.text$mn:000085E6
.text$mn:000085E8 ; ===========================================================================
.text$mn:000085E8
.text$mn:000085E8 ; Segment type: Pure code
.text$mn:000085E8 ; Segment permissions: Read/Execute
.text$mn:000085E8 _text$mn        segment para public 'CODE' use32
.text$mn:000085E8                 assume cs:_text$mn
.text$mn:000085E8                 ;org 85E8h
.text$mn:000085E8 ; COMDAT (pick any)
.text$mn:000085E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000085E8
.text$mn:000085E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000085E8
.text$mn:000085E8 ; Attributes: bp-based frame
.text$mn:000085E8
.text$mn:000085E8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000085E8                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000085E8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000085E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000085E8
.text$mn:000085E8 var_4           = dword ptr -4
.text$mn:000085E8
.text$mn:000085E8                 push    ebp
.text$mn:000085E9                 mov     ebp, esp
.text$mn:000085EB                 push    ecx
.text$mn:000085EC                 mov     [ebp+var_4], ecx
.text$mn:000085EF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000085F4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000085F9                 mov     esp, ebp
.text$mn:000085FB                 pop     ebp
.text$mn:000085FC                 retn
.text$mn:000085FC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000085FC
.text$mn:000085FC ; ---------------------------------------------------------------------------
.text$mn:000085FD                 align 10h
.text$mn:000085FD _text$mn        ends
.text$mn:000085FD
.text$mn:00008600 ; ===========================================================================
.text$mn:00008600
.text$mn:00008600 ; Segment type: Pure code
.text$mn:00008600 ; Segment permissions: Read/Execute
.text$mn:00008600 _text$mn        segment para public 'CODE' use32
.text$mn:00008600                 assume cs:_text$mn
.text$mn:00008600                 ;org 8600h
.text$mn:00008600 ; COMDAT (pick any)
.text$mn:00008600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008600
.text$mn:00008600 ; =============== S U B R O U T I N E =======================================
.text$mn:00008600
.text$mn:00008600 ; Attributes: bp-based frame
.text$mn:00008600
.text$mn:00008600 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00008600                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00008600 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00008600                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00008600                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:00008600
.text$mn:00008600 var_4           = dword ptr -4
.text$mn:00008600
.text$mn:00008600                 push    ebp
.text$mn:00008601                 mov     ebp, esp
.text$mn:00008603                 push    ecx
.text$mn:00008604                 mov     [ebp+var_4], ecx
.text$mn:00008607                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000860C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00008611                 mov     esp, ebp
.text$mn:00008613                 pop     ebp
.text$mn:00008614                 retn
.text$mn:00008614 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00008614
.text$mn:00008614 ; ---------------------------------------------------------------------------
.text$mn:00008615                 align 4
.text$mn:00008615 _text$mn        ends
.text$mn:00008615
.text$mn:00008618 ; ===========================================================================
.text$mn:00008618
.text$mn:00008618 ; Segment type: Pure code
.text$mn:00008618 ; Segment permissions: Read/Execute
.text$mn:00008618 _text$mn        segment para public 'CODE' use32
.text$mn:00008618                 assume cs:_text$mn
.text$mn:00008618                 ;org 8618h
.text$mn:00008618 ; COMDAT (pick any)
.text$mn:00008618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008618
.text$mn:00008618 ; =============== S U B R O U T I N E =======================================
.text$mn:00008618
.text$mn:00008618 ; Attributes: bp-based frame
.text$mn:00008618
.text$mn:00008618 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Xlen(void)const
.text$mn:00008618                 public ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
.text$mn:00008618 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ proc near
.text$mn:00008618                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+31p
.text$mn:00008618
.text$mn:00008618 var_4           = dword ptr -4
.text$mn:00008618
.text$mn:00008618                 push    ebp
.text$mn:00008619                 mov     ebp, esp
.text$mn:0000861B                 push    ecx
.text$mn:0000861C                 mov     [ebp+var_4], ecx
.text$mn:0000861F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00008624                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00008629                 mov     esp, ebp
.text$mn:0000862B                 pop     ebp
.text$mn:0000862C                 retn
.text$mn:0000862C ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ endp
.text$mn:0000862C
.text$mn:0000862C ; ---------------------------------------------------------------------------
.text$mn:0000862D                 align 10h
.text$mn:0000862D _text$mn        ends
.text$mn:0000862D
.text$mn:00008630 ; ===========================================================================
.text$mn:00008630
.text$mn:00008630 ; Segment type: Pure code
.text$mn:00008630 ; Segment permissions: Read/Execute
.text$mn:00008630 _text$mn        segment para public 'CODE' use32
.text$mn:00008630                 assume cs:_text$mn
.text$mn:00008630                 ;org 8630h
.text$mn:00008630 ; COMDAT (pick any)
.text$mn:00008630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008630
.text$mn:00008630 ; =============== S U B R O U T I N E =======================================
.text$mn:00008630
.text$mn:00008630 ; Attributes: bp-based frame
.text$mn:00008630
.text$mn:00008630 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00008630                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00008630 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00008630                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00008630                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00008630
.text$mn:00008630 var_4           = dword ptr -4
.text$mn:00008630
.text$mn:00008630                 push    ebp
.text$mn:00008631                 mov     ebp, esp
.text$mn:00008633                 push    ecx
.text$mn:00008634                 mov     [ebp+var_4], ecx
.text$mn:00008637                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000863C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00008641                 mov     esp, ebp
.text$mn:00008643                 pop     ebp
.text$mn:00008644                 retn
.text$mn:00008644 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00008644
.text$mn:00008644 ; ---------------------------------------------------------------------------
.text$mn:00008645                 align 4
.text$mn:00008645 _text$mn        ends
.text$mn:00008645
.text$mn:00008648 ; ===========================================================================
.text$mn:00008648
.text$mn:00008648 ; Segment type: Pure code
.text$mn:00008648 ; Segment permissions: Read/Execute
.text$mn:00008648 _text$mn        segment para public 'CODE' use32
.text$mn:00008648                 assume cs:_text$mn
.text$mn:00008648                 ;org 8648h
.text$mn:00008648 ; COMDAT (pick any)
.text$mn:00008648                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008648
.text$mn:00008648 ; =============== S U B R O U T I N E =======================================
.text$mn:00008648
.text$mn:00008648 ; Attributes: bp-based frame
.text$mn:00008648
.text$mn:00008648 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00008648                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00008648 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00008648                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00008648                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:00008648
.text$mn:00008648 var_4           = dword ptr -4
.text$mn:00008648
.text$mn:00008648                 push    ebp
.text$mn:00008649                 mov     ebp, esp
.text$mn:0000864B                 push    ecx
.text$mn:0000864C                 mov     [ebp+var_4], ecx
.text$mn:0000864F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00008654                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00008659                 mov     esp, ebp
.text$mn:0000865B                 pop     ebp
.text$mn:0000865C                 retn
.text$mn:0000865C ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:0000865C
.text$mn:0000865C ; ---------------------------------------------------------------------------
.text$mn:0000865D                 align 10h
.text$mn:0000865D _text$mn        ends
.text$mn:0000865D
.text$mn:00008660 ; ===========================================================================
.text$mn:00008660
.text$mn:00008660 ; Segment type: Pure code
.text$mn:00008660 ; Segment permissions: Read/Execute
.text$mn:00008660 _text$mn        segment para public 'CODE' use32
.text$mn:00008660                 assume cs:_text$mn
.text$mn:00008660                 ;org 8660h
.text$mn:00008660 ; COMDAT (pick any)
.text$mn:00008660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008660
.text$mn:00008660 ; =============== S U B R O U T I N E =======================================
.text$mn:00008660
.text$mn:00008660 ; Attributes: bp-based frame
.text$mn:00008660
.text$mn:00008660 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Xran(void)const
.text$mn:00008660                 public ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
.text$mn:00008660 ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ proc near
.text$mn:00008660                                         ; CODE XREF: std::vector<int,std::allocator<int>>::at(uint)+17p
.text$mn:00008660
.text$mn:00008660 var_4           = dword ptr -4
.text$mn:00008660
.text$mn:00008660                 push    ebp
.text$mn:00008661                 mov     ebp, esp
.text$mn:00008663                 push    ecx
.text$mn:00008664                 mov     [ebp+var_4], ecx
.text$mn:00008667                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:0000866C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00008671                 mov     esp, ebp
.text$mn:00008673                 pop     ebp
.text$mn:00008674                 retn
.text$mn:00008674 ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ endp
.text$mn:00008674
.text$mn:00008674 ; ---------------------------------------------------------------------------
.text$mn:00008675                 align 4
.text$mn:00008675 _text$mn        ends
.text$mn:00008675
.text$mn:00008678 ; ===========================================================================
.text$mn:00008678
.text$mn:00008678 ; Segment type: Pure code
.text$mn:00008678 ; Segment permissions: Read/Execute
.text$mn:00008678 _text$mn        segment para public 'CODE' use32
.text$mn:00008678                 assume cs:_text$mn
.text$mn:00008678                 ;org 8678h
.text$mn:00008678 ; COMDAT (pick any)
.text$mn:00008678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008678
.text$mn:00008678 ; =============== S U B R O U T I N E =======================================
.text$mn:00008678
.text$mn:00008678 ; Attributes: bp-based frame
.text$mn:00008678
.text$mn:00008678 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00008678                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00008678 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00008678                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00008678                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00008678
.text$mn:00008678 var_4           = dword ptr -4
.text$mn:00008678 arg_0           = dword ptr  8
.text$mn:00008678
.text$mn:00008678                 push    ebp
.text$mn:00008679                 mov     ebp, esp
.text$mn:0000867B                 push    ecx
.text$mn:0000867C                 mov     [ebp+var_4], ecx
.text$mn:0000867F                 mov     eax, [ebp+arg_0]
.text$mn:00008682                 push    eax
.text$mn:00008683                 mov     ecx, [ebp+var_4]
.text$mn:00008686                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000868B                 mov     esp, ebp
.text$mn:0000868D                 pop     ebp
.text$mn:0000868E                 retn    4
.text$mn:0000868E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000868E
.text$mn:0000868E ; ---------------------------------------------------------------------------
.text$mn:00008691                 align 4
.text$mn:00008691 _text$mn        ends
.text$mn:00008691
.text$mn:00008694 ; ===========================================================================
.text$mn:00008694
.text$mn:00008694 ; Segment type: Pure code
.text$mn:00008694 ; Segment permissions: Read/Execute
.text$mn:00008694 _text$mn        segment para public 'CODE' use32
.text$mn:00008694                 assume cs:_text$mn
.text$mn:00008694                 ;org 8694h
.text$mn:00008694 ; COMDAT (pick any)
.text$mn:00008694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008694
.text$mn:00008694 ; =============== S U B R O U T I N E =======================================
.text$mn:00008694
.text$mn:00008694 ; Attributes: bp-based frame
.text$mn:00008694
.text$mn:00008694 ; public: int * __thiscall std::_Wrap_alloc<class std::allocator<int>>::allocate(unsigned int)
.text$mn:00008694                 public ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z
.text$mn:00008694 ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z proc near
.text$mn:00008694                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+41p
.text$mn:00008694
.text$mn:00008694 var_4           = dword ptr -4
.text$mn:00008694 arg_0           = dword ptr  8
.text$mn:00008694
.text$mn:00008694                 push    ebp
.text$mn:00008695                 mov     ebp, esp
.text$mn:00008697                 push    ecx
.text$mn:00008698                 mov     [ebp+var_4], ecx
.text$mn:0000869B                 mov     eax, [ebp+arg_0]
.text$mn:0000869E                 push    eax
.text$mn:0000869F                 mov     ecx, [ebp+var_4]
.text$mn:000086A2                 call    ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate(uint)
.text$mn:000086A7                 mov     esp, ebp
.text$mn:000086A9                 pop     ebp
.text$mn:000086AA                 retn    4
.text$mn:000086AA ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z endp
.text$mn:000086AA
.text$mn:000086AA ; ---------------------------------------------------------------------------
.text$mn:000086AD                 align 10h
.text$mn:000086AD _text$mn        ends
.text$mn:000086AD
.text$mn:000086B0 ; ===========================================================================
.text$mn:000086B0
.text$mn:000086B0 ; Segment type: Pure code
.text$mn:000086B0 ; Segment permissions: Read/Execute
.text$mn:000086B0 _text$mn        segment para public 'CODE' use32
.text$mn:000086B0                 assume cs:_text$mn
.text$mn:000086B0                 ;org 86B0h
.text$mn:000086B0 ; COMDAT (pick any)
.text$mn:000086B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086B0
.text$mn:000086B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000086B0
.text$mn:000086B0 ; Attributes: bp-based frame
.text$mn:000086B0
.text$mn:000086B0 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:000086B0                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000086B0 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000086B0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Alloc_proxy(void)+16p
.text$mn:000086B0
.text$mn:000086B0 var_4           = dword ptr -4
.text$mn:000086B0 arg_0           = dword ptr  8
.text$mn:000086B0
.text$mn:000086B0                 push    ebp
.text$mn:000086B1                 mov     ebp, esp
.text$mn:000086B3                 push    ecx
.text$mn:000086B4                 mov     [ebp+var_4], ecx
.text$mn:000086B7                 mov     eax, [ebp+arg_0]
.text$mn:000086BA                 push    eax
.text$mn:000086BB                 mov     ecx, [ebp+var_4]
.text$mn:000086BE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000086C3                 mov     esp, ebp
.text$mn:000086C5                 pop     ebp
.text$mn:000086C6                 retn    4
.text$mn:000086C6 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000086C6
.text$mn:000086C6 ; ---------------------------------------------------------------------------
.text$mn:000086C9                 align 4
.text$mn:000086C9 _text$mn        ends
.text$mn:000086C9
.text$mn:000086CC ; ===========================================================================
.text$mn:000086CC
.text$mn:000086CC ; Segment type: Pure code
.text$mn:000086CC ; Segment permissions: Read/Execute
.text$mn:000086CC _text$mn        segment para public 'CODE' use32
.text$mn:000086CC                 assume cs:_text$mn
.text$mn:000086CC                 ;org 86CCh
.text$mn:000086CC ; COMDAT (pick any)
.text$mn:000086CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086CC
.text$mn:000086CC ; =============== S U B R O U T I N E =======================================
.text$mn:000086CC
.text$mn:000086CC ; Attributes: bp-based frame
.text$mn:000086CC
.text$mn:000086CC ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:000086CC                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:000086CC ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:000086CC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:000086CC                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:000086CC
.text$mn:000086CC var_4           = dword ptr -4
.text$mn:000086CC arg_0           = dword ptr  8
.text$mn:000086CC
.text$mn:000086CC                 push    ebp
.text$mn:000086CD                 mov     ebp, esp
.text$mn:000086CF                 push    ecx
.text$mn:000086D0                 mov     [ebp+var_4], ecx
.text$mn:000086D3                 mov     eax, [ebp+arg_0]
.text$mn:000086D6                 push    eax
.text$mn:000086D7                 mov     ecx, [ebp+var_4]
.text$mn:000086DA                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:000086DF                 mov     esp, ebp
.text$mn:000086E1                 pop     ebp
.text$mn:000086E2                 retn    4
.text$mn:000086E2 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:000086E2
.text$mn:000086E2 ; ---------------------------------------------------------------------------
.text$mn:000086E5                 align 4
.text$mn:000086E5 _text$mn        ends
.text$mn:000086E5
.text$mn:000086E8 ; ===========================================================================
.text$mn:000086E8
.text$mn:000086E8 ; Segment type: Pure code
.text$mn:000086E8 ; Segment permissions: Read/Execute
.text$mn:000086E8 _text$mn        segment para public 'CODE' use32
.text$mn:000086E8                 assume cs:_text$mn
.text$mn:000086E8                 ;org 86E8h
.text$mn:000086E8 ; COMDAT (pick any)
.text$mn:000086E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086E8
.text$mn:000086E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000086E8
.text$mn:000086E8 ; Attributes: bp-based frame
.text$mn:000086E8
.text$mn:000086E8 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000086E8                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000086E8 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000086E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000086E8
.text$mn:000086E8 var_4           = dword ptr -4
.text$mn:000086E8 arg_0           = dword ptr  8
.text$mn:000086E8
.text$mn:000086E8                 push    ebp
.text$mn:000086E9                 mov     ebp, esp
.text$mn:000086EB                 push    ecx
.text$mn:000086EC                 mov     [ebp+var_4], ecx
.text$mn:000086EF                 push    0
.text$mn:000086F1                 mov     eax, [ebp+arg_0]
.text$mn:000086F4                 push    eax
.text$mn:000086F5                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000086FA                 add     esp, 8
.text$mn:000086FD                 mov     esp, ebp
.text$mn:000086FF                 pop     ebp
.text$mn:00008700                 retn    4
.text$mn:00008700 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00008700
.text$mn:00008700 ; ---------------------------------------------------------------------------
.text$mn:00008703                 align 4
.text$mn:00008703 _text$mn        ends
.text$mn:00008703
.text$mn:00008704 ; ===========================================================================
.text$mn:00008704
.text$mn:00008704 ; Segment type: Pure code
.text$mn:00008704 ; Segment permissions: Read/Execute
.text$mn:00008704 _text$mn        segment para public 'CODE' use32
.text$mn:00008704                 assume cs:_text$mn
.text$mn:00008704                 ;org 8704h
.text$mn:00008704 ; COMDAT (pick any)
.text$mn:00008704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008704
.text$mn:00008704 ; =============== S U B R O U T I N E =======================================
.text$mn:00008704
.text$mn:00008704 ; Attributes: bp-based frame
.text$mn:00008704
.text$mn:00008704 ; public: int * __thiscall std::allocator<int>::allocate(unsigned int)
.text$mn:00008704                 public ?allocate@?$allocator@H@std@@QAEPAHI@Z
.text$mn:00008704 ?allocate@?$allocator@H@std@@QAEPAHI@Z proc near
.text$mn:00008704                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::allocate(uint)+Ep
.text$mn:00008704
.text$mn:00008704 var_4           = dword ptr -4
.text$mn:00008704 arg_0           = dword ptr  8
.text$mn:00008704
.text$mn:00008704                 push    ebp
.text$mn:00008705                 mov     ebp, esp
.text$mn:00008707                 push    ecx
.text$mn:00008708                 mov     [ebp+var_4], ecx
.text$mn:0000870B                 push    0
.text$mn:0000870D                 mov     eax, [ebp+arg_0]
.text$mn:00008710                 push    eax
.text$mn:00008711                 call    ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>(uint,int *)
.text$mn:00008716                 add     esp, 8
.text$mn:00008719                 mov     esp, ebp
.text$mn:0000871B                 pop     ebp
.text$mn:0000871C                 retn    4
.text$mn:0000871C ?allocate@?$allocator@H@std@@QAEPAHI@Z endp
.text$mn:0000871C
.text$mn:0000871C ; ---------------------------------------------------------------------------
.text$mn:0000871F                 align 10h
.text$mn:0000871F _text$mn        ends
.text$mn:0000871F
.text$mn:00008720 ; ===========================================================================
.text$mn:00008720
.text$mn:00008720 ; Segment type: Pure code
.text$mn:00008720 ; Segment permissions: Read/Execute
.text$mn:00008720 _text$mn        segment para public 'CODE' use32
.text$mn:00008720                 assume cs:_text$mn
.text$mn:00008720                 ;org 8720h
.text$mn:00008720 ; COMDAT (pick any)
.text$mn:00008720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008720
.text$mn:00008720 ; =============== S U B R O U T I N E =======================================
.text$mn:00008720
.text$mn:00008720 ; Attributes: bp-based frame
.text$mn:00008720
.text$mn:00008720 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00008720                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00008720 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00008720                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00008720                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:00008720
.text$mn:00008720 var_4           = dword ptr -4
.text$mn:00008720 arg_0           = dword ptr  8
.text$mn:00008720
.text$mn:00008720                 push    ebp
.text$mn:00008721                 mov     ebp, esp
.text$mn:00008723                 push    ecx
.text$mn:00008724                 mov     [ebp+var_4], ecx
.text$mn:00008727                 push    0
.text$mn:00008729                 mov     eax, [ebp+arg_0]
.text$mn:0000872C                 push    eax
.text$mn:0000872D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00008732                 add     esp, 8
.text$mn:00008735                 mov     esp, ebp
.text$mn:00008737                 pop     ebp
.text$mn:00008738                 retn    4
.text$mn:00008738 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00008738
.text$mn:00008738 ; ---------------------------------------------------------------------------
.text$mn:0000873B                 align 4
.text$mn:0000873B _text$mn        ends
.text$mn:0000873B
.text$mn:0000873C ; ===========================================================================
.text$mn:0000873C
.text$mn:0000873C ; Segment type: Pure code
.text$mn:0000873C ; Segment permissions: Read/Execute
.text$mn:0000873C _text$mn        segment para public 'CODE' use32
.text$mn:0000873C                 assume cs:_text$mn
.text$mn:0000873C                 ;org 873Ch
.text$mn:0000873C ; COMDAT (pick any)
.text$mn:0000873C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000873C
.text$mn:0000873C ; =============== S U B R O U T I N E =======================================
.text$mn:0000873C
.text$mn:0000873C ; Attributes: bp-based frame
.text$mn:0000873C
.text$mn:0000873C ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:0000873C                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:0000873C ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:0000873C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:0000873C
.text$mn:0000873C var_4           = dword ptr -4
.text$mn:0000873C arg_0           = dword ptr  8
.text$mn:0000873C
.text$mn:0000873C                 push    ebp
.text$mn:0000873D                 mov     ebp, esp
.text$mn:0000873F                 push    ecx
.text$mn:00008740                 mov     [ebp+var_4], ecx
.text$mn:00008743                 push    0
.text$mn:00008745                 mov     eax, [ebp+arg_0]
.text$mn:00008748                 push    eax
.text$mn:00008749                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000874E                 add     esp, 8
.text$mn:00008751                 mov     esp, ebp
.text$mn:00008753                 pop     ebp
.text$mn:00008754                 retn    4
.text$mn:00008754 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00008754
.text$mn:00008754 ; ---------------------------------------------------------------------------
.text$mn:00008757                 align 4
.text$mn:00008757 _text$mn        ends
.text$mn:00008757
.text$mn:00008758 ; ===========================================================================
.text$mn:00008758
.text$mn:00008758 ; Segment type: Pure code
.text$mn:00008758 ; Segment permissions: Read/Execute
.text$mn:00008758 _text$mn        segment para public 'CODE' use32
.text$mn:00008758                 assume cs:_text$mn
.text$mn:00008758                 ;org 8758h
.text$mn:00008758 ; COMDAT (pick any)
.text$mn:00008758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008758
.text$mn:00008758 ; =============== S U B R O U T I N E =======================================
.text$mn:00008758
.text$mn:00008758 ; Attributes: bp-based frame
.text$mn:00008758
.text$mn:00008758 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00008758                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:00008758 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:00008758                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+5AAp
.text$mn:00008758                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+D4Bp
.text$mn:00008758
.text$mn:00008758 var_4           = dword ptr -4
.text$mn:00008758 arg_0           = dword ptr  8
.text$mn:00008758
.text$mn:00008758                 push    ebp
.text$mn:00008759                 mov     ebp, esp
.text$mn:0000875B                 push    ecx
.text$mn:0000875C                 mov     [ebp+var_4], ecx
.text$mn:0000875F                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00008764                 push    eax
.text$mn:00008765                 push    0
.text$mn:00008767                 mov     ecx, [ebp+arg_0]
.text$mn:0000876A                 push    ecx
.text$mn:0000876B                 mov     ecx, [ebp+var_4]
.text$mn:0000876E                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00008773                 mov     esp, ebp
.text$mn:00008775                 pop     ebp
.text$mn:00008776                 retn    4
.text$mn:00008776 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:00008776
.text$mn:00008776 ; ---------------------------------------------------------------------------
.text$mn:00008779                 align 4
.text$mn:00008779 _text$mn        ends
.text$mn:00008779
.text$mn:0000877C ; ===========================================================================
.text$mn:0000877C
.text$mn:0000877C ; Segment type: Pure code
.text$mn:0000877C ; Segment permissions: Read/Execute
.text$mn:0000877C _text$mn        segment para public 'CODE' use32
.text$mn:0000877C                 assume cs:_text$mn
.text$mn:0000877C                 ;org 877Ch
.text$mn:0000877C ; COMDAT (pick any)
.text$mn:0000877C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000877C
.text$mn:0000877C ; =============== S U B R O U T I N E =======================================
.text$mn:0000877C
.text$mn:0000877C ; Attributes: bp-based frame
.text$mn:0000877C
.text$mn:0000877C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000877C                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000877C ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000877C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p
.text$mn:0000877C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:0000877C
.text$mn:0000877C var_8           = dword ptr -8
.text$mn:0000877C var_4           = dword ptr -4
.text$mn:0000877C arg_0           = dword ptr  8
.text$mn:0000877C arg_4           = dword ptr  0Ch
.text$mn:0000877C arg_8           = dword ptr  10h
.text$mn:0000877C
.text$mn:0000877C                 push    ebp
.text$mn:0000877D                 mov     ebp, esp
.text$mn:0000877F                 sub     esp, 8
.text$mn:00008782                 mov     [ebp+var_4], ecx
.text$mn:00008785                 mov     ecx, [ebp+arg_0]
.text$mn:00008788                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000878D                 cmp     eax, [ebp+arg_4]
.text$mn:00008790                 jnb     short loc_879A
.text$mn:00008792                 mov     ecx, [ebp+var_4]
.text$mn:00008795                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000879A
.text$mn:0000879A loc_879A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000879A                 mov     ecx, [ebp+arg_0]
.text$mn:0000879D                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000087A2                 sub     eax, [ebp+arg_4]
.text$mn:000087A5                 mov     [ebp+var_8], eax
.text$mn:000087A8                 mov     eax, [ebp+var_8]
.text$mn:000087AB                 cmp     eax, [ebp+arg_8]
.text$mn:000087AE                 jnb     short loc_87B6
.text$mn:000087B0                 mov     ecx, [ebp+var_8]
.text$mn:000087B3                 mov     [ebp+arg_8], ecx
.text$mn:000087B6
.text$mn:000087B6 loc_87B6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:000087B6                 mov     edx, [ebp+var_4]
.text$mn:000087B9                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000087BE                 sub     eax, [edx+14h]
.text$mn:000087C1                 cmp     eax, [ebp+arg_8]
.text$mn:000087C4                 ja      short loc_87CE
.text$mn:000087C6                 mov     ecx, [ebp+var_4]
.text$mn:000087C9                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000087CE
.text$mn:000087CE loc_87CE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:000087CE                 cmp     [ebp+arg_8], 0
.text$mn:000087D2                 jbe     short loc_882E
.text$mn:000087D4                 mov     ecx, [ebp+var_4]
.text$mn:000087D7                 mov     edx, [ecx+14h]
.text$mn:000087DA                 add     edx, [ebp+arg_8]
.text$mn:000087DD                 mov     [ebp+var_8], edx
.text$mn:000087E0                 push    0
.text$mn:000087E2                 mov     eax, [ebp+var_8]
.text$mn:000087E5                 push    eax
.text$mn:000087E6                 mov     ecx, [ebp+var_4]
.text$mn:000087E9                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:000087EE                 movzx   ecx, al
.text$mn:000087F1                 test    ecx, ecx
.text$mn:000087F3                 jz      short loc_882E
.text$mn:000087F5                 mov     edx, [ebp+arg_8]
.text$mn:000087F8                 push    edx             ; int
.text$mn:000087F9                 mov     ecx, [ebp+arg_0]
.text$mn:000087FC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008801                 mov     ecx, [ebp+arg_4]
.text$mn:00008804                 lea     edx, [eax+ecx*2]
.text$mn:00008807                 push    edx             ; Src
.text$mn:00008808                 mov     ecx, [ebp+var_4]
.text$mn:0000880B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008810                 mov     ecx, [ebp+var_4]
.text$mn:00008813                 mov     edx, [ecx+14h]
.text$mn:00008816                 lea     eax, [eax+edx*2]
.text$mn:00008819                 push    eax             ; Dst
.text$mn:0000881A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000881F                 add     esp, 0Ch
.text$mn:00008822                 mov     ecx, [ebp+var_8]
.text$mn:00008825                 push    ecx
.text$mn:00008826                 mov     ecx, [ebp+var_4]
.text$mn:00008829                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000882E
.text$mn:0000882E loc_882E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:0000882E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:0000882E                 mov     eax, [ebp+var_4]
.text$mn:00008831                 mov     esp, ebp
.text$mn:00008833                 pop     ebp
.text$mn:00008834                 retn    0Ch
.text$mn:00008834 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00008834
.text$mn:00008834 ; ---------------------------------------------------------------------------
.text$mn:00008837                 align 4
.text$mn:00008837 _text$mn        ends
.text$mn:00008837
.text$mn:00008838 ; ===========================================================================
.text$mn:00008838
.text$mn:00008838 ; Segment type: Pure code
.text$mn:00008838 ; Segment permissions: Read/Execute
.text$mn:00008838 _text$mn        segment para public 'CODE' use32
.text$mn:00008838                 assume cs:_text$mn
.text$mn:00008838                 ;org 8838h
.text$mn:00008838 ; COMDAT (pick any)
.text$mn:00008838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008838
.text$mn:00008838 ; =============== S U B R O U T I N E =======================================
.text$mn:00008838
.text$mn:00008838 ; Attributes: bp-based frame
.text$mn:00008838
.text$mn:00008838 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:00008838                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00008838 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00008838                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+5BCp
.text$mn:00008838                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+D5Dp
.text$mn:00008838
.text$mn:00008838 var_4           = dword ptr -4
.text$mn:00008838 Str             = dword ptr  8
.text$mn:00008838
.text$mn:00008838                 push    ebp
.text$mn:00008839                 mov     ebp, esp
.text$mn:0000883B                 push    ecx
.text$mn:0000883C                 mov     [ebp+var_4], ecx
.text$mn:0000883F                 push    43Eh            ; unsigned int
.text$mn:00008844                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008849                 mov     eax, [ebp+Str]
.text$mn:0000884C                 push    eax             ; int
.text$mn:0000884D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00008852                 add     esp, 0Ch
.text$mn:00008855                 mov     ecx, [ebp+Str]
.text$mn:00008858                 push    ecx             ; Str
.text$mn:00008859                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000885E                 add     esp, 4
.text$mn:00008861                 push    eax             ; int
.text$mn:00008862                 mov     edx, [ebp+Str]
.text$mn:00008865                 push    edx             ; Src
.text$mn:00008866                 mov     ecx, [ebp+var_4]
.text$mn:00008869                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:0000886E                 mov     esp, ebp
.text$mn:00008870                 pop     ebp
.text$mn:00008871                 retn    4
.text$mn:00008871 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00008871
.text$mn:00008871 _text$mn        ends
.text$mn:00008871
.text$mn:00008874 ; ===========================================================================
.text$mn:00008874
.text$mn:00008874 ; Segment type: Pure code
.text$mn:00008874 ; Segment permissions: Read/Execute
.text$mn:00008874 _text$mn        segment para public 'CODE' use32
.text$mn:00008874                 assume cs:_text$mn
.text$mn:00008874                 ;org 8874h
.text$mn:00008874 ; COMDAT (pick any)
.text$mn:00008874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008874
.text$mn:00008874 ; =============== S U B R O U T I N E =======================================
.text$mn:00008874
.text$mn:00008874 ; Attributes: bp-based frame
.text$mn:00008874
.text$mn:00008874 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:00008874                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00008874 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00008874                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:00008874
.text$mn:00008874 var_8           = dword ptr -8
.text$mn:00008874 var_4           = dword ptr -4
.text$mn:00008874 Src             = dword ptr  8
.text$mn:00008874 arg_4           = dword ptr  0Ch
.text$mn:00008874
.text$mn:00008874                 push    ebp
.text$mn:00008875                 mov     ebp, esp
.text$mn:00008877                 sub     esp, 8
.text$mn:0000887A                 mov     [ebp+var_4], ecx
.text$mn:0000887D                 cmp     [ebp+arg_4], 0
.text$mn:00008881                 jz      short loc_8899
.text$mn:00008883                 push    42Ah            ; unsigned int
.text$mn:00008888                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000888D                 mov     eax, [ebp+Src]
.text$mn:00008890                 push    eax             ; int
.text$mn:00008891                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00008896                 add     esp, 0Ch
.text$mn:00008899
.text$mn:00008899 loc_8899:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:00008899                 mov     ecx, [ebp+Src]
.text$mn:0000889C                 push    ecx
.text$mn:0000889D                 mov     ecx, [ebp+var_4]
.text$mn:000088A0                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000088A5                 movzx   edx, al
.text$mn:000088A8                 test    edx, edx
.text$mn:000088AA                 jz      short loc_88CE
.text$mn:000088AC                 mov     eax, [ebp+arg_4]
.text$mn:000088AF                 push    eax
.text$mn:000088B0                 mov     ecx, [ebp+var_4]
.text$mn:000088B3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000088B8                 mov     ecx, [ebp+Src]
.text$mn:000088BB                 sub     ecx, eax
.text$mn:000088BD                 sar     ecx, 1
.text$mn:000088BF                 push    ecx
.text$mn:000088C0                 mov     edx, [ebp+var_4]
.text$mn:000088C3                 push    edx
.text$mn:000088C4                 mov     ecx, [ebp+var_4]
.text$mn:000088C7                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000088CC                 jmp     short loc_893F
.text$mn:000088CE ; ---------------------------------------------------------------------------
.text$mn:000088CE
.text$mn:000088CE loc_88CE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:000088CE                 mov     eax, [ebp+var_4]
.text$mn:000088D1                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000088D7                 sub     ecx, [eax+14h]
.text$mn:000088DA                 cmp     ecx, [ebp+arg_4]
.text$mn:000088DD                 ja      short loc_88E7
.text$mn:000088DF                 mov     ecx, [ebp+var_4]
.text$mn:000088E2                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000088E7
.text$mn:000088E7 loc_88E7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:000088E7                 cmp     [ebp+arg_4], 0
.text$mn:000088EB                 jbe     short loc_893C
.text$mn:000088ED                 mov     edx, [ebp+var_4]
.text$mn:000088F0                 mov     eax, [edx+14h]
.text$mn:000088F3                 add     eax, [ebp+arg_4]
.text$mn:000088F6                 mov     [ebp+var_8], eax
.text$mn:000088F9                 push    0
.text$mn:000088FB                 mov     ecx, [ebp+var_8]
.text$mn:000088FE                 push    ecx
.text$mn:000088FF                 mov     ecx, [ebp+var_4]
.text$mn:00008902                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00008907                 movzx   edx, al
.text$mn:0000890A                 test    edx, edx
.text$mn:0000890C                 jz      short loc_893C
.text$mn:0000890E                 mov     eax, [ebp+arg_4]
.text$mn:00008911                 push    eax             ; int
.text$mn:00008912                 mov     ecx, [ebp+Src]
.text$mn:00008915                 push    ecx             ; Src
.text$mn:00008916                 mov     ecx, [ebp+var_4]
.text$mn:00008919                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000891E                 mov     edx, [ebp+var_4]
.text$mn:00008921                 mov     ecx, [edx+14h]
.text$mn:00008924                 lea     edx, [eax+ecx*2]
.text$mn:00008927                 push    edx             ; Dst
.text$mn:00008928                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000892D                 add     esp, 0Ch
.text$mn:00008930                 mov     eax, [ebp+var_8]
.text$mn:00008933                 push    eax
.text$mn:00008934                 mov     ecx, [ebp+var_4]
.text$mn:00008937                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000893C
.text$mn:0000893C loc_893C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:0000893C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:0000893C                 mov     eax, [ebp+var_4]
.text$mn:0000893F
.text$mn:0000893F loc_893F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:0000893F                 mov     esp, ebp
.text$mn:00008941                 pop     ebp
.text$mn:00008942                 retn    8
.text$mn:00008942 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00008942
.text$mn:00008942 ; ---------------------------------------------------------------------------
.text$mn:00008945                 align 4
.text$mn:00008945 _text$mn        ends
.text$mn:00008945
.text$mn:00008948 ; ===========================================================================
.text$mn:00008948
.text$mn:00008948 ; Segment type: Pure code
.text$mn:00008948 ; Segment permissions: Read/Execute
.text$mn:00008948 _text$mn        segment para public 'CODE' use32
.text$mn:00008948                 assume cs:_text$mn
.text$mn:00008948                 ;org 8948h
.text$mn:00008948 ; COMDAT (pick any)
.text$mn:00008948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008948
.text$mn:00008948 ; =============== S U B R O U T I N E =======================================
.text$mn:00008948
.text$mn:00008948 ; Attributes: bp-based frame
.text$mn:00008948
.text$mn:00008948 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00008948                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00008948 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00008948                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00008948
.text$mn:00008948 Size            = dword ptr -8
.text$mn:00008948 var_4           = dword ptr -4
.text$mn:00008948 arg_0           = dword ptr  8
.text$mn:00008948 arg_4           = dword ptr  0Ch
.text$mn:00008948 arg_8           = dword ptr  10h
.text$mn:00008948
.text$mn:00008948                 push    ebp
.text$mn:00008949                 mov     ebp, esp
.text$mn:0000894B                 sub     esp, 8
.text$mn:0000894E                 mov     [ebp+var_4], ecx
.text$mn:00008951                 mov     ecx, [ebp+arg_0]
.text$mn:00008954                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00008959                 cmp     eax, [ebp+arg_4]
.text$mn:0000895C                 jnb     short loc_8966
.text$mn:0000895E                 mov     ecx, [ebp+var_4]
.text$mn:00008961                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00008966
.text$mn:00008966 loc_8966:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00008966                 mov     ecx, [ebp+arg_0]
.text$mn:00008969                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000896E                 sub     eax, [ebp+arg_4]
.text$mn:00008971                 mov     [ebp+Size], eax
.text$mn:00008974                 mov     eax, [ebp+arg_8]
.text$mn:00008977                 cmp     eax, [ebp+Size]
.text$mn:0000897A                 jnb     short loc_8982
.text$mn:0000897C                 mov     ecx, [ebp+arg_8]
.text$mn:0000897F                 mov     [ebp+Size], ecx
.text$mn:00008982
.text$mn:00008982 loc_8982:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00008982                 mov     edx, [ebp+var_4]
.text$mn:00008985                 cmp     edx, [ebp+arg_0]
.text$mn:00008988                 jnz     short loc_89A9
.text$mn:0000898A                 mov     eax, [ebp+arg_4]
.text$mn:0000898D                 add     eax, [ebp+Size]
.text$mn:00008990                 push    eax
.text$mn:00008991                 mov     ecx, [ebp+var_4]
.text$mn:00008994                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00008999                 mov     ecx, [ebp+arg_4]
.text$mn:0000899C                 push    ecx
.text$mn:0000899D                 push    0
.text$mn:0000899F                 mov     ecx, [ebp+var_4]
.text$mn:000089A2                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000089A7                 jmp     short loc_89EB
.text$mn:000089A9 ; ---------------------------------------------------------------------------
.text$mn:000089A9
.text$mn:000089A9 loc_89A9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000089A9                 push    0
.text$mn:000089AB                 mov     edx, [ebp+Size]
.text$mn:000089AE                 push    edx
.text$mn:000089AF                 mov     ecx, [ebp+var_4]
.text$mn:000089B2                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000089B7                 movzx   eax, al
.text$mn:000089BA                 test    eax, eax
.text$mn:000089BC                 jz      short loc_89EB
.text$mn:000089BE                 mov     ecx, [ebp+Size]
.text$mn:000089C1                 push    ecx             ; Size
.text$mn:000089C2                 mov     ecx, [ebp+arg_0]
.text$mn:000089C5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000089CA                 add     eax, [ebp+arg_4]
.text$mn:000089CD                 push    eax             ; Src
.text$mn:000089CE                 mov     ecx, [ebp+var_4]
.text$mn:000089D1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000089D6                 push    eax             ; Dst
.text$mn:000089D7                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000089DC                 add     esp, 0Ch
.text$mn:000089DF                 mov     edx, [ebp+Size]
.text$mn:000089E2                 push    edx
.text$mn:000089E3                 mov     ecx, [ebp+var_4]
.text$mn:000089E6                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000089EB
.text$mn:000089EB loc_89EB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000089EB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000089EB                 mov     eax, [ebp+var_4]
.text$mn:000089EE                 mov     esp, ebp
.text$mn:000089F0                 pop     ebp
.text$mn:000089F1                 retn    0Ch
.text$mn:000089F1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000089F1
.text$mn:000089F1 _text$mn        ends
.text$mn:000089F1
.text$mn:000089F4 ; ===========================================================================
.text$mn:000089F4
.text$mn:000089F4 ; Segment type: Pure code
.text$mn:000089F4 ; Segment permissions: Read/Execute
.text$mn:000089F4 _text$mn        segment para public 'CODE' use32
.text$mn:000089F4                 assume cs:_text$mn
.text$mn:000089F4                 ;org 89F4h
.text$mn:000089F4 ; COMDAT (pick any)
.text$mn:000089F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089F4
.text$mn:000089F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000089F4
.text$mn:000089F4 ; Attributes: bp-based frame
.text$mn:000089F4
.text$mn:000089F4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000089F4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000089F4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000089F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000089F4
.text$mn:000089F4 var_4           = dword ptr -4
.text$mn:000089F4 Str             = dword ptr  8
.text$mn:000089F4
.text$mn:000089F4                 push    ebp
.text$mn:000089F5                 mov     ebp, esp
.text$mn:000089F7                 push    ecx
.text$mn:000089F8                 mov     [ebp+var_4], ecx
.text$mn:000089FB                 push    490h            ; unsigned int
.text$mn:00008A00                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008A05                 mov     eax, [ebp+Str]
.text$mn:00008A08                 push    eax             ; int
.text$mn:00008A09                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00008A0E                 add     esp, 0Ch
.text$mn:00008A11                 mov     ecx, [ebp+Str]
.text$mn:00008A14                 push    ecx             ; Str
.text$mn:00008A15                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00008A1A                 add     esp, 4
.text$mn:00008A1D                 push    eax             ; Size
.text$mn:00008A1E                 mov     edx, [ebp+Str]
.text$mn:00008A21                 push    edx             ; Src
.text$mn:00008A22                 mov     ecx, [ebp+var_4]
.text$mn:00008A25                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00008A2A                 mov     esp, ebp
.text$mn:00008A2C                 pop     ebp
.text$mn:00008A2D                 retn    4
.text$mn:00008A2D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00008A2D
.text$mn:00008A2D _text$mn        ends
.text$mn:00008A2D
.text$mn:00008A30 ; ===========================================================================
.text$mn:00008A30
.text$mn:00008A30 ; Segment type: Pure code
.text$mn:00008A30 ; Segment permissions: Read/Execute
.text$mn:00008A30 _text$mn        segment para public 'CODE' use32
.text$mn:00008A30                 assume cs:_text$mn
.text$mn:00008A30                 ;org 8A30h
.text$mn:00008A30 ; COMDAT (pick any)
.text$mn:00008A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A30
.text$mn:00008A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A30
.text$mn:00008A30 ; Attributes: bp-based frame
.text$mn:00008A30
.text$mn:00008A30 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00008A30                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00008A30 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00008A30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00008A30
.text$mn:00008A30 var_4           = dword ptr -4
.text$mn:00008A30 Src             = dword ptr  8
.text$mn:00008A30 Size            = dword ptr  0Ch
.text$mn:00008A30
.text$mn:00008A30                 push    ebp
.text$mn:00008A31                 mov     ebp, esp
.text$mn:00008A33                 push    ecx
.text$mn:00008A34                 mov     [ebp+var_4], ecx
.text$mn:00008A37                 cmp     [ebp+Size], 0
.text$mn:00008A3B                 jz      short loc_8A53
.text$mn:00008A3D                 push    47Fh            ; unsigned int
.text$mn:00008A42                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008A47                 mov     eax, [ebp+Src]
.text$mn:00008A4A                 push    eax             ; int
.text$mn:00008A4B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00008A50                 add     esp, 0Ch
.text$mn:00008A53
.text$mn:00008A53 loc_8A53:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00008A53                 mov     ecx, [ebp+Src]
.text$mn:00008A56                 push    ecx
.text$mn:00008A57                 mov     ecx, [ebp+var_4]
.text$mn:00008A5A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00008A5F                 movzx   edx, al
.text$mn:00008A62                 test    edx, edx
.text$mn:00008A64                 jz      short loc_8A86
.text$mn:00008A66                 mov     eax, [ebp+Size]
.text$mn:00008A69                 push    eax
.text$mn:00008A6A                 mov     ecx, [ebp+var_4]
.text$mn:00008A6D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00008A72                 mov     ecx, [ebp+Src]
.text$mn:00008A75                 sub     ecx, eax
.text$mn:00008A77                 push    ecx
.text$mn:00008A78                 mov     edx, [ebp+var_4]
.text$mn:00008A7B                 push    edx
.text$mn:00008A7C                 mov     ecx, [ebp+var_4]
.text$mn:00008A7F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00008A84                 jmp     short loc_8AC3
.text$mn:00008A86 ; ---------------------------------------------------------------------------
.text$mn:00008A86
.text$mn:00008A86 loc_8A86:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00008A86                 push    0
.text$mn:00008A88                 mov     eax, [ebp+Size]
.text$mn:00008A8B                 push    eax
.text$mn:00008A8C                 mov     ecx, [ebp+var_4]
.text$mn:00008A8F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00008A94                 movzx   ecx, al
.text$mn:00008A97                 test    ecx, ecx
.text$mn:00008A99                 jz      short loc_8AC0
.text$mn:00008A9B                 mov     edx, [ebp+Size]
.text$mn:00008A9E                 push    edx             ; Size
.text$mn:00008A9F                 mov     eax, [ebp+Src]
.text$mn:00008AA2                 push    eax             ; Src
.text$mn:00008AA3                 mov     ecx, [ebp+var_4]
.text$mn:00008AA6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00008AAB                 push    eax             ; Dst
.text$mn:00008AAC                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00008AB1                 add     esp, 0Ch
.text$mn:00008AB4                 mov     ecx, [ebp+Size]
.text$mn:00008AB7                 push    ecx
.text$mn:00008AB8                 mov     ecx, [ebp+var_4]
.text$mn:00008ABB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00008AC0
.text$mn:00008AC0 loc_8AC0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00008AC0                 mov     eax, [ebp+var_4]
.text$mn:00008AC3
.text$mn:00008AC3 loc_8AC3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00008AC3                 mov     esp, ebp
.text$mn:00008AC5                 pop     ebp
.text$mn:00008AC6                 retn    8
.text$mn:00008AC6 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00008AC6
.text$mn:00008AC6 ; ---------------------------------------------------------------------------
.text$mn:00008AC9                 align 4
.text$mn:00008AC9 _text$mn        ends
.text$mn:00008AC9
.text$mn:00008ACC ; ===========================================================================
.text$mn:00008ACC
.text$mn:00008ACC ; Segment type: Pure code
.text$mn:00008ACC ; Segment permissions: Read/Execute
.text$mn:00008ACC _text$mn        segment para public 'CODE' use32
.text$mn:00008ACC                 assume cs:_text$mn
.text$mn:00008ACC                 ;org 8ACCh
.text$mn:00008ACC ; COMDAT (pick any)
.text$mn:00008ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008ACC
.text$mn:00008ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00008ACC
.text$mn:00008ACC ; Attributes: bp-based frame
.text$mn:00008ACC
.text$mn:00008ACC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00008ACC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00008ACC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00008ACC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00008ACC
.text$mn:00008ACC var_8           = dword ptr -8
.text$mn:00008ACC var_4           = dword ptr -4
.text$mn:00008ACC arg_0           = dword ptr  8
.text$mn:00008ACC arg_4           = dword ptr  0Ch
.text$mn:00008ACC arg_8           = dword ptr  10h
.text$mn:00008ACC
.text$mn:00008ACC                 push    ebp
.text$mn:00008ACD                 mov     ebp, esp
.text$mn:00008ACF                 sub     esp, 8
.text$mn:00008AD2                 mov     [ebp+var_4], ecx
.text$mn:00008AD5                 mov     ecx, [ebp+arg_0]
.text$mn:00008AD8                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00008ADD                 cmp     eax, [ebp+arg_4]
.text$mn:00008AE0                 jnb     short loc_8AEA
.text$mn:00008AE2                 mov     ecx, [ebp+var_4]
.text$mn:00008AE5                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00008AEA
.text$mn:00008AEA loc_8AEA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00008AEA                 mov     ecx, [ebp+arg_0]
.text$mn:00008AED                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00008AF2                 sub     eax, [ebp+arg_4]
.text$mn:00008AF5                 mov     [ebp+var_8], eax
.text$mn:00008AF8                 mov     eax, [ebp+arg_8]
.text$mn:00008AFB                 cmp     eax, [ebp+var_8]
.text$mn:00008AFE                 jnb     short loc_8B06
.text$mn:00008B00                 mov     ecx, [ebp+arg_8]
.text$mn:00008B03                 mov     [ebp+var_8], ecx
.text$mn:00008B06
.text$mn:00008B06 loc_8B06:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00008B06                 mov     edx, [ebp+var_4]
.text$mn:00008B09                 cmp     edx, [ebp+arg_0]
.text$mn:00008B0C                 jnz     short loc_8B2D
.text$mn:00008B0E                 mov     eax, [ebp+arg_4]
.text$mn:00008B11                 add     eax, [ebp+var_8]
.text$mn:00008B14                 push    eax
.text$mn:00008B15                 mov     ecx, [ebp+var_4]
.text$mn:00008B18                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00008B1D                 mov     ecx, [ebp+arg_4]
.text$mn:00008B20                 push    ecx
.text$mn:00008B21                 push    0
.text$mn:00008B23                 mov     ecx, [ebp+var_4]
.text$mn:00008B26                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00008B2B                 jmp     short loc_8B72
.text$mn:00008B2D ; ---------------------------------------------------------------------------
.text$mn:00008B2D
.text$mn:00008B2D loc_8B2D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00008B2D                 push    0
.text$mn:00008B2F                 mov     edx, [ebp+var_8]
.text$mn:00008B32                 push    edx
.text$mn:00008B33                 mov     ecx, [ebp+var_4]
.text$mn:00008B36                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00008B3B                 movzx   eax, al
.text$mn:00008B3E                 test    eax, eax
.text$mn:00008B40                 jz      short loc_8B72
.text$mn:00008B42                 mov     ecx, [ebp+var_8]
.text$mn:00008B45                 push    ecx             ; int
.text$mn:00008B46                 mov     ecx, [ebp+arg_0]
.text$mn:00008B49                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008B4E                 mov     edx, [ebp+arg_4]
.text$mn:00008B51                 lea     eax, [eax+edx*2]
.text$mn:00008B54                 push    eax             ; Src
.text$mn:00008B55                 mov     ecx, [ebp+var_4]
.text$mn:00008B58                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008B5D                 push    eax             ; Dst
.text$mn:00008B5E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00008B63                 add     esp, 0Ch
.text$mn:00008B66                 mov     ecx, [ebp+var_8]
.text$mn:00008B69                 push    ecx
.text$mn:00008B6A                 mov     ecx, [ebp+var_4]
.text$mn:00008B6D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00008B72
.text$mn:00008B72 loc_8B72:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00008B72                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00008B72                 mov     eax, [ebp+var_4]
.text$mn:00008B75                 mov     esp, ebp
.text$mn:00008B77                 pop     ebp
.text$mn:00008B78                 retn    0Ch
.text$mn:00008B78 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00008B78
.text$mn:00008B78 ; ---------------------------------------------------------------------------
.text$mn:00008B7B                 align 4
.text$mn:00008B7B _text$mn        ends
.text$mn:00008B7B
.text$mn:00008B7C ; ===========================================================================
.text$mn:00008B7C
.text$mn:00008B7C ; Segment type: Pure code
.text$mn:00008B7C ; Segment permissions: Read/Execute
.text$mn:00008B7C _text$mn        segment para public 'CODE' use32
.text$mn:00008B7C                 assume cs:_text$mn
.text$mn:00008B7C                 ;org 8B7Ch
.text$mn:00008B7C ; COMDAT (pick any)
.text$mn:00008B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B7C
.text$mn:00008B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00008B7C
.text$mn:00008B7C ; Attributes: bp-based frame
.text$mn:00008B7C
.text$mn:00008B7C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(unsigned int, wchar_t)
.text$mn:00008B7C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
.text$mn:00008B7C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z proc near
.text$mn:00008B7C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(uint,wchar_t)+58p
.text$mn:00008B7C
.text$mn:00008B7C var_4           = dword ptr -4
.text$mn:00008B7C arg_0           = dword ptr  8
.text$mn:00008B7C arg_4           = word ptr  0Ch
.text$mn:00008B7C
.text$mn:00008B7C                 push    ebp
.text$mn:00008B7D                 mov     ebp, esp
.text$mn:00008B7F                 push    ecx
.text$mn:00008B80                 mov     [ebp+var_4], ecx
.text$mn:00008B83                 mov     eax, [ebp+arg_0]
.text$mn:00008B86                 cmp     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00008B8C                 jnz     short loc_8B96
.text$mn:00008B8E                 mov     ecx, [ebp+var_4]
.text$mn:00008B91                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00008B96
.text$mn:00008B96 loc_8B96:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(uint,wchar_t)+10j
.text$mn:00008B96                 push    0
.text$mn:00008B98                 mov     ecx, [ebp+arg_0]
.text$mn:00008B9B                 push    ecx
.text$mn:00008B9C                 mov     ecx, [ebp+var_4]
.text$mn:00008B9F                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00008BA4                 movzx   edx, al
.text$mn:00008BA7                 test    edx, edx
.text$mn:00008BA9                 jz      short loc_8BCA
.text$mn:00008BAB                 movzx   eax, [ebp+arg_4]
.text$mn:00008BAF                 push    eax
.text$mn:00008BB0                 mov     ecx, [ebp+arg_0]
.text$mn:00008BB3                 push    ecx
.text$mn:00008BB4                 push    0
.text$mn:00008BB6                 mov     ecx, [ebp+var_4]
.text$mn:00008BB9                 call    ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)
.text$mn:00008BBE                 mov     edx, [ebp+arg_0]
.text$mn:00008BC1                 push    edx
.text$mn:00008BC2                 mov     ecx, [ebp+var_4]
.text$mn:00008BC5                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00008BCA
.text$mn:00008BCA loc_8BCA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(uint,wchar_t)+2Dj
.text$mn:00008BCA                 mov     eax, [ebp+var_4]
.text$mn:00008BCD                 mov     esp, ebp
.text$mn:00008BCF                 pop     ebp
.text$mn:00008BD0                 retn    8
.text$mn:00008BD0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z endp
.text$mn:00008BD0
.text$mn:00008BD0 ; ---------------------------------------------------------------------------
.text$mn:00008BD3                 align 4
.text$mn:00008BD3 _text$mn        ends
.text$mn:00008BD3
.text$mn:00008BD4 ; ===========================================================================
.text$mn:00008BD4
.text$mn:00008BD4 ; Segment type: Pure code
.text$mn:00008BD4 ; Segment permissions: Read/Execute
.text$mn:00008BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00008BD4                 assume cs:_text$mn
.text$mn:00008BD4                 ;org 8BD4h
.text$mn:00008BD4 ; COMDAT (pick any)
.text$mn:00008BD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008BD4
.text$mn:00008BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008BD4
.text$mn:00008BD4 ; Attributes: bp-based frame
.text$mn:00008BD4
.text$mn:00008BD4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00008BD4                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00008BD4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00008BD4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:00008BD4
.text$mn:00008BD4 var_4           = dword ptr -4
.text$mn:00008BD4 Str             = dword ptr  8
.text$mn:00008BD4
.text$mn:00008BD4                 push    ebp
.text$mn:00008BD5                 mov     ebp, esp
.text$mn:00008BD7                 push    ecx
.text$mn:00008BD8                 mov     [ebp+var_4], ecx
.text$mn:00008BDB                 push    490h            ; unsigned int
.text$mn:00008BE0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008BE5                 mov     eax, [ebp+Str]
.text$mn:00008BE8                 push    eax             ; int
.text$mn:00008BE9                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00008BEE                 add     esp, 0Ch
.text$mn:00008BF1                 mov     ecx, [ebp+Str]
.text$mn:00008BF4                 push    ecx             ; Str
.text$mn:00008BF5                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00008BFA                 add     esp, 4
.text$mn:00008BFD                 push    eax             ; int
.text$mn:00008BFE                 mov     edx, [ebp+Str]
.text$mn:00008C01                 push    edx             ; Src
.text$mn:00008C02                 mov     ecx, [ebp+var_4]
.text$mn:00008C05                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00008C0A                 mov     esp, ebp
.text$mn:00008C0C                 pop     ebp
.text$mn:00008C0D                 retn    4
.text$mn:00008C0D ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00008C0D
.text$mn:00008C0D _text$mn        ends
.text$mn:00008C0D
.text$mn:00008C10 ; ===========================================================================
.text$mn:00008C10
.text$mn:00008C10 ; Segment type: Pure code
.text$mn:00008C10 ; Segment permissions: Read/Execute
.text$mn:00008C10 _text$mn        segment para public 'CODE' use32
.text$mn:00008C10                 assume cs:_text$mn
.text$mn:00008C10                 ;org 8C10h
.text$mn:00008C10 ; COMDAT (pick any)
.text$mn:00008C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008C10
.text$mn:00008C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C10
.text$mn:00008C10 ; Attributes: bp-based frame
.text$mn:00008C10
.text$mn:00008C10 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00008C10                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00008C10 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00008C10                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00008C10
.text$mn:00008C10 var_4           = dword ptr -4
.text$mn:00008C10 Src             = dword ptr  8
.text$mn:00008C10 arg_4           = dword ptr  0Ch
.text$mn:00008C10
.text$mn:00008C10                 push    ebp
.text$mn:00008C11                 mov     ebp, esp
.text$mn:00008C13                 push    ecx
.text$mn:00008C14                 mov     [ebp+var_4], ecx
.text$mn:00008C17                 cmp     [ebp+arg_4], 0
.text$mn:00008C1B                 jz      short loc_8C33
.text$mn:00008C1D                 push    47Fh            ; unsigned int
.text$mn:00008C22                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008C27                 mov     eax, [ebp+Src]
.text$mn:00008C2A                 push    eax             ; int
.text$mn:00008C2B                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00008C30                 add     esp, 0Ch
.text$mn:00008C33
.text$mn:00008C33 loc_8C33:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00008C33                 mov     ecx, [ebp+Src]
.text$mn:00008C36                 push    ecx
.text$mn:00008C37                 mov     ecx, [ebp+var_4]
.text$mn:00008C3A                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00008C3F                 movzx   edx, al
.text$mn:00008C42                 test    edx, edx
.text$mn:00008C44                 jz      short loc_8C68
.text$mn:00008C46                 mov     eax, [ebp+arg_4]
.text$mn:00008C49                 push    eax
.text$mn:00008C4A                 mov     ecx, [ebp+var_4]
.text$mn:00008C4D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008C52                 mov     ecx, [ebp+Src]
.text$mn:00008C55                 sub     ecx, eax
.text$mn:00008C57                 sar     ecx, 1
.text$mn:00008C59                 push    ecx
.text$mn:00008C5A                 mov     edx, [ebp+var_4]
.text$mn:00008C5D                 push    edx
.text$mn:00008C5E                 mov     ecx, [ebp+var_4]
.text$mn:00008C61                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00008C66                 jmp     short loc_8CA5
.text$mn:00008C68 ; ---------------------------------------------------------------------------
.text$mn:00008C68
.text$mn:00008C68 loc_8C68:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00008C68                 push    0
.text$mn:00008C6A                 mov     eax, [ebp+arg_4]
.text$mn:00008C6D                 push    eax
.text$mn:00008C6E                 mov     ecx, [ebp+var_4]
.text$mn:00008C71                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00008C76                 movzx   ecx, al
.text$mn:00008C79                 test    ecx, ecx
.text$mn:00008C7B                 jz      short loc_8CA2
.text$mn:00008C7D                 mov     edx, [ebp+arg_4]
.text$mn:00008C80                 push    edx             ; int
.text$mn:00008C81                 mov     eax, [ebp+Src]
.text$mn:00008C84                 push    eax             ; Src
.text$mn:00008C85                 mov     ecx, [ebp+var_4]
.text$mn:00008C88                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008C8D                 push    eax             ; Dst
.text$mn:00008C8E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00008C93                 add     esp, 0Ch
.text$mn:00008C96                 mov     ecx, [ebp+arg_4]
.text$mn:00008C99                 push    ecx
.text$mn:00008C9A                 mov     ecx, [ebp+var_4]
.text$mn:00008C9D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00008CA2
.text$mn:00008CA2 loc_8CA2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00008CA2                 mov     eax, [ebp+var_4]
.text$mn:00008CA5
.text$mn:00008CA5 loc_8CA5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00008CA5                 mov     esp, ebp
.text$mn:00008CA7                 pop     ebp
.text$mn:00008CA8                 retn    8
.text$mn:00008CA8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00008CA8
.text$mn:00008CA8 ; ---------------------------------------------------------------------------
.text$mn:00008CAB                 align 4
.text$mn:00008CAB _text$mn        ends
.text$mn:00008CAB
.text$mn:00008CAC ; ===========================================================================
.text$mn:00008CAC
.text$mn:00008CAC ; Segment type: Pure code
.text$mn:00008CAC ; Segment permissions: Read/Execute
.text$mn:00008CAC _text$mn        segment para public 'CODE' use32
.text$mn:00008CAC                 assume cs:_text$mn
.text$mn:00008CAC                 ;org 8CACh
.text$mn:00008CAC ; COMDAT (pick any)
.text$mn:00008CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008CAC
.text$mn:00008CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00008CAC
.text$mn:00008CAC ; Attributes: bp-based frame
.text$mn:00008CAC
.text$mn:00008CAC ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00008CAC                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00008CAC ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00008CAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00008CAC
.text$mn:00008CAC arg_0           = dword ptr  8
.text$mn:00008CAC arg_4           = dword ptr  0Ch
.text$mn:00008CAC
.text$mn:00008CAC                 push    ebp
.text$mn:00008CAD                 mov     ebp, esp
.text$mn:00008CAF                 mov     eax, [ebp+arg_0]
.text$mn:00008CB2                 mov     ecx, [ebp+arg_4]
.text$mn:00008CB5                 mov     dl, [ecx]
.text$mn:00008CB7                 mov     [eax], dl
.text$mn:00008CB9                 pop     ebp
.text$mn:00008CBA                 retn
.text$mn:00008CBA ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00008CBA
.text$mn:00008CBA ; ---------------------------------------------------------------------------
.text$mn:00008CBB                 align 4
.text$mn:00008CBB _text$mn        ends
.text$mn:00008CBB
.text$mn:00008CBC ; ===========================================================================
.text$mn:00008CBC
.text$mn:00008CBC ; Segment type: Pure code
.text$mn:00008CBC ; Segment permissions: Read/Execute
.text$mn:00008CBC _text$mn        segment para public 'CODE' use32
.text$mn:00008CBC                 assume cs:_text$mn
.text$mn:00008CBC                 ;org 8CBCh
.text$mn:00008CBC ; COMDAT (pick any)
.text$mn:00008CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008CBC
.text$mn:00008CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00008CBC
.text$mn:00008CBC ; Attributes: bp-based frame
.text$mn:00008CBC
.text$mn:00008CBC ; public: static wchar_t * __cdecl std::char_traits<wchar_t>::assign(wchar_t *, unsigned int, wchar_t)
.text$mn:00008CBC                 public ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z
.text$mn:00008CBC ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z proc near
.text$mn:00008CBC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+42p
.text$mn:00008CBC
.text$mn:00008CBC arg_0           = dword ptr  8
.text$mn:00008CBC arg_4           = dword ptr  0Ch
.text$mn:00008CBC arg_8           = word ptr  10h
.text$mn:00008CBC
.text$mn:00008CBC                 push    ebp
.text$mn:00008CBD                 mov     ebp, esp
.text$mn:00008CBF                 mov     eax, [ebp+arg_4]
.text$mn:00008CC2                 push    eax
.text$mn:00008CC3                 movzx   ecx, [ebp+arg_8]
.text$mn:00008CC7                 push    ecx
.text$mn:00008CC8                 mov     edx, [ebp+arg_0]
.text$mn:00008CCB                 push    edx
.text$mn:00008CCC                 call    _wmemset
.text$mn:00008CD1                 add     esp, 0Ch
.text$mn:00008CD4                 pop     ebp
.text$mn:00008CD5                 retn
.text$mn:00008CD5 ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z endp
.text$mn:00008CD5
.text$mn:00008CD5 ; ---------------------------------------------------------------------------
.text$mn:00008CD6                 align 4
.text$mn:00008CD6 _text$mn        ends
.text$mn:00008CD6
.text$mn:00008CD8 ; ===========================================================================
.text$mn:00008CD8
.text$mn:00008CD8 ; Segment type: Pure code
.text$mn:00008CD8 ; Segment permissions: Read/Execute
.text$mn:00008CD8 _text$mn        segment para public 'CODE' use32
.text$mn:00008CD8                 assume cs:_text$mn
.text$mn:00008CD8                 ;org 8CD8h
.text$mn:00008CD8 ; COMDAT (pick any)
.text$mn:00008CD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008CD8
.text$mn:00008CD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008CD8
.text$mn:00008CD8 ; Attributes: bp-based frame
.text$mn:00008CD8
.text$mn:00008CD8 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00008CD8                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00008CD8 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00008CD8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Chassign(uint,uint,wchar_t)+20p
.text$mn:00008CD8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00008CD8
.text$mn:00008CD8 arg_0           = dword ptr  8
.text$mn:00008CD8 arg_4           = dword ptr  0Ch
.text$mn:00008CD8
.text$mn:00008CD8                 push    ebp
.text$mn:00008CD9                 mov     ebp, esp
.text$mn:00008CDB                 mov     eax, [ebp+arg_0]
.text$mn:00008CDE                 mov     ecx, [ebp+arg_4]
.text$mn:00008CE1                 mov     dx, [ecx]
.text$mn:00008CE4                 mov     [eax], dx
.text$mn:00008CE7                 pop     ebp
.text$mn:00008CE8                 retn
.text$mn:00008CE8 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00008CE8
.text$mn:00008CE8 ; ---------------------------------------------------------------------------
.text$mn:00008CE9                 align 4
.text$mn:00008CE9 _text$mn        ends
.text$mn:00008CE9
.text$mn:00008CEC ; ===========================================================================
.text$mn:00008CEC
.text$mn:00008CEC ; Segment type: Pure code
.text$mn:00008CEC ; Segment permissions: Read/Execute
.text$mn:00008CEC _text$mn        segment para public 'CODE' use32
.text$mn:00008CEC                 assume cs:_text$mn
.text$mn:00008CEC                 ;org 8CECh
.text$mn:00008CEC ; COMDAT (pick any)
.text$mn:00008CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008CEC
.text$mn:00008CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00008CEC
.text$mn:00008CEC ; Attributes: bp-based frame
.text$mn:00008CEC
.text$mn:00008CEC ; public: int & __thiscall std::vector<int, class std::allocator<int>>::at(unsigned int)
.text$mn:00008CEC                 public ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
.text$mn:00008CEC ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z proc near
.text$mn:00008CEC                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+CF6p
.text$mn:00008CEC
.text$mn:00008CEC var_4           = dword ptr -4
.text$mn:00008CEC arg_0           = dword ptr  8
.text$mn:00008CEC
.text$mn:00008CEC                 push    ebp
.text$mn:00008CED                 mov     ebp, esp
.text$mn:00008CEF                 push    ecx
.text$mn:00008CF0                 mov     [ebp+var_4], ecx
.text$mn:00008CF3                 mov     ecx, [ebp+var_4]
.text$mn:00008CF6                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00008CFB                 cmp     eax, [ebp+arg_0]
.text$mn:00008CFE                 ja      short loc_8D08
.text$mn:00008D00                 mov     ecx, [ebp+var_4]
.text$mn:00008D03                 call    ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int>>::_Xran(void)
.text$mn:00008D08
.text$mn:00008D08 loc_8D08:                               ; CODE XREF: std::vector<int,std::allocator<int>>::at(uint)+12j
.text$mn:00008D08                 mov     eax, [ebp+var_4]
.text$mn:00008D0B                 mov     ecx, [eax+4]
.text$mn:00008D0E                 mov     edx, [ebp+arg_0]
.text$mn:00008D11                 lea     eax, [ecx+edx*4]
.text$mn:00008D14                 mov     esp, ebp
.text$mn:00008D16                 pop     ebp
.text$mn:00008D17                 retn    4
.text$mn:00008D17 ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z endp
.text$mn:00008D17
.text$mn:00008D17 ; ---------------------------------------------------------------------------
.text$mn:00008D1A                 align 4
.text$mn:00008D1A _text$mn        ends
.text$mn:00008D1A
.text$mn:00008D1C ; ===========================================================================
.text$mn:00008D1C
.text$mn:00008D1C ; Segment type: Pure code
.text$mn:00008D1C ; Segment permissions: Read/Execute
.text$mn:00008D1C _text$mn        segment para public 'CODE' use32
.text$mn:00008D1C                 assume cs:_text$mn
.text$mn:00008D1C                 ;org 8D1Ch
.text$mn:00008D1C ; COMDAT (pick any)
.text$mn:00008D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D1C
.text$mn:00008D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00008D1C
.text$mn:00008D1C ; Attributes: bp-based frame
.text$mn:00008D1C
.text$mn:00008D1C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>> __thiscall std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>::begin(void)
.text$mn:00008D1C                 public ?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.text$mn:00008D1C ?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ proc near
.text$mn:00008D1C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+275p
.text$mn:00008D1C                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+306p ...
.text$mn:00008D1C
.text$mn:00008D1C var_14          = dword ptr -14h
.text$mn:00008D1C var_10          = dword ptr -10h
.text$mn:00008D1C var_C           = dword ptr -0Ch
.text$mn:00008D1C var_4           = dword ptr -4
.text$mn:00008D1C arg_0           = dword ptr  8
.text$mn:00008D1C
.text$mn:00008D1C                 push    ebp
.text$mn:00008D1D                 mov     ebp, esp
.text$mn:00008D1F                 push    0FFFFFFFFh
.text$mn:00008D21                 push    offset __ehhandler$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.text$mn:00008D26                 mov     eax, large fs:0
.text$mn:00008D2C                 push    eax
.text$mn:00008D2D                 sub     esp, 8
.text$mn:00008D30                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008D35                 xor     eax, ebp
.text$mn:00008D37                 push    eax
.text$mn:00008D38                 lea     eax, [ebp+var_C]
.text$mn:00008D3B                 mov     large fs:0, eax
.text$mn:00008D41                 mov     [ebp+var_10], ecx
.text$mn:00008D44                 mov     [ebp+var_14], 0
.text$mn:00008D4B                 mov     eax, [ebp+var_10]
.text$mn:00008D4E                 push    eax             ; struct std::_Container_base12 *
.text$mn:00008D4F                 mov     ecx, [ebp+var_10]
.text$mn:00008D52                 mov     edx, [ecx+4]
.text$mn:00008D55                 push    edx             ; int
.text$mn:00008D56                 mov     ecx, [ebp+arg_0]
.text$mn:00008D59                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)
.text$mn:00008D5E                 mov     [ebp+var_4], 0
.text$mn:00008D65                 mov     eax, [ebp+var_14]
.text$mn:00008D68                 or      eax, 1
.text$mn:00008D6B                 mov     [ebp+var_14], eax
.text$mn:00008D6E                 mov     eax, [ebp+arg_0]
.text$mn:00008D71                 mov     ecx, [ebp+var_C]
.text$mn:00008D74                 mov     large fs:0, ecx
.text$mn:00008D7B                 pop     ecx
.text$mn:00008D7C                 mov     esp, ebp
.text$mn:00008D7E                 pop     ebp
.text$mn:00008D7F                 retn    4
.text$mn:00008D7F ?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ endp
.text$mn:00008D7F
.text$mn:00008D7F ; ---------------------------------------------------------------------------
.text$mn:00008D82                 align 4
.text$mn:00008D82 _text$mn        ends
.text$mn:00008D82
.text$x:00008D84 ; ===========================================================================
.text$x:00008D84
.text$x:00008D84 ; Segment type: Pure code
.text$x:00008D84 ; Segment permissions: Read/Execute
.text$x:00008D84 _text$x         segment para public 'CODE' use32
.text$x:00008D84                 assume cs:_text$x
.text$x:00008D84                 ;org 8D84h
.text$x:00008D84 ; COMDAT (pick associative to section at 8D1C)
.text$x:00008D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008D84
.text$x:00008D84 ; =============== S U B R O U T I N E =======================================
.text$x:00008D84
.text$x:00008D84
.text$x:00008D84 __unwindfunclet$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0 proc near
.text$x:00008D84                                         ; DATA XREF: .xdata$x:0000A788o
.text$x:00008D84                 mov     eax, [ebp-14h]
.text$x:00008D87                 and     eax, 1
.text$x:00008D8A                 jz      $LN4_0
.text$x:00008D90                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008D94                 mov     ecx, [ebp+8]
.text$x:00008D97                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:00008D9C ; ---------------------------------------------------------------------------
.text$x:00008D9C
.text$x:00008D9C $LN4_0:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0+6j
.text$x:00008D9C                 retn
.text$x:00008D9C __unwindfunclet$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0 endp
.text$x:00008D9C
.text$x:00008D9D
.text$x:00008D9D ; =============== S U B R O U T I N E =======================================
.text$x:00008D9D
.text$x:00008D9D
.text$x:00008D9D __ehhandler$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ proc near
.text$x:00008D9D                                         ; DATA XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::begin(void)+5o
.text$x:00008D9D
.text$x:00008D9D arg_4           = dword ptr  8
.text$x:00008D9D
.text$x:00008D9D                 mov     edx, [esp+arg_4]
.text$x:00008DA1                 lea     eax, [edx+0Ch]
.text$x:00008DA4                 mov     ecx, [edx-0Ch]
.text$x:00008DA7                 xor     ecx, eax
.text$x:00008DA9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008DAE                 mov     eax, offset __ehfuncinfo$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.text$x:00008DB3                 jmp     ___CxxFrameHandler3
.text$x:00008DB3 __ehhandler$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ endp
.text$x:00008DB3
.text$x:00008DB3 _text$x         ends
.text$x:00008DB3
.text$mn:00008DB8 ; ===========================================================================
.text$mn:00008DB8
.text$mn:00008DB8 ; Segment type: Pure code
.text$mn:00008DB8 ; Segment permissions: Read/Execute
.text$mn:00008DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00008DB8                 assume cs:_text$mn
.text$mn:00008DB8                 ;org 8DB8h
.text$mn:00008DB8 ; COMDAT (pick any)
.text$mn:00008DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008DB8
.text$mn:00008DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008DB8
.text$mn:00008DB8 ; Attributes: bp-based frame
.text$mn:00008DB8
.text$mn:00008DB8 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00008DB8                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00008DB8 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00008DB8                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+637p
.text$mn:00008DB8                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+DD8p
.text$mn:00008DB8
.text$mn:00008DB8 var_4           = dword ptr -4
.text$mn:00008DB8
.text$mn:00008DB8                 push    ebp
.text$mn:00008DB9                 mov     ebp, esp
.text$mn:00008DBB                 push    ecx
.text$mn:00008DBC                 mov     [ebp+var_4], ecx
.text$mn:00008DBF                 mov     ecx, [ebp+var_4]
.text$mn:00008DC2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008DC7                 mov     esp, ebp
.text$mn:00008DC9                 pop     ebp
.text$mn:00008DCA                 retn
.text$mn:00008DCA ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00008DCA
.text$mn:00008DCA ; ---------------------------------------------------------------------------
.text$mn:00008DCB                 align 4
.text$mn:00008DCB _text$mn        ends
.text$mn:00008DCB
.text$mn:00008DCC ; ===========================================================================
.text$mn:00008DCC
.text$mn:00008DCC ; Segment type: Pure code
.text$mn:00008DCC ; Segment permissions: Read/Execute
.text$mn:00008DCC _text$mn        segment para public 'CODE' use32
.text$mn:00008DCC                 assume cs:_text$mn
.text$mn:00008DCC                 ;org 8DCCh
.text$mn:00008DCC ; COMDAT (pick any)
.text$mn:00008DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008DCC
.text$mn:00008DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00008DCC
.text$mn:00008DCC ; Attributes: bp-based frame
.text$mn:00008DCC
.text$mn:00008DCC ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::capacity(void)const
.text$mn:00008DCC                 public ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00008DCC ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00008DCC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+Cp
.text$mn:00008DCC
.text$mn:00008DCC var_4           = dword ptr -4
.text$mn:00008DCC
.text$mn:00008DCC                 push    ebp
.text$mn:00008DCD                 mov     ebp, esp
.text$mn:00008DCF                 push    ecx
.text$mn:00008DD0                 mov     [ebp+var_4], ecx
.text$mn:00008DD3                 mov     eax, [ebp+var_4]
.text$mn:00008DD6                 mov     ecx, [ebp+var_4]
.text$mn:00008DD9                 mov     eax, [eax+0Ch]
.text$mn:00008DDC                 sub     eax, [ecx+4]
.text$mn:00008DDF                 sar     eax, 2
.text$mn:00008DE2                 mov     esp, ebp
.text$mn:00008DE4                 pop     ebp
.text$mn:00008DE5                 retn
.text$mn:00008DE5 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00008DE5
.text$mn:00008DE5 ; ---------------------------------------------------------------------------
.text$mn:00008DE6                 align 4
.text$mn:00008DE6 _text$mn        ends
.text$mn:00008DE6
.text$mn:00008DE8 ; ===========================================================================
.text$mn:00008DE8
.text$mn:00008DE8 ; Segment type: Pure code
.text$mn:00008DE8 ; Segment permissions: Read/Execute
.text$mn:00008DE8 _text$mn        segment para public 'CODE' use32
.text$mn:00008DE8                 assume cs:_text$mn
.text$mn:00008DE8                 ;org 8DE8h
.text$mn:00008DE8 ; COMDAT (pick any)
.text$mn:00008DE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008DE8
.text$mn:00008DE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008DE8
.text$mn:00008DE8 ; Attributes: bp-based frame
.text$mn:00008DE8
.text$mn:00008DE8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00008DE8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00008DE8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00008DE8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00008DE8
.text$mn:00008DE8 var_4           = dword ptr -4
.text$mn:00008DE8
.text$mn:00008DE8                 push    ebp
.text$mn:00008DE9                 mov     ebp, esp
.text$mn:00008DEB                 push    ecx
.text$mn:00008DEC                 mov     [ebp+var_4], ecx
.text$mn:00008DEF                 mov     eax, [ebp+var_4]
.text$mn:00008DF2                 mov     eax, [eax+4]
.text$mn:00008DF5                 mov     esp, ebp
.text$mn:00008DF7                 pop     ebp
.text$mn:00008DF8                 retn
.text$mn:00008DF8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00008DF8
.text$mn:00008DF8 ; ---------------------------------------------------------------------------
.text$mn:00008DF9                 align 4
.text$mn:00008DF9 _text$mn        ends
.text$mn:00008DF9
.text$mn:00008DFC ; ===========================================================================
.text$mn:00008DFC
.text$mn:00008DFC ; Segment type: Pure code
.text$mn:00008DFC ; Segment permissions: Read/Execute
.text$mn:00008DFC _text$mn        segment para public 'CODE' use32
.text$mn:00008DFC                 assume cs:_text$mn
.text$mn:00008DFC                 ;org 8DFCh
.text$mn:00008DFC ; COMDAT (pick any)
.text$mn:00008DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008DFC
.text$mn:00008DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00008DFC
.text$mn:00008DFC ; Attributes: bp-based frame
.text$mn:00008DFC
.text$mn:00008DFC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00008DFC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00008DFC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00008DFC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00008DFC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00008DFC
.text$mn:00008DFC var_4           = dword ptr -4
.text$mn:00008DFC
.text$mn:00008DFC                 push    ebp
.text$mn:00008DFD                 mov     ebp, esp
.text$mn:00008DFF                 push    ecx
.text$mn:00008E00                 mov     [ebp+var_4], ecx
.text$mn:00008E03                 mov     eax, [ebp+var_4]
.text$mn:00008E06                 mov     eax, [eax+4]
.text$mn:00008E09                 mov     esp, ebp
.text$mn:00008E0B                 pop     ebp
.text$mn:00008E0C                 retn
.text$mn:00008E0C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00008E0C
.text$mn:00008E0C ; ---------------------------------------------------------------------------
.text$mn:00008E0D                 align 10h
.text$mn:00008E0D _text$mn        ends
.text$mn:00008E0D
.text$mn:00008E10 ; ===========================================================================
.text$mn:00008E10
.text$mn:00008E10 ; Segment type: Pure code
.text$mn:00008E10 ; Segment permissions: Read/Execute
.text$mn:00008E10 _text$mn        segment para public 'CODE' use32
.text$mn:00008E10                 assume cs:_text$mn
.text$mn:00008E10                 ;org 8E10h
.text$mn:00008E10 ; COMDAT (pick any)
.text$mn:00008E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E10
.text$mn:00008E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E10
.text$mn:00008E10 ; Attributes: bp-based frame
.text$mn:00008E10
.text$mn:00008E10 ; int __stdcall std::allocator<int>::construct(void *, int)
.text$mn:00008E10                 public ?construct@?$allocator@H@std@@QAEXPAHABH@Z
.text$mn:00008E10 ?construct@?$allocator@H@std@@QAEXPAHABH@Z proc near
.text$mn:00008E10                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)+17p
.text$mn:00008E10
.text$mn:00008E10 var_C           = dword ptr -0Ch
.text$mn:00008E10 var_8           = dword ptr -8
.text$mn:00008E10 var_4           = dword ptr -4
.text$mn:00008E10 arg_0           = dword ptr  8
.text$mn:00008E10 arg_4           = dword ptr  0Ch
.text$mn:00008E10
.text$mn:00008E10                 push    ebp
.text$mn:00008E11                 mov     ebp, esp
.text$mn:00008E13                 sub     esp, 0Ch
.text$mn:00008E16                 mov     [ebp+var_C], ecx
.text$mn:00008E19                 mov     eax, [ebp+arg_0]
.text$mn:00008E1C                 push    eax             ; void *
.text$mn:00008E1D                 push    4               ; unsigned int
.text$mn:00008E1F                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00008E24                 add     esp, 8
.text$mn:00008E27                 mov     [ebp+var_4], eax
.text$mn:00008E2A                 cmp     [ebp+var_4], 0
.text$mn:00008E2E                 jz      short loc_8E42
.text$mn:00008E30                 mov     ecx, [ebp+var_4]
.text$mn:00008E33                 mov     edx, [ebp+arg_4]
.text$mn:00008E36                 mov     eax, [edx]
.text$mn:00008E38                 mov     [ecx], eax
.text$mn:00008E3A                 mov     ecx, [ebp+var_4]
.text$mn:00008E3D                 mov     [ebp+var_8], ecx
.text$mn:00008E40                 jmp     short loc_8E49
.text$mn:00008E42 ; ---------------------------------------------------------------------------
.text$mn:00008E42
.text$mn:00008E42 loc_8E42:                               ; CODE XREF: std::allocator<int>::construct(int *,int const &)+1Ej
.text$mn:00008E42                 mov     [ebp+var_8], 0
.text$mn:00008E49
.text$mn:00008E49 loc_8E49:                               ; CODE XREF: std::allocator<int>::construct(int *,int const &)+30j
.text$mn:00008E49                 mov     esp, ebp
.text$mn:00008E4B                 pop     ebp
.text$mn:00008E4C                 retn    8
.text$mn:00008E4C ?construct@?$allocator@H@std@@QAEXPAHABH@Z endp
.text$mn:00008E4C
.text$mn:00008E4C ; ---------------------------------------------------------------------------
.text$mn:00008E4F                 align 10h
.text$mn:00008E4F _text$mn        ends
.text$mn:00008E4F
.text$mn:00008E50 ; ===========================================================================
.text$mn:00008E50
.text$mn:00008E50 ; Segment type: Pure code
.text$mn:00008E50 ; Segment permissions: Read/Execute
.text$mn:00008E50 _text$mn        segment para public 'CODE' use32
.text$mn:00008E50                 assume cs:_text$mn
.text$mn:00008E50                 ;org 8E50h
.text$mn:00008E50 ; COMDAT (pick any)
.text$mn:00008E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E50
.text$mn:00008E50 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E50
.text$mn:00008E50 ; Attributes: bp-based frame
.text$mn:00008E50
.text$mn:00008E50 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00008E50                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00008E50 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00008E50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00008E50
.text$mn:00008E50 var_4           = dword ptr -4
.text$mn:00008E50 Dst             = dword ptr  8
.text$mn:00008E50 Src             = dword ptr  0Ch
.text$mn:00008E50 Size            = dword ptr  10h
.text$mn:00008E50
.text$mn:00008E50                 push    ebp
.text$mn:00008E51                 mov     ebp, esp
.text$mn:00008E53                 push    ecx
.text$mn:00008E54                 cmp     [ebp+Size], 0
.text$mn:00008E58                 jnz     short loc_8E62
.text$mn:00008E5A                 mov     eax, [ebp+Dst]
.text$mn:00008E5D                 mov     [ebp+var_4], eax
.text$mn:00008E60                 jmp     short loc_8E79
.text$mn:00008E62 ; ---------------------------------------------------------------------------
.text$mn:00008E62
.text$mn:00008E62 loc_8E62:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00008E62                 mov     ecx, [ebp+Size]
.text$mn:00008E65                 push    ecx             ; Size
.text$mn:00008E66                 mov     edx, [ebp+Src]
.text$mn:00008E69                 push    edx             ; Src
.text$mn:00008E6A                 mov     eax, [ebp+Dst]
.text$mn:00008E6D                 push    eax             ; Dst
.text$mn:00008E6E                 call    _memcpy
.text$mn:00008E73                 add     esp, 0Ch
.text$mn:00008E76                 mov     [ebp+var_4], eax
.text$mn:00008E79
.text$mn:00008E79 loc_8E79:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00008E79                 mov     eax, [ebp+var_4]
.text$mn:00008E7C                 mov     esp, ebp
.text$mn:00008E7E                 pop     ebp
.text$mn:00008E7F                 retn
.text$mn:00008E7F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00008E7F
.text$mn:00008E7F _text$mn        ends
.text$mn:00008E7F
.text$mn:00008E80 ; ===========================================================================
.text$mn:00008E80
.text$mn:00008E80 ; Segment type: Pure code
.text$mn:00008E80 ; Segment permissions: Read/Execute
.text$mn:00008E80 _text$mn        segment para public 'CODE' use32
.text$mn:00008E80                 assume cs:_text$mn
.text$mn:00008E80                 ;org 8E80h
.text$mn:00008E80 ; COMDAT (pick any)
.text$mn:00008E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E80
.text$mn:00008E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E80
.text$mn:00008E80 ; Attributes: bp-based frame
.text$mn:00008E80
.text$mn:00008E80 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00008E80                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00008E80 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00008E80                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00008E80                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00008E80
.text$mn:00008E80 var_4           = dword ptr -4
.text$mn:00008E80 Dst             = dword ptr  8
.text$mn:00008E80 Src             = dword ptr  0Ch
.text$mn:00008E80 arg_8           = dword ptr  10h
.text$mn:00008E80
.text$mn:00008E80                 push    ebp
.text$mn:00008E81                 mov     ebp, esp
.text$mn:00008E83                 push    ecx
.text$mn:00008E84                 cmp     [ebp+arg_8], 0
.text$mn:00008E88                 jnz     short loc_8E92
.text$mn:00008E8A                 mov     eax, [ebp+Dst]
.text$mn:00008E8D                 mov     [ebp+var_4], eax
.text$mn:00008E90                 jmp     short loc_8EA9
.text$mn:00008E92 ; ---------------------------------------------------------------------------
.text$mn:00008E92
.text$mn:00008E92 loc_8E92:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00008E92                 mov     ecx, [ebp+arg_8]
.text$mn:00008E95                 push    ecx             ; int
.text$mn:00008E96                 mov     edx, [ebp+Src]
.text$mn:00008E99                 push    edx             ; Src
.text$mn:00008E9A                 mov     eax, [ebp+Dst]
.text$mn:00008E9D                 push    eax             ; Dst
.text$mn:00008E9E                 call    _wmemcpy
.text$mn:00008EA3                 add     esp, 0Ch
.text$mn:00008EA6                 mov     [ebp+var_4], eax
.text$mn:00008EA9
.text$mn:00008EA9 loc_8EA9:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00008EA9                 mov     eax, [ebp+var_4]
.text$mn:00008EAC                 mov     esp, ebp
.text$mn:00008EAE                 pop     ebp
.text$mn:00008EAF                 retn
.text$mn:00008EAF ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00008EAF
.text$mn:00008EAF _text$mn        ends
.text$mn:00008EAF
.text$mn:00008EB0 ; ===========================================================================
.text$mn:00008EB0
.text$mn:00008EB0 ; Segment type: Pure code
.text$mn:00008EB0 ; Segment permissions: Read/Execute
.text$mn:00008EB0 _text$mn        segment para public 'CODE' use32
.text$mn:00008EB0                 assume cs:_text$mn
.text$mn:00008EB0                 ;org 8EB0h
.text$mn:00008EB0 ; COMDAT (pick any)
.text$mn:00008EB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008EB0
.text$mn:00008EB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008EB0
.text$mn:00008EB0 ; Attributes: bp-based frame
.text$mn:00008EB0
.text$mn:00008EB0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00008EB0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00008EB0 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00008EB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00008EB0
.text$mn:00008EB0 var_4           = dword ptr -4
.text$mn:00008EB0 arg_0           = dword ptr  8
.text$mn:00008EB0 arg_4           = dword ptr  0Ch
.text$mn:00008EB0
.text$mn:00008EB0                 push    ebp
.text$mn:00008EB1                 mov     ebp, esp
.text$mn:00008EB3                 push    ecx
.text$mn:00008EB4                 mov     [ebp+var_4], ecx
.text$mn:00008EB7                 mov     eax, [ebp+arg_4]
.text$mn:00008EBA                 push    eax             ; int
.text$mn:00008EBB                 mov     ecx, [ebp+arg_0]
.text$mn:00008EBE                 push    ecx             ; void *
.text$mn:00008EBF                 mov     ecx, [ebp+var_4]
.text$mn:00008EC2                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00008EC7                 mov     esp, ebp
.text$mn:00008EC9                 pop     ebp
.text$mn:00008ECA                 retn    8
.text$mn:00008ECA ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00008ECA
.text$mn:00008ECA ; ---------------------------------------------------------------------------
.text$mn:00008ECD                 align 10h
.text$mn:00008ECD _text$mn        ends
.text$mn:00008ECD
.text$mn:00008ED0 ; ===========================================================================
.text$mn:00008ED0
.text$mn:00008ED0 ; Segment type: Pure code
.text$mn:00008ED0 ; Segment permissions: Read/Execute
.text$mn:00008ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00008ED0                 assume cs:_text$mn
.text$mn:00008ED0                 ;org 8ED0h
.text$mn:00008ED0 ; COMDAT (pick any)
.text$mn:00008ED0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008ED0
.text$mn:00008ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008ED0
.text$mn:00008ED0 ; Attributes: bp-based frame
.text$mn:00008ED0
.text$mn:00008ED0 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::deallocate(void *, int)
.text$mn:00008ED0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z
.text$mn:00008ED0 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z proc near
.text$mn:00008ED0                                         ; CODE XREF: __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0+16p
.text$mn:00008ED0                                         ; std::vector<int,std::allocator<int>>::_Reallocate(uint)+F5p ...
.text$mn:00008ED0
.text$mn:00008ED0 var_4           = dword ptr -4
.text$mn:00008ED0 arg_0           = dword ptr  8
.text$mn:00008ED0 arg_4           = dword ptr  0Ch
.text$mn:00008ED0
.text$mn:00008ED0                 push    ebp
.text$mn:00008ED1                 mov     ebp, esp
.text$mn:00008ED3                 push    ecx
.text$mn:00008ED4                 mov     [ebp+var_4], ecx
.text$mn:00008ED7                 mov     eax, [ebp+arg_4]
.text$mn:00008EDA                 push    eax             ; int
.text$mn:00008EDB                 mov     ecx, [ebp+arg_0]
.text$mn:00008EDE                 push    ecx             ; void *
.text$mn:00008EDF                 mov     ecx, [ebp+var_4]
.text$mn:00008EE2                 call    ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate(int *,uint)
.text$mn:00008EE7                 mov     esp, ebp
.text$mn:00008EE9                 pop     ebp
.text$mn:00008EEA                 retn    8
.text$mn:00008EEA ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z endp
.text$mn:00008EEA
.text$mn:00008EEA ; ---------------------------------------------------------------------------
.text$mn:00008EED                 align 10h
.text$mn:00008EED _text$mn        ends
.text$mn:00008EED
.text$mn:00008EF0 ; ===========================================================================
.text$mn:00008EF0
.text$mn:00008EF0 ; Segment type: Pure code
.text$mn:00008EF0 ; Segment permissions: Read/Execute
.text$mn:00008EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00008EF0                 assume cs:_text$mn
.text$mn:00008EF0                 ;org 8EF0h
.text$mn:00008EF0 ; COMDAT (pick any)
.text$mn:00008EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008EF0
.text$mn:00008EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008EF0
.text$mn:00008EF0 ; Attributes: bp-based frame
.text$mn:00008EF0
.text$mn:00008EF0 ; int __stdcall std::_Wrap_alloc<std::allocator<ColumnModeInfo>>::deallocate(void *, int)
.text$mn:00008EF0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@I@Z
.text$mn:00008EF0 ?deallocate@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@I@Z proc near
.text$mn:00008EF0                                         ; CODE XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::_Tidy(void)+5Cp
.text$mn:00008EF0
.text$mn:00008EF0 var_4           = dword ptr -4
.text$mn:00008EF0 arg_0           = dword ptr  8
.text$mn:00008EF0 arg_4           = dword ptr  0Ch
.text$mn:00008EF0
.text$mn:00008EF0                 push    ebp
.text$mn:00008EF1                 mov     ebp, esp
.text$mn:00008EF3                 push    ecx
.text$mn:00008EF4                 mov     [ebp+var_4], ecx
.text$mn:00008EF7                 mov     eax, [ebp+arg_4]
.text$mn:00008EFA                 push    eax             ; int
.text$mn:00008EFB                 mov     ecx, [ebp+arg_0]
.text$mn:00008EFE                 push    ecx             ; void *
.text$mn:00008EFF                 mov     ecx, [ebp+var_4]
.text$mn:00008F02                 call    ?deallocate@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@I@Z ; std::allocator<ColumnModeInfo>::deallocate(ColumnModeInfo *,uint)
.text$mn:00008F07                 mov     esp, ebp
.text$mn:00008F09                 pop     ebp
.text$mn:00008F0A                 retn    8
.text$mn:00008F0A ?deallocate@?$_Wrap_alloc@V?$allocator@UColumnModeInfo@@@std@@@std@@QAEXPAUColumnModeInfo@@I@Z endp
.text$mn:00008F0A
.text$mn:00008F0A ; ---------------------------------------------------------------------------
.text$mn:00008F0D                 align 10h
.text$mn:00008F0D _text$mn        ends
.text$mn:00008F0D
.text$mn:00008F10 ; ===========================================================================
.text$mn:00008F10
.text$mn:00008F10 ; Segment type: Pure code
.text$mn:00008F10 ; Segment permissions: Read/Execute
.text$mn:00008F10 _text$mn        segment para public 'CODE' use32
.text$mn:00008F10                 assume cs:_text$mn
.text$mn:00008F10                 ;org 8F10h
.text$mn:00008F10 ; COMDAT (pick any)
.text$mn:00008F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F10
.text$mn:00008F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F10
.text$mn:00008F10 ; Attributes: bp-based frame
.text$mn:00008F10
.text$mn:00008F10 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00008F10                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00008F10 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00008F10                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Free_proxy(void)+32p
.text$mn:00008F10                                         ; std::_Vector_alloc<0,std::_Vec_base_types<ColumnModeInfo,std::allocator<ColumnModeInfo>>>::_Free_proxy(void)+32p
.text$mn:00008F10
.text$mn:00008F10 var_4           = dword ptr -4
.text$mn:00008F10 arg_0           = dword ptr  8
.text$mn:00008F10 arg_4           = dword ptr  0Ch
.text$mn:00008F10
.text$mn:00008F10                 push    ebp
.text$mn:00008F11                 mov     ebp, esp
.text$mn:00008F13                 push    ecx
.text$mn:00008F14                 mov     [ebp+var_4], ecx
.text$mn:00008F17                 mov     eax, [ebp+arg_4]
.text$mn:00008F1A                 push    eax             ; int
.text$mn:00008F1B                 mov     ecx, [ebp+arg_0]
.text$mn:00008F1E                 push    ecx             ; void *
.text$mn:00008F1F                 mov     ecx, [ebp+var_4]
.text$mn:00008F22                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00008F27                 mov     esp, ebp
.text$mn:00008F29                 pop     ebp
.text$mn:00008F2A                 retn    8
.text$mn:00008F2A ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00008F2A
.text$mn:00008F2A ; ---------------------------------------------------------------------------
.text$mn:00008F2D                 align 10h
.text$mn:00008F2D _text$mn        ends
.text$mn:00008F2D
.text$mn:00008F30 ; ===========================================================================
.text$mn:00008F30
.text$mn:00008F30 ; Segment type: Pure code
.text$mn:00008F30 ; Segment permissions: Read/Execute
.text$mn:00008F30 _text$mn        segment para public 'CODE' use32
.text$mn:00008F30                 assume cs:_text$mn
.text$mn:00008F30                 ;org 8F30h
.text$mn:00008F30 ; COMDAT (pick any)
.text$mn:00008F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F30
.text$mn:00008F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F30
.text$mn:00008F30 ; Attributes: bp-based frame
.text$mn:00008F30
.text$mn:00008F30 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00008F30                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00008F30 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00008F30                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00008F30
.text$mn:00008F30 var_4           = dword ptr -4
.text$mn:00008F30 arg_0           = dword ptr  8
.text$mn:00008F30 arg_4           = dword ptr  0Ch
.text$mn:00008F30
.text$mn:00008F30                 push    ebp
.text$mn:00008F31                 mov     ebp, esp
.text$mn:00008F33                 push    ecx
.text$mn:00008F34                 mov     [ebp+var_4], ecx
.text$mn:00008F37                 mov     eax, [ebp+arg_4]
.text$mn:00008F3A                 push    eax             ; int
.text$mn:00008F3B                 mov     ecx, [ebp+arg_0]
.text$mn:00008F3E                 push    ecx             ; void *
.text$mn:00008F3F                 mov     ecx, [ebp+var_4]
.text$mn:00008F42                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:00008F47                 mov     esp, ebp
.text$mn:00008F49                 pop     ebp
.text$mn:00008F4A                 retn    8
.text$mn:00008F4A ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:00008F4A
.text$mn:00008F4A ; ---------------------------------------------------------------------------
.text$mn:00008F4D                 align 10h
.text$mn:00008F4D _text$mn        ends
.text$mn:00008F4D
.text$mn:00008F50 ; ===========================================================================
.text$mn:00008F50
.text$mn:00008F50 ; Segment type: Pure code
.text$mn:00008F50 ; Segment permissions: Read/Execute
.text$mn:00008F50 _text$mn        segment para public 'CODE' use32
.text$mn:00008F50                 assume cs:_text$mn
.text$mn:00008F50                 ;org 8F50h
.text$mn:00008F50 ; COMDAT (pick any)
.text$mn:00008F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F50
.text$mn:00008F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F50
.text$mn:00008F50 ; Attributes: bp-based frame
.text$mn:00008F50
.text$mn:00008F50 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00008F50                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00008F50 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00008F50                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00008F50
.text$mn:00008F50 var_4           = dword ptr -4
.text$mn:00008F50 arg_0           = dword ptr  8
.text$mn:00008F50
.text$mn:00008F50                 push    ebp
.text$mn:00008F51                 mov     ebp, esp
.text$mn:00008F53                 push    ecx
.text$mn:00008F54                 mov     [ebp+var_4], ecx
.text$mn:00008F57                 mov     eax, [ebp+arg_0]
.text$mn:00008F5A                 push    eax             ; void *
.text$mn:00008F5B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008F60                 add     esp, 4
.text$mn:00008F63                 mov     esp, ebp
.text$mn:00008F65                 pop     ebp
.text$mn:00008F66                 retn    8
.text$mn:00008F66 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00008F66
.text$mn:00008F66 ; ---------------------------------------------------------------------------
.text$mn:00008F69                 align 4
.text$mn:00008F69 _text$mn        ends
.text$mn:00008F69
.text$mn:00008F6C ; ===========================================================================
.text$mn:00008F6C
.text$mn:00008F6C ; Segment type: Pure code
.text$mn:00008F6C ; Segment permissions: Read/Execute
.text$mn:00008F6C _text$mn        segment para public 'CODE' use32
.text$mn:00008F6C                 assume cs:_text$mn
.text$mn:00008F6C                 ;org 8F6Ch
.text$mn:00008F6C ; COMDAT (pick any)
.text$mn:00008F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F6C
.text$mn:00008F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00008F6C
.text$mn:00008F6C ; Attributes: bp-based frame
.text$mn:00008F6C
.text$mn:00008F6C ; int __stdcall std::allocator<int>::deallocate(void *, int)
.text$mn:00008F6C                 public ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
.text$mn:00008F6C ?deallocate@?$allocator@H@std@@QAEXPAHI@Z proc near
.text$mn:00008F6C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)+12p
.text$mn:00008F6C
.text$mn:00008F6C var_4           = dword ptr -4
.text$mn:00008F6C arg_0           = dword ptr  8
.text$mn:00008F6C
.text$mn:00008F6C                 push    ebp
.text$mn:00008F6D                 mov     ebp, esp
.text$mn:00008F6F                 push    ecx
.text$mn:00008F70                 mov     [ebp+var_4], ecx
.text$mn:00008F73                 mov     eax, [ebp+arg_0]
.text$mn:00008F76                 push    eax             ; void *
.text$mn:00008F77                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008F7C                 add     esp, 4
.text$mn:00008F7F                 mov     esp, ebp
.text$mn:00008F81                 pop     ebp
.text$mn:00008F82                 retn    8
.text$mn:00008F82 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z endp
.text$mn:00008F82
.text$mn:00008F82 ; ---------------------------------------------------------------------------
.text$mn:00008F85                 align 4
.text$mn:00008F85 _text$mn        ends
.text$mn:00008F85
.text$mn:00008F88 ; ===========================================================================
.text$mn:00008F88
.text$mn:00008F88 ; Segment type: Pure code
.text$mn:00008F88 ; Segment permissions: Read/Execute
.text$mn:00008F88 _text$mn        segment para public 'CODE' use32
.text$mn:00008F88                 assume cs:_text$mn
.text$mn:00008F88                 ;org 8F88h
.text$mn:00008F88 ; COMDAT (pick any)
.text$mn:00008F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008F88
.text$mn:00008F88 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F88
.text$mn:00008F88 ; Attributes: bp-based frame
.text$mn:00008F88
.text$mn:00008F88 ; int __stdcall std::allocator<ColumnModeInfo>::deallocate(void *, int)
.text$mn:00008F88                 public ?deallocate@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@I@Z
.text$mn:00008F88 ?deallocate@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@I@Z proc near
.text$mn:00008F88                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<ColumnModeInfo>>::deallocate(ColumnModeInfo *,uint)+12p
.text$mn:00008F88
.text$mn:00008F88 var_4           = dword ptr -4
.text$mn:00008F88 arg_0           = dword ptr  8
.text$mn:00008F88
.text$mn:00008F88                 push    ebp
.text$mn:00008F89                 mov     ebp, esp
.text$mn:00008F8B                 push    ecx
.text$mn:00008F8C                 mov     [ebp+var_4], ecx
.text$mn:00008F8F                 mov     eax, [ebp+arg_0]
.text$mn:00008F92                 push    eax             ; void *
.text$mn:00008F93                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008F98                 add     esp, 4
.text$mn:00008F9B                 mov     esp, ebp
.text$mn:00008F9D                 pop     ebp
.text$mn:00008F9E                 retn    8
.text$mn:00008F9E ?deallocate@?$allocator@UColumnModeInfo@@@std@@QAEXPAUColumnModeInfo@@I@Z endp
.text$mn:00008F9E
.text$mn:00008F9E ; ---------------------------------------------------------------------------
.text$mn:00008FA1                 align 4
.text$mn:00008FA1 _text$mn        ends
.text$mn:00008FA1
.text$mn:00008FA4 ; ===========================================================================
.text$mn:00008FA4
.text$mn:00008FA4 ; Segment type: Pure code
.text$mn:00008FA4 ; Segment permissions: Read/Execute
.text$mn:00008FA4 _text$mn        segment para public 'CODE' use32
.text$mn:00008FA4                 assume cs:_text$mn
.text$mn:00008FA4                 ;org 8FA4h
.text$mn:00008FA4 ; COMDAT (pick any)
.text$mn:00008FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FA4
.text$mn:00008FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008FA4
.text$mn:00008FA4 ; Attributes: bp-based frame
.text$mn:00008FA4
.text$mn:00008FA4 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00008FA4                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00008FA4 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00008FA4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00008FA4                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:00008FA4
.text$mn:00008FA4 var_4           = dword ptr -4
.text$mn:00008FA4 arg_0           = dword ptr  8
.text$mn:00008FA4
.text$mn:00008FA4                 push    ebp
.text$mn:00008FA5                 mov     ebp, esp
.text$mn:00008FA7                 push    ecx
.text$mn:00008FA8                 mov     [ebp+var_4], ecx
.text$mn:00008FAB                 mov     eax, [ebp+arg_0]
.text$mn:00008FAE                 push    eax             ; void *
.text$mn:00008FAF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008FB4                 add     esp, 4
.text$mn:00008FB7                 mov     esp, ebp
.text$mn:00008FB9                 pop     ebp
.text$mn:00008FBA                 retn    8
.text$mn:00008FBA ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00008FBA
.text$mn:00008FBA ; ---------------------------------------------------------------------------
.text$mn:00008FBD                 align 10h
.text$mn:00008FBD _text$mn        ends
.text$mn:00008FBD
.text$mn:00008FC0 ; ===========================================================================
.text$mn:00008FC0
.text$mn:00008FC0 ; Segment type: Pure code
.text$mn:00008FC0 ; Segment permissions: Read/Execute
.text$mn:00008FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00008FC0                 assume cs:_text$mn
.text$mn:00008FC0                 ;org 8FC0h
.text$mn:00008FC0 ; COMDAT (pick any)
.text$mn:00008FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FC0
.text$mn:00008FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008FC0
.text$mn:00008FC0 ; Attributes: bp-based frame
.text$mn:00008FC0
.text$mn:00008FC0 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00008FC0                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00008FC0 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00008FC0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00008FC0
.text$mn:00008FC0 var_4           = dword ptr -4
.text$mn:00008FC0 arg_0           = dword ptr  8
.text$mn:00008FC0
.text$mn:00008FC0                 push    ebp
.text$mn:00008FC1                 mov     ebp, esp
.text$mn:00008FC3                 push    ecx
.text$mn:00008FC4                 mov     [ebp+var_4], ecx
.text$mn:00008FC7                 mov     eax, [ebp+arg_0]
.text$mn:00008FCA                 push    eax             ; void *
.text$mn:00008FCB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008FD0                 add     esp, 4
.text$mn:00008FD3                 mov     esp, ebp
.text$mn:00008FD5                 pop     ebp
.text$mn:00008FD6                 retn    8
.text$mn:00008FD6 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00008FD6
.text$mn:00008FD6 ; ---------------------------------------------------------------------------
.text$mn:00008FD9                 align 4
.text$mn:00008FD9 _text$mn        ends
.text$mn:00008FD9
.text$mn:00008FDC ; ===========================================================================
.text$mn:00008FDC
.text$mn:00008FDC ; Segment type: Pure code
.text$mn:00008FDC ; Segment permissions: Read/Execute
.text$mn:00008FDC _text$mn        segment para public 'CODE' use32
.text$mn:00008FDC                 assume cs:_text$mn
.text$mn:00008FDC                 ;org 8FDCh
.text$mn:00008FDC ; COMDAT (pick any)
.text$mn:00008FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008FDC
.text$mn:00008FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00008FDC
.text$mn:00008FDC ; Attributes: bp-based frame
.text$mn:00008FDC
.text$mn:00008FDC ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00008FDC                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00008FDC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00008FDC                                         ; DATA XREF: .rdata:0000B040o
.text$mn:00008FDC
.text$mn:00008FDC var_4           = dword ptr -4
.text$mn:00008FDC arg_0           = dword ptr  8
.text$mn:00008FDC arg_4           = dword ptr  0Ch
.text$mn:00008FDC
.text$mn:00008FDC                 push    ebp
.text$mn:00008FDD                 mov     ebp, esp
.text$mn:00008FDF                 push    ecx
.text$mn:00008FE0                 mov     [ebp+var_4], ecx
.text$mn:00008FE3                 mov     eax, [ebp+arg_4]
.text$mn:00008FE6                 push    eax             ; int
.text$mn:00008FE7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00008FEC                 add     esp, 4
.text$mn:00008FEF                 test    eax, eax
.text$mn:00008FF1                 jz      short loc_900C
.text$mn:00008FF3                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00008FF8                 push    eax             ; struct std::error_category *
.text$mn:00008FF9                 mov     ecx, [ebp+arg_4]
.text$mn:00008FFC                 push    ecx             ; int
.text$mn:00008FFD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00009000                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00009005                 mov     eax, [ebp+arg_0]
.text$mn:00009008                 jmp     short loc_9021
.text$mn:0000900A ; ---------------------------------------------------------------------------
.text$mn:0000900A                 jmp     short loc_9021
.text$mn:0000900C ; ---------------------------------------------------------------------------
.text$mn:0000900C
.text$mn:0000900C loc_900C:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000900C                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00009011                 push    eax             ; struct std::error_category *
.text$mn:00009012                 mov     edx, [ebp+arg_4]
.text$mn:00009015                 push    edx             ; int
.text$mn:00009016                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00009019                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000901E                 mov     eax, [ebp+arg_0]
.text$mn:00009021
.text$mn:00009021 loc_9021:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00009021                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00009021                 mov     esp, ebp
.text$mn:00009023                 pop     ebp
.text$mn:00009024                 retn    8
.text$mn:00009024 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00009024
.text$mn:00009024 ; ---------------------------------------------------------------------------
.text$mn:00009027                 align 4
.text$mn:00009027 _text$mn        ends
.text$mn:00009027
.text$mn:00009028 ; ===========================================================================
.text$mn:00009028
.text$mn:00009028 ; Segment type: Pure code
.text$mn:00009028 ; Segment permissions: Read/Execute
.text$mn:00009028 _text$mn        segment para public 'CODE' use32
.text$mn:00009028                 assume cs:_text$mn
.text$mn:00009028                 ;org 9028h
.text$mn:00009028 ; COMDAT (pick any)
.text$mn:00009028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009028
.text$mn:00009028 ; =============== S U B R O U T I N E =======================================
.text$mn:00009028
.text$mn:00009028 ; Attributes: bp-based frame
.text$mn:00009028
.text$mn:00009028 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00009028                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00009028 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00009028                                         ; DATA XREF: .rdata:0000AFB0o
.text$mn:00009028                                         ; .rdata:0000AFCCo ...
.text$mn:00009028
.text$mn:00009028 var_4           = dword ptr -4
.text$mn:00009028 arg_0           = dword ptr  8
.text$mn:00009028 arg_4           = dword ptr  0Ch
.text$mn:00009028
.text$mn:00009028                 push    ebp
.text$mn:00009029                 mov     ebp, esp
.text$mn:0000902B                 push    ecx
.text$mn:0000902C                 mov     [ebp+var_4], ecx
.text$mn:0000902F                 mov     eax, [ebp+var_4]
.text$mn:00009032                 push    eax             ; struct std::error_category *
.text$mn:00009033                 mov     ecx, [ebp+arg_4]
.text$mn:00009036                 push    ecx             ; int
.text$mn:00009037                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000903A                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000903F                 mov     eax, [ebp+arg_0]
.text$mn:00009042                 mov     esp, ebp
.text$mn:00009044                 pop     ebp
.text$mn:00009045                 retn    8
.text$mn:00009045 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00009045
.text$mn:00009045 _text$mn        ends
.text$mn:00009045
.text$mn:00009048 ; ===========================================================================
.text$mn:00009048
.text$mn:00009048 ; Segment type: Pure code
.text$mn:00009048 ; Segment permissions: Read/Execute
.text$mn:00009048 _text$mn        segment para public 'CODE' use32
.text$mn:00009048                 assume cs:_text$mn
.text$mn:00009048                 ;org 9048h
.text$mn:00009048 ; COMDAT (pick any)
.text$mn:00009048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009048
.text$mn:00009048 ; =============== S U B R O U T I N E =======================================
.text$mn:00009048
.text$mn:00009048 ; Attributes: bp-based frame
.text$mn:00009048
.text$mn:00009048 ; void __thiscall Window::display(Window *this, bool)
.text$mn:00009048                 public ?display@Window@@UBEX_N@Z
.text$mn:00009048 ?display@Window@@UBEX_N@Z proc near     ; CODE XREF: ColumnEditorDlg::display(bool)+Fp
.text$mn:00009048
.text$mn:00009048 var_8           = dword ptr -8
.text$mn:00009048 nCmdShow        = dword ptr -4
.text$mn:00009048 arg_0           = byte ptr  8
.text$mn:00009048
.text$mn:00009048                 push    ebp
.text$mn:00009049                 mov     ebp, esp
.text$mn:0000904B                 sub     esp, 8
.text$mn:0000904E                 mov     [ebp+var_8], ecx
.text$mn:00009051                 movzx   eax, [ebp+arg_0]
.text$mn:00009055                 test    eax, eax
.text$mn:00009057                 jz      short loc_9062
.text$mn:00009059                 mov     [ebp+nCmdShow], 5
.text$mn:00009060                 jmp     short loc_9069
.text$mn:00009062 ; ---------------------------------------------------------------------------
.text$mn:00009062
.text$mn:00009062 loc_9062:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:00009062                 mov     [ebp+nCmdShow], 0
.text$mn:00009069
.text$mn:00009069 loc_9069:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:00009069                 mov     ecx, [ebp+nCmdShow]
.text$mn:0000906C                 push    ecx             ; nCmdShow
.text$mn:0000906D                 mov     edx, [ebp+var_8]
.text$mn:00009070                 mov     eax, [edx+0Ch]
.text$mn:00009073                 push    eax             ; hWnd
.text$mn:00009074                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:0000907A                 mov     esp, ebp
.text$mn:0000907C                 pop     ebp
.text$mn:0000907D                 retn    4
.text$mn:0000907D ?display@Window@@UBEX_N@Z endp
.text$mn:0000907D
.text$mn:0000907D _text$mn        ends
.text$mn:0000907D
.text$mn:00009080 ; ===========================================================================
.text$mn:00009080
.text$mn:00009080 ; Segment type: Pure code
.text$mn:00009080 ; Segment permissions: Read/Execute
.text$mn:00009080 _text$mn        segment para public 'CODE' use32
.text$mn:00009080                 assume cs:_text$mn
.text$mn:00009080                 ;org 9080h
.text$mn:00009080 ; COMDAT (pick any)
.text$mn:00009080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009080
.text$mn:00009080 ; =============== S U B R O U T I N E =======================================
.text$mn:00009080
.text$mn:00009080 ; Attributes: bp-based frame
.text$mn:00009080
.text$mn:00009080 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::end(void)
.text$mn:00009080                 public ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:00009080 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$mn:00009080                                         ; CODE XREF: std::vector<int,std::allocator<int>>::rbegin(void)+3Bp
.text$mn:00009080
.text$mn:00009080 var_14          = dword ptr -14h
.text$mn:00009080 var_10          = dword ptr -10h
.text$mn:00009080 var_C           = dword ptr -0Ch
.text$mn:00009080 var_4           = dword ptr -4
.text$mn:00009080 arg_0           = dword ptr  8
.text$mn:00009080
.text$mn:00009080                 push    ebp
.text$mn:00009081                 mov     ebp, esp
.text$mn:00009083                 push    0FFFFFFFFh
.text$mn:00009085                 push    offset __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000908A                 mov     eax, large fs:0
.text$mn:00009090                 push    eax
.text$mn:00009091                 sub     esp, 8
.text$mn:00009094                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009099                 xor     eax, ebp
.text$mn:0000909B                 push    eax
.text$mn:0000909C                 lea     eax, [ebp+var_C]
.text$mn:0000909F                 mov     large fs:0, eax
.text$mn:000090A5                 mov     [ebp+var_10], ecx
.text$mn:000090A8                 mov     [ebp+var_14], 0
.text$mn:000090AF                 mov     eax, [ebp+var_10]
.text$mn:000090B2                 push    eax             ; struct std::_Container_base12 *
.text$mn:000090B3                 mov     ecx, [ebp+var_10]
.text$mn:000090B6                 mov     edx, [ecx+8]
.text$mn:000090B9                 push    edx             ; int
.text$mn:000090BA                 mov     ecx, [ebp+arg_0]
.text$mn:000090BD                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:000090C2                 mov     [ebp+var_4], 0
.text$mn:000090C9                 mov     eax, [ebp+var_14]
.text$mn:000090CC                 or      eax, 1
.text$mn:000090CF                 mov     [ebp+var_14], eax
.text$mn:000090D2                 mov     eax, [ebp+arg_0]
.text$mn:000090D5                 mov     ecx, [ebp+var_C]
.text$mn:000090D8                 mov     large fs:0, ecx
.text$mn:000090DF                 pop     ecx
.text$mn:000090E0                 mov     esp, ebp
.text$mn:000090E2                 pop     ebp
.text$mn:000090E3                 retn    4
.text$mn:000090E3 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$mn:000090E3
.text$mn:000090E3 ; ---------------------------------------------------------------------------
.text$mn:000090E6                 align 4
.text$mn:000090E6 _text$mn        ends
.text$mn:000090E6
.text$x:000090E8 ; ===========================================================================
.text$x:000090E8
.text$x:000090E8 ; Segment type: Pure code
.text$x:000090E8 ; Segment permissions: Read/Execute
.text$x:000090E8 _text$x         segment para public 'CODE' use32
.text$x:000090E8                 assume cs:_text$x
.text$x:000090E8                 ;org 90E8h
.text$x:000090E8 ; COMDAT (pick associative to section at 9080)
.text$x:000090E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000090E8
.text$x:000090E8 ; =============== S U B R O U T I N E =======================================
.text$x:000090E8
.text$x:000090E8
.text$x:000090E8 __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 proc near
.text$x:000090E8                                         ; DATA XREF: .xdata$x:0000A618o
.text$x:000090E8                 mov     eax, [ebp-14h]
.text$x:000090EB                 and     eax, 1
.text$x:000090EE                 jz      $LN4
.text$x:000090F4                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000090F8                 mov     ecx, [ebp+8]
.text$x:000090FB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00009100 ; ---------------------------------------------------------------------------
.text$x:00009100
.text$x:00009100 $LN4:                                   ; CODE XREF: __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0+6j
.text$x:00009100                 retn
.text$x:00009100 __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 endp
.text$x:00009100
.text$x:00009101
.text$x:00009101 ; =============== S U B R O U T I N E =======================================
.text$x:00009101
.text$x:00009101
.text$x:00009101 __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$x:00009101                                         ; DATA XREF: std::vector<int,std::allocator<int>>::end(void)+5o
.text$x:00009101
.text$x:00009101 arg_4           = dword ptr  8
.text$x:00009101
.text$x:00009101                 mov     edx, [esp+arg_4]
.text$x:00009105                 lea     eax, [edx+0Ch]
.text$x:00009108                 mov     ecx, [edx-0Ch]
.text$x:0000910B                 xor     ecx, eax
.text$x:0000910D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009112                 mov     eax, offset __ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$x:00009117                 jmp     ___CxxFrameHandler3
.text$x:00009117 __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$x:00009117
.text$x:00009117 _text$x         ends
.text$x:00009117
.text$mn:0000911C ; ===========================================================================
.text$mn:0000911C
.text$mn:0000911C ; Segment type: Pure code
.text$mn:0000911C ; Segment permissions: Read/Execute
.text$mn:0000911C _text$mn        segment para public 'CODE' use32
.text$mn:0000911C                 assume cs:_text$mn
.text$mn:0000911C                 ;org 911Ch
.text$mn:0000911C ; COMDAT (pick any)
.text$mn:0000911C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000911C
.text$mn:0000911C ; =============== S U B R O U T I N E =======================================
.text$mn:0000911C
.text$mn:0000911C ; Attributes: bp-based frame
.text$mn:0000911C
.text$mn:0000911C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct ColumnModeInfo>>> __thiscall std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>>::end(void)
.text$mn:0000911C                 public ?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.text$mn:0000911C ?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ proc near
.text$mn:0000911C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+248p
.text$mn:0000911C                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+2D9p ...
.text$mn:0000911C
.text$mn:0000911C var_14          = dword ptr -14h
.text$mn:0000911C var_10          = dword ptr -10h
.text$mn:0000911C var_C           = dword ptr -0Ch
.text$mn:0000911C var_4           = dword ptr -4
.text$mn:0000911C arg_0           = dword ptr  8
.text$mn:0000911C
.text$mn:0000911C                 push    ebp
.text$mn:0000911D                 mov     ebp, esp
.text$mn:0000911F                 push    0FFFFFFFFh
.text$mn:00009121                 push    offset __ehhandler$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.text$mn:00009126                 mov     eax, large fs:0
.text$mn:0000912C                 push    eax
.text$mn:0000912D                 sub     esp, 8
.text$mn:00009130                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009135                 xor     eax, ebp
.text$mn:00009137                 push    eax
.text$mn:00009138                 lea     eax, [ebp+var_C]
.text$mn:0000913B                 mov     large fs:0, eax
.text$mn:00009141                 mov     [ebp+var_10], ecx
.text$mn:00009144                 mov     [ebp+var_14], 0
.text$mn:0000914B                 mov     eax, [ebp+var_10]
.text$mn:0000914E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000914F                 mov     ecx, [ebp+var_10]
.text$mn:00009152                 mov     edx, [ecx+8]
.text$mn:00009155                 push    edx             ; int
.text$mn:00009156                 mov     ecx, [ebp+arg_0]
.text$mn:00009159                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(ColumnModeInfo *,std::_Container_base12 const *)
.text$mn:0000915E                 mov     [ebp+var_4], 0
.text$mn:00009165                 mov     eax, [ebp+var_14]
.text$mn:00009168                 or      eax, 1
.text$mn:0000916B                 mov     [ebp+var_14], eax
.text$mn:0000916E                 mov     eax, [ebp+arg_0]
.text$mn:00009171                 mov     ecx, [ebp+var_C]
.text$mn:00009174                 mov     large fs:0, ecx
.text$mn:0000917B                 pop     ecx
.text$mn:0000917C                 mov     esp, ebp
.text$mn:0000917E                 pop     ebp
.text$mn:0000917F                 retn    4
.text$mn:0000917F ?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ endp
.text$mn:0000917F
.text$mn:0000917F ; ---------------------------------------------------------------------------
.text$mn:00009182                 align 4
.text$mn:00009182 _text$mn        ends
.text$mn:00009182
.text$x:00009184 ; ===========================================================================
.text$x:00009184
.text$x:00009184 ; Segment type: Pure code
.text$x:00009184 ; Segment permissions: Read/Execute
.text$x:00009184 _text$x         segment para public 'CODE' use32
.text$x:00009184                 assume cs:_text$x
.text$x:00009184                 ;org 9184h
.text$x:00009184 ; COMDAT (pick associative to section at 911C)
.text$x:00009184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009184
.text$x:00009184 ; =============== S U B R O U T I N E =======================================
.text$x:00009184
.text$x:00009184
.text$x:00009184 __unwindfunclet$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0 proc near
.text$x:00009184                                         ; DATA XREF: .xdata$x:0000A7B4o
.text$x:00009184                 mov     eax, [ebp-14h]
.text$x:00009187                 and     eax, 1
.text$x:0000918A                 jz      $LN4_1
.text$x:00009190                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00009194                 mov     ecx, [ebp+8]
.text$x:00009197                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>(void)
.text$x:0000919C ; ---------------------------------------------------------------------------
.text$x:0000919C
.text$x:0000919C $LN4_1:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0+6j
.text$x:0000919C                 retn
.text$x:0000919C __unwindfunclet$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0 endp
.text$x:0000919C
.text$x:0000919D
.text$x:0000919D ; =============== S U B R O U T I N E =======================================
.text$x:0000919D
.text$x:0000919D
.text$x:0000919D __ehhandler$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ proc near
.text$x:0000919D                                         ; DATA XREF: std::vector<ColumnModeInfo,std::allocator<ColumnModeInfo>>::end(void)+5o
.text$x:0000919D
.text$x:0000919D arg_4           = dword ptr  8
.text$x:0000919D
.text$x:0000919D                 mov     edx, [esp+arg_4]
.text$x:000091A1                 lea     eax, [edx+0Ch]
.text$x:000091A4                 mov     ecx, [edx-0Ch]
.text$x:000091A7                 xor     ecx, eax
.text$x:000091A9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000091AE                 mov     eax, offset __ehfuncinfo$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.text$x:000091B3                 jmp     ___CxxFrameHandler3
.text$x:000091B3 __ehhandler$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ endp
.text$x:000091B3
.text$x:000091B3 _text$x         ends
.text$x:000091B3
.text$mn:000091B8 ; ===========================================================================
.text$mn:000091B8
.text$mn:000091B8 ; Segment type: Pure code
.text$mn:000091B8 ; Segment permissions: Read/Execute
.text$mn:000091B8 _text$mn        segment para public 'CODE' use32
.text$mn:000091B8                 assume cs:_text$mn
.text$mn:000091B8                 ;org 91B8h
.text$mn:000091B8 ; COMDAT (pick any)
.text$mn:000091B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000091B8
.text$mn:000091B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000091B8
.text$mn:000091B8 ; Attributes: bp-based frame
.text$mn:000091B8
.text$mn:000091B8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000091B8                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000091B8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000091B8                                         ; DATA XREF: .rdata:0000AFB4o
.text$mn:000091B8                                         ; .rdata:0000AFD0o ...
.text$mn:000091B8
.text$mn:000091B8 var_8           = dword ptr -8
.text$mn:000091B8 var_4           = dword ptr -4
.text$mn:000091B8 arg_0           = dword ptr  8
.text$mn:000091B8 arg_4           = dword ptr  0Ch
.text$mn:000091B8
.text$mn:000091B8                 push    ebp
.text$mn:000091B9                 mov     ebp, esp
.text$mn:000091BB                 sub     esp, 8
.text$mn:000091BE                 mov     [ebp+var_8], ecx
.text$mn:000091C1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000091C4                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000091C9                 push    eax
.text$mn:000091CA                 mov     ecx, [ebp+var_8]
.text$mn:000091CD                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000091D2                 movzx   eax, al
.text$mn:000091D5                 test    eax, eax
.text$mn:000091D7                 jz      short loc_91EF
.text$mn:000091D9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000091DC                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000091E1                 cmp     eax, [ebp+arg_4]
.text$mn:000091E4                 jnz     short loc_91EF
.text$mn:000091E6                 mov     [ebp+var_4], 1
.text$mn:000091ED                 jmp     short loc_91F6
.text$mn:000091EF ; ---------------------------------------------------------------------------
.text$mn:000091EF
.text$mn:000091EF loc_91EF:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000091EF                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000091EF                 mov     [ebp+var_4], 0
.text$mn:000091F6
.text$mn:000091F6 loc_91F6:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000091F6                 mov     al, byte ptr [ebp+var_4]
.text$mn:000091F9                 mov     esp, ebp
.text$mn:000091FB                 pop     ebp
.text$mn:000091FC                 retn    8
.text$mn:000091FC ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000091FC
.text$mn:000091FC ; ---------------------------------------------------------------------------
.text$mn:000091FF                 align 10h
.text$mn:000091FF _text$mn        ends
.text$mn:000091FF
.text$mn:00009200 ; ===========================================================================
.text$mn:00009200
.text$mn:00009200 ; Segment type: Pure code
.text$mn:00009200 ; Segment permissions: Read/Execute
.text$mn:00009200 _text$mn        segment para public 'CODE' use32
.text$mn:00009200                 assume cs:_text$mn
.text$mn:00009200                 ;org 9200h
.text$mn:00009200 ; COMDAT (pick any)
.text$mn:00009200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009200
.text$mn:00009200 ; =============== S U B R O U T I N E =======================================
.text$mn:00009200
.text$mn:00009200 ; Attributes: bp-based frame
.text$mn:00009200
.text$mn:00009200 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00009200                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00009200 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00009200                                         ; DATA XREF: .rdata:0000AFB8o
.text$mn:00009200                                         ; .rdata:0000AFD4o ...
.text$mn:00009200
.text$mn:00009200 var_C           = byte ptr -0Ch
.text$mn:00009200 var_4           = dword ptr -4
.text$mn:00009200 arg_0           = dword ptr  8
.text$mn:00009200 arg_4           = dword ptr  0Ch
.text$mn:00009200
.text$mn:00009200                 push    ebp
.text$mn:00009201                 mov     ebp, esp
.text$mn:00009203                 sub     esp, 0Ch
.text$mn:00009206                 mov     [ebp+var_4], ecx
.text$mn:00009209                 mov     eax, [ebp+arg_4]
.text$mn:0000920C                 push    eax             ; std::error_condition *
.text$mn:0000920D                 mov     ecx, [ebp+arg_0]
.text$mn:00009210                 push    ecx
.text$mn:00009211                 lea     edx, [ebp+var_C]
.text$mn:00009214                 push    edx
.text$mn:00009215                 mov     eax, [ebp+var_4]
.text$mn:00009218                 mov     edx, [eax]
.text$mn:0000921A                 mov     ecx, [ebp+var_4]
.text$mn:0000921D                 mov     eax, [edx+0Ch]
.text$mn:00009220                 call    eax
.text$mn:00009222                 mov     ecx, eax
.text$mn:00009224                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00009229                 mov     esp, ebp
.text$mn:0000922B                 pop     ebp
.text$mn:0000922C                 retn    8
.text$mn:0000922C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000922C
.text$mn:0000922C ; ---------------------------------------------------------------------------
.text$mn:0000922F                 align 10h
.text$mn:0000922F _text$mn        ends
.text$mn:0000922F
.text$mn:00009230 ; ===========================================================================
.text$mn:00009230
.text$mn:00009230 ; Segment type: Pure code
.text$mn:00009230 ; Segment permissions: Read/Execute
.text$mn:00009230 _text$mn        segment para public 'CODE' use32
.text$mn:00009230                 assume cs:_text$mn
.text$mn:00009230                 ;org 9230h
.text$mn:00009230 ; COMDAT (pick any)
.text$mn:00009230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009230
.text$mn:00009230 ; =============== S U B R O U T I N E =======================================
.text$mn:00009230
.text$mn:00009230 ; Attributes: bp-based frame
.text$mn:00009230
.text$mn:00009230 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00009230                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00009230 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00009230                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00009230
.text$mn:00009230 var_4           = dword ptr -4
.text$mn:00009230 arg_0           = dword ptr  8
.text$mn:00009230
.text$mn:00009230                 push    ebp
.text$mn:00009231                 mov     ebp, esp
.text$mn:00009233                 push    ecx
.text$mn:00009234                 mov     [ebp+var_4], ecx
.text$mn:00009237                 mov     eax, [ebp+var_4]
.text$mn:0000923A                 mov     ecx, [eax+14h]
.text$mn:0000923D                 cmp     ecx, [ebp+arg_0]
.text$mn:00009240                 jnb     short loc_924A
.text$mn:00009242                 mov     ecx, [ebp+var_4]
.text$mn:00009245                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000924A
.text$mn:0000924A loc_924A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000924A                 mov     edx, [ebp+arg_0]
.text$mn:0000924D                 push    edx
.text$mn:0000924E                 mov     ecx, [ebp+var_4]
.text$mn:00009251                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00009256                 mov     eax, [ebp+var_4]
.text$mn:00009259                 mov     esp, ebp
.text$mn:0000925B                 pop     ebp
.text$mn:0000925C                 retn    4
.text$mn:0000925C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000925C
.text$mn:0000925C ; ---------------------------------------------------------------------------
.text$mn:0000925F                 align 10h
.text$mn:0000925F _text$mn        ends
.text$mn:0000925F
.text$mn:00009260 ; ===========================================================================
.text$mn:00009260
.text$mn:00009260 ; Segment type: Pure code
.text$mn:00009260 ; Segment permissions: Read/Execute
.text$mn:00009260 _text$mn        segment para public 'CODE' use32
.text$mn:00009260                 assume cs:_text$mn
.text$mn:00009260                 ;org 9260h
.text$mn:00009260 ; COMDAT (pick any)
.text$mn:00009260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009260
.text$mn:00009260 ; =============== S U B R O U T I N E =======================================
.text$mn:00009260
.text$mn:00009260 ; Attributes: bp-based frame
.text$mn:00009260
.text$mn:00009260 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00009260                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00009260 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00009260                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00009260
.text$mn:00009260 var_C           = dword ptr -0Ch
.text$mn:00009260 Dst             = dword ptr -8
.text$mn:00009260 var_4           = dword ptr -4
.text$mn:00009260 arg_0           = dword ptr  8
.text$mn:00009260 arg_4           = dword ptr  0Ch
.text$mn:00009260
.text$mn:00009260                 push    ebp
.text$mn:00009261                 mov     ebp, esp
.text$mn:00009263                 sub     esp, 0Ch
.text$mn:00009266                 mov     [ebp+var_4], ecx
.text$mn:00009269                 mov     eax, [ebp+var_4]
.text$mn:0000926C                 mov     ecx, [eax+14h]
.text$mn:0000926F                 cmp     ecx, [ebp+arg_0]
.text$mn:00009272                 jnb     short loc_927C
.text$mn:00009274                 mov     ecx, [ebp+var_4]
.text$mn:00009277                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000927C
.text$mn:0000927C loc_927C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000927C                 mov     edx, [ebp+var_4]
.text$mn:0000927F                 mov     eax, [edx+14h]
.text$mn:00009282                 sub     eax, [ebp+arg_0]
.text$mn:00009285                 cmp     eax, [ebp+arg_4]
.text$mn:00009288                 ja      short loc_9298
.text$mn:0000928A                 mov     ecx, [ebp+arg_0]
.text$mn:0000928D                 push    ecx
.text$mn:0000928E                 mov     ecx, [ebp+var_4]
.text$mn:00009291                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00009296                 jmp     short loc_92DE
.text$mn:00009298 ; ---------------------------------------------------------------------------
.text$mn:00009298
.text$mn:00009298 loc_9298:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00009298                 cmp     [ebp+arg_4], 0
.text$mn:0000929C                 jbe     short loc_92DE
.text$mn:0000929E                 mov     ecx, [ebp+var_4]
.text$mn:000092A1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000092A6                 add     eax, [ebp+arg_0]
.text$mn:000092A9                 mov     [ebp+Dst], eax
.text$mn:000092AC                 mov     edx, [ebp+var_4]
.text$mn:000092AF                 mov     eax, [edx+14h]
.text$mn:000092B2                 sub     eax, [ebp+arg_4]
.text$mn:000092B5                 mov     [ebp+var_C], eax
.text$mn:000092B8                 mov     ecx, [ebp+var_C]
.text$mn:000092BB                 sub     ecx, [ebp+arg_0]
.text$mn:000092BE                 push    ecx             ; Size
.text$mn:000092BF                 mov     edx, [ebp+Dst]
.text$mn:000092C2                 add     edx, [ebp+arg_4]
.text$mn:000092C5                 push    edx             ; Src
.text$mn:000092C6                 mov     eax, [ebp+Dst]
.text$mn:000092C9                 push    eax             ; Dst
.text$mn:000092CA                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000092CF                 add     esp, 0Ch
.text$mn:000092D2                 mov     ecx, [ebp+var_C]
.text$mn:000092D5                 push    ecx
.text$mn:000092D6                 mov     ecx, [ebp+var_4]
.text$mn:000092D9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000092DE
.text$mn:000092DE loc_92DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000092DE                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000092DE                 mov     eax, [ebp+var_4]
.text$mn:000092E1                 mov     esp, ebp
.text$mn:000092E3                 pop     ebp
.text$mn:000092E4                 retn    8
.text$mn:000092E4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000092E4
.text$mn:000092E4 ; ---------------------------------------------------------------------------
.text$mn:000092E7                 align 4
.text$mn:000092E7 _text$mn        ends
.text$mn:000092E7
.text$mn:000092E8 ; ===========================================================================
.text$mn:000092E8
.text$mn:000092E8 ; Segment type: Pure code
.text$mn:000092E8 ; Segment permissions: Read/Execute
.text$mn:000092E8 _text$mn        segment para public 'CODE' use32
.text$mn:000092E8                 assume cs:_text$mn
.text$mn:000092E8                 ;org 92E8h
.text$mn:000092E8 ; COMDAT (pick any)
.text$mn:000092E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000092E8
.text$mn:000092E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000092E8
.text$mn:000092E8 ; Attributes: bp-based frame
.text$mn:000092E8
.text$mn:000092E8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:000092E8                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:000092E8 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000092E8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:000092E8
.text$mn:000092E8 var_4           = dword ptr -4
.text$mn:000092E8 arg_0           = dword ptr  8
.text$mn:000092E8
.text$mn:000092E8                 push    ebp
.text$mn:000092E9                 mov     ebp, esp
.text$mn:000092EB                 push    ecx
.text$mn:000092EC                 mov     [ebp+var_4], ecx
.text$mn:000092EF                 mov     eax, [ebp+var_4]
.text$mn:000092F2                 mov     ecx, [eax+14h]
.text$mn:000092F5                 cmp     ecx, [ebp+arg_0]
.text$mn:000092F8                 jnb     short loc_9302
.text$mn:000092FA                 mov     ecx, [ebp+var_4]
.text$mn:000092FD                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00009302
.text$mn:00009302 loc_9302:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:00009302                 mov     edx, [ebp+arg_0]
.text$mn:00009305                 push    edx
.text$mn:00009306                 mov     ecx, [ebp+var_4]
.text$mn:00009309                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000930E                 mov     eax, [ebp+var_4]
.text$mn:00009311                 mov     esp, ebp
.text$mn:00009313                 pop     ebp
.text$mn:00009314                 retn    4
.text$mn:00009314 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00009314
.text$mn:00009314 ; ---------------------------------------------------------------------------
.text$mn:00009317                 align 4
.text$mn:00009317 _text$mn        ends
.text$mn:00009317
.text$mn:00009318 ; ===========================================================================
.text$mn:00009318
.text$mn:00009318 ; Segment type: Pure code
.text$mn:00009318 ; Segment permissions: Read/Execute
.text$mn:00009318 _text$mn        segment para public 'CODE' use32
.text$mn:00009318                 assume cs:_text$mn
.text$mn:00009318                 ;org 9318h
.text$mn:00009318 ; COMDAT (pick any)
.text$mn:00009318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009318
.text$mn:00009318 ; =============== S U B R O U T I N E =======================================
.text$mn:00009318
.text$mn:00009318 ; Attributes: bp-based frame
.text$mn:00009318
.text$mn:00009318 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00009318                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00009318 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00009318                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00009318
.text$mn:00009318 var_C           = dword ptr -0Ch
.text$mn:00009318 Dst             = dword ptr -8
.text$mn:00009318 var_4           = dword ptr -4
.text$mn:00009318 arg_0           = dword ptr  8
.text$mn:00009318 arg_4           = dword ptr  0Ch
.text$mn:00009318
.text$mn:00009318                 push    ebp
.text$mn:00009319                 mov     ebp, esp
.text$mn:0000931B                 sub     esp, 0Ch
.text$mn:0000931E                 mov     [ebp+var_4], ecx
.text$mn:00009321                 mov     eax, [ebp+var_4]
.text$mn:00009324                 mov     ecx, [eax+14h]
.text$mn:00009327                 cmp     ecx, [ebp+arg_0]
.text$mn:0000932A                 jnb     short loc_9334
.text$mn:0000932C                 mov     ecx, [ebp+var_4]
.text$mn:0000932F                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00009334
.text$mn:00009334 loc_9334:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00009334                 mov     edx, [ebp+var_4]
.text$mn:00009337                 mov     eax, [edx+14h]
.text$mn:0000933A                 sub     eax, [ebp+arg_0]
.text$mn:0000933D                 cmp     eax, [ebp+arg_4]
.text$mn:00009340                 ja      short loc_9350
.text$mn:00009342                 mov     ecx, [ebp+arg_0]
.text$mn:00009345                 push    ecx
.text$mn:00009346                 mov     ecx, [ebp+var_4]
.text$mn:00009349                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000934E                 jmp     short loc_939C
.text$mn:00009350 ; ---------------------------------------------------------------------------
.text$mn:00009350
.text$mn:00009350 loc_9350:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00009350                 cmp     [ebp+arg_4], 0
.text$mn:00009354                 jbe     short loc_939C
.text$mn:00009356                 mov     ecx, [ebp+var_4]
.text$mn:00009359                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000935E                 mov     edx, [ebp+arg_0]
.text$mn:00009361                 lea     eax, [eax+edx*2]
.text$mn:00009364                 mov     [ebp+Dst], eax
.text$mn:00009367                 mov     ecx, [ebp+var_4]
.text$mn:0000936A                 mov     edx, [ecx+14h]
.text$mn:0000936D                 sub     edx, [ebp+arg_4]
.text$mn:00009370                 mov     [ebp+var_C], edx
.text$mn:00009373                 mov     eax, [ebp+var_C]
.text$mn:00009376                 sub     eax, [ebp+arg_0]
.text$mn:00009379                 push    eax             ; int
.text$mn:0000937A                 mov     ecx, [ebp+arg_4]
.text$mn:0000937D                 mov     edx, [ebp+Dst]
.text$mn:00009380                 lea     eax, [edx+ecx*2]
.text$mn:00009383                 push    eax             ; Src
.text$mn:00009384                 mov     ecx, [ebp+Dst]
.text$mn:00009387                 push    ecx             ; Dst
.text$mn:00009388                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000938D                 add     esp, 0Ch
.text$mn:00009390                 mov     edx, [ebp+var_C]
.text$mn:00009393                 push    edx
.text$mn:00009394                 mov     ecx, [ebp+var_4]
.text$mn:00009397                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000939C
.text$mn:0000939C loc_939C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:0000939C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:0000939C                 mov     eax, [ebp+var_4]
.text$mn:0000939F                 mov     esp, ebp
.text$mn:000093A1                 pop     ebp
.text$mn:000093A2                 retn    8
.text$mn:000093A2 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:000093A2
.text$mn:000093A2 ; ---------------------------------------------------------------------------
.text$mn:000093A5                 align 4
.text$mn:000093A5 _text$mn        ends
.text$mn:000093A5
.text$mn:000093A8 ; ===========================================================================
.text$mn:000093A8
.text$mn:000093A8 ; Segment type: Pure code
.text$mn:000093A8 ; Segment permissions: Read/Execute
.text$mn:000093A8 _text$mn        segment para public 'CODE' use32
.text$mn:000093A8                 assume cs:_text$mn
.text$mn:000093A8                 ;org 93A8h
.text$mn:000093A8 ; COMDAT (pick any)
.text$mn:000093A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093A8
.text$mn:000093A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000093A8
.text$mn:000093A8 ; Attributes: bp-based frame
.text$mn:000093A8
.text$mn:000093A8 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:000093A8                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:000093A8 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:000093A8                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+143p
.text$mn:000093A8                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+1E3p ...
.text$mn:000093A8
.text$mn:000093A8 var_4           = dword ptr -4
.text$mn:000093A8 arg_0           = dword ptr  8
.text$mn:000093A8 arg_4           = dword ptr  0Ch
.text$mn:000093A8 arg_8           = dword ptr  10h
.text$mn:000093A8
.text$mn:000093A8                 push    ebp
.text$mn:000093A9                 mov     ebp, esp
.text$mn:000093AB                 push    ecx
.text$mn:000093AC                 mov     [ebp+var_4], ecx
.text$mn:000093AF                 mov     eax, [ebp+arg_8]
.text$mn:000093B2                 push    eax
.text$mn:000093B3                 mov     ecx, [ebp+arg_4]
.text$mn:000093B6                 push    ecx
.text$mn:000093B7                 mov     edx, [ebp+arg_0]
.text$mn:000093BA                 push    edx
.text$mn:000093BB                 mov     eax, [ebp+var_4]
.text$mn:000093BE                 mov     ecx, [eax+14h]
.text$mn:000093C1                 push    ecx
.text$mn:000093C2                 mov     edx, [ebp+var_4]
.text$mn:000093C5                 mov     eax, [edx+10h]
.text$mn:000093C8                 call    eax
.text$mn:000093CA                 add     esp, 10h
.text$mn:000093CD                 mov     esp, ebp
.text$mn:000093CF                 pop     ebp
.text$mn:000093D0                 retn    0Ch
.text$mn:000093D0 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:000093D0
.text$mn:000093D0 ; ---------------------------------------------------------------------------
.text$mn:000093D3                 align 4
.text$mn:000093D3 _text$mn        ends
.text$mn:000093D3
.text$mn:000093D4 ; ===========================================================================
.text$mn:000093D4
.text$mn:000093D4 ; Segment type: Pure code
.text$mn:000093D4 ; Segment permissions: Read/Execute
.text$mn:000093D4 _text$mn        segment para public 'CODE' use32
.text$mn:000093D4                 assume cs:_text$mn
.text$mn:000093D4                 ;org 93D4h
.text$mn:000093D4 ; COMDAT (pick any)
.text$mn:000093D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093D4
.text$mn:000093D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000093D4
.text$mn:000093D4 ; Attributes: bp-based frame
.text$mn:000093D4
.text$mn:000093D4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000093D4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000093D4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000093D4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000093D4                 push    ebp
.text$mn:000093D5                 mov     ebp, esp
.text$mn:000093D7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000093DC                 pop     ebp
.text$mn:000093DD                 retn
.text$mn:000093DD ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000093DD
.text$mn:000093DD ; ---------------------------------------------------------------------------
.text$mn:000093DE                 align 10h
.text$mn:000093DE _text$mn        ends
.text$mn:000093DE
.text$mn:000093E0 ; ===========================================================================
.text$mn:000093E0
.text$mn:000093E0 ; Segment type: Pure code
.text$mn:000093E0 ; Segment permissions: Read/Execute
.text$mn:000093E0 _text$mn        segment para public 'CODE' use32
.text$mn:000093E0                 assume cs:_text$mn
.text$mn:000093E0                 ;org 93E0h
.text$mn:000093E0 ; COMDAT (pick any)
.text$mn:000093E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093E0
.text$mn:000093E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000093E0
.text$mn:000093E0 ; Attributes: bp-based frame
.text$mn:000093E0
.text$mn:000093E0 ; public: long (__stdcall *__thiscall NppParameters::getEnableThemeDlgTexture(void)const)(struct HWND__ *, unsigned int, unsigned int, long)
.text$mn:000093E0                 public ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ
.text$mn:000093E0 ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ proc near
.text$mn:000093E0                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+8Fp
.text$mn:000093E0
.text$mn:000093E0 var_4           = dword ptr -4
.text$mn:000093E0
.text$mn:000093E0                 push    ebp
.text$mn:000093E1                 mov     ebp, esp
.text$mn:000093E3                 push    ecx
.text$mn:000093E4                 mov     [ebp+var_4], ecx
.text$mn:000093E7                 mov     eax, [ebp+var_4]
.text$mn:000093EA                 mov     eax, [eax+1C8FCh]
.text$mn:000093F0                 mov     esp, ebp
.text$mn:000093F2                 pop     ebp
.text$mn:000093F3                 retn
.text$mn:000093F3 ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ endp
.text$mn:000093F3
.text$mn:000093F3 _text$mn        ends
.text$mn:000093F3
.text$mn:000093F4 ; ===========================================================================
.text$mn:000093F4
.text$mn:000093F4 ; Segment type: Pure code
.text$mn:000093F4 ; Segment permissions: Read/Execute
.text$mn:000093F4 _text$mn        segment para public 'CODE' use32
.text$mn:000093F4                 assume cs:_text$mn
.text$mn:000093F4                 ;org 93F4h
.text$mn:000093F4 ; COMDAT (pick any)
.text$mn:000093F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000093F4
.text$mn:000093F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000093F4
.text$mn:000093F4 ; Attributes: bp-based frame
.text$mn:000093F4
.text$mn:000093F4 ; void __thiscall Window::getFocus(Window *__hidden this)
.text$mn:000093F4                 public ?getFocus@Window@@QBEXXZ
.text$mn:000093F4 ?getFocus@Window@@QBEXXZ proc near      ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+E4Ap
.text$mn:000093F4
.text$mn:000093F4 var_4           = dword ptr -4
.text$mn:000093F4
.text$mn:000093F4                 push    ebp
.text$mn:000093F5                 mov     ebp, esp
.text$mn:000093F7                 push    ecx
.text$mn:000093F8                 mov     [ebp+var_4], ecx
.text$mn:000093FB                 mov     eax, [ebp+var_4]
.text$mn:000093FE                 mov     ecx, [eax+0Ch]
.text$mn:00009401                 push    ecx             ; hWnd
.text$mn:00009402                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:00009408                 mov     esp, ebp
.text$mn:0000940A                 pop     ebp
.text$mn:0000940B                 retn
.text$mn:0000940B ?getFocus@Window@@QBEXXZ endp
.text$mn:0000940B
.text$mn:0000940B _text$mn        ends
.text$mn:0000940B
.text$mn:0000940C ; ===========================================================================
.text$mn:0000940C
.text$mn:0000940C ; Segment type: Pure code
.text$mn:0000940C ; Segment permissions: Read/Execute
.text$mn:0000940C _text$mn        segment para public 'CODE' use32
.text$mn:0000940C                 assume cs:_text$mn
.text$mn:0000940C                 ;org 940Ch
.text$mn:0000940C ; COMDAT (pick any)
.text$mn:0000940C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000940C
.text$mn:0000940C ; =============== S U B R O U T I N E =======================================
.text$mn:0000940C
.text$mn:0000940C ; Attributes: bp-based frame
.text$mn:0000940C
.text$mn:0000940C ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:0000940C                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:0000940C ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:0000940C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+7Ep
.text$mn:0000940C                 push    ebp
.text$mn:0000940D                 mov     ebp, esp
.text$mn:0000940F                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00009414                 pop     ebp
.text$mn:00009415                 retn
.text$mn:00009415 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00009415
.text$mn:00009415 ; ---------------------------------------------------------------------------
.text$mn:00009416                 align 4
.text$mn:00009416 _text$mn        ends
.text$mn:00009416
.text$mn:00009418 ; ===========================================================================
.text$mn:00009418
.text$mn:00009418 ; Segment type: Pure code
.text$mn:00009418 ; Segment permissions: Read/Execute
.text$mn:00009418 _text$mn        segment para public 'CODE' use32
.text$mn:00009418                 assume cs:_text$mn
.text$mn:00009418                 ;org 9418h
.text$mn:00009418 ; COMDAT (pick any)
.text$mn:00009418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009418
.text$mn:00009418 ; =============== S U B R O U T I N E =======================================
.text$mn:00009418
.text$mn:00009418 ; Attributes: bp-based frame
.text$mn:00009418
.text$mn:00009418 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00009418                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00009418 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00009418                                         ; CODE XREF: ColumnEditorDlg::init(HINSTANCE__ *,HWND__ *,ScintillaEditView * *)+14p
.text$mn:00009418
.text$mn:00009418 var_4           = dword ptr -4
.text$mn:00009418 arg_0           = dword ptr  8
.text$mn:00009418 arg_4           = dword ptr  0Ch
.text$mn:00009418
.text$mn:00009418                 push    ebp
.text$mn:00009419                 mov     ebp, esp
.text$mn:0000941B                 push    ecx
.text$mn:0000941C                 mov     [ebp+var_4], ecx
.text$mn:0000941F                 mov     eax, [ebp+var_4]
.text$mn:00009422                 mov     ecx, [ebp+arg_0]
.text$mn:00009425                 mov     [eax+4], ecx
.text$mn:00009428                 mov     edx, [ebp+var_4]
.text$mn:0000942B                 mov     eax, [ebp+arg_4]
.text$mn:0000942E                 mov     [edx+8], eax
.text$mn:00009431                 mov     esp, ebp
.text$mn:00009433                 pop     ebp
.text$mn:00009434                 retn    8
.text$mn:00009434 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00009434
.text$mn:00009434 ; ---------------------------------------------------------------------------
.text$mn:00009437                 align 4
.text$mn:00009437 _text$mn        ends
.text$mn:00009437
.text$mn:00009438 ; ===========================================================================
.text$mn:00009438
.text$mn:00009438 ; Segment type: Pure code
.text$mn:00009438 ; Segment permissions: Read/Execute
.text$mn:00009438 _text$mn        segment para public 'CODE' use32
.text$mn:00009438                 assume cs:_text$mn
.text$mn:00009438                 ;org 9438h
.text$mn:00009438 ; COMDAT (pick any)
.text$mn:00009438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009438
.text$mn:00009438 ; =============== S U B R O U T I N E =======================================
.text$mn:00009438
.text$mn:00009438 ; Attributes: bp-based frame
.text$mn:00009438
.text$mn:00009438 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::insert(unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00009438                 public ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z
.text$mn:00009438 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z proc near
.text$mn:00009438                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+57p
.text$mn:00009438
.text$mn:00009438 var_C           = dword ptr -0Ch
.text$mn:00009438 var_8           = dword ptr -8
.text$mn:00009438 var_4           = dword ptr -4
.text$mn:00009438 arg_0           = dword ptr  8
.text$mn:00009438 arg_4           = dword ptr  0Ch
.text$mn:00009438 arg_8           = dword ptr  10h
.text$mn:00009438 arg_C           = dword ptr  14h
.text$mn:00009438
.text$mn:00009438                 push    ebp
.text$mn:00009439                 mov     ebp, esp
.text$mn:0000943B                 sub     esp, 0Ch
.text$mn:0000943E                 mov     [ebp+var_4], ecx
.text$mn:00009441                 mov     eax, [ebp+var_4]
.text$mn:00009444                 mov     ecx, [eax+14h]
.text$mn:00009447                 cmp     ecx, [ebp+arg_0]
.text$mn:0000944A                 jb      short loc_9459
.text$mn:0000944C                 mov     ecx, [ebp+arg_4]
.text$mn:0000944F                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00009454                 cmp     eax, [ebp+arg_8]
.text$mn:00009457                 jnb     short loc_9461
.text$mn:00009459
.text$mn:00009459 loc_9459:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+12j
.text$mn:00009459                 mov     ecx, [ebp+var_4]
.text$mn:0000945C                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00009461
.text$mn:00009461 loc_9461:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+1Fj
.text$mn:00009461                 mov     ecx, [ebp+arg_4]
.text$mn:00009464                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00009469                 sub     eax, [ebp+arg_8]
.text$mn:0000946C                 mov     [ebp+var_8], eax
.text$mn:0000946F                 mov     edx, [ebp+var_8]
.text$mn:00009472                 cmp     edx, [ebp+arg_C]
.text$mn:00009475                 jnb     short loc_947D
.text$mn:00009477                 mov     eax, [ebp+var_8]
.text$mn:0000947A                 mov     [ebp+arg_C], eax
.text$mn:0000947D
.text$mn:0000947D loc_947D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+3Dj
.text$mn:0000947D                 mov     ecx, [ebp+var_4]
.text$mn:00009480                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00009486                 sub     edx, [ecx+14h]
.text$mn:00009489                 cmp     edx, [ebp+arg_C]
.text$mn:0000948C                 ja      short loc_9496
.text$mn:0000948E                 mov     ecx, [ebp+var_4]
.text$mn:00009491                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00009496
.text$mn:00009496 loc_9496:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+54j
.text$mn:00009496                 cmp     [ebp+arg_C], 0
.text$mn:0000949A                 jbe     loc_957E
.text$mn:000094A0                 mov     eax, [ebp+var_4]
.text$mn:000094A3                 mov     ecx, [eax+14h]
.text$mn:000094A6                 add     ecx, [ebp+arg_C]
.text$mn:000094A9                 mov     [ebp+var_8], ecx
.text$mn:000094AC                 push    0
.text$mn:000094AE                 mov     edx, [ebp+var_8]
.text$mn:000094B1                 push    edx
.text$mn:000094B2                 mov     ecx, [ebp+var_4]
.text$mn:000094B5                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:000094BA                 movzx   eax, al
.text$mn:000094BD                 test    eax, eax
.text$mn:000094BF                 jz      loc_957E
.text$mn:000094C5                 mov     ecx, [ebp+var_4]
.text$mn:000094C8                 mov     edx, [ecx+14h]
.text$mn:000094CB                 sub     edx, [ebp+arg_0]
.text$mn:000094CE                 push    edx             ; int
.text$mn:000094CF                 mov     ecx, [ebp+var_4]
.text$mn:000094D2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000094D7                 mov     ecx, [ebp+arg_0]
.text$mn:000094DA                 lea     edx, [eax+ecx*2]
.text$mn:000094DD                 push    edx             ; Src
.text$mn:000094DE                 mov     ecx, [ebp+var_4]
.text$mn:000094E1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000094E6                 mov     ecx, [ebp+arg_0]
.text$mn:000094E9                 lea     edx, [eax+ecx*2]
.text$mn:000094EC                 mov     eax, [ebp+arg_C]
.text$mn:000094EF                 lea     ecx, [edx+eax*2]
.text$mn:000094F2                 push    ecx             ; Dst
.text$mn:000094F3                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000094F8                 add     esp, 0Ch
.text$mn:000094FB                 mov     edx, [ebp+var_4]
.text$mn:000094FE                 cmp     edx, [ebp+arg_4]
.text$mn:00009501                 jnz     short loc_9548
.text$mn:00009503                 mov     eax, [ebp+arg_0]
.text$mn:00009506                 cmp     eax, [ebp+arg_8]
.text$mn:00009509                 jnb     short loc_9516
.text$mn:0000950B                 mov     ecx, [ebp+arg_8]
.text$mn:0000950E                 add     ecx, [ebp+arg_C]
.text$mn:00009511                 mov     [ebp+var_C], ecx
.text$mn:00009514                 jmp     short loc_951C
.text$mn:00009516 ; ---------------------------------------------------------------------------
.text$mn:00009516
.text$mn:00009516 loc_9516:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+D1j
.text$mn:00009516                 mov     edx, [ebp+arg_8]
.text$mn:00009519                 mov     [ebp+var_C], edx
.text$mn:0000951C
.text$mn:0000951C loc_951C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+DCj
.text$mn:0000951C                 mov     eax, [ebp+arg_C]
.text$mn:0000951F                 push    eax             ; int
.text$mn:00009520                 mov     ecx, [ebp+var_4]
.text$mn:00009523                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009528                 mov     ecx, [ebp+var_C]
.text$mn:0000952B                 lea     edx, [eax+ecx*2]
.text$mn:0000952E                 push    edx             ; Src
.text$mn:0000952F                 mov     ecx, [ebp+var_4]
.text$mn:00009532                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009537                 mov     ecx, [ebp+arg_0]
.text$mn:0000953A                 lea     edx, [eax+ecx*2]
.text$mn:0000953D                 push    edx             ; Dst
.text$mn:0000953E                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00009543                 add     esp, 0Ch
.text$mn:00009546                 jmp     short loc_9572
.text$mn:00009548 ; ---------------------------------------------------------------------------
.text$mn:00009548
.text$mn:00009548 loc_9548:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+C9j
.text$mn:00009548                 mov     eax, [ebp+arg_C]
.text$mn:0000954B                 push    eax             ; int
.text$mn:0000954C                 mov     ecx, [ebp+arg_4]
.text$mn:0000954F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009554                 mov     ecx, [ebp+arg_8]
.text$mn:00009557                 lea     edx, [eax+ecx*2]
.text$mn:0000955A                 push    edx             ; Src
.text$mn:0000955B                 mov     ecx, [ebp+var_4]
.text$mn:0000955E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009563                 mov     ecx, [ebp+arg_0]
.text$mn:00009566                 lea     edx, [eax+ecx*2]
.text$mn:00009569                 push    edx             ; Dst
.text$mn:0000956A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000956F                 add     esp, 0Ch
.text$mn:00009572
.text$mn:00009572 loc_9572:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+10Ej
.text$mn:00009572                 mov     eax, [ebp+var_8]
.text$mn:00009575                 push    eax
.text$mn:00009576                 mov     ecx, [ebp+var_4]
.text$mn:00009579                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000957E
.text$mn:0000957E loc_957E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+62j
.text$mn:0000957E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+87j
.text$mn:0000957E                 mov     eax, [ebp+var_4]
.text$mn:00009581                 mov     esp, ebp
.text$mn:00009583                 pop     ebp
.text$mn:00009584                 retn    10h
.text$mn:00009584 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z endp
.text$mn:00009584
.text$mn:00009584 ; ---------------------------------------------------------------------------
.text$mn:00009587                 align 4
.text$mn:00009587 _text$mn        ends
.text$mn:00009587
.text$mn:00009588 ; ===========================================================================
.text$mn:00009588
.text$mn:00009588 ; Segment type: Pure code
.text$mn:00009588 ; Segment permissions: Read/Execute
.text$mn:00009588 _text$mn        segment para public 'CODE' use32
.text$mn:00009588                 assume cs:_text$mn
.text$mn:00009588                 ;org 9588h
.text$mn:00009588 ; COMDAT (pick any)
.text$mn:00009588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009588
.text$mn:00009588 ; =============== S U B R O U T I N E =======================================
.text$mn:00009588
.text$mn:00009588 ; Attributes: bp-based frame
.text$mn:00009588
.text$mn:00009588 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(int, wchar_t *Str)
.text$mn:00009588                 public ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z
.text$mn:00009588 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z proc near
.text$mn:00009588                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+61Ep
.text$mn:00009588                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+DBFp
.text$mn:00009588
.text$mn:00009588 var_4           = dword ptr -4
.text$mn:00009588 arg_0           = dword ptr  8
.text$mn:00009588 Str             = dword ptr  0Ch
.text$mn:00009588
.text$mn:00009588                 push    ebp
.text$mn:00009589                 mov     ebp, esp
.text$mn:0000958B                 push    ecx
.text$mn:0000958C                 mov     [ebp+var_4], ecx
.text$mn:0000958F                 push    4F1h            ; unsigned int
.text$mn:00009594                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009599                 mov     eax, [ebp+Str]
.text$mn:0000959C                 push    eax             ; int
.text$mn:0000959D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000095A2                 add     esp, 0Ch
.text$mn:000095A5                 mov     ecx, [ebp+Str]
.text$mn:000095A8                 push    ecx             ; Str
.text$mn:000095A9                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000095AE                 add     esp, 4
.text$mn:000095B1                 push    eax             ; int
.text$mn:000095B2                 mov     edx, [ebp+Str]
.text$mn:000095B5                 push    edx             ; Src
.text$mn:000095B6                 mov     eax, [ebp+arg_0]
.text$mn:000095B9                 push    eax             ; int
.text$mn:000095BA                 mov     ecx, [ebp+var_4]
.text$mn:000095BD                 call    ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)
.text$mn:000095C2                 mov     esp, ebp
.text$mn:000095C4                 pop     ebp
.text$mn:000095C5                 retn    8
.text$mn:000095C5 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z endp
.text$mn:000095C5
.text$mn:000095C5 _text$mn        ends
.text$mn:000095C5
.text$mn:000095C8 ; ===========================================================================
.text$mn:000095C8
.text$mn:000095C8 ; Segment type: Pure code
.text$mn:000095C8 ; Segment permissions: Read/Execute
.text$mn:000095C8 _text$mn        segment para public 'CODE' use32
.text$mn:000095C8                 assume cs:_text$mn
.text$mn:000095C8                 ;org 95C8h
.text$mn:000095C8 ; COMDAT (pick any)
.text$mn:000095C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000095C8
.text$mn:000095C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000095C8
.text$mn:000095C8 ; Attributes: bp-based frame
.text$mn:000095C8
.text$mn:000095C8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(int, void *Src, int)
.text$mn:000095C8                 public ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z
.text$mn:000095C8 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z proc near
.text$mn:000095C8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *)+35p
.text$mn:000095C8
.text$mn:000095C8 var_8           = dword ptr -8
.text$mn:000095C8 var_4           = dword ptr -4
.text$mn:000095C8 arg_0           = dword ptr  8
.text$mn:000095C8 Src             = dword ptr  0Ch
.text$mn:000095C8 arg_8           = dword ptr  10h
.text$mn:000095C8
.text$mn:000095C8                 push    ebp
.text$mn:000095C9                 mov     ebp, esp
.text$mn:000095CB                 sub     esp, 8
.text$mn:000095CE                 mov     [ebp+var_4], ecx
.text$mn:000095D1                 cmp     [ebp+arg_8], 0
.text$mn:000095D5                 jz      short loc_95ED
.text$mn:000095D7                 push    4D9h            ; unsigned int
.text$mn:000095DC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000095E1                 mov     eax, [ebp+Src]
.text$mn:000095E4                 push    eax             ; int
.text$mn:000095E5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000095EA                 add     esp, 0Ch
.text$mn:000095ED
.text$mn:000095ED loc_95ED:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+Dj
.text$mn:000095ED                 mov     ecx, [ebp+Src]
.text$mn:000095F0                 push    ecx
.text$mn:000095F1                 mov     ecx, [ebp+var_4]
.text$mn:000095F4                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000095F9                 movzx   edx, al
.text$mn:000095FC                 test    edx, edx
.text$mn:000095FE                 jz      short loc_9629
.text$mn:00009600                 mov     eax, [ebp+arg_8]
.text$mn:00009603                 push    eax
.text$mn:00009604                 mov     ecx, [ebp+var_4]
.text$mn:00009607                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000960C                 mov     ecx, [ebp+Src]
.text$mn:0000960F                 sub     ecx, eax
.text$mn:00009611                 sar     ecx, 1
.text$mn:00009613                 push    ecx
.text$mn:00009614                 mov     edx, [ebp+var_4]
.text$mn:00009617                 push    edx
.text$mn:00009618                 mov     eax, [ebp+arg_0]
.text$mn:0000961B                 push    eax
.text$mn:0000961C                 mov     ecx, [ebp+var_4]
.text$mn:0000961F                 call    ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00009624                 jmp     loc_96E4
.text$mn:00009629 ; ---------------------------------------------------------------------------
.text$mn:00009629
.text$mn:00009629 loc_9629:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+36j
.text$mn:00009629                 mov     ecx, [ebp+var_4]
.text$mn:0000962C                 mov     edx, [ecx+14h]
.text$mn:0000962F                 cmp     edx, [ebp+arg_0]
.text$mn:00009632                 jnb     short loc_963C
.text$mn:00009634                 mov     ecx, [ebp+var_4]
.text$mn:00009637                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000963C
.text$mn:0000963C loc_963C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+6Aj
.text$mn:0000963C                 mov     eax, [ebp+var_4]
.text$mn:0000963F                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00009645                 sub     ecx, [eax+14h]
.text$mn:00009648                 cmp     ecx, [ebp+arg_8]
.text$mn:0000964B                 ja      short loc_9655
.text$mn:0000964D                 mov     ecx, [ebp+var_4]
.text$mn:00009650                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00009655
.text$mn:00009655 loc_9655:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+83j
.text$mn:00009655                 cmp     [ebp+arg_8], 0
.text$mn:00009659                 jbe     loc_96E1
.text$mn:0000965F                 mov     edx, [ebp+var_4]
.text$mn:00009662                 mov     eax, [edx+14h]
.text$mn:00009665                 add     eax, [ebp+arg_8]
.text$mn:00009668                 mov     [ebp+var_8], eax
.text$mn:0000966B                 push    0
.text$mn:0000966D                 mov     ecx, [ebp+var_8]
.text$mn:00009670                 push    ecx
.text$mn:00009671                 mov     ecx, [ebp+var_4]
.text$mn:00009674                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00009679                 movzx   edx, al
.text$mn:0000967C                 test    edx, edx
.text$mn:0000967E                 jz      short loc_96E1
.text$mn:00009680                 mov     eax, [ebp+var_4]
.text$mn:00009683                 mov     ecx, [eax+14h]
.text$mn:00009686                 sub     ecx, [ebp+arg_0]
.text$mn:00009689                 push    ecx             ; int
.text$mn:0000968A                 mov     ecx, [ebp+var_4]
.text$mn:0000968D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009692                 mov     edx, [ebp+arg_0]
.text$mn:00009695                 lea     eax, [eax+edx*2]
.text$mn:00009698                 push    eax             ; Src
.text$mn:00009699                 mov     ecx, [ebp+var_4]
.text$mn:0000969C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000096A1                 mov     ecx, [ebp+arg_0]
.text$mn:000096A4                 lea     edx, [eax+ecx*2]
.text$mn:000096A7                 mov     eax, [ebp+arg_8]
.text$mn:000096AA                 lea     ecx, [edx+eax*2]
.text$mn:000096AD                 push    ecx             ; Dst
.text$mn:000096AE                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000096B3                 add     esp, 0Ch
.text$mn:000096B6                 mov     edx, [ebp+arg_8]
.text$mn:000096B9                 push    edx             ; int
.text$mn:000096BA                 mov     eax, [ebp+Src]
.text$mn:000096BD                 push    eax             ; Src
.text$mn:000096BE                 mov     ecx, [ebp+var_4]
.text$mn:000096C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000096C6                 mov     ecx, [ebp+arg_0]
.text$mn:000096C9                 lea     edx, [eax+ecx*2]
.text$mn:000096CC                 push    edx             ; Dst
.text$mn:000096CD                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000096D2                 add     esp, 0Ch
.text$mn:000096D5                 mov     eax, [ebp+var_8]
.text$mn:000096D8                 push    eax
.text$mn:000096D9                 mov     ecx, [ebp+var_4]
.text$mn:000096DC                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000096E1
.text$mn:000096E1 loc_96E1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+91j
.text$mn:000096E1                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+B6j
.text$mn:000096E1                 mov     eax, [ebp+var_4]
.text$mn:000096E4
.text$mn:000096E4 loc_96E4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,wchar_t const *,uint)+5Cj
.text$mn:000096E4                 mov     esp, ebp
.text$mn:000096E6                 pop     ebp
.text$mn:000096E7                 retn    0Ch
.text$mn:000096E7 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z endp
.text$mn:000096E7
.text$mn:000096E7 ; ---------------------------------------------------------------------------
.text$mn:000096EA                 align 4
.text$mn:000096EA _text$mn        ends
.text$mn:000096EA
.text$mn:000096EC ; ===========================================================================
.text$mn:000096EC
.text$mn:000096EC ; Segment type: Pure code
.text$mn:000096EC ; Segment permissions: Read/Execute
.text$mn:000096EC _text$mn        segment para public 'CODE' use32
.text$mn:000096EC                 assume cs:_text$mn
.text$mn:000096EC                 ;org 96ECh
.text$mn:000096EC ; COMDAT (pick any)
.text$mn:000096EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000096EC
.text$mn:000096EC ; =============== S U B R O U T I N E =======================================
.text$mn:000096EC
.text$mn:000096EC ; Attributes: bp-based frame
.text$mn:000096EC
.text$mn:000096EC ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000096EC                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000096EC ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000096EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000096EC
.text$mn:000096EC var_4           = dword ptr -4
.text$mn:000096EC Str             = dword ptr  8
.text$mn:000096EC
.text$mn:000096EC                 push    ebp
.text$mn:000096ED                 mov     ebp, esp
.text$mn:000096EF                 push    ecx
.text$mn:000096F0                 mov     eax, [ebp+Str]
.text$mn:000096F3                 movsx   ecx, byte ptr [eax]
.text$mn:000096F6                 test    ecx, ecx
.text$mn:000096F8                 jnz     short loc_9703
.text$mn:000096FA                 mov     [ebp+var_4], 0
.text$mn:00009701                 jmp     short loc_9712
.text$mn:00009703 ; ---------------------------------------------------------------------------
.text$mn:00009703
.text$mn:00009703 loc_9703:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00009703                 mov     edx, [ebp+Str]
.text$mn:00009706                 push    edx             ; Str
.text$mn:00009707                 call    _strlen
.text$mn:0000970C                 add     esp, 4
.text$mn:0000970F                 mov     [ebp+var_4], eax
.text$mn:00009712
.text$mn:00009712 loc_9712:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00009712                 mov     eax, [ebp+var_4]
.text$mn:00009715                 mov     esp, ebp
.text$mn:00009717                 pop     ebp
.text$mn:00009718                 retn
.text$mn:00009718 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00009718
.text$mn:00009718 ; ---------------------------------------------------------------------------
.text$mn:00009719                 align 4
.text$mn:00009719 _text$mn        ends
.text$mn:00009719
.text$mn:0000971C ; ===========================================================================
.text$mn:0000971C
.text$mn:0000971C ; Segment type: Pure code
.text$mn:0000971C ; Segment permissions: Read/Execute
.text$mn:0000971C _text$mn        segment para public 'CODE' use32
.text$mn:0000971C                 assume cs:_text$mn
.text$mn:0000971C                 ;org 971Ch
.text$mn:0000971C ; COMDAT (pick any)
.text$mn:0000971C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000971C
.text$mn:0000971C ; =============== S U B R O U T I N E =======================================
.text$mn:0000971C
.text$mn:0000971C ; Attributes: bp-based frame
.text$mn:0000971C
.text$mn:0000971C ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000971C                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000971C ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000971C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:0000971C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p ...
.text$mn:0000971C
.text$mn:0000971C var_4           = dword ptr -4
.text$mn:0000971C Str             = dword ptr  8
.text$mn:0000971C
.text$mn:0000971C                 push    ebp
.text$mn:0000971D                 mov     ebp, esp
.text$mn:0000971F                 push    ecx
.text$mn:00009720                 mov     eax, [ebp+Str]
.text$mn:00009723                 movzx   ecx, word ptr [eax]
.text$mn:00009726                 test    ecx, ecx
.text$mn:00009728                 jnz     short loc_9733
.text$mn:0000972A                 mov     [ebp+var_4], 0
.text$mn:00009731                 jmp     short loc_9742
.text$mn:00009733 ; ---------------------------------------------------------------------------
.text$mn:00009733
.text$mn:00009733 loc_9733:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00009733                 mov     edx, [ebp+Str]
.text$mn:00009736                 push    edx             ; Str
.text$mn:00009737                 call    _wcslen
.text$mn:0000973C                 add     esp, 4
.text$mn:0000973F                 mov     [ebp+var_4], eax
.text$mn:00009742
.text$mn:00009742 loc_9742:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00009742                 mov     eax, [ebp+var_4]
.text$mn:00009745                 mov     esp, ebp
.text$mn:00009747                 pop     ebp
.text$mn:00009748                 retn
.text$mn:00009748 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00009748
.text$mn:00009748 ; ---------------------------------------------------------------------------
.text$mn:00009749                 align 4
.text$mn:00009749 _text$mn        ends
.text$mn:00009749
.text$mn:0000974C ; ===========================================================================
.text$mn:0000974C
.text$mn:0000974C ; Segment type: Pure code
.text$mn:0000974C ; Segment permissions: Read/Execute
.text$mn:0000974C _text$mn        segment para public 'CODE' use32
.text$mn:0000974C                 assume cs:_text$mn
.text$mn:0000974C                 ;org 974Ch
.text$mn:0000974C ; COMDAT (pick any)
.text$mn:0000974C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000974C
.text$mn:0000974C ; =============== S U B R O U T I N E =======================================
.text$mn:0000974C
.text$mn:0000974C ; Attributes: bp-based frame
.text$mn:0000974C
.text$mn:0000974C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000974C                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000974C ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000974C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000974C
.text$mn:0000974C var_4           = dword ptr -4
.text$mn:0000974C
.text$mn:0000974C                 push    ebp
.text$mn:0000974D                 mov     ebp, esp
.text$mn:0000974F                 push    ecx
.text$mn:00009750                 mov     [ebp+var_4], ecx
.text$mn:00009753                 mov     eax, [ebp+var_4]
.text$mn:00009756                 push    eax
.text$mn:00009757                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000975C                 add     esp, 4
.text$mn:0000975F                 mov     esp, ebp
.text$mn:00009761                 pop     ebp
.text$mn:00009762                 retn
.text$mn:00009762 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00009762
.text$mn:00009762 ; ---------------------------------------------------------------------------
.text$mn:00009763                 align 4
.text$mn:00009763 _text$mn        ends
.text$mn:00009763
.text$mn:00009764 ; ===========================================================================
.text$mn:00009764
.text$mn:00009764 ; Segment type: Pure code
.text$mn:00009764 ; Segment permissions: Read/Execute
.text$mn:00009764 _text$mn        segment para public 'CODE' use32
.text$mn:00009764                 assume cs:_text$mn
.text$mn:00009764                 ;org 9764h
.text$mn:00009764 ; COMDAT (pick any)
.text$mn:00009764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009764
.text$mn:00009764 ; =============== S U B R O U T I N E =======================================
.text$mn:00009764
.text$mn:00009764 ; Attributes: bp-based frame
.text$mn:00009764
.text$mn:00009764 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<int>>::max_size(void)const
.text$mn:00009764                 public ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00009764 ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00009764                                         ; CODE XREF: std::vector<int,std::allocator<int>>::max_size(void)+17p
.text$mn:00009764
.text$mn:00009764 var_4           = dword ptr -4
.text$mn:00009764
.text$mn:00009764                 push    ebp
.text$mn:00009765                 mov     ebp, esp
.text$mn:00009767                 push    ecx
.text$mn:00009768                 mov     [ebp+var_4], ecx
.text$mn:0000976B                 mov     eax, [ebp+var_4]
.text$mn:0000976E                 push    eax
.text$mn:0000976F                 call    ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)
.text$mn:00009774                 add     esp, 4
.text$mn:00009777                 mov     esp, ebp
.text$mn:00009779                 pop     ebp
.text$mn:0000977A                 retn
.text$mn:0000977A ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000977A
.text$mn:0000977A ; ---------------------------------------------------------------------------
.text$mn:0000977B                 align 4
.text$mn:0000977B _text$mn        ends
.text$mn:0000977B
.text$mn:0000977C ; ===========================================================================
.text$mn:0000977C
.text$mn:0000977C ; Segment type: Pure code
.text$mn:0000977C ; Segment permissions: Read/Execute
.text$mn:0000977C _text$mn        segment para public 'CODE' use32
.text$mn:0000977C                 assume cs:_text$mn
.text$mn:0000977C                 ;org 977Ch
.text$mn:0000977C ; COMDAT (pick any)
.text$mn:0000977C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000977C
.text$mn:0000977C ; =============== S U B R O U T I N E =======================================
.text$mn:0000977C
.text$mn:0000977C ; Attributes: bp-based frame
.text$mn:0000977C
.text$mn:0000977C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000977C                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000977C ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000977C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000977C
.text$mn:0000977C var_4           = dword ptr -4
.text$mn:0000977C
.text$mn:0000977C                 push    ebp
.text$mn:0000977D                 mov     ebp, esp
.text$mn:0000977F                 push    ecx
.text$mn:00009780                 mov     [ebp+var_4], ecx
.text$mn:00009783                 mov     eax, [ebp+var_4]
.text$mn:00009786                 push    eax
.text$mn:00009787                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:0000978C                 add     esp, 4
.text$mn:0000978F                 mov     esp, ebp
.text$mn:00009791                 pop     ebp
.text$mn:00009792                 retn
.text$mn:00009792 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:00009792
.text$mn:00009792 ; ---------------------------------------------------------------------------
.text$mn:00009793                 align 4
.text$mn:00009793 _text$mn        ends
.text$mn:00009793
.text$mn:00009794 ; ===========================================================================
.text$mn:00009794
.text$mn:00009794 ; Segment type: Pure code
.text$mn:00009794 ; Segment permissions: Read/Execute
.text$mn:00009794 _text$mn        segment para public 'CODE' use32
.text$mn:00009794                 assume cs:_text$mn
.text$mn:00009794                 ;org 9794h
.text$mn:00009794 ; COMDAT (pick any)
.text$mn:00009794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009794
.text$mn:00009794 ; =============== S U B R O U T I N E =======================================
.text$mn:00009794
.text$mn:00009794 ; Attributes: bp-based frame
.text$mn:00009794
.text$mn:00009794 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00009794                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00009794 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00009794                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00009794
.text$mn:00009794 var_4           = dword ptr -4
.text$mn:00009794
.text$mn:00009794                 push    ebp
.text$mn:00009795                 mov     ebp, esp
.text$mn:00009797                 push    ecx
.text$mn:00009798                 mov     [ebp+var_4], ecx
.text$mn:0000979B                 or      eax, 0FFFFFFFFh
.text$mn:0000979E                 mov     esp, ebp
.text$mn:000097A0                 pop     ebp
.text$mn:000097A1                 retn
.text$mn:000097A1 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000097A1
.text$mn:000097A1 ; ---------------------------------------------------------------------------
.text$mn:000097A2                 align 4
.text$mn:000097A2 _text$mn        ends
.text$mn:000097A2
.text$mn:000097A4 ; ===========================================================================
.text$mn:000097A4
.text$mn:000097A4 ; Segment type: Pure code
.text$mn:000097A4 ; Segment permissions: Read/Execute
.text$mn:000097A4 _text$mn        segment para public 'CODE' use32
.text$mn:000097A4                 assume cs:_text$mn
.text$mn:000097A4                 ;org 97A4h
.text$mn:000097A4 ; COMDAT (pick any)
.text$mn:000097A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097A4
.text$mn:000097A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000097A4
.text$mn:000097A4 ; Attributes: bp-based frame
.text$mn:000097A4
.text$mn:000097A4 ; public: unsigned int __thiscall std::allocator<int>::max_size(void)const
.text$mn:000097A4                 public ?max_size@?$allocator@H@std@@QBEIXZ
.text$mn:000097A4 ?max_size@?$allocator@H@std@@QBEIXZ proc near
.text$mn:000097A4                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)+6p
.text$mn:000097A4
.text$mn:000097A4 var_4           = dword ptr -4
.text$mn:000097A4
.text$mn:000097A4                 push    ebp
.text$mn:000097A5                 mov     ebp, esp
.text$mn:000097A7                 push    ecx
.text$mn:000097A8                 mov     [ebp+var_4], ecx
.text$mn:000097AB                 mov     eax, 3FFFFFFFh
.text$mn:000097B0                 mov     esp, ebp
.text$mn:000097B2                 pop     ebp
.text$mn:000097B3                 retn
.text$mn:000097B3 ?max_size@?$allocator@H@std@@QBEIXZ endp
.text$mn:000097B3
.text$mn:000097B3 _text$mn        ends
.text$mn:000097B3
.text$mn:000097B4 ; ===========================================================================
.text$mn:000097B4
.text$mn:000097B4 ; Segment type: Pure code
.text$mn:000097B4 ; Segment permissions: Read/Execute
.text$mn:000097B4 _text$mn        segment para public 'CODE' use32
.text$mn:000097B4                 assume cs:_text$mn
.text$mn:000097B4                 ;org 97B4h
.text$mn:000097B4 ; COMDAT (pick any)
.text$mn:000097B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097B4
.text$mn:000097B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000097B4
.text$mn:000097B4 ; Attributes: bp-based frame
.text$mn:000097B4
.text$mn:000097B4 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:000097B4                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:000097B4 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:000097B4                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:000097B4
.text$mn:000097B4 var_4           = dword ptr -4
.text$mn:000097B4
.text$mn:000097B4                 push    ebp
.text$mn:000097B5                 mov     ebp, esp
.text$mn:000097B7                 push    ecx
.text$mn:000097B8                 mov     [ebp+var_4], ecx
.text$mn:000097BB                 mov     eax, 7FFFFFFFh
.text$mn:000097C0                 mov     esp, ebp
.text$mn:000097C2                 pop     ebp
.text$mn:000097C3                 retn
.text$mn:000097C3 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:000097C3
.text$mn:000097C3 _text$mn        ends
.text$mn:000097C3
.text$mn:000097C4 ; ===========================================================================
.text$mn:000097C4
.text$mn:000097C4 ; Segment type: Pure code
.text$mn:000097C4 ; Segment permissions: Read/Execute
.text$mn:000097C4 _text$mn        segment para public 'CODE' use32
.text$mn:000097C4                 assume cs:_text$mn
.text$mn:000097C4                 ;org 97C4h
.text$mn:000097C4 ; COMDAT (pick any)
.text$mn:000097C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097C4
.text$mn:000097C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000097C4
.text$mn:000097C4 ; Attributes: bp-based frame
.text$mn:000097C4
.text$mn:000097C4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000097C4                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000097C4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000097C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000097C4
.text$mn:000097C4 arg_0           = dword ptr  8
.text$mn:000097C4
.text$mn:000097C4                 push    ebp
.text$mn:000097C5                 mov     ebp, esp
.text$mn:000097C7                 mov     ecx, [ebp+arg_0]
.text$mn:000097CA                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000097CF                 pop     ebp
.text$mn:000097D0                 retn
.text$mn:000097D0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000097D0
.text$mn:000097D0 ; ---------------------------------------------------------------------------
.text$mn:000097D1                 align 4
.text$mn:000097D1 _text$mn        ends
.text$mn:000097D1
.text$mn:000097D4 ; ===========================================================================
.text$mn:000097D4
.text$mn:000097D4 ; Segment type: Pure code
.text$mn:000097D4 ; Segment permissions: Read/Execute
.text$mn:000097D4 _text$mn        segment para public 'CODE' use32
.text$mn:000097D4                 assume cs:_text$mn
.text$mn:000097D4                 ;org 97D4h
.text$mn:000097D4 ; COMDAT (pick any)
.text$mn:000097D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097D4
.text$mn:000097D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000097D4
.text$mn:000097D4 ; Attributes: bp-based frame
.text$mn:000097D4
.text$mn:000097D4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<int>>::max_size(class std::allocator<int> const &)
.text$mn:000097D4                 public ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
.text$mn:000097D4 ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z proc near
.text$mn:000097D4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::max_size(void)+Bp
.text$mn:000097D4
.text$mn:000097D4 arg_0           = dword ptr  8
.text$mn:000097D4
.text$mn:000097D4                 push    ebp
.text$mn:000097D5                 mov     ebp, esp
.text$mn:000097D7                 mov     ecx, [ebp+arg_0]
.text$mn:000097DA                 call    ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size(void)
.text$mn:000097DF                 pop     ebp
.text$mn:000097E0                 retn
.text$mn:000097E0 ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z endp
.text$mn:000097E0
.text$mn:000097E0 ; ---------------------------------------------------------------------------
.text$mn:000097E1                 align 4
.text$mn:000097E1 _text$mn        ends
.text$mn:000097E1
.text$mn:000097E4 ; ===========================================================================
.text$mn:000097E4
.text$mn:000097E4 ; Segment type: Pure code
.text$mn:000097E4 ; Segment permissions: Read/Execute
.text$mn:000097E4 _text$mn        segment para public 'CODE' use32
.text$mn:000097E4                 assume cs:_text$mn
.text$mn:000097E4                 ;org 97E4h
.text$mn:000097E4 ; COMDAT (pick any)
.text$mn:000097E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097E4
.text$mn:000097E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000097E4
.text$mn:000097E4 ; Attributes: bp-based frame
.text$mn:000097E4
.text$mn:000097E4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:000097E4                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:000097E4 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:000097E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:000097E4
.text$mn:000097E4 arg_0           = dword ptr  8
.text$mn:000097E4
.text$mn:000097E4                 push    ebp
.text$mn:000097E5                 mov     ebp, esp
.text$mn:000097E7                 mov     ecx, [ebp+arg_0]
.text$mn:000097EA                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:000097EF                 pop     ebp
.text$mn:000097F0                 retn
.text$mn:000097F0 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:000097F0
.text$mn:000097F0 ; ---------------------------------------------------------------------------
.text$mn:000097F1                 align 4
.text$mn:000097F1 _text$mn        ends
.text$mn:000097F1
.text$mn:000097F4 ; ===========================================================================
.text$mn:000097F4
.text$mn:000097F4 ; Segment type: Pure code
.text$mn:000097F4 ; Segment permissions: Read/Execute
.text$mn:000097F4 _text$mn        segment para public 'CODE' use32
.text$mn:000097F4                 assume cs:_text$mn
.text$mn:000097F4                 ;org 97F4h
.text$mn:000097F4 ; COMDAT (pick any)
.text$mn:000097F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000097F4
.text$mn:000097F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000097F4
.text$mn:000097F4 ; Attributes: bp-based frame
.text$mn:000097F4
.text$mn:000097F4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000097F4                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000097F4 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000097F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000097F4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000097F4
.text$mn:000097F4 var_10          = dword ptr -10h
.text$mn:000097F4 var_C           = dword ptr -0Ch
.text$mn:000097F4 var_8           = dword ptr -8
.text$mn:000097F4 var_1           = byte ptr -1
.text$mn:000097F4
.text$mn:000097F4                 push    ebp
.text$mn:000097F5                 mov     ebp, esp
.text$mn:000097F7                 sub     esp, 10h
.text$mn:000097FA                 mov     [ebp+var_10], ecx
.text$mn:000097FD                 lea     eax, [ebp+var_1]
.text$mn:00009800                 push    eax
.text$mn:00009801                 mov     ecx, [ebp+var_10]
.text$mn:00009804                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00009809                 mov     ecx, eax
.text$mn:0000980B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00009810                 mov     [ebp+var_8], eax
.text$mn:00009813                 cmp     [ebp+var_8], 1
.text$mn:00009817                 ja      short loc_9822
.text$mn:00009819                 mov     [ebp+var_C], 1
.text$mn:00009820                 jmp     short loc_982B
.text$mn:00009822 ; ---------------------------------------------------------------------------
.text$mn:00009822
.text$mn:00009822 loc_9822:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00009822                 mov     ecx, [ebp+var_8]
.text$mn:00009825                 sub     ecx, 1
.text$mn:00009828                 mov     [ebp+var_C], ecx
.text$mn:0000982B
.text$mn:0000982B loc_982B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000982B                 mov     eax, [ebp+var_C]
.text$mn:0000982E                 mov     esp, ebp
.text$mn:00009830                 pop     ebp
.text$mn:00009831                 retn
.text$mn:00009831 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00009831
.text$mn:00009831 ; ---------------------------------------------------------------------------
.text$mn:00009832                 align 4
.text$mn:00009832 _text$mn        ends
.text$mn:00009832
.text$mn:00009834 ; ===========================================================================
.text$mn:00009834
.text$mn:00009834 ; Segment type: Pure code
.text$mn:00009834 ; Segment permissions: Read/Execute
.text$mn:00009834 _text$mn        segment para public 'CODE' use32
.text$mn:00009834                 assume cs:_text$mn
.text$mn:00009834                 ;org 9834h
.text$mn:00009834 ; COMDAT (pick any)
.text$mn:00009834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009834
.text$mn:00009834 ; =============== S U B R O U T I N E =======================================
.text$mn:00009834
.text$mn:00009834 ; Attributes: bp-based frame
.text$mn:00009834
.text$mn:00009834 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00009834                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00009834 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00009834                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:00009834                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:00009834
.text$mn:00009834 var_10          = dword ptr -10h
.text$mn:00009834 var_C           = dword ptr -0Ch
.text$mn:00009834 var_8           = dword ptr -8
.text$mn:00009834 var_1           = byte ptr -1
.text$mn:00009834
.text$mn:00009834                 push    ebp
.text$mn:00009835                 mov     ebp, esp
.text$mn:00009837                 sub     esp, 10h
.text$mn:0000983A                 mov     [ebp+var_10], ecx
.text$mn:0000983D                 lea     eax, [ebp+var_1]
.text$mn:00009840                 push    eax
.text$mn:00009841                 mov     ecx, [ebp+var_10]
.text$mn:00009844                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00009849                 mov     ecx, eax
.text$mn:0000984B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00009850                 mov     [ebp+var_8], eax
.text$mn:00009853                 cmp     [ebp+var_8], 1
.text$mn:00009857                 ja      short loc_9862
.text$mn:00009859                 mov     [ebp+var_C], 1
.text$mn:00009860                 jmp     short loc_986B
.text$mn:00009862 ; ---------------------------------------------------------------------------
.text$mn:00009862
.text$mn:00009862 loc_9862:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:00009862                 mov     ecx, [ebp+var_8]
.text$mn:00009865                 sub     ecx, 1
.text$mn:00009868                 mov     [ebp+var_C], ecx
.text$mn:0000986B
.text$mn:0000986B loc_986B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000986B                 mov     eax, [ebp+var_C]
.text$mn:0000986E                 mov     esp, ebp
.text$mn:00009870                 pop     ebp
.text$mn:00009871                 retn
.text$mn:00009871 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00009871
.text$mn:00009871 ; ---------------------------------------------------------------------------
.text$mn:00009872                 align 4
.text$mn:00009872 _text$mn        ends
.text$mn:00009872
.text$mn:00009874 ; ===========================================================================
.text$mn:00009874
.text$mn:00009874 ; Segment type: Pure code
.text$mn:00009874 ; Segment permissions: Read/Execute
.text$mn:00009874 _text$mn        segment para public 'CODE' use32
.text$mn:00009874                 assume cs:_text$mn
.text$mn:00009874                 ;org 9874h
.text$mn:00009874 ; COMDAT (pick any)
.text$mn:00009874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009874
.text$mn:00009874 ; =============== S U B R O U T I N E =======================================
.text$mn:00009874
.text$mn:00009874 ; Attributes: bp-based frame
.text$mn:00009874
.text$mn:00009874 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::max_size(void)const
.text$mn:00009874                 public ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00009874 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00009874                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+17p
.text$mn:00009874                                         ; std::vector<int,std::allocator<int>>::_Reserve(uint)+18p
.text$mn:00009874
.text$mn:00009874 var_8           = dword ptr -8
.text$mn:00009874 var_1           = byte ptr -1
.text$mn:00009874
.text$mn:00009874                 push    ebp
.text$mn:00009875                 mov     ebp, esp
.text$mn:00009877                 sub     esp, 8
.text$mn:0000987A                 mov     [ebp+var_8], ecx
.text$mn:0000987D                 lea     eax, [ebp+var_1]
.text$mn:00009880                 push    eax
.text$mn:00009881                 mov     ecx, [ebp+var_8]
.text$mn:00009884                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00009889                 mov     ecx, eax
.text$mn:0000988B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<int>>::max_size(void)
.text$mn:00009890                 mov     esp, ebp
.text$mn:00009892                 pop     ebp
.text$mn:00009893                 retn
.text$mn:00009893 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00009893
.text$mn:00009893 _text$mn        ends
.text$mn:00009893
.text$mn:00009894 ; ===========================================================================
.text$mn:00009894
.text$mn:00009894 ; Segment type: Pure code
.text$mn:00009894 ; Segment permissions: Read/Execute
.text$mn:00009894 _text$mn        segment para public 'CODE' use32
.text$mn:00009894                 assume cs:_text$mn
.text$mn:00009894                 ;org 9894h
.text$mn:00009894 ; COMDAT (pick any)
.text$mn:00009894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009894
.text$mn:00009894 ; =============== S U B R O U T I N E =======================================
.text$mn:00009894
.text$mn:00009894 ; Attributes: bp-based frame
.text$mn:00009894
.text$mn:00009894 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00009894                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00009894 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00009894                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00009894                                         ; DATA XREF: .rdata:0000AFC8o
.text$mn:00009894
.text$mn:00009894 var_1C          = dword ptr -1Ch
.text$mn:00009894 var_18          = dword ptr -18h
.text$mn:00009894 Str             = dword ptr -14h
.text$mn:00009894 var_10          = dword ptr -10h
.text$mn:00009894 var_C           = dword ptr -0Ch
.text$mn:00009894 var_4           = dword ptr -4
.text$mn:00009894 arg_0           = dword ptr  8
.text$mn:00009894 arg_4           = dword ptr  0Ch
.text$mn:00009894
.text$mn:00009894                 push    ebp
.text$mn:00009895                 mov     ebp, esp
.text$mn:00009897                 push    0FFFFFFFFh
.text$mn:00009899                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000989E                 mov     eax, large fs:0
.text$mn:000098A4                 push    eax
.text$mn:000098A5                 sub     esp, 10h
.text$mn:000098A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000098AD                 xor     eax, ebp
.text$mn:000098AF                 push    eax
.text$mn:000098B0                 lea     eax, [ebp+var_C]
.text$mn:000098B3                 mov     large fs:0, eax
.text$mn:000098B9                 mov     [ebp+var_1C], ecx
.text$mn:000098BC                 mov     [ebp+var_18], 0
.text$mn:000098C3                 mov     eax, [ebp+arg_4]
.text$mn:000098C6                 push    eax             ; int
.text$mn:000098C7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000098CC                 add     esp, 4
.text$mn:000098CF                 mov     [ebp+var_10], eax
.text$mn:000098D2                 cmp     [ebp+var_10], 0
.text$mn:000098D6                 jz      short loc_98E0
.text$mn:000098D8                 mov     ecx, [ebp+var_10]
.text$mn:000098DB                 mov     [ebp+Str], ecx
.text$mn:000098DE                 jmp     short loc_98E7
.text$mn:000098E0 ; ---------------------------------------------------------------------------
.text$mn:000098E0
.text$mn:000098E0 loc_98E0:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000098E0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000098E7
.text$mn:000098E7 loc_98E7:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000098E7                 mov     edx, [ebp+Str]
.text$mn:000098EA                 push    edx             ; Str
.text$mn:000098EB                 mov     ecx, [ebp+arg_0]
.text$mn:000098EE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000098F3                 mov     [ebp+var_4], 0
.text$mn:000098FA                 mov     eax, [ebp+var_18]
.text$mn:000098FD                 or      eax, 1
.text$mn:00009900                 mov     [ebp+var_18], eax
.text$mn:00009903                 mov     eax, [ebp+arg_0]
.text$mn:00009906                 mov     ecx, [ebp+var_C]
.text$mn:00009909                 mov     large fs:0, ecx
.text$mn:00009910                 pop     ecx
.text$mn:00009911                 mov     esp, ebp
.text$mn:00009913                 pop     ebp
.text$mn:00009914                 retn    8
.text$mn:00009914 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00009914
.text$mn:00009914 ; ---------------------------------------------------------------------------
.text$mn:00009917                 align 4
.text$mn:00009917 _text$mn        ends
.text$mn:00009917
.text$x:00009918 ; ===========================================================================
.text$x:00009918
.text$x:00009918 ; Segment type: Pure code
.text$x:00009918 ; Segment permissions: Read/Execute
.text$x:00009918 _text$x         segment para public 'CODE' use32
.text$x:00009918                 assume cs:_text$x
.text$x:00009918                 ;org 9918h
.text$x:00009918 ; COMDAT (pick associative to section at 9894)
.text$x:00009918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009918
.text$x:00009918 ; =============== S U B R O U T I N E =======================================
.text$x:00009918
.text$x:00009918
.text$x:00009918 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00009918                                         ; DATA XREF: .xdata$x:0000A1F0o
.text$x:00009918                 mov     eax, [ebp-18h]
.text$x:0000991B                 and     eax, 1
.text$x:0000991E                 jz      $LN6
.text$x:00009924                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00009928                 mov     ecx, [ebp+8]
.text$x:0000992B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00009930 ; ---------------------------------------------------------------------------
.text$x:00009930
.text$x:00009930 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00009930                 retn
.text$x:00009930 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00009930
.text$x:00009931
.text$x:00009931 ; =============== S U B R O U T I N E =======================================
.text$x:00009931
.text$x:00009931
.text$x:00009931 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00009931                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00009931
.text$x:00009931 arg_4           = dword ptr  8
.text$x:00009931
.text$x:00009931                 mov     edx, [esp+arg_4]
.text$x:00009935                 lea     eax, [edx+0Ch]
.text$x:00009938                 mov     ecx, [edx-14h]
.text$x:0000993B                 xor     ecx, eax
.text$x:0000993D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009942                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00009947                 jmp     ___CxxFrameHandler3
.text$x:00009947 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00009947
.text$x:00009947 _text$x         ends
.text$x:00009947
.text$mn:0000994C ; ===========================================================================
.text$mn:0000994C
.text$mn:0000994C ; Segment type: Pure code
.text$mn:0000994C ; Segment permissions: Read/Execute
.text$mn:0000994C _text$mn        segment para public 'CODE' use32
.text$mn:0000994C                 assume cs:_text$mn
.text$mn:0000994C                 ;org 994Ch
.text$mn:0000994C ; COMDAT (pick any)
.text$mn:0000994C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000994C
.text$mn:0000994C ; =============== S U B R O U T I N E =======================================
.text$mn:0000994C
.text$mn:0000994C ; Attributes: bp-based frame
.text$mn:0000994C
.text$mn:0000994C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000994C                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000994C ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000994C                                         ; DATA XREF: .rdata:0000AFFCo
.text$mn:0000994C
.text$mn:0000994C var_14          = dword ptr -14h
.text$mn:0000994C var_10          = dword ptr -10h
.text$mn:0000994C var_C           = dword ptr -0Ch
.text$mn:0000994C var_4           = dword ptr -4
.text$mn:0000994C arg_0           = dword ptr  8
.text$mn:0000994C arg_4           = dword ptr  0Ch
.text$mn:0000994C
.text$mn:0000994C                 push    ebp
.text$mn:0000994D                 mov     ebp, esp
.text$mn:0000994F                 push    0FFFFFFFFh
.text$mn:00009951                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00009956                 mov     eax, large fs:0
.text$mn:0000995C                 push    eax
.text$mn:0000995D                 sub     esp, 8
.text$mn:00009960                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009965                 xor     eax, ebp
.text$mn:00009967                 push    eax
.text$mn:00009968                 lea     eax, [ebp+var_C]
.text$mn:0000996B                 mov     large fs:0, eax
.text$mn:00009971                 mov     [ebp+var_14], ecx
.text$mn:00009974                 mov     [ebp+var_10], 0
.text$mn:0000997B                 cmp     [ebp+arg_4], 1
.text$mn:0000997F                 jnz     short loc_99A5
.text$mn:00009981                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00009986                 mov     ecx, [ebp+arg_0]
.text$mn:00009989                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000998E                 mov     [ebp+var_4], 0
.text$mn:00009995                 mov     eax, [ebp+var_10]
.text$mn:00009998                 or      eax, 1
.text$mn:0000999B                 mov     [ebp+var_10], eax
.text$mn:0000999E                 mov     eax, [ebp+arg_0]
.text$mn:000099A1                 jmp     short loc_99C8
.text$mn:000099A3 ; ---------------------------------------------------------------------------
.text$mn:000099A3                 jmp     short loc_99C8
.text$mn:000099A5 ; ---------------------------------------------------------------------------
.text$mn:000099A5
.text$mn:000099A5 loc_99A5:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000099A5                 mov     ecx, [ebp+arg_4]
.text$mn:000099A8                 push    ecx
.text$mn:000099A9                 mov     edx, [ebp+arg_0]
.text$mn:000099AC                 push    edx
.text$mn:000099AD                 mov     ecx, [ebp+var_14]
.text$mn:000099B0                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000099B5                 mov     [ebp+var_4], 0
.text$mn:000099BC                 mov     eax, [ebp+var_10]
.text$mn:000099BF                 or      eax, 1
.text$mn:000099C2                 mov     [ebp+var_10], eax
.text$mn:000099C5                 mov     eax, [ebp+arg_0]
.text$mn:000099C8
.text$mn:000099C8 loc_99C8:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000099C8                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000099C8                 mov     ecx, [ebp+var_C]
.text$mn:000099CB                 mov     large fs:0, ecx
.text$mn:000099D2                 pop     ecx
.text$mn:000099D3                 mov     esp, ebp
.text$mn:000099D5                 pop     ebp
.text$mn:000099D6                 retn    8
.text$mn:000099D6 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000099D6
.text$mn:000099D6 ; ---------------------------------------------------------------------------
.text$mn:000099D9                 align 4
.text$mn:000099D9 _text$mn        ends
.text$mn:000099D9
.text$x:000099DC ; ===========================================================================
.text$x:000099DC
.text$x:000099DC ; Segment type: Pure code
.text$x:000099DC ; Segment permissions: Read/Execute
.text$x:000099DC _text$x         segment para public 'CODE' use32
.text$x:000099DC                 assume cs:_text$x
.text$x:000099DC                 ;org 99DCh
.text$x:000099DC ; COMDAT (pick associative to section at 994C)
.text$x:000099DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000099DC
.text$x:000099DC ; =============== S U B R O U T I N E =======================================
.text$x:000099DC
.text$x:000099DC
.text$x:000099DC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000099DC                                         ; DATA XREF: .xdata$x:0000A274o
.text$x:000099DC                 mov     eax, [ebp-10h]
.text$x:000099DF                 and     eax, 1
.text$x:000099E2                 jz      $LN6_0
.text$x:000099E8                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000099EC                 mov     ecx, [ebp+8]
.text$x:000099EF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000099F4 ; ---------------------------------------------------------------------------
.text$x:000099F4
.text$x:000099F4 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000099F4                 retn
.text$x:000099F4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000099F4
.text$x:000099F5
.text$x:000099F5 ; =============== S U B R O U T I N E =======================================
.text$x:000099F5
.text$x:000099F5
.text$x:000099F5 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000099F5                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000099F5
.text$x:000099F5 arg_4           = dword ptr  8
.text$x:000099F5
.text$x:000099F5                 mov     edx, [esp+arg_4]
.text$x:000099F9                 lea     eax, [edx+0Ch]
.text$x:000099FC                 mov     ecx, [edx-0Ch]
.text$x:000099FF                 xor     ecx, eax
.text$x:00009A01                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009A06                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00009A0B                 jmp     ___CxxFrameHandler3
.text$x:00009A0B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00009A0B
.text$x:00009A0B _text$x         ends
.text$x:00009A0B
.text$mn:00009A10 ; ===========================================================================
.text$mn:00009A10
.text$mn:00009A10 ; Segment type: Pure code
.text$mn:00009A10 ; Segment permissions: Read/Execute
.text$mn:00009A10 _text$mn        segment para public 'CODE' use32
.text$mn:00009A10                 assume cs:_text$mn
.text$mn:00009A10                 ;org 9A10h
.text$mn:00009A10 ; COMDAT (pick any)
.text$mn:00009A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009A10
.text$mn:00009A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A10
.text$mn:00009A10 ; Attributes: bp-based frame
.text$mn:00009A10
.text$mn:00009A10 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00009A10                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00009A10 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00009A10                                         ; DATA XREF: .rdata:0000B03Co
.text$mn:00009A10
.text$mn:00009A10 var_1C          = dword ptr -1Ch
.text$mn:00009A10 var_18          = dword ptr -18h
.text$mn:00009A10 Str             = dword ptr -14h
.text$mn:00009A10 var_10          = dword ptr -10h
.text$mn:00009A10 var_C           = dword ptr -0Ch
.text$mn:00009A10 var_4           = dword ptr -4
.text$mn:00009A10 arg_0           = dword ptr  8
.text$mn:00009A10 arg_4           = dword ptr  0Ch
.text$mn:00009A10
.text$mn:00009A10                 push    ebp
.text$mn:00009A11                 mov     ebp, esp
.text$mn:00009A13                 push    0FFFFFFFFh
.text$mn:00009A15                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00009A1A                 mov     eax, large fs:0
.text$mn:00009A20                 push    eax
.text$mn:00009A21                 sub     esp, 10h
.text$mn:00009A24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009A29                 xor     eax, ebp
.text$mn:00009A2B                 push    eax
.text$mn:00009A2C                 lea     eax, [ebp+var_C]
.text$mn:00009A2F                 mov     large fs:0, eax
.text$mn:00009A35                 mov     [ebp+var_1C], ecx
.text$mn:00009A38                 mov     [ebp+var_18], 0
.text$mn:00009A3F                 mov     eax, [ebp+arg_4]
.text$mn:00009A42                 push    eax             ; int
.text$mn:00009A43                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00009A48                 add     esp, 4
.text$mn:00009A4B                 mov     [ebp+var_10], eax
.text$mn:00009A4E                 cmp     [ebp+var_10], 0
.text$mn:00009A52                 jz      short loc_9A5C
.text$mn:00009A54                 mov     ecx, [ebp+var_10]
.text$mn:00009A57                 mov     [ebp+Str], ecx
.text$mn:00009A5A                 jmp     short loc_9A63
.text$mn:00009A5C ; ---------------------------------------------------------------------------
.text$mn:00009A5C
.text$mn:00009A5C loc_9A5C:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00009A5C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00009A63
.text$mn:00009A63 loc_9A63:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00009A63                 mov     edx, [ebp+Str]
.text$mn:00009A66                 push    edx             ; Str
.text$mn:00009A67                 mov     ecx, [ebp+arg_0]
.text$mn:00009A6A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00009A6F                 mov     [ebp+var_4], 0
.text$mn:00009A76                 mov     eax, [ebp+var_18]
.text$mn:00009A79                 or      eax, 1
.text$mn:00009A7C                 mov     [ebp+var_18], eax
.text$mn:00009A7F                 mov     eax, [ebp+arg_0]
.text$mn:00009A82                 mov     ecx, [ebp+var_C]
.text$mn:00009A85                 mov     large fs:0, ecx
.text$mn:00009A8C                 pop     ecx
.text$mn:00009A8D                 mov     esp, ebp
.text$mn:00009A8F                 pop     ebp
.text$mn:00009A90                 retn    8
.text$mn:00009A90 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00009A90
.text$mn:00009A90 ; ---------------------------------------------------------------------------
.text$mn:00009A93                 align 4
.text$mn:00009A93 _text$mn        ends
.text$mn:00009A93
.text$x:00009A94 ; ===========================================================================
.text$x:00009A94
.text$x:00009A94 ; Segment type: Pure code
.text$x:00009A94 ; Segment permissions: Read/Execute
.text$x:00009A94 _text$x         segment para public 'CODE' use32
.text$x:00009A94                 assume cs:_text$x
.text$x:00009A94                 ;org 9A94h
.text$x:00009A94 ; COMDAT (pick associative to section at 9A10)
.text$x:00009A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009A94
.text$x:00009A94 ; =============== S U B R O U T I N E =======================================
.text$x:00009A94
.text$x:00009A94
.text$x:00009A94 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00009A94                                         ; DATA XREF: .xdata$x:0000A2F8o
.text$x:00009A94                 mov     eax, [ebp-18h]
.text$x:00009A97                 and     eax, 1
.text$x:00009A9A                 jz      $LN6_1
.text$x:00009AA0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00009AA4                 mov     ecx, [ebp+8]
.text$x:00009AA7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00009AAC ; ---------------------------------------------------------------------------
.text$x:00009AAC
.text$x:00009AAC $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00009AAC                 retn
.text$x:00009AAC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00009AAC
.text$x:00009AAD
.text$x:00009AAD ; =============== S U B R O U T I N E =======================================
.text$x:00009AAD
.text$x:00009AAD
.text$x:00009AAD __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00009AAD                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00009AAD
.text$x:00009AAD arg_4           = dword ptr  8
.text$x:00009AAD
.text$x:00009AAD                 mov     edx, [esp+arg_4]
.text$x:00009AB1                 lea     eax, [edx+0Ch]
.text$x:00009AB4                 mov     ecx, [edx-14h]
.text$x:00009AB7                 xor     ecx, eax
.text$x:00009AB9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009ABE                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00009AC3                 jmp     ___CxxFrameHandler3
.text$x:00009AC3 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00009AC3
.text$x:00009AC3 _text$x         ends
.text$x:00009AC3
.text$mn:00009AC8 ; ===========================================================================
.text$mn:00009AC8
.text$mn:00009AC8 ; Segment type: Pure code
.text$mn:00009AC8 ; Segment permissions: Read/Execute
.text$mn:00009AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00009AC8                 assume cs:_text$mn
.text$mn:00009AC8                 ;org 9AC8h
.text$mn:00009AC8 ; COMDAT (pick any)
.text$mn:00009AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009AC8
.text$mn:00009AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AC8
.text$mn:00009AC8 ; Attributes: bp-based frame
.text$mn:00009AC8
.text$mn:00009AC8 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00009AC8                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00009AC8 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00009AC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00009AC8
.text$mn:00009AC8 var_4           = dword ptr -4
.text$mn:00009AC8 Dst             = dword ptr  8
.text$mn:00009AC8 Src             = dword ptr  0Ch
.text$mn:00009AC8 Size            = dword ptr  10h
.text$mn:00009AC8
.text$mn:00009AC8                 push    ebp
.text$mn:00009AC9                 mov     ebp, esp
.text$mn:00009ACB                 push    ecx
.text$mn:00009ACC                 cmp     [ebp+Size], 0
.text$mn:00009AD0                 jnz     short loc_9ADA
.text$mn:00009AD2                 mov     eax, [ebp+Dst]
.text$mn:00009AD5                 mov     [ebp+var_4], eax
.text$mn:00009AD8                 jmp     short loc_9AF1
.text$mn:00009ADA ; ---------------------------------------------------------------------------
.text$mn:00009ADA
.text$mn:00009ADA loc_9ADA:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00009ADA                 mov     ecx, [ebp+Size]
.text$mn:00009ADD                 push    ecx             ; Size
.text$mn:00009ADE                 mov     edx, [ebp+Src]
.text$mn:00009AE1                 push    edx             ; Src
.text$mn:00009AE2                 mov     eax, [ebp+Dst]
.text$mn:00009AE5                 push    eax             ; Dst
.text$mn:00009AE6                 call    _memmove
.text$mn:00009AEB                 add     esp, 0Ch
.text$mn:00009AEE                 mov     [ebp+var_4], eax
.text$mn:00009AF1
.text$mn:00009AF1 loc_9AF1:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00009AF1                 mov     eax, [ebp+var_4]
.text$mn:00009AF4                 mov     esp, ebp
.text$mn:00009AF6                 pop     ebp
.text$mn:00009AF7                 retn
.text$mn:00009AF7 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00009AF7
.text$mn:00009AF7 _text$mn        ends
.text$mn:00009AF7
.text$mn:00009AF8 ; ===========================================================================
.text$mn:00009AF8
.text$mn:00009AF8 ; Segment type: Pure code
.text$mn:00009AF8 ; Segment permissions: Read/Execute
.text$mn:00009AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00009AF8                 assume cs:_text$mn
.text$mn:00009AF8                 ;org 9AF8h
.text$mn:00009AF8 ; COMDAT (pick any)
.text$mn:00009AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009AF8
.text$mn:00009AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AF8
.text$mn:00009AF8 ; Attributes: bp-based frame
.text$mn:00009AF8
.text$mn:00009AF8 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00009AF8                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00009AF8 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00009AF8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:00009AF8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::insert(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+BBp ...
.text$mn:00009AF8
.text$mn:00009AF8 var_4           = dword ptr -4
.text$mn:00009AF8 Dst             = dword ptr  8
.text$mn:00009AF8 Src             = dword ptr  0Ch
.text$mn:00009AF8 arg_8           = dword ptr  10h
.text$mn:00009AF8
.text$mn:00009AF8                 push    ebp
.text$mn:00009AF9                 mov     ebp, esp
.text$mn:00009AFB                 push    ecx
.text$mn:00009AFC                 cmp     [ebp+arg_8], 0
.text$mn:00009B00                 jnz     short loc_9B0A
.text$mn:00009B02                 mov     eax, [ebp+Dst]
.text$mn:00009B05                 mov     [ebp+var_4], eax
.text$mn:00009B08                 jmp     short loc_9B21
.text$mn:00009B0A ; ---------------------------------------------------------------------------
.text$mn:00009B0A
.text$mn:00009B0A loc_9B0A:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00009B0A                 mov     ecx, [ebp+arg_8]
.text$mn:00009B0D                 push    ecx             ; int
.text$mn:00009B0E                 mov     edx, [ebp+Src]
.text$mn:00009B11                 push    edx             ; Src
.text$mn:00009B12                 mov     eax, [ebp+Dst]
.text$mn:00009B15                 push    eax             ; Dst
.text$mn:00009B16                 call    _wmemmove
.text$mn:00009B1B                 add     esp, 0Ch
.text$mn:00009B1E                 mov     [ebp+var_4], eax
.text$mn:00009B21
.text$mn:00009B21 loc_9B21:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00009B21                 mov     eax, [ebp+var_4]
.text$mn:00009B24                 mov     esp, ebp
.text$mn:00009B26                 pop     ebp
.text$mn:00009B27                 retn
.text$mn:00009B27 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00009B27
.text$mn:00009B27 _text$mn        ends
.text$mn:00009B27
.text$mn:00009B28 ; ===========================================================================
.text$mn:00009B28
.text$mn:00009B28 ; Segment type: Pure code
.text$mn:00009B28 ; Segment permissions: Read/Execute
.text$mn:00009B28 _text$mn        segment para public 'CODE' use32
.text$mn:00009B28                 assume cs:_text$mn
.text$mn:00009B28                 ;org 9B28h
.text$mn:00009B28 ; COMDAT (pick any)
.text$mn:00009B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B28
.text$mn:00009B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B28
.text$mn:00009B28 ; Attributes: bp-based frame
.text$mn:00009B28
.text$mn:00009B28 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00009B28                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00009B28 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00009B28                                         ; DATA XREF: .rdata:0000AFC4o
.text$mn:00009B28
.text$mn:00009B28 var_4           = dword ptr -4
.text$mn:00009B28
.text$mn:00009B28                 push    ebp
.text$mn:00009B29                 mov     ebp, esp
.text$mn:00009B2B                 push    ecx
.text$mn:00009B2C                 mov     [ebp+var_4], ecx
.text$mn:00009B2F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00009B34                 mov     esp, ebp
.text$mn:00009B36                 pop     ebp
.text$mn:00009B37                 retn
.text$mn:00009B37 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00009B37
.text$mn:00009B37 _text$mn        ends
.text$mn:00009B37
.text$mn:00009B38 ; ===========================================================================
.text$mn:00009B38
.text$mn:00009B38 ; Segment type: Pure code
.text$mn:00009B38 ; Segment permissions: Read/Execute
.text$mn:00009B38 _text$mn        segment para public 'CODE' use32
.text$mn:00009B38                 assume cs:_text$mn
.text$mn:00009B38                 ;org 9B38h
.text$mn:00009B38 ; COMDAT (pick any)
.text$mn:00009B38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B38
.text$mn:00009B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B38
.text$mn:00009B38 ; Attributes: bp-based frame
.text$mn:00009B38
.text$mn:00009B38 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00009B38                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00009B38 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00009B38                                         ; DATA XREF: .rdata:0000AFF8o
.text$mn:00009B38
.text$mn:00009B38 var_4           = dword ptr -4
.text$mn:00009B38
.text$mn:00009B38                 push    ebp
.text$mn:00009B39                 mov     ebp, esp
.text$mn:00009B3B                 push    ecx
.text$mn:00009B3C                 mov     [ebp+var_4], ecx
.text$mn:00009B3F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00009B44                 mov     esp, ebp
.text$mn:00009B46                 pop     ebp
.text$mn:00009B47                 retn
.text$mn:00009B47 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00009B47
.text$mn:00009B47 _text$mn        ends
.text$mn:00009B47
.text$mn:00009B48 ; ===========================================================================
.text$mn:00009B48
.text$mn:00009B48 ; Segment type: Pure code
.text$mn:00009B48 ; Segment permissions: Read/Execute
.text$mn:00009B48 _text$mn        segment para public 'CODE' use32
.text$mn:00009B48                 assume cs:_text$mn
.text$mn:00009B48                 ;org 9B48h
.text$mn:00009B48 ; COMDAT (pick any)
.text$mn:00009B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B48
.text$mn:00009B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B48
.text$mn:00009B48 ; Attributes: bp-based frame
.text$mn:00009B48
.text$mn:00009B48 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00009B48                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00009B48 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00009B48                                         ; DATA XREF: .rdata:0000B038o
.text$mn:00009B48
.text$mn:00009B48 var_4           = dword ptr -4
.text$mn:00009B48
.text$mn:00009B48                 push    ebp
.text$mn:00009B49                 mov     ebp, esp
.text$mn:00009B4B                 push    ecx
.text$mn:00009B4C                 mov     [ebp+var_4], ecx
.text$mn:00009B4F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00009B54                 mov     esp, ebp
.text$mn:00009B56                 pop     ebp
.text$mn:00009B57                 retn
.text$mn:00009B57 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00009B57
.text$mn:00009B57 _text$mn        ends
.text$mn:00009B57
.text$mn:00009B58 ; ===========================================================================
.text$mn:00009B58
.text$mn:00009B58 ; Segment type: Pure code
.text$mn:00009B58 ; Segment permissions: Read/Execute
.text$mn:00009B58 _text$mn        segment para public 'CODE' use32
.text$mn:00009B58                 assume cs:_text$mn
.text$mn:00009B58                 ;org 9B58h
.text$mn:00009B58 ; COMDAT (pick any)
.text$mn:00009B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009B58
.text$mn:00009B58 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B58
.text$mn:00009B58 ; Attributes: bp-based frame
.text$mn:00009B58
.text$mn:00009B58 ; public: void __thiscall std::vector<int, class std::allocator<int>>::push_back(int const &)
.text$mn:00009B58                 public ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
.text$mn:00009B58 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z proc near
.text$mn:00009B58                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+9B8p
.text$mn:00009B58
.text$mn:00009B58 var_C           = dword ptr -0Ch
.text$mn:00009B58 var_8           = dword ptr -8
.text$mn:00009B58 var_2           = byte ptr -2
.text$mn:00009B58 var_1           = byte ptr -1
.text$mn:00009B58 arg_0           = dword ptr  8
.text$mn:00009B58
.text$mn:00009B58                 push    ebp
.text$mn:00009B59                 mov     ebp, esp
.text$mn:00009B5B                 sub     esp, 0Ch
.text$mn:00009B5E                 mov     [ebp+var_8], ecx
.text$mn:00009B61                 mov     eax, [ebp+arg_0]
.text$mn:00009B64                 push    eax
.text$mn:00009B65                 call    ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const>(int const &)
.text$mn:00009B6A                 add     esp, 4
.text$mn:00009B6D                 push    eax
.text$mn:00009B6E                 mov     ecx, [ebp+var_8]
.text$mn:00009B71                 call    ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int>>::_Inside(int const *)
.text$mn:00009B76                 movzx   ecx, al
.text$mn:00009B79                 test    ecx, ecx
.text$mn:00009B7B                 jz      short loc_9BFB
.text$mn:00009B7D                 mov     edx, [ebp+arg_0]
.text$mn:00009B80                 push    edx
.text$mn:00009B81                 call    ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const>(int const &)
.text$mn:00009B86                 add     esp, 4
.text$mn:00009B89                 mov     ecx, [ebp+var_8]
.text$mn:00009B8C                 sub     eax, [ecx+4]
.text$mn:00009B8F                 sar     eax, 2
.text$mn:00009B92                 mov     [ebp+var_C], eax
.text$mn:00009B95                 mov     edx, [ebp+var_8]
.text$mn:00009B98                 mov     eax, [ebp+var_8]
.text$mn:00009B9B                 mov     ecx, [edx+8]
.text$mn:00009B9E                 cmp     ecx, [eax+0Ch]
.text$mn:00009BA1                 jnz     short loc_9BAD
.text$mn:00009BA3                 push    1
.text$mn:00009BA5                 mov     ecx, [ebp+var_8]
.text$mn:00009BA8                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:00009BAD
.text$mn:00009BAD loc_9BAD:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+49j
.text$mn:00009BAD                 mov     edx, [ebp+var_8]
.text$mn:00009BB0                 mov     eax, [edx+8]
.text$mn:00009BB3                 push    eax
.text$mn:00009BB4                 mov     ecx, [ebp+var_8]
.text$mn:00009BB7                 mov     edx, [ecx+8]
.text$mn:00009BBA                 push    edx
.text$mn:00009BBB                 mov     ecx, [ebp+var_8]
.text$mn:00009BBE                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:00009BC3                 mov     eax, [ebp+var_8]
.text$mn:00009BC6                 mov     ecx, [eax+4]
.text$mn:00009BC9                 mov     edx, [ebp+var_C]
.text$mn:00009BCC                 lea     eax, [ecx+edx*4]
.text$mn:00009BCF                 push    eax             ; int
.text$mn:00009BD0                 mov     ecx, [ebp+var_8]
.text$mn:00009BD3                 mov     edx, [ecx+8]
.text$mn:00009BD6                 push    edx             ; void *
.text$mn:00009BD7                 lea     eax, [ebp+var_1]
.text$mn:00009BDA                 push    eax
.text$mn:00009BDB                 mov     ecx, [ebp+var_8]
.text$mn:00009BDE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00009BE3                 mov     ecx, eax
.text$mn:00009BE5                 call    ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z ; std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)
.text$mn:00009BEA                 mov     ecx, [ebp+var_8]
.text$mn:00009BED                 mov     edx, [ecx+8]
.text$mn:00009BF0                 add     edx, 4
.text$mn:00009BF3                 mov     eax, [ebp+var_8]
.text$mn:00009BF6                 mov     [eax+8], edx
.text$mn:00009BF9                 jmp     short loc_9C56
.text$mn:00009BFB ; ---------------------------------------------------------------------------
.text$mn:00009BFB
.text$mn:00009BFB loc_9BFB:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+23j
.text$mn:00009BFB                 mov     ecx, [ebp+var_8]
.text$mn:00009BFE                 mov     edx, [ebp+var_8]
.text$mn:00009C01                 mov     eax, [ecx+8]
.text$mn:00009C04                 cmp     eax, [edx+0Ch]
.text$mn:00009C07                 jnz     short loc_9C13
.text$mn:00009C09                 push    1
.text$mn:00009C0B                 mov     ecx, [ebp+var_8]
.text$mn:00009C0E                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:00009C13
.text$mn:00009C13 loc_9C13:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+AFj
.text$mn:00009C13                 mov     ecx, [ebp+var_8]
.text$mn:00009C16                 mov     edx, [ecx+8]
.text$mn:00009C19                 push    edx
.text$mn:00009C1A                 mov     eax, [ebp+var_8]
.text$mn:00009C1D                 mov     ecx, [eax+8]
.text$mn:00009C20                 push    ecx
.text$mn:00009C21                 mov     ecx, [ebp+var_8]
.text$mn:00009C24                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:00009C29                 mov     edx, [ebp+arg_0]
.text$mn:00009C2C                 push    edx             ; int
.text$mn:00009C2D                 mov     eax, [ebp+var_8]
.text$mn:00009C30                 mov     ecx, [eax+8]
.text$mn:00009C33                 push    ecx             ; void *
.text$mn:00009C34                 lea     edx, [ebp+var_2]
.text$mn:00009C37                 push    edx
.text$mn:00009C38                 mov     ecx, [ebp+var_8]
.text$mn:00009C3B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00009C40                 mov     ecx, eax
.text$mn:00009C42                 call    ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z ; std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)
.text$mn:00009C47                 mov     eax, [ebp+var_8]
.text$mn:00009C4A                 mov     ecx, [eax+8]
.text$mn:00009C4D                 add     ecx, 4
.text$mn:00009C50                 mov     edx, [ebp+var_8]
.text$mn:00009C53                 mov     [edx+8], ecx
.text$mn:00009C56
.text$mn:00009C56 loc_9C56:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+A1j
.text$mn:00009C56                 mov     esp, ebp
.text$mn:00009C58                 pop     ebp
.text$mn:00009C59                 retn    4
.text$mn:00009C59 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z endp
.text$mn:00009C59
.text$mn:00009C59 _text$mn        ends
.text$mn:00009C59
.text$mn:00009C5C ; ===========================================================================
.text$mn:00009C5C
.text$mn:00009C5C ; Segment type: Pure code
.text$mn:00009C5C ; Segment permissions: Read/Execute
.text$mn:00009C5C _text$mn        segment para public 'CODE' use32
.text$mn:00009C5C                 assume cs:_text$mn
.text$mn:00009C5C                 ;org 9C5Ch
.text$mn:00009C5C ; COMDAT (pick any)
.text$mn:00009C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009C5C
.text$mn:00009C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00009C5C
.text$mn:00009C5C ; Attributes: bp-based frame
.text$mn:00009C5C
.text$mn:00009C5C ; public: class std::reverse_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>> __thiscall std::vector<int, class std::allocator<int>>::rbegin(void)
.text$mn:00009C5C                 public ?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ
.text$mn:00009C5C ?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ proc near
.text$mn:00009C5C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+AE4p
.text$mn:00009C5C
.text$mn:00009C5C var_34          = byte ptr -34h
.text$mn:00009C5C var_28          = dword ptr -28h
.text$mn:00009C5C var_24          = dword ptr -24h
.text$mn:00009C5C var_20          = dword ptr -20h
.text$mn:00009C5C var_1C          = dword ptr -1Ch
.text$mn:00009C5C var_18          = dword ptr -18h
.text$mn:00009C5C var_14          = dword ptr -14h
.text$mn:00009C5C var_10          = dword ptr -10h
.text$mn:00009C5C var_C           = dword ptr -0Ch
.text$mn:00009C5C var_4           = dword ptr -4
.text$mn:00009C5C arg_0           = dword ptr  8
.text$mn:00009C5C
.text$mn:00009C5C                 push    ebp
.text$mn:00009C5D                 mov     ebp, esp
.text$mn:00009C5F                 push    0FFFFFFFFh
.text$mn:00009C61                 push    offset __ehhandler$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ
.text$mn:00009C66                 mov     eax, large fs:0
.text$mn:00009C6C                 push    eax
.text$mn:00009C6D                 sub     esp, 28h
.text$mn:00009C70                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009C75                 xor     eax, ebp
.text$mn:00009C77                 push    eax
.text$mn:00009C78                 lea     eax, [ebp+var_C]
.text$mn:00009C7B                 mov     large fs:0, eax
.text$mn:00009C81                 mov     [ebp+var_14], ecx
.text$mn:00009C84                 mov     [ebp+var_10], 0
.text$mn:00009C8B                 sub     esp, 0Ch
.text$mn:00009C8E                 mov     eax, esp
.text$mn:00009C90                 mov     [ebp+var_24], esp
.text$mn:00009C93                 push    eax
.text$mn:00009C94                 mov     ecx, [ebp+var_14]
.text$mn:00009C97                 call    ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::end(void)
.text$mn:00009C9C                 mov     [ebp+var_18], eax
.text$mn:00009C9F                 mov     ecx, [ebp+var_18]
.text$mn:00009CA2                 mov     [ebp+var_28], ecx
.text$mn:00009CA5                 mov     [ebp+var_4], 1
.text$mn:00009CAC                 mov     byte ptr [ebp+var_4], 0
.text$mn:00009CB0                 lea     ecx, [ebp+var_34]
.text$mn:00009CB3                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00009CB8                 mov     [ebp+var_1C], eax
.text$mn:00009CBB                 mov     edx, [ebp+var_1C]
.text$mn:00009CBE                 mov     [ebp+var_20], edx
.text$mn:00009CC1                 mov     [ebp+var_4], 2
.text$mn:00009CC8                 mov     eax, [ebp+var_20]
.text$mn:00009CCB                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00009CCC                 mov     ecx, [ebp+arg_0]
.text$mn:00009CCF                 call    ??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>> const &)
.text$mn:00009CD4                 mov     ecx, [ebp+var_10]
.text$mn:00009CD7                 or      ecx, 1
.text$mn:00009CDA                 mov     [ebp+var_10], ecx
.text$mn:00009CDD                 mov     byte ptr [ebp+var_4], 0
.text$mn:00009CE1                 lea     ecx, [ebp+var_34]
.text$mn:00009CE4                 call    ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(void)
.text$mn:00009CE9                 mov     eax, [ebp+arg_0]
.text$mn:00009CEC                 mov     ecx, [ebp+var_C]
.text$mn:00009CEF                 mov     large fs:0, ecx
.text$mn:00009CF6                 pop     ecx
.text$mn:00009CF7                 mov     esp, ebp
.text$mn:00009CF9                 pop     ebp
.text$mn:00009CFA                 retn    4
.text$mn:00009CFA ?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ endp
.text$mn:00009CFA
.text$mn:00009CFA ; ---------------------------------------------------------------------------
.text$mn:00009CFD                 align 10h
.text$mn:00009CFD _text$mn        ends
.text$mn:00009CFD
.text$x:00009D00 ; ===========================================================================
.text$x:00009D00
.text$x:00009D00 ; Segment type: Pure code
.text$x:00009D00 ; Segment permissions: Read/Execute
.text$x:00009D00 _text$x         segment para public 'CODE' use32
.text$x:00009D00                 assume cs:_text$x
.text$x:00009D00                 ;org 9D00h
.text$x:00009D00 ; COMDAT (pick associative to section at 9C5C)
.text$x:00009D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009D00
.text$x:00009D00 ; =============== S U B R O U T I N E =======================================
.text$x:00009D00
.text$x:00009D00
.text$x:00009D00 __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00009D00                                         ; DATA XREF: .xdata$x:0000A64Co
.text$x:00009D00                 mov     ecx, [ebp-24h]
.text$x:00009D03                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00009D03 __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00009D03
.text$x:00009D08
.text$x:00009D08 ; =============== S U B R O U T I N E =======================================
.text$x:00009D08
.text$x:00009D08
.text$x:00009D08 __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$1 proc near
.text$x:00009D08                                         ; DATA XREF: .xdata$x:0000A654o
.text$x:00009D08                 lea     ecx, [ebp-34h]
.text$x:00009D0B                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(void)
.text$x:00009D0B __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$1 endp
.text$x:00009D0B
.text$x:00009D10
.text$x:00009D10 ; =============== S U B R O U T I N E =======================================
.text$x:00009D10
.text$x:00009D10
.text$x:00009D10 __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$2 proc near
.text$x:00009D10                                         ; DATA XREF: .xdata$x:0000A644o
.text$x:00009D10                 mov     eax, [ebp-10h]
.text$x:00009D13                 and     eax, 1
.text$x:00009D16                 jz      $LN6_2
.text$x:00009D1C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00009D20                 mov     ecx, [ebp+8]
.text$x:00009D23                 jmp     ??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ ; std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>::~reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>(void)
.text$x:00009D28 ; ---------------------------------------------------------------------------
.text$x:00009D28
.text$x:00009D28 $LN6_2:                                 ; CODE XREF: __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$2+6j
.text$x:00009D28                 retn
.text$x:00009D28 __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$2 endp
.text$x:00009D28
.text$x:00009D29
.text$x:00009D29 ; =============== S U B R O U T I N E =======================================
.text$x:00009D29
.text$x:00009D29
.text$x:00009D29 __ehhandler$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ proc near
.text$x:00009D29                                         ; DATA XREF: std::vector<int,std::allocator<int>>::rbegin(void)+5o
.text$x:00009D29
.text$x:00009D29 arg_4           = dword ptr  8
.text$x:00009D29
.text$x:00009D29                 mov     edx, [esp+arg_4]
.text$x:00009D2D                 lea     eax, [edx+0Ch]
.text$x:00009D30                 mov     ecx, [edx-2Ch]
.text$x:00009D33                 xor     ecx, eax
.text$x:00009D35                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009D3A                 mov     eax, offset __ehfuncinfo$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ
.text$x:00009D3F                 jmp     ___CxxFrameHandler3
.text$x:00009D3F __ehhandler$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ endp
.text$x:00009D3F
.text$x:00009D3F _text$x         ends
.text$x:00009D3F
.text$mn:00009D44 ; ===========================================================================
.text$mn:00009D44
.text$mn:00009D44 ; Segment type: Pure code
.text$mn:00009D44 ; Segment permissions: Read/Execute
.text$mn:00009D44 _text$mn        segment para public 'CODE' use32
.text$mn:00009D44                 assume cs:_text$mn
.text$mn:00009D44                 ;org 9D44h
.text$mn:00009D44 ; COMDAT (pick any)
.text$mn:00009D44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D44
.text$mn:00009D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D44
.text$mn:00009D44 ; Attributes: bp-based frame
.text$mn:00009D44
.text$mn:00009D44 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00009D44                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00009D44 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00009D44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00009D44                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00009D44
.text$mn:00009D44 var_4           = dword ptr -4
.text$mn:00009D44
.text$mn:00009D44                 push    ebp
.text$mn:00009D45                 mov     ebp, esp
.text$mn:00009D47                 push    ecx
.text$mn:00009D48                 mov     [ebp+var_4], ecx
.text$mn:00009D4B                 mov     eax, [ebp+var_4]
.text$mn:00009D4E                 mov     eax, [eax+14h]
.text$mn:00009D51                 mov     esp, ebp
.text$mn:00009D53                 pop     ebp
.text$mn:00009D54                 retn
.text$mn:00009D54 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00009D54
.text$mn:00009D54 ; ---------------------------------------------------------------------------
.text$mn:00009D55                 align 4
.text$mn:00009D55 _text$mn        ends
.text$mn:00009D55
.text$mn:00009D58 ; ===========================================================================
.text$mn:00009D58
.text$mn:00009D58 ; Segment type: Pure code
.text$mn:00009D58 ; Segment permissions: Read/Execute
.text$mn:00009D58 _text$mn        segment para public 'CODE' use32
.text$mn:00009D58                 assume cs:_text$mn
.text$mn:00009D58                 ;org 9D58h
.text$mn:00009D58 ; COMDAT (pick any)
.text$mn:00009D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D58
.text$mn:00009D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D58
.text$mn:00009D58 ; Attributes: bp-based frame
.text$mn:00009D58
.text$mn:00009D58 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00009D58                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00009D58 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00009D58                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00009D58                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:00009D58
.text$mn:00009D58 var_4           = dword ptr -4
.text$mn:00009D58
.text$mn:00009D58                 push    ebp
.text$mn:00009D59                 mov     ebp, esp
.text$mn:00009D5B                 push    ecx
.text$mn:00009D5C                 mov     [ebp+var_4], ecx
.text$mn:00009D5F                 mov     eax, [ebp+var_4]
.text$mn:00009D62                 mov     eax, [eax+14h]
.text$mn:00009D65                 mov     esp, ebp
.text$mn:00009D67                 pop     ebp
.text$mn:00009D68                 retn
.text$mn:00009D68 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00009D68
.text$mn:00009D68 ; ---------------------------------------------------------------------------
.text$mn:00009D69                 align 4
.text$mn:00009D69 _text$mn        ends
.text$mn:00009D69
.text$mn:00009D6C ; ===========================================================================
.text$mn:00009D6C
.text$mn:00009D6C ; Segment type: Pure code
.text$mn:00009D6C ; Segment permissions: Read/Execute
.text$mn:00009D6C _text$mn        segment para public 'CODE' use32
.text$mn:00009D6C                 assume cs:_text$mn
.text$mn:00009D6C                 ;org 9D6Ch
.text$mn:00009D6C ; COMDAT (pick any)
.text$mn:00009D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D6C
.text$mn:00009D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00009D6C
.text$mn:00009D6C ; Attributes: bp-based frame
.text$mn:00009D6C
.text$mn:00009D6C ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::size(void)const
.text$mn:00009D6C                 public ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00009D6C ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00009D6C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+975p
.text$mn:00009D6C                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+9C3p ...
.text$mn:00009D6C
.text$mn:00009D6C var_4           = dword ptr -4
.text$mn:00009D6C
.text$mn:00009D6C                 push    ebp
.text$mn:00009D6D                 mov     ebp, esp
.text$mn:00009D6F                 push    ecx
.text$mn:00009D70                 mov     [ebp+var_4], ecx
.text$mn:00009D73                 mov     eax, [ebp+var_4]
.text$mn:00009D76                 mov     ecx, [ebp+var_4]
.text$mn:00009D79                 mov     eax, [eax+8]
.text$mn:00009D7C                 sub     eax, [ecx+4]
.text$mn:00009D7F                 sar     eax, 2
.text$mn:00009D82                 mov     esp, ebp
.text$mn:00009D84                 pop     ebp
.text$mn:00009D85                 retn
.text$mn:00009D85 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00009D85
.text$mn:00009D85 ; ---------------------------------------------------------------------------
.text$mn:00009D86                 align 4
.text$mn:00009D86 _text$mn        ends
.text$mn:00009D86
.text$mn:00009D88 ; ===========================================================================
.text$mn:00009D88
.text$mn:00009D88 ; Segment type: Pure code
.text$mn:00009D88 ; Segment permissions: Read/Execute
.text$mn:00009D88 _text$mn        segment para public 'CODE' use32
.text$mn:00009D88                 assume cs:_text$mn
.text$mn:00009D88                 ;org 9D88h
.text$mn:00009D88 ; COMDAT (pick any)
.text$mn:00009D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D88
.text$mn:00009D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D88
.text$mn:00009D88 ; Attributes: bp-based frame
.text$mn:00009D88
.text$mn:00009D88 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00009D88                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00009D88 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00009D88                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_900Cp
.text$mn:00009D88                 push    ebp
.text$mn:00009D89                 mov     ebp, esp
.text$mn:00009D8B                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00009D90                 pop     ebp
.text$mn:00009D91                 retn
.text$mn:00009D91 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00009D91
.text$mn:00009D91 ; ---------------------------------------------------------------------------
.text$mn:00009D92                 align 4
.text$mn:00009D92 _text$mn        ends
.text$mn:00009D92
.text$mn:00009D94 ; ===========================================================================
.text$mn:00009D94
.text$mn:00009D94 ; Segment type: Pure code
.text$mn:00009D94 ; Segment permissions: Read/Execute
.text$mn:00009D94 _text$mn        segment para public 'CODE' use32
.text$mn:00009D94                 assume cs:_text$mn
.text$mn:00009D94                 ;org 9D94h
.text$mn:00009D94 ; COMDAT (pick any)
.text$mn:00009D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009D94
.text$mn:00009D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D94
.text$mn:00009D94 ; Attributes: bp-based frame
.text$mn:00009D94
.text$mn:00009D94 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00009D94                 public ?value@error_code@std@@QBEHXZ
.text$mn:00009D94 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00009D94
.text$mn:00009D94 var_4           = dword ptr -4
.text$mn:00009D94
.text$mn:00009D94                 push    ebp
.text$mn:00009D95                 mov     ebp, esp
.text$mn:00009D97                 push    ecx
.text$mn:00009D98                 mov     [ebp+var_4], ecx
.text$mn:00009D9B                 mov     eax, [ebp+var_4]
.text$mn:00009D9E                 mov     eax, [eax]
.text$mn:00009DA0                 mov     esp, ebp
.text$mn:00009DA2                 pop     ebp
.text$mn:00009DA3                 retn
.text$mn:00009DA3 ?value@error_code@std@@QBEHXZ endp
.text$mn:00009DA3
.text$mn:00009DA3 _text$mn        ends
.text$mn:00009DA3
.text$mn:00009DA4 ; ===========================================================================
.text$mn:00009DA4
.text$mn:00009DA4 ; Segment type: Pure code
.text$mn:00009DA4 ; Segment permissions: Read/Execute
.text$mn:00009DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00009DA4                 assume cs:_text$mn
.text$mn:00009DA4                 ;org 9DA4h
.text$mn:00009DA4 ; COMDAT (pick any)
.text$mn:00009DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DA4
.text$mn:00009DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DA4
.text$mn:00009DA4 ; Attributes: bp-based frame
.text$mn:00009DA4
.text$mn:00009DA4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00009DA4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00009DA4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00009DA4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00009DA4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00009DA4
.text$mn:00009DA4 var_4           = dword ptr -4
.text$mn:00009DA4
.text$mn:00009DA4                 push    ebp
.text$mn:00009DA5                 mov     ebp, esp
.text$mn:00009DA7                 push    ecx
.text$mn:00009DA8                 mov     [ebp+var_4], ecx
.text$mn:00009DAB                 mov     eax, [ebp+var_4]
.text$mn:00009DAE                 mov     eax, [eax]
.text$mn:00009DB0                 mov     esp, ebp
.text$mn:00009DB2                 pop     ebp
.text$mn:00009DB3                 retn
.text$mn:00009DB3 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00009DB3
.text$mn:00009DB3 _text$mn        ends
.text$mn:00009DB3
.text$mn:00009DB4 ; ===========================================================================
.text$mn:00009DB4
.text$mn:00009DB4 ; Segment type: Pure code
.text$mn:00009DB4 ; Segment permissions: Read/Execute
.text$mn:00009DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00009DB4                 assume cs:_text$mn
.text$mn:00009DB4                 ;org 9DB4h
.text$mn:00009DB4 ; COMDAT (pick any)
.text$mn:00009DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DB4
.text$mn:00009DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DB4
.text$mn:00009DB4 ; Attributes: bp-based frame
.text$mn:00009DB4
.text$mn:00009DB4                 public _hypot
.text$mn:00009DB4 _hypot          proc near
.text$mn:00009DB4
.text$mn:00009DB4 var_10          = qword ptr -10h
.text$mn:00009DB4 var_8           = qword ptr -8
.text$mn:00009DB4 arg_0           = qword ptr  8
.text$mn:00009DB4 arg_8           = qword ptr  10h
.text$mn:00009DB4
.text$mn:00009DB4                 push    ebp
.text$mn:00009DB5                 mov     ebp, esp
.text$mn:00009DB7                 sub     esp, 8
.text$mn:00009DBA                 movsd   xmm0, [ebp+arg_8]
.text$mn:00009DBF                 movsd   [esp+8+var_8], xmm0
.text$mn:00009DC4                 sub     esp, 8
.text$mn:00009DC7                 movsd   xmm0, [ebp+arg_0]
.text$mn:00009DCC                 movsd   [esp+10h+var_10], xmm0
.text$mn:00009DD1                 call    __hypot
.text$mn:00009DD6                 add     esp, 10h
.text$mn:00009DD9                 pop     ebp
.text$mn:00009DDA                 retn
.text$mn:00009DDA _hypot          endp
.text$mn:00009DDA
.text$mn:00009DDA ; ---------------------------------------------------------------------------
.text$mn:00009DDB                 align 4
.text$mn:00009DDB _text$mn        ends
.text$mn:00009DDB
.text$mn:00009DDC ; ===========================================================================
.text$mn:00009DDC
.text$mn:00009DDC ; Segment type: Pure code
.text$mn:00009DDC ; Segment permissions: Read/Execute
.text$mn:00009DDC _text$mn        segment para public 'CODE' use32
.text$mn:00009DDC                 assume cs:_text$mn
.text$mn:00009DDC                 ;org 9DDCh
.text$mn:00009DDC ; COMDAT (pick any)
.text$mn:00009DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DDC
.text$mn:00009DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00009DDC
.text$mn:00009DDC ; Attributes: bp-based frame
.text$mn:00009DDC
.text$mn:00009DDC ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00009DDC                 public _wmemcpy
.text$mn:00009DDC _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00009DDC
.text$mn:00009DDC Dst             = dword ptr  8
.text$mn:00009DDC Src             = dword ptr  0Ch
.text$mn:00009DDC arg_8           = dword ptr  10h
.text$mn:00009DDC
.text$mn:00009DDC                 push    ebp
.text$mn:00009DDD                 mov     ebp, esp
.text$mn:00009DDF                 mov     eax, [ebp+arg_8]
.text$mn:00009DE2                 shl     eax, 1
.text$mn:00009DE4                 push    eax             ; Size
.text$mn:00009DE5                 mov     ecx, [ebp+Src]
.text$mn:00009DE8                 push    ecx             ; Src
.text$mn:00009DE9                 mov     edx, [ebp+Dst]
.text$mn:00009DEC                 push    edx             ; Dst
.text$mn:00009DED                 call    _memcpy
.text$mn:00009DF2                 add     esp, 0Ch
.text$mn:00009DF5                 pop     ebp
.text$mn:00009DF6                 retn
.text$mn:00009DF6 _wmemcpy        endp
.text$mn:00009DF6
.text$mn:00009DF6 ; ---------------------------------------------------------------------------
.text$mn:00009DF7                 align 4
.text$mn:00009DF7 _text$mn        ends
.text$mn:00009DF7
.text$mn:00009DF8 ; ===========================================================================
.text$mn:00009DF8
.text$mn:00009DF8 ; Segment type: Pure code
.text$mn:00009DF8 ; Segment permissions: Read/Execute
.text$mn:00009DF8 _text$mn        segment para public 'CODE' use32
.text$mn:00009DF8                 assume cs:_text$mn
.text$mn:00009DF8                 ;org 9DF8h
.text$mn:00009DF8 ; COMDAT (pick any)
.text$mn:00009DF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009DF8
.text$mn:00009DF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DF8
.text$mn:00009DF8 ; Attributes: bp-based frame
.text$mn:00009DF8
.text$mn:00009DF8 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00009DF8                 public _wmemmove
.text$mn:00009DF8 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00009DF8
.text$mn:00009DF8 Dst             = dword ptr  8
.text$mn:00009DF8 Src             = dword ptr  0Ch
.text$mn:00009DF8 arg_8           = dword ptr  10h
.text$mn:00009DF8
.text$mn:00009DF8                 push    ebp
.text$mn:00009DF9                 mov     ebp, esp
.text$mn:00009DFB                 mov     eax, [ebp+arg_8]
.text$mn:00009DFE                 shl     eax, 1
.text$mn:00009E00                 push    eax             ; Size
.text$mn:00009E01                 mov     ecx, [ebp+Src]
.text$mn:00009E04                 push    ecx             ; Src
.text$mn:00009E05                 mov     edx, [ebp+Dst]
.text$mn:00009E08                 push    edx             ; Dst
.text$mn:00009E09                 call    _memmove
.text$mn:00009E0E                 add     esp, 0Ch
.text$mn:00009E11                 pop     ebp
.text$mn:00009E12                 retn
.text$mn:00009E12 _wmemmove       endp
.text$mn:00009E12
.text$mn:00009E12 ; ---------------------------------------------------------------------------
.text$mn:00009E13                 align 4
.text$mn:00009E13 _text$mn        ends
.text$mn:00009E13
.text$mn:00009E14 ; ===========================================================================
.text$mn:00009E14
.text$mn:00009E14 ; Segment type: Pure code
.text$mn:00009E14 ; Segment permissions: Read/Execute
.text$mn:00009E14 _text$mn        segment para public 'CODE' use32
.text$mn:00009E14                 assume cs:_text$mn
.text$mn:00009E14                 ;org 9E14h
.text$mn:00009E14 ; COMDAT (pick any)
.text$mn:00009E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00009E14
.text$mn:00009E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E14
.text$mn:00009E14 ; Attributes: bp-based frame
.text$mn:00009E14
.text$mn:00009E14                 public _wmemset
.text$mn:00009E14 _wmemset        proc near               ; CODE XREF: std::char_traits<wchar_t>::assign(wchar_t *,uint,wchar_t)+10p
.text$mn:00009E14
.text$mn:00009E14 var_4           = dword ptr -4
.text$mn:00009E14 arg_0           = dword ptr  8
.text$mn:00009E14 arg_4           = word ptr  0Ch
.text$mn:00009E14 arg_8           = dword ptr  10h
.text$mn:00009E14
.text$mn:00009E14                 push    ebp
.text$mn:00009E15                 mov     ebp, esp
.text$mn:00009E17                 push    ecx
.text$mn:00009E18                 mov     eax, [ebp+arg_0]
.text$mn:00009E1B                 mov     [ebp+var_4], eax
.text$mn:00009E1E                 jmp     short loc_9E32
.text$mn:00009E20 ; ---------------------------------------------------------------------------
.text$mn:00009E20
.text$mn:00009E20 loc_9E20:                               ; CODE XREF: _wmemset+2Ej
.text$mn:00009E20                 mov     ecx, [ebp+var_4]
.text$mn:00009E23                 add     ecx, 2
.text$mn:00009E26                 mov     [ebp+var_4], ecx
.text$mn:00009E29                 mov     edx, [ebp+arg_8]
.text$mn:00009E2C                 sub     edx, 1
.text$mn:00009E2F                 mov     [ebp+arg_8], edx
.text$mn:00009E32
.text$mn:00009E32 loc_9E32:                               ; CODE XREF: _wmemset+Aj
.text$mn:00009E32                 cmp     [ebp+arg_8], 0
.text$mn:00009E36                 jbe     short loc_9E44
.text$mn:00009E38                 mov     eax, [ebp+var_4]
.text$mn:00009E3B                 mov     cx, [ebp+arg_4]
.text$mn:00009E3F                 mov     [eax], cx
.text$mn:00009E42                 jmp     short loc_9E20
.text$mn:00009E44 ; ---------------------------------------------------------------------------
.text$mn:00009E44
.text$mn:00009E44 loc_9E44:                               ; CODE XREF: _wmemset+22j
.text$mn:00009E44                 mov     eax, [ebp+arg_0]
.text$mn:00009E47                 mov     esp, ebp
.text$mn:00009E49                 pop     ebp
.text$mn:00009E4A                 retn
.text$mn:00009E4A _wmemset        endp
.text$mn:00009E4A
.text$mn:00009E4A ; ---------------------------------------------------------------------------
.text$mn:00009E4B                 align 4
.text$mn:00009E4B _text$mn        ends
.text$mn:00009E4B
.xdata$x:00009E4C ; ===========================================================================
.xdata$x:00009E4C
.xdata$x:00009E4C ; Segment type: Pure data
.xdata$x:00009E4C ; Segment permissions: Read
.xdata$x:00009E4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E4C                 assume cs:_xdata$x
.xdata$x:00009E4C                 ;org 9E4Ch
.xdata$x:00009E4C ; COMDAT (pick associative to section at 7FA8)
.xdata$x:00009E4C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00009E4C                                         ; DATA XREF: .xdata$x:00009E5Co
.xdata$x:00009E4D                 db 0FFh
.xdata$x:00009E4E                 db 0FFh
.xdata$x:00009E4F                 db 0FFh
.xdata$x:00009E50                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00009E54 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00009E54                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00009E55                 db    5
.xdata$x:00009E56                 db  93h ; ô
.xdata$x:00009E57                 db  19h
.xdata$x:00009E58                 db    1
.xdata$x:00009E59                 db    0
.xdata$x:00009E5A                 db    0
.xdata$x:00009E5B                 db    0
.xdata$x:00009E5C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00009E60                 db    0
.xdata$x:00009E61                 db    0
.xdata$x:00009E62                 db    0
.xdata$x:00009E63                 db    0
.xdata$x:00009E64                 db    0
.xdata$x:00009E65                 db    0
.xdata$x:00009E66                 db    0
.xdata$x:00009E67                 db    0
.xdata$x:00009E68                 db    0
.xdata$x:00009E69                 db    0
.xdata$x:00009E6A                 db    0
.xdata$x:00009E6B                 db    0
.xdata$x:00009E6C                 db    0
.xdata$x:00009E6D                 db    0
.xdata$x:00009E6E                 db    0
.xdata$x:00009E6F                 db    0
.xdata$x:00009E70                 db    0
.xdata$x:00009E71                 db    0
.xdata$x:00009E72                 db    0
.xdata$x:00009E73                 db    0
.xdata$x:00009E74                 db    0
.xdata$x:00009E75                 db    0
.xdata$x:00009E76                 db    0
.xdata$x:00009E77                 db    0
.xdata$x:00009E77 _xdata$x        ends
.xdata$x:00009E77
.xdata$x:00009E78 ; ===========================================================================
.xdata$x:00009E78
.xdata$x:00009E78 ; Segment type: Pure data
.xdata$x:00009E78 ; Segment permissions: Read
.xdata$x:00009E78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E78                 assume cs:_xdata$x
.xdata$x:00009E78                 ;org 9E78h
.xdata$x:00009E78 ; COMDAT (pick associative to section at 6CD8)
.xdata$x:00009E78 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00009E78                                         ; DATA XREF: .xdata$x:00009E88o
.xdata$x:00009E79                 db 0FFh
.xdata$x:00009E7A                 db 0FFh
.xdata$x:00009E7B                 db 0FFh
.xdata$x:00009E7C                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00009E80 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00009E80                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00009E81                 db    5
.xdata$x:00009E82                 db  93h ; ô
.xdata$x:00009E83                 db  19h
.xdata$x:00009E84                 db    1
.xdata$x:00009E85                 db    0
.xdata$x:00009E86                 db    0
.xdata$x:00009E87                 db    0
.xdata$x:00009E88                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00009E8C                 db    0
.xdata$x:00009E8D                 db    0
.xdata$x:00009E8E                 db    0
.xdata$x:00009E8F                 db    0
.xdata$x:00009E90                 db    0
.xdata$x:00009E91                 db    0
.xdata$x:00009E92                 db    0
.xdata$x:00009E93                 db    0
.xdata$x:00009E94                 db    0
.xdata$x:00009E95                 db    0
.xdata$x:00009E96                 db    0
.xdata$x:00009E97                 db    0
.xdata$x:00009E98                 db    0
.xdata$x:00009E99                 db    0
.xdata$x:00009E9A                 db    0
.xdata$x:00009E9B                 db    0
.xdata$x:00009E9C                 db    0
.xdata$x:00009E9D                 db    0
.xdata$x:00009E9E                 db    0
.xdata$x:00009E9F                 db    0
.xdata$x:00009EA0                 db    0
.xdata$x:00009EA1                 db    0
.xdata$x:00009EA2                 db    0
.xdata$x:00009EA3                 db    0
.xdata$x:00009EA3 _xdata$x        ends
.xdata$x:00009EA3
.xdata$x:00009EA4 ; ===========================================================================
.xdata$x:00009EA4
.xdata$x:00009EA4 ; Segment type: Pure data
.xdata$x:00009EA4 ; Segment permissions: Read
.xdata$x:00009EA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009EA4                 assume cs:_xdata$x
.xdata$x:00009EA4                 ;org 9EA4h
.xdata$x:00009EA4 ; COMDAT (pick associative to section at 6B50)
.xdata$x:00009EA4 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00009EA4                                         ; DATA XREF: .xdata$x:00009EB4o
.xdata$x:00009EA5                 db 0FFh
.xdata$x:00009EA6                 db 0FFh
.xdata$x:00009EA7                 db 0FFh
.xdata$x:00009EA8                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00009EAC __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00009EAC                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00009EAD                 db    5
.xdata$x:00009EAE                 db  93h ; ô
.xdata$x:00009EAF                 db  19h
.xdata$x:00009EB0                 db    1
.xdata$x:00009EB1                 db    0
.xdata$x:00009EB2                 db    0
.xdata$x:00009EB3                 db    0
.xdata$x:00009EB4                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00009EB8                 db    0
.xdata$x:00009EB9                 db    0
.xdata$x:00009EBA                 db    0
.xdata$x:00009EBB                 db    0
.xdata$x:00009EBC                 db    0
.xdata$x:00009EBD                 db    0
.xdata$x:00009EBE                 db    0
.xdata$x:00009EBF                 db    0
.xdata$x:00009EC0                 db    0
.xdata$x:00009EC1                 db    0
.xdata$x:00009EC2                 db    0
.xdata$x:00009EC3                 db    0
.xdata$x:00009EC4                 db    0
.xdata$x:00009EC5                 db    0
.xdata$x:00009EC6                 db    0
.xdata$x:00009EC7                 db    0
.xdata$x:00009EC8                 db    0
.xdata$x:00009EC9                 db    0
.xdata$x:00009ECA                 db    0
.xdata$x:00009ECB                 db    0
.xdata$x:00009ECC                 db    0
.xdata$x:00009ECD                 db    0
.xdata$x:00009ECE                 db    0
.xdata$x:00009ECF                 db    0
.xdata$x:00009ECF _xdata$x        ends
.xdata$x:00009ECF
.xdata$x:00009ED0 ; ===========================================================================
.xdata$x:00009ED0
.xdata$x:00009ED0 ; Segment type: Pure data
.xdata$x:00009ED0 ; Segment permissions: Read
.xdata$x:00009ED0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009ED0                 assume cs:_xdata$x
.xdata$x:00009ED0                 ;org 9ED0h
.xdata$x:00009ED0 ; COMDAT (pick associative to section at 7378)
.xdata$x:00009ED0 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:00009ED0                                         ; DATA XREF: .xdata$x:00009EE8o
.xdata$x:00009ED1                 db 0FFh
.xdata$x:00009ED2                 db 0FFh
.xdata$x:00009ED3                 db 0FFh
.xdata$x:00009ED4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:00009ED8                 db 0FFh
.xdata$x:00009ED9                 db 0FFh
.xdata$x:00009EDA                 db 0FFh
.xdata$x:00009EDB                 db 0FFh
.xdata$x:00009EDC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:00009EE0 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:00009EE0                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:00009EE1                 db    5
.xdata$x:00009EE2                 db  93h ; ô
.xdata$x:00009EE3                 db  19h
.xdata$x:00009EE4                 db    2
.xdata$x:00009EE5                 db    0
.xdata$x:00009EE6                 db    0
.xdata$x:00009EE7                 db    0
.xdata$x:00009EE8                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:00009EEC                 db    0
.xdata$x:00009EED                 db    0
.xdata$x:00009EEE                 db    0
.xdata$x:00009EEF                 db    0
.xdata$x:00009EF0                 db    0
.xdata$x:00009EF1                 db    0
.xdata$x:00009EF2                 db    0
.xdata$x:00009EF3                 db    0
.xdata$x:00009EF4                 db    0
.xdata$x:00009EF5                 db    0
.xdata$x:00009EF6                 db    0
.xdata$x:00009EF7                 db    0
.xdata$x:00009EF8                 db    0
.xdata$x:00009EF9                 db    0
.xdata$x:00009EFA                 db    0
.xdata$x:00009EFB                 db    0
.xdata$x:00009EFC                 db    0
.xdata$x:00009EFD                 db    0
.xdata$x:00009EFE                 db    0
.xdata$x:00009EFF                 db    0
.xdata$x:00009F00                 db    0
.xdata$x:00009F01                 db    0
.xdata$x:00009F02                 db    0
.xdata$x:00009F03                 db    0
.xdata$x:00009F03 _xdata$x        ends
.xdata$x:00009F03
.xdata$x:00009F04 ; ===========================================================================
.xdata$x:00009F04
.xdata$x:00009F04 ; Segment type: Pure data
.xdata$x:00009F04 ; Segment permissions: Read
.xdata$x:00009F04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F04                 assume cs:_xdata$x
.xdata$x:00009F04                 ;org 9F04h
.xdata$x:00009F04 ; COMDAT (pick associative to section at 537C)
.xdata$x:00009F04 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009F04                                         ; DATA XREF: .xdata$x:00009F14o
.xdata$x:00009F05                 db 0FFh
.xdata$x:00009F06                 db 0FFh
.xdata$x:00009F07                 db 0FFh
.xdata$x:00009F08                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00009F0C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009F0C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00009F0D                 db    5
.xdata$x:00009F0E                 db  93h ; ô
.xdata$x:00009F0F                 db  19h
.xdata$x:00009F10                 db    1
.xdata$x:00009F11                 db    0
.xdata$x:00009F12                 db    0
.xdata$x:00009F13                 db    0
.xdata$x:00009F14                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00009F18                 db    0
.xdata$x:00009F19                 db    0
.xdata$x:00009F1A                 db    0
.xdata$x:00009F1B                 db    0
.xdata$x:00009F1C                 db    0
.xdata$x:00009F1D                 db    0
.xdata$x:00009F1E                 db    0
.xdata$x:00009F1F                 db    0
.xdata$x:00009F20                 db    0
.xdata$x:00009F21                 db    0
.xdata$x:00009F22                 db    0
.xdata$x:00009F23                 db    0
.xdata$x:00009F24                 db    0
.xdata$x:00009F25                 db    0
.xdata$x:00009F26                 db    0
.xdata$x:00009F27                 db    0
.xdata$x:00009F28                 db    0
.xdata$x:00009F29                 db    0
.xdata$x:00009F2A                 db    0
.xdata$x:00009F2B                 db    0
.xdata$x:00009F2C                 db    0
.xdata$x:00009F2D                 db    0
.xdata$x:00009F2E                 db    0
.xdata$x:00009F2F                 db    0
.xdata$x:00009F2F _xdata$x        ends
.xdata$x:00009F2F
.xdata$x:00009F30 ; ===========================================================================
.xdata$x:00009F30
.xdata$x:00009F30 ; Segment type: Pure data
.xdata$x:00009F30 ; Segment permissions: Read
.xdata$x:00009F30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F30                 assume cs:_xdata$x
.xdata$x:00009F30                 ;org 9F30h
.xdata$x:00009F30 ; COMDAT (pick associative to section at 6394)
.xdata$x:00009F30 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009F30                                         ; DATA XREF: .xdata$x:00009F40o
.xdata$x:00009F31                 db 0FFh
.xdata$x:00009F32                 db 0FFh
.xdata$x:00009F33                 db 0FFh
.xdata$x:00009F34                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00009F38 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009F38                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00009F39                 db    5
.xdata$x:00009F3A                 db  93h ; ô
.xdata$x:00009F3B                 db  19h
.xdata$x:00009F3C                 db    1
.xdata$x:00009F3D                 db    0
.xdata$x:00009F3E                 db    0
.xdata$x:00009F3F                 db    0
.xdata$x:00009F40                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00009F44                 db    0
.xdata$x:00009F45                 db    0
.xdata$x:00009F46                 db    0
.xdata$x:00009F47                 db    0
.xdata$x:00009F48                 db    0
.xdata$x:00009F49                 db    0
.xdata$x:00009F4A                 db    0
.xdata$x:00009F4B                 db    0
.xdata$x:00009F4C                 db    0
.xdata$x:00009F4D                 db    0
.xdata$x:00009F4E                 db    0
.xdata$x:00009F4F                 db    0
.xdata$x:00009F50                 db    0
.xdata$x:00009F51                 db    0
.xdata$x:00009F52                 db    0
.xdata$x:00009F53                 db    0
.xdata$x:00009F54                 db    0
.xdata$x:00009F55                 db    0
.xdata$x:00009F56                 db    0
.xdata$x:00009F57                 db    0
.xdata$x:00009F58                 db    0
.xdata$x:00009F59                 db    0
.xdata$x:00009F5A                 db    0
.xdata$x:00009F5B                 db    0
.xdata$x:00009F5B _xdata$x        ends
.xdata$x:00009F5B
.xdata$x:00009F5C ; ===========================================================================
.xdata$x:00009F5C
.xdata$x:00009F5C ; Segment type: Pure data
.xdata$x:00009F5C ; Segment permissions: Read
.xdata$x:00009F5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F5C                 assume cs:_xdata$x
.xdata$x:00009F5C                 ;org 9F5Ch
.xdata$x:00009F5C ; COMDAT (pick associative to section at 5284)
.xdata$x:00009F5C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00009F5C                                         ; DATA XREF: .xdata$x:00009F6Co
.xdata$x:00009F5D                 db 0FFh
.xdata$x:00009F5E                 db 0FFh
.xdata$x:00009F5F                 db 0FFh
.xdata$x:00009F60                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00009F64 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00009F64                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00009F65                 db    5
.xdata$x:00009F66                 db  93h ; ô
.xdata$x:00009F67                 db  19h
.xdata$x:00009F68                 db    1
.xdata$x:00009F69                 db    0
.xdata$x:00009F6A                 db    0
.xdata$x:00009F6B                 db    0
.xdata$x:00009F6C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00009F70                 db    0
.xdata$x:00009F71                 db    0
.xdata$x:00009F72                 db    0
.xdata$x:00009F73                 db    0
.xdata$x:00009F74                 db    0
.xdata$x:00009F75                 db    0
.xdata$x:00009F76                 db    0
.xdata$x:00009F77                 db    0
.xdata$x:00009F78                 db    0
.xdata$x:00009F79                 db    0
.xdata$x:00009F7A                 db    0
.xdata$x:00009F7B                 db    0
.xdata$x:00009F7C                 db    0
.xdata$x:00009F7D                 db    0
.xdata$x:00009F7E                 db    0
.xdata$x:00009F7F                 db    0
.xdata$x:00009F80                 db    0
.xdata$x:00009F81                 db    0
.xdata$x:00009F82                 db    0
.xdata$x:00009F83                 db    0
.xdata$x:00009F84                 db    0
.xdata$x:00009F85                 db    0
.xdata$x:00009F86                 db    0
.xdata$x:00009F87                 db    0
.xdata$x:00009F87 _xdata$x        ends
.xdata$x:00009F87
.xdata$x:00009F88 ; ===========================================================================
.xdata$x:00009F88
.xdata$x:00009F88 ; Segment type: Pure data
.xdata$x:00009F88 ; Segment permissions: Read
.xdata$x:00009F88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F88                 assume cs:_xdata$x
.xdata$x:00009F88                 ;org 9F88h
.xdata$x:00009F88 ; COMDAT (pick associative to section at 62A4)
.xdata$x:00009F88 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009F88                                         ; DATA XREF: .xdata$x:00009F98o
.xdata$x:00009F89                 db 0FFh
.xdata$x:00009F8A                 db 0FFh
.xdata$x:00009F8B                 db 0FFh
.xdata$x:00009F8C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009F90 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009F90                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009F91                 db    5
.xdata$x:00009F92                 db  93h ; ô
.xdata$x:00009F93                 db  19h
.xdata$x:00009F94                 db    1
.xdata$x:00009F95                 db    0
.xdata$x:00009F96                 db    0
.xdata$x:00009F97                 db    0
.xdata$x:00009F98                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00009F9C                 db    0
.xdata$x:00009F9D                 db    0
.xdata$x:00009F9E                 db    0
.xdata$x:00009F9F                 db    0
.xdata$x:00009FA0                 db    0
.xdata$x:00009FA1                 db    0
.xdata$x:00009FA2                 db    0
.xdata$x:00009FA3                 db    0
.xdata$x:00009FA4                 db    0
.xdata$x:00009FA5                 db    0
.xdata$x:00009FA6                 db    0
.xdata$x:00009FA7                 db    0
.xdata$x:00009FA8                 db    0
.xdata$x:00009FA9                 db    0
.xdata$x:00009FAA                 db    0
.xdata$x:00009FAB                 db    0
.xdata$x:00009FAC                 db    0
.xdata$x:00009FAD                 db    0
.xdata$x:00009FAE                 db    0
.xdata$x:00009FAF                 db    0
.xdata$x:00009FB0                 db    0
.xdata$x:00009FB1                 db    0
.xdata$x:00009FB2                 db    0
.xdata$x:00009FB3                 db    0
.xdata$x:00009FB3 _xdata$x        ends
.xdata$x:00009FB3
.xdata$x:00009FB4 ; ===========================================================================
.xdata$x:00009FB4
.xdata$x:00009FB4 ; Segment type: Pure data
.xdata$x:00009FB4 ; Segment permissions: Read
.xdata$x:00009FB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FB4                 assume cs:_xdata$x
.xdata$x:00009FB4                 ;org 9FB4h
.xdata$x:00009FB4 ; COMDAT (pick associative to section at 5A68)
.xdata$x:00009FB4 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00009FB4                                         ; DATA XREF: .xdata$x:00009FC4o
.xdata$x:00009FB5                 db 0FFh
.xdata$x:00009FB6                 db 0FFh
.xdata$x:00009FB7                 db 0FFh
.xdata$x:00009FB8                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00009FBC __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00009FBC                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00009FBD                 db    5
.xdata$x:00009FBE                 db  93h ; ô
.xdata$x:00009FBF                 db  19h
.xdata$x:00009FC0                 db    1
.xdata$x:00009FC1                 db    0
.xdata$x:00009FC2                 db    0
.xdata$x:00009FC3                 db    0
.xdata$x:00009FC4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00009FC8                 align 20h
.xdata$x:00009FC8 _xdata$x        ends
.xdata$x:00009FC8
.xdata$x:00009FE0 ; ===========================================================================
.xdata$x:00009FE0
.xdata$x:00009FE0 ; Segment type: Pure data
.xdata$x:00009FE0 ; Segment permissions: Read
.xdata$x:00009FE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FE0                 assume cs:_xdata$x
.xdata$x:00009FE0                 ;org 9FE0h
.xdata$x:00009FE0 ; COMDAT (pick associative to section at 6804)
.xdata$x:00009FE0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009FE0                                         ; DATA XREF: .xdata$x:00009FF0o
.xdata$x:00009FE1                 db 0FFh
.xdata$x:00009FE2                 db 0FFh
.xdata$x:00009FE3                 db 0FFh
.xdata$x:00009FE4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00009FE8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009FE8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00009FE9                 db    5
.xdata$x:00009FEA                 db  93h ; ô
.xdata$x:00009FEB                 db  19h
.xdata$x:00009FEC                 db    1
.xdata$x:00009FED                 db    0
.xdata$x:00009FEE                 db    0
.xdata$x:00009FEF                 db    0
.xdata$x:00009FF0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00009FF4                 db    0
.xdata$x:00009FF5                 db    0
.xdata$x:00009FF6                 db    0
.xdata$x:00009FF7                 db    0
.xdata$x:00009FF8                 db    0
.xdata$x:00009FF9                 db    0
.xdata$x:00009FFA                 db    0
.xdata$x:00009FFB                 db    0
.xdata$x:00009FFC                 db    0
.xdata$x:00009FFD                 db    0
.xdata$x:00009FFE                 db    0
.xdata$x:00009FFF                 db    0
.xdata$x:0000A000                 db    0
.xdata$x:0000A001                 db    0
.xdata$x:0000A002                 db    0
.xdata$x:0000A003                 db    0
.xdata$x:0000A004                 db    0
.xdata$x:0000A005                 db    0
.xdata$x:0000A006                 db    0
.xdata$x:0000A007                 db    0
.xdata$x:0000A008                 db    0
.xdata$x:0000A009                 db    0
.xdata$x:0000A00A                 db    0
.xdata$x:0000A00B                 db    0
.xdata$x:0000A00B _xdata$x        ends
.xdata$x:0000A00B
.xdata$x:0000A00C ; ===========================================================================
.xdata$x:0000A00C
.xdata$x:0000A00C ; Segment type: Pure data
.xdata$x:0000A00C ; Segment permissions: Read
.xdata$x:0000A00C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A00C                 assume cs:_xdata$x
.xdata$x:0000A00C                 ;org 0A00Ch
.xdata$x:0000A00C ; COMDAT (pick associative to section at 763C)
.xdata$x:0000A00C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000A00C                                         ; DATA XREF: .xdata$x:0000A094o
.xdata$x:0000A00D                 db    0
.xdata$x:0000A00E                 db    0
.xdata$x:0000A00F                 db    0
.xdata$x:0000A010                 db    0
.xdata$x:0000A011                 db    0
.xdata$x:0000A012                 db    0
.xdata$x:0000A013                 db    0
.xdata$x:0000A014                 db    0
.xdata$x:0000A015                 db    0
.xdata$x:0000A016                 db    0
.xdata$x:0000A017                 db    0
.xdata$x:0000A018                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000A01C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000A01C                                         ; DATA XREF: .xdata$x:0000A080o
.xdata$x:0000A01D                 db    0
.xdata$x:0000A01E                 db    0
.xdata$x:0000A01F                 db    0
.xdata$x:0000A020                 db    0
.xdata$x:0000A021                 db    0
.xdata$x:0000A022                 db    0
.xdata$x:0000A023                 db    0
.xdata$x:0000A024                 db    0
.xdata$x:0000A025                 db    0
.xdata$x:0000A026                 db    0
.xdata$x:0000A027                 db    0
.xdata$x:0000A028                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000A02C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000A02C                                         ; DATA XREF: .xdata$x:0000A054o
.xdata$x:0000A02D                 db 0FFh
.xdata$x:0000A02E                 db 0FFh
.xdata$x:0000A02F                 db 0FFh
.xdata$x:0000A030                 db    0
.xdata$x:0000A031                 db    0
.xdata$x:0000A032                 db    0
.xdata$x:0000A033                 db    0
.xdata$x:0000A034                 db 0FFh
.xdata$x:0000A035                 db 0FFh
.xdata$x:0000A036                 db 0FFh
.xdata$x:0000A037                 db 0FFh
.xdata$x:0000A038                 db    0
.xdata$x:0000A039                 db    0
.xdata$x:0000A03A                 db    0
.xdata$x:0000A03B                 db    0
.xdata$x:0000A03C                 db    1
.xdata$x:0000A03D                 db    0
.xdata$x:0000A03E                 db    0
.xdata$x:0000A03F                 db    0
.xdata$x:0000A040                 db    0
.xdata$x:0000A041                 db    0
.xdata$x:0000A042                 db    0
.xdata$x:0000A043                 db    0
.xdata$x:0000A044                 db    1
.xdata$x:0000A045                 db    0
.xdata$x:0000A046                 db    0
.xdata$x:0000A047                 db    0
.xdata$x:0000A048                 db    0
.xdata$x:0000A049                 db    0
.xdata$x:0000A04A                 db    0
.xdata$x:0000A04B                 db    0
.xdata$x:0000A04C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000A04C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000A04D                 db    5
.xdata$x:0000A04E                 db  93h ; ô
.xdata$x:0000A04F                 db  19h
.xdata$x:0000A050                 db    4
.xdata$x:0000A051                 db    0
.xdata$x:0000A052                 db    0
.xdata$x:0000A053                 db    0
.xdata$x:0000A054                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000A058                 db    2
.xdata$x:0000A059                 db    0
.xdata$x:0000A05A                 db    0
.xdata$x:0000A05B                 db    0
.xdata$x:0000A05C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000A060                 db    0
.xdata$x:0000A061                 db    0
.xdata$x:0000A062                 db    0
.xdata$x:0000A063                 db    0
.xdata$x:0000A064                 db    0
.xdata$x:0000A065                 db    0
.xdata$x:0000A066                 db    0
.xdata$x:0000A067                 db    0
.xdata$x:0000A068                 db    0
.xdata$x:0000A069                 db    0
.xdata$x:0000A06A                 db    0
.xdata$x:0000A06B                 db    0
.xdata$x:0000A06C                 db    0
.xdata$x:0000A06D                 db    0
.xdata$x:0000A06E                 db    0
.xdata$x:0000A06F                 db    0
.xdata$x:0000A070 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000A070                                         ; DATA XREF: .xdata$x:0000A05Co
.xdata$x:0000A071                 db    0
.xdata$x:0000A072                 db    0
.xdata$x:0000A073                 db    0
.xdata$x:0000A074                 db    2
.xdata$x:0000A075                 db    0
.xdata$x:0000A076                 db    0
.xdata$x:0000A077                 db    0
.xdata$x:0000A078                 db    3
.xdata$x:0000A079                 db    0
.xdata$x:0000A07A                 db    0
.xdata$x:0000A07B                 db    0
.xdata$x:0000A07C                 db    1
.xdata$x:0000A07D                 db    0
.xdata$x:0000A07E                 db    0
.xdata$x:0000A07F                 db    0
.xdata$x:0000A080                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:0000A084                 db    0
.xdata$x:0000A085                 db    0
.xdata$x:0000A086                 db    0
.xdata$x:0000A087                 db    0
.xdata$x:0000A088                 db    0
.xdata$x:0000A089                 db    0
.xdata$x:0000A08A                 db    0
.xdata$x:0000A08B                 db    0
.xdata$x:0000A08C                 db    3
.xdata$x:0000A08D                 db    0
.xdata$x:0000A08E                 db    0
.xdata$x:0000A08F                 db    0
.xdata$x:0000A090                 db    1
.xdata$x:0000A091                 db    0
.xdata$x:0000A092                 db    0
.xdata$x:0000A093                 db    0
.xdata$x:0000A094                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:0000A094 _xdata$x        ends
.xdata$x:0000A094
.xdata$x:0000A098 ; ===========================================================================
.xdata$x:0000A098
.xdata$x:0000A098 ; Segment type: Pure data
.xdata$x:0000A098 ; Segment permissions: Read
.xdata$x:0000A098 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A098                 assume cs:_xdata$x
.xdata$x:0000A098                 ;org 0A098h
.xdata$x:0000A098 ; COMDAT (pick associative to section at 60D0)
.xdata$x:0000A098 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000A098                                         ; DATA XREF: .xdata$x:0000A0A8o
.xdata$x:0000A099                 db 0FFh
.xdata$x:0000A09A                 db 0FFh
.xdata$x:0000A09B                 db 0FFh
.xdata$x:0000A09C                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:0000A0A0 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000A0A0                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:0000A0A1                 db    5
.xdata$x:0000A0A2                 db  93h ; ô
.xdata$x:0000A0A3                 db  19h
.xdata$x:0000A0A4                 db    1
.xdata$x:0000A0A5                 db    0
.xdata$x:0000A0A6                 db    0
.xdata$x:0000A0A7                 db    0
.xdata$x:0000A0A8                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:0000A0AC                 db    0
.xdata$x:0000A0AD                 db    0
.xdata$x:0000A0AE                 db    0
.xdata$x:0000A0AF                 db    0
.xdata$x:0000A0B0                 db    0
.xdata$x:0000A0B1                 db    0
.xdata$x:0000A0B2                 db    0
.xdata$x:0000A0B3                 db    0
.xdata$x:0000A0B4                 db    0
.xdata$x:0000A0B5                 db    0
.xdata$x:0000A0B6                 db    0
.xdata$x:0000A0B7                 db    0
.xdata$x:0000A0B8                 db    0
.xdata$x:0000A0B9                 db    0
.xdata$x:0000A0BA                 db    0
.xdata$x:0000A0BB                 db    0
.xdata$x:0000A0BC                 db    0
.xdata$x:0000A0BD                 db    0
.xdata$x:0000A0BE                 db    0
.xdata$x:0000A0BF                 db    0
.xdata$x:0000A0C0                 db    0
.xdata$x:0000A0C1                 db    0
.xdata$x:0000A0C2                 db    0
.xdata$x:0000A0C3                 db    0
.xdata$x:0000A0C3 _xdata$x        ends
.xdata$x:0000A0C3
.xdata$x:0000A0C4 ; ===========================================================================
.xdata$x:0000A0C4
.xdata$x:0000A0C4 ; Segment type: Pure data
.xdata$x:0000A0C4 ; Segment permissions: Read
.xdata$x:0000A0C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0C4                 assume cs:_xdata$x
.xdata$x:0000A0C4                 ;org 0A0C4h
.xdata$x:0000A0C4 ; COMDAT (pick associative to section at 6C58)
.xdata$x:0000A0C4 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:0000A0C4                                         ; DATA XREF: .xdata$x:0000A0D4o
.xdata$x:0000A0C5                 db 0FFh
.xdata$x:0000A0C6                 db 0FFh
.xdata$x:0000A0C7                 db 0FFh
.xdata$x:0000A0C8                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:0000A0CC __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:0000A0CC                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:0000A0CD                 db    5
.xdata$x:0000A0CE                 db  93h ; ô
.xdata$x:0000A0CF                 db  19h
.xdata$x:0000A0D0                 db    1
.xdata$x:0000A0D1                 db    0
.xdata$x:0000A0D2                 db    0
.xdata$x:0000A0D3                 db    0
.xdata$x:0000A0D4                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:0000A0D8                 db    0
.xdata$x:0000A0D9                 db    0
.xdata$x:0000A0DA                 db    0
.xdata$x:0000A0DB                 db    0
.xdata$x:0000A0DC                 db    0
.xdata$x:0000A0DD                 db    0
.xdata$x:0000A0DE                 db    0
.xdata$x:0000A0DF                 db    0
.xdata$x:0000A0E0                 db    0
.xdata$x:0000A0E1                 db    0
.xdata$x:0000A0E2                 db    0
.xdata$x:0000A0E3                 db    0
.xdata$x:0000A0E4                 db    0
.xdata$x:0000A0E5                 db    0
.xdata$x:0000A0E6                 db    0
.xdata$x:0000A0E7                 db    0
.xdata$x:0000A0E8                 db    0
.xdata$x:0000A0E9                 db    0
.xdata$x:0000A0EA                 db    0
.xdata$x:0000A0EB                 db    0
.xdata$x:0000A0EC                 db    0
.xdata$x:0000A0ED                 db    0
.xdata$x:0000A0EE                 db    0
.xdata$x:0000A0EF                 db    0
.xdata$x:0000A0EF _xdata$x        ends
.xdata$x:0000A0EF
.xdata$x:0000A0F0 ; ===========================================================================
.xdata$x:0000A0F0
.xdata$x:0000A0F0 ; Segment type: Pure data
.xdata$x:0000A0F0 ; Segment permissions: Read
.xdata$x:0000A0F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0F0                 assume cs:_xdata$x
.xdata$x:0000A0F0                 ;org 0A0F0h
.xdata$x:0000A0F0 ; COMDAT (pick associative to section at 604C)
.xdata$x:0000A0F0 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000A0F0                                         ; DATA XREF: .xdata$x:0000A100o
.xdata$x:0000A0F1                 db 0FFh
.xdata$x:0000A0F2                 db 0FFh
.xdata$x:0000A0F3                 db 0FFh
.xdata$x:0000A0F4                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:0000A0F8 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000A0F8                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:0000A0F9                 db    5
.xdata$x:0000A0FA                 db  93h ; ô
.xdata$x:0000A0FB                 db  19h
.xdata$x:0000A0FC                 db    1
.xdata$x:0000A0FD                 db    0
.xdata$x:0000A0FE                 db    0
.xdata$x:0000A0FF                 db    0
.xdata$x:0000A100                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:0000A104                 db    0
.xdata$x:0000A105                 db    0
.xdata$x:0000A106                 db    0
.xdata$x:0000A107                 db    0
.xdata$x:0000A108                 db    0
.xdata$x:0000A109                 db    0
.xdata$x:0000A10A                 db    0
.xdata$x:0000A10B                 db    0
.xdata$x:0000A10C                 db    0
.xdata$x:0000A10D                 db    0
.xdata$x:0000A10E                 db    0
.xdata$x:0000A10F                 db    0
.xdata$x:0000A110                 db    0
.xdata$x:0000A111                 db    0
.xdata$x:0000A112                 db    0
.xdata$x:0000A113                 db    0
.xdata$x:0000A114                 db    0
.xdata$x:0000A115                 db    0
.xdata$x:0000A116                 db    0
.xdata$x:0000A117                 db    0
.xdata$x:0000A118                 db    0
.xdata$x:0000A119                 db    0
.xdata$x:0000A11A                 db    0
.xdata$x:0000A11B                 db    0
.xdata$x:0000A11B _xdata$x        ends
.xdata$x:0000A11B
.xdata$x:0000A11C ; ===========================================================================
.xdata$x:0000A11C
.xdata$x:0000A11C ; Segment type: Pure data
.xdata$x:0000A11C ; Segment permissions: Read
.xdata$x:0000A11C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A11C                 assume cs:_xdata$x
.xdata$x:0000A11C                 ;org 0A11Ch
.xdata$x:0000A11C __ehfuncinfo$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z db  22h ; "
.xdata$x:0000A11C                                         ; DATA XREF: __ehhandler$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z+1Eo
.xdata$x:0000A11D                 db    5
.xdata$x:0000A11E                 db  93h ; ô
.xdata$x:0000A11F                 db  19h
.xdata$x:0000A120                 db  10h
.xdata$x:0000A121                 db    0
.xdata$x:0000A122                 db    0
.xdata$x:0000A123                 db    0
.xdata$x:0000A124                 dd offset __unwindtable$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z
.xdata$x:0000A128                 align 20h
.xdata$x:0000A140 __unwindtable$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z db 0FFh
.xdata$x:0000A140                                         ; DATA XREF: .xdata$x:0000A124o
.xdata$x:0000A141                 db 0FFh
.xdata$x:0000A142                 db 0FFh
.xdata$x:0000A143                 db 0FFh
.xdata$x:0000A144                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$0
.xdata$x:0000A148                 db    0
.xdata$x:0000A149                 db    0
.xdata$x:0000A14A                 db    0
.xdata$x:0000A14B                 db    0
.xdata$x:0000A14C                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$1
.xdata$x:0000A150                 db    1
.xdata$x:0000A151                 db    0
.xdata$x:0000A152                 db    0
.xdata$x:0000A153                 db    0
.xdata$x:0000A154                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$2
.xdata$x:0000A158                 db    0
.xdata$x:0000A159                 db    0
.xdata$x:0000A15A                 db    0
.xdata$x:0000A15B                 db    0
.xdata$x:0000A15C                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$3
.xdata$x:0000A160                 db    3
.xdata$x:0000A161                 db    0
.xdata$x:0000A162                 db    0
.xdata$x:0000A163                 db    0
.xdata$x:0000A164                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$4
.xdata$x:0000A168                 db 0FFh
.xdata$x:0000A169                 db 0FFh
.xdata$x:0000A16A                 db 0FFh
.xdata$x:0000A16B                 db 0FFh
.xdata$x:0000A16C                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$5
.xdata$x:0000A170                 db    5
.xdata$x:0000A171                 db    0
.xdata$x:0000A172                 db    0
.xdata$x:0000A173                 db    0
.xdata$x:0000A174                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$6
.xdata$x:0000A178                 db 0FFh
.xdata$x:0000A179                 db 0FFh
.xdata$x:0000A17A                 db 0FFh
.xdata$x:0000A17B                 db 0FFh
.xdata$x:0000A17C                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$7
.xdata$x:0000A180                 db    7
.xdata$x:0000A181                 db    0
.xdata$x:0000A182                 db    0
.xdata$x:0000A183                 db    0
.xdata$x:0000A184                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$8
.xdata$x:0000A188                 db    8
.xdata$x:0000A189                 db    0
.xdata$x:0000A18A                 db    0
.xdata$x:0000A18B                 db    0
.xdata$x:0000A18C                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$9
.xdata$x:0000A190                 db    7
.xdata$x:0000A191                 db    0
.xdata$x:0000A192                 db    0
.xdata$x:0000A193                 db    0
.xdata$x:0000A194                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$10
.xdata$x:0000A198                 db  0Ah
.xdata$x:0000A199                 db    0
.xdata$x:0000A19A                 db    0
.xdata$x:0000A19B                 db    0
.xdata$x:0000A19C                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$11
.xdata$x:0000A1A0                 db 0FFh
.xdata$x:0000A1A1                 db 0FFh
.xdata$x:0000A1A2                 db 0FFh
.xdata$x:0000A1A3                 db 0FFh
.xdata$x:0000A1A4                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$12
.xdata$x:0000A1A8                 db  0Ch
.xdata$x:0000A1A9                 db    0
.xdata$x:0000A1AA                 db    0
.xdata$x:0000A1AB                 db    0
.xdata$x:0000A1AC                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$13
.xdata$x:0000A1B0                 db  0Ch
.xdata$x:0000A1B1                 db    0
.xdata$x:0000A1B2                 db    0
.xdata$x:0000A1B3                 db    0
.xdata$x:0000A1B4                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$14
.xdata$x:0000A1B8                 db  0Eh
.xdata$x:0000A1B9                 db    0
.xdata$x:0000A1BA                 db    0
.xdata$x:0000A1BB                 db    0
.xdata$x:0000A1BC                 dd offset __unwindfunclet$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z$15
.xdata$x:0000A1BC _xdata$x        ends
.xdata$x:0000A1BC
.xdata$x:0000A1C0 ; ===========================================================================
.xdata$x:0000A1C0
.xdata$x:0000A1C0 ; Segment type: Pure data
.xdata$x:0000A1C0 ; Segment permissions: Read
.xdata$x:0000A1C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A1C0                 assume cs:_xdata$x
.xdata$x:0000A1C0                 ;org 0A1C0h
.xdata$x:0000A1C0 ; COMDAT (pick associative to section at 5E20)
.xdata$x:0000A1C0 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000A1C0                                         ; DATA XREF: .xdata$x:0000A1D0o
.xdata$x:0000A1C1                 db 0FFh
.xdata$x:0000A1C2                 db 0FFh
.xdata$x:0000A1C3                 db 0FFh
.xdata$x:0000A1C4                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:0000A1C8 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000A1C8                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:0000A1C9                 db    5
.xdata$x:0000A1CA                 db  93h ; ô
.xdata$x:0000A1CB                 db  19h
.xdata$x:0000A1CC                 db    1
.xdata$x:0000A1CD                 db    0
.xdata$x:0000A1CE                 db    0
.xdata$x:0000A1CF                 db    0
.xdata$x:0000A1D0                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000A1D4                 db    0
.xdata$x:0000A1D5                 db    0
.xdata$x:0000A1D6                 db    0
.xdata$x:0000A1D7                 db    0
.xdata$x:0000A1D8                 db    0
.xdata$x:0000A1D9                 db    0
.xdata$x:0000A1DA                 db    0
.xdata$x:0000A1DB                 db    0
.xdata$x:0000A1DC                 db    0
.xdata$x:0000A1DD                 db    0
.xdata$x:0000A1DE                 db    0
.xdata$x:0000A1DF                 db    0
.xdata$x:0000A1E0                 db    0
.xdata$x:0000A1E1                 db    0
.xdata$x:0000A1E2                 db    0
.xdata$x:0000A1E3                 db    0
.xdata$x:0000A1E4                 db    0
.xdata$x:0000A1E5                 db    0
.xdata$x:0000A1E6                 db    0
.xdata$x:0000A1E7                 db    0
.xdata$x:0000A1E8                 db    0
.xdata$x:0000A1E9                 db    0
.xdata$x:0000A1EA                 db    0
.xdata$x:0000A1EB                 db    0
.xdata$x:0000A1EB _xdata$x        ends
.xdata$x:0000A1EB
.xdata$x:0000A1EC ; ===========================================================================
.xdata$x:0000A1EC
.xdata$x:0000A1EC ; Segment type: Pure data
.xdata$x:0000A1EC ; Segment permissions: Read
.xdata$x:0000A1EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A1EC                 assume cs:_xdata$x
.xdata$x:0000A1EC                 ;org 0A1ECh
.xdata$x:0000A1EC ; COMDAT (pick associative to section at 9894)
.xdata$x:0000A1EC __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000A1EC                                         ; DATA XREF: .xdata$x:0000A1FCo
.xdata$x:0000A1ED                 db 0FFh
.xdata$x:0000A1EE                 db 0FFh
.xdata$x:0000A1EF                 db 0FFh
.xdata$x:0000A1F0                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000A1F4 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000A1F4                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000A1F5                 db    5
.xdata$x:0000A1F6                 db  93h ; ô
.xdata$x:0000A1F7                 db  19h
.xdata$x:0000A1F8                 db    1
.xdata$x:0000A1F9                 db    0
.xdata$x:0000A1FA                 db    0
.xdata$x:0000A1FB                 db    0
.xdata$x:0000A1FC                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000A200                 db    0
.xdata$x:0000A201                 db    0
.xdata$x:0000A202                 db    0
.xdata$x:0000A203                 db    0
.xdata$x:0000A204                 db    0
.xdata$x:0000A205                 db    0
.xdata$x:0000A206                 db    0
.xdata$x:0000A207                 db    0
.xdata$x:0000A208                 db    0
.xdata$x:0000A209                 db    0
.xdata$x:0000A20A                 db    0
.xdata$x:0000A20B                 db    0
.xdata$x:0000A20C                 db    0
.xdata$x:0000A20D                 db    0
.xdata$x:0000A20E                 db    0
.xdata$x:0000A20F                 db    0
.xdata$x:0000A210                 db    0
.xdata$x:0000A211                 db    0
.xdata$x:0000A212                 db    0
.xdata$x:0000A213                 db    0
.xdata$x:0000A214                 db    0
.xdata$x:0000A215                 db    0
.xdata$x:0000A216                 db    0
.xdata$x:0000A217                 db    0
.xdata$x:0000A217 _xdata$x        ends
.xdata$x:0000A217
.xdata$x:0000A218 ; ===========================================================================
.xdata$x:0000A218
.xdata$x:0000A218 ; Segment type: Pure data
.xdata$x:0000A218 ; Segment permissions: Read
.xdata$x:0000A218 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A218                 assume cs:_xdata$x
.xdata$x:0000A218                 ;org 0A218h
.xdata$x:0000A218 ; COMDAT (pick associative to section at 6A70)
.xdata$x:0000A218 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000A218                                         ; DATA XREF: .xdata$x:0000A228o
.xdata$x:0000A219                 db 0FFh
.xdata$x:0000A21A                 db 0FFh
.xdata$x:0000A21B                 db 0FFh
.xdata$x:0000A21C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000A220 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000A220                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000A221                 db    5
.xdata$x:0000A222                 db  93h ; ô
.xdata$x:0000A223                 db  19h
.xdata$x:0000A224                 db    1
.xdata$x:0000A225                 db    0
.xdata$x:0000A226                 db    0
.xdata$x:0000A227                 db    0
.xdata$x:0000A228                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000A22C                 db    0
.xdata$x:0000A22D                 db    0
.xdata$x:0000A22E                 db    0
.xdata$x:0000A22F                 db    0
.xdata$x:0000A230                 db    0
.xdata$x:0000A231                 db    0
.xdata$x:0000A232                 db    0
.xdata$x:0000A233                 db    0
.xdata$x:0000A234                 db    0
.xdata$x:0000A235                 db    0
.xdata$x:0000A236                 db    0
.xdata$x:0000A237                 db    0
.xdata$x:0000A238                 db    0
.xdata$x:0000A239                 db    0
.xdata$x:0000A23A                 db    0
.xdata$x:0000A23B                 db    0
.xdata$x:0000A23C                 db    0
.xdata$x:0000A23D                 db    0
.xdata$x:0000A23E                 db    0
.xdata$x:0000A23F                 db    0
.xdata$x:0000A240                 db    0
.xdata$x:0000A241                 db    0
.xdata$x:0000A242                 db    0
.xdata$x:0000A243                 db    0
.xdata$x:0000A243 _xdata$x        ends
.xdata$x:0000A243
.xdata$x:0000A244 ; ===========================================================================
.xdata$x:0000A244
.xdata$x:0000A244 ; Segment type: Pure data
.xdata$x:0000A244 ; Segment permissions: Read
.xdata$x:0000A244 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A244                 assume cs:_xdata$x
.xdata$x:0000A244                 ;org 0A244h
.xdata$x:0000A244 ; COMDAT (pick associative to section at 5EAC)
.xdata$x:0000A244 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000A244                                         ; DATA XREF: .xdata$x:0000A254o
.xdata$x:0000A245                 db 0FFh
.xdata$x:0000A246                 db 0FFh
.xdata$x:0000A247                 db 0FFh
.xdata$x:0000A248                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000A24C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000A24C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000A24D                 db    5
.xdata$x:0000A24E                 db  93h ; ô
.xdata$x:0000A24F                 db  19h
.xdata$x:0000A250                 db    1
.xdata$x:0000A251                 db    0
.xdata$x:0000A252                 db    0
.xdata$x:0000A253                 db    0
.xdata$x:0000A254                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000A258                 db    0
.xdata$x:0000A259                 db    0
.xdata$x:0000A25A                 db    0
.xdata$x:0000A25B                 db    0
.xdata$x:0000A25C                 db    0
.xdata$x:0000A25D                 db    0
.xdata$x:0000A25E                 db    0
.xdata$x:0000A25F                 db    0
.xdata$x:0000A260                 db    0
.xdata$x:0000A261                 db    0
.xdata$x:0000A262                 db    0
.xdata$x:0000A263                 db    0
.xdata$x:0000A264                 db    0
.xdata$x:0000A265                 db    0
.xdata$x:0000A266                 db    0
.xdata$x:0000A267                 db    0
.xdata$x:0000A268                 db    0
.xdata$x:0000A269                 db    0
.xdata$x:0000A26A                 db    0
.xdata$x:0000A26B                 db    0
.xdata$x:0000A26C                 db    0
.xdata$x:0000A26D                 db    0
.xdata$x:0000A26E                 db    0
.xdata$x:0000A26F                 db    0
.xdata$x:0000A26F _xdata$x        ends
.xdata$x:0000A26F
.xdata$x:0000A270 ; ===========================================================================
.xdata$x:0000A270
.xdata$x:0000A270 ; Segment type: Pure data
.xdata$x:0000A270 ; Segment permissions: Read
.xdata$x:0000A270 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A270                 assume cs:_xdata$x
.xdata$x:0000A270                 ;org 0A270h
.xdata$x:0000A270 ; COMDAT (pick associative to section at 994C)
.xdata$x:0000A270 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000A270                                         ; DATA XREF: .xdata$x:0000A280o
.xdata$x:0000A271                 db 0FFh
.xdata$x:0000A272                 db 0FFh
.xdata$x:0000A273                 db 0FFh
.xdata$x:0000A274                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000A278 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000A278                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000A279                 db    5
.xdata$x:0000A27A                 db  93h ; ô
.xdata$x:0000A27B                 db  19h
.xdata$x:0000A27C                 db    1
.xdata$x:0000A27D                 db    0
.xdata$x:0000A27E                 db    0
.xdata$x:0000A27F                 db    0
.xdata$x:0000A280                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000A284                 db    0
.xdata$x:0000A285                 db    0
.xdata$x:0000A286                 db    0
.xdata$x:0000A287                 db    0
.xdata$x:0000A288                 db    0
.xdata$x:0000A289                 db    0
.xdata$x:0000A28A                 db    0
.xdata$x:0000A28B                 db    0
.xdata$x:0000A28C                 db    0
.xdata$x:0000A28D                 db    0
.xdata$x:0000A28E                 db    0
.xdata$x:0000A28F                 db    0
.xdata$x:0000A290                 db    0
.xdata$x:0000A291                 db    0
.xdata$x:0000A292                 db    0
.xdata$x:0000A293                 db    0
.xdata$x:0000A294                 db    0
.xdata$x:0000A295                 db    0
.xdata$x:0000A296                 db    0
.xdata$x:0000A297                 db    0
.xdata$x:0000A298                 db    0
.xdata$x:0000A299                 db    0
.xdata$x:0000A29A                 db    0
.xdata$x:0000A29B                 db    0
.xdata$x:0000A29B _xdata$x        ends
.xdata$x:0000A29B
.xdata$x:0000A29C ; ===========================================================================
.xdata$x:0000A29C
.xdata$x:0000A29C ; Segment type: Pure data
.xdata$x:0000A29C ; Segment permissions: Read
.xdata$x:0000A29C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A29C                 assume cs:_xdata$x
.xdata$x:0000A29C                 ;org 0A29Ch
.xdata$x:0000A29C ; COMDAT (pick associative to section at 6AE0)
.xdata$x:0000A29C __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000A29C                                         ; DATA XREF: .xdata$x:0000A2ACo
.xdata$x:0000A29D                 db 0FFh
.xdata$x:0000A29E                 db 0FFh
.xdata$x:0000A29F                 db 0FFh
.xdata$x:0000A2A0                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000A2A4 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000A2A4                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000A2A5                 db    5
.xdata$x:0000A2A6                 db  93h ; ô
.xdata$x:0000A2A7                 db  19h
.xdata$x:0000A2A8                 db    1
.xdata$x:0000A2A9                 db    0
.xdata$x:0000A2AA                 db    0
.xdata$x:0000A2AB                 db    0
.xdata$x:0000A2AC                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000A2B0                 db    0
.xdata$x:0000A2B1                 db    0
.xdata$x:0000A2B2                 db    0
.xdata$x:0000A2B3                 db    0
.xdata$x:0000A2B4                 db    0
.xdata$x:0000A2B5                 db    0
.xdata$x:0000A2B6                 db    0
.xdata$x:0000A2B7                 db    0
.xdata$x:0000A2B8                 db    0
.xdata$x:0000A2B9                 db    0
.xdata$x:0000A2BA                 db    0
.xdata$x:0000A2BB                 db    0
.xdata$x:0000A2BC                 db    0
.xdata$x:0000A2BD                 db    0
.xdata$x:0000A2BE                 db    0
.xdata$x:0000A2BF                 db    0
.xdata$x:0000A2C0                 db    0
.xdata$x:0000A2C1                 db    0
.xdata$x:0000A2C2                 db    0
.xdata$x:0000A2C3                 db    0
.xdata$x:0000A2C4                 db    0
.xdata$x:0000A2C5                 db    0
.xdata$x:0000A2C6                 db    0
.xdata$x:0000A2C7                 db    0
.xdata$x:0000A2C7 _xdata$x        ends
.xdata$x:0000A2C7
.xdata$x:0000A2C8 ; ===========================================================================
.xdata$x:0000A2C8
.xdata$x:0000A2C8 ; Segment type: Pure data
.xdata$x:0000A2C8 ; Segment permissions: Read
.xdata$x:0000A2C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A2C8                 assume cs:_xdata$x
.xdata$x:0000A2C8                 ;org 0A2C8h
.xdata$x:0000A2C8 ; COMDAT (pick associative to section at 5F7C)
.xdata$x:0000A2C8 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000A2C8                                         ; DATA XREF: .xdata$x:0000A2D8o
.xdata$x:0000A2C9                 db 0FFh
.xdata$x:0000A2CA                 db 0FFh
.xdata$x:0000A2CB                 db 0FFh
.xdata$x:0000A2CC                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000A2D0 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000A2D0                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000A2D1                 db    5
.xdata$x:0000A2D2                 db  93h ; ô
.xdata$x:0000A2D3                 db  19h
.xdata$x:0000A2D4                 db    1
.xdata$x:0000A2D5                 db    0
.xdata$x:0000A2D6                 db    0
.xdata$x:0000A2D7                 db    0
.xdata$x:0000A2D8                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000A2DC                 db    0
.xdata$x:0000A2DD                 db    0
.xdata$x:0000A2DE                 db    0
.xdata$x:0000A2DF                 db    0
.xdata$x:0000A2E0                 db    0
.xdata$x:0000A2E1                 db    0
.xdata$x:0000A2E2                 db    0
.xdata$x:0000A2E3                 db    0
.xdata$x:0000A2E4                 db    0
.xdata$x:0000A2E5                 db    0
.xdata$x:0000A2E6                 db    0
.xdata$x:0000A2E7                 db    0
.xdata$x:0000A2E8                 db    0
.xdata$x:0000A2E9                 db    0
.xdata$x:0000A2EA                 db    0
.xdata$x:0000A2EB                 db    0
.xdata$x:0000A2EC                 db    0
.xdata$x:0000A2ED                 db    0
.xdata$x:0000A2EE                 db    0
.xdata$x:0000A2EF                 db    0
.xdata$x:0000A2F0                 db    0
.xdata$x:0000A2F1                 db    0
.xdata$x:0000A2F2                 db    0
.xdata$x:0000A2F3                 db    0
.xdata$x:0000A2F3 _xdata$x        ends
.xdata$x:0000A2F3
.xdata$x:0000A2F4 ; ===========================================================================
.xdata$x:0000A2F4
.xdata$x:0000A2F4 ; Segment type: Pure data
.xdata$x:0000A2F4 ; Segment permissions: Read
.xdata$x:0000A2F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A2F4                 assume cs:_xdata$x
.xdata$x:0000A2F4                 ;org 0A2F4h
.xdata$x:0000A2F4 ; COMDAT (pick associative to section at 9A10)
.xdata$x:0000A2F4 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000A2F4                                         ; DATA XREF: .xdata$x:0000A304o
.xdata$x:0000A2F5                 db 0FFh
.xdata$x:0000A2F6                 db 0FFh
.xdata$x:0000A2F7                 db 0FFh
.xdata$x:0000A2F8                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000A2FC __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000A2FC                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000A2FD                 db    5
.xdata$x:0000A2FE                 db  93h ; ô
.xdata$x:0000A2FF                 db  19h
.xdata$x:0000A300                 db    1
.xdata$x:0000A301                 db    0
.xdata$x:0000A302                 db    0
.xdata$x:0000A303                 db    0
.xdata$x:0000A304                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000A308                 align 20h
.xdata$x:0000A308 _xdata$x        ends
.xdata$x:0000A308
.xdata$x:0000A320 ; ===========================================================================
.xdata$x:0000A320
.xdata$x:0000A320 ; Segment type: Pure data
.xdata$x:0000A320 ; Segment permissions: Read
.xdata$x:0000A320 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A320                 assume cs:_xdata$x
.xdata$x:0000A320                 ;org 0A320h
.xdata$x:0000A320 ; COMDAT (pick associative to section at 6BD4)
.xdata$x:0000A320 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000A320                                         ; DATA XREF: .xdata$x:0000A330o
.xdata$x:0000A321                 db 0FFh
.xdata$x:0000A322                 db 0FFh
.xdata$x:0000A323                 db 0FFh
.xdata$x:0000A324                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000A328 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000A328                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000A329                 db    5
.xdata$x:0000A32A                 db  93h ; ô
.xdata$x:0000A32B                 db  19h
.xdata$x:0000A32C                 db    1
.xdata$x:0000A32D                 db    0
.xdata$x:0000A32E                 db    0
.xdata$x:0000A32F                 db    0
.xdata$x:0000A330                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000A334                 db    0
.xdata$x:0000A335                 db    0
.xdata$x:0000A336                 db    0
.xdata$x:0000A337                 db    0
.xdata$x:0000A338                 db    0
.xdata$x:0000A339                 db    0
.xdata$x:0000A33A                 db    0
.xdata$x:0000A33B                 db    0
.xdata$x:0000A33C                 db    0
.xdata$x:0000A33D                 db    0
.xdata$x:0000A33E                 db    0
.xdata$x:0000A33F                 db    0
.xdata$x:0000A340                 db    0
.xdata$x:0000A341                 db    0
.xdata$x:0000A342                 db    0
.xdata$x:0000A343                 db    0
.xdata$x:0000A344                 db    0
.xdata$x:0000A345                 db    0
.xdata$x:0000A346                 db    0
.xdata$x:0000A347                 db    0
.xdata$x:0000A348                 db    0
.xdata$x:0000A349                 db    0
.xdata$x:0000A34A                 db    0
.xdata$x:0000A34B                 db    0
.xdata$x:0000A34B _xdata$x        ends
.xdata$x:0000A34B
.xdata$x:0000A34C ; ===========================================================================
.xdata$x:0000A34C
.xdata$x:0000A34C ; Segment type: Pure data
.xdata$x:0000A34C ; Segment permissions: Read
.xdata$x:0000A34C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A34C                 assume cs:_xdata$x
.xdata$x:0000A34C                 ;org 0A34Ch
.xdata$x:0000A34C ; COMDAT (pick associative to section at 5404)
.xdata$x:0000A34C __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A34C                                         ; DATA XREF: .xdata$x:0000A35Co
.xdata$x:0000A34D                 db 0FFh
.xdata$x:0000A34E                 db 0FFh
.xdata$x:0000A34F                 db 0FFh
.xdata$x:0000A350                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000A354 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A354                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000A355                 db    5
.xdata$x:0000A356                 db  93h ; ô
.xdata$x:0000A357                 db  19h
.xdata$x:0000A358                 db    1
.xdata$x:0000A359                 db    0
.xdata$x:0000A35A                 db    0
.xdata$x:0000A35B                 db    0
.xdata$x:0000A35C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000A360                 db    0
.xdata$x:0000A361                 db    0
.xdata$x:0000A362                 db    0
.xdata$x:0000A363                 db    0
.xdata$x:0000A364                 db    0
.xdata$x:0000A365                 db    0
.xdata$x:0000A366                 db    0
.xdata$x:0000A367                 db    0
.xdata$x:0000A368                 db    0
.xdata$x:0000A369                 db    0
.xdata$x:0000A36A                 db    0
.xdata$x:0000A36B                 db    0
.xdata$x:0000A36C                 db    0
.xdata$x:0000A36D                 db    0
.xdata$x:0000A36E                 db    0
.xdata$x:0000A36F                 db    0
.xdata$x:0000A370                 db    0
.xdata$x:0000A371                 db    0
.xdata$x:0000A372                 db    0
.xdata$x:0000A373                 db    0
.xdata$x:0000A374                 db    0
.xdata$x:0000A375                 db    0
.xdata$x:0000A376                 db    0
.xdata$x:0000A377                 db    0
.xdata$x:0000A377 _xdata$x        ends
.xdata$x:0000A377
.xdata$x:0000A378 ; ===========================================================================
.xdata$x:0000A378
.xdata$x:0000A378 ; Segment type: Pure data
.xdata$x:0000A378 ; Segment permissions: Read
.xdata$x:0000A378 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A378                 assume cs:_xdata$x
.xdata$x:0000A378                 ;org 0A378h
.xdata$x:0000A378 ; COMDAT (pick associative to section at 6404)
.xdata$x:0000A378 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A378                                         ; DATA XREF: .xdata$x:0000A388o
.xdata$x:0000A379                 db 0FFh
.xdata$x:0000A37A                 db 0FFh
.xdata$x:0000A37B                 db 0FFh
.xdata$x:0000A37C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000A380 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A380                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000A381                 db    5
.xdata$x:0000A382                 db  93h ; ô
.xdata$x:0000A383                 db  19h
.xdata$x:0000A384                 db    1
.xdata$x:0000A385                 db    0
.xdata$x:0000A386                 db    0
.xdata$x:0000A387                 db    0
.xdata$x:0000A388                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000A38C                 db    0
.xdata$x:0000A38D                 db    0
.xdata$x:0000A38E                 db    0
.xdata$x:0000A38F                 db    0
.xdata$x:0000A390                 db    0
.xdata$x:0000A391                 db    0
.xdata$x:0000A392                 db    0
.xdata$x:0000A393                 db    0
.xdata$x:0000A394                 db    0
.xdata$x:0000A395                 db    0
.xdata$x:0000A396                 db    0
.xdata$x:0000A397                 db    0
.xdata$x:0000A398                 db    0
.xdata$x:0000A399                 db    0
.xdata$x:0000A39A                 db    0
.xdata$x:0000A39B                 db    0
.xdata$x:0000A39C                 db    0
.xdata$x:0000A39D                 db    0
.xdata$x:0000A39E                 db    0
.xdata$x:0000A39F                 db    0
.xdata$x:0000A3A0                 db    0
.xdata$x:0000A3A1                 db    0
.xdata$x:0000A3A2                 db    0
.xdata$x:0000A3A3                 db    0
.xdata$x:0000A3A3 _xdata$x        ends
.xdata$x:0000A3A3
.xdata$x:0000A3A4 ; ===========================================================================
.xdata$x:0000A3A4
.xdata$x:0000A3A4 ; Segment type: Pure data
.xdata$x:0000A3A4 ; Segment permissions: Read
.xdata$x:0000A3A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A3A4                 assume cs:_xdata$x
.xdata$x:0000A3A4                 ;org 0A3A4h
.xdata$x:0000A3A4 ; COMDAT (pick associative to section at 5300)
.xdata$x:0000A3A4 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000A3A4                                         ; DATA XREF: .xdata$x:0000A3B4o
.xdata$x:0000A3A5                 db 0FFh
.xdata$x:0000A3A6                 db 0FFh
.xdata$x:0000A3A7                 db 0FFh
.xdata$x:0000A3A8                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000A3AC __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000A3AC                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000A3AD                 db    5
.xdata$x:0000A3AE                 db  93h ; ô
.xdata$x:0000A3AF                 db  19h
.xdata$x:0000A3B0                 db    1
.xdata$x:0000A3B1                 db    0
.xdata$x:0000A3B2                 db    0
.xdata$x:0000A3B3                 db    0
.xdata$x:0000A3B4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000A3B8                 db    0
.xdata$x:0000A3B9                 db    0
.xdata$x:0000A3BA                 db    0
.xdata$x:0000A3BB                 db    0
.xdata$x:0000A3BC                 db    0
.xdata$x:0000A3BD                 db    0
.xdata$x:0000A3BE                 db    0
.xdata$x:0000A3BF                 db    0
.xdata$x:0000A3C0                 db    0
.xdata$x:0000A3C1                 db    0
.xdata$x:0000A3C2                 db    0
.xdata$x:0000A3C3                 db    0
.xdata$x:0000A3C4                 db    0
.xdata$x:0000A3C5                 db    0
.xdata$x:0000A3C6                 db    0
.xdata$x:0000A3C7                 db    0
.xdata$x:0000A3C8                 db    0
.xdata$x:0000A3C9                 db    0
.xdata$x:0000A3CA                 db    0
.xdata$x:0000A3CB                 db    0
.xdata$x:0000A3CC                 db    0
.xdata$x:0000A3CD                 db    0
.xdata$x:0000A3CE                 db    0
.xdata$x:0000A3CF                 db    0
.xdata$x:0000A3CF _xdata$x        ends
.xdata$x:0000A3CF
.xdata$x:0000A3D0 ; ===========================================================================
.xdata$x:0000A3D0
.xdata$x:0000A3D0 ; Segment type: Pure data
.xdata$x:0000A3D0 ; Segment permissions: Read
.xdata$x:0000A3D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A3D0                 assume cs:_xdata$x
.xdata$x:0000A3D0                 ;org 0A3D0h
.xdata$x:0000A3D0 ; COMDAT (pick associative to section at 631C)
.xdata$x:0000A3D0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A3D0                                         ; DATA XREF: .xdata$x:0000A3E0o
.xdata$x:0000A3D1                 db 0FFh
.xdata$x:0000A3D2                 db 0FFh
.xdata$x:0000A3D3                 db 0FFh
.xdata$x:0000A3D4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A3D8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A3D8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A3D9                 db    5
.xdata$x:0000A3DA                 db  93h ; ô
.xdata$x:0000A3DB                 db  19h
.xdata$x:0000A3DC                 db    1
.xdata$x:0000A3DD                 db    0
.xdata$x:0000A3DE                 db    0
.xdata$x:0000A3DF                 db    0
.xdata$x:0000A3E0                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A3E4                 db    0
.xdata$x:0000A3E5                 db    0
.xdata$x:0000A3E6                 db    0
.xdata$x:0000A3E7                 db    0
.xdata$x:0000A3E8                 db    0
.xdata$x:0000A3E9                 db    0
.xdata$x:0000A3EA                 db    0
.xdata$x:0000A3EB                 db    0
.xdata$x:0000A3EC                 db    0
.xdata$x:0000A3ED                 db    0
.xdata$x:0000A3EE                 db    0
.xdata$x:0000A3EF                 db    0
.xdata$x:0000A3F0                 db    0
.xdata$x:0000A3F1                 db    0
.xdata$x:0000A3F2                 db    0
.xdata$x:0000A3F3                 db    0
.xdata$x:0000A3F4                 db    0
.xdata$x:0000A3F5                 db    0
.xdata$x:0000A3F6                 db    0
.xdata$x:0000A3F7                 db    0
.xdata$x:0000A3F8                 db    0
.xdata$x:0000A3F9                 db    0
.xdata$x:0000A3FA                 db    0
.xdata$x:0000A3FB                 db    0
.xdata$x:0000A3FB _xdata$x        ends
.xdata$x:0000A3FB
.xdata$x:0000A3FC ; ===========================================================================
.xdata$x:0000A3FC
.xdata$x:0000A3FC ; Segment type: Pure data
.xdata$x:0000A3FC ; Segment permissions: Read
.xdata$x:0000A3FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A3FC                 assume cs:_xdata$x
.xdata$x:0000A3FC                 ;org 0A3FCh
.xdata$x:0000A3FC ; COMDAT (pick associative to section at 5B9C)
.xdata$x:0000A3FC __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:0000A3FC                                         ; DATA XREF: .xdata$x:0000A40Co
.xdata$x:0000A3FD                 db 0FFh
.xdata$x:0000A3FE                 db 0FFh
.xdata$x:0000A3FF                 db 0FFh
.xdata$x:0000A400                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:0000A404 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:0000A404                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:0000A405                 db    5
.xdata$x:0000A406                 db  93h ; ô
.xdata$x:0000A407                 db  19h
.xdata$x:0000A408                 db    1
.xdata$x:0000A409                 db    0
.xdata$x:0000A40A                 db    0
.xdata$x:0000A40B                 db    0
.xdata$x:0000A40C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:0000A410                 db    0
.xdata$x:0000A411                 db    0
.xdata$x:0000A412                 db    0
.xdata$x:0000A413                 db    0
.xdata$x:0000A414                 db    0
.xdata$x:0000A415                 db    0
.xdata$x:0000A416                 db    0
.xdata$x:0000A417                 db    0
.xdata$x:0000A418                 db    0
.xdata$x:0000A419                 db    0
.xdata$x:0000A41A                 db    0
.xdata$x:0000A41B                 db    0
.xdata$x:0000A41C                 db    0
.xdata$x:0000A41D                 db    0
.xdata$x:0000A41E                 db    0
.xdata$x:0000A41F                 db    0
.xdata$x:0000A420                 db    0
.xdata$x:0000A421                 db    0
.xdata$x:0000A422                 db    0
.xdata$x:0000A423                 db    0
.xdata$x:0000A424                 db    0
.xdata$x:0000A425                 db    0
.xdata$x:0000A426                 db    0
.xdata$x:0000A427                 db    0
.xdata$x:0000A427 _xdata$x        ends
.xdata$x:0000A427
.xdata$x:0000A428 ; ===========================================================================
.xdata$x:0000A428
.xdata$x:0000A428 ; Segment type: Pure data
.xdata$x:0000A428 ; Segment permissions: Read
.xdata$x:0000A428 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A428                 assume cs:_xdata$x
.xdata$x:0000A428                 ;org 0A428h
.xdata$x:0000A428 ; COMDAT (pick associative to section at 5B00)
.xdata$x:0000A428 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z db 0FFh
.xdata$x:0000A428                                         ; DATA XREF: .xdata$x:0000A438o
.xdata$x:0000A429                 db 0FFh
.xdata$x:0000A42A                 db 0FFh
.xdata$x:0000A42B                 db 0FFh
.xdata$x:0000A42C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z$0
.xdata$x:0000A430 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z db  22h ; "
.xdata$x:0000A430                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z+11o
.xdata$x:0000A431                 db    5
.xdata$x:0000A432                 db  93h ; ô
.xdata$x:0000A433                 db  19h
.xdata$x:0000A434                 db    1
.xdata$x:0000A435                 db    0
.xdata$x:0000A436                 db    0
.xdata$x:0000A437                 db    0
.xdata$x:0000A438                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
.xdata$x:0000A43C                 db    0
.xdata$x:0000A43D                 db    0
.xdata$x:0000A43E                 db    0
.xdata$x:0000A43F                 db    0
.xdata$x:0000A440                 db    0
.xdata$x:0000A441                 db    0
.xdata$x:0000A442                 db    0
.xdata$x:0000A443                 db    0
.xdata$x:0000A444                 db    0
.xdata$x:0000A445                 db    0
.xdata$x:0000A446                 db    0
.xdata$x:0000A447                 db    0
.xdata$x:0000A448                 db    0
.xdata$x:0000A449                 db    0
.xdata$x:0000A44A                 db    0
.xdata$x:0000A44B                 db    0
.xdata$x:0000A44C                 db    0
.xdata$x:0000A44D                 db    0
.xdata$x:0000A44E                 db    0
.xdata$x:0000A44F                 db    0
.xdata$x:0000A450                 db    0
.xdata$x:0000A451                 db    0
.xdata$x:0000A452                 db    0
.xdata$x:0000A453                 db    0
.xdata$x:0000A453 _xdata$x        ends
.xdata$x:0000A453
.xdata$x:0000A454 ; ===========================================================================
.xdata$x:0000A454
.xdata$x:0000A454 ; Segment type: Pure data
.xdata$x:0000A454 ; Segment permissions: Read
.xdata$x:0000A454 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A454                 assume cs:_xdata$x
.xdata$x:0000A454                 ;org 0A454h
.xdata$x:0000A454 ; COMDAT (pick associative to section at 6880)
.xdata$x:0000A454 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A454                                         ; DATA XREF: .xdata$x:0000A464o
.xdata$x:0000A455                 db 0FFh
.xdata$x:0000A456                 db 0FFh
.xdata$x:0000A457                 db 0FFh
.xdata$x:0000A458                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000A45C __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A45C                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000A45D                 db    5
.xdata$x:0000A45E                 db  93h ; ô
.xdata$x:0000A45F                 db  19h
.xdata$x:0000A460                 db    1
.xdata$x:0000A461                 db    0
.xdata$x:0000A462                 db    0
.xdata$x:0000A463                 db    0
.xdata$x:0000A464                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000A468                 align 20h
.xdata$x:0000A468 _xdata$x        ends
.xdata$x:0000A468
.xdata$x:0000A480 ; ===========================================================================
.xdata$x:0000A480
.xdata$x:0000A480 ; Segment type: Pure data
.xdata$x:0000A480 ; Segment permissions: Read
.xdata$x:0000A480 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A480                 assume cs:_xdata$x
.xdata$x:0000A480                 ;org 0A480h
.xdata$x:0000A480 ; COMDAT (pick associative to section at 77FC)
.xdata$x:0000A480 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000A480                                         ; DATA XREF: .xdata$x:0000A508o
.xdata$x:0000A481                 db    0
.xdata$x:0000A482                 db    0
.xdata$x:0000A483                 db    0
.xdata$x:0000A484                 db    0
.xdata$x:0000A485                 db    0
.xdata$x:0000A486                 db    0
.xdata$x:0000A487                 db    0
.xdata$x:0000A488                 db    0
.xdata$x:0000A489                 db    0
.xdata$x:0000A48A                 db    0
.xdata$x:0000A48B                 db    0
.xdata$x:0000A48C                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:0000A490 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000A490                                         ; DATA XREF: .xdata$x:0000A4F4o
.xdata$x:0000A491                 db    0
.xdata$x:0000A492                 db    0
.xdata$x:0000A493                 db    0
.xdata$x:0000A494                 db    0
.xdata$x:0000A495                 db    0
.xdata$x:0000A496                 db    0
.xdata$x:0000A497                 db    0
.xdata$x:0000A498                 db    0
.xdata$x:0000A499                 db    0
.xdata$x:0000A49A                 db    0
.xdata$x:0000A49B                 db    0
.xdata$x:0000A49C                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:0000A4A0 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000A4A0                                         ; DATA XREF: .xdata$x:0000A4C8o
.xdata$x:0000A4A1                 db 0FFh
.xdata$x:0000A4A2                 db 0FFh
.xdata$x:0000A4A3                 db 0FFh
.xdata$x:0000A4A4                 db    0
.xdata$x:0000A4A5                 db    0
.xdata$x:0000A4A6                 db    0
.xdata$x:0000A4A7                 db    0
.xdata$x:0000A4A8                 db 0FFh
.xdata$x:0000A4A9                 db 0FFh
.xdata$x:0000A4AA                 db 0FFh
.xdata$x:0000A4AB                 db 0FFh
.xdata$x:0000A4AC                 db    0
.xdata$x:0000A4AD                 db    0
.xdata$x:0000A4AE                 db    0
.xdata$x:0000A4AF                 db    0
.xdata$x:0000A4B0                 db    1
.xdata$x:0000A4B1                 db    0
.xdata$x:0000A4B2                 db    0
.xdata$x:0000A4B3                 db    0
.xdata$x:0000A4B4                 db    0
.xdata$x:0000A4B5                 db    0
.xdata$x:0000A4B6                 db    0
.xdata$x:0000A4B7                 db    0
.xdata$x:0000A4B8                 db    1
.xdata$x:0000A4B9                 db    0
.xdata$x:0000A4BA                 db    0
.xdata$x:0000A4BB                 db    0
.xdata$x:0000A4BC                 db    0
.xdata$x:0000A4BD                 db    0
.xdata$x:0000A4BE                 db    0
.xdata$x:0000A4BF                 db    0
.xdata$x:0000A4C0 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000A4C0                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:0000A4C1                 db    5
.xdata$x:0000A4C2                 db  93h ; ô
.xdata$x:0000A4C3                 db  19h
.xdata$x:0000A4C4                 db    4
.xdata$x:0000A4C5                 db    0
.xdata$x:0000A4C6                 db    0
.xdata$x:0000A4C7                 db    0
.xdata$x:0000A4C8                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000A4CC                 db    2
.xdata$x:0000A4CD                 db    0
.xdata$x:0000A4CE                 db    0
.xdata$x:0000A4CF                 db    0
.xdata$x:0000A4D0                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000A4D4                 db    0
.xdata$x:0000A4D5                 db    0
.xdata$x:0000A4D6                 db    0
.xdata$x:0000A4D7                 db    0
.xdata$x:0000A4D8                 db    0
.xdata$x:0000A4D9                 db    0
.xdata$x:0000A4DA                 db    0
.xdata$x:0000A4DB                 db    0
.xdata$x:0000A4DC                 db    0
.xdata$x:0000A4DD                 db    0
.xdata$x:0000A4DE                 db    0
.xdata$x:0000A4DF                 db    0
.xdata$x:0000A4E0                 db    0
.xdata$x:0000A4E1                 db    0
.xdata$x:0000A4E2                 db    0
.xdata$x:0000A4E3                 db    0
.xdata$x:0000A4E4 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000A4E4                                         ; DATA XREF: .xdata$x:0000A4D0o
.xdata$x:0000A4E5                 db    0
.xdata$x:0000A4E6                 db    0
.xdata$x:0000A4E7                 db    0
.xdata$x:0000A4E8                 db    2
.xdata$x:0000A4E9                 db    0
.xdata$x:0000A4EA                 db    0
.xdata$x:0000A4EB                 db    0
.xdata$x:0000A4EC                 db    3
.xdata$x:0000A4ED                 db    0
.xdata$x:0000A4EE                 db    0
.xdata$x:0000A4EF                 db    0
.xdata$x:0000A4F0                 db    1
.xdata$x:0000A4F1                 db    0
.xdata$x:0000A4F2                 db    0
.xdata$x:0000A4F3                 db    0
.xdata$x:0000A4F4                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000A4F8                 align 10h
.xdata$x:0000A500                 db    3
.xdata$x:0000A501                 db    0
.xdata$x:0000A502                 db    0
.xdata$x:0000A503                 db    0
.xdata$x:0000A504                 db    1
.xdata$x:0000A505                 db    0
.xdata$x:0000A506                 db    0
.xdata$x:0000A507                 db    0
.xdata$x:0000A508                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000A508 _xdata$x        ends
.xdata$x:0000A508
.xdata$x:0000A50C ; ===========================================================================
.xdata$x:0000A50C
.xdata$x:0000A50C ; Segment type: Pure data
.xdata$x:0000A50C ; Segment permissions: Read
.xdata$x:0000A50C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A50C                 assume cs:_xdata$x
.xdata$x:0000A50C                 ;org 0A50Ch
.xdata$x:0000A50C ; COMDAT (pick associative to section at 5910)
.xdata$x:0000A50C __unwindtable$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A50C                                         ; DATA XREF: .xdata$x:0000A51Co
.xdata$x:0000A50D                 db 0FFh
.xdata$x:0000A50E                 db 0FFh
.xdata$x:0000A50F                 db 0FFh
.xdata$x:0000A510                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0
.xdata$x:0000A514 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A514                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000A515                 db    5
.xdata$x:0000A516                 db  93h ; ô
.xdata$x:0000A517                 db  19h
.xdata$x:0000A518                 db    1
.xdata$x:0000A519                 db    0
.xdata$x:0000A51A                 db    0
.xdata$x:0000A51B                 db    0
.xdata$x:0000A51C                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.xdata$x:0000A520                 db    0
.xdata$x:0000A521                 db    0
.xdata$x:0000A522                 db    0
.xdata$x:0000A523                 db    0
.xdata$x:0000A524                 db    0
.xdata$x:0000A525                 db    0
.xdata$x:0000A526                 db    0
.xdata$x:0000A527                 db    0
.xdata$x:0000A528                 db    0
.xdata$x:0000A529                 db    0
.xdata$x:0000A52A                 db    0
.xdata$x:0000A52B                 db    0
.xdata$x:0000A52C                 db    0
.xdata$x:0000A52D                 db    0
.xdata$x:0000A52E                 db    0
.xdata$x:0000A52F                 db    0
.xdata$x:0000A530                 db    0
.xdata$x:0000A531                 db    0
.xdata$x:0000A532                 db    0
.xdata$x:0000A533                 db    0
.xdata$x:0000A534                 db    0
.xdata$x:0000A535                 db    0
.xdata$x:0000A536                 db    0
.xdata$x:0000A537                 db    0
.xdata$x:0000A537 _xdata$x        ends
.xdata$x:0000A537
.xdata$x:0000A538 ; ===========================================================================
.xdata$x:0000A538
.xdata$x:0000A538 ; Segment type: Pure data
.xdata$x:0000A538 ; Segment permissions: Read
.xdata$x:0000A538 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A538                 assume cs:_xdata$x
.xdata$x:0000A538                 ;org 0A538h
.xdata$x:0000A538 ; COMDAT (pick associative to section at 6724)
.xdata$x:0000A538 __unwindtable$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A538                                         ; DATA XREF: .xdata$x:0000A548o
.xdata$x:0000A539                 db 0FFh
.xdata$x:0000A53A                 db 0FFh
.xdata$x:0000A53B                 db 0FFh
.xdata$x:0000A53C                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ$0
.xdata$x:0000A540 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A540                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000A541                 db    5
.xdata$x:0000A542                 db  93h ; ô
.xdata$x:0000A543                 db  19h
.xdata$x:0000A544                 db    1
.xdata$x:0000A545                 db    0
.xdata$x:0000A546                 db    0
.xdata$x:0000A547                 db    0
.xdata$x:0000A548                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
.xdata$x:0000A54C                 db    0
.xdata$x:0000A54D                 db    0
.xdata$x:0000A54E                 db    0
.xdata$x:0000A54F                 db    0
.xdata$x:0000A550                 db    0
.xdata$x:0000A551                 db    0
.xdata$x:0000A552                 db    0
.xdata$x:0000A553                 db    0
.xdata$x:0000A554                 db    0
.xdata$x:0000A555                 db    0
.xdata$x:0000A556                 db    0
.xdata$x:0000A557                 db    0
.xdata$x:0000A558                 db    0
.xdata$x:0000A559                 db    0
.xdata$x:0000A55A                 db    0
.xdata$x:0000A55B                 db    0
.xdata$x:0000A55C                 db    0
.xdata$x:0000A55D                 db    0
.xdata$x:0000A55E                 db    0
.xdata$x:0000A55F                 db    0
.xdata$x:0000A560                 db    0
.xdata$x:0000A561                 db    0
.xdata$x:0000A562                 db    0
.xdata$x:0000A563                 db    0
.xdata$x:0000A563 _xdata$x        ends
.xdata$x:0000A563
.xdata$x:0000A564 ; ===========================================================================
.xdata$x:0000A564
.xdata$x:0000A564 ; Segment type: Pure data
.xdata$x:0000A564 ; Segment permissions: Read
.xdata$x:0000A564 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A564                 assume cs:_xdata$x
.xdata$x:0000A564                 ;org 0A564h
.xdata$x:0000A564 ; COMDAT (pick associative to section at 548C)
.xdata$x:0000A564 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z db 0FFh
.xdata$x:0000A564                                         ; DATA XREF: .xdata$x:0000A574o
.xdata$x:0000A565                 db 0FFh
.xdata$x:0000A566                 db 0FFh
.xdata$x:0000A567                 db 0FFh
.xdata$x:0000A568                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z$0
.xdata$x:0000A56C __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z db  22h ; "
.xdata$x:0000A56C                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z+11o
.xdata$x:0000A56D                 db    5
.xdata$x:0000A56E                 db  93h ; ô
.xdata$x:0000A56F                 db  19h
.xdata$x:0000A570                 db    1
.xdata$x:0000A571                 db    0
.xdata$x:0000A572                 db    0
.xdata$x:0000A573                 db    0
.xdata$x:0000A574                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
.xdata$x:0000A578                 db    0
.xdata$x:0000A579                 db    0
.xdata$x:0000A57A                 db    0
.xdata$x:0000A57B                 db    0
.xdata$x:0000A57C                 db    0
.xdata$x:0000A57D                 db    0
.xdata$x:0000A57E                 db    0
.xdata$x:0000A57F                 db    0
.xdata$x:0000A580                 db    0
.xdata$x:0000A581                 db    0
.xdata$x:0000A582                 db    0
.xdata$x:0000A583                 db    0
.xdata$x:0000A584                 db    0
.xdata$x:0000A585                 db    0
.xdata$x:0000A586                 db    0
.xdata$x:0000A587                 db    0
.xdata$x:0000A588                 db    0
.xdata$x:0000A589                 db    0
.xdata$x:0000A58A                 db    0
.xdata$x:0000A58B                 db    0
.xdata$x:0000A58C                 db    0
.xdata$x:0000A58D                 db    0
.xdata$x:0000A58E                 db    0
.xdata$x:0000A58F                 db    0
.xdata$x:0000A58F _xdata$x        ends
.xdata$x:0000A58F
.xdata$x:0000A590 ; ===========================================================================
.xdata$x:0000A590
.xdata$x:0000A590 ; Segment type: Pure data
.xdata$x:0000A590 ; Segment permissions: Read
.xdata$x:0000A590 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A590                 assume cs:_xdata$x
.xdata$x:0000A590                 ;org 0A590h
.xdata$x:0000A590 ; COMDAT (pick associative to section at 6474)
.xdata$x:0000A590 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A590                                         ; DATA XREF: .xdata$x:0000A5A0o
.xdata$x:0000A591                 db 0FFh
.xdata$x:0000A592                 db 0FFh
.xdata$x:0000A593                 db 0FFh
.xdata$x:0000A594                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A598 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A598                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A599                 db    5
.xdata$x:0000A59A                 db  93h ; ô
.xdata$x:0000A59B                 db  19h
.xdata$x:0000A59C                 db    1
.xdata$x:0000A59D                 db    0
.xdata$x:0000A59E                 db    0
.xdata$x:0000A59F                 db    0
.xdata$x:0000A5A0                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A5A4                 db    0
.xdata$x:0000A5A5                 db    0
.xdata$x:0000A5A6                 db    0
.xdata$x:0000A5A7                 db    0
.xdata$x:0000A5A8                 db    0
.xdata$x:0000A5A9                 db    0
.xdata$x:0000A5AA                 db    0
.xdata$x:0000A5AB                 db    0
.xdata$x:0000A5AC                 db    0
.xdata$x:0000A5AD                 db    0
.xdata$x:0000A5AE                 db    0
.xdata$x:0000A5AF                 db    0
.xdata$x:0000A5B0                 db    0
.xdata$x:0000A5B1                 db    0
.xdata$x:0000A5B2                 db    0
.xdata$x:0000A5B3                 db    0
.xdata$x:0000A5B4                 db    0
.xdata$x:0000A5B5                 db    0
.xdata$x:0000A5B6                 db    0
.xdata$x:0000A5B7                 db    0
.xdata$x:0000A5B8                 db    0
.xdata$x:0000A5B9                 db    0
.xdata$x:0000A5BA                 db    0
.xdata$x:0000A5BB                 db    0
.xdata$x:0000A5BB _xdata$x        ends
.xdata$x:0000A5BB
.xdata$x:0000A5BC ; ===========================================================================
.xdata$x:0000A5BC
.xdata$x:0000A5BC ; Segment type: Pure data
.xdata$x:0000A5BC ; Segment permissions: Read
.xdata$x:0000A5BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A5BC                 assume cs:_xdata$x
.xdata$x:0000A5BC                 ;org 0A5BCh
.xdata$x:0000A5BC ; COMDAT (pick associative to section at 5D64)
.xdata$x:0000A5BC __unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A5BC                                         ; DATA XREF: .xdata$x:0000A5CCo
.xdata$x:0000A5BD                 db 0FFh
.xdata$x:0000A5BE                 db 0FFh
.xdata$x:0000A5BF                 db 0FFh
.xdata$x:0000A5C0                 dd offset __unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
.xdata$x:0000A5C4 __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A5C4                                         ; DATA XREF: __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000A5C5                 db    5
.xdata$x:0000A5C6                 db  93h ; ô
.xdata$x:0000A5C7                 db  19h
.xdata$x:0000A5C8                 db    1
.xdata$x:0000A5C9                 db    0
.xdata$x:0000A5CA                 db    0
.xdata$x:0000A5CB                 db    0
.xdata$x:0000A5CC                 dd offset __unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.xdata$x:0000A5D0                 db    0
.xdata$x:0000A5D1                 db    0
.xdata$x:0000A5D2                 db    0
.xdata$x:0000A5D3                 db    0
.xdata$x:0000A5D4                 db    0
.xdata$x:0000A5D5                 db    0
.xdata$x:0000A5D6                 db    0
.xdata$x:0000A5D7                 db    0
.xdata$x:0000A5D8                 db    0
.xdata$x:0000A5D9                 db    0
.xdata$x:0000A5DA                 db    0
.xdata$x:0000A5DB                 db    0
.xdata$x:0000A5DC                 db    0
.xdata$x:0000A5DD                 db    0
.xdata$x:0000A5DE                 db    0
.xdata$x:0000A5DF                 db    0
.xdata$x:0000A5E0                 db    0
.xdata$x:0000A5E1                 db    0
.xdata$x:0000A5E2                 db    0
.xdata$x:0000A5E3                 db    0
.xdata$x:0000A5E4                 db    0
.xdata$x:0000A5E5                 db    0
.xdata$x:0000A5E6                 db    0
.xdata$x:0000A5E7                 db    0
.xdata$x:0000A5E7 _xdata$x        ends
.xdata$x:0000A5E7
.xdata$x:0000A5E8 ; ===========================================================================
.xdata$x:0000A5E8
.xdata$x:0000A5E8 ; Segment type: Pure data
.xdata$x:0000A5E8 ; Segment permissions: Read
.xdata$x:0000A5E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A5E8                 assume cs:_xdata$x
.xdata$x:0000A5E8                 ;org 0A5E8h
.xdata$x:0000A5E8 ; COMDAT (pick associative to section at 696C)
.xdata$x:0000A5E8 __unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A5E8                                         ; DATA XREF: .xdata$x:0000A5F8o
.xdata$x:0000A5E9                 db 0FFh
.xdata$x:0000A5EA                 db 0FFh
.xdata$x:0000A5EB                 db 0FFh
.xdata$x:0000A5EC                 dd offset __unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
.xdata$x:0000A5F0 __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A5F0                                         ; DATA XREF: __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ+11o
.xdata$x:0000A5F1                 db    5
.xdata$x:0000A5F2                 db  93h ; ô
.xdata$x:0000A5F3                 db  19h
.xdata$x:0000A5F4                 db    1
.xdata$x:0000A5F5                 db    0
.xdata$x:0000A5F6                 db    0
.xdata$x:0000A5F7                 db    0
.xdata$x:0000A5F8                 dd offset __unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
.xdata$x:0000A5FC                 db    0
.xdata$x:0000A5FD                 db    0
.xdata$x:0000A5FE                 db    0
.xdata$x:0000A5FF                 db    0
.xdata$x:0000A600                 db    0
.xdata$x:0000A601                 db    0
.xdata$x:0000A602                 db    0
.xdata$x:0000A603                 db    0
.xdata$x:0000A604                 db    0
.xdata$x:0000A605                 db    0
.xdata$x:0000A606                 db    0
.xdata$x:0000A607                 db    0
.xdata$x:0000A608                 db    0
.xdata$x:0000A609                 db    0
.xdata$x:0000A60A                 db    0
.xdata$x:0000A60B                 db    0
.xdata$x:0000A60C                 db    0
.xdata$x:0000A60D                 db    0
.xdata$x:0000A60E                 db    0
.xdata$x:0000A60F                 db    0
.xdata$x:0000A610                 db    0
.xdata$x:0000A611                 db    0
.xdata$x:0000A612                 db    0
.xdata$x:0000A613                 db    0
.xdata$x:0000A613 _xdata$x        ends
.xdata$x:0000A613
.xdata$x:0000A614 ; ===========================================================================
.xdata$x:0000A614
.xdata$x:0000A614 ; Segment type: Pure data
.xdata$x:0000A614 ; Segment permissions: Read
.xdata$x:0000A614 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A614                 assume cs:_xdata$x
.xdata$x:0000A614                 ;org 0A614h
.xdata$x:0000A614 ; COMDAT (pick associative to section at 9080)
.xdata$x:0000A614 __unwindtable$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A614                                         ; DATA XREF: .xdata$x:0000A624o
.xdata$x:0000A615                 db 0FFh
.xdata$x:0000A616                 db 0FFh
.xdata$x:0000A617                 db 0FFh
.xdata$x:0000A618                 dd offset __unwindfunclet$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0
.xdata$x:0000A61C __ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A61C                                         ; DATA XREF: __ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ+11o
.xdata$x:0000A61D                 db    5
.xdata$x:0000A61E                 db  93h ; ô
.xdata$x:0000A61F                 db  19h
.xdata$x:0000A620                 db    1
.xdata$x:0000A621                 db    0
.xdata$x:0000A622                 db    0
.xdata$x:0000A623                 db    0
.xdata$x:0000A624                 dd offset __unwindtable$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.xdata$x:0000A628                 align 20h
.xdata$x:0000A628 _xdata$x        ends
.xdata$x:0000A628
.xdata$x:0000A640 ; ===========================================================================
.xdata$x:0000A640
.xdata$x:0000A640 ; Segment type: Pure data
.xdata$x:0000A640 ; Segment permissions: Read
.xdata$x:0000A640 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A640                 assume cs:_xdata$x
.xdata$x:0000A640                 ;org 0A640h
.xdata$x:0000A640 ; COMDAT (pick associative to section at 9C5C)
.xdata$x:0000A640 __unwindtable$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A640                                         ; DATA XREF: .xdata$x:0000A660o
.xdata$x:0000A641                 db 0FFh
.xdata$x:0000A642                 db 0FFh
.xdata$x:0000A643                 db 0FFh
.xdata$x:0000A644                 dd offset __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$2
.xdata$x:0000A648                 db    0
.xdata$x:0000A649                 db    0
.xdata$x:0000A64A                 db    0
.xdata$x:0000A64B                 db    0
.xdata$x:0000A64C                 dd offset __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$0
.xdata$x:0000A650                 db    0
.xdata$x:0000A651                 db    0
.xdata$x:0000A652                 db    0
.xdata$x:0000A653                 db    0
.xdata$x:0000A654                 dd offset __unwindfunclet$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ$1
.xdata$x:0000A658 __ehfuncinfo$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A658                                         ; DATA XREF: __ehhandler$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A659                 db    5
.xdata$x:0000A65A                 db  93h ; ô
.xdata$x:0000A65B                 db  19h
.xdata$x:0000A65C                 db    3
.xdata$x:0000A65D                 db    0
.xdata$x:0000A65E                 db    0
.xdata$x:0000A65F                 db    0
.xdata$x:0000A660                 dd offset __unwindtable$?rbegin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@2@XZ
.xdata$x:0000A664                 db    0
.xdata$x:0000A665                 db    0
.xdata$x:0000A666                 db    0
.xdata$x:0000A667                 db    0
.xdata$x:0000A668                 db    0
.xdata$x:0000A669                 db    0
.xdata$x:0000A66A                 db    0
.xdata$x:0000A66B                 db    0
.xdata$x:0000A66C                 db    0
.xdata$x:0000A66D                 db    0
.xdata$x:0000A66E                 db    0
.xdata$x:0000A66F                 db    0
.xdata$x:0000A670                 db    0
.xdata$x:0000A671                 db    0
.xdata$x:0000A672                 db    0
.xdata$x:0000A673                 db    0
.xdata$x:0000A674                 db    0
.xdata$x:0000A675                 db    0
.xdata$x:0000A676                 db    0
.xdata$x:0000A677                 db    0
.xdata$x:0000A678                 db    0
.xdata$x:0000A679                 db    0
.xdata$x:0000A67A                 db    0
.xdata$x:0000A67B                 db    0
.xdata$x:0000A67B _xdata$x        ends
.xdata$x:0000A67B
.xdata$x:0000A67C ; ===========================================================================
.xdata$x:0000A67C
.xdata$x:0000A67C ; Segment type: Pure data
.xdata$x:0000A67C ; Segment permissions: Read
.xdata$x:0000A67C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A67C                 assume cs:_xdata$x
.xdata$x:0000A67C                 ;org 0A67Ch
.xdata$x:0000A67C ; COMDAT (pick associative to section at 81B8)
.xdata$x:0000A67C __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000A67C                                         ; DATA XREF: .xdata$x:0000A6ACo
.xdata$x:0000A67D                 db    0
.xdata$x:0000A67E                 db    0
.xdata$x:0000A67F                 db    0
.xdata$x:0000A680                 db    0
.xdata$x:0000A681                 db    0
.xdata$x:0000A682                 db    0
.xdata$x:0000A683                 db    0
.xdata$x:0000A684                 db    0
.xdata$x:0000A685                 db    0
.xdata$x:0000A686                 db    0
.xdata$x:0000A687                 db    0
.xdata$x:0000A688                 dd offset __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0
.xdata$x:0000A68C __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000A68C                                         ; DATA XREF: .xdata$x:0000A6B8o
.xdata$x:0000A68D                 db 0FFh
.xdata$x:0000A68E                 db 0FFh
.xdata$x:0000A68F                 db 0FFh
.xdata$x:0000A690                 db    0
.xdata$x:0000A691                 db    0
.xdata$x:0000A692                 db    0
.xdata$x:0000A693                 db    0
.xdata$x:0000A694                 db 0FFh
.xdata$x:0000A695                 db 0FFh
.xdata$x:0000A696                 db 0FFh
.xdata$x:0000A697                 db 0FFh
.xdata$x:0000A698                 db    0
.xdata$x:0000A699                 db    0
.xdata$x:0000A69A                 db    0
.xdata$x:0000A69B                 db    0
.xdata$x:0000A69C __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db    0
.xdata$x:0000A69C                                         ; DATA XREF: .xdata$x:0000A6C0o
.xdata$x:0000A69D                 db    0
.xdata$x:0000A69E                 db    0
.xdata$x:0000A69F                 db    0
.xdata$x:0000A6A0                 db    0
.xdata$x:0000A6A1                 db    0
.xdata$x:0000A6A2                 db    0
.xdata$x:0000A6A3                 db    0
.xdata$x:0000A6A4                 db    1
.xdata$x:0000A6A5                 db    0
.xdata$x:0000A6A6                 db    0
.xdata$x:0000A6A7                 db    0
.xdata$x:0000A6A8                 db    1
.xdata$x:0000A6A9                 db    0
.xdata$x:0000A6AA                 db    0
.xdata$x:0000A6AB                 db    0
.xdata$x:0000A6AC                 dd offset __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2
.xdata$x:0000A6B0 __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000A6B0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z+11o
.xdata$x:0000A6B1                 db    5
.xdata$x:0000A6B2                 db  93h ; ô
.xdata$x:0000A6B3                 db  19h
.xdata$x:0000A6B4                 db    2
.xdata$x:0000A6B5                 db    0
.xdata$x:0000A6B6                 db    0
.xdata$x:0000A6B7                 db    0
.xdata$x:0000A6B8                 dd offset __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:0000A6BC                 db    1
.xdata$x:0000A6BD                 db    0
.xdata$x:0000A6BE                 db    0
.xdata$x:0000A6BF                 db    0
.xdata$x:0000A6C0                 dd offset __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:0000A6C4                 db    0
.xdata$x:0000A6C5                 db    0
.xdata$x:0000A6C6                 db    0
.xdata$x:0000A6C7                 db    0
.xdata$x:0000A6C8                 db    0
.xdata$x:0000A6C9                 db    0
.xdata$x:0000A6CA                 db    0
.xdata$x:0000A6CB                 db    0
.xdata$x:0000A6CC                 db    0
.xdata$x:0000A6CD                 db    0
.xdata$x:0000A6CE                 db    0
.xdata$x:0000A6CF                 db    0
.xdata$x:0000A6D0                 db    0
.xdata$x:0000A6D1                 db    0
.xdata$x:0000A6D2                 db    0
.xdata$x:0000A6D3                 db    0
.xdata$x:0000A6D3 _xdata$x        ends
.xdata$x:0000A6D3
.xdata$x:0000A6D4 ; ===========================================================================
.xdata$x:0000A6D4
.xdata$x:0000A6D4 ; Segment type: Pure data
.xdata$x:0000A6D4 ; Segment permissions: Read
.xdata$x:0000A6D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A6D4                 assume cs:_xdata$x
.xdata$x:0000A6D4                 ;org 0A6D4h
.xdata$x:0000A6D4 ; COMDAT (pick associative to section at 80DC)
.xdata$x:0000A6D4 __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db 0FFh
.xdata$x:0000A6D4                                         ; DATA XREF: .xdata$x:0000A6E4o
.xdata$x:0000A6D5                 db 0FFh
.xdata$x:0000A6D6                 db 0FFh
.xdata$x:0000A6D7                 db 0FFh
.xdata$x:0000A6D8                 dd offset __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0
.xdata$x:0000A6DC __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db  22h ; "
.xdata$x:0000A6DC                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z+11o
.xdata$x:0000A6DD                 db    5
.xdata$x:0000A6DE                 db  93h ; ô
.xdata$x:0000A6DF                 db  19h
.xdata$x:0000A6E0                 db    1
.xdata$x:0000A6E1                 db    0
.xdata$x:0000A6E2                 db    0
.xdata$x:0000A6E3                 db    0
.xdata$x:0000A6E4                 dd offset __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.xdata$x:0000A6E8                 align 20h
.xdata$x:0000A6E8 _xdata$x        ends
.xdata$x:0000A6E8
.xdata$x:0000A700 ; ===========================================================================
.xdata$x:0000A700
.xdata$x:0000A700 ; Segment type: Pure data
.xdata$x:0000A700 ; Segment permissions: Read
.xdata$x:0000A700 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A700                 assume cs:_xdata$x
.xdata$x:0000A700                 ;org 0A700h
.xdata$x:0000A700 ; COMDAT (pick associative to section at 6794)
.xdata$x:0000A700 __unwindtable$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A700                                         ; DATA XREF: .xdata$x:0000A710o
.xdata$x:0000A701                 db 0FFh
.xdata$x:0000A702                 db 0FFh
.xdata$x:0000A703                 db 0FFh
.xdata$x:0000A704                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A708 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A708                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A709                 db    5
.xdata$x:0000A70A                 db  93h ; ô
.xdata$x:0000A70B                 db  19h
.xdata$x:0000A70C                 db    1
.xdata$x:0000A70D                 db    0
.xdata$x:0000A70E                 db    0
.xdata$x:0000A70F                 db    0
.xdata$x:0000A710                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@QAE@XZ
.xdata$x:0000A714                 db    0
.xdata$x:0000A715                 db    0
.xdata$x:0000A716                 db    0
.xdata$x:0000A717                 db    0
.xdata$x:0000A718                 db    0
.xdata$x:0000A719                 db    0
.xdata$x:0000A71A                 db    0
.xdata$x:0000A71B                 db    0
.xdata$x:0000A71C                 db    0
.xdata$x:0000A71D                 db    0
.xdata$x:0000A71E                 db    0
.xdata$x:0000A71F                 db    0
.xdata$x:0000A720                 db    0
.xdata$x:0000A721                 db    0
.xdata$x:0000A722                 db    0
.xdata$x:0000A723                 db    0
.xdata$x:0000A724                 db    0
.xdata$x:0000A725                 db    0
.xdata$x:0000A726                 db    0
.xdata$x:0000A727                 db    0
.xdata$x:0000A728                 db    0
.xdata$x:0000A729                 db    0
.xdata$x:0000A72A                 db    0
.xdata$x:0000A72B                 db    0
.xdata$x:0000A72B _xdata$x        ends
.xdata$x:0000A72B
.xdata$x:0000A72C ; ===========================================================================
.xdata$x:0000A72C
.xdata$x:0000A72C ; Segment type: Pure data
.xdata$x:0000A72C ; Segment permissions: Read
.xdata$x:0000A72C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A72C                 assume cs:_xdata$x
.xdata$x:0000A72C                 ;org 0A72Ch
.xdata$x:0000A72C ; COMDAT (pick associative to section at 64EC)
.xdata$x:0000A72C __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A72C                                         ; DATA XREF: .xdata$x:0000A73Co
.xdata$x:0000A72D                 db 0FFh
.xdata$x:0000A72E                 db 0FFh
.xdata$x:0000A72F                 db 0FFh
.xdata$x:0000A730                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A734 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A734                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A735                 db    5
.xdata$x:0000A736                 db  93h ; ô
.xdata$x:0000A737                 db  19h
.xdata$x:0000A738                 db    1
.xdata$x:0000A739                 db    0
.xdata$x:0000A73A                 db    0
.xdata$x:0000A73B                 db    0
.xdata$x:0000A73C                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A740                 db    0
.xdata$x:0000A741                 db    0
.xdata$x:0000A742                 db    0
.xdata$x:0000A743                 db    0
.xdata$x:0000A744                 db    0
.xdata$x:0000A745                 db    0
.xdata$x:0000A746                 db    0
.xdata$x:0000A747                 db    0
.xdata$x:0000A748                 db    0
.xdata$x:0000A749                 db    0
.xdata$x:0000A74A                 db    0
.xdata$x:0000A74B                 db    0
.xdata$x:0000A74C                 db    0
.xdata$x:0000A74D                 db    0
.xdata$x:0000A74E                 db    0
.xdata$x:0000A74F                 db    0
.xdata$x:0000A750                 db    0
.xdata$x:0000A751                 db    0
.xdata$x:0000A752                 db    0
.xdata$x:0000A753                 db    0
.xdata$x:0000A754                 db    0
.xdata$x:0000A755                 db    0
.xdata$x:0000A756                 db    0
.xdata$x:0000A757                 db    0
.xdata$x:0000A757 _xdata$x        ends
.xdata$x:0000A757
.xdata$x:0000A758 ; ===========================================================================
.xdata$x:0000A758
.xdata$x:0000A758 ; Segment type: Pure data
.xdata$x:0000A758 ; Segment permissions: Read
.xdata$x:0000A758 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A758                 assume cs:_xdata$x
.xdata$x:0000A758                 ;org 0A758h
.xdata$x:0000A758 ; COMDAT (pick associative to section at 69E4)
.xdata$x:0000A758 __unwindtable$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A758                                         ; DATA XREF: .xdata$x:0000A768o
.xdata$x:0000A759                 db 0FFh
.xdata$x:0000A75A                 db 0FFh
.xdata$x:0000A75B                 db 0FFh
.xdata$x:0000A75C                 dd offset __unwindfunclet$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A760 __ehfuncinfo$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A760                                         ; DATA XREF: __ehhandler$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A761                 db    5
.xdata$x:0000A762                 db  93h ; ô
.xdata$x:0000A763                 db  19h
.xdata$x:0000A764                 db    1
.xdata$x:0000A765                 db    0
.xdata$x:0000A766                 db    0
.xdata$x:0000A767                 db    0
.xdata$x:0000A768                 dd offset __unwindtable$??1?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE@XZ
.xdata$x:0000A76C                 db    0
.xdata$x:0000A76D                 db    0
.xdata$x:0000A76E                 db    0
.xdata$x:0000A76F                 db    0
.xdata$x:0000A770                 db    0
.xdata$x:0000A771                 db    0
.xdata$x:0000A772                 db    0
.xdata$x:0000A773                 db    0
.xdata$x:0000A774                 db    0
.xdata$x:0000A775                 db    0
.xdata$x:0000A776                 db    0
.xdata$x:0000A777                 db    0
.xdata$x:0000A778                 db    0
.xdata$x:0000A779                 db    0
.xdata$x:0000A77A                 db    0
.xdata$x:0000A77B                 db    0
.xdata$x:0000A77C                 db    0
.xdata$x:0000A77D                 db    0
.xdata$x:0000A77E                 db    0
.xdata$x:0000A77F                 db    0
.xdata$x:0000A780                 db    0
.xdata$x:0000A781                 db    0
.xdata$x:0000A782                 db    0
.xdata$x:0000A783                 db    0
.xdata$x:0000A783 _xdata$x        ends
.xdata$x:0000A783
.xdata$x:0000A784 ; ===========================================================================
.xdata$x:0000A784
.xdata$x:0000A784 ; Segment type: Pure data
.xdata$x:0000A784 ; Segment permissions: Read
.xdata$x:0000A784 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A784                 assume cs:_xdata$x
.xdata$x:0000A784                 ;org 0A784h
.xdata$x:0000A784 ; COMDAT (pick associative to section at 8D1C)
.xdata$x:0000A784 __unwindtable$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A784                                         ; DATA XREF: .xdata$x:0000A794o
.xdata$x:0000A785                 db 0FFh
.xdata$x:0000A786                 db 0FFh
.xdata$x:0000A787                 db 0FFh
.xdata$x:0000A788                 dd offset __unwindfunclet$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0
.xdata$x:0000A78C __ehfuncinfo$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A78C                                         ; DATA XREF: __ehhandler$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A78D                 db    5
.xdata$x:0000A78E                 db  93h ; ô
.xdata$x:0000A78F                 db  19h
.xdata$x:0000A790                 db    1
.xdata$x:0000A791                 db    0
.xdata$x:0000A792                 db    0
.xdata$x:0000A793                 db    0
.xdata$x:0000A794                 dd offset __unwindtable$?begin@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.xdata$x:0000A798                 db    0
.xdata$x:0000A799                 db    0
.xdata$x:0000A79A                 db    0
.xdata$x:0000A79B                 db    0
.xdata$x:0000A79C                 db    0
.xdata$x:0000A79D                 db    0
.xdata$x:0000A79E                 db    0
.xdata$x:0000A79F                 db    0
.xdata$x:0000A7A0                 db    0
.xdata$x:0000A7A1                 db    0
.xdata$x:0000A7A2                 db    0
.xdata$x:0000A7A3                 db    0
.xdata$x:0000A7A4                 db    0
.xdata$x:0000A7A5                 db    0
.xdata$x:0000A7A6                 db    0
.xdata$x:0000A7A7                 db    0
.xdata$x:0000A7A8                 db    0
.xdata$x:0000A7A9                 db    0
.xdata$x:0000A7AA                 db    0
.xdata$x:0000A7AB                 db    0
.xdata$x:0000A7AC                 db    0
.xdata$x:0000A7AD                 db    0
.xdata$x:0000A7AE                 db    0
.xdata$x:0000A7AF                 db    0
.xdata$x:0000A7AF _xdata$x        ends
.xdata$x:0000A7AF
.xdata$x:0000A7B0 ; ===========================================================================
.xdata$x:0000A7B0
.xdata$x:0000A7B0 ; Segment type: Pure data
.xdata$x:0000A7B0 ; Segment permissions: Read
.xdata$x:0000A7B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A7B0                 assume cs:_xdata$x
.xdata$x:0000A7B0                 ;org 0A7B0h
.xdata$x:0000A7B0 ; COMDAT (pick associative to section at 911C)
.xdata$x:0000A7B0 __unwindtable$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000A7B0                                         ; DATA XREF: .xdata$x:0000A7C0o
.xdata$x:0000A7B1                 db 0FFh
.xdata$x:0000A7B2                 db 0FFh
.xdata$x:0000A7B3                 db 0FFh
.xdata$x:0000A7B4                 dd offset __unwindfunclet$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ$0
.xdata$x:0000A7B8 __ehfuncinfo$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000A7B8                                         ; DATA XREF: __ehhandler$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ+11o
.xdata$x:0000A7B9                 db    5
.xdata$x:0000A7BA                 db  93h ; ô
.xdata$x:0000A7BB                 db  19h
.xdata$x:0000A7BC                 db    1
.xdata$x:0000A7BD                 db    0
.xdata$x:0000A7BE                 db    0
.xdata$x:0000A7BF                 db    0
.xdata$x:0000A7C0                 dd offset __unwindtable$?end@?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@2@XZ
.xdata$x:0000A7C4                 db    0
.xdata$x:0000A7C5                 db    0
.xdata$x:0000A7C6                 db    0
.xdata$x:0000A7C7                 db    0
.xdata$x:0000A7C8                 db    0
.xdata$x:0000A7C9                 db    0
.xdata$x:0000A7CA                 db    0
.xdata$x:0000A7CB                 db    0
.xdata$x:0000A7CC                 db    0
.xdata$x:0000A7CD                 db    0
.xdata$x:0000A7CE                 db    0
.xdata$x:0000A7CF                 db    0
.xdata$x:0000A7D0                 db    0
.xdata$x:0000A7D1                 db    0
.xdata$x:0000A7D2                 db    0
.xdata$x:0000A7D3                 db    0
.xdata$x:0000A7D4                 db    0
.xdata$x:0000A7D5                 db    0
.xdata$x:0000A7D6                 db    0
.xdata$x:0000A7D7                 db    0
.xdata$x:0000A7D8                 db    0
.xdata$x:0000A7D9                 db    0
.xdata$x:0000A7DA                 db    0
.xdata$x:0000A7DB                 db    0
.xdata$x:0000A7DB _xdata$x        ends
.xdata$x:0000A7DB
.xdata$x:0000A7DC ; ===========================================================================
.xdata$x:0000A7DC
.xdata$x:0000A7DC ; Segment type: Pure data
.xdata$x:0000A7DC ; Segment permissions: Read
.xdata$x:0000A7DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A7DC                 assume cs:_xdata$x
.xdata$x:0000A7DC                 ;org 0A7DCh
.xdata$x:0000A7DC ; COMDAT (pick associative to section at 510C)
.xdata$x:0000A7DC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A7DC                                         ; DATA XREF: .xdata$x:0000A7ECo
.xdata$x:0000A7DD                 db 0FFh
.xdata$x:0000A7DE                 db 0FFh
.xdata$x:0000A7DF                 db 0FFh
.xdata$x:0000A7E0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A7E4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A7E4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A7E5                 db    5
.xdata$x:0000A7E6                 db  93h ; ô
.xdata$x:0000A7E7                 db  19h
.xdata$x:0000A7E8                 db    1
.xdata$x:0000A7E9                 db    0
.xdata$x:0000A7EA                 db    0
.xdata$x:0000A7EB                 db    0
.xdata$x:0000A7EC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A7F0                 db    0
.xdata$x:0000A7F1                 db    0
.xdata$x:0000A7F2                 db    0
.xdata$x:0000A7F3                 db    0
.xdata$x:0000A7F4                 db    0
.xdata$x:0000A7F5                 db    0
.xdata$x:0000A7F6                 db    0
.xdata$x:0000A7F7                 db    0
.xdata$x:0000A7F8                 db    0
.xdata$x:0000A7F9                 db    0
.xdata$x:0000A7FA                 db    0
.xdata$x:0000A7FB                 db    0
.xdata$x:0000A7FC                 db    0
.xdata$x:0000A7FD                 db    0
.xdata$x:0000A7FE                 db    0
.xdata$x:0000A7FF                 db    0
.xdata$x:0000A800                 db    0
.xdata$x:0000A801                 db    0
.xdata$x:0000A802                 db    0
.xdata$x:0000A803                 db    0
.xdata$x:0000A804                 db    0
.xdata$x:0000A805                 db    0
.xdata$x:0000A806                 db    0
.xdata$x:0000A807                 db    0
.xdata$x:0000A807 _xdata$x        ends
.xdata$x:0000A807
.xdata$x:0000A808 ; ===========================================================================
.xdata$x:0000A808
.xdata$x:0000A808 ; Segment type: Pure data
.xdata$x:0000A808 ; Segment permissions: Read
.xdata$x:0000A808 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A808                 assume cs:_xdata$x
.xdata$x:0000A808                 ;org 0A808h
.xdata$x:0000A808 ; COMDAT (pick associative to section at 61C4)
.xdata$x:0000A808 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000A808                                         ; DATA XREF: .xdata$x:0000A818o
.xdata$x:0000A809                 db 0FFh
.xdata$x:0000A80A                 db 0FFh
.xdata$x:0000A80B                 db 0FFh
.xdata$x:0000A80C                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000A810 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A810                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000A811                 db    5
.xdata$x:0000A812                 db  93h ; ô
.xdata$x:0000A813                 db  19h
.xdata$x:0000A814                 db    1
.xdata$x:0000A815                 db    0
.xdata$x:0000A816                 db    0
.xdata$x:0000A817                 db    0
.xdata$x:0000A818                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000A81C                 db    0
.xdata$x:0000A81D                 db    0
.xdata$x:0000A81E                 db    0
.xdata$x:0000A81F                 db    0
.xdata$x:0000A820                 db    0
.xdata$x:0000A821                 db    0
.xdata$x:0000A822                 db    0
.xdata$x:0000A823                 db    0
.xdata$x:0000A824                 db    0
.xdata$x:0000A825                 db    0
.xdata$x:0000A826                 db    0
.xdata$x:0000A827                 db    0
.xdata$x:0000A828                 db    0
.xdata$x:0000A829                 db    0
.xdata$x:0000A82A                 db    0
.xdata$x:0000A82B                 db    0
.xdata$x:0000A82C                 db    0
.xdata$x:0000A82D                 db    0
.xdata$x:0000A82E                 db    0
.xdata$x:0000A82F                 db    0
.xdata$x:0000A830                 db    0
.xdata$x:0000A831                 db    0
.xdata$x:0000A832                 db    0
.xdata$x:0000A833                 db    0
.xdata$x:0000A833 _xdata$x        ends
.xdata$x:0000A833
.xdata$x:0000A834 ; ===========================================================================
.xdata$x:0000A834
.xdata$x:0000A834 ; Segment type: Pure data
.xdata$x:0000A834 ; Segment permissions: Read
.xdata$x:0000A834 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A834                 assume cs:_xdata$x
.xdata$x:0000A834                 ;org 0A834h
.xdata$x:0000A834 ; COMDAT (pick associative to section at 5094)
.xdata$x:0000A834 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000A834                                         ; DATA XREF: .xdata$x:0000A844o
.xdata$x:0000A835                 db 0FFh
.xdata$x:0000A836                 db 0FFh
.xdata$x:0000A837                 db 0FFh
.xdata$x:0000A838                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000A83C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000A83C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000A83D                 db    5
.xdata$x:0000A83E                 db  93h ; ô
.xdata$x:0000A83F                 db  19h
.xdata$x:0000A840                 db    1
.xdata$x:0000A841                 db    0
.xdata$x:0000A842                 db    0
.xdata$x:0000A843                 db    0
.xdata$x:0000A844                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@UColumnModeInfo@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000A848                 align 20h
.xdata$x:0000A848 _xdata$x        ends
.xdata$x:0000A848
.xdata$x:0000A860 ; ===========================================================================
.xdata$x:0000A860
.xdata$x:0000A860 ; Segment type: Pure data
.xdata$x:0000A860 ; Segment permissions: Read
.xdata$x:0000A860 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A860                 assume cs:_xdata$x
.xdata$x:0000A860                 ;org 0A860h
.xdata$x:0000A860 ; COMDAT (pick associative to section at 569C)
.xdata$x:0000A860 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000A860                                         ; DATA XREF: .xdata$x:0000A870o
.xdata$x:0000A861                 db 0FFh
.xdata$x:0000A862                 db 0FFh
.xdata$x:0000A863                 db 0FFh
.xdata$x:0000A864                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0
.xdata$x:0000A868 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000A868                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000A869                 db    5
.xdata$x:0000A86A                 db  93h ; ô
.xdata$x:0000A86B                 db  19h
.xdata$x:0000A86C                 db    1
.xdata$x:0000A86D                 db    0
.xdata$x:0000A86E                 db    0
.xdata$x:0000A86F                 db    0
.xdata$x:0000A870                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.xdata$x:0000A874                 db    0
.xdata$x:0000A875                 db    0
.xdata$x:0000A876                 db    0
.xdata$x:0000A877                 db    0
.xdata$x:0000A878                 db    0
.xdata$x:0000A879                 db    0
.xdata$x:0000A87A                 db    0
.xdata$x:0000A87B                 db    0
.xdata$x:0000A87C                 db    0
.xdata$x:0000A87D                 db    0
.xdata$x:0000A87E                 db    0
.xdata$x:0000A87F                 db    0
.xdata$x:0000A880                 db    0
.xdata$x:0000A881                 db    0
.xdata$x:0000A882                 db    0
.xdata$x:0000A883                 db    0
.xdata$x:0000A884                 db    0
.xdata$x:0000A885                 db    0
.xdata$x:0000A886                 db    0
.xdata$x:0000A887                 db    0
.xdata$x:0000A888                 db    0
.xdata$x:0000A889                 db    0
.xdata$x:0000A88A                 db    0
.xdata$x:0000A88B                 db    0
.xdata$x:0000A88B _xdata$x        ends
.xdata$x:0000A88B
.xdata$x:0000A88C ; ===========================================================================
.xdata$x:0000A88C
.xdata$x:0000A88C ; Segment type: Pure data
.xdata$x:0000A88C ; Segment permissions: Read
.xdata$x:0000A88C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A88C                 assume cs:_xdata$x
.xdata$x:0000A88C                 ;org 0A88Ch
.xdata$x:0000A88C ; COMDAT (pick associative to section at 65D4)
.xdata$x:0000A88C __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A88C                                         ; DATA XREF: .xdata$x:0000A89Co
.xdata$x:0000A88D                 db 0FFh
.xdata$x:0000A88E                 db 0FFh
.xdata$x:0000A88F                 db 0FFh
.xdata$x:0000A890                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A894 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A894                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A895                 db    5
.xdata$x:0000A896                 db  93h ; ô
.xdata$x:0000A897                 db  19h
.xdata$x:0000A898                 db    1
.xdata$x:0000A899                 db    0
.xdata$x:0000A89A                 db    0
.xdata$x:0000A89B                 db    0
.xdata$x:0000A89C                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A8A0                 db    0
.xdata$x:0000A8A1                 db    0
.xdata$x:0000A8A2                 db    0
.xdata$x:0000A8A3                 db    0
.xdata$x:0000A8A4                 db    0
.xdata$x:0000A8A5                 db    0
.xdata$x:0000A8A6                 db    0
.xdata$x:0000A8A7                 db    0
.xdata$x:0000A8A8                 db    0
.xdata$x:0000A8A9                 db    0
.xdata$x:0000A8AA                 db    0
.xdata$x:0000A8AB                 db    0
.xdata$x:0000A8AC                 db    0
.xdata$x:0000A8AD                 db    0
.xdata$x:0000A8AE                 db    0
.xdata$x:0000A8AF                 db    0
.xdata$x:0000A8B0                 db    0
.xdata$x:0000A8B1                 db    0
.xdata$x:0000A8B2                 db    0
.xdata$x:0000A8B3                 db    0
.xdata$x:0000A8B4                 db    0
.xdata$x:0000A8B5                 db    0
.xdata$x:0000A8B6                 db    0
.xdata$x:0000A8B7                 db    0
.xdata$x:0000A8B7 _xdata$x        ends
.xdata$x:0000A8B7
.xdata$x:0000A8B8 ; ===========================================================================
.xdata$x:0000A8B8
.xdata$x:0000A8B8 ; Segment type: Pure data
.xdata$x:0000A8B8 ; Segment permissions: Read
.xdata$x:0000A8B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A8B8                 assume cs:_xdata$x
.xdata$x:0000A8B8                 ;org 0A8B8h
.xdata$x:0000A8B8 ; COMDAT (pick associative to section at 5618)
.xdata$x:0000A8B8 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000A8B8                                         ; DATA XREF: .xdata$x:0000A8C8o
.xdata$x:0000A8B9                 db 0FFh
.xdata$x:0000A8BA                 db 0FFh
.xdata$x:0000A8BB                 db 0FFh
.xdata$x:0000A8BC                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000A8C0 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000A8C0                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000A8C1                 db    5
.xdata$x:0000A8C2                 db  93h ; ô
.xdata$x:0000A8C3                 db  19h
.xdata$x:0000A8C4                 db    1
.xdata$x:0000A8C5                 db    0
.xdata$x:0000A8C6                 db    0
.xdata$x:0000A8C7                 db    0
.xdata$x:0000A8C8                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000A8CC                 db    0
.xdata$x:0000A8CD                 db    0
.xdata$x:0000A8CE                 db    0
.xdata$x:0000A8CF                 db    0
.xdata$x:0000A8D0                 db    0
.xdata$x:0000A8D1                 db    0
.xdata$x:0000A8D2                 db    0
.xdata$x:0000A8D3                 db    0
.xdata$x:0000A8D4                 db    0
.xdata$x:0000A8D5                 db    0
.xdata$x:0000A8D6                 db    0
.xdata$x:0000A8D7                 db    0
.xdata$x:0000A8D8                 db    0
.xdata$x:0000A8D9                 db    0
.xdata$x:0000A8DA                 db    0
.xdata$x:0000A8DB                 db    0
.xdata$x:0000A8DC                 db    0
.xdata$x:0000A8DD                 db    0
.xdata$x:0000A8DE                 db    0
.xdata$x:0000A8DF                 db    0
.xdata$x:0000A8E0                 db    0
.xdata$x:0000A8E1                 db    0
.xdata$x:0000A8E2                 db    0
.xdata$x:0000A8E3                 db    0
.xdata$x:0000A8E3 _xdata$x        ends
.xdata$x:0000A8E3
.xdata$x:0000A8E4 ; ===========================================================================
.xdata$x:0000A8E4
.xdata$x:0000A8E4 ; Segment type: Pure data
.xdata$x:0000A8E4 ; Segment permissions: Read
.xdata$x:0000A8E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A8E4                 assume cs:_xdata$x
.xdata$x:0000A8E4                 ;org 0A8E4h
.xdata$x:0000A8E4 ; COMDAT (pick associative to section at 5894)
.xdata$x:0000A8E4 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000A8E4                                         ; DATA XREF: .xdata$x:0000A8F4o
.xdata$x:0000A8E5                 db 0FFh
.xdata$x:0000A8E6                 db 0FFh
.xdata$x:0000A8E7                 db 0FFh
.xdata$x:0000A8E8                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z$0
.xdata$x:0000A8EC __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000A8EC                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z+11o
.xdata$x:0000A8ED                 db    5
.xdata$x:0000A8EE                 db  93h ; ô
.xdata$x:0000A8EF                 db  19h
.xdata$x:0000A8F0                 db    1
.xdata$x:0000A8F1                 db    0
.xdata$x:0000A8F2                 db    0
.xdata$x:0000A8F3                 db    0
.xdata$x:0000A8F4                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@PAUColumnModeInfo@@PBU_Container_base12@1@@Z
.xdata$x:0000A8F8                 db    0
.xdata$x:0000A8F9                 db    0
.xdata$x:0000A8FA                 db    0
.xdata$x:0000A8FB                 db    0
.xdata$x:0000A8FC                 db    0
.xdata$x:0000A8FD                 db    0
.xdata$x:0000A8FE                 db    0
.xdata$x:0000A8FF                 db    0
.xdata$x:0000A900                 db    0
.xdata$x:0000A901                 db    0
.xdata$x:0000A902                 db    0
.xdata$x:0000A903                 db    0
.xdata$x:0000A904                 db    0
.xdata$x:0000A905                 db    0
.xdata$x:0000A906                 db    0
.xdata$x:0000A907                 db    0
.xdata$x:0000A908                 db    0
.xdata$x:0000A909                 db    0
.xdata$x:0000A90A                 db    0
.xdata$x:0000A90B                 db    0
.xdata$x:0000A90C                 db    0
.xdata$x:0000A90D                 db    0
.xdata$x:0000A90E                 db    0
.xdata$x:0000A90F                 db    0
.xdata$x:0000A90F _xdata$x        ends
.xdata$x:0000A90F
.xdata$x:0000A910 ; ===========================================================================
.xdata$x:0000A910
.xdata$x:0000A910 ; Segment type: Pure data
.xdata$x:0000A910 ; Segment permissions: Read
.xdata$x:0000A910 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A910                 assume cs:_xdata$x
.xdata$x:0000A910                 ;org 0A910h
.xdata$x:0000A910 ; COMDAT (pick associative to section at 66B4)
.xdata$x:0000A910 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000A910                                         ; DATA XREF: .xdata$x:0000A920o
.xdata$x:0000A911                 db 0FFh
.xdata$x:0000A912                 db 0FFh
.xdata$x:0000A913                 db 0FFh
.xdata$x:0000A914                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000A918 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000A918                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000A919                 db    5
.xdata$x:0000A91A                 db  93h ; ô
.xdata$x:0000A91B                 db  19h
.xdata$x:0000A91C                 db    1
.xdata$x:0000A91D                 db    0
.xdata$x:0000A91E                 db    0
.xdata$x:0000A91F                 db    0
.xdata$x:0000A920                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000A924                 db    0
.xdata$x:0000A925                 db    0
.xdata$x:0000A926                 db    0
.xdata$x:0000A927                 db    0
.xdata$x:0000A928                 db    0
.xdata$x:0000A929                 db    0
.xdata$x:0000A92A                 db    0
.xdata$x:0000A92B                 db    0
.xdata$x:0000A92C                 db    0
.xdata$x:0000A92D                 db    0
.xdata$x:0000A92E                 db    0
.xdata$x:0000A92F                 db    0
.xdata$x:0000A930                 db    0
.xdata$x:0000A931                 db    0
.xdata$x:0000A932                 db    0
.xdata$x:0000A933                 db    0
.xdata$x:0000A934                 db    0
.xdata$x:0000A935                 db    0
.xdata$x:0000A936                 db    0
.xdata$x:0000A937                 db    0
.xdata$x:0000A938                 db    0
.xdata$x:0000A939                 db    0
.xdata$x:0000A93A                 db    0
.xdata$x:0000A93B                 db    0
.xdata$x:0000A93B _xdata$x        ends
.xdata$x:0000A93B
.xdata$x:0000A93C ; ===========================================================================
.xdata$x:0000A93C
.xdata$x:0000A93C ; Segment type: Pure data
.xdata$x:0000A93C ; Segment permissions: Read
.xdata$x:0000A93C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A93C                 assume cs:_xdata$x
.xdata$x:0000A93C                 ;org 0A93Ch
.xdata$x:0000A93C ; COMDAT (pick associative to section at 581C)
.xdata$x:0000A93C __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000A93C                                         ; DATA XREF: .xdata$x:0000A94Co
.xdata$x:0000A93D                 db 0FFh
.xdata$x:0000A93E                 db 0FFh
.xdata$x:0000A93F                 db 0FFh
.xdata$x:0000A940                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000A944 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000A944                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000A945                 db    5
.xdata$x:0000A946                 db  93h ; ô
.xdata$x:0000A947                 db  19h
.xdata$x:0000A948                 db    1
.xdata$x:0000A949                 db    0
.xdata$x:0000A94A                 db    0
.xdata$x:0000A94B                 db    0
.xdata$x:0000A94C                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000A950                 db    0
.xdata$x:0000A951                 db    0
.xdata$x:0000A952                 db    0
.xdata$x:0000A953                 db    0
.xdata$x:0000A954                 db    0
.xdata$x:0000A955                 db    0
.xdata$x:0000A956                 db    0
.xdata$x:0000A957                 db    0
.xdata$x:0000A958                 db    0
.xdata$x:0000A959                 db    0
.xdata$x:0000A95A                 db    0
.xdata$x:0000A95B                 db    0
.xdata$x:0000A95C                 db    0
.xdata$x:0000A95D                 db    0
.xdata$x:0000A95E                 db    0
.xdata$x:0000A95F                 db    0
.xdata$x:0000A960                 db    0
.xdata$x:0000A961                 db    0
.xdata$x:0000A962                 db    0
.xdata$x:0000A963                 db    0
.xdata$x:0000A964                 db    0
.xdata$x:0000A965                 db    0
.xdata$x:0000A966                 db    0
.xdata$x:0000A967                 db    0
.xdata$x:0000A967 _xdata$x        ends
.xdata$x:0000A967
.xdata$x:0000A968 ; ===========================================================================
.xdata$x:0000A968
.xdata$x:0000A968 ; Segment type: Pure data
.xdata$x:0000A968 ; Segment permissions: Read
.xdata$x:0000A968 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A968                 assume cs:_xdata$x
.xdata$x:0000A968                 ;org 0A968h
.xdata$x:0000A968 ; COMDAT (pick associative to section at 4AF4)
.xdata$x:0000A968 __ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z db  22h ; "
.xdata$x:0000A968                                         ; DATA XREF: __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z+11o
.xdata$x:0000A969                 db    5
.xdata$x:0000A96A                 db  93h ; ô
.xdata$x:0000A96B                 db  19h
.xdata$x:0000A96C                 db    6
.xdata$x:0000A96D                 db    0
.xdata$x:0000A96E                 db    0
.xdata$x:0000A96F                 db    0
.xdata$x:0000A970                 dd offset __unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z
.xdata$x:0000A974                 db    0
.xdata$x:0000A975                 db    0
.xdata$x:0000A976                 db    0
.xdata$x:0000A977                 db    0
.xdata$x:0000A978                 db    0
.xdata$x:0000A979                 db    0
.xdata$x:0000A97A                 db    0
.xdata$x:0000A97B                 db    0
.xdata$x:0000A97C                 db    0
.xdata$x:0000A97D                 db    0
.xdata$x:0000A97E                 db    0
.xdata$x:0000A97F                 db    0
.xdata$x:0000A980                 db    0
.xdata$x:0000A981                 db    0
.xdata$x:0000A982                 db    0
.xdata$x:0000A983                 db    0
.xdata$x:0000A984                 db    0
.xdata$x:0000A985                 db    0
.xdata$x:0000A986                 db    0
.xdata$x:0000A987                 db    0
.xdata$x:0000A988                 db    0
.xdata$x:0000A989                 db    0
.xdata$x:0000A98A                 db    0
.xdata$x:0000A98B                 db    0
.xdata$x:0000A98C __unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z db 0FFh
.xdata$x:0000A98C                                         ; DATA XREF: .xdata$x:0000A970o
.xdata$x:0000A98D                 db 0FFh
.xdata$x:0000A98E                 db 0FFh
.xdata$x:0000A98F                 db 0FFh
.xdata$x:0000A990                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$0
.xdata$x:0000A994                 align 8
.xdata$x:0000A998                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$1
.xdata$x:0000A99C                 db    1
.xdata$x:0000A99D                 db    0
.xdata$x:0000A99E                 db    0
.xdata$x:0000A99F                 db    0
.xdata$x:0000A9A0                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$2
.xdata$x:0000A9A4                 db    2
.xdata$x:0000A9A5                 db    0
.xdata$x:0000A9A6                 db    0
.xdata$x:0000A9A7                 db    0
.xdata$x:0000A9A8                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$3
.xdata$x:0000A9AC                 db    1
.xdata$x:0000A9AD                 db    0
.xdata$x:0000A9AE                 db    0
.xdata$x:0000A9AF                 db    0
.xdata$x:0000A9B0                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$4
.xdata$x:0000A9B4                 db    1
.xdata$x:0000A9B5                 db    0
.xdata$x:0000A9B6                 db    0
.xdata$x:0000A9B7                 db    0
.xdata$x:0000A9B8                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInPositionOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInPositionOrder@@@Z$5
.xdata$x:0000A9B8 _xdata$x        ends
.xdata$x:0000A9B8
.xdata$x:0000A9BC ; ===========================================================================
.xdata$x:0000A9BC
.xdata$x:0000A9BC ; Segment type: Pure data
.xdata$x:0000A9BC ; Segment permissions: Read
.xdata$x:0000A9BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A9BC                 assume cs:_xdata$x
.xdata$x:0000A9BC                 ;org 0A9BCh
.xdata$x:0000A9BC ; COMDAT (pick associative to section at 4C7C)
.xdata$x:0000A9BC __ehfuncinfo$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z db  22h ; "
.xdata$x:0000A9BC                                         ; DATA XREF: __ehhandler$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z+11o
.xdata$x:0000A9BD                 db    5
.xdata$x:0000A9BE                 db  93h ; ô
.xdata$x:0000A9BF                 db  19h
.xdata$x:0000A9C0                 db    6
.xdata$x:0000A9C1                 db    0
.xdata$x:0000A9C2                 db    0
.xdata$x:0000A9C3                 db    0
.xdata$x:0000A9C4                 dd offset __unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z
.xdata$x:0000A9C8                 align 20h
.xdata$x:0000A9E0 __unwindtable$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z db 0FFh
.xdata$x:0000A9E0                                         ; DATA XREF: .xdata$x:0000A9C4o
.xdata$x:0000A9E1                 db 0FFh
.xdata$x:0000A9E2                 db 0FFh
.xdata$x:0000A9E3                 db 0FFh
.xdata$x:0000A9E4                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$0
.xdata$x:0000A9E8                 db    0
.xdata$x:0000A9E9                 db    0
.xdata$x:0000A9EA                 db    0
.xdata$x:0000A9EB                 db    0
.xdata$x:0000A9EC                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$1
.xdata$x:0000A9F0                 db    1
.xdata$x:0000A9F1                 db    0
.xdata$x:0000A9F2                 db    0
.xdata$x:0000A9F3                 db    0
.xdata$x:0000A9F4                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$2
.xdata$x:0000A9F8                 db    2
.xdata$x:0000A9F9                 db    0
.xdata$x:0000A9FA                 db    0
.xdata$x:0000A9FB                 db    0
.xdata$x:0000A9FC                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$3
.xdata$x:0000AA00                 db    1
.xdata$x:0000AA01                 db    0
.xdata$x:0000AA02                 db    0
.xdata$x:0000AA03                 db    0
.xdata$x:0000AA04                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$4
.xdata$x:0000AA08                 db    1
.xdata$x:0000AA09                 db    0
.xdata$x:0000AA0A                 db    0
.xdata$x:0000AA0B                 db    0
.xdata$x:0000AA0C                 dd offset __unwindfunclet$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@USortInSelectOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0USortInSelectOrder@@@Z$5
.xdata$x:0000AA0C _xdata$x        ends
.xdata$x:0000AA0C
.xdata$x:0000AA10 ; ===========================================================================
.xdata$x:0000AA10
.xdata$x:0000AA10 ; Segment type: Pure data
.xdata$x:0000AA10 ; Segment permissions: Read
.xdata$x:0000AA10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AA10                 assume cs:_xdata$x
.xdata$x:0000AA10                 ;org 0AA10h
.xdata$x:0000AA10 ; COMDAT (pick associative to section at 5020)
.xdata$x:0000AA10 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000AA10                                         ; DATA XREF: .xdata$x:0000AA20o
.xdata$x:0000AA11                 db 0FFh
.xdata$x:0000AA12                 db 0FFh
.xdata$x:0000AA13                 db 0FFh
.xdata$x:0000AA14                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000AA18 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AA18                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000AA19                 db    5
.xdata$x:0000AA1A                 db  93h ; ô
.xdata$x:0000AA1B                 db  19h
.xdata$x:0000AA1C                 db    1
.xdata$x:0000AA1D                 db    0
.xdata$x:0000AA1E                 db    0
.xdata$x:0000AA1F                 db    0
.xdata$x:0000AA20                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000AA24                 db    0
.xdata$x:0000AA25                 db    0
.xdata$x:0000AA26                 db    0
.xdata$x:0000AA27                 db    0
.xdata$x:0000AA28                 db    0
.xdata$x:0000AA29                 db    0
.xdata$x:0000AA2A                 db    0
.xdata$x:0000AA2B                 db    0
.xdata$x:0000AA2C                 db    0
.xdata$x:0000AA2D                 db    0
.xdata$x:0000AA2E                 db    0
.xdata$x:0000AA2F                 db    0
.xdata$x:0000AA30                 db    0
.xdata$x:0000AA31                 db    0
.xdata$x:0000AA32                 db    0
.xdata$x:0000AA33                 db    0
.xdata$x:0000AA34                 db    0
.xdata$x:0000AA35                 db    0
.xdata$x:0000AA36                 db    0
.xdata$x:0000AA37                 db    0
.xdata$x:0000AA38                 db    0
.xdata$x:0000AA39                 db    0
.xdata$x:0000AA3A                 db    0
.xdata$x:0000AA3B                 db    0
.xdata$x:0000AA3B _xdata$x        ends
.xdata$x:0000AA3B
.xdata$x:0000AA3C ; ===========================================================================
.xdata$x:0000AA3C
.xdata$x:0000AA3C ; Segment type: Pure data
.xdata$x:0000AA3C ; Segment permissions: Read
.xdata$x:0000AA3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AA3C                 assume cs:_xdata$x
.xdata$x:0000AA3C                 ;org 0AA3Ch
.xdata$x:0000AA3C ; COMDAT (pick associative to section at 6154)
.xdata$x:0000AA3C __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000AA3C                                         ; DATA XREF: .xdata$x:0000AA4Co
.xdata$x:0000AA3D                 db 0FFh
.xdata$x:0000AA3E                 db 0FFh
.xdata$x:0000AA3F                 db 0FFh
.xdata$x:0000AA40                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000AA44 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AA44                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000AA45                 db    5
.xdata$x:0000AA46                 db  93h ; ô
.xdata$x:0000AA47                 db  19h
.xdata$x:0000AA48                 db    1
.xdata$x:0000AA49                 db    0
.xdata$x:0000AA4A                 db    0
.xdata$x:0000AA4B                 db    0
.xdata$x:0000AA4C                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:0000AA50                 db    0
.xdata$x:0000AA51                 db    0
.xdata$x:0000AA52                 db    0
.xdata$x:0000AA53                 db    0
.xdata$x:0000AA54                 db    0
.xdata$x:0000AA55                 db    0
.xdata$x:0000AA56                 db    0
.xdata$x:0000AA57                 db    0
.xdata$x:0000AA58                 db    0
.xdata$x:0000AA59                 db    0
.xdata$x:0000AA5A                 db    0
.xdata$x:0000AA5B                 db    0
.xdata$x:0000AA5C                 db    0
.xdata$x:0000AA5D                 db    0
.xdata$x:0000AA5E                 db    0
.xdata$x:0000AA5F                 db    0
.xdata$x:0000AA60                 db    0
.xdata$x:0000AA61                 db    0
.xdata$x:0000AA62                 db    0
.xdata$x:0000AA63                 db    0
.xdata$x:0000AA64                 db    0
.xdata$x:0000AA65                 db    0
.xdata$x:0000AA66                 db    0
.xdata$x:0000AA67                 db    0
.xdata$x:0000AA67 _xdata$x        ends
.xdata$x:0000AA67
.xdata$x:0000AA68 ; ===========================================================================
.xdata$x:0000AA68
.xdata$x:0000AA68 ; Segment type: Pure data
.xdata$x:0000AA68 ; Segment permissions: Read
.xdata$x:0000AA68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AA68                 assume cs:_xdata$x
.xdata$x:0000AA68                 ;org 0AA68h
.xdata$x:0000AA68 ; COMDAT (pick associative to section at 4FA8)
.xdata$x:0000AA68 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000AA68                                         ; DATA XREF: .xdata$x:0000AA78o
.xdata$x:0000AA69                 db 0FFh
.xdata$x:0000AA6A                 db 0FFh
.xdata$x:0000AA6B                 db 0FFh
.xdata$x:0000AA6C                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:0000AA70 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000AA70                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:0000AA71                 db    5
.xdata$x:0000AA72                 db  93h ; ô
.xdata$x:0000AA73                 db  19h
.xdata$x:0000AA74                 db    1
.xdata$x:0000AA75                 db    0
.xdata$x:0000AA76                 db    0
.xdata$x:0000AA77                 db    0
.xdata$x:0000AA78                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000AA7C                 db    0
.xdata$x:0000AA7D                 db    0
.xdata$x:0000AA7E                 db    0
.xdata$x:0000AA7F                 db    0
.xdata$x:0000AA80                 db    0
.xdata$x:0000AA81                 db    0
.xdata$x:0000AA82                 db    0
.xdata$x:0000AA83                 db    0
.xdata$x:0000AA84                 db    0
.xdata$x:0000AA85                 db    0
.xdata$x:0000AA86                 db    0
.xdata$x:0000AA87                 db    0
.xdata$x:0000AA88                 db    0
.xdata$x:0000AA89                 db    0
.xdata$x:0000AA8A                 db    0
.xdata$x:0000AA8B                 db    0
.xdata$x:0000AA8C                 db    0
.xdata$x:0000AA8D                 db    0
.xdata$x:0000AA8E                 db    0
.xdata$x:0000AA8F                 db    0
.xdata$x:0000AA90                 db    0
.xdata$x:0000AA91                 db    0
.xdata$x:0000AA92                 db    0
.xdata$x:0000AA93                 db    0
.xdata$x:0000AA93 _xdata$x        ends
.xdata$x:0000AA93
.xdata$x:0000AA94 ; ===========================================================================
.xdata$x:0000AA94
.xdata$x:0000AA94 ; Segment type: Pure data
.xdata$x:0000AA94 ; Segment permissions: Read
.xdata$x:0000AA94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AA94                 assume cs:_xdata$x
.xdata$x:0000AA94                 ;org 0AA94h
.xdata$x:0000AA94 ; COMDAT (pick associative to section at 558C)
.xdata$x:0000AA94 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000AA94                                         ; DATA XREF: .xdata$x:0000AAA4o
.xdata$x:0000AA95                 db 0FFh
.xdata$x:0000AA96                 db 0FFh
.xdata$x:0000AA97                 db 0FFh
.xdata$x:0000AA98                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
.xdata$x:0000AA9C __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000AA9C                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z+11o
.xdata$x:0000AA9D                 db    5
.xdata$x:0000AA9E                 db  93h ; ô
.xdata$x:0000AA9F                 db  19h
.xdata$x:0000AAA0                 db    1
.xdata$x:0000AAA1                 db    0
.xdata$x:0000AAA2                 db    0
.xdata$x:0000AAA3                 db    0
.xdata$x:0000AAA4                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.xdata$x:0000AAA8                 align 20h
.xdata$x:0000AAA8 _xdata$x        ends
.xdata$x:0000AAA8
.xdata$x:0000AAC0 ; ===========================================================================
.xdata$x:0000AAC0
.xdata$x:0000AAC0 ; Segment type: Pure data
.xdata$x:0000AAC0 ; Segment permissions: Read
.xdata$x:0000AAC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AAC0                 assume cs:_xdata$x
.xdata$x:0000AAC0                 ;org 0AAC0h
.xdata$x:0000AAC0 ; COMDAT (pick associative to section at 6564)
.xdata$x:0000AAC0 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000AAC0                                         ; DATA XREF: .xdata$x:0000AAD0o
.xdata$x:0000AAC1                 db 0FFh
.xdata$x:0000AAC2                 db 0FFh
.xdata$x:0000AAC3                 db 0FFh
.xdata$x:0000AAC4                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000AAC8 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AAC8                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000AAC9                 db    5
.xdata$x:0000AACA                 db  93h ; ô
.xdata$x:0000AACB                 db  19h
.xdata$x:0000AACC                 db    1
.xdata$x:0000AACD                 db    0
.xdata$x:0000AACE                 db    0
.xdata$x:0000AACF                 db    0
.xdata$x:0000AAD0                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.xdata$x:0000AAD4                 db    0
.xdata$x:0000AAD5                 db    0
.xdata$x:0000AAD6                 db    0
.xdata$x:0000AAD7                 db    0
.xdata$x:0000AAD8                 db    0
.xdata$x:0000AAD9                 db    0
.xdata$x:0000AADA                 db    0
.xdata$x:0000AADB                 db    0
.xdata$x:0000AADC                 db    0
.xdata$x:0000AADD                 db    0
.xdata$x:0000AADE                 db    0
.xdata$x:0000AADF                 db    0
.xdata$x:0000AAE0                 db    0
.xdata$x:0000AAE1                 db    0
.xdata$x:0000AAE2                 db    0
.xdata$x:0000AAE3                 db    0
.xdata$x:0000AAE4                 db    0
.xdata$x:0000AAE5                 db    0
.xdata$x:0000AAE6                 db    0
.xdata$x:0000AAE7                 db    0
.xdata$x:0000AAE8                 db    0
.xdata$x:0000AAE9                 db    0
.xdata$x:0000AAEA                 db    0
.xdata$x:0000AAEB                 db    0
.xdata$x:0000AAEB _xdata$x        ends
.xdata$x:0000AAEB
.xdata$x:0000AAEC ; ===========================================================================
.xdata$x:0000AAEC
.xdata$x:0000AAEC ; Segment type: Pure data
.xdata$x:0000AAEC ; Segment permissions: Read
.xdata$x:0000AAEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AAEC                 assume cs:_xdata$x
.xdata$x:0000AAEC                 ;org 0AAECh
.xdata$x:0000AAEC ; COMDAT (pick associative to section at 5508)
.xdata$x:0000AAEC __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000AAEC                                         ; DATA XREF: .xdata$x:0000AAFCo
.xdata$x:0000AAED                 db 0FFh
.xdata$x:0000AAEE                 db 0FFh
.xdata$x:0000AAEF                 db 0FFh
.xdata$x:0000AAF0                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000AAF4 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000AAF4                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000AAF5                 db    5
.xdata$x:0000AAF6                 db  93h ; ô
.xdata$x:0000AAF7                 db  19h
.xdata$x:0000AAF8                 db    1
.xdata$x:0000AAF9                 db    0
.xdata$x:0000AAFA                 db    0
.xdata$x:0000AAFB                 db    0
.xdata$x:0000AAFC                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000AB00                 db    0
.xdata$x:0000AB01                 db    0
.xdata$x:0000AB02                 db    0
.xdata$x:0000AB03                 db    0
.xdata$x:0000AB04                 db    0
.xdata$x:0000AB05                 db    0
.xdata$x:0000AB06                 db    0
.xdata$x:0000AB07                 db    0
.xdata$x:0000AB08                 db    0
.xdata$x:0000AB09                 db    0
.xdata$x:0000AB0A                 db    0
.xdata$x:0000AB0B                 db    0
.xdata$x:0000AB0C                 db    0
.xdata$x:0000AB0D                 db    0
.xdata$x:0000AB0E                 db    0
.xdata$x:0000AB0F                 db    0
.xdata$x:0000AB10                 db    0
.xdata$x:0000AB11                 db    0
.xdata$x:0000AB12                 db    0
.xdata$x:0000AB13                 db    0
.xdata$x:0000AB14                 db    0
.xdata$x:0000AB15                 db    0
.xdata$x:0000AB16                 db    0
.xdata$x:0000AB17                 db    0
.xdata$x:0000AB17 _xdata$x        ends
.xdata$x:0000AB17
.xdata$x:0000AB18 ; ===========================================================================
.xdata$x:0000AB18
.xdata$x:0000AB18 ; Segment type: Pure data
.xdata$x:0000AB18 ; Segment permissions: Read
.xdata$x:0000AB18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB18                 assume cs:_xdata$x
.xdata$x:0000AB18                 ;org 0AB18h
.xdata$x:0000AB18 ; COMDAT (pick associative to section at 57A0)
.xdata$x:0000AB18 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000AB18                                         ; DATA XREF: .xdata$x:0000AB28o
.xdata$x:0000AB19                 db 0FFh
.xdata$x:0000AB1A                 db 0FFh
.xdata$x:0000AB1B                 db 0FFh
.xdata$x:0000AB1C                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
.xdata$x:0000AB20 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000AB20                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z+11o
.xdata$x:0000AB21                 db    5
.xdata$x:0000AB22                 db  93h ; ô
.xdata$x:0000AB23                 db  19h
.xdata$x:0000AB24                 db    1
.xdata$x:0000AB25                 db    0
.xdata$x:0000AB26                 db    0
.xdata$x:0000AB27                 db    0
.xdata$x:0000AB28                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.xdata$x:0000AB2C                 db    0
.xdata$x:0000AB2D                 db    0
.xdata$x:0000AB2E                 db    0
.xdata$x:0000AB2F                 db    0
.xdata$x:0000AB30                 db    0
.xdata$x:0000AB31                 db    0
.xdata$x:0000AB32                 db    0
.xdata$x:0000AB33                 db    0
.xdata$x:0000AB34                 db    0
.xdata$x:0000AB35                 db    0
.xdata$x:0000AB36                 db    0
.xdata$x:0000AB37                 db    0
.xdata$x:0000AB38                 db    0
.xdata$x:0000AB39                 db    0
.xdata$x:0000AB3A                 db    0
.xdata$x:0000AB3B                 db    0
.xdata$x:0000AB3C                 db    0
.xdata$x:0000AB3D                 db    0
.xdata$x:0000AB3E                 db    0
.xdata$x:0000AB3F                 db    0
.xdata$x:0000AB40                 db    0
.xdata$x:0000AB41                 db    0
.xdata$x:0000AB42                 db    0
.xdata$x:0000AB43                 db    0
.xdata$x:0000AB43 _xdata$x        ends
.xdata$x:0000AB43
.xdata$x:0000AB44 ; ===========================================================================
.xdata$x:0000AB44
.xdata$x:0000AB44 ; Segment type: Pure data
.xdata$x:0000AB44 ; Segment permissions: Read
.xdata$x:0000AB44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB44                 assume cs:_xdata$x
.xdata$x:0000AB44                 ;org 0AB44h
.xdata$x:0000AB44 ; COMDAT (pick associative to section at 6644)
.xdata$x:0000AB44 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000AB44                                         ; DATA XREF: .xdata$x:0000AB54o
.xdata$x:0000AB45                 db 0FFh
.xdata$x:0000AB46                 db 0FFh
.xdata$x:0000AB47                 db 0FFh
.xdata$x:0000AB48                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000AB4C __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AB4C                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000AB4D                 db    5
.xdata$x:0000AB4E                 db  93h ; ô
.xdata$x:0000AB4F                 db  19h
.xdata$x:0000AB50                 db    1
.xdata$x:0000AB51                 db    0
.xdata$x:0000AB52                 db    0
.xdata$x:0000AB53                 db    0
.xdata$x:0000AB54                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.xdata$x:0000AB58                 db    0
.xdata$x:0000AB59                 db    0
.xdata$x:0000AB5A                 db    0
.xdata$x:0000AB5B                 db    0
.xdata$x:0000AB5C                 db    0
.xdata$x:0000AB5D                 db    0
.xdata$x:0000AB5E                 db    0
.xdata$x:0000AB5F                 db    0
.xdata$x:0000AB60                 db    0
.xdata$x:0000AB61                 db    0
.xdata$x:0000AB62                 db    0
.xdata$x:0000AB63                 db    0
.xdata$x:0000AB64                 db    0
.xdata$x:0000AB65                 db    0
.xdata$x:0000AB66                 db    0
.xdata$x:0000AB67                 db    0
.xdata$x:0000AB68                 db    0
.xdata$x:0000AB69                 db    0
.xdata$x:0000AB6A                 db    0
.xdata$x:0000AB6B                 db    0
.xdata$x:0000AB6C                 db    0
.xdata$x:0000AB6D                 db    0
.xdata$x:0000AB6E                 db    0
.xdata$x:0000AB6F                 db    0
.xdata$x:0000AB6F _xdata$x        ends
.xdata$x:0000AB6F
.xdata$x:0000AB70 ; ===========================================================================
.xdata$x:0000AB70
.xdata$x:0000AB70 ; Segment type: Pure data
.xdata$x:0000AB70 ; Segment permissions: Read
.xdata$x:0000AB70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB70                 assume cs:_xdata$x
.xdata$x:0000AB70                 ;org 0AB70h
.xdata$x:0000AB70 ; COMDAT (pick associative to section at 5728)
.xdata$x:0000AB70 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000AB70                                         ; DATA XREF: .xdata$x:0000AB80o
.xdata$x:0000AB71                 db 0FFh
.xdata$x:0000AB72                 db 0FFh
.xdata$x:0000AB73                 db 0FFh
.xdata$x:0000AB74                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000AB78 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000AB78                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000AB79                 db    5
.xdata$x:0000AB7A                 db  93h ; ô
.xdata$x:0000AB7B                 db  19h
.xdata$x:0000AB7C                 db    1
.xdata$x:0000AB7D                 db    0
.xdata$x:0000AB7E                 db    0
.xdata$x:0000AB7F                 db    0
.xdata$x:0000AB80                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000AB84                 db    0
.xdata$x:0000AB85                 db    0
.xdata$x:0000AB86                 db    0
.xdata$x:0000AB87                 db    0
.xdata$x:0000AB88                 db    0
.xdata$x:0000AB89                 db    0
.xdata$x:0000AB8A                 db    0
.xdata$x:0000AB8B                 db    0
.xdata$x:0000AB8C                 db    0
.xdata$x:0000AB8D                 db    0
.xdata$x:0000AB8E                 db    0
.xdata$x:0000AB8F                 db    0
.xdata$x:0000AB90                 db    0
.xdata$x:0000AB91                 db    0
.xdata$x:0000AB92                 db    0
.xdata$x:0000AB93                 db    0
.xdata$x:0000AB94                 db    0
.xdata$x:0000AB95                 db    0
.xdata$x:0000AB96                 db    0
.xdata$x:0000AB97                 db    0
.xdata$x:0000AB98                 db    0
.xdata$x:0000AB99                 db    0
.xdata$x:0000AB9A                 db    0
.xdata$x:0000AB9B                 db    0
.xdata$x:0000AB9B _xdata$x        ends
.xdata$x:0000AB9B
.xdata$x:0000AB9C ; ===========================================================================
.xdata$x:0000AB9C
.xdata$x:0000AB9C ; Segment type: Pure data
.xdata$x:0000AB9C ; Segment permissions: Read
.xdata$x:0000AB9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB9C                 assume cs:_xdata$x
.xdata$x:0000AB9C                 ;org 0AB9Ch
.xdata$x:0000AB9C ; COMDAT (pick associative to section at 51F8)
.xdata$x:0000AB9C __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000AB9C                                         ; DATA XREF: .xdata$x:0000ABB4o
.xdata$x:0000AB9D                 db 0FFh
.xdata$x:0000AB9E                 db 0FFh
.xdata$x:0000AB9F                 db 0FFh
.xdata$x:0000ABA0                 dd offset __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$0
.xdata$x:0000ABA4                 align 8
.xdata$x:0000ABA8                 dd offset __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$1
.xdata$x:0000ABAC __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000ABAC                                         ; DATA XREF: __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z+11o
.xdata$x:0000ABAD                 db    5
.xdata$x:0000ABAE                 db  93h ; ô
.xdata$x:0000ABAF                 db  19h
.xdata$x:0000ABB0                 db    2
.xdata$x:0000ABB1                 db    0
.xdata$x:0000ABB2                 db    0
.xdata$x:0000ABB3                 db    0
.xdata$x:0000ABB4                 dd offset __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.xdata$x:0000ABB8                 db    0
.xdata$x:0000ABB9                 db    0
.xdata$x:0000ABBA                 db    0
.xdata$x:0000ABBB                 db    0
.xdata$x:0000ABBC                 db    0
.xdata$x:0000ABBD                 db    0
.xdata$x:0000ABBE                 db    0
.xdata$x:0000ABBF                 db    0
.xdata$x:0000ABC0                 db    0
.xdata$x:0000ABC1                 db    0
.xdata$x:0000ABC2                 db    0
.xdata$x:0000ABC3                 db    0
.xdata$x:0000ABC4                 db    0
.xdata$x:0000ABC5                 db    0
.xdata$x:0000ABC6                 db    0
.xdata$x:0000ABC7                 db    0
.xdata$x:0000ABC8                 db    0
.xdata$x:0000ABC9                 db    0
.xdata$x:0000ABCA                 db    0
.xdata$x:0000ABCB                 db    0
.xdata$x:0000ABCC                 db    0
.xdata$x:0000ABCD                 db    0
.xdata$x:0000ABCE                 db    0
.xdata$x:0000ABCF                 db    0
.xdata$x:0000ABCF _xdata$x        ends
.xdata$x:0000ABCF
.xdata$x:0000ABD0 ; ===========================================================================
.xdata$x:0000ABD0
.xdata$x:0000ABD0 ; Segment type: Pure data
.xdata$x:0000ABD0 ; Segment permissions: Read
.xdata$x:0000ABD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ABD0                 assume cs:_xdata$x
.xdata$x:0000ABD0                 ;org 0ABD0h
.xdata$x:0000ABD0 ; COMDAT (pick associative to section at 6E84)
.xdata$x:0000ABD0 __unwindtable$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ db 0FFh
.xdata$x:0000ABD0                                         ; DATA XREF: .xdata$x:0000ABE0o
.xdata$x:0000ABD1                 db 0FFh
.xdata$x:0000ABD2                 db 0FFh
.xdata$x:0000ABD3                 db 0FFh
.xdata$x:0000ABD4                 dd offset __unwindfunclet$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ$0
.xdata$x:0000ABD8 __ehfuncinfo$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ db  22h ; "
.xdata$x:0000ABD8                                         ; DATA XREF: __ehhandler$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ+11o
.xdata$x:0000ABD9                 db    5
.xdata$x:0000ABDA                 db  93h ; ô
.xdata$x:0000ABDB                 db  19h
.xdata$x:0000ABDC                 db    1
.xdata$x:0000ABDD                 db    0
.xdata$x:0000ABDE                 db    0
.xdata$x:0000ABDF                 db    0
.xdata$x:0000ABE0                 dd offset __unwindtable$??D?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QBEAAHXZ
.xdata$x:0000ABE4                 db    0
.xdata$x:0000ABE5                 db    0
.xdata$x:0000ABE6                 db    0
.xdata$x:0000ABE7                 db    0
.xdata$x:0000ABE8                 db    0
.xdata$x:0000ABE9                 db    0
.xdata$x:0000ABEA                 db    0
.xdata$x:0000ABEB                 db    0
.xdata$x:0000ABEC                 db    0
.xdata$x:0000ABED                 db    0
.xdata$x:0000ABEE                 db    0
.xdata$x:0000ABEF                 db    0
.xdata$x:0000ABF0                 db    0
.xdata$x:0000ABF1                 db    0
.xdata$x:0000ABF2                 db    0
.xdata$x:0000ABF3                 db    0
.xdata$x:0000ABF4                 db    0
.xdata$x:0000ABF5                 db    0
.xdata$x:0000ABF6                 db    0
.xdata$x:0000ABF7                 db    0
.xdata$x:0000ABF8                 db    0
.xdata$x:0000ABF9                 db    0
.xdata$x:0000ABFA                 db    0
.xdata$x:0000ABFB                 db    0
.xdata$x:0000ABFB _xdata$x        ends
.xdata$x:0000ABFB
.xdata$x:0000ABFC ; ===========================================================================
.xdata$x:0000ABFC
.xdata$x:0000ABFC ; Segment type: Pure data
.xdata$x:0000ABFC ; Segment permissions: Read
.xdata$x:0000ABFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ABFC                 assume cs:_xdata$x
.xdata$x:0000ABFC                 ;org 0ABFCh
.xdata$x:0000ABFC ; COMDAT (pick associative to section at 6234)
.xdata$x:0000ABFC __unwindtable$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000ABFC                                         ; DATA XREF: .xdata$x:0000AC0Co
.xdata$x:0000ABFD                 db 0FFh
.xdata$x:0000ABFE                 db 0FFh
.xdata$x:0000ABFF                 db 0FFh
.xdata$x:0000AC00                 dd offset __unwindfunclet$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ$0
.xdata$x:0000AC04 __ehfuncinfo$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AC04                                         ; DATA XREF: __ehhandler$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ+11o
.xdata$x:0000AC05                 db    5
.xdata$x:0000AC06                 db  93h ; ô
.xdata$x:0000AC07                 db  19h
.xdata$x:0000AC08                 db    1
.xdata$x:0000AC09                 db    0
.xdata$x:0000AC0A                 db    0
.xdata$x:0000AC0B                 db    0
.xdata$x:0000AC0C                 dd offset __unwindtable$??1?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@XZ
.xdata$x:0000AC10                 db    0
.xdata$x:0000AC11                 db    0
.xdata$x:0000AC12                 db    0
.xdata$x:0000AC13                 db    0
.xdata$x:0000AC14                 db    0
.xdata$x:0000AC15                 db    0
.xdata$x:0000AC16                 db    0
.xdata$x:0000AC17                 db    0
.xdata$x:0000AC18                 db    0
.xdata$x:0000AC19                 db    0
.xdata$x:0000AC1A                 db    0
.xdata$x:0000AC1B                 db    0
.xdata$x:0000AC1C                 db    0
.xdata$x:0000AC1D                 db    0
.xdata$x:0000AC1E                 db    0
.xdata$x:0000AC1F                 db    0
.xdata$x:0000AC20                 db    0
.xdata$x:0000AC21                 db    0
.xdata$x:0000AC22                 db    0
.xdata$x:0000AC23                 db    0
.xdata$x:0000AC24                 db    0
.xdata$x:0000AC25                 db    0
.xdata$x:0000AC26                 db    0
.xdata$x:0000AC27                 db    0
.xdata$x:0000AC27 _xdata$x        ends
.xdata$x:0000AC27
.xdata$x:0000AC28 ; ===========================================================================
.xdata$x:0000AC28
.xdata$x:0000AC28 ; Segment type: Pure data
.xdata$x:0000AC28 ; Segment permissions: Read
.xdata$x:0000AC28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AC28                 assume cs:_xdata$x
.xdata$x:0000AC28                 ;org 0AC28h
.xdata$x:0000AC28 ; COMDAT (pick associative to section at 5180)
.xdata$x:0000AC28 __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000AC28                                         ; DATA XREF: .xdata$x:0000AC38o
.xdata$x:0000AC29                 db 0FFh
.xdata$x:0000AC2A                 db 0FFh
.xdata$x:0000AC2B                 db 0FFh
.xdata$x:0000AC2C                 dd offset __unwindfunclet$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z$0
.xdata$x:0000AC30 __ehfuncinfo$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000AC30                                         ; DATA XREF: __ehhandler$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000AC31                 db    5
.xdata$x:0000AC32                 db  93h ; ô
.xdata$x:0000AC33                 db  19h
.xdata$x:0000AC34                 db    1
.xdata$x:0000AC35                 db    0
.xdata$x:0000AC36                 db    0
.xdata$x:0000AC37                 db    0
.xdata$x:0000AC38                 dd offset __unwindtable$??0?$_Revranit@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@U?$iterator@Urandom_access_iterator_tag@std@@HHPAHAAH@2@@std@@QAE@ABV01@@Z
.xdata$x:0000AC3C                 db    0
.xdata$x:0000AC3D                 db    0
.xdata$x:0000AC3E                 db    0
.xdata$x:0000AC3F                 db    0
.xdata$x:0000AC40                 db    0
.xdata$x:0000AC41                 db    0
.xdata$x:0000AC42                 db    0
.xdata$x:0000AC43                 db    0
.xdata$x:0000AC44                 db    0
.xdata$x:0000AC45                 db    0
.xdata$x:0000AC46                 db    0
.xdata$x:0000AC47                 db    0
.xdata$x:0000AC48                 db    0
.xdata$x:0000AC49                 db    0
.xdata$x:0000AC4A                 db    0
.xdata$x:0000AC4B                 db    0
.xdata$x:0000AC4C                 db    0
.xdata$x:0000AC4D                 db    0
.xdata$x:0000AC4E                 db    0
.xdata$x:0000AC4F                 db    0
.xdata$x:0000AC50                 db    0
.xdata$x:0000AC51                 db    0
.xdata$x:0000AC52                 db    0
.xdata$x:0000AC53                 db    0
.xdata$x:0000AC53 _xdata$x        ends
.xdata$x:0000AC53
.xdata$x:0000AC54 ; ===========================================================================
.xdata$x:0000AC54
.xdata$x:0000AC54 ; Segment type: Pure data
.xdata$x:0000AC54 ; Segment permissions: Read
.xdata$x:0000AC54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AC54                 assume cs:_xdata$x
.xdata$x:0000AC54                 ;org 0AC54h
.xdata$x:0000AC54 ; COMDAT (pick associative to section at 5CAC)
.xdata$x:0000AC54 __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z db 0FFh
.xdata$x:0000AC54                                         ; DATA XREF: .xdata$x:0000AC74o
.xdata$x:0000AC55                 db 0FFh
.xdata$x:0000AC56                 db 0FFh
.xdata$x:0000AC57                 db 0FFh
.xdata$x:0000AC58                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$0
.xdata$x:0000AC5C                 align 10h
.xdata$x:0000AC60                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$1
.xdata$x:0000AC64                 align 8
.xdata$x:0000AC68                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z$2
.xdata$x:0000AC6C __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z db  22h ; "
.xdata$x:0000AC6C                                         ; DATA XREF: __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z+11o
.xdata$x:0000AC6D                 db    5
.xdata$x:0000AC6E                 db  93h ; ô
.xdata$x:0000AC6F                 db  19h
.xdata$x:0000AC70                 db    3
.xdata$x:0000AC71                 db    0
.xdata$x:0000AC72                 db    0
.xdata$x:0000AC73                 db    0
.xdata$x:0000AC74                 dd offset __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@@Z
.xdata$x:0000AC78                 db    0
.xdata$x:0000AC79                 db    0
.xdata$x:0000AC7A                 db    0
.xdata$x:0000AC7B                 db    0
.xdata$x:0000AC7C                 db    0
.xdata$x:0000AC7D                 db    0
.xdata$x:0000AC7E                 db    0
.xdata$x:0000AC7F                 db    0
.xdata$x:0000AC80                 db    0
.xdata$x:0000AC81                 db    0
.xdata$x:0000AC82                 db    0
.xdata$x:0000AC83                 db    0
.xdata$x:0000AC84                 db    0
.xdata$x:0000AC85                 db    0
.xdata$x:0000AC86                 db    0
.xdata$x:0000AC87                 db    0
.xdata$x:0000AC88                 db    0
.xdata$x:0000AC89                 db    0
.xdata$x:0000AC8A                 db    0
.xdata$x:0000AC8B                 db    0
.xdata$x:0000AC8C                 db    0
.xdata$x:0000AC8D                 db    0
.xdata$x:0000AC8E                 db    0
.xdata$x:0000AC8F                 db    0
.xdata$x:0000AC8F _xdata$x        ends
.xdata$x:0000AC8F
.xdata$x:0000AC90 ; ===========================================================================
.xdata$x:0000AC90
.xdata$x:0000AC90 ; Segment type: Pure data
.xdata$x:0000AC90 ; Segment permissions: Read
.xdata$x:0000AC90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AC90                 assume cs:_xdata$x
.xdata$x:0000AC90                 ;org 0AC90h
.xdata$x:0000AC90 ; COMDAT (pick associative to section at 68FC)
.xdata$x:0000AC90 __unwindtable$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000AC90                                         ; DATA XREF: .xdata$x:0000ACA0o
.xdata$x:0000AC91                 db 0FFh
.xdata$x:0000AC92                 db 0FFh
.xdata$x:0000AC93                 db 0FFh
.xdata$x:0000AC94                 dd offset __unwindfunclet$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000AC98 __ehfuncinfo$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000AC98                                         ; DATA XREF: __ehhandler$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000AC99                 db    5
.xdata$x:0000AC9A                 db  93h ; ô
.xdata$x:0000AC9B                 db  19h
.xdata$x:0000AC9C                 db    1
.xdata$x:0000AC9D                 db    0
.xdata$x:0000AC9E                 db    0
.xdata$x:0000AC9F                 db    0
.xdata$x:0000ACA0                 dd offset __unwindtable$??1?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000ACA4                 db    0
.xdata$x:0000ACA5                 db    0
.xdata$x:0000ACA6                 db    0
.xdata$x:0000ACA7                 db    0
.xdata$x:0000ACA8                 db    0
.xdata$x:0000ACA9                 db    0
.xdata$x:0000ACAA                 db    0
.xdata$x:0000ACAB                 db    0
.xdata$x:0000ACAC                 db    0
.xdata$x:0000ACAD                 db    0
.xdata$x:0000ACAE                 db    0
.xdata$x:0000ACAF                 db    0
.xdata$x:0000ACB0                 db    0
.xdata$x:0000ACB1                 db    0
.xdata$x:0000ACB2                 db    0
.xdata$x:0000ACB3                 db    0
.xdata$x:0000ACB4                 db    0
.xdata$x:0000ACB5                 db    0
.xdata$x:0000ACB6                 db    0
.xdata$x:0000ACB7                 db    0
.xdata$x:0000ACB8                 db    0
.xdata$x:0000ACB9                 db    0
.xdata$x:0000ACBA                 db    0
.xdata$x:0000ACBB                 db    0
.xdata$x:0000ACBB _xdata$x        ends
.xdata$x:0000ACBB
.xdata$x:0000ACBC ; ===========================================================================
.xdata$x:0000ACBC
.xdata$x:0000ACBC ; Segment type: Pure data
.xdata$x:0000ACBC ; Segment permissions: Read
.xdata$x:0000ACBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ACBC                 assume cs:_xdata$x
.xdata$x:0000ACBC                 ;org 0ACBCh
.xdata$x:0000ACBC ; COMDAT (pick associative to section at 5C34)
.xdata$x:0000ACBC __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000ACBC                                         ; DATA XREF: .xdata$x:0000ACCCo
.xdata$x:0000ACBD                 db 0FFh
.xdata$x:0000ACBE                 db 0FFh
.xdata$x:0000ACBF                 db 0FFh
.xdata$x:0000ACC0                 dd offset __unwindfunclet$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000ACC4 __ehfuncinfo$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000ACC4                                         ; DATA XREF: __ehhandler$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000ACC5                 db    5
.xdata$x:0000ACC6                 db  93h ; ô
.xdata$x:0000ACC7                 db  19h
.xdata$x:0000ACC8                 db    1
.xdata$x:0000ACC9                 db    0
.xdata$x:0000ACCA                 db    0
.xdata$x:0000ACCB                 db    0
.xdata$x:0000ACCC                 dd offset __unwindtable$??0?$reverse_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000ACD0                 db    0
.xdata$x:0000ACD1                 db    0
.xdata$x:0000ACD2                 db    0
.xdata$x:0000ACD3                 db    0
.xdata$x:0000ACD4                 db    0
.xdata$x:0000ACD5                 db    0
.xdata$x:0000ACD6                 db    0
.xdata$x:0000ACD7                 db    0
.xdata$x:0000ACD8                 db    0
.xdata$x:0000ACD9                 db    0
.xdata$x:0000ACDA                 db    0
.xdata$x:0000ACDB                 db    0
.xdata$x:0000ACDC                 db    0
.xdata$x:0000ACDD                 db    0
.xdata$x:0000ACDE                 db    0
.xdata$x:0000ACDF                 db    0
.xdata$x:0000ACE0                 db    0
.xdata$x:0000ACE1                 db    0
.xdata$x:0000ACE2                 db    0
.xdata$x:0000ACE3                 db    0
.xdata$x:0000ACE4                 db    0
.xdata$x:0000ACE5                 db    0
.xdata$x:0000ACE6                 db    0
.xdata$x:0000ACE7                 db    0
.xdata$x:0000ACE7 _xdata$x        ends
.xdata$x:0000ACE7
.xdata$x:0000ACE8 ; ===========================================================================
.xdata$x:0000ACE8
.xdata$x:0000ACE8 ; Segment type: Pure data
.xdata$x:0000ACE8 ; Segment permissions: Read
.xdata$x:0000ACE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ACE8                 assume cs:_xdata$x
.xdata$x:0000ACE8                 ;org 0ACE8h
.xdata$x:0000ACE8 ; COMDAT (pick associative to section at 479C)
.xdata$x:0000ACE8 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000ACE8                                         ; DATA XREF: .xdata$x:0000ACF8o
.xdata$x:0000ACE9                 db 0FFh
.xdata$x:0000ACEA                 db 0FFh
.xdata$x:0000ACEB                 db 0FFh
.xdata$x:0000ACEC                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000ACF0 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000ACF0                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000ACF1                 db    5
.xdata$x:0000ACF2                 db  93h ; ô
.xdata$x:0000ACF3                 db  19h
.xdata$x:0000ACF4                 db    1
.xdata$x:0000ACF5                 db    0
.xdata$x:0000ACF6                 db    0
.xdata$x:0000ACF7                 db    0
.xdata$x:0000ACF8                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000ACFC                 db    0
.xdata$x:0000ACFD                 db    0
.xdata$x:0000ACFE                 db    0
.xdata$x:0000ACFF                 db    0
.xdata$x:0000AD00                 db    0
.xdata$x:0000AD01                 db    0
.xdata$x:0000AD02                 db    0
.xdata$x:0000AD03                 db    0
.xdata$x:0000AD04                 db    0
.xdata$x:0000AD05                 db    0
.xdata$x:0000AD06                 db    0
.xdata$x:0000AD07                 db    0
.xdata$x:0000AD08                 db    0
.xdata$x:0000AD09                 db    0
.xdata$x:0000AD0A                 db    0
.xdata$x:0000AD0B                 db    0
.xdata$x:0000AD0C                 db    0
.xdata$x:0000AD0D                 db    0
.xdata$x:0000AD0E                 db    0
.xdata$x:0000AD0F                 db    0
.xdata$x:0000AD10                 db    0
.xdata$x:0000AD11                 db    0
.xdata$x:0000AD12                 db    0
.xdata$x:0000AD13                 db    0
.xdata$x:0000AD13 _xdata$x        ends
.xdata$x:0000AD13
.xdata$x:0000AD14 ; ===========================================================================
.xdata$x:0000AD14
.xdata$x:0000AD14 ; Segment type: Pure data
.xdata$x:0000AD14 ; Segment permissions: Read
.xdata$x:0000AD14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AD14                 assume cs:_xdata$x
.xdata$x:0000AD14                 ;org 0AD14h
.xdata$x:0000AD14 ; COMDAT (pick associative to section at 2B60)
.xdata$x:0000AD14 __unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z db 0FFh
.xdata$x:0000AD14                                         ; DATA XREF: .xdata$x:0000AD3Co
.xdata$x:0000AD15                 db 0FFh
.xdata$x:0000AD16                 db 0FFh
.xdata$x:0000AD17                 db 0FFh
.xdata$x:0000AD18                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$0
.xdata$x:0000AD1C                 align 10h
.xdata$x:0000AD20                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$1
.xdata$x:0000AD24                 db    1
.xdata$x:0000AD25                 db    0
.xdata$x:0000AD26                 db    0
.xdata$x:0000AD27                 db    0
.xdata$x:0000AD28                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$2
.xdata$x:0000AD2C                 db    2
.xdata$x:0000AD2D                 db    0
.xdata$x:0000AD2E                 db    0
.xdata$x:0000AD2F                 db    0
.xdata$x:0000AD30                 dd offset __unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z$3
.xdata$x:0000AD34 __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z db  22h ; "
.xdata$x:0000AD34                                         ; DATA XREF: __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z+11o
.xdata$x:0000AD35                 db    5
.xdata$x:0000AD36                 db  93h ; ô
.xdata$x:0000AD37                 db  19h
.xdata$x:0000AD38                 db    4
.xdata$x:0000AD39                 db    0
.xdata$x:0000AD3A                 db    0
.xdata$x:0000AD3B                 db    0
.xdata$x:0000AD3C                 dd offset __unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WI@Z
.xdata$x:0000AD40                 db    0
.xdata$x:0000AD41                 db    0
.xdata$x:0000AD42                 db    0
.xdata$x:0000AD43                 db    0
.xdata$x:0000AD44                 db    0
.xdata$x:0000AD45                 db    0
.xdata$x:0000AD46                 db    0
.xdata$x:0000AD47                 db    0
.xdata$x:0000AD48                 db    0
.xdata$x:0000AD49                 db    0
.xdata$x:0000AD4A                 db    0
.xdata$x:0000AD4B                 db    0
.xdata$x:0000AD4C                 db    0
.xdata$x:0000AD4D                 db    0
.xdata$x:0000AD4E                 db    0
.xdata$x:0000AD4F                 db    0
.xdata$x:0000AD50                 db    0
.xdata$x:0000AD51                 db    0
.xdata$x:0000AD52                 db    0
.xdata$x:0000AD53                 db    0
.xdata$x:0000AD54                 db    0
.xdata$x:0000AD55                 db    0
.xdata$x:0000AD56                 db    0
.xdata$x:0000AD57                 db    0
.xdata$x:0000AD57 _xdata$x        ends
.xdata$x:0000AD57
.xdata$x:0000AD58 ; ===========================================================================
.xdata$x:0000AD58
.xdata$x:0000AD58 ; Segment type: Pure data
.xdata$x:0000AD58 ; Segment permissions: Read
.xdata$x:0000AD58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AD58                 assume cs:_xdata$x
.xdata$x:0000AD58                 ;org 0AD58h
.xdata$x:0000AD58 ; COMDAT (pick associative to section at 3C64)
.xdata$x:0000AD58 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z db 0FFh
.xdata$x:0000AD58                                         ; DATA XREF: .xdata$x:0000AD68o
.xdata$x:0000AD59                 db 0FFh
.xdata$x:0000AD5A                 db 0FFh
.xdata$x:0000AD5B                 db 0FFh
.xdata$x:0000AD5C                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z$0
.xdata$x:0000AD60 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z db  22h ; "
.xdata$x:0000AD60                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z+11o
.xdata$x:0000AD61                 db    5
.xdata$x:0000AD62                 db  93h ; ô
.xdata$x:0000AD63                 db  19h
.xdata$x:0000AD64                 db    1
.xdata$x:0000AD65                 db    0
.xdata$x:0000AD66                 db    0
.xdata$x:0000AD67                 db    0
.xdata$x:0000AD68                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@YAPAUColumnModeInfo@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@@Z
.xdata$x:0000AD6C                 db    0
.xdata$x:0000AD6D                 db    0
.xdata$x:0000AD6E                 db    0
.xdata$x:0000AD6F                 db    0
.xdata$x:0000AD70                 db    0
.xdata$x:0000AD71                 db    0
.xdata$x:0000AD72                 db    0
.xdata$x:0000AD73                 db    0
.xdata$x:0000AD74                 db    0
.xdata$x:0000AD75                 db    0
.xdata$x:0000AD76                 db    0
.xdata$x:0000AD77                 db    0
.xdata$x:0000AD78                 db    0
.xdata$x:0000AD79                 db    0
.xdata$x:0000AD7A                 db    0
.xdata$x:0000AD7B                 db    0
.xdata$x:0000AD7C                 db    0
.xdata$x:0000AD7D                 db    0
.xdata$x:0000AD7E                 db    0
.xdata$x:0000AD7F                 db    0
.xdata$x:0000AD80                 db    0
.xdata$x:0000AD81                 db    0
.xdata$x:0000AD82                 db    0
.xdata$x:0000AD83                 db    0
.xdata$x:0000AD83 _xdata$x        ends
.xdata$x:0000AD83
.xdata$x:0000AD84 ; ===========================================================================
.xdata$x:0000AD84
.xdata$x:0000AD84 ; Segment type: Pure data
.xdata$x:0000AD84 ; Segment permissions: Read
.xdata$x:0000AD84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AD84                 assume cs:_xdata$x
.xdata$x:0000AD84                 ;org 0AD84h
.xdata$x:0000AD84 ; COMDAT (pick associative to section at 2A0C)
.xdata$x:0000AD84 __unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000AD84                                         ; DATA XREF: .xdata$x:0000AD9Co
.xdata$x:0000AD85                 db 0FFh
.xdata$x:0000AD86                 db 0FFh
.xdata$x:0000AD87                 db 0FFh
.xdata$x:0000AD88                 dd offset __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000AD8C                 align 10h
.xdata$x:0000AD90                 dd offset __unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000AD94 __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000AD94                                         ; DATA XREF: __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000AD95                 db    5
.xdata$x:0000AD96                 db  93h ; ô
.xdata$x:0000AD97                 db  19h
.xdata$x:0000AD98                 db    2
.xdata$x:0000AD99                 db    0
.xdata$x:0000AD9A                 db    0
.xdata$x:0000AD9B                 db    0
.xdata$x:0000AD9C                 dd offset __unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.xdata$x:0000ADA0                 db    0
.xdata$x:0000ADA1                 db    0
.xdata$x:0000ADA2                 db    0
.xdata$x:0000ADA3                 db    0
.xdata$x:0000ADA4                 db    0
.xdata$x:0000ADA5                 db    0
.xdata$x:0000ADA6                 db    0
.xdata$x:0000ADA7                 db    0
.xdata$x:0000ADA8                 db    0
.xdata$x:0000ADA9                 db    0
.xdata$x:0000ADAA                 db    0
.xdata$x:0000ADAB                 db    0
.xdata$x:0000ADAC                 db    0
.xdata$x:0000ADAD                 db    0
.xdata$x:0000ADAE                 db    0
.xdata$x:0000ADAF                 db    0
.xdata$x:0000ADB0                 db    0
.xdata$x:0000ADB1                 db    0
.xdata$x:0000ADB2                 db    0
.xdata$x:0000ADB3                 db    0
.xdata$x:0000ADB4                 db    0
.xdata$x:0000ADB5                 db    0
.xdata$x:0000ADB6                 db    0
.xdata$x:0000ADB7                 db    0
.xdata$x:0000ADB7 _xdata$x        ends
.xdata$x:0000ADB7
.xdata$x:0000ADB8 ; ===========================================================================
.xdata$x:0000ADB8
.xdata$x:0000ADB8 ; Segment type: Pure data
.xdata$x:0000ADB8 ; Segment permissions: Read
.xdata$x:0000ADB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ADB8                 assume cs:_xdata$x
.xdata$x:0000ADB8                 ;org 0ADB8h
.xdata$x:0000ADB8 ; COMDAT (pick associative to section at 4450)
.xdata$x:0000ADB8 __unwindtable$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z db 0FFh
.xdata$x:0000ADB8                                         ; DATA XREF: .xdata$x:0000ADC8o
.xdata$x:0000ADB9                 db 0FFh
.xdata$x:0000ADBA                 db 0FFh
.xdata$x:0000ADBB                 db 0FFh
.xdata$x:0000ADBC                 dd offset __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0
.xdata$x:0000ADC0 __ehfuncinfo$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z db  22h ; "
.xdata$x:0000ADC0                                         ; DATA XREF: __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z+11o
.xdata$x:0000ADC1                 db    5
.xdata$x:0000ADC2                 db  93h ; ô
.xdata$x:0000ADC3                 db  19h
.xdata$x:0000ADC4                 db    1
.xdata$x:0000ADC5                 db    0
.xdata$x:0000ADC6                 db    0
.xdata$x:0000ADC7                 db    0
.xdata$x:0000ADC8                 dd offset __unwindtable$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.xdata$x:0000ADCC                 db    0
.xdata$x:0000ADCD                 db    0
.xdata$x:0000ADCE                 db    0
.xdata$x:0000ADCF                 db    0
.xdata$x:0000ADD0                 db    0
.xdata$x:0000ADD1                 db    0
.xdata$x:0000ADD2                 db    0
.xdata$x:0000ADD3                 db    0
.xdata$x:0000ADD4                 db    0
.xdata$x:0000ADD5                 db    0
.xdata$x:0000ADD6                 db    0
.xdata$x:0000ADD7                 db    0
.xdata$x:0000ADD8                 db    0
.xdata$x:0000ADD9                 db    0
.xdata$x:0000ADDA                 db    0
.xdata$x:0000ADDB                 db    0
.xdata$x:0000ADDC                 db    0
.xdata$x:0000ADDD                 db    0
.xdata$x:0000ADDE                 db    0
.xdata$x:0000ADDF                 db    0
.xdata$x:0000ADE0                 db    0
.xdata$x:0000ADE1                 db    0
.xdata$x:0000ADE2                 db    0
.xdata$x:0000ADE3                 db    0
.xdata$x:0000ADE3 _xdata$x        ends
.xdata$x:0000ADE3
.xdata$x:0000ADE4 ; ===========================================================================
.xdata$x:0000ADE4
.xdata$x:0000ADE4 ; Segment type: Pure data
.xdata$x:0000ADE4 ; Segment permissions: Read
.xdata$x:0000ADE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000ADE4                 assume cs:_xdata$x
.xdata$x:0000ADE4                 ;org 0ADE4h
.xdata$x:0000ADE4 ; COMDAT (pick associative to section at 459C)
.xdata$x:0000ADE4 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000ADE4                                         ; DATA XREF: .xdata$x:0000ADF4o
.xdata$x:0000ADE5                 db 0FFh
.xdata$x:0000ADE6                 db 0FFh
.xdata$x:0000ADE7                 db 0FFh
.xdata$x:0000ADE8                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000ADEC __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000ADEC                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000ADED                 db    5
.xdata$x:0000ADEE                 db  93h ; ô
.xdata$x:0000ADEF                 db  19h
.xdata$x:0000ADF0                 db    1
.xdata$x:0000ADF1                 db    0
.xdata$x:0000ADF2                 db    0
.xdata$x:0000ADF3                 db    0
.xdata$x:0000ADF4                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000ADF8                 db    0
.xdata$x:0000ADF9                 db    0
.xdata$x:0000ADFA                 db    0
.xdata$x:0000ADFB                 db    0
.xdata$x:0000ADFC                 db    0
.xdata$x:0000ADFD                 db    0
.xdata$x:0000ADFE                 db    0
.xdata$x:0000ADFF                 db    0
.xdata$x:0000AE00                 db    0
.xdata$x:0000AE01                 db    0
.xdata$x:0000AE02                 db    0
.xdata$x:0000AE03                 db    0
.xdata$x:0000AE04                 db    0
.xdata$x:0000AE05                 db    0
.xdata$x:0000AE06                 db    0
.xdata$x:0000AE07                 db    0
.xdata$x:0000AE08                 db    0
.xdata$x:0000AE09                 db    0
.xdata$x:0000AE0A                 db    0
.xdata$x:0000AE0B                 db    0
.xdata$x:0000AE0C                 db    0
.xdata$x:0000AE0D                 db    0
.xdata$x:0000AE0E                 db    0
.xdata$x:0000AE0F                 db    0
.xdata$x:0000AE0F _xdata$x        ends
.xdata$x:0000AE0F
.xdata$x:0000AE10 ; ===========================================================================
.xdata$x:0000AE10
.xdata$x:0000AE10 ; Segment type: Pure data
.xdata$x:0000AE10 ; Segment permissions: Read
.xdata$x:0000AE10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AE10                 assume cs:_xdata$x
.xdata$x:0000AE10                 ;org 0AE10h
.xdata$x:0000AE10 ; COMDAT (pick associative to section at 469C)
.xdata$x:0000AE10 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000AE10                                         ; DATA XREF: .xdata$x:0000AE20o
.xdata$x:0000AE11                 db 0FFh
.xdata$x:0000AE12                 db 0FFh
.xdata$x:0000AE13                 db 0FFh
.xdata$x:0000AE14                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000AE18 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000AE18                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000AE19                 db    5
.xdata$x:0000AE1A                 db  93h ; ô
.xdata$x:0000AE1B                 db  19h
.xdata$x:0000AE1C                 db    1
.xdata$x:0000AE1D                 db    0
.xdata$x:0000AE1E                 db    0
.xdata$x:0000AE1F                 db    0
.xdata$x:0000AE20                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:0000AE24                 db    0
.xdata$x:0000AE25                 db    0
.xdata$x:0000AE26                 db    0
.xdata$x:0000AE27                 db    0
.xdata$x:0000AE28                 db    0
.xdata$x:0000AE29                 db    0
.xdata$x:0000AE2A                 db    0
.xdata$x:0000AE2B                 db    0
.xdata$x:0000AE2C                 db    0
.xdata$x:0000AE2D                 db    0
.xdata$x:0000AE2E                 db    0
.xdata$x:0000AE2F                 db    0
.xdata$x:0000AE30                 db    0
.xdata$x:0000AE31                 db    0
.xdata$x:0000AE32                 db    0
.xdata$x:0000AE33                 db    0
.xdata$x:0000AE34                 db    0
.xdata$x:0000AE35                 db    0
.xdata$x:0000AE36                 db    0
.xdata$x:0000AE37                 db    0
.xdata$x:0000AE38                 db    0
.xdata$x:0000AE39                 db    0
.xdata$x:0000AE3A                 db    0
.xdata$x:0000AE3B                 db    0
.xdata$x:0000AE3B _xdata$x        ends
.xdata$x:0000AE3B
.bss:0000AE3C ; ===========================================================================
.bss:0000AE3C
.bss:0000AE3C ; Segment type: Uninitialized
.bss:0000AE3C ; Segment permissions: Read/Write
.bss:0000AE3C _bss            segment byte public 'BSS' use32
.bss:0000AE3C                 assume cs:_bss
.bss:0000AE3C                 ;org 0AE3Ch
.bss:0000AE3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000AE3C __Tuple_alloc   db    ? ;
.bss:0000AE3D ; std::_Ignore ignore
.bss:0000AE3D _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:0000AE3E _allocator_arg  db    ? ;
.bss:0000AE3F _piecewise_construct db    ? ;
.bss:0000AE3F _bss            ends
.bss:0000AE3F
.rdata:0000AE40 ; ===========================================================================
.rdata:0000AE40
.rdata:0000AE40 ; Segment type: Pure data
.rdata:0000AE40 ; Segment permissions: Read
.rdata:0000AE40 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AE40 _rdata          segment para public 'DATA' use32
.rdata:0000AE40                 assume cs:_rdata
.rdata:0000AE40                 ;org 0AE40h
.rdata:0000AE40 ; COMDAT (pick any)
.rdata:0000AE40                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000AE40 ; wchar_t `string'
.rdata:0000AE40 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000AE40                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:0000AE40                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000AE40                 unicode 0, <clude\xutility>,0
.rdata:0000AE40 _rdata          ends
.rdata:0000AE40
.rdata:0000AED0 ; ===========================================================================
.rdata:0000AED0
.rdata:0000AED0 ; Segment type: Pure data
.rdata:0000AED0 ; Segment permissions: Read
.rdata:0000AED0 _rdata          segment dword public 'DATA' use32
.rdata:0000AED0                 assume cs:_rdata
.rdata:0000AED0                 ;org 0AED0h
.rdata:0000AED0 ; COMDAT (pick any)
.rdata:0000AED0                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000AED0 ; wchar_t `string'
.rdata:0000AED0 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000AED0                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000AED0                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000AF02                 align 4
.rdata:0000AF02 _rdata          ends
.rdata:0000AF02
.rdata:0000AF04 ; ===========================================================================
.rdata:0000AF04
.rdata:0000AF04 ; Segment type: Pure data
.rdata:0000AF04 ; Segment permissions: Read
.rdata:0000AF04 _rdata          segment dword public 'DATA' use32
.rdata:0000AF04                 assume cs:_rdata
.rdata:0000AF04                 ;org 0AF04h
.rdata:0000AF04 ; COMDAT (pick largest)
.rdata:0000AF04                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:0000AF08                 public ??_7runtime_error@std@@6B@
.rdata:0000AF08 ; const std::runtime_error::`vftable'
.rdata:0000AF08 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:0000AF08                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:0000AF08                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:0000AF08                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:0000AF0C                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:0000AF0C _rdata          ends
.rdata:0000AF0C
.xdata$x:0000AF10 ; ===========================================================================
.xdata$x:0000AF10
.xdata$x:0000AF10 ; Segment type: Pure data
.xdata$x:0000AF10 ; Segment permissions: Read
.xdata$x:0000AF10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AF10                 assume cs:_xdata$x
.xdata$x:0000AF10                 ;org 0AF10h
.xdata$x:0000AF10 ; COMDAT (pick any)
.xdata$x:0000AF10                 public __TI2?AVruntime_error@std@@
.xdata$x:0000AF10 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: ColumnEditorDlg::init(HINSTANCE__ *,HWND__ *,ScintillaEditView * *)+2Co
.xdata$x:0000AF11                 db    0
.xdata$x:0000AF12                 db    0
.xdata$x:0000AF13                 db    0
.xdata$x:0000AF14                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:0000AF18                 db    0
.xdata$x:0000AF19                 db    0
.xdata$x:0000AF1A                 db    0
.xdata$x:0000AF1B                 db    0
.xdata$x:0000AF1C                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:0000AF1C _xdata$x        ends
.xdata$x:0000AF1C
.xdata$x:0000AF20 ; ===========================================================================
.xdata$x:0000AF20
.xdata$x:0000AF20 ; Segment type: Pure data
.xdata$x:0000AF20 ; Segment permissions: Read
.xdata$x:0000AF20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AF20                 assume cs:_xdata$x
.xdata$x:0000AF20                 ;org 0AF20h
.xdata$x:0000AF20 ; COMDAT (pick any)
.xdata$x:0000AF20                 public __CTA2?AVruntime_error@std@@
.xdata$x:0000AF20 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:0000AF1Co
.xdata$x:0000AF21                 db    0
.xdata$x:0000AF22                 db    0
.xdata$x:0000AF23                 db    0
.xdata$x:0000AF24                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:0000AF28                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:0000AF28 _xdata$x        ends
.xdata$x:0000AF28
.data$r:0000AF2C ; ===========================================================================
.data$r:0000AF2C
.data$r:0000AF2C ; Segment type: Pure data
.data$r:0000AF2C ; Segment permissions: Read/Write
.data$r:0000AF2C _data$r         segment dword public 'DATA' use32
.data$r:0000AF2C                 assume cs:_data$r
.data$r:0000AF2C                 ;org 0AF2Ch
.data$r:0000AF2C ; COMDAT (pick any)
.data$r:0000AF2C                 public ??_R0?AVruntime_error@std@@@8
.data$r:0000AF2C ; class std::runtime_error `RTTI Type Descriptor'
.data$r:0000AF2C ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000AF2C                                         ; DATA XREF: .xdata$x:0000AF50o
.data$r:0000AF2C                                         ; .rdata$r:0000B874o ...
.data$r:0000AF2C                                         ; const type_info::`vftable'
.data$r:0000AF30                 db    0
.data$r:0000AF31                 db    0
.data$r:0000AF32                 db    0
.data$r:0000AF33                 db    0
.data$r:0000AF34                 db  2Eh ; .
.data$r:0000AF35                 db  3Fh ; ?
.data$r:0000AF36                 db  41h ; A
.data$r:0000AF37                 db  56h ; V
.data$r:0000AF38                 db  72h ; r
.data$r:0000AF39                 db  75h ; u
.data$r:0000AF3A                 db  6Eh ; n
.data$r:0000AF3B                 db  74h ; t
.data$r:0000AF3C                 db  69h ; i
.data$r:0000AF3D                 db  6Dh ; m
.data$r:0000AF3E                 db  65h ; e
.data$r:0000AF3F                 db  5Fh ; _
.data$r:0000AF40                 db  65h ; e
.data$r:0000AF41                 db  72h ; r
.data$r:0000AF42                 db  72h ; r
.data$r:0000AF43                 db  6Fh ; o
.data$r:0000AF44                 db  72h ; r
.data$r:0000AF45                 db  40h ; @
.data$r:0000AF46                 db  73h ; s
.data$r:0000AF47                 db  74h ; t
.data$r:0000AF48                 db  64h ; d
.data$r:0000AF49                 db  40h ; @
.data$r:0000AF4A                 db  40h ; @
.data$r:0000AF4B                 db    0
.data$r:0000AF4B _data$r         ends
.data$r:0000AF4B
.xdata$x:0000AF4C ; ===========================================================================
.xdata$x:0000AF4C
.xdata$x:0000AF4C ; Segment type: Pure data
.xdata$x:0000AF4C ; Segment permissions: Read
.xdata$x:0000AF4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AF4C                 assume cs:_xdata$x
.xdata$x:0000AF4C                 ;org 0AF4Ch
.xdata$x:0000AF4C ; COMDAT (pick any)
.xdata$x:0000AF4C                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:0000AF4C __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:0000AF4C                                         ; DATA XREF: .xdata$x:0000AF24o
.xdata$x:0000AF4D                 db    0
.xdata$x:0000AF4E                 db    0
.xdata$x:0000AF4F                 db    0
.xdata$x:0000AF50                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:0000AF54                 align 8
.xdata$x:0000AF58                 db 0FFh
.xdata$x:0000AF59                 db 0FFh
.xdata$x:0000AF5A                 db 0FFh
.xdata$x:0000AF5B                 db 0FFh
.xdata$x:0000AF5C                 db    0
.xdata$x:0000AF5D                 db    0
.xdata$x:0000AF5E                 db    0
.xdata$x:0000AF5F                 db    0
.xdata$x:0000AF60                 db  0Ch
.xdata$x:0000AF61                 db    0
.xdata$x:0000AF62                 db    0
.xdata$x:0000AF63                 db    0
.xdata$x:0000AF64                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:0000AF64 _xdata$x        ends
.xdata$x:0000AF64
.data$r:0000AF68 ; ===========================================================================
.data$r:0000AF68
.data$r:0000AF68 ; Segment type: Pure data
.data$r:0000AF68 ; Segment permissions: Read/Write
.data$r:0000AF68 _data$r         segment dword public 'DATA' use32
.data$r:0000AF68                 assume cs:_data$r
.data$r:0000AF68                 ;org 0AF68h
.data$r:0000AF68 ; COMDAT (pick any)
.data$r:0000AF68                 public ??_R0?AVexception@std@@@8
.data$r:0000AF68 ; class std::exception `RTTI Type Descriptor'
.data$r:0000AF68 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000AF68                                         ; DATA XREF: .xdata$x:0000AF88o
.data$r:0000AF68                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000AF68                                         ; const type_info::`vftable'
.data$r:0000AF6C                 align 10h
.data$r:0000AF70 a_?avexception@ db '.?AVexception@std@@',0
.data$r:0000AF70 _data$r         ends
.data$r:0000AF70
.xdata$x:0000AF84 ; ===========================================================================
.xdata$x:0000AF84
.xdata$x:0000AF84 ; Segment type: Pure data
.xdata$x:0000AF84 ; Segment permissions: Read
.xdata$x:0000AF84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AF84                 assume cs:_xdata$x
.xdata$x:0000AF84                 ;org 0AF84h
.xdata$x:0000AF84 ; COMDAT (pick any)
.xdata$x:0000AF84                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:0000AF84 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:0000AF84                                         ; DATA XREF: .xdata$x:0000AF28o
.xdata$x:0000AF85                 db    0
.xdata$x:0000AF86                 db    0
.xdata$x:0000AF87                 db    0
.xdata$x:0000AF88                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:0000AF8C                 align 10h
.xdata$x:0000AF90                 db 0FFh
.xdata$x:0000AF91                 db 0FFh
.xdata$x:0000AF92                 db 0FFh
.xdata$x:0000AF93                 db 0FFh
.xdata$x:0000AF94                 db    0
.xdata$x:0000AF95                 db    0
.xdata$x:0000AF96                 db    0
.xdata$x:0000AF97                 db    0
.xdata$x:0000AF98                 db  0Ch
.xdata$x:0000AF99                 db    0
.xdata$x:0000AF9A                 db    0
.xdata$x:0000AF9B                 db    0
.xdata$x:0000AF9C                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:0000AF9C _xdata$x        ends
.xdata$x:0000AF9C
.rdata:0000AFA0 ; ===========================================================================
.rdata:0000AFA0
.rdata:0000AFA0 ; Segment type: Pure data
.rdata:0000AFA0 ; Segment permissions: Read
.rdata:0000AFA0 _rdata          segment dword public 'DATA' use32
.rdata:0000AFA0                 assume cs:_rdata
.rdata:0000AFA0                 ;org 0AFA0h
.rdata:0000AFA0 ; COMDAT (pick largest)
.rdata:0000AFA0                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000AFA4                 public ??_7error_category@std@@6B@
.rdata:0000AFA4 ; const std::error_category::`vftable'
.rdata:0000AFA4 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000AFA4                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000AFA4                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000AFA4                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000AFA8                 dd offset __purecall
.rdata:0000AFAC                 dd offset __purecall
.rdata:0000AFB0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000AFB4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000AFB8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000AFB8 _rdata          ends
.rdata:0000AFB8
.rdata:0000AFBC ; ===========================================================================
.rdata:0000AFBC
.rdata:0000AFBC ; Segment type: Pure data
.rdata:0000AFBC ; Segment permissions: Read
.rdata:0000AFBC _rdata          segment dword public 'DATA' use32
.rdata:0000AFBC                 assume cs:_rdata
.rdata:0000AFBC                 ;org 0AFBCh
.rdata:0000AFBC ; COMDAT (pick largest)
.rdata:0000AFBC                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000AFC0                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000AFC0 ; const std::_Generic_error_category::`vftable'
.rdata:0000AFC0 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000AFC0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000AFC0                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000AFC4                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000AFC8                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000AFCC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000AFD0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000AFD4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000AFD4 _rdata          ends
.rdata:0000AFD4
.rdata:0000AFD8 ; ===========================================================================
.rdata:0000AFD8
.rdata:0000AFD8 ; Segment type: Pure data
.rdata:0000AFD8 ; Segment permissions: Read
.rdata:0000AFD8 _rdata          segment dword public 'DATA' use32
.rdata:0000AFD8                 assume cs:_rdata
.rdata:0000AFD8                 ;org 0AFD8h
.rdata:0000AFD8 ; COMDAT (pick any)
.rdata:0000AFD8                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000AFD8 ; `string'
.rdata:0000AFD8 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000AFD8                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000AFD8 _rdata          ends
.rdata:0000AFD8
.rdata:0000AFE0 ; ===========================================================================
.rdata:0000AFE0
.rdata:0000AFE0 ; Segment type: Pure data
.rdata:0000AFE0 ; Segment permissions: Read
.rdata:0000AFE0 _rdata          segment dword public 'DATA' use32
.rdata:0000AFE0                 assume cs:_rdata
.rdata:0000AFE0                 ;org 0AFE0h
.rdata:0000AFE0 ; COMDAT (pick any)
.rdata:0000AFE0                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000AFE0 ; `string'
.rdata:0000AFE0 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000AFE0                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_98E0o
.rdata:0000AFE0                                         ; std::_System_error_category::message(int):loc_9A5Co
.rdata:0000AFEE                 align 10h
.rdata:0000AFEE _rdata          ends
.rdata:0000AFEE
.rdata:0000AFF0 ; ===========================================================================
.rdata:0000AFF0
.rdata:0000AFF0 ; Segment type: Pure data
.rdata:0000AFF0 ; Segment permissions: Read
.rdata:0000AFF0 _rdata          segment dword public 'DATA' use32
.rdata:0000AFF0                 assume cs:_rdata
.rdata:0000AFF0                 ;org 0AFF0h
.rdata:0000AFF0 ; COMDAT (pick largest)
.rdata:0000AFF0                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000AFF4                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000AFF4 ; const std::_Iostream_error_category::`vftable'
.rdata:0000AFF4 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000AFF4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000AFF4                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000AFF8                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000AFFC                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000B000                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000B004                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000B008                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000B008 _rdata          ends
.rdata:0000B008
.rdata:0000B00C ; ===========================================================================
.rdata:0000B00C
.rdata:0000B00C ; Segment type: Pure data
.rdata:0000B00C ; Segment permissions: Read
.rdata:0000B00C _rdata          segment dword public 'DATA' use32
.rdata:0000B00C                 assume cs:_rdata
.rdata:0000B00C                 ;org 0B00Ch
.rdata:0000B00C ; COMDAT (pick any)
.rdata:0000B00C                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000B00C ; `string'
.rdata:0000B00C ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000B00C                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000B015                 align 4
.rdata:0000B015 _rdata          ends
.rdata:0000B015
.rdata:0000B018 ; ===========================================================================
.rdata:0000B018
.rdata:0000B018 ; Segment type: Pure data
.rdata:0000B018 ; Segment permissions: Read
.rdata:0000B018 _rdata          segment dword public 'DATA' use32
.rdata:0000B018                 assume cs:_rdata
.rdata:0000B018                 ;org 0B018h
.rdata:0000B018 ; COMDAT (pick any)
.rdata:0000B018                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000B018 ; char `string'[]
.rdata:0000B018 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000B018                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000B02E                 align 10h
.rdata:0000B02E _rdata          ends
.rdata:0000B02E
.rdata:0000B030 ; ===========================================================================
.rdata:0000B030
.rdata:0000B030 ; Segment type: Pure data
.rdata:0000B030 ; Segment permissions: Read
.rdata:0000B030 _rdata          segment dword public 'DATA' use32
.rdata:0000B030                 assume cs:_rdata
.rdata:0000B030                 ;org 0B030h
.rdata:0000B030 ; COMDAT (pick largest)
.rdata:0000B030                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000B034                 public ??_7_System_error_category@std@@6B@
.rdata:0000B034 ; const std::_System_error_category::`vftable'
.rdata:0000B034 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000B034                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000B034                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000B038                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000B03C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000B040                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000B044                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000B048                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000B048 _rdata          ends
.rdata:0000B048
.rdata:0000B04C ; ===========================================================================
.rdata:0000B04C
.rdata:0000B04C ; Segment type: Pure data
.rdata:0000B04C ; Segment permissions: Read
.rdata:0000B04C _rdata          segment dword public 'DATA' use32
.rdata:0000B04C                 assume cs:_rdata
.rdata:0000B04C                 ;org 0B04Ch
.rdata:0000B04C ; COMDAT (pick any)
.rdata:0000B04C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000B04C ; `string'
.rdata:0000B04C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000B04C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000B053                 align 4
.rdata:0000B053 _rdata          ends
.rdata:0000B053
.bss:0000B054 ; ===========================================================================
.bss:0000B054
.bss:0000B054 ; Segment type: Uninitialized
.bss:0000B054 ; Segment permissions: Read/Write
.bss:0000B054 _bss            segment dword public 'BSS' use32
.bss:0000B054                 assume cs:_bss
.bss:0000B054                 ;org 0B054h
.bss:0000B054 ; COMDAT (pick any)
.bss:0000B054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000B054                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000B054 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000B054 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000B054                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000B054                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000B055                 db    ? ;
.bss:0000B056                 db    ? ;
.bss:0000B057                 db    ? ;
.bss:0000B057 _bss            ends
.bss:0000B057
.bss:0000B058 ; ===========================================================================
.bss:0000B058
.bss:0000B058 ; Segment type: Uninitialized
.bss:0000B058 ; Segment permissions: Read/Write
.bss:0000B058 _bss            segment dword public 'BSS' use32
.bss:0000B058                 assume cs:_bss
.bss:0000B058                 ;org 0B058h
.bss:0000B058 ; COMDAT (pick any)
.bss:0000B058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000B058                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000B058 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000B058 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000B058                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000B058                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000B059                 db    ? ;
.bss:0000B05A                 db    ? ;
.bss:0000B05B                 db    ? ;
.bss:0000B05B _bss            ends
.bss:0000B05B
.bss:0000B05C ; ===========================================================================
.bss:0000B05C
.bss:0000B05C ; Segment type: Uninitialized
.bss:0000B05C ; Segment permissions: Read/Write
.bss:0000B05C _bss            segment dword public 'BSS' use32
.bss:0000B05C                 assume cs:_bss
.bss:0000B05C                 ;org 0B05Ch
.bss:0000B05C ; COMDAT (pick any)
.bss:0000B05C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000B05C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000B05C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000B05C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000B05C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000B05C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000B05D                 db    ? ;
.bss:0000B05E                 db    ? ;
.bss:0000B05F                 db    ? ;
.bss:0000B05F _bss            ends
.bss:0000B05F
.rdata:0000B060 ; ===========================================================================
.rdata:0000B060
.rdata:0000B060 ; Segment type: Pure data
.rdata:0000B060 ; Segment permissions: Read
.rdata:0000B060 _rdata          segment dword public 'DATA' use32
.rdata:0000B060                 assume cs:_rdata
.rdata:0000B060                 ;org 0B060h
.rdata:0000B060 ; COMDAT (pick any)
.rdata:0000B060                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000B060 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000B060 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000B060                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7r
.rdata:0000B060                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+3Dr ...
.rdata:0000B060 _rdata          ends
.rdata:0000B060
.bss:0000B064 ; ===========================================================================
.bss:0000B064
.bss:0000B064 ; Segment type: Uninitialized
.bss:0000B064 ; Segment permissions: Read/Write
.bss:0000B064 _bss            segment dword public 'BSS' use32
.bss:0000B064                 assume cs:_bss
.bss:0000B064                 ;org 0B064h
.bss:0000B064 ; COMDAT (pick any)
.bss:0000B064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000B064                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000B064 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000B064 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000B064                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000B065                 db    ? ;
.bss:0000B066                 db    ? ;
.bss:0000B067                 db    ? ;
.bss:0000B067 _bss            ends
.bss:0000B067
.bss:0000B068 ; ===========================================================================
.bss:0000B068
.bss:0000B068 ; Segment type: Uninitialized
.bss:0000B068 ; Segment permissions: Read/Write
.bss:0000B068 _bss            segment dword public 'BSS' use32
.bss:0000B068                 assume cs:_bss
.bss:0000B068                 ;org 0B068h
.bss:0000B068 ; COMDAT (pick any)
.bss:0000B068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000B068                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000B068 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000B068 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000B068                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000B069                 db    ? ;
.bss:0000B06A                 db    ? ;
.bss:0000B06B                 db    ? ;
.bss:0000B06B _bss            ends
.bss:0000B06B
.rdata:0000B06C ; ===========================================================================
.rdata:0000B06C
.rdata:0000B06C ; Segment type: Pure data
.rdata:0000B06C ; Segment permissions: Read
.rdata:0000B06C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B06C _rdata          segment para public 'DATA' use32
.rdata:0000B06C                 assume cs:_rdata
.rdata:0000B06C                 ;org 0B06Ch
.rdata:0000B06C ; COMDAT (pick any)
.rdata:0000B06C                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000B06C ; wchar_t `string'
.rdata:0000B06C ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000B06C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+Co
.rdata:0000B06C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+14o ...
.rdata:0000B06C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000B06C                 unicode 0, <clude\xstring>,0
.rdata:0000B0FA                 align 4
.rdata:0000B0FA _rdata          ends
.rdata:0000B0FA
.bss:0000B0FC ; ===========================================================================
.bss:0000B0FC
.bss:0000B0FC ; Segment type: Uninitialized
.bss:0000B0FC ; Segment permissions: Read/Write
.bss:0000B0FC _bss            segment dword public 'BSS' use32
.bss:0000B0FC                 assume cs:_bss
.bss:0000B0FC                 ;org 0B0FCh
.bss:0000B0FC ; COMDAT (pick any)
.bss:0000B0FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000B0FC                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000B0FC ; std::locale::id std::numpunct<char>::id
.bss:0000B0FC ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000B0FC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000B0FD                 db    ? ;
.bss:0000B0FE                 db    ? ;
.bss:0000B0FF                 db    ? ;
.bss:0000B0FF _bss            ends
.bss:0000B0FF
.bss:0000B100 ; ===========================================================================
.bss:0000B100
.bss:0000B100 ; Segment type: Uninitialized
.bss:0000B100 ; Segment permissions: Read/Write
.bss:0000B100 _bss            segment dword public 'BSS' use32
.bss:0000B100                 assume cs:_bss
.bss:0000B100                 ;org 0B100h
.bss:0000B100 ; COMDAT (pick any)
.bss:0000B100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000B100                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000B100 ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000B100 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000B100                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000B101                 db    ? ;
.bss:0000B102                 db    ? ;
.bss:0000B103                 db    ? ;
.bss:0000B103 _bss            ends
.bss:0000B103
.rdata:0000B104 ; ===========================================================================
.rdata:0000B104
.rdata:0000B104 ; Segment type: Pure data
.rdata:0000B104 ; Segment permissions: Read
.rdata:0000B104 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B104 _rdata          segment para public 'DATA' use32
.rdata:0000B104                 assume cs:_rdata
.rdata:0000B104                 ;org 0B104h
.rdata:0000B104 ; COMDAT (pick any)
.rdata:0000B104                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000B104 ; wchar_t `string'
.rdata:0000B104 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000B104                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+44o
.rdata:0000B104                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+71o ...
.rdata:0000B104                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000B104                 unicode 0, <clude\vector>,0
.rdata:0000B104 _rdata          ends
.rdata:0000B104
.rdata:0000B190 ; ===========================================================================
.rdata:0000B190
.rdata:0000B190 ; Segment type: Pure data
.rdata:0000B190 ; Segment permissions: Read
.rdata:0000B190 _rdata          segment dword public 'DATA' use32
.rdata:0000B190                 assume cs:_rdata
.rdata:0000B190                 ;org 0B190h
.rdata:0000B190 ; COMDAT (pick any)
.rdata:0000B190                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000B190 ; `string'
.rdata:0000B190 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000B190                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+56o
.rdata:0000B190                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+46o
.rdata:0000B190 _rdata          ends
.rdata:0000B190
.rdata:0000B1B4 ; ===========================================================================
.rdata:0000B1B4
.rdata:0000B1B4 ; Segment type: Pure data
.rdata:0000B1B4 ; Segment permissions: Read
.rdata:0000B1B4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B1B4 _rdata          segment para public 'DATA' use32
.rdata:0000B1B4                 assume cs:_rdata
.rdata:0000B1B4                 ;org 0B1B4h
.rdata:0000B1B4 ; COMDAT (pick any)
.rdata:0000B1B4                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000B1B4 ; `string'
.rdata:0000B1B4 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000B1B4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void):loc_6F7Bo
.rdata:0000B1B4                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void):loc_702Bo
.rdata:0000B1B4                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000B20A                 align 4
.rdata:0000B20A _rdata          ends
.rdata:0000B20A
.rdata:0000B20C ; ===========================================================================
.rdata:0000B20C
.rdata:0000B20C ; Segment type: Pure data
.rdata:0000B20C ; Segment permissions: Read
.rdata:0000B20C _rdata          segment dword public 'DATA' use32
.rdata:0000B20C                 assume cs:_rdata
.rdata:0000B20C                 ;org 0B20Ch
.rdata:0000B20C ; COMDAT (pick any)
.rdata:0000B20C                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000B20C ; `string'
.rdata:0000B20C ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000B20C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+68o
.rdata:0000B20C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+58o ...
.rdata:0000B20C                 unicode 0, <%s>,0
.rdata:0000B212                 align 4
.rdata:0000B212 _rdata          ends
.rdata:0000B212
.rdata:0000B214 ; ===========================================================================
.rdata:0000B214
.rdata:0000B214 ; Segment type: Pure data
.rdata:0000B214 ; Segment permissions: Read
.rdata:0000B214 _rdata          segment dword public 'DATA' use32
.rdata:0000B214                 assume cs:_rdata
.rdata:0000B214                 ;org 0B214h
.rdata:0000B214 ; COMDAT (pick any)
.rdata:0000B214                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000B214 ; `string'
.rdata:0000B214 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000B214                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+94o
.rdata:0000B214                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+8Ao
.rdata:0000B214                 unicode 0, <"out of range">,0
.rdata:0000B232                 align 4
.rdata:0000B232 _rdata          ends
.rdata:0000B232
.rdata:0000B234 ; ===========================================================================
.rdata:0000B234
.rdata:0000B234 ; Segment type: Pure data
.rdata:0000B234 ; Segment permissions: Read
.rdata:0000B234 _rdata          segment dword public 'DATA' use32
.rdata:0000B234                 assume cs:_rdata
.rdata:0000B234                 ;org 0B234h
.rdata:0000B234 ; COMDAT (pick any)
.rdata:0000B234                 public ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
.rdata:0000B234 ; char `string'[]
.rdata:0000B234 ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ db 'invalid vector<T> subscript',0
.rdata:0000B234                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Xran(void)+7o
.rdata:0000B234 _rdata          ends
.rdata:0000B234
.rdata:0000B250 ; ===========================================================================
.rdata:0000B250
.rdata:0000B250 ; Segment type: Pure data
.rdata:0000B250 ; Segment permissions: Read
.rdata:0000B250 _rdata          segment dword public 'DATA' use32
.rdata:0000B250                 assume cs:_rdata
.rdata:0000B250                 ;org 0B250h
.rdata:0000B250 ; COMDAT (pick any)
.rdata:0000B250                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:0000B250 ; `string'
.rdata:0000B250 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:0000B250                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+41o
.rdata:0000B250 _rdata          ends
.rdata:0000B250
.rdata:0000B278 ; ===========================================================================
.rdata:0000B278
.rdata:0000B278 ; Segment type: Pure data
.rdata:0000B278 ; Segment permissions: Read
.rdata:0000B278 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B278 _rdata          segment para public 'DATA' use32
.rdata:0000B278                 assume cs:_rdata
.rdata:0000B278                 ;org 0B278h
.rdata:0000B278 ; COMDAT (pick any)
.rdata:0000B278                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:0000B278 ; `string'
.rdata:0000B278 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:0000B278                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &):loc_75EEo
.rdata:0000B278                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:0000B2D6                 align 4
.rdata:0000B2D6 _rdata          ends
.rdata:0000B2D6
.rdata:0000B2D8 ; ===========================================================================
.rdata:0000B2D8
.rdata:0000B2D8 ; Segment type: Pure data
.rdata:0000B2D8 ; Segment permissions: Read
.rdata:0000B2D8 _rdata          segment dword public 'DATA' use32
.rdata:0000B2D8                 assume cs:_rdata
.rdata:0000B2D8                 ;org 0B2D8h
.rdata:0000B2D8 ; COMDAT (pick any)
.rdata:0000B2D8                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:0000B2D8 ; `string'
.rdata:0000B2D8 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:0000B2D8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+85o
.rdata:0000B2D8                 unicode 0, <"invalid argument">,0
.rdata:0000B2FE                 align 10h
.rdata:0000B2FE _rdata          ends
.rdata:0000B2FE
.rdata:0000B300 ; ===========================================================================
.rdata:0000B300
.rdata:0000B300 ; Segment type: Pure data
.rdata:0000B300 ; Segment permissions: Read
.rdata:0000B300 _rdata          segment dword public 'DATA' use32
.rdata:0000B300                 assume cs:_rdata
.rdata:0000B300                 ;org 0B300h
.rdata:0000B300 ; COMDAT (pick any)
.rdata:0000B300                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000B300 ; char `string'[]
.rdata:0000B300 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000B300                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000B300                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000B300 _rdata          ends
.rdata:0000B300
.rdata:0000B310 ; ===========================================================================
.rdata:0000B310
.rdata:0000B310 ; Segment type: Pure data
.rdata:0000B310 ; Segment permissions: Read
.rdata:0000B310 _rdata          segment dword public 'DATA' use32
.rdata:0000B310                 assume cs:_rdata
.rdata:0000B310                 ;org 0B310h
.rdata:0000B310 ; COMDAT (pick any)
.rdata:0000B310                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000B310 ; char `string'[]
.rdata:0000B310 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000B310                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000B310                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:0000B310 _rdata          ends
.rdata:0000B310
.rdata:0000B328 ; ===========================================================================
.rdata:0000B328
.rdata:0000B328 ; Segment type: Pure data
.rdata:0000B328 ; Segment permissions: Read
.rdata:0000B328 _rdata          segment dword public 'DATA' use32
.rdata:0000B328                 assume cs:_rdata
.rdata:0000B328                 ;org 0B328h
.rdata:0000B328 ; COMDAT (pick any)
.rdata:0000B328                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000B328 ; char `string'[]
.rdata:0000B328 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000B328                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Xlen(void)+7o
.rdata:0000B33B                 align 4
.rdata:0000B33B _rdata          ends
.rdata:0000B33B
.rdata:0000B33C ; ===========================================================================
.rdata:0000B33C
.rdata:0000B33C ; Segment type: Pure data
.rdata:0000B33C ; Segment permissions: Read
.rdata:0000B33C _rdata          segment dword public 'DATA' use32
.rdata:0000B33C                 assume cs:_rdata
.rdata:0000B33C                 ;org 0B33Ch
.rdata:0000B33C ; COMDAT (pick any)
.rdata:0000B33C                 public ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:0000B33C ; wchar_t `string'
.rdata:0000B33C ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:0000B33C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+34o
.rdata:0000B33C                 unicode 0, <vector iterators incompatible>,0
.rdata:0000B33C _rdata          ends
.rdata:0000B33C
.rdata:0000B378 ; ===========================================================================
.rdata:0000B378
.rdata:0000B378 ; Segment type: Pure data
.rdata:0000B378 ; Segment permissions: Read
.rdata:0000B378 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B378 _rdata          segment para public 'DATA' use32
.rdata:0000B378                 assume cs:_rdata
.rdata:0000B378                 ;org 0B378h
.rdata:0000B378 ; COMDAT (pick any)
.rdata:0000B378                 public ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:0000B378 ; wchar_t `string'
.rdata:0000B378 ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:0000B378                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+49o
.rdata:0000B378                 unicode 0, <vector iterator not dereferencable>,0
.rdata:0000B3BE                 align 10h
.rdata:0000B3BE _rdata          ends
.rdata:0000B3BE
.rdata:0000B3C0 ; ===========================================================================
.rdata:0000B3C0
.rdata:0000B3C0 ; Segment type: Pure data
.rdata:0000B3C0 ; Segment permissions: Read
.rdata:0000B3C0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B3C0 _rdata          segment para public 'DATA' use32
.rdata:0000B3C0                 assume cs:_rdata
.rdata:0000B3C0                 ;org 0B3C0h
.rdata:0000B3C0 ; COMDAT (pick any)
.rdata:0000B3C0                 public ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000B3C0 ; `string'
.rdata:0000B3C0 ??_C@_1ME@LLCFNFIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000B3C0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+8Fo
.rdata:0000B3C0                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000B3C0                 dw 3Ch
.rdata:0000B3C0                 unicode 0, <class std::_Vector_val>
.rdata:0000B3C0                 dw 3Ch
.rdata:0000B3C0                 unicode 0, <struct std::_Simple_types>
.rdata:0000B3C0                 dw 3Ch
.rdata:0000B3C0                 unicode 0, <int>
.rdata:0000B3C0                 dw 3Eh
.rdata:0000B3C0                 unicode 0, < >
.rdata:0000B3C0                 dw 3Eh
.rdata:0000B3C0                 unicode 0, < >
.rdata:0000B3C0                 dw 3Eh
.rdata:0000B3C0                 unicode 0, <::operator *>,0
.rdata:0000B3C0 _rdata          ends
.rdata:0000B3C0
.rdata:0000B484 ; ===========================================================================
.rdata:0000B484
.rdata:0000B484 ; Segment type: Pure data
.rdata:0000B484 ; Segment permissions: Read
.rdata:0000B484 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B484 _rdata          segment para public 'DATA' use32
.rdata:0000B484                 assume cs:_rdata
.rdata:0000B484                 ;org 0B484h
.rdata:0000B484 ; COMDAT (pick any)
.rdata:0000B484                 public ??_C@_1EE@OEIJAKGE@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
.rdata:0000B484 ; wchar_t `string'
.rdata:0000B484 ??_C@_1EE@OEIJAKGE@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@:
.rdata:0000B484                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+39o
.rdata:0000B484                 unicode 0, <vector iterator not decrementable>,0
.rdata:0000B484 _rdata          ends
.rdata:0000B484
.rdata:0000B4C8 ; ===========================================================================
.rdata:0000B4C8
.rdata:0000B4C8 ; Segment type: Pure data
.rdata:0000B4C8 ; Segment permissions: Read
.rdata:0000B4C8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B4C8 _rdata          segment para public 'DATA' use32
.rdata:0000B4C8                 assume cs:_rdata
.rdata:0000B4C8                 ;org 0B4C8h
.rdata:0000B4C8 ; COMDAT (pick any)
.rdata:0000B4C8                 public ??_C@_1MG@BMOEGPOA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000B4C8 ; `string'
.rdata:0000B4C8 ??_C@_1MG@BMOEGPOA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000B4C8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+85o
.rdata:0000B4C8                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000B4C8                 dw 3Ch
.rdata:0000B4C8                 unicode 0, <class std::_Vector_val>
.rdata:0000B4C8                 dw 3Ch
.rdata:0000B4C8                 unicode 0, <struct std::_Simple_types>
.rdata:0000B4C8                 dw 3Ch
.rdata:0000B4C8                 unicode 0, <int>
.rdata:0000B4C8                 dw 3Eh
.rdata:0000B4C8                 unicode 0, < >
.rdata:0000B4C8                 dw 3Eh
.rdata:0000B4C8                 unicode 0, < >
.rdata:0000B4C8                 dw 3Eh
.rdata:0000B4C8                 unicode 0, <::operator -->,0
.rdata:0000B58E                 align 10h
.rdata:0000B58E _rdata          ends
.rdata:0000B58E
.rdata:0000B590 ; ===========================================================================
.rdata:0000B590
.rdata:0000B590 ; Segment type: Pure data
.rdata:0000B590 ; Segment permissions: Read
.rdata:0000B590 _rdata          segment dword public 'DATA' use32
.rdata:0000B590                 assume cs:_rdata
.rdata:0000B590                 ;org 0B590h
.rdata:0000B590 ; COMDAT (pick any)
.rdata:0000B590                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000B590 ; wchar_t `string'
.rdata:0000B590 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000B590                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000B590                                         ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)+11o ...
.rdata:0000B590                 unicode 0, <invalid null pointer>,0
.rdata:0000B5BA                 align 4
.rdata:0000B5BA _rdata          ends
.rdata:0000B5BA
.rdata:0000B5BC ; ===========================================================================
.rdata:0000B5BC
.rdata:0000B5BC ; Segment type: Pure data
.rdata:0000B5BC ; Segment permissions: Read
.rdata:0000B5BC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B5BC _rdata          segment para public 'DATA' use32
.rdata:0000B5BC                 assume cs:_rdata
.rdata:0000B5BC                 ;org 0B5BCh
.rdata:0000B5BC ; COMDAT (pick any)
.rdata:0000B5BC                 public ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000B5BC ; wchar_t `string'
.rdata:0000B5BC ??_C@_1JC@HALMDPKM@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000B5BC                                         ; DATA XREF: std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInPositionOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInPositionOrder)+33o
.rdata:0000B5BC                                         ; std::_Adjust_heap<ColumnModeInfo *,int,ColumnModeInfo,SortInSelectOrder>(ColumnModeInfo *,int,int,ColumnModeInfo &&,SortInSelectOrder)+33o ...
.rdata:0000B5BC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000B5BC                 unicode 0, <clude\algorithm>,0
.rdata:0000B64E                 align 10h
.rdata:0000B64E _rdata          ends
.rdata:0000B64E
.rdata:0000B650 ; ===========================================================================
.rdata:0000B650
.rdata:0000B650 ; Segment type: Pure data
.rdata:0000B650 ; Segment permissions: Read
.rdata:0000B650 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B650 _rdata          segment para public 'DATA' use32
.rdata:0000B650                 assume cs:_rdata
.rdata:0000B650                 ;org 0B650h
.rdata:0000B650 ; COMDAT (pick any)
.rdata:0000B650                 public ??_C@_1OC@LDKFIGAP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000B650 ; `string'
.rdata:0000B650 ??_C@_1OC@LDKFIGAP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000B650                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>> const &)+80o
.rdata:0000B650                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000B650                 dw 3Ch
.rdata:0000B650                 unicode 0, <class std::_Vector_val>
.rdata:0000B650                 dw 3Ch
.rdata:0000B650                 unicode 0, <struct std::_Simple_types>
.rdata:0000B650                 dw 3Ch
.rdata:0000B650                 unicode 0, <struct ColumnModeInfo>
.rdata:0000B650                 dw 3Eh
.rdata:0000B650                 unicode 0, < >
.rdata:0000B650                 dw 3Eh
.rdata:0000B650                 unicode 0, < >
.rdata:0000B650                 dw 3Eh
.rdata:0000B650                 unicode 0, <::_Compat>,0
.rdata:0000B732                 align 4
.rdata:0000B732 _rdata          ends
.rdata:0000B732
.rdata:0000B734 ; ===========================================================================
.rdata:0000B734
.rdata:0000B734 ; Segment type: Pure data
.rdata:0000B734 ; Segment permissions: Read
.rdata:0000B734 _rdata          segment dword public 'DATA' use32
.rdata:0000B734                 assume cs:_rdata
.rdata:0000B734                 ;org 0B734h
.rdata:0000B734 ; COMDAT (pick any)
.rdata:0000B734                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000B734 ; wchar_t `string'
.rdata:0000B734 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000B734                                         ; DATA XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000B734                                         ; std::_Debug_range2<ColumnModeInfo *>(ColumnModeInfo *,ColumnModeInfo *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000B734                 unicode 0, <invalid iterator range>,0
.rdata:0000B762                 align 4
.rdata:0000B762 _rdata          ends
.rdata:0000B762
.rdata:0000B764 ; ===========================================================================
.rdata:0000B764
.rdata:0000B764 ; Segment type: Pure data
.rdata:0000B764 ; Segment permissions: Read
.rdata:0000B764 _rdata          segment dword public 'DATA' use32
.rdata:0000B764                 assume cs:_rdata
.rdata:0000B764                 ;org 0B764h
.rdata:0000B764 ; COMDAT (pick any)
.rdata:0000B764                 public ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@
.rdata:0000B764 ; wchar_t `string'
.rdata:0000B764 ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@:
.rdata:0000B764                                         ; DATA XREF: std::_Debug_lt_pred<SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInPositionOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+63o
.rdata:0000B764                                         ; std::_Debug_lt_pred<SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &>(SortInSelectOrder,ColumnModeInfo &,ColumnModeInfo &,wchar_t const *,uint)+63o
.rdata:0000B764                 unicode 0, <invalid operator>
.rdata:0000B764                 dw 3Ch, 0
.rdata:0000B764 _rdata          ends
.rdata:0000B764
.rdata:0000B788 ; ===========================================================================
.rdata:0000B788
.rdata:0000B788 ; Segment type: Pure data
.rdata:0000B788 ; Segment permissions: Read
.rdata:0000B788 _rdata          segment dword public 'DATA' use32
.rdata:0000B788                 assume cs:_rdata
.rdata:0000B788                 ;org 0B788h
.rdata:0000B788 ; COMDAT (pick any)
.rdata:0000B788                 public ??_C@_1BK@KAECGCDK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAh?$AAe?$AAa?$AAp?$AA?$AA@
.rdata:0000B788 ; wchar_t `string'
.rdata:0000B788 ??_C@_1BK@KAECGCDK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAh?$AAe?$AAa?$AAp?$AA?$AA@:
.rdata:0000B788                                         ; DATA XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+66o
.rdata:0000B788                                         ; std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+BAo ...
.rdata:0000B788                 unicode 0, <invalid heap>,0
.rdata:0000B7A2                 align 4
.rdata:0000B7A2 _rdata          ends
.rdata:0000B7A2
.rdata:0000B7A4 ; ===========================================================================
.rdata:0000B7A4
.rdata:0000B7A4 ; Segment type: Pure data
.rdata:0000B7A4 ; Segment permissions: Read
.rdata:0000B7A4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B7A4 _rdata          segment para public 'DATA' use32
.rdata:0000B7A4                 assume cs:_rdata
.rdata:0000B7A4                 ;org 0B7A4h
.rdata:0000B7A4 ; COMDAT (pick any)
.rdata:0000B7A4                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000B7A4 ; wchar_t `string'
.rdata:0000B7A4 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000B7A4                                         ; DATA XREF: std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+9o
.rdata:0000B7A4                                         ; std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+23o
.rdata:0000B7A4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000B7A4                 unicode 0, <clude\xmemory>,0
.rdata:0000B832                 align 4
.rdata:0000B832 _rdata          ends
.rdata:0000B832
.rdata$r:0000B834 ; ===========================================================================
.rdata$r:0000B834
.rdata$r:0000B834 ; Segment type: Pure data
.rdata$r:0000B834 ; Segment permissions: Read
.rdata$r:0000B834 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B834                 assume cs:_rdata$r
.rdata$r:0000B834                 ;org 0B834h
.rdata$r:0000B834 ; COMDAT (pick any)
.rdata$r:0000B834                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0000B834 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B834 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:0000B834                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:0000B834                                         ; .rdata$r:0000B890o
.rdata$r:0000B834                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:0000B838                 align 10h
.rdata$r:0000B840                 db 0FFh
.rdata$r:0000B841                 db 0FFh
.rdata$r:0000B842                 db 0FFh
.rdata$r:0000B843                 db 0FFh
.rdata$r:0000B844                 db    0
.rdata$r:0000B845                 db    0
.rdata$r:0000B846                 db    0
.rdata$r:0000B847                 db    0
.rdata$r:0000B848                 db  40h ; @
.rdata$r:0000B849                 db    0
.rdata$r:0000B84A                 db    0
.rdata$r:0000B84B                 db    0
.rdata$r:0000B84C                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B84C _rdata$r        ends
.rdata$r:0000B84C
.rdata$r:0000B850 ; ===========================================================================
.rdata$r:0000B850
.rdata$r:0000B850 ; Segment type: Pure data
.rdata$r:0000B850 ; Segment permissions: Read
.rdata$r:0000B850 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B850                 assume cs:_rdata$r
.rdata$r:0000B850                 ;org 0B850h
.rdata$r:0000B850 ; COMDAT (pick any)
.rdata$r:0000B850                 public ??_R3exception@std@@8
.rdata$r:0000B850 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B850 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:0000B84Co
.rdata$r:0000B851                 db    0
.rdata$r:0000B852                 db    0
.rdata$r:0000B853                 db    0
.rdata$r:0000B854                 db    0
.rdata$r:0000B855                 db    0
.rdata$r:0000B856                 db    0
.rdata$r:0000B857                 db    0
.rdata$r:0000B858                 db    1
.rdata$r:0000B859                 db    0
.rdata$r:0000B85A                 db    0
.rdata$r:0000B85B                 db    0
.rdata$r:0000B85C                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:0000B85C _rdata$r        ends
.rdata$r:0000B85C
.rdata$r:0000B860 ; ===========================================================================
.rdata$r:0000B860
.rdata$r:0000B860 ; Segment type: Pure data
.rdata$r:0000B860 ; Segment permissions: Read
.rdata$r:0000B860 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B860                 assume cs:_rdata$r
.rdata$r:0000B860                 ;org 0B860h
.rdata$r:0000B860 ; COMDAT (pick any)
.rdata$r:0000B860                 public ??_R2exception@std@@8
.rdata$r:0000B860 ; std::exception::`RTTI Base Class Array'
.rdata$r:0000B860 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0000B860                                         ; DATA XREF: .rdata$r:0000B85Co
.rdata$r:0000B860                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B864                 db    0
.rdata$r:0000B865                 align 4
.rdata$r:0000B865 _rdata$r        ends
.rdata$r:0000B865
.rdata$r:0000B868 ; ===========================================================================
.rdata$r:0000B868
.rdata$r:0000B868 ; Segment type: Pure data
.rdata$r:0000B868 ; Segment permissions: Read
.rdata$r:0000B868 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B868                 assume cs:_rdata$r
.rdata$r:0000B868                 ;org 0B868h
.rdata$r:0000B868 ; COMDAT (pick any)
.rdata$r:0000B868                 public ??_R4runtime_error@std@@6B@
.rdata$r:0000B868 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:0000B868 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:0000AF04o
.rdata$r:0000B869                 db    0
.rdata$r:0000B86A                 db    0
.rdata$r:0000B86B                 db    0
.rdata$r:0000B86C                 db    0
.rdata$r:0000B86D                 db    0
.rdata$r:0000B86E                 db    0
.rdata$r:0000B86F                 db    0
.rdata$r:0000B870                 db    0
.rdata$r:0000B871                 db    0
.rdata$r:0000B872                 db    0
.rdata$r:0000B873                 db    0
.rdata$r:0000B874                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:0000B878                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B878 _rdata$r        ends
.rdata$r:0000B878
.rdata$r:0000B87C ; ===========================================================================
.rdata$r:0000B87C
.rdata$r:0000B87C ; Segment type: Pure data
.rdata$r:0000B87C ; Segment permissions: Read
.rdata$r:0000B87C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B87C                 assume cs:_rdata$r
.rdata$r:0000B87C                 ;org 0B87Ch
.rdata$r:0000B87C ; COMDAT (pick any)
.rdata$r:0000B87C                 public ??_R3runtime_error@std@@8
.rdata$r:0000B87C ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B87C ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:0000B878o
.rdata$r:0000B87C                                         ; .rdata$r:0000B8B0o
.rdata$r:0000B87D                 db    0
.rdata$r:0000B87E                 db    0
.rdata$r:0000B87F                 db    0
.rdata$r:0000B880                 db    0
.rdata$r:0000B881                 db    0
.rdata$r:0000B882                 db    0
.rdata$r:0000B883                 db    0
.rdata$r:0000B884                 db    2
.rdata$r:0000B885                 db    0
.rdata$r:0000B886                 db    0
.rdata$r:0000B887                 db    0
.rdata$r:0000B888                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:0000B888 _rdata$r        ends
.rdata$r:0000B888
.rdata$r:0000B88C ; ===========================================================================
.rdata$r:0000B88C
.rdata$r:0000B88C ; Segment type: Pure data
.rdata$r:0000B88C ; Segment permissions: Read
.rdata$r:0000B88C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B88C                 assume cs:_rdata$r
.rdata$r:0000B88C                 ;org 0B88Ch
.rdata$r:0000B88C ; COMDAT (pick any)
.rdata$r:0000B88C                 public ??_R2runtime_error@std@@8
.rdata$r:0000B88C ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:0000B88C ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:0000B88C                                         ; DATA XREF: .rdata$r:0000B888o
.rdata$r:0000B88C                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B890                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B894                 db    0
.rdata$r:0000B895                 align 4
.rdata$r:0000B895 _rdata$r        ends
.rdata$r:0000B895
.rdata$r:0000B898 ; ===========================================================================
.rdata$r:0000B898
.rdata$r:0000B898 ; Segment type: Pure data
.rdata$r:0000B898 ; Segment permissions: Read
.rdata$r:0000B898 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B898                 assume cs:_rdata$r
.rdata$r:0000B898                 ;org 0B898h
.rdata$r:0000B898 ; COMDAT (pick any)
.rdata$r:0000B898                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:0000B898 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B898 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:0000B898                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:0000B898                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:0000B89C                 db    1
.rdata$r:0000B89D                 db    0
.rdata$r:0000B89E                 db    0
.rdata$r:0000B89F                 db    0
.rdata$r:0000B8A0                 db    0
.rdata$r:0000B8A1                 db    0
.rdata$r:0000B8A2                 db    0
.rdata$r:0000B8A3                 db    0
.rdata$r:0000B8A4                 db 0FFh
.rdata$r:0000B8A5                 db 0FFh
.rdata$r:0000B8A6                 db 0FFh
.rdata$r:0000B8A7                 db 0FFh
.rdata$r:0000B8A8                 db    0
.rdata$r:0000B8A9                 db    0
.rdata$r:0000B8AA                 db    0
.rdata$r:0000B8AB                 db    0
.rdata$r:0000B8AC                 db  40h ; @
.rdata$r:0000B8AD                 db    0
.rdata$r:0000B8AE                 db    0
.rdata$r:0000B8AF                 db    0
.rdata$r:0000B8B0                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B8B0 _rdata$r        ends
.rdata$r:0000B8B0
.rdata$r:0000B8B4 ; ===========================================================================
.rdata$r:0000B8B4
.rdata$r:0000B8B4 ; Segment type: Pure data
.rdata$r:0000B8B4 ; Segment permissions: Read
.rdata$r:0000B8B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B8B4                 assume cs:_rdata$r
.rdata$r:0000B8B4                 ;org 0B8B4h
.rdata$r:0000B8B4 ; COMDAT (pick any)
.rdata$r:0000B8B4                 public ??_R4error_category@std@@6B@
.rdata$r:0000B8B4 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000B8B4 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000AFA0o
.rdata$r:0000B8B5                 db    0
.rdata$r:0000B8B6                 db    0
.rdata$r:0000B8B7                 db    0
.rdata$r:0000B8B8                 db    0
.rdata$r:0000B8B9                 db    0
.rdata$r:0000B8BA                 db    0
.rdata$r:0000B8BB                 db    0
.rdata$r:0000B8BC                 db    0
.rdata$r:0000B8BD                 db    0
.rdata$r:0000B8BE                 db    0
.rdata$r:0000B8BF                 db    0
.rdata$r:0000B8C0                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000B8C4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B8C4 _rdata$r        ends
.rdata$r:0000B8C4
.data$r:0000B8C8 ; ===========================================================================
.data$r:0000B8C8
.data$r:0000B8C8 ; Segment type: Pure data
.data$r:0000B8C8 ; Segment permissions: Read/Write
.data$r:0000B8C8 _data$r         segment dword public 'DATA' use32
.data$r:0000B8C8                 assume cs:_data$r
.data$r:0000B8C8                 ;org 0B8C8h
.data$r:0000B8C8 ; COMDAT (pick any)
.data$r:0000B8C8                 public ??_R0?AVerror_category@std@@@8
.data$r:0000B8C8 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000B8C8 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000B8C8                                         ; DATA XREF: .rdata$r:0000B8C0o
.data$r:0000B8C8                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000B8C8                                         ; const type_info::`vftable'
.data$r:0000B8CC                 align 10h
.data$r:0000B8D0 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:0000B8E9                 align 4
.data$r:0000B8E9 _data$r         ends
.data$r:0000B8E9
.rdata$r:0000B8EC ; ===========================================================================
.rdata$r:0000B8EC
.rdata$r:0000B8EC ; Segment type: Pure data
.rdata$r:0000B8EC ; Segment permissions: Read
.rdata$r:0000B8EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B8EC                 assume cs:_rdata$r
.rdata$r:0000B8EC                 ;org 0B8ECh
.rdata$r:0000B8EC ; COMDAT (pick any)
.rdata$r:0000B8EC                 public ??_R3error_category@std@@8
.rdata$r:0000B8EC ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B8EC ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000B8C4o
.rdata$r:0000B8EC                                         ; .rdata$r:0000B91Co
.rdata$r:0000B8ED                 db    0
.rdata$r:0000B8EE                 db    0
.rdata$r:0000B8EF                 db    0
.rdata$r:0000B8F0                 db    0
.rdata$r:0000B8F1                 db    0
.rdata$r:0000B8F2                 db    0
.rdata$r:0000B8F3                 db    0
.rdata$r:0000B8F4                 db    1
.rdata$r:0000B8F5                 db    0
.rdata$r:0000B8F6                 db    0
.rdata$r:0000B8F7                 db    0
.rdata$r:0000B8F8                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000B8F8 _rdata$r        ends
.rdata$r:0000B8F8
.rdata$r:0000B8FC ; ===========================================================================
.rdata$r:0000B8FC
.rdata$r:0000B8FC ; Segment type: Pure data
.rdata$r:0000B8FC ; Segment permissions: Read
.rdata$r:0000B8FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B8FC                 assume cs:_rdata$r
.rdata$r:0000B8FC                 ;org 0B8FCh
.rdata$r:0000B8FC ; COMDAT (pick any)
.rdata$r:0000B8FC                 public ??_R2error_category@std@@8
.rdata$r:0000B8FC ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000B8FC ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000B8FC                                         ; DATA XREF: .rdata$r:0000B8F8o
.rdata$r:0000B8FC                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B900                 db    0
.rdata$r:0000B901                 align 4
.rdata$r:0000B901 _rdata$r        ends
.rdata$r:0000B901
.rdata$r:0000B904 ; ===========================================================================
.rdata$r:0000B904
.rdata$r:0000B904 ; Segment type: Pure data
.rdata$r:0000B904 ; Segment permissions: Read
.rdata$r:0000B904 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B904                 assume cs:_rdata$r
.rdata$r:0000B904                 ;org 0B904h
.rdata$r:0000B904 ; COMDAT (pick any)
.rdata$r:0000B904                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000B904 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B904 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000B904                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000B904                                         ; .rdata$r:0000B974o ...
.rdata$r:0000B904                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000B908                 align 10h
.rdata$r:0000B910                 db 0FFh
.rdata$r:0000B911                 db 0FFh
.rdata$r:0000B912                 db 0FFh
.rdata$r:0000B913                 db 0FFh
.rdata$r:0000B914                 db    0
.rdata$r:0000B915                 db    0
.rdata$r:0000B916                 db    0
.rdata$r:0000B917                 db    0
.rdata$r:0000B918                 db  40h ; @
.rdata$r:0000B919                 db    0
.rdata$r:0000B91A                 db    0
.rdata$r:0000B91B                 db    0
.rdata$r:0000B91C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B91C _rdata$r        ends
.rdata$r:0000B91C
.rdata$r:0000B920 ; ===========================================================================
.rdata$r:0000B920
.rdata$r:0000B920 ; Segment type: Pure data
.rdata$r:0000B920 ; Segment permissions: Read
.rdata$r:0000B920 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B920                 assume cs:_rdata$r
.rdata$r:0000B920                 ;org 0B920h
.rdata$r:0000B920 ; COMDAT (pick any)
.rdata$r:0000B920                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000B920 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000B920 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000B920                                         ; DATA XREF: .rdata:0000AFBCo
.rdata$r:0000B921                 db    0
.rdata$r:0000B922                 db    0
.rdata$r:0000B923                 db    0
.rdata$r:0000B924                 db    0
.rdata$r:0000B925                 db    0
.rdata$r:0000B926                 db    0
.rdata$r:0000B927                 db    0
.rdata$r:0000B928                 db    0
.rdata$r:0000B929                 db    0
.rdata$r:0000B92A                 db    0
.rdata$r:0000B92B                 db    0
.rdata$r:0000B92C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000B930                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B930 _rdata$r        ends
.rdata$r:0000B930
.data$r:0000B934 ; ===========================================================================
.data$r:0000B934
.data$r:0000B934 ; Segment type: Pure data
.data$r:0000B934 ; Segment permissions: Read/Write
.data$r:0000B934 _data$r         segment dword public 'DATA' use32
.data$r:0000B934                 assume cs:_data$r
.data$r:0000B934                 ;org 0B934h
.data$r:0000B934 ; COMDAT (pick any)
.data$r:0000B934                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000B934 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000B934 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000B934                                         ; DATA XREF: .rdata$r:0000B92Co
.data$r:0000B934                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000B934                                         ; const type_info::`vftable'
.data$r:0000B938                 db    0
.data$r:0000B939                 db    0
.data$r:0000B93A                 db    0
.data$r:0000B93B                 db    0
.data$r:0000B93C                 db  2Eh ; .
.data$r:0000B93D                 db  3Fh ; ?
.data$r:0000B93E                 db  41h ; A
.data$r:0000B93F                 db  56h ; V
.data$r:0000B940                 db  5Fh ; _
.data$r:0000B941                 db  47h ; G
.data$r:0000B942                 db  65h ; e
.data$r:0000B943                 db  6Eh ; n
.data$r:0000B944                 db  65h ; e
.data$r:0000B945                 db  72h ; r
.data$r:0000B946                 db  69h ; i
.data$r:0000B947                 db  63h ; c
.data$r:0000B948                 db  5Fh ; _
.data$r:0000B949                 db  65h ; e
.data$r:0000B94A                 db  72h ; r
.data$r:0000B94B                 db  72h ; r
.data$r:0000B94C                 db  6Fh ; o
.data$r:0000B94D                 db  72h ; r
.data$r:0000B94E                 db  5Fh ; _
.data$r:0000B94F                 db  63h ; c
.data$r:0000B950                 db  61h ; a
.data$r:0000B951                 db  74h ; t
.data$r:0000B952                 db  65h ; e
.data$r:0000B953                 db  67h ; g
.data$r:0000B954                 db  6Fh ; o
.data$r:0000B955                 db  72h ; r
.data$r:0000B956                 db  79h ; y
.data$r:0000B957                 db  40h ; @
.data$r:0000B958                 db  73h ; s
.data$r:0000B959                 db  74h ; t
.data$r:0000B95A                 db  64h ; d
.data$r:0000B95B                 db  40h ; @
.data$r:0000B95C                 db  40h ; @
.data$r:0000B95D                 db    0
.data$r:0000B95E                 align 10h
.data$r:0000B95E _data$r         ends
.data$r:0000B95E
.rdata$r:0000B960 ; ===========================================================================
.rdata$r:0000B960
.rdata$r:0000B960 ; Segment type: Pure data
.rdata$r:0000B960 ; Segment permissions: Read
.rdata$r:0000B960 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B960                 assume cs:_rdata$r
.rdata$r:0000B960                 ;org 0B960h
.rdata$r:0000B960 ; COMDAT (pick any)
.rdata$r:0000B960                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000B960 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B960 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000B960                                         ; DATA XREF: .rdata$r:0000B930o
.rdata$r:0000B960                                         ; .rdata$r:0000B994o
.rdata$r:0000B961                 db    0
.rdata$r:0000B962                 db    0
.rdata$r:0000B963                 db    0
.rdata$r:0000B964                 db    0
.rdata$r:0000B965                 db    0
.rdata$r:0000B966                 db    0
.rdata$r:0000B967                 db    0
.rdata$r:0000B968                 db    2
.rdata$r:0000B969                 db    0
.rdata$r:0000B96A                 db    0
.rdata$r:0000B96B                 db    0
.rdata$r:0000B96C                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000B96C _rdata$r        ends
.rdata$r:0000B96C
.rdata$r:0000B970 ; ===========================================================================
.rdata$r:0000B970
.rdata$r:0000B970 ; Segment type: Pure data
.rdata$r:0000B970 ; Segment permissions: Read
.rdata$r:0000B970 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B970                 assume cs:_rdata$r
.rdata$r:0000B970                 ;org 0B970h
.rdata$r:0000B970 ; COMDAT (pick any)
.rdata$r:0000B970                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000B970 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000B970 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000B970                                         ; DATA XREF: .rdata$r:0000B96Co
.rdata$r:0000B970                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B974                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B978                 db    0
.rdata$r:0000B979                 align 4
.rdata$r:0000B979 _rdata$r        ends
.rdata$r:0000B979
.rdata$r:0000B97C ; ===========================================================================
.rdata$r:0000B97C
.rdata$r:0000B97C ; Segment type: Pure data
.rdata$r:0000B97C ; Segment permissions: Read
.rdata$r:0000B97C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B97C                 assume cs:_rdata$r
.rdata$r:0000B97C                 ;org 0B97Ch
.rdata$r:0000B97C ; COMDAT (pick any)
.rdata$r:0000B97C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000B97C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B97C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000B97C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000B97C                                         ; .rdata$r:0000B9ECo ...
.rdata$r:0000B97C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000B980                 db    1
.rdata$r:0000B981                 db    0
.rdata$r:0000B982                 db    0
.rdata$r:0000B983                 db    0
.rdata$r:0000B984                 db    0
.rdata$r:0000B985                 db    0
.rdata$r:0000B986                 db    0
.rdata$r:0000B987                 db    0
.rdata$r:0000B988                 db 0FFh
.rdata$r:0000B989                 db 0FFh
.rdata$r:0000B98A                 db 0FFh
.rdata$r:0000B98B                 db 0FFh
.rdata$r:0000B98C                 db    0
.rdata$r:0000B98D                 db    0
.rdata$r:0000B98E                 db    0
.rdata$r:0000B98F                 db    0
.rdata$r:0000B990                 db  40h ; @
.rdata$r:0000B991                 db    0
.rdata$r:0000B992                 db    0
.rdata$r:0000B993                 db    0
.rdata$r:0000B994                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B994 _rdata$r        ends
.rdata$r:0000B994
.rdata$r:0000B998 ; ===========================================================================
.rdata$r:0000B998
.rdata$r:0000B998 ; Segment type: Pure data
.rdata$r:0000B998 ; Segment permissions: Read
.rdata$r:0000B998 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B998                 assume cs:_rdata$r
.rdata$r:0000B998                 ;org 0B998h
.rdata$r:0000B998 ; COMDAT (pick any)
.rdata$r:0000B998                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000B998 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000B998 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000B998                                         ; DATA XREF: .rdata:0000AFF0o
.rdata$r:0000B999                 db    0
.rdata$r:0000B99A                 db    0
.rdata$r:0000B99B                 db    0
.rdata$r:0000B99C                 db    0
.rdata$r:0000B99D                 db    0
.rdata$r:0000B99E                 db    0
.rdata$r:0000B99F                 db    0
.rdata$r:0000B9A0                 db    0
.rdata$r:0000B9A1                 db    0
.rdata$r:0000B9A2                 db    0
.rdata$r:0000B9A3                 db    0
.rdata$r:0000B9A4                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000B9A8                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B9A8 _rdata$r        ends
.rdata$r:0000B9A8
.data$r:0000B9AC ; ===========================================================================
.data$r:0000B9AC
.data$r:0000B9AC ; Segment type: Pure data
.data$r:0000B9AC ; Segment permissions: Read/Write
.data$r:0000B9AC _data$r         segment dword public 'DATA' use32
.data$r:0000B9AC                 assume cs:_data$r
.data$r:0000B9AC                 ;org 0B9ACh
.data$r:0000B9AC ; COMDAT (pick any)
.data$r:0000B9AC                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000B9AC ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000B9AC ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000B9AC                                         ; DATA XREF: .rdata$r:0000B9A4o
.data$r:0000B9AC                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000B9AC                                         ; const type_info::`vftable'
.data$r:0000B9B0                 db    0
.data$r:0000B9B1                 db    0
.data$r:0000B9B2                 db    0
.data$r:0000B9B3                 db    0
.data$r:0000B9B4                 db  2Eh ; .
.data$r:0000B9B5                 db  3Fh ; ?
.data$r:0000B9B6                 db  41h ; A
.data$r:0000B9B7                 db  56h ; V
.data$r:0000B9B8                 db  5Fh ; _
.data$r:0000B9B9                 db  49h ; I
.data$r:0000B9BA                 db  6Fh ; o
.data$r:0000B9BB                 db  73h ; s
.data$r:0000B9BC                 db  74h ; t
.data$r:0000B9BD                 db  72h ; r
.data$r:0000B9BE                 db  65h ; e
.data$r:0000B9BF                 db  61h ; a
.data$r:0000B9C0                 db  6Dh ; m
.data$r:0000B9C1                 db  5Fh ; _
.data$r:0000B9C2                 db  65h ; e
.data$r:0000B9C3                 db  72h ; r
.data$r:0000B9C4                 db  72h ; r
.data$r:0000B9C5                 db  6Fh ; o
.data$r:0000B9C6                 db  72h ; r
.data$r:0000B9C7                 db  5Fh ; _
.data$r:0000B9C8                 db  63h ; c
.data$r:0000B9C9                 db  61h ; a
.data$r:0000B9CA                 db  74h ; t
.data$r:0000B9CB                 db  65h ; e
.data$r:0000B9CC                 db  67h ; g
.data$r:0000B9CD                 db  6Fh ; o
.data$r:0000B9CE                 db  72h ; r
.data$r:0000B9CF                 db  79h ; y
.data$r:0000B9D0                 db  40h ; @
.data$r:0000B9D1                 db  73h ; s
.data$r:0000B9D2                 db  74h ; t
.data$r:0000B9D3                 db  64h ; d
.data$r:0000B9D4                 db  40h ; @
.data$r:0000B9D5                 db  40h ; @
.data$r:0000B9D6                 db    0
.data$r:0000B9D7                 align 4
.data$r:0000B9D7 _data$r         ends
.data$r:0000B9D7
.rdata$r:0000B9D8 ; ===========================================================================
.rdata$r:0000B9D8
.rdata$r:0000B9D8 ; Segment type: Pure data
.rdata$r:0000B9D8 ; Segment permissions: Read
.rdata$r:0000B9D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B9D8                 assume cs:_rdata$r
.rdata$r:0000B9D8                 ;org 0B9D8h
.rdata$r:0000B9D8 ; COMDAT (pick any)
.rdata$r:0000B9D8                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000B9D8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B9D8 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000B9D8                                         ; DATA XREF: .rdata$r:0000B9A8o
.rdata$r:0000B9D8                                         ; .rdata$r:0000BA10o
.rdata$r:0000B9D9                 db    0
.rdata$r:0000B9DA                 db    0
.rdata$r:0000B9DB                 db    0
.rdata$r:0000B9DC                 db    0
.rdata$r:0000B9DD                 db    0
.rdata$r:0000B9DE                 db    0
.rdata$r:0000B9DF                 db    0
.rdata$r:0000B9E0                 db    3
.rdata$r:0000B9E1                 db    0
.rdata$r:0000B9E2                 db    0
.rdata$r:0000B9E3                 db    0
.rdata$r:0000B9E4                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000B9E4 _rdata$r        ends
.rdata$r:0000B9E4
.rdata$r:0000B9E8 ; ===========================================================================
.rdata$r:0000B9E8
.rdata$r:0000B9E8 ; Segment type: Pure data
.rdata$r:0000B9E8 ; Segment permissions: Read
.rdata$r:0000B9E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B9E8                 assume cs:_rdata$r
.rdata$r:0000B9E8                 ;org 0B9E8h
.rdata$r:0000B9E8 ; COMDAT (pick any)
.rdata$r:0000B9E8                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000B9E8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000B9E8 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000B9E8                                         ; DATA XREF: .rdata$r:0000B9E4o
.rdata$r:0000B9E8                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B9EC                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B9F0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B9F4                 db    0
.rdata$r:0000B9F5                 align 4
.rdata$r:0000B9F5 _rdata$r        ends
.rdata$r:0000B9F5
.rdata$r:0000B9F8 ; ===========================================================================
.rdata$r:0000B9F8
.rdata$r:0000B9F8 ; Segment type: Pure data
.rdata$r:0000B9F8 ; Segment permissions: Read
.rdata$r:0000B9F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B9F8                 assume cs:_rdata$r
.rdata$r:0000B9F8                 ;org 0B9F8h
.rdata$r:0000B9F8 ; COMDAT (pick any)
.rdata$r:0000B9F8                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000B9F8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B9F8 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000B9F8                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000B9F8                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000B9FC                 db    2
.rdata$r:0000B9FD                 db    0
.rdata$r:0000B9FE                 db    0
.rdata$r:0000B9FF                 db    0
.rdata$r:0000BA00                 db    0
.rdata$r:0000BA01                 db    0
.rdata$r:0000BA02                 db    0
.rdata$r:0000BA03                 db    0
.rdata$r:0000BA04                 db 0FFh
.rdata$r:0000BA05                 db 0FFh
.rdata$r:0000BA06                 db 0FFh
.rdata$r:0000BA07                 db 0FFh
.rdata$r:0000BA08                 db    0
.rdata$r:0000BA09                 db    0
.rdata$r:0000BA0A                 db    0
.rdata$r:0000BA0B                 db    0
.rdata$r:0000BA0C                 db  40h ; @
.rdata$r:0000BA0D                 db    0
.rdata$r:0000BA0E                 db    0
.rdata$r:0000BA0F                 db    0
.rdata$r:0000BA10                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BA10 _rdata$r        ends
.rdata$r:0000BA10
.rdata$r:0000BA14 ; ===========================================================================
.rdata$r:0000BA14
.rdata$r:0000BA14 ; Segment type: Pure data
.rdata$r:0000BA14 ; Segment permissions: Read
.rdata$r:0000BA14 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BA14                 assume cs:_rdata$r
.rdata$r:0000BA14                 ;org 0BA14h
.rdata$r:0000BA14 ; COMDAT (pick any)
.rdata$r:0000BA14                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000BA14 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000BA14 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000B030o
.rdata$r:0000BA15                 db    0
.rdata$r:0000BA16                 db    0
.rdata$r:0000BA17                 db    0
.rdata$r:0000BA18                 db    0
.rdata$r:0000BA19                 db    0
.rdata$r:0000BA1A                 db    0
.rdata$r:0000BA1B                 db    0
.rdata$r:0000BA1C                 db    0
.rdata$r:0000BA1D                 db    0
.rdata$r:0000BA1E                 db    0
.rdata$r:0000BA1F                 db    0
.rdata$r:0000BA20                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000BA24                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BA24 _rdata$r        ends
.rdata$r:0000BA24
.data$r:0000BA28 ; ===========================================================================
.data$r:0000BA28
.data$r:0000BA28 ; Segment type: Pure data
.data$r:0000BA28 ; Segment permissions: Read/Write
.data$r:0000BA28 _data$r         segment dword public 'DATA' use32
.data$r:0000BA28                 assume cs:_data$r
.data$r:0000BA28                 ;org 0BA28h
.data$r:0000BA28 ; COMDAT (pick any)
.data$r:0000BA28                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000BA28 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000BA28 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000BA28                                         ; DATA XREF: .rdata$r:0000BA20o
.data$r:0000BA28                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000BA28                                         ; const type_info::`vftable'
.data$r:0000BA2C                 align 10h
.data$r:0000BA30 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:0000BA51                 align 4
.data$r:0000BA51 _data$r         ends
.data$r:0000BA51
.rdata$r:0000BA54 ; ===========================================================================
.rdata$r:0000BA54
.rdata$r:0000BA54 ; Segment type: Pure data
.rdata$r:0000BA54 ; Segment permissions: Read
.rdata$r:0000BA54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BA54                 assume cs:_rdata$r
.rdata$r:0000BA54                 ;org 0BA54h
.rdata$r:0000BA54 ; COMDAT (pick any)
.rdata$r:0000BA54                 public ??_R3_System_error_category@std@@8
.rdata$r:0000BA54 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BA54 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000BA24o
.rdata$r:0000BA54                                         ; .rdata$r:0000BA8Co
.rdata$r:0000BA55                 db    0
.rdata$r:0000BA56                 db    0
.rdata$r:0000BA57                 db    0
.rdata$r:0000BA58                 db    0
.rdata$r:0000BA59                 db    0
.rdata$r:0000BA5A                 db    0
.rdata$r:0000BA5B                 db    0
.rdata$r:0000BA5C                 db    3
.rdata$r:0000BA5D                 db    0
.rdata$r:0000BA5E                 db    0
.rdata$r:0000BA5F                 db    0
.rdata$r:0000BA60                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000BA60 _rdata$r        ends
.rdata$r:0000BA60
.rdata$r:0000BA64 ; ===========================================================================
.rdata$r:0000BA64
.rdata$r:0000BA64 ; Segment type: Pure data
.rdata$r:0000BA64 ; Segment permissions: Read
.rdata$r:0000BA64 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BA64                 assume cs:_rdata$r
.rdata$r:0000BA64                 ;org 0BA64h
.rdata$r:0000BA64 ; COMDAT (pick any)
.rdata$r:0000BA64                 public ??_R2_System_error_category@std@@8
.rdata$r:0000BA64 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000BA64 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000BA64                                         ; DATA XREF: .rdata$r:0000BA60o
.rdata$r:0000BA64                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BA68                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BA6C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BA70                 db    0
.rdata$r:0000BA71                 align 4
.rdata$r:0000BA71 _rdata$r        ends
.rdata$r:0000BA71
.rdata$r:0000BA74 ; ===========================================================================
.rdata$r:0000BA74
.rdata$r:0000BA74 ; Segment type: Pure data
.rdata$r:0000BA74 ; Segment permissions: Read
.rdata$r:0000BA74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BA74                 assume cs:_rdata$r
.rdata$r:0000BA74                 ;org 0BA74h
.rdata$r:0000BA74 ; COMDAT (pick any)
.rdata$r:0000BA74                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000BA74 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000BA74 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000BA74                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000BA74                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000BA78                 db    2
.rdata$r:0000BA79                 db    0
.rdata$r:0000BA7A                 db    0
.rdata$r:0000BA7B                 db    0
.rdata$r:0000BA7C                 db    0
.rdata$r:0000BA7D                 db    0
.rdata$r:0000BA7E                 db    0
.rdata$r:0000BA7F                 db    0
.rdata$r:0000BA80                 db 0FFh
.rdata$r:0000BA81                 db 0FFh
.rdata$r:0000BA82                 db 0FFh
.rdata$r:0000BA83                 db 0FFh
.rdata$r:0000BA84                 db    0
.rdata$r:0000BA85                 db    0
.rdata$r:0000BA86                 db    0
.rdata$r:0000BA87                 db    0
.rdata$r:0000BA88                 db  40h ; @
.rdata$r:0000BA89                 db    0
.rdata$r:0000BA8A                 db    0
.rdata$r:0000BA8B                 db    0
.rdata$r:0000BA8C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BA8C _rdata$r        ends
.rdata$r:0000BA8C
.CRT$XCU:0000BA90 ; ===========================================================================
.CRT$XCU:0000BA90
.CRT$XCU:0000BA90 ; Segment type: Pure data
.CRT$XCU:0000BA90 ; Segment permissions: Read
.CRT$XCU:0000BA90 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BA90                 assume cs:_CRT$XCU
.CRT$XCU:0000BA90                 ;org 0BA90h
.CRT$XCU:0000BA90 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000BA94 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000BA98 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000BA9C __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000BA9C _CRT$XCU        ends
.CRT$XCU:0000BA9C
.CRT$XCU:0000BAA0 ; ===========================================================================
.CRT$XCU:0000BAA0
.CRT$XCU:0000BAA0 ; Segment type: Pure data
.CRT$XCU:0000BAA0 ; Segment permissions: Read
.CRT$XCU:0000BAA0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BAA0                 assume cs:_CRT$XCU
.CRT$XCU:0000BAA0                 ;org 0BAA0h
.CRT$XCU:0000BAA0 ; COMDAT (pick associative to section at B054)
.CRT$XCU:0000BAA0 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000BAA0 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000BAA0 _CRT$XCU        ends
.CRT$XCU:0000BAA0
.CRT$XCU:0000BAA4 ; ===========================================================================
.CRT$XCU:0000BAA4
.CRT$XCU:0000BAA4 ; Segment type: Pure data
.CRT$XCU:0000BAA4 ; Segment permissions: Read
.CRT$XCU:0000BAA4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BAA4                 assume cs:_CRT$XCU
.CRT$XCU:0000BAA4                 ;org 0BAA4h
.CRT$XCU:0000BAA4 ; COMDAT (pick associative to section at B058)
.CRT$XCU:0000BAA4 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000BAA4 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000BAA4 _CRT$XCU        ends
.CRT$XCU:0000BAA4
.CRT$XCU:0000BAA8 ; ===========================================================================
.CRT$XCU:0000BAA8
.CRT$XCU:0000BAA8 ; Segment type: Pure data
.CRT$XCU:0000BAA8 ; Segment permissions: Read
.CRT$XCU:0000BAA8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BAA8                 assume cs:_CRT$XCU
.CRT$XCU:0000BAA8                 ;org 0BAA8h
.CRT$XCU:0000BAA8 ; COMDAT (pick associative to section at B05C)
.CRT$XCU:0000BAA8 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000BAA8 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000BAA8 _CRT$XCU        ends
.CRT$XCU:0000BAA8
.CRT$XCU:0000BAAC ; ===========================================================================
.CRT$XCU:0000BAAC
.CRT$XCU:0000BAAC ; Segment type: Pure data
.CRT$XCU:0000BAAC ; Segment permissions: Read
.CRT$XCU:0000BAAC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BAAC                 assume cs:_CRT$XCU
.CRT$XCU:0000BAAC                 ;org 0BAACh
.CRT$XCU:0000BAAC ; COMDAT (pick associative to section at B064)
.CRT$XCU:0000BAAC ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000BAAC ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000BAAC _CRT$XCU        ends
.CRT$XCU:0000BAAC
.CRT$XCU:0000BAB0 ; ===========================================================================
.CRT$XCU:0000BAB0
.CRT$XCU:0000BAB0 ; Segment type: Pure data
.CRT$XCU:0000BAB0 ; Segment permissions: Read
.CRT$XCU:0000BAB0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BAB0                 assume cs:_CRT$XCU
.CRT$XCU:0000BAB0                 ;org 0BAB0h
.CRT$XCU:0000BAB0 ; COMDAT (pick associative to section at B068)
.CRT$XCU:0000BAB0 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000BAB0 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000BAB0 _CRT$XCU        ends
.CRT$XCU:0000BAB0
.CRT$XCU:0000BAB4 ; ===========================================================================
.CRT$XCU:0000BAB4
.CRT$XCU:0000BAB4 ; Segment type: Pure data
.CRT$XCU:0000BAB4 ; Segment permissions: Read
.CRT$XCU:0000BAB4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BAB4                 assume cs:_CRT$XCU
.CRT$XCU:0000BAB4                 ;org 0BAB4h
.CRT$XCU:0000BAB4 ; COMDAT (pick associative to section at B0FC)
.CRT$XCU:0000BAB4 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000BAB4 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000BAB4 _CRT$XCU        ends
.CRT$XCU:0000BAB4
.CRT$XCU:0000BAB8 ; ===========================================================================
.CRT$XCU:0000BAB8
.CRT$XCU:0000BAB8 ; Segment type: Pure data
.CRT$XCU:0000BAB8 ; Segment permissions: Read
.CRT$XCU:0000BAB8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000BAB8                 assume cs:_CRT$XCU
.CRT$XCU:0000BAB8                 ;org 0BAB8h
.CRT$XCU:0000BAB8 ; COMDAT (pick associative to section at B100)
.CRT$XCU:0000BAB8 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000BAB8 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000BAB8 _CRT$XCU        ends
.CRT$XCU:0000BAB8
UNDEF:0000BAC0 ; ===========================================================================
UNDEF:0000BAC0
UNDEF:0000BAC0 ; Segment type: Externs
UNDEF:0000BAC0 ; UNDEF
UNDEF:0000BAC0                 extrn __purecall:near   ; DATA XREF: .rdata:0000AFA8o
UNDEF:0000BAC0                                         ; .rdata:0000AFACo
UNDEF:0000BAC4 ; void *__cdecl operator new(unsigned int)
UNDEF:0000BAC4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:0000BAC4                                         ; std::_Allocate<int>(uint,int *)+23p ...
UNDEF:0000BAC8 ; void __cdecl operator delete(void *)
UNDEF:0000BAC8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:0000BAC8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000BACC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000BACC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000BACC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000BAD0                 extrn __invalid_parameter:near
UNDEF:0000BAD0                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+99p
UNDEF:0000BAD0                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+8Fp ...
UNDEF:0000BAD4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000BAD4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000BAD4                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000BAD4                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000BAD8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000BAD8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000BAD8                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000BAD8                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000BADC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000BAE0 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000BAE0                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:0000BAE4 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000BAE4                 extrn _memmove:near     ; CODE XREF: std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:0000BAE4                                         ; std::char_traits<char>::move(char *,char const *,uint)+1Ep ...
UNDEF:0000BAE8 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000BAE8                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000BAE8                                         ; _wmemcpy+11p
UNDEF:0000BAEC ; size_t __cdecl strlen(const char *Str)
UNDEF:0000BAEC                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000BAF0 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:0000BAF0                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:0000BAF0                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:0000BAF4 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:0000BAF4                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:0000BAF4                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:0000BAF4                                         ; DATA XREF: .xdata$x:0000AF9Co
UNDEF:0000BAF8 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:0000BAF8                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:0000BAF8                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:0000BAF8                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:0000BAFC ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:0000BAFC                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:0000BAFC                                         ; DATA XREF: .rdata:0000AF0Co
UNDEF:0000BB00 ; void __cdecl operator delete[](void *)
UNDEF:0000BB00                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000BB00                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+4F6p
UNDEF:0000BB00                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+674p ...
UNDEF:0000BB04 ; void *__cdecl operator new[](unsigned int)
UNDEF:0000BB04                 extrn ??_U@YAPAXI@Z:near
UNDEF:0000BB04                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+414p
UNDEF:0000BB04                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+515p ...
UNDEF:0000BB08                 extrn __CrtDbgReportW:near
UNDEF:0000BB08                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator*(void)+78p
UNDEF:0000BB08                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator--(void)+6Bp ...
UNDEF:0000BB0C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000BB0C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000BB0C                                         ; CODE XREF: std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+6Bp
UNDEF:0000BB0C                                         ; std::_Debug_heap<ColumnModeInfo *,SortInPositionOrder>(ColumnModeInfo *,ColumnModeInfo *,SortInPositionOrder)+BFp ...
UNDEF:0000BB10 ; void __cdecl std::_Xbad_alloc()
UNDEF:0000BB10                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000BB10                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2576p
UNDEF:0000BB10                                         ; std::_Allocate<int>(uint,int *):loc_25B8p ...
UNDEF:0000BB14 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000BB14                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000BB14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000BB14                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:0000BB18 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000BB18                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000BB18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000BB18                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp ...
UNDEF:0000BB1C ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:0000BB1C                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:0000BB1C                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:0000BB20 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:0000BB20                 extrn __imp__ShowWindow@8:near
UNDEF:0000BB20                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:0000BB20                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:0000BB24 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:0000BB24                 extrn __imp__GetDlgItem@8:near
UNDEF:0000BB24                                         ; CODE XREF: ColumnEditorDlg::display(bool)+28p
UNDEF:0000BB24                                         ; ColumnEditorDlg::switchTo(bool)+15p ...
UNDEF:0000BB28 ; UINT __stdcall GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
UNDEF:0000BB28                 extrn __imp__GetDlgItemInt@16:near
UNDEF:0000BB28                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+691p
UNDEF:0000BB28                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+6ADp ...
UNDEF:0000BB2C ; LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000BB2C                 extrn __imp__SendDlgItemMessageW@20:near
UNDEF:0000BB2C                                         ; CODE XREF: ColumnEditorDlg::switchTo(bool)+63p
UNDEF:0000BB2C                                         ; ColumnEditorDlg::switchTo(bool)+ADp ...
UNDEF:0000BB30 ; HWND __stdcall SetFocus(HWND hWnd)
UNDEF:0000BB30                 extrn __imp__SetFocus@4:near
UNDEF:0000BB30                                         ; CODE XREF: ColumnEditorDlg::display(bool)+2Fp
UNDEF:0000BB30                                         ; ColumnEditorDlg::switchTo(bool)+36Fp ...
UNDEF:0000BB34 ; BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable)
UNDEF:0000BB34                 extrn __imp__EnableWindow@8:near
UNDEF:0000BB34                                         ; CODE XREF: ColumnEditorDlg::switchTo(bool)+27p
UNDEF:0000BB34                                         ; ColumnEditorDlg::switchTo(bool)+45p ...
UNDEF:0000BB38 ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:0000BB38                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:0000BB38                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+79p
UNDEF:0000BB3C ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:0000BB3C                 extrn __wassert:near    ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+A06p
UNDEF:0000BB40 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000BB40                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000BB40                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000BB44 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000BB44                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000BB44                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000BB44                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000BB48 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000BB48                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000BB48                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000BB4C ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000BB4C                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000BB4C                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000BB50 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000BB50                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000BB50                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000BB54 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000BB54                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000BB54                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000BB58 ; int __cdecl getNbDigits(int, int)
UNDEF:0000BB58                 extrn ?getNbDigits@@YAHHH@Z:near
UNDEF:0000BB58                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+B2Fp
UNDEF:0000BB58                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+B4Bp
UNDEF:0000BB5C ; wchar_t *__cdecl int2str(wchar_t *, int, int, int, int, bool)
UNDEF:0000BB5C                 extrn ?int2str@@YAPA_WPA_WHHHH_N@Z:near
UNDEF:0000BB5C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+D0Ap
UNDEF:0000BB60 ; void __thiscall ScintillaEditView::getGenericText(ScintillaEditView *__hidden this, wchar_t *, unsigned int, int, int)
UNDEF:0000BB60                 extrn ?getGenericText@ScintillaEditView@@QBEXPA_WIHH@Z:near
UNDEF:0000BB60                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+553p
UNDEF:0000BB60                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+CB2p
UNDEF:0000BB64 ; int __thiscall ScintillaEditView::replaceTarget(ScintillaEditView *__hidden this, const wchar_t *, int, int)
UNDEF:0000BB64                 extrn ?replaceTarget@ScintillaEditView@@QBEHPB_WHH@Z:near
UNDEF:0000BB64                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+645p
UNDEF:0000BB64                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+DE6p
UNDEF:0000BB68 ; public: void __thiscall ScintillaEditView::setMultiSelections(class std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>> const &)
UNDEF:0000BB68                 extrn ?setMultiSelections@ScintillaEditView@@QAEXABV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@@Z:near
UNDEF:0000BB68                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+33Cp
UNDEF:0000BB68                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+885p
UNDEF:0000BB6C ; public: class std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>> __thiscall ScintillaEditView::getColumnModeSelectInfo(void)
UNDEF:0000BB6C                 extrn ?getColumnModeSelectInfo@ScintillaEditView@@QAE?AV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@XZ:near
UNDEF:0000BB6C                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+21Ap
UNDEF:0000BB6C                                         ; ColumnEditorDlg::run_dlgProc(uint,uint,long)+74Dp
UNDEF:0000BB70 ; public: void __thiscall ScintillaEditView::columnReplace(class std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>> &, wchar_t const *)
UNDEF:0000BB70                 extrn ?columnReplace@ScintillaEditView@@QAEXAAV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@PB_W@Z:near
UNDEF:0000BB70                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+2B2p
UNDEF:0000BB74 ; public: void __thiscall ScintillaEditView::columnReplace(class std::vector<struct ColumnModeInfo, class std::allocator<struct ColumnModeInfo>> &, int, int, int, unsigned char)
UNDEF:0000BB74                 extrn ?columnReplace@ScintillaEditView@@QAEXAAV?$vector@UColumnModeInfo@@V?$allocator@UColumnModeInfo@@@std@@@std@@HHHE@Z:near
UNDEF:0000BB74                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+7FBp
UNDEF:0000BB78 ; __fastcall __security_check_cookie(x)
UNDEF:0000BB78                 extrn @__security_check_cookie@4:near
UNDEF:0000BB78                                         ; CODE XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+ED1p
UNDEF:0000BB78                                         ; __ehhandler$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z+Fp ...
UNDEF:0000BB7C ; __stdcall _CxxThrowException(x, x)
UNDEF:0000BB7C                 extrn __CxxThrowException@8:near
UNDEF:0000BB7C                                         ; CODE XREF: ColumnEditorDlg::init(HINSTANCE__ *,HWND__ *,ScintillaEditView * *)+35p
UNDEF:0000BB7C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p ...
UNDEF:0000BB80                 extrn ___CxxFrameHandler3:near
UNDEF:0000BB80                                         ; CODE XREF: __ehhandler$?run_dlgProc@ColumnEditorDlg@@MAGHIIJ@Z+23j
UNDEF:0000BB80                                         ; __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UColumnModeInfo@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z+16j ...
UNDEF:0000BB84 ; const type_info::`vftable'
UNDEF:0000BB84                 extrn ??_7type_info@@6B@:near
UNDEF:0000BB84                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:0000BB84                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:0000BB88 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000BB88                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000BB88                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:0000BB8C                 extrn ___security_cookie:near
UNDEF:0000BB8C                                         ; DATA XREF: ColumnEditorDlg::run_dlgProc(uint,uint,long)+17r
UNDEF:0000BB8C                                         ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ColumnModeInfo>>>,wchar_t const *,uint,std::random_access_iterator_tag)+11r ...
UNDEF:0000BB90                 extrn __fltused:near
UNDEF:0000BB90
UNDEF:0000BB90
UNDEF:0000BB90                 end