.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 3BD147A55E993DE5CF069793CB23DD19
.data:00000000 ; Input CRC32 : 61AD750D
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\SmartHighlighter.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143428     ; "12 12 56 1"
.data:00000004                 dd offset $SG143429     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143430     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143431     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143432     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143433     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143434     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143435     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG143436     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143437     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143438     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143439     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143440     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143441     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143442     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143443     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143444     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143445     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143446     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143447     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143448     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143449     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143450     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143451     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143452     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143453     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143454     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143455     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143456     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143457     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143458     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143459     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143460     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143461     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143462     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143463     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143464     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143465     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143466     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143467     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143468     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143469     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143470     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143471     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143472     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143473     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143474     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143475     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143476     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143477     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143478     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143479     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143480     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143481     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143482     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143483     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143484     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143485     ; "    .+      "
.data:000000E8                 dd offset $SG143486     ; "    @#$     "
.data:000000EC                 dd offset $SG143487     ; "    %&*=    "
.data:000000F0                 dd offset $SG143488     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143489     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143490     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143491     ; "    |123456 "
.data:00000100                 dd offset $SG143492     ; "    7890abc "
.data:00000104                 dd offset $SG143493     ; "    defgh   "
.data:00000108                 dd offset $SG143494     ; "    ijkl    "
.data:0000010C                 dd offset $SG143495     ; "    mno     "
.data:00000110                 dd offset $SG143496     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143498     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143499     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143500     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143501     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143502     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143503     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143504     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143505     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143506     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143507     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143508     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143509     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143510     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143511     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143512     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143513     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143514     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143515     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143516     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143517     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143518     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143519     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143520     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143521     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143522     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143523     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143524     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143525     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143526     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143527     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143528     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143529     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143530     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143531     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143532     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143533     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143534     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143535     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143536     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143537     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143538     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143539     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143540     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143541     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143542     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143543     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143544     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143545     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143546     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143547     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143548     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143549     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143550     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143551     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143552     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143553     ; "         .+ "
.data:000001F8                 dd offset $SG143554     ; "        @#$ "
.data:000001FC                 dd offset $SG143555     ; "       %&*= L"
.data:00000200                 dd offset $SG143556     ; "      -;>,' "
.data:00000204                 dd offset $SG143557     ; "     )!>~{] "
.data:00000208                 dd offset $SG143558     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143559     ; "    (}|1234 "
.data:00000210                 dd offset $SG143560     ; "    567890a "
.data:00000214                 dd offset $SG143561     ; "      bcdef "
.data:00000218                 dd offset $SG143562     ; "       ghij "
.data:0000021C                 dd offset $SG143563     ; "        klm "
.data:00000220                 dd offset $SG143564     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143566     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143567     ; " \tc None"
.data:00000230                 dd offset $SG143568     ; ".\tc #545254"
.data:00000234                 dd offset $SG143569     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143570     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143571     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143572     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143573     ; "%\tc #747284"
.data:00000248                 dd offset $SG143574     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143575     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143576     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143577     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143578     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143579     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143580     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143581     ; "'\tc #242644"
.data:00000268                 dd offset $SG143582     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143583     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143584     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143585     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143586     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143587     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143588     ; "/\tc #143789"
.data:00000284                 dd offset $SG143589     ; "(\tc #204990"
.data:00000288                 dd offset $SG143590     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143591     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143592     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143593     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143594     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143595     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143596     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143597     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143598     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143599     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143600     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143601     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143602     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143603     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143604     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143605     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143606     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143607     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143608     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143609     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143610     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143611     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143612     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143613     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143614     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143615     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143616     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143617     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143618     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143619     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143620     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143621     ; "     .+.     "
.data:00000308                 dd offset $SG143622     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143623     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143624     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143625     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143626     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143627     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143628     ; "12[3455563[21"
.data:00000324                 dd offset $SG143629     ; "7_365899063_7"
.data:00000328                 dd offset $SG143630     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143631     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143632     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143633     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143634     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143428       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143429       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143430       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143431       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143432       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143433       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143434       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143435       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143436       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG143437       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143438       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143439       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143440       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143441       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143442       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143443       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143444       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143445       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143446       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143447       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143448       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143449       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143450       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143451       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143452       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143453       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143454       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143455       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143456       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143457       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143458       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143459       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143460       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143461       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143462       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143463       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143464       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143465       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143466       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143467       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143468       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143469       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143470       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143471       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143472       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143473       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143474       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143475       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143476       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143477       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143478       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143479       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143480       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143481       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143482       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143483       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143484       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143485       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143486       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143487       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143488       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143489       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143490       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143491       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143492       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143493       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143494       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143495       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143496       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143498       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143499       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143500       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143501       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143502       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143503       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143504       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143505       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143506       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143507       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143508       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143509       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143510       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143511       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143512       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143513       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143514       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143515       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143516       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143517       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143518       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143519       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143520       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143521       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143522       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143523       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143524       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143525       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143526       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143527       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143528       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143529       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143530       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143531       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143532       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143533       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143534       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143535       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143536       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143537       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143538       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143539       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143540       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143541       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143542       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143543       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143544       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143545       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143546       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143547       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143548       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143549       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143550       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143551       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143552       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143553       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143554       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143555       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143556       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143557       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143558       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143559       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143560       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143561       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143562       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143563       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143564       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143566       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG143567       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG143568       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG143569       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG143570       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG143571       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG143572       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG143573       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG143574       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG143575       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG143576       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG143577       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG143578       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG143579       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG143580       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG143581       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG143582       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG143583       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG143584       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG143585       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG143586       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG143587       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG143588       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG143589       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG143590       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG143591       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG143592       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG143593       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG143594       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG143595       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG143596       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG143597       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG143598       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG143599       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG143600       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG143601       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG143602       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG143603       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG143604       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG143605       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG143606       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG143607       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG143608       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG143609       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG143610       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG143611       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG143612       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG143613       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG143614       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG143615       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG143616       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG143617       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG143618       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG143619       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG143620       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG143621       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG143622       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143623       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143624       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143625       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143626       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143627       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143628       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143629       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143630       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143631       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143632       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143633       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143634       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D6E _rdata          ends
.rdata:00000D6E
.text$mn:00000D70 ; ===========================================================================
.text$mn:00000D70
.text$mn:00000D70 ; Segment type: Pure code
.text$mn:00000D70 ; Segment permissions: Read/Execute
.text$mn:00000D70 _text$mn        segment para public 'CODE' use32
.text$mn:00000D70                 assume cs:_text$mn
.text$mn:00000D70                 ;org 0D70h
.text$mn:00000D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D70
.text$mn:00000D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D70
.text$mn:00000D70 ; Attributes: bp-based frame
.text$mn:00000D70
.text$mn:00000D70 ; _DWORD __thiscall SmartHighlighter::SmartHighlighter(SmartHighlighter *this, struct FindReplaceDlg *)
.text$mn:00000D70                 public ??0SmartHighlighter@@QAE@PAVFindReplaceDlg@@@Z
.text$mn:00000D70 ??0SmartHighlighter@@QAE@PAVFindReplaceDlg@@@Z proc near
.text$mn:00000D70
.text$mn:00000D70 var_4           = dword ptr -4
.text$mn:00000D70 arg_0           = dword ptr  8
.text$mn:00000D70
.text$mn:00000D70                 push    ebp
.text$mn:00000D71                 mov     ebp, esp
.text$mn:00000D73                 push    ecx
.text$mn:00000D74                 mov     [ebp+var_4], ecx
.text$mn:00000D77                 mov     eax, [ebp+var_4]
.text$mn:00000D7A                 mov     ecx, [ebp+arg_0]
.text$mn:00000D7D                 mov     [eax], ecx
.text$mn:00000D7F                 mov     eax, [ebp+var_4]
.text$mn:00000D82                 mov     esp, ebp
.text$mn:00000D84                 pop     ebp
.text$mn:00000D85                 retn    4
.text$mn:00000D85 ??0SmartHighlighter@@QAE@PAVFindReplaceDlg@@@Z endp
.text$mn:00000D85
.text$mn:00000D85 ; ---------------------------------------------------------------------------
.text$mn:00000D88                 align 10h
.text$mn:00000D90
.text$mn:00000D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D90
.text$mn:00000D90 ; Attributes: bp-based frame
.text$mn:00000D90
.text$mn:00000D90 ; void __thiscall SmartHighlighter::highlightView(SmartHighlighter *this, struct ScintillaEditView *)
.text$mn:00000D90                 public ?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z
.text$mn:00000D90 ?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z proc near
.text$mn:00000D90
.text$mn:00000D90 var_F4          = dword ptr -0F4h
.text$mn:00000D90 var_F0          = dword ptr -0F0h
.text$mn:00000D90 var_EC          = dword ptr -0ECh
.text$mn:00000D90 var_E8          = dword ptr -0E8h
.text$mn:00000D90 var_E4          = dword ptr -0E4h
.text$mn:00000D90 var_E0          = dword ptr -0E0h
.text$mn:00000D90 var_DC          = dword ptr -0DCh
.text$mn:00000D90 var_D8          = dword ptr -0D8h
.text$mn:00000D90 var_D4          = dword ptr -0D4h
.text$mn:00000D90 var_D0          = dword ptr -0D0h
.text$mn:00000D90 var_CC          = dword ptr -0CCh
.text$mn:00000D90 var_C8          = dword ptr -0C8h
.text$mn:00000D90 var_C4          = dword ptr -0C4h
.text$mn:00000D90 var_C0          = dword ptr -0C0h
.text$mn:00000D90 var_BC          = dword ptr -0BCh
.text$mn:00000D90 var_B8          = dword ptr -0B8h
.text$mn:00000D90 var_B4          = dword ptr -0B4h
.text$mn:00000D90 var_B0          = dword ptr -0B0h
.text$mn:00000D90 var_AC          = dword ptr -0ACh
.text$mn:00000D90 var_A8          = dword ptr -0A8h
.text$mn:00000D90 var_A4          = dword ptr -0A4h
.text$mn:00000D90 var_A0          = dword ptr -0A0h
.text$mn:00000D90 var_9C          = dword ptr -9Ch
.text$mn:00000D90 var_96          = byte ptr -96h
.text$mn:00000D90 var_95          = byte ptr -95h
.text$mn:00000D90 var_94          = byte ptr -94h
.text$mn:00000D90 var_93          = byte ptr -93h
.text$mn:00000D90 var_10          = dword ptr -10h
.text$mn:00000D90 var_C           = dword ptr -0Ch
.text$mn:00000D90 var_4           = dword ptr -4
.text$mn:00000D90 arg_0           = dword ptr  8
.text$mn:00000D90
.text$mn:00000D90                 push    ebp
.text$mn:00000D91                 mov     ebp, esp
.text$mn:00000D93                 push    0FFFFFFFFh
.text$mn:00000D95                 push    offset __ehhandler$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z
.text$mn:00000D9A                 mov     eax, large fs:0
.text$mn:00000DA0                 push    eax
.text$mn:00000DA1                 sub     esp, 0E8h
.text$mn:00000DA7                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DAC                 xor     eax, ebp
.text$mn:00000DAE                 mov     [ebp+var_10], eax
.text$mn:00000DB1                 push    eax
.text$mn:00000DB2                 lea     eax, [ebp+var_C]
.text$mn:00000DB5                 mov     large fs:0, eax
.text$mn:00000DBB                 mov     [ebp+var_A0], ecx
.text$mn:00000DC1                 lea     eax, [ebp+var_BC]
.text$mn:00000DC7                 push    eax
.text$mn:00000DC8                 mov     ecx, [ebp+arg_0]
.text$mn:00000DCB                 call    ?getSelection@ScintillaEditView@@QBE?AUSci_CharacterRange@@XZ ; ScintillaEditView::getSelection(void)
.text$mn:00000DD0                 push    1Dh             ; int
.text$mn:00000DD2                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000DD5                 call    ?clearIndicator@ScintillaEditView@@QAEXH@Z ; ScintillaEditView::clearIndicator(int)
.text$mn:00000DDA                 mov     ecx, [ebp+var_BC]
.text$mn:00000DE0                 cmp     ecx, [ebp+var_B8]
.text$mn:00000DE6                 jnz     short loc_DED
.text$mn:00000DE8                 jmp     loc_11E0
.text$mn:00000DED ; ---------------------------------------------------------------------------
.text$mn:00000DED
.text$mn:00000DED loc_DED:                                ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+56j
.text$mn:00000DED                 mov     edx, [ebp+var_B8]
.text$mn:00000DF3                 sub     edx, [ebp+var_BC]
.text$mn:00000DF9                 add     edx, 1
.text$mn:00000DFC                 mov     [ebp+var_C4], edx
.text$mn:00000E02                 mov     eax, [ebp+var_C4]
.text$mn:00000E08                 push    eax             ; unsigned int
.text$mn:00000E09                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00000E0E                 add     esp, 4
.text$mn:00000E11                 mov     [ebp+var_E0], eax
.text$mn:00000E17                 mov     ecx, [ebp+var_E0]
.text$mn:00000E1D                 mov     [ebp+var_A8], ecx
.text$mn:00000E23                 push    0               ; bool
.text$mn:00000E25                 mov     edx, [ebp+var_C4]
.text$mn:00000E2B                 push    edx             ; int
.text$mn:00000E2C                 mov     eax, [ebp+var_A8]
.text$mn:00000E32                 push    eax             ; char *
.text$mn:00000E33                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000E36                 call    ?getSelectedText@ScintillaEditView@@QAEPADPADH_N@Z ; ScintillaEditView::getSelectedText(char *,int,bool)
.text$mn:00000E3B                 mov     [ebp+var_96], 1
.text$mn:00000E42                 mov     ecx, [ebp+var_A8]
.text$mn:00000E48                 push    ecx             ; char *
.text$mn:00000E49                 mov     ecx, [ebp+var_A0] ; this
.text$mn:00000E4F                 call    ?isQualifiedWord@SmartHighlighter@@ABE_NPBD@Z ; SmartHighlighter::isQualifiedWord(char const *)
.text$mn:00000E54                 movzx   edx, al
.text$mn:00000E57                 test    edx, edx
.text$mn:00000E59                 jnz     short loc_E67
.text$mn:00000E5B                 mov     [ebp+var_96], 0
.text$mn:00000E62                 jmp     loc_EFA
.text$mn:00000E67 ; ---------------------------------------------------------------------------
.text$mn:00000E67
.text$mn:00000E67 loc_E67:                                ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+C9j
.text$mn:00000E67                 push    0               ; __int32
.text$mn:00000E69                 mov     eax, [ebp+var_B8]
.text$mn:00000E6F                 push    eax             ; unsigned int
.text$mn:00000E70                 push    7D7h            ; unsigned int
.text$mn:00000E75                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000E78                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000E7D                 mov     [ebp+var_95], al
.text$mn:00000E83                 movzx   ecx, [ebp+var_95]
.text$mn:00000E8A                 test    ecx, ecx
.text$mn:00000E8C                 jz      short loc_EAF
.text$mn:00000E8E                 movzx   edx, [ebp+var_95]
.text$mn:00000E95                 push    edx             ; char
.text$mn:00000E96                 mov     ecx, [ebp+var_A0] ; this
.text$mn:00000E9C                 call    ?isWordChar@SmartHighlighter@@ABE_ND@Z ; SmartHighlighter::isWordChar(char)
.text$mn:00000EA1                 movzx   eax, al
.text$mn:00000EA4                 test    eax, eax
.text$mn:00000EA6                 jz      short loc_EAF
.text$mn:00000EA8                 mov     [ebp+var_96], 0
.text$mn:00000EAF
.text$mn:00000EAF loc_EAF:                                ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+FCj
.text$mn:00000EAF                                         ; SmartHighlighter::highlightView(ScintillaEditView *)+116j
.text$mn:00000EAF                 push    0               ; __int32
.text$mn:00000EB1                 mov     ecx, [ebp+var_BC]
.text$mn:00000EB7                 sub     ecx, 1
.text$mn:00000EBA                 push    ecx             ; unsigned int
.text$mn:00000EBB                 push    7D7h            ; unsigned int
.text$mn:00000EC0                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000EC3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000EC8                 mov     [ebp+var_95], al
.text$mn:00000ECE                 movzx   edx, [ebp+var_95]
.text$mn:00000ED5                 test    edx, edx
.text$mn:00000ED7                 jz      short loc_EFA
.text$mn:00000ED9                 movzx   eax, [ebp+var_95]
.text$mn:00000EE0                 push    eax             ; char
.text$mn:00000EE1                 mov     ecx, [ebp+var_A0] ; this
.text$mn:00000EE7                 call    ?isWordChar@SmartHighlighter@@ABE_ND@Z ; SmartHighlighter::isWordChar(char)
.text$mn:00000EEC                 movzx   ecx, al
.text$mn:00000EEF                 test    ecx, ecx
.text$mn:00000EF1                 jz      short loc_EFA
.text$mn:00000EF3                 mov     [ebp+var_96], 0
.text$mn:00000EFA
.text$mn:00000EFA loc_EFA:                                ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+D2j
.text$mn:00000EFA                                         ; SmartHighlighter::highlightView(ScintillaEditView *)+147j ...
.text$mn:00000EFA                 movzx   edx, [ebp+var_96]
.text$mn:00000F01                 test    edx, edx
.text$mn:00000F03                 jnz     short loc_F25
.text$mn:00000F05                 mov     eax, [ebp+var_A8]
.text$mn:00000F0B                 mov     [ebp+var_EC], eax
.text$mn:00000F11                 mov     ecx, [ebp+var_EC]
.text$mn:00000F17                 push    ecx             ; void *
.text$mn:00000F18                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00000F1D                 add     esp, 4
.text$mn:00000F20                 jmp     loc_11E0
.text$mn:00000F25 ; ---------------------------------------------------------------------------
.text$mn:00000F25
.text$mn:00000F25 loc_F25:                                ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+173j
.text$mn:00000F25                 push    0               ; __int32
.text$mn:00000F27                 push    0               ; unsigned int
.text$mn:00000F29                 push    88Fh            ; unsigned int
.text$mn:00000F2E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F31                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F36                 mov     [ebp+var_DC], eax
.text$mn:00000F3C                 push    0               ; __int32
.text$mn:00000F3E                 push    0               ; unsigned int
.text$mn:00000F40                 push    891h            ; unsigned int
.text$mn:00000F45                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F48                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F4D                 mov     [ebp+var_E4], eax
.text$mn:00000F53                 push    0               ; __int32
.text$mn:00000F55                 push    0               ; unsigned int
.text$mn:00000F57                 push    868h            ; unsigned int
.text$mn:00000F5C                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F5F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F64                 mov     [ebp+var_C8], eax
.text$mn:00000F6A                 push    0               ; __int32
.text$mn:00000F6C                 push    0               ; unsigned int
.text$mn:00000F6E                 push    942h            ; unsigned int
.text$mn:00000F73                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F76                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F7B                 cmp     eax, 190h
.text$mn:00000F80                 jge     short loc_F9B
.text$mn:00000F82                 push    0               ; __int32
.text$mn:00000F84                 push    0               ; unsigned int
.text$mn:00000F86                 push    942h            ; unsigned int
.text$mn:00000F8B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F8E                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F93                 mov     [ebp+var_CC], eax
.text$mn:00000F99                 jmp     short loc_FA5
.text$mn:00000F9B ; ---------------------------------------------------------------------------
.text$mn:00000F9B
.text$mn:00000F9B loc_F9B:                                ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+1F0j
.text$mn:00000F9B                 mov     [ebp+var_CC], 190h
.text$mn:00000FA5
.text$mn:00000FA5 loc_FA5:                                ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+209j
.text$mn:00000FA5                 mov     edx, [ebp+var_CC]
.text$mn:00000FAB                 add     edx, 1
.text$mn:00000FAE                 mov     [ebp+var_F4], edx
.text$mn:00000FB4                 mov     eax, [ebp+var_C8]
.text$mn:00000FBA                 add     eax, [ebp+var_F4]
.text$mn:00000FC0                 mov     [ebp+var_D4], eax
.text$mn:00000FC6                 mov     [ebp+var_B4], 0
.text$mn:00000FD0                 mov     [ebp+var_9C], 0
.text$mn:00000FDA                 mov     ecx, [ebp+var_C8]
.text$mn:00000FE0                 mov     [ebp+var_A4], ecx
.text$mn:00000FE6                 mov     [ebp+var_C0], 0FFFFFFFFh
.text$mn:00000FF0                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000FF5                 mov     ecx, eax        ; this
.text$mn:00000FF7                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00000FFC                 mov     [ebp+var_D8], eax
.text$mn:00001002                 lea     ecx, [ebp+var_94]
.text$mn:00001008                 call    ??0FindOption@@QAE@XZ ; FindOption::FindOption(void)
.text$mn:0000100D                 mov     [ebp+var_4], 0
.text$mn:00001014                 mov     edx, [ebp+var_D8]
.text$mn:0000101A                 mov     al, [edx+40h]
.text$mn:0000101D                 mov     [ebp+var_93], al
.text$mn:00001023                 mov     [ebp+var_94], 1
.text$mn:0000102A                 mov     [ebp+var_B0], 0
.text$mn:00001034                 call    ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ ; WcharMbcsConvertor::getInstance(void)
.text$mn:00001039                 mov     [ebp+var_D0], eax
.text$mn:0000103F                 push    0               ; __int32
.text$mn:00001041                 push    0               ; unsigned int
.text$mn:00001043                 push    859h            ; unsigned int
.text$mn:00001048                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000104B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001050                 mov     [ebp+var_E8], eax
.text$mn:00001056                 push    0               ; int *
.text$mn:00001058                 push    0               ; int *
.text$mn:0000105A                 push    0FFFFFFFFh      ; int
.text$mn:0000105C                 mov     ecx, [ebp+var_E8]
.text$mn:00001062                 push    ecx             ; unsigned int
.text$mn:00001063                 mov     edx, [ebp+var_A8]
.text$mn:00001069                 push    edx             ; char *
.text$mn:0000106A                 mov     ecx, [ebp+var_D0] ; this
.text$mn:00001070                 call    ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)
.text$mn:00001075                 mov     [ebp+var_F0], eax
.text$mn:0000107B                 mov     eax, [ebp+var_F0]
.text$mn:00001081                 mov     [ebp+var_B0], eax
.text$mn:00001087                 jmp     short loc_1098
.text$mn:00001089 ; ---------------------------------------------------------------------------
.text$mn:00001089
.text$mn:00001089 loc_1089:                               ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+344j
.text$mn:00001089                                         ; SmartHighlighter::highlightView(ScintillaEditView *):loc_119Dj
.text$mn:00001089                 mov     ecx, [ebp+var_A4]
.text$mn:0000108F                 add     ecx, 1
.text$mn:00001092                 mov     [ebp+var_A4], ecx
.text$mn:00001098
.text$mn:00001098 loc_1098:                               ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+2F7j
.text$mn:00001098                 mov     edx, [ebp+var_A4]
.text$mn:0000109E                 cmp     edx, [ebp+var_D4]
.text$mn:000010A4                 jge     loc_11A2
.text$mn:000010AA                 push    0               ; __int32
.text$mn:000010AC                 mov     eax, [ebp+var_A4]
.text$mn:000010B2                 push    eax             ; unsigned int
.text$mn:000010B3                 push    8ADh            ; unsigned int
.text$mn:000010B8                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000010BB                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000010C0                 mov     [ebp+var_AC], eax
.text$mn:000010C6                 mov     ecx, [ebp+var_AC]
.text$mn:000010CC                 cmp     ecx, [ebp+var_C0]
.text$mn:000010D2                 jnz     short loc_10D6
.text$mn:000010D4                 jmp     short loc_1089
.text$mn:000010D6 ; ---------------------------------------------------------------------------
.text$mn:000010D6
.text$mn:000010D6 loc_10D6:                               ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+342j
.text$mn:000010D6                 mov     edx, [ebp+var_AC]
.text$mn:000010DC                 mov     [ebp+var_C0], edx
.text$mn:000010E2                 push    0               ; __int32
.text$mn:000010E4                 mov     eax, [ebp+var_AC]
.text$mn:000010EA                 push    eax             ; unsigned int
.text$mn:000010EB                 push    877h            ; unsigned int
.text$mn:000010F0                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000010F3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000010F8                 mov     [ebp+var_B4], eax
.text$mn:000010FE                 push    0               ; __int32
.text$mn:00001100                 mov     ecx, [ebp+var_AC]
.text$mn:00001106                 add     ecx, 1
.text$mn:00001109                 push    ecx             ; unsigned int
.text$mn:0000110A                 push    877h            ; unsigned int
.text$mn:0000110F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001112                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001117                 mov     [ebp+var_9C], eax
.text$mn:0000111D                 cmp     [ebp+var_9C], 0FFFFFFFFh
.text$mn:00001124                 jnz     short loc_116C
.text$mn:00001126                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001129                 call    ?getCurrentDocLen@ScintillaEditView@@QBEHXZ ; ScintillaEditView::getCurrentDocLen(void)
.text$mn:0000112E                 sub     eax, 1
.text$mn:00001131                 mov     [ebp+var_9C], eax
.text$mn:00001137                 push    0FFFFFFFFh
.text$mn:00001139                 lea     edx, [ebp+var_94]
.text$mn:0000113F                 push    edx
.text$mn:00001140                 push    0
.text$mn:00001142                 mov     eax, [ebp+var_9C]
.text$mn:00001148                 push    eax
.text$mn:00001149                 mov     ecx, [ebp+var_B4]
.text$mn:0000114F                 push    ecx
.text$mn:00001150                 push    0
.text$mn:00001152                 mov     edx, [ebp+var_B0]
.text$mn:00001158                 push    edx
.text$mn:00001159                 push    4
.text$mn:0000115B                 mov     eax, [ebp+var_A0]
.text$mn:00001161                 mov     ecx, [eax]
.text$mn:00001163                 call    ?processRange@FindReplaceDlg@@QAEHW4ProcessOperation@@PB_W1HH1PBUFindOption@@H@Z ; FindReplaceDlg::processRange(ProcessOperation,wchar_t const *,wchar_t const *,int,int,wchar_t const *,FindOption const *,int)
.text$mn:00001168                 jmp     short loc_11A2
.text$mn:0000116A ; ---------------------------------------------------------------------------
.text$mn:0000116A                 jmp     short loc_119D
.text$mn:0000116C ; ---------------------------------------------------------------------------
.text$mn:0000116C
.text$mn:0000116C loc_116C:                               ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+394j
.text$mn:0000116C                 push    0FFFFFFFFh
.text$mn:0000116E                 lea     ecx, [ebp+var_94]
.text$mn:00001174                 push    ecx
.text$mn:00001175                 push    0
.text$mn:00001177                 mov     edx, [ebp+var_9C]
.text$mn:0000117D                 push    edx
.text$mn:0000117E                 mov     eax, [ebp+var_B4]
.text$mn:00001184                 push    eax
.text$mn:00001185                 push    0
.text$mn:00001187                 mov     ecx, [ebp+var_B0]
.text$mn:0000118D                 push    ecx
.text$mn:0000118E                 push    4
.text$mn:00001190                 mov     edx, [ebp+var_A0]
.text$mn:00001196                 mov     ecx, [edx]
.text$mn:00001198                 call    ?processRange@FindReplaceDlg@@QAEHW4ProcessOperation@@PB_W1HH1PBUFindOption@@H@Z ; FindReplaceDlg::processRange(ProcessOperation,wchar_t const *,wchar_t const *,int,int,wchar_t const *,FindOption const *,int)
.text$mn:0000119D
.text$mn:0000119D loc_119D:                               ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+3DAj
.text$mn:0000119D                 jmp     loc_1089
.text$mn:000011A2 ; ---------------------------------------------------------------------------
.text$mn:000011A2
.text$mn:000011A2 loc_11A2:                               ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+314j
.text$mn:000011A2                                         ; SmartHighlighter::highlightView(ScintillaEditView *)+3D8j
.text$mn:000011A2                 push    0               ; __int32
.text$mn:000011A4                 mov     eax, [ebp+var_DC]
.text$mn:000011AA                 push    eax             ; unsigned int
.text$mn:000011AB                 push    88Eh            ; unsigned int
.text$mn:000011B0                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000011B3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000011B8                 push    0               ; __int32
.text$mn:000011BA                 mov     ecx, [ebp+var_E4]
.text$mn:000011C0                 push    ecx             ; unsigned int
.text$mn:000011C1                 push    890h            ; unsigned int
.text$mn:000011C6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000011C9                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000011CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011D5                 lea     ecx, [ebp+var_94] ; this
.text$mn:000011DB                 call    ??1FindOption@@QAE@XZ ; FindOption::~FindOption(void)
.text$mn:000011E0
.text$mn:000011E0 loc_11E0:                               ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+58j
.text$mn:000011E0                                         ; SmartHighlighter::highlightView(ScintillaEditView *)+190j
.text$mn:000011E0                 mov     ecx, [ebp+var_C]
.text$mn:000011E3                 mov     large fs:0, ecx
.text$mn:000011EA                 pop     ecx
.text$mn:000011EB                 mov     ecx, [ebp+var_10]
.text$mn:000011EE                 xor     ecx, ebp
.text$mn:000011F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000011F5                 mov     esp, ebp
.text$mn:000011F7                 pop     ebp
.text$mn:000011F8                 retn    4
.text$mn:000011F8 ?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z endp ; sp-analysis failed
.text$mn:000011F8
.text$mn:000011F8 ; ---------------------------------------------------------------------------
.text$mn:000011FB                 align 10h
.text$mn:00001200
.text$mn:00001200 ; =============== S U B R O U T I N E =======================================
.text$mn:00001200
.text$mn:00001200 ; Attributes: bp-based frame
.text$mn:00001200
.text$mn:00001200 ; bool __thiscall SmartHighlighter::isQualifiedWord(SmartHighlighter *this, const char *)
.text$mn:00001200                 public ?isQualifiedWord@SmartHighlighter@@ABE_NPBD@Z
.text$mn:00001200 ?isQualifiedWord@SmartHighlighter@@ABE_NPBD@Z proc near
.text$mn:00001200                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+BFp
.text$mn:00001200
.text$mn:00001200 var_C           = dword ptr -0Ch
.text$mn:00001200 var_8           = dword ptr -8
.text$mn:00001200 var_4           = dword ptr -4
.text$mn:00001200 Str             = dword ptr  8
.text$mn:00001200
.text$mn:00001200                 push    ebp
.text$mn:00001201                 mov     ebp, esp
.text$mn:00001203                 sub     esp, 0Ch
.text$mn:00001206                 mov     [ebp+var_C], ecx
.text$mn:00001209                 mov     [ebp+var_4], 0
.text$mn:00001210                 mov     eax, [ebp+Str]
.text$mn:00001213                 push    eax             ; Str
.text$mn:00001214                 call    _strlen
.text$mn:00001219                 add     esp, 4
.text$mn:0000121C                 mov     [ebp+var_8], eax
.text$mn:0000121F                 jmp     short loc_122A
.text$mn:00001221 ; ---------------------------------------------------------------------------
.text$mn:00001221
.text$mn:00001221 loc_1221:                               ; CODE XREF: SmartHighlighter::isQualifiedWord(char const *):loc_124Fj
.text$mn:00001221                 mov     ecx, [ebp+var_4]
.text$mn:00001224                 add     ecx, 1
.text$mn:00001227                 mov     [ebp+var_4], ecx
.text$mn:0000122A
.text$mn:0000122A loc_122A:                               ; CODE XREF: SmartHighlighter::isQualifiedWord(char const *)+1Fj
.text$mn:0000122A                 mov     edx, [ebp+var_4]
.text$mn:0000122D                 cmp     edx, [ebp+var_8]
.text$mn:00001230                 jnb     short loc_1251
.text$mn:00001232                 mov     eax, [ebp+Str]
.text$mn:00001235                 add     eax, [ebp+var_4]
.text$mn:00001238                 movzx   ecx, byte ptr [eax]
.text$mn:0000123B                 push    ecx             ; char
.text$mn:0000123C                 mov     ecx, [ebp+var_C] ; this
.text$mn:0000123F                 call    ?isWordChar@SmartHighlighter@@ABE_ND@Z ; SmartHighlighter::isWordChar(char)
.text$mn:00001244                 movzx   edx, al
.text$mn:00001247                 test    edx, edx
.text$mn:00001249                 jnz     short loc_124F
.text$mn:0000124B                 xor     al, al
.text$mn:0000124D                 jmp     short loc_1253
.text$mn:0000124F ; ---------------------------------------------------------------------------
.text$mn:0000124F
.text$mn:0000124F loc_124F:                               ; CODE XREF: SmartHighlighter::isQualifiedWord(char const *)+49j
.text$mn:0000124F                 jmp     short loc_1221
.text$mn:00001251 ; ---------------------------------------------------------------------------
.text$mn:00001251
.text$mn:00001251 loc_1251:                               ; CODE XREF: SmartHighlighter::isQualifiedWord(char const *)+30j
.text$mn:00001251                 mov     al, 1
.text$mn:00001253
.text$mn:00001253 loc_1253:                               ; CODE XREF: SmartHighlighter::isQualifiedWord(char const *)+4Dj
.text$mn:00001253                 mov     esp, ebp
.text$mn:00001255                 pop     ebp
.text$mn:00001256                 retn    4
.text$mn:00001256 ?isQualifiedWord@SmartHighlighter@@ABE_NPBD@Z endp
.text$mn:00001256
.text$mn:00001256 ; ---------------------------------------------------------------------------
.text$mn:00001259                 align 10h
.text$mn:00001260
.text$mn:00001260 ; =============== S U B R O U T I N E =======================================
.text$mn:00001260
.text$mn:00001260 ; Attributes: bp-based frame
.text$mn:00001260
.text$mn:00001260 ; bool __thiscall SmartHighlighter::isWordChar(SmartHighlighter *this, char)
.text$mn:00001260                 public ?isWordChar@SmartHighlighter@@ABE_ND@Z
.text$mn:00001260 ?isWordChar@SmartHighlighter@@ABE_ND@Z proc near
.text$mn:00001260                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+10Cp
.text$mn:00001260                                         ; SmartHighlighter::highlightView(ScintillaEditView *)+157p ...
.text$mn:00001260
.text$mn:00001260 var_8           = dword ptr -8
.text$mn:00001260 var_4           = dword ptr -4
.text$mn:00001260 arg_0           = byte ptr  8
.text$mn:00001260
.text$mn:00001260                 push    ebp
.text$mn:00001261                 mov     ebp, esp
.text$mn:00001263                 sub     esp, 8
.text$mn:00001266                 mov     [ebp+var_8], ecx
.text$mn:00001269                 movzx   eax, [ebp+arg_0]
.text$mn:0000126D                 cmp     eax, 20h ; ' '
.text$mn:00001270                 jge     short loc_1276
.text$mn:00001272                 xor     al, al
.text$mn:00001274                 jmp     short loc_12A3
.text$mn:00001276 ; ---------------------------------------------------------------------------
.text$mn:00001276
.text$mn:00001276 loc_1276:                               ; CODE XREF: SmartHighlighter::isWordChar(char)+10j
.text$mn:00001276                 movsx   ecx, [ebp+arg_0]
.text$mn:0000127A                 mov     [ebp+var_4], ecx
.text$mn:0000127D                 mov     edx, [ebp+var_4]
.text$mn:00001280                 sub     edx, 9
.text$mn:00001283                 mov     [ebp+var_4], edx
.text$mn:00001286                 cmp     [ebp+var_4], 75h ; 'u' ; switch 118 cases
.text$mn:0000128A                 ja      short $LN2      ; jumptable 00001296 default case
.text$mn:0000128C                 mov     eax, [ebp+var_4]
.text$mn:0000128F                 movzx   ecx, ds:$LN7[eax]
.text$mn:00001296                 jmp     ds:$LN8[ecx*4]  ; switch jump
.text$mn:0000129D ; ---------------------------------------------------------------------------
.text$mn:0000129D
.text$mn:0000129D $LN1:                                   ; CODE XREF: SmartHighlighter::isWordChar(char)+36j
.text$mn:0000129D                                         ; DATA XREF: .text$mn:$LN8o
.text$mn:0000129D                 xor     al, al          ; jumptable 00001296 cases 0,1,4,23-38,49-55,82-85,114-117
.text$mn:0000129F                 jmp     short loc_12A3
.text$mn:000012A1 ; ---------------------------------------------------------------------------
.text$mn:000012A1
.text$mn:000012A1 $LN2:                                   ; CODE XREF: SmartHighlighter::isWordChar(char)+2Aj
.text$mn:000012A1                                         ; SmartHighlighter::isWordChar(char)+36j
.text$mn:000012A1                                         ; DATA XREF: ...
.text$mn:000012A1                 mov     al, 1           ; jumptable 00001296 default case
.text$mn:000012A3
.text$mn:000012A3 loc_12A3:                               ; CODE XREF: SmartHighlighter::isWordChar(char)+14j
.text$mn:000012A3                                         ; SmartHighlighter::isWordChar(char)+3Fj
.text$mn:000012A3                 mov     esp, ebp
.text$mn:000012A5                 pop     ebp
.text$mn:000012A6                 retn    4
.text$mn:000012A6 ?isWordChar@SmartHighlighter@@ABE_ND@Z endp
.text$mn:000012A6
.text$mn:000012A6 ; ---------------------------------------------------------------------------
.text$mn:000012A9                 align 4
.text$mn:000012AC $LN8            dd offset $LN1, offset $LN2
.text$mn:000012AC                                         ; DATA XREF: SmartHighlighter::isWordChar(char)+36r
.text$mn:000012AC                                         ; jump table for switch statement
.text$mn:000012B4 $LN7            db      0,     0,     1,     1
.text$mn:000012B4                                         ; DATA XREF: SmartHighlighter::isWordChar(char)+2Fr
.text$mn:000012B4                 db      0,     1,     1,     1 ; indirect table for switch statement
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     0
.text$mn:000012B4                 db      0,     0,     0,     0
.text$mn:000012B4                 db      0,     0,     0,     0
.text$mn:000012B4                 db      0,     0,     0,     0
.text$mn:000012B4                 db      0,     0,     0,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     0,     0,     0
.text$mn:000012B4                 db      0,     0,     0,     0
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     0,     0
.text$mn:000012B4                 db      0,     0,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     1,     1
.text$mn:000012B4                 db      1,     1,     0,     0
.text$mn:000012B4                 db      0,     0
.text$mn:0000132A                 align 4
.text$mn:0000132A _text$mn        ends
.text$mn:0000132A
.text$x:0000132C ; ===========================================================================
.text$x:0000132C
.text$x:0000132C ; Segment type: Pure code
.text$x:0000132C ; Segment permissions: Read/Execute
.text$x:0000132C _text$x         segment para public 'CODE' use32
.text$x:0000132C                 assume cs:_text$x
.text$x:0000132C                 ;org 132Ch
.text$x:0000132C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000132C
.text$x:0000132C ; =============== S U B R O U T I N E =======================================
.text$x:0000132C
.text$x:0000132C
.text$x:0000132C __unwindfunclet$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z$0 proc near
.text$x:0000132C                                         ; DATA XREF: .xdata$x:00003E00o
.text$x:0000132C                 lea     ecx, [ebp-94h]  ; this
.text$x:00001332                 jmp     ??1FindOption@@QAE@XZ ; FindOption::~FindOption(void)
.text$x:00001332 __unwindfunclet$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z$0 endp
.text$x:00001332
.text$x:00001337
.text$x:00001337 ; =============== S U B R O U T I N E =======================================
.text$x:00001337
.text$x:00001337
.text$x:00001337 __ehhandler$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z proc near
.text$x:00001337                                         ; DATA XREF: SmartHighlighter::highlightView(ScintillaEditView *)+5o
.text$x:00001337
.text$x:00001337 arg_4           = dword ptr  8
.text$x:00001337
.text$x:00001337                 mov     edx, [esp+arg_4]
.text$x:0000133B                 lea     eax, [edx+0Ch]
.text$x:0000133E                 mov     ecx, [edx-0ECh]
.text$x:00001344                 xor     ecx, eax
.text$x:00001346                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000134B                 mov     ecx, [edx-4]
.text$x:0000134E                 xor     ecx, eax
.text$x:00001350                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001355                 mov     eax, offset __ehfuncinfo$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z
.text$x:0000135A                 jmp     ___CxxFrameHandler3
.text$x:0000135A __ehhandler$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z endp
.text$x:0000135A
.text$x:0000135A ; ---------------------------------------------------------------------------
.text$x:0000135F                 align 10h
.text$x:0000135F _text$x         ends
.text$x:0000135F
.text$mn:00001360 ; ===========================================================================
.text$mn:00001360
.text$mn:00001360 ; Segment type: Pure code
.text$mn:00001360 ; Segment permissions: Read/Execute
.text$mn:00001360 _text$mn        segment para public 'CODE' use32
.text$mn:00001360                 assume cs:_text$mn
.text$mn:00001360                 ;org 1360h
.text$mn:00001360 ; COMDAT (pick any)
.text$mn:00001360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001360
.text$mn:00001360 ; =============== S U B R O U T I N E =======================================
.text$mn:00001360
.text$mn:00001360 ; Attributes: bp-based frame
.text$mn:00001360
.text$mn:00001360 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001360                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001360 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001360                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001360
.text$mn:00001360 var_4           = dword ptr -4
.text$mn:00001360 arg_0           = dword ptr  8
.text$mn:00001360
.text$mn:00001360                 push    ebp
.text$mn:00001361                 mov     ebp, esp
.text$mn:00001363                 push    ecx
.text$mn:00001364                 mov     [ebp+var_4], 0
.text$mn:0000136B                 cmp     [ebp+arg_0], 0
.text$mn:0000136F                 jnz     short loc_1373
.text$mn:00001371                 jmp     short loc_1393
.text$mn:00001373 ; ---------------------------------------------------------------------------
.text$mn:00001373
.text$mn:00001373 loc_1373:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00001373                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001377                 ja      short loc_138E
.text$mn:00001379                 mov     eax, [ebp+arg_0]
.text$mn:0000137C                 push    eax             ; unsigned int
.text$mn:0000137D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001382                 add     esp, 4
.text$mn:00001385                 mov     [ebp+var_4], eax
.text$mn:00001388                 cmp     [ebp+var_4], 0
.text$mn:0000138C                 jnz     short loc_1393
.text$mn:0000138E
.text$mn:0000138E loc_138E:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000138E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001393
.text$mn:00001393 loc_1393:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00001393                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00001393                 mov     eax, [ebp+var_4]
.text$mn:00001396                 mov     esp, ebp
.text$mn:00001398                 pop     ebp
.text$mn:00001399                 retn
.text$mn:00001399 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001399
.text$mn:00001399 ; ---------------------------------------------------------------------------
.text$mn:0000139A                 align 4
.text$mn:0000139A _text$mn        ends
.text$mn:0000139A
.text$mn:0000139C ; ===========================================================================
.text$mn:0000139C
.text$mn:0000139C ; Segment type: Pure code
.text$mn:0000139C ; Segment permissions: Read/Execute
.text$mn:0000139C _text$mn        segment para public 'CODE' use32
.text$mn:0000139C                 assume cs:_text$mn
.text$mn:0000139C                 ;org 139Ch
.text$mn:0000139C ; COMDAT (pick any)
.text$mn:0000139C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000139C
.text$mn:0000139C ; =============== S U B R O U T I N E =======================================
.text$mn:0000139C
.text$mn:0000139C ; Attributes: bp-based frame
.text$mn:0000139C
.text$mn:0000139C ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:0000139C                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:0000139C ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:0000139C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:0000139C
.text$mn:0000139C var_4           = dword ptr -4
.text$mn:0000139C arg_0           = dword ptr  8
.text$mn:0000139C
.text$mn:0000139C                 push    ebp
.text$mn:0000139D                 mov     ebp, esp
.text$mn:0000139F                 push    ecx
.text$mn:000013A0                 mov     [ebp+var_4], 0
.text$mn:000013A7                 cmp     [ebp+arg_0], 0
.text$mn:000013AB                 jnz     short loc_13AF
.text$mn:000013AD                 jmp     short loc_13D5
.text$mn:000013AF ; ---------------------------------------------------------------------------
.text$mn:000013AF
.text$mn:000013AF loc_13AF:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000013AF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000013B6                 ja      short loc_13D0
.text$mn:000013B8                 mov     eax, [ebp+arg_0]
.text$mn:000013BB                 shl     eax, 3
.text$mn:000013BE                 push    eax             ; unsigned int
.text$mn:000013BF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000013C4                 add     esp, 4
.text$mn:000013C7                 mov     [ebp+var_4], eax
.text$mn:000013CA                 cmp     [ebp+var_4], 0
.text$mn:000013CE                 jnz     short loc_13D5
.text$mn:000013D0
.text$mn:000013D0 loc_13D0:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000013D0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000013D5
.text$mn:000013D5 loc_13D5:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000013D5                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000013D5                 mov     eax, [ebp+var_4]
.text$mn:000013D8                 mov     esp, ebp
.text$mn:000013DA                 pop     ebp
.text$mn:000013DB                 retn
.text$mn:000013DB ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000013DB
.text$mn:000013DB _text$mn        ends
.text$mn:000013DB
.text$mn:000013DC ; ===========================================================================
.text$mn:000013DC
.text$mn:000013DC ; Segment type: Pure code
.text$mn:000013DC ; Segment permissions: Read/Execute
.text$mn:000013DC _text$mn        segment para public 'CODE' use32
.text$mn:000013DC                 assume cs:_text$mn
.text$mn:000013DC                 ;org 13DCh
.text$mn:000013DC ; COMDAT (pick any)
.text$mn:000013DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013DC
.text$mn:000013DC ; =============== S U B R O U T I N E =======================================
.text$mn:000013DC
.text$mn:000013DC ; Attributes: bp-based frame
.text$mn:000013DC
.text$mn:000013DC ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:000013DC                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:000013DC ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:000013DC                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:000013DC
.text$mn:000013DC var_4           = dword ptr -4
.text$mn:000013DC arg_0           = dword ptr  8
.text$mn:000013DC
.text$mn:000013DC                 push    ebp
.text$mn:000013DD                 mov     ebp, esp
.text$mn:000013DF                 push    ecx
.text$mn:000013E0                 mov     [ebp+var_4], 0
.text$mn:000013E7                 cmp     [ebp+arg_0], 0
.text$mn:000013EB                 jnz     short loc_13EF
.text$mn:000013ED                 jmp     short loc_1414
.text$mn:000013EF ; ---------------------------------------------------------------------------
.text$mn:000013EF
.text$mn:000013EF loc_13EF:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:000013EF                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:000013F6                 ja      short loc_140F
.text$mn:000013F8                 mov     eax, [ebp+arg_0]
.text$mn:000013FB                 shl     eax, 1
.text$mn:000013FD                 push    eax             ; unsigned int
.text$mn:000013FE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001403                 add     esp, 4
.text$mn:00001406                 mov     [ebp+var_4], eax
.text$mn:00001409                 cmp     [ebp+var_4], 0
.text$mn:0000140D                 jnz     short loc_1414
.text$mn:0000140F
.text$mn:0000140F loc_140F:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:0000140F                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001414
.text$mn:00001414 loc_1414:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00001414                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00001414                 mov     eax, [ebp+var_4]
.text$mn:00001417                 mov     esp, ebp
.text$mn:00001419                 pop     ebp
.text$mn:0000141A                 retn
.text$mn:0000141A ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:0000141A
.text$mn:0000141A ; ---------------------------------------------------------------------------
.text$mn:0000141B                 align 4
.text$mn:0000141B _text$mn        ends
.text$mn:0000141B
.text$mn:0000141C ; ===========================================================================
.text$mn:0000141C
.text$mn:0000141C ; Segment type: Pure code
.text$mn:0000141C ; Segment permissions: Read/Execute
.text$mn:0000141C _text$mn        segment para public 'CODE' use32
.text$mn:0000141C                 assume cs:_text$mn
.text$mn:0000141C                 ;org 141Ch
.text$mn:0000141C ; COMDAT (pick any)
.text$mn:0000141C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000141C
.text$mn:0000141C ; =============== S U B R O U T I N E =======================================
.text$mn:0000141C
.text$mn:0000141C ; Attributes: bp-based frame
.text$mn:0000141C
.text$mn:0000141C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000141C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000141C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000141C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000141C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000141C
.text$mn:0000141C arg_0           = dword ptr  8
.text$mn:0000141C arg_4           = dword ptr  0Ch
.text$mn:0000141C arg_8           = dword ptr  10h
.text$mn:0000141C
.text$mn:0000141C                 push    ebp
.text$mn:0000141D                 mov     ebp, esp
.text$mn:0000141F                 cmp     [ebp+arg_0], 0
.text$mn:00001423                 jnz     short loc_143A
.text$mn:00001425                 mov     eax, [ebp+arg_8]
.text$mn:00001428                 push    eax             ; unsigned int
.text$mn:00001429                 mov     ecx, [ebp+arg_4]
.text$mn:0000142C                 push    ecx             ; wchar_t *
.text$mn:0000142D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001432                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001437                 add     esp, 0Ch
.text$mn:0000143A
.text$mn:0000143A loc_143A:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000143A                 pop     ebp
.text$mn:0000143B                 retn
.text$mn:0000143B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000143B
.text$mn:0000143B _text$mn        ends
.text$mn:0000143B
.text$mn:0000143C ; ===========================================================================
.text$mn:0000143C
.text$mn:0000143C ; Segment type: Pure code
.text$mn:0000143C ; Segment permissions: Read/Execute
.text$mn:0000143C _text$mn        segment para public 'CODE' use32
.text$mn:0000143C                 assume cs:_text$mn
.text$mn:0000143C                 ;org 143Ch
.text$mn:0000143C ; COMDAT (pick any)
.text$mn:0000143C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000143C
.text$mn:0000143C ; =============== S U B R O U T I N E =======================================
.text$mn:0000143C
.text$mn:0000143C ; Attributes: bp-based frame
.text$mn:0000143C
.text$mn:0000143C ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:0000143C                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:0000143C ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:0000143C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:0000143C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp
.text$mn:0000143C
.text$mn:0000143C arg_0           = dword ptr  8
.text$mn:0000143C arg_4           = dword ptr  0Ch
.text$mn:0000143C arg_8           = dword ptr  10h
.text$mn:0000143C
.text$mn:0000143C                 push    ebp
.text$mn:0000143D                 mov     ebp, esp
.text$mn:0000143F                 cmp     [ebp+arg_0], 0
.text$mn:00001443                 jnz     short loc_145A
.text$mn:00001445                 mov     eax, [ebp+arg_8]
.text$mn:00001448                 push    eax             ; unsigned int
.text$mn:00001449                 mov     ecx, [ebp+arg_4]
.text$mn:0000144C                 push    ecx             ; wchar_t *
.text$mn:0000144D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001452                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001457                 add     esp, 0Ch
.text$mn:0000145A
.text$mn:0000145A loc_145A:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:0000145A                 pop     ebp
.text$mn:0000145B                 retn
.text$mn:0000145B ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:0000145B
.text$mn:0000145B _text$mn        ends
.text$mn:0000145B
.text$mn:0000145C ; ===========================================================================
.text$mn:0000145C
.text$mn:0000145C ; Segment type: Pure code
.text$mn:0000145C ; Segment permissions: Read/Execute
.text$mn:0000145C _text$mn        segment para public 'CODE' use32
.text$mn:0000145C                 assume cs:_text$mn
.text$mn:0000145C                 ;org 145Ch
.text$mn:0000145C ; COMDAT (pick any)
.text$mn:0000145C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000145C
.text$mn:0000145C ; =============== S U B R O U T I N E =======================================
.text$mn:0000145C
.text$mn:0000145C ; Attributes: bp-based frame
.text$mn:0000145C
.text$mn:0000145C ; char * __cdecl std::addressof<char>(char &)
.text$mn:0000145C                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:0000145C ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:0000145C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:0000145C                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:0000145C
.text$mn:0000145C arg_0           = dword ptr  8
.text$mn:0000145C
.text$mn:0000145C                 push    ebp
.text$mn:0000145D                 mov     ebp, esp
.text$mn:0000145F                 mov     eax, [ebp+arg_0]
.text$mn:00001462                 pop     ebp
.text$mn:00001463                 retn
.text$mn:00001463 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00001463
.text$mn:00001463 _text$mn        ends
.text$mn:00001463
.text$mn:00001464 ; ===========================================================================
.text$mn:00001464
.text$mn:00001464 ; Segment type: Pure code
.text$mn:00001464 ; Segment permissions: Read/Execute
.text$mn:00001464 _text$mn        segment para public 'CODE' use32
.text$mn:00001464                 assume cs:_text$mn
.text$mn:00001464                 ;org 1464h
.text$mn:00001464 ; COMDAT (pick any)
.text$mn:00001464                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001464
.text$mn:00001464 ; =============== S U B R O U T I N E =======================================
.text$mn:00001464
.text$mn:00001464 ; Attributes: bp-based frame
.text$mn:00001464
.text$mn:00001464 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00001464                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00001464 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00001464                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00001464                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00001464
.text$mn:00001464 arg_0           = dword ptr  8
.text$mn:00001464
.text$mn:00001464                 push    ebp
.text$mn:00001465                 mov     ebp, esp
.text$mn:00001467                 mov     eax, [ebp+arg_0]
.text$mn:0000146A                 pop     ebp
.text$mn:0000146B                 retn
.text$mn:0000146B ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000146B
.text$mn:0000146B _text$mn        ends
.text$mn:0000146B
.text$mn:0000146C ; ===========================================================================
.text$mn:0000146C
.text$mn:0000146C ; Segment type: Pure code
.text$mn:0000146C ; Segment permissions: Read/Execute
.text$mn:0000146C _text$mn        segment para public 'CODE' use32
.text$mn:0000146C                 assume cs:_text$mn
.text$mn:0000146C                 ;org 146Ch
.text$mn:0000146C ; COMDAT (pick any)
.text$mn:0000146C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000146C
.text$mn:0000146C ; =============== S U B R O U T I N E =======================================
.text$mn:0000146C
.text$mn:0000146C ; Attributes: bp-based frame
.text$mn:0000146C
.text$mn:0000146C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:0000146C                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:0000146C ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000146C                                         ; CODE XREF: $LN19+4Bp
.text$mn:0000146C
.text$mn:0000146C var_4           = dword ptr -4
.text$mn:0000146C arg_0           = dword ptr  8
.text$mn:0000146C arg_4           = dword ptr  0Ch
.text$mn:0000146C
.text$mn:0000146C                 push    ebp
.text$mn:0000146D                 mov     ebp, esp
.text$mn:0000146F                 push    ecx
.text$mn:00001470                 mov     [ebp+var_4], ecx
.text$mn:00001473                 mov     eax, [ebp+arg_4]
.text$mn:00001476                 push    eax
.text$mn:00001477                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000147C                 add     esp, 4
.text$mn:0000147F                 push    eax             ; int
.text$mn:00001480                 mov     ecx, [ebp+arg_0]
.text$mn:00001483                 push    ecx             ; void *
.text$mn:00001484                 mov     edx, [ebp+var_4]
.text$mn:00001487                 push    edx             ; int
.text$mn:00001488                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000148D                 add     esp, 0Ch
.text$mn:00001490                 mov     esp, ebp
.text$mn:00001492                 pop     ebp
.text$mn:00001493                 retn    8
.text$mn:00001493 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001493
.text$mn:00001493 ; ---------------------------------------------------------------------------
.text$mn:00001496                 align 4
.text$mn:00001496 _text$mn        ends
.text$mn:00001496
.text$mn:00001498 ; ===========================================================================
.text$mn:00001498
.text$mn:00001498 ; Segment type: Pure code
.text$mn:00001498 ; Segment permissions: Read/Execute
.text$mn:00001498 _text$mn        segment para public 'CODE' use32
.text$mn:00001498                 assume cs:_text$mn
.text$mn:00001498                 ;org 1498h
.text$mn:00001498 ; COMDAT (pick any)
.text$mn:00001498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001498
.text$mn:00001498 ; =============== S U B R O U T I N E =======================================
.text$mn:00001498
.text$mn:00001498 ; Attributes: bp-based frame
.text$mn:00001498
.text$mn:00001498 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001498                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001498 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001498                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001498
.text$mn:00001498 var_1C          = dword ptr -1Ch
.text$mn:00001498 var_18          = dword ptr -18h
.text$mn:00001498 var_14          = dword ptr -14h
.text$mn:00001498 var_10          = dword ptr -10h
.text$mn:00001498 var_C           = dword ptr -0Ch
.text$mn:00001498 var_4           = dword ptr -4
.text$mn:00001498 arg_0           = dword ptr  8
.text$mn:00001498 arg_4           = dword ptr  0Ch
.text$mn:00001498
.text$mn:00001498                 push    ebp
.text$mn:00001499                 mov     ebp, esp
.text$mn:0000149B                 push    0FFFFFFFFh
.text$mn:0000149D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000014A2                 mov     eax, large fs:0
.text$mn:000014A8                 push    eax
.text$mn:000014A9                 sub     esp, 10h
.text$mn:000014AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014B1                 xor     eax, ebp
.text$mn:000014B3                 push    eax
.text$mn:000014B4                 lea     eax, [ebp+var_C]
.text$mn:000014B7                 mov     large fs:0, eax
.text$mn:000014BD                 mov     [ebp+var_18], ecx
.text$mn:000014C0                 mov     eax, [ebp+arg_0]
.text$mn:000014C3                 push    eax             ; void *
.text$mn:000014C4                 push    4               ; unsigned int
.text$mn:000014C6                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000014CB                 add     esp, 8
.text$mn:000014CE                 mov     [ebp+var_10], eax
.text$mn:000014D1                 mov     [ebp+var_4], 0
.text$mn:000014D8                 cmp     [ebp+var_10], 0
.text$mn:000014DC                 jz      short loc_14F9
.text$mn:000014DE                 mov     ecx, [ebp+arg_4]
.text$mn:000014E1                 push    ecx
.text$mn:000014E2                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000014E7                 add     esp, 4
.text$mn:000014EA                 mov     edx, [ebp+var_10]
.text$mn:000014ED                 mov     eax, [eax]
.text$mn:000014EF                 mov     [edx], eax
.text$mn:000014F1                 mov     ecx, [ebp+var_10]
.text$mn:000014F4                 mov     [ebp+var_14], ecx
.text$mn:000014F7                 jmp     short loc_1500
.text$mn:000014F9 ; ---------------------------------------------------------------------------
.text$mn:000014F9
.text$mn:000014F9 loc_14F9:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000014F9                 mov     [ebp+var_14], 0
.text$mn:00001500
.text$mn:00001500 loc_1500:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00001500                 mov     edx, [ebp+var_14]
.text$mn:00001503                 mov     [ebp+var_1C], edx
.text$mn:00001506                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000150D                 mov     ecx, [ebp+var_C]
.text$mn:00001510                 mov     large fs:0, ecx
.text$mn:00001517                 pop     ecx
.text$mn:00001518                 mov     esp, ebp
.text$mn:0000151A                 pop     ebp
.text$mn:0000151B                 retn    8
.text$mn:0000151B ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000151B
.text$mn:0000151B ; ---------------------------------------------------------------------------
.text$mn:0000151E                 align 10h
.text$mn:0000151E _text$mn        ends
.text$mn:0000151E
.text$x:00001520 ; ===========================================================================
.text$x:00001520
.text$x:00001520 ; Segment type: Pure code
.text$x:00001520 ; Segment permissions: Read/Execute
.text$x:00001520 _text$x         segment para public 'CODE' use32
.text$x:00001520                 assume cs:_text$x
.text$x:00001520                 ;org 1520h
.text$x:00001520 ; COMDAT (pick associative to section at 1498)
.text$x:00001520                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001520
.text$x:00001520 ; =============== S U B R O U T I N E =======================================
.text$x:00001520
.text$x:00001520
.text$x:00001520 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00001520                                         ; DATA XREF: .xdata$x:000043ECo
.text$x:00001520                 mov     eax, [ebp+8]
.text$x:00001523                 push    eax
.text$x:00001524                 mov     eax, [ebp-10h]
.text$x:00001527                 push    eax             ; void *
.text$x:00001528                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000152D                 add     esp, 8
.text$x:00001530                 retn
.text$x:00001530 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00001530
.text$x:00001531
.text$x:00001531 ; =============== S U B R O U T I N E =======================================
.text$x:00001531
.text$x:00001531
.text$x:00001531 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00001531                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00001531
.text$x:00001531 arg_4           = dword ptr  8
.text$x:00001531
.text$x:00001531                 mov     edx, [esp+arg_4]
.text$x:00001535                 lea     eax, [edx+0Ch]
.text$x:00001538                 mov     ecx, [edx-14h]
.text$x:0000153B                 xor     ecx, eax
.text$x:0000153D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001542                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00001547                 jmp     ___CxxFrameHandler3
.text$x:00001547 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00001547
.text$x:00001547 _text$x         ends
.text$x:00001547
.text$mn:0000154C ; ===========================================================================
.text$mn:0000154C
.text$mn:0000154C ; Segment type: Pure code
.text$mn:0000154C ; Segment permissions: Read/Execute
.text$mn:0000154C _text$mn        segment para public 'CODE' use32
.text$mn:0000154C                 assume cs:_text$mn
.text$mn:0000154C                 ;org 154Ch
.text$mn:0000154C ; COMDAT (pick any)
.text$mn:0000154C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000154C
.text$mn:0000154C ; =============== S U B R O U T I N E =======================================
.text$mn:0000154C
.text$mn:0000154C ; Attributes: bp-based frame
.text$mn:0000154C
.text$mn:0000154C ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:0000154C                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:0000154C ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:0000154C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:0000154C
.text$mn:0000154C arg_0           = dword ptr  8
.text$mn:0000154C arg_4           = dword ptr  0Ch
.text$mn:0000154C arg_8           = dword ptr  10h
.text$mn:0000154C
.text$mn:0000154C                 push    ebp
.text$mn:0000154D                 mov     ebp, esp
.text$mn:0000154F                 mov     eax, [ebp+arg_8]
.text$mn:00001552                 push    eax
.text$mn:00001553                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001558                 add     esp, 4
.text$mn:0000155B                 push    eax             ; int
.text$mn:0000155C                 mov     ecx, [ebp+arg_4]
.text$mn:0000155F                 push    ecx             ; void *
.text$mn:00001560                 mov     ecx, [ebp+arg_0]
.text$mn:00001563                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001568                 pop     ebp
.text$mn:00001569                 retn
.text$mn:00001569 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001569
.text$mn:00001569 ; ---------------------------------------------------------------------------
.text$mn:0000156A                 align 4
.text$mn:0000156A _text$mn        ends
.text$mn:0000156A
.text$mn:0000156C ; ===========================================================================
.text$mn:0000156C
.text$mn:0000156C ; Segment type: Pure code
.text$mn:0000156C ; Segment permissions: Read/Execute
.text$mn:0000156C _text$mn        segment para public 'CODE' use32
.text$mn:0000156C                 assume cs:_text$mn
.text$mn:0000156C                 ;org 156Ch
.text$mn:0000156C ; COMDAT (pick any)
.text$mn:0000156C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000156C
.text$mn:0000156C ; =============== S U B R O U T I N E =======================================
.text$mn:0000156C
.text$mn:0000156C ; Attributes: bp-based frame
.text$mn:0000156C
.text$mn:0000156C ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:0000156C                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000156C ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:0000156C                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:0000156C
.text$mn:0000156C var_4           = dword ptr -4
.text$mn:0000156C arg_0           = dword ptr  8
.text$mn:0000156C arg_4           = dword ptr  0Ch
.text$mn:0000156C
.text$mn:0000156C                 push    ebp
.text$mn:0000156D                 mov     ebp, esp
.text$mn:0000156F                 push    ecx
.text$mn:00001570                 mov     [ebp+var_4], ecx
.text$mn:00001573                 mov     eax, [ebp+arg_4]
.text$mn:00001576                 push    eax
.text$mn:00001577                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000157C                 add     esp, 4
.text$mn:0000157F                 push    eax             ; int
.text$mn:00001580                 mov     ecx, [ebp+arg_0]
.text$mn:00001583                 push    ecx             ; void *
.text$mn:00001584                 mov     edx, [ebp+var_4]
.text$mn:00001587                 push    edx             ; int
.text$mn:00001588                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:0000158D                 add     esp, 0Ch
.text$mn:00001590                 mov     esp, ebp
.text$mn:00001592                 pop     ebp
.text$mn:00001593                 retn    8
.text$mn:00001593 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00001593
.text$mn:00001593 ; ---------------------------------------------------------------------------
.text$mn:00001596                 align 4
.text$mn:00001596 _text$mn        ends
.text$mn:00001596
.text$mn:00001598 ; ===========================================================================
.text$mn:00001598
.text$mn:00001598 ; Segment type: Pure code
.text$mn:00001598 ; Segment permissions: Read/Execute
.text$mn:00001598 _text$mn        segment para public 'CODE' use32
.text$mn:00001598                 assume cs:_text$mn
.text$mn:00001598                 ;org 1598h
.text$mn:00001598 ; COMDAT (pick any)
.text$mn:00001598                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001598
.text$mn:00001598 ; =============== S U B R O U T I N E =======================================
.text$mn:00001598
.text$mn:00001598 ; Attributes: bp-based frame
.text$mn:00001598
.text$mn:00001598 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00001598                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001598 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00001598                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00001598
.text$mn:00001598 var_1C          = dword ptr -1Ch
.text$mn:00001598 var_18          = dword ptr -18h
.text$mn:00001598 var_14          = dword ptr -14h
.text$mn:00001598 var_10          = dword ptr -10h
.text$mn:00001598 var_C           = dword ptr -0Ch
.text$mn:00001598 var_4           = dword ptr -4
.text$mn:00001598 arg_0           = dword ptr  8
.text$mn:00001598 arg_4           = dword ptr  0Ch
.text$mn:00001598
.text$mn:00001598                 push    ebp
.text$mn:00001599                 mov     ebp, esp
.text$mn:0000159B                 push    0FFFFFFFFh
.text$mn:0000159D                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000015A2                 mov     eax, large fs:0
.text$mn:000015A8                 push    eax
.text$mn:000015A9                 sub     esp, 10h
.text$mn:000015AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015B1                 xor     eax, ebp
.text$mn:000015B3                 push    eax
.text$mn:000015B4                 lea     eax, [ebp+var_C]
.text$mn:000015B7                 mov     large fs:0, eax
.text$mn:000015BD                 mov     [ebp+var_18], ecx
.text$mn:000015C0                 mov     eax, [ebp+arg_0]
.text$mn:000015C3                 push    eax             ; void *
.text$mn:000015C4                 push    4               ; unsigned int
.text$mn:000015C6                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000015CB                 add     esp, 8
.text$mn:000015CE                 mov     [ebp+var_10], eax
.text$mn:000015D1                 mov     [ebp+var_4], 0
.text$mn:000015D8                 cmp     [ebp+var_10], 0
.text$mn:000015DC                 jz      short loc_15F9
.text$mn:000015DE                 mov     ecx, [ebp+arg_4]
.text$mn:000015E1                 push    ecx
.text$mn:000015E2                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000015E7                 add     esp, 4
.text$mn:000015EA                 mov     edx, [ebp+var_10]
.text$mn:000015ED                 mov     eax, [eax]
.text$mn:000015EF                 mov     [edx], eax
.text$mn:000015F1                 mov     ecx, [ebp+var_10]
.text$mn:000015F4                 mov     [ebp+var_14], ecx
.text$mn:000015F7                 jmp     short loc_1600
.text$mn:000015F9 ; ---------------------------------------------------------------------------
.text$mn:000015F9
.text$mn:000015F9 loc_15F9:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:000015F9                 mov     [ebp+var_14], 0
.text$mn:00001600
.text$mn:00001600 loc_1600:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00001600                 mov     edx, [ebp+var_14]
.text$mn:00001603                 mov     [ebp+var_1C], edx
.text$mn:00001606                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000160D                 mov     ecx, [ebp+var_C]
.text$mn:00001610                 mov     large fs:0, ecx
.text$mn:00001617                 pop     ecx
.text$mn:00001618                 mov     esp, ebp
.text$mn:0000161A                 pop     ebp
.text$mn:0000161B                 retn    8
.text$mn:0000161B ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:0000161B
.text$mn:0000161B ; ---------------------------------------------------------------------------
.text$mn:0000161E                 align 10h
.text$mn:0000161E _text$mn        ends
.text$mn:0000161E
.text$x:00001620 ; ===========================================================================
.text$x:00001620
.text$x:00001620 ; Segment type: Pure code
.text$x:00001620 ; Segment permissions: Read/Execute
.text$x:00001620 _text$x         segment para public 'CODE' use32
.text$x:00001620                 assume cs:_text$x
.text$x:00001620                 ;org 1620h
.text$x:00001620 ; COMDAT (pick associative to section at 1598)
.text$x:00001620                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001620
.text$x:00001620 ; =============== S U B R O U T I N E =======================================
.text$x:00001620
.text$x:00001620
.text$x:00001620 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00001620                                         ; DATA XREF: .xdata$x:00004418o
.text$x:00001620                 mov     eax, [ebp+8]
.text$x:00001623                 push    eax
.text$x:00001624                 mov     eax, [ebp-10h]
.text$x:00001627                 push    eax             ; void *
.text$x:00001628                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000162D                 add     esp, 8
.text$x:00001630                 retn
.text$x:00001630 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00001630
.text$x:00001631
.text$x:00001631 ; =============== S U B R O U T I N E =======================================
.text$x:00001631
.text$x:00001631
.text$x:00001631 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00001631                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00001631
.text$x:00001631 arg_4           = dword ptr  8
.text$x:00001631
.text$x:00001631                 mov     edx, [esp+arg_4]
.text$x:00001635                 lea     eax, [edx+0Ch]
.text$x:00001638                 mov     ecx, [edx-14h]
.text$x:0000163B                 xor     ecx, eax
.text$x:0000163D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001642                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00001647                 jmp     ___CxxFrameHandler3
.text$x:00001647 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00001647
.text$x:00001647 _text$x         ends
.text$x:00001647
.text$mn:0000164C ; ===========================================================================
.text$mn:0000164C
.text$mn:0000164C ; Segment type: Pure code
.text$mn:0000164C ; Segment permissions: Read/Execute
.text$mn:0000164C _text$mn        segment para public 'CODE' use32
.text$mn:0000164C                 assume cs:_text$mn
.text$mn:0000164C                 ;org 164Ch
.text$mn:0000164C ; COMDAT (pick any)
.text$mn:0000164C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000164C
.text$mn:0000164C ; =============== S U B R O U T I N E =======================================
.text$mn:0000164C
.text$mn:0000164C ; Attributes: bp-based frame
.text$mn:0000164C
.text$mn:0000164C ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:0000164C                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:0000164C ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:0000164C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:0000164C
.text$mn:0000164C arg_0           = dword ptr  8
.text$mn:0000164C arg_4           = dword ptr  0Ch
.text$mn:0000164C arg_8           = dword ptr  10h
.text$mn:0000164C
.text$mn:0000164C                 push    ebp
.text$mn:0000164D                 mov     ebp, esp
.text$mn:0000164F                 mov     eax, [ebp+arg_8]
.text$mn:00001652                 push    eax
.text$mn:00001653                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001658                 add     esp, 4
.text$mn:0000165B                 push    eax             ; int
.text$mn:0000165C                 mov     ecx, [ebp+arg_4]
.text$mn:0000165F                 push    ecx             ; void *
.text$mn:00001660                 mov     ecx, [ebp+arg_0]
.text$mn:00001663                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00001668                 pop     ebp
.text$mn:00001669                 retn
.text$mn:00001669 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00001669
.text$mn:00001669 ; ---------------------------------------------------------------------------
.text$mn:0000166A                 align 4
.text$mn:0000166A _text$mn        ends
.text$mn:0000166A
.text$mn:0000166C ; ===========================================================================
.text$mn:0000166C
.text$mn:0000166C ; Segment type: Pure code
.text$mn:0000166C ; Segment permissions: Read/Execute
.text$mn:0000166C _text$mn        segment para public 'CODE' use32
.text$mn:0000166C                 assume cs:_text$mn
.text$mn:0000166C                 ;org 166Ch
.text$mn:0000166C ; COMDAT (pick any)
.text$mn:0000166C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000166C
.text$mn:0000166C ; =============== S U B R O U T I N E =======================================
.text$mn:0000166C
.text$mn:0000166C ; Attributes: bp-based frame
.text$mn:0000166C
.text$mn:0000166C ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:0000166C                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000166C ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:0000166C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:0000166C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:0000166C
.text$mn:0000166C var_1C          = dword ptr -1Ch
.text$mn:0000166C var_18          = dword ptr -18h
.text$mn:0000166C var_14          = dword ptr -14h
.text$mn:0000166C var_10          = dword ptr -10h
.text$mn:0000166C var_C           = dword ptr -0Ch
.text$mn:0000166C var_4           = dword ptr -4
.text$mn:0000166C arg_0           = dword ptr  8
.text$mn:0000166C arg_4           = dword ptr  0Ch
.text$mn:0000166C
.text$mn:0000166C                 push    ebp
.text$mn:0000166D                 mov     ebp, esp
.text$mn:0000166F                 push    0FFFFFFFFh
.text$mn:00001671                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001676                 mov     eax, large fs:0
.text$mn:0000167C                 push    eax
.text$mn:0000167D                 sub     esp, 10h
.text$mn:00001680                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001685                 xor     eax, ebp
.text$mn:00001687                 push    eax
.text$mn:00001688                 lea     eax, [ebp+var_C]
.text$mn:0000168B                 mov     large fs:0, eax
.text$mn:00001691                 mov     [ebp+var_18], ecx
.text$mn:00001694                 mov     eax, [ebp+arg_0]
.text$mn:00001697                 push    eax             ; void *
.text$mn:00001698                 push    8               ; unsigned int
.text$mn:0000169A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000169F                 add     esp, 8
.text$mn:000016A2                 mov     [ebp+var_10], eax
.text$mn:000016A5                 mov     [ebp+var_4], 0
.text$mn:000016AC                 cmp     [ebp+var_10], 0
.text$mn:000016B0                 jz      short loc_16D3
.text$mn:000016B2                 mov     ecx, [ebp+arg_4]
.text$mn:000016B5                 push    ecx
.text$mn:000016B6                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000016BB                 add     esp, 4
.text$mn:000016BE                 mov     edx, [eax]
.text$mn:000016C0                 mov     eax, [eax+4]
.text$mn:000016C3                 mov     ecx, [ebp+var_10]
.text$mn:000016C6                 mov     [ecx], edx
.text$mn:000016C8                 mov     [ecx+4], eax
.text$mn:000016CB                 mov     edx, [ebp+var_10]
.text$mn:000016CE                 mov     [ebp+var_14], edx
.text$mn:000016D1                 jmp     short loc_16DA
.text$mn:000016D3 ; ---------------------------------------------------------------------------
.text$mn:000016D3
.text$mn:000016D3 loc_16D3:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000016D3                 mov     [ebp+var_14], 0
.text$mn:000016DA
.text$mn:000016DA loc_16DA:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000016DA                 mov     eax, [ebp+var_14]
.text$mn:000016DD                 mov     [ebp+var_1C], eax
.text$mn:000016E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016E7                 mov     ecx, [ebp+var_C]
.text$mn:000016EA                 mov     large fs:0, ecx
.text$mn:000016F1                 pop     ecx
.text$mn:000016F2                 mov     esp, ebp
.text$mn:000016F4                 pop     ebp
.text$mn:000016F5                 retn    8
.text$mn:000016F5 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000016F5
.text$mn:000016F5 _text$mn        ends
.text$mn:000016F5
.text$x:000016F8 ; ===========================================================================
.text$x:000016F8
.text$x:000016F8 ; Segment type: Pure code
.text$x:000016F8 ; Segment permissions: Read/Execute
.text$x:000016F8 _text$x         segment para public 'CODE' use32
.text$x:000016F8                 assume cs:_text$x
.text$x:000016F8                 ;org 16F8h
.text$x:000016F8 ; COMDAT (pick associative to section at 166C)
.text$x:000016F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000016F8
.text$x:000016F8 ; =============== S U B R O U T I N E =======================================
.text$x:000016F8
.text$x:000016F8
.text$x:000016F8 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000016F8                                         ; DATA XREF: .xdata$x:000043C0o
.text$x:000016F8                 mov     eax, [ebp+8]
.text$x:000016FB                 push    eax
.text$x:000016FC                 mov     eax, [ebp-10h]
.text$x:000016FF                 push    eax             ; void *
.text$x:00001700                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001705                 add     esp, 8
.text$x:00001708                 retn
.text$x:00001708 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001708
.text$x:00001709
.text$x:00001709 ; =============== S U B R O U T I N E =======================================
.text$x:00001709
.text$x:00001709
.text$x:00001709 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001709                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001709
.text$x:00001709 arg_4           = dword ptr  8
.text$x:00001709
.text$x:00001709                 mov     edx, [esp+arg_4]
.text$x:0000170D                 lea     eax, [edx+0Ch]
.text$x:00001710                 mov     ecx, [edx-14h]
.text$x:00001713                 xor     ecx, eax
.text$x:00001715                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000171A                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000171F                 jmp     ___CxxFrameHandler3
.text$x:0000171F __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000171F
.text$x:0000171F _text$x         ends
.text$x:0000171F
.text$mn:00001724 ; ===========================================================================
.text$mn:00001724
.text$mn:00001724 ; Segment type: Pure code
.text$mn:00001724 ; Segment permissions: Read/Execute
.text$mn:00001724 _text$mn        segment para public 'CODE' use32
.text$mn:00001724                 assume cs:_text$mn
.text$mn:00001724                 ;org 1724h
.text$mn:00001724 ; COMDAT (pick any)
.text$mn:00001724                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001724
.text$mn:00001724 ; =============== S U B R O U T I N E =======================================
.text$mn:00001724
.text$mn:00001724 ; Attributes: bp-based frame
.text$mn:00001724
.text$mn:00001724 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001724                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00001724 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00001724                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00001724
.text$mn:00001724 var_4           = dword ptr -4
.text$mn:00001724 arg_0           = dword ptr  8
.text$mn:00001724
.text$mn:00001724                 push    ebp
.text$mn:00001725                 mov     ebp, esp
.text$mn:00001727                 push    ecx
.text$mn:00001728                 mov     [ebp+var_4], ecx
.text$mn:0000172B                 mov     eax, [ebp+arg_0]
.text$mn:0000172E                 push    eax
.text$mn:0000172F                 mov     ecx, [ebp+var_4]
.text$mn:00001732                 push    ecx
.text$mn:00001733                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001738                 add     esp, 8
.text$mn:0000173B                 mov     esp, ebp
.text$mn:0000173D                 pop     ebp
.text$mn:0000173E                 retn    4
.text$mn:0000173E ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:0000173E
.text$mn:0000173E ; ---------------------------------------------------------------------------
.text$mn:00001741                 align 4
.text$mn:00001741 _text$mn        ends
.text$mn:00001741
.text$mn:00001744 ; ===========================================================================
.text$mn:00001744
.text$mn:00001744 ; Segment type: Pure code
.text$mn:00001744 ; Segment permissions: Read/Execute
.text$mn:00001744 _text$mn        segment para public 'CODE' use32
.text$mn:00001744                 assume cs:_text$mn
.text$mn:00001744                 ;org 1744h
.text$mn:00001744 ; COMDAT (pick any)
.text$mn:00001744                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001744
.text$mn:00001744 ; =============== S U B R O U T I N E =======================================
.text$mn:00001744
.text$mn:00001744 ; Attributes: bp-based frame
.text$mn:00001744
.text$mn:00001744 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001744                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00001744 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00001744                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00001744
.text$mn:00001744 var_4           = dword ptr -4
.text$mn:00001744
.text$mn:00001744                 push    ebp
.text$mn:00001745                 mov     ebp, esp
.text$mn:00001747                 push    ecx
.text$mn:00001748                 mov     [ebp+var_4], ecx
.text$mn:0000174B                 mov     esp, ebp
.text$mn:0000174D                 pop     ebp
.text$mn:0000174E                 retn    4
.text$mn:0000174E ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:0000174E
.text$mn:0000174E ; ---------------------------------------------------------------------------
.text$mn:00001751                 align 4
.text$mn:00001751 _text$mn        ends
.text$mn:00001751
.text$mn:00001754 ; ===========================================================================
.text$mn:00001754
.text$mn:00001754 ; Segment type: Pure code
.text$mn:00001754 ; Segment permissions: Read/Execute
.text$mn:00001754 _text$mn        segment para public 'CODE' use32
.text$mn:00001754                 assume cs:_text$mn
.text$mn:00001754                 ;org 1754h
.text$mn:00001754 ; COMDAT (pick any)
.text$mn:00001754                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001754
.text$mn:00001754 ; =============== S U B R O U T I N E =======================================
.text$mn:00001754
.text$mn:00001754 ; Attributes: bp-based frame
.text$mn:00001754
.text$mn:00001754 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00001754                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00001754 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00001754                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00001754
.text$mn:00001754 arg_0           = dword ptr  8
.text$mn:00001754 arg_4           = dword ptr  0Ch
.text$mn:00001754
.text$mn:00001754                 push    ebp
.text$mn:00001755                 mov     ebp, esp
.text$mn:00001757                 mov     eax, [ebp+arg_4]
.text$mn:0000175A                 push    eax
.text$mn:0000175B                 mov     ecx, [ebp+arg_0]
.text$mn:0000175E                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001763                 pop     ebp
.text$mn:00001764                 retn
.text$mn:00001764 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00001764
.text$mn:00001764 ; ---------------------------------------------------------------------------
.text$mn:00001765                 align 4
.text$mn:00001765 _text$mn        ends
.text$mn:00001765
.text$mn:00001768 ; ===========================================================================
.text$mn:00001768
.text$mn:00001768 ; Segment type: Pure code
.text$mn:00001768 ; Segment permissions: Read/Execute
.text$mn:00001768 _text$mn        segment para public 'CODE' use32
.text$mn:00001768                 assume cs:_text$mn
.text$mn:00001768                 ;org 1768h
.text$mn:00001768 ; COMDAT (pick any)
.text$mn:00001768                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001768
.text$mn:00001768 ; =============== S U B R O U T I N E =======================================
.text$mn:00001768
.text$mn:00001768 ; Attributes: bp-based frame
.text$mn:00001768
.text$mn:00001768 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001768                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00001768 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00001768                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00001768
.text$mn:00001768 var_4           = dword ptr -4
.text$mn:00001768 arg_0           = dword ptr  8
.text$mn:00001768
.text$mn:00001768                 push    ebp
.text$mn:00001769                 mov     ebp, esp
.text$mn:0000176B                 push    ecx
.text$mn:0000176C                 mov     [ebp+var_4], ecx
.text$mn:0000176F                 mov     eax, [ebp+arg_0]
.text$mn:00001772                 push    eax
.text$mn:00001773                 mov     ecx, [ebp+var_4]
.text$mn:00001776                 push    ecx
.text$mn:00001777                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:0000177C                 add     esp, 8
.text$mn:0000177F                 mov     esp, ebp
.text$mn:00001781                 pop     ebp
.text$mn:00001782                 retn    4
.text$mn:00001782 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00001782
.text$mn:00001782 ; ---------------------------------------------------------------------------
.text$mn:00001785                 align 4
.text$mn:00001785 _text$mn        ends
.text$mn:00001785
.text$mn:00001788 ; ===========================================================================
.text$mn:00001788
.text$mn:00001788 ; Segment type: Pure code
.text$mn:00001788 ; Segment permissions: Read/Execute
.text$mn:00001788 _text$mn        segment para public 'CODE' use32
.text$mn:00001788                 assume cs:_text$mn
.text$mn:00001788                 ;org 1788h
.text$mn:00001788 ; COMDAT (pick any)
.text$mn:00001788                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001788
.text$mn:00001788 ; =============== S U B R O U T I N E =======================================
.text$mn:00001788
.text$mn:00001788 ; Attributes: bp-based frame
.text$mn:00001788
.text$mn:00001788 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001788                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00001788 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00001788                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00001788
.text$mn:00001788 var_4           = dword ptr -4
.text$mn:00001788
.text$mn:00001788                 push    ebp
.text$mn:00001789                 mov     ebp, esp
.text$mn:0000178B                 push    ecx
.text$mn:0000178C                 mov     [ebp+var_4], ecx
.text$mn:0000178F                 mov     esp, ebp
.text$mn:00001791                 pop     ebp
.text$mn:00001792                 retn    4
.text$mn:00001792 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00001792
.text$mn:00001792 ; ---------------------------------------------------------------------------
.text$mn:00001795                 align 4
.text$mn:00001795 _text$mn        ends
.text$mn:00001795
.text$mn:00001798 ; ===========================================================================
.text$mn:00001798
.text$mn:00001798 ; Segment type: Pure code
.text$mn:00001798 ; Segment permissions: Read/Execute
.text$mn:00001798 _text$mn        segment para public 'CODE' use32
.text$mn:00001798                 assume cs:_text$mn
.text$mn:00001798                 ;org 1798h
.text$mn:00001798 ; COMDAT (pick any)
.text$mn:00001798                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001798
.text$mn:00001798 ; =============== S U B R O U T I N E =======================================
.text$mn:00001798
.text$mn:00001798 ; Attributes: bp-based frame
.text$mn:00001798
.text$mn:00001798 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00001798                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00001798 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00001798                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00001798
.text$mn:00001798 arg_0           = dword ptr  8
.text$mn:00001798 arg_4           = dword ptr  0Ch
.text$mn:00001798
.text$mn:00001798                 push    ebp
.text$mn:00001799                 mov     ebp, esp
.text$mn:0000179B                 mov     eax, [ebp+arg_4]
.text$mn:0000179E                 push    eax
.text$mn:0000179F                 mov     ecx, [ebp+arg_0]
.text$mn:000017A2                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000017A7                 pop     ebp
.text$mn:000017A8                 retn
.text$mn:000017A8 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:000017A8
.text$mn:000017A8 ; ---------------------------------------------------------------------------
.text$mn:000017A9                 align 4
.text$mn:000017A9 _text$mn        ends
.text$mn:000017A9
.text$mn:000017AC ; ===========================================================================
.text$mn:000017AC
.text$mn:000017AC ; Segment type: Pure code
.text$mn:000017AC ; Segment permissions: Read/Execute
.text$mn:000017AC _text$mn        segment para public 'CODE' use32
.text$mn:000017AC                 assume cs:_text$mn
.text$mn:000017AC                 ;org 17ACh
.text$mn:000017AC ; COMDAT (pick any)
.text$mn:000017AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017AC
.text$mn:000017AC ; =============== S U B R O U T I N E =======================================
.text$mn:000017AC
.text$mn:000017AC ; Attributes: bp-based frame
.text$mn:000017AC
.text$mn:000017AC ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000017AC                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000017AC ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000017AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000017AC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:000017AC
.text$mn:000017AC var_4           = dword ptr -4
.text$mn:000017AC
.text$mn:000017AC                 push    ebp
.text$mn:000017AD                 mov     ebp, esp
.text$mn:000017AF                 push    ecx
.text$mn:000017B0                 mov     [ebp+var_4], ecx
.text$mn:000017B3                 mov     esp, ebp
.text$mn:000017B5                 pop     ebp
.text$mn:000017B6                 retn    4
.text$mn:000017B6 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000017B6
.text$mn:000017B6 ; ---------------------------------------------------------------------------
.text$mn:000017B9                 align 4
.text$mn:000017B9 _text$mn        ends
.text$mn:000017B9
.text$mn:000017BC ; ===========================================================================
.text$mn:000017BC
.text$mn:000017BC ; Segment type: Pure code
.text$mn:000017BC ; Segment permissions: Read/Execute
.text$mn:000017BC _text$mn        segment para public 'CODE' use32
.text$mn:000017BC                 assume cs:_text$mn
.text$mn:000017BC                 ;org 17BCh
.text$mn:000017BC ; COMDAT (pick any)
.text$mn:000017BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017BC
.text$mn:000017BC ; =============== S U B R O U T I N E =======================================
.text$mn:000017BC
.text$mn:000017BC ; Attributes: bp-based frame
.text$mn:000017BC
.text$mn:000017BC ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000017BC                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000017BC ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000017BC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000017BC                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000017BC
.text$mn:000017BC arg_0           = dword ptr  8
.text$mn:000017BC
.text$mn:000017BC                 push    ebp
.text$mn:000017BD                 mov     ebp, esp
.text$mn:000017BF                 mov     eax, [ebp+arg_0]
.text$mn:000017C2                 pop     ebp
.text$mn:000017C3                 retn
.text$mn:000017C3 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000017C3
.text$mn:000017C3 _text$mn        ends
.text$mn:000017C3
.text$mn:000017C4 ; ===========================================================================
.text$mn:000017C4
.text$mn:000017C4 ; Segment type: Pure code
.text$mn:000017C4 ; Segment permissions: Read/Execute
.text$mn:000017C4 _text$mn        segment para public 'CODE' use32
.text$mn:000017C4                 assume cs:_text$mn
.text$mn:000017C4                 ;org 17C4h
.text$mn:000017C4 ; COMDAT (pick any)
.text$mn:000017C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017C4
.text$mn:000017C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000017C4
.text$mn:000017C4 ; Attributes: bp-based frame
.text$mn:000017C4
.text$mn:000017C4 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000017C4                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:000017C4 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:000017C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:000017C4                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:000017C4
.text$mn:000017C4 arg_0           = dword ptr  8
.text$mn:000017C4
.text$mn:000017C4                 push    ebp
.text$mn:000017C5                 mov     ebp, esp
.text$mn:000017C7                 mov     eax, [ebp+arg_0]
.text$mn:000017CA                 pop     ebp
.text$mn:000017CB                 retn
.text$mn:000017CB ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:000017CB
.text$mn:000017CB _text$mn        ends
.text$mn:000017CB
.text$mn:000017CC ; ===========================================================================
.text$mn:000017CC
.text$mn:000017CC ; Segment type: Pure code
.text$mn:000017CC ; Segment permissions: Read/Execute
.text$mn:000017CC _text$mn        segment para public 'CODE' use32
.text$mn:000017CC                 assume cs:_text$mn
.text$mn:000017CC                 ;org 17CCh
.text$mn:000017CC ; COMDAT (pick any)
.text$mn:000017CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017CC
.text$mn:000017CC ; =============== S U B R O U T I N E =======================================
.text$mn:000017CC
.text$mn:000017CC ; Attributes: bp-based frame
.text$mn:000017CC
.text$mn:000017CC ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000017CC                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000017CC ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000017CC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000017CC
.text$mn:000017CC arg_0           = dword ptr  8
.text$mn:000017CC
.text$mn:000017CC                 push    ebp
.text$mn:000017CD                 mov     ebp, esp
.text$mn:000017CF                 mov     eax, [ebp+arg_0]
.text$mn:000017D2                 pop     ebp
.text$mn:000017D3                 retn
.text$mn:000017D3 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000017D3
.text$mn:000017D3 _text$mn        ends
.text$mn:000017D3
.text$mn:000017D4 ; ===========================================================================
.text$mn:000017D4
.text$mn:000017D4 ; Segment type: Pure code
.text$mn:000017D4 ; Segment permissions: Read/Execute
.text$mn:000017D4 _text$mn        segment para public 'CODE' use32
.text$mn:000017D4                 assume cs:_text$mn
.text$mn:000017D4                 ;org 17D4h
.text$mn:000017D4 ; COMDAT (pick any)
.text$mn:000017D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017D4
.text$mn:000017D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000017D4
.text$mn:000017D4 ; Attributes: bp-based frame
.text$mn:000017D4
.text$mn:000017D4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000017D4                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000017D4 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000017D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000017D4
.text$mn:000017D4 var_10          = dword ptr -10h
.text$mn:000017D4 var_C           = dword ptr -0Ch
.text$mn:000017D4 var_4           = dword ptr -4
.text$mn:000017D4
.text$mn:000017D4                 push    ebp
.text$mn:000017D5                 mov     ebp, esp
.text$mn:000017D7                 push    0FFFFFFFFh
.text$mn:000017D9                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000017DE                 mov     eax, large fs:0
.text$mn:000017E4                 push    eax
.text$mn:000017E5                 push    ecx
.text$mn:000017E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017EB                 xor     eax, ebp
.text$mn:000017ED                 push    eax
.text$mn:000017EE                 lea     eax, [ebp+var_C]
.text$mn:000017F1                 mov     large fs:0, eax
.text$mn:000017F7                 mov     [ebp+var_10], ecx
.text$mn:000017FA                 mov     ecx, [ebp+var_10]
.text$mn:000017FD                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00001802                 mov     [ebp+var_4], 0
.text$mn:00001809                 mov     ecx, [ebp+var_10]
.text$mn:0000180C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001811                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001818                 mov     eax, [ebp+var_10]
.text$mn:0000181B                 mov     ecx, [ebp+var_C]
.text$mn:0000181E                 mov     large fs:0, ecx
.text$mn:00001825                 pop     ecx
.text$mn:00001826                 mov     esp, ebp
.text$mn:00001828                 pop     ebp
.text$mn:00001829                 retn    4
.text$mn:00001829 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00001829
.text$mn:00001829 _text$mn        ends
.text$mn:00001829
.text$x:0000182C ; ===========================================================================
.text$x:0000182C
.text$x:0000182C ; Segment type: Pure code
.text$x:0000182C ; Segment permissions: Read/Execute
.text$x:0000182C _text$x         segment para public 'CODE' use32
.text$x:0000182C                 assume cs:_text$x
.text$x:0000182C                 ;org 182Ch
.text$x:0000182C ; COMDAT (pick associative to section at 17D4)
.text$x:0000182C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000182C
.text$x:0000182C ; =============== S U B R O U T I N E =======================================
.text$x:0000182C
.text$x:0000182C
.text$x:0000182C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:0000182C                                         ; DATA XREF: .xdata$x:00003EB0o
.text$x:0000182C                 mov     ecx, [ebp-10h]
.text$x:0000182F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000182F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:0000182F
.text$x:00001834
.text$x:00001834 ; =============== S U B R O U T I N E =======================================
.text$x:00001834
.text$x:00001834
.text$x:00001834 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00001834                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00001834
.text$x:00001834 arg_4           = dword ptr  8
.text$x:00001834
.text$x:00001834                 mov     edx, [esp+arg_4]
.text$x:00001838                 lea     eax, [edx+0Ch]
.text$x:0000183B                 mov     ecx, [edx-8]
.text$x:0000183E                 xor     ecx, eax
.text$x:00001840                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001845                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000184A                 jmp     ___CxxFrameHandler3
.text$x:0000184A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000184A
.text$x:0000184A ; ---------------------------------------------------------------------------
.text$x:0000184F                 align 10h
.text$x:0000184F _text$x         ends
.text$x:0000184F
.text$mn:00001850 ; ===========================================================================
.text$mn:00001850
.text$mn:00001850 ; Segment type: Pure code
.text$mn:00001850 ; Segment permissions: Read/Execute
.text$mn:00001850 _text$mn        segment para public 'CODE' use32
.text$mn:00001850                 assume cs:_text$mn
.text$mn:00001850                 ;org 1850h
.text$mn:00001850 ; COMDAT (pick any)
.text$mn:00001850                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001850
.text$mn:00001850 ; =============== S U B R O U T I N E =======================================
.text$mn:00001850
.text$mn:00001850 ; Attributes: bp-based frame
.text$mn:00001850
.text$mn:00001850 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00001850                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00001850 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00001850                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:00001850                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p
.text$mn:00001850
.text$mn:00001850 var_10          = dword ptr -10h
.text$mn:00001850 var_C           = dword ptr -0Ch
.text$mn:00001850 var_4           = dword ptr -4
.text$mn:00001850
.text$mn:00001850                 push    ebp
.text$mn:00001851                 mov     ebp, esp
.text$mn:00001853                 push    0FFFFFFFFh
.text$mn:00001855                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000185A                 mov     eax, large fs:0
.text$mn:00001860                 push    eax
.text$mn:00001861                 push    ecx
.text$mn:00001862                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001867                 xor     eax, ebp
.text$mn:00001869                 push    eax
.text$mn:0000186A                 lea     eax, [ebp+var_C]
.text$mn:0000186D                 mov     large fs:0, eax
.text$mn:00001873                 mov     [ebp+var_10], ecx
.text$mn:00001876                 mov     ecx, [ebp+var_10]
.text$mn:00001879                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:0000187E                 mov     [ebp+var_4], 0
.text$mn:00001885                 mov     ecx, [ebp+var_10]
.text$mn:00001888                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:0000188D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001894                 mov     eax, [ebp+var_10]
.text$mn:00001897                 mov     ecx, [ebp+var_C]
.text$mn:0000189A                 mov     large fs:0, ecx
.text$mn:000018A1                 pop     ecx
.text$mn:000018A2                 mov     esp, ebp
.text$mn:000018A4                 pop     ebp
.text$mn:000018A5                 retn    4
.text$mn:000018A5 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:000018A5
.text$mn:000018A5 _text$mn        ends
.text$mn:000018A5
.text$x:000018A8 ; ===========================================================================
.text$x:000018A8
.text$x:000018A8 ; Segment type: Pure code
.text$x:000018A8 ; Segment permissions: Read/Execute
.text$x:000018A8 _text$x         segment para public 'CODE' use32
.text$x:000018A8                 assume cs:_text$x
.text$x:000018A8                 ;org 18A8h
.text$x:000018A8 ; COMDAT (pick associative to section at 1850)
.text$x:000018A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000018A8
.text$x:000018A8 ; =============== S U B R O U T I N E =======================================
.text$x:000018A8
.text$x:000018A8
.text$x:000018A8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:000018A8                                         ; DATA XREF: .xdata$x:000041D0o
.text$x:000018A8                 mov     ecx, [ebp-10h]
.text$x:000018AB                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000018AB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:000018AB
.text$x:000018B0
.text$x:000018B0 ; =============== S U B R O U T I N E =======================================
.text$x:000018B0
.text$x:000018B0
.text$x:000018B0 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:000018B0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:000018B0
.text$x:000018B0 arg_4           = dword ptr  8
.text$x:000018B0
.text$x:000018B0                 mov     edx, [esp+arg_4]
.text$x:000018B4                 lea     eax, [edx+0Ch]
.text$x:000018B7                 mov     ecx, [edx-8]
.text$x:000018BA                 xor     ecx, eax
.text$x:000018BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018C1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:000018C6                 jmp     ___CxxFrameHandler3
.text$x:000018C6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:000018C6
.text$x:000018C6 ; ---------------------------------------------------------------------------
.text$x:000018CB                 align 4
.text$x:000018CB _text$x         ends
.text$x:000018CB
.text$mn:000018CC ; ===========================================================================
.text$mn:000018CC
.text$mn:000018CC ; Segment type: Pure code
.text$mn:000018CC ; Segment permissions: Read/Execute
.text$mn:000018CC _text$mn        segment para public 'CODE' use32
.text$mn:000018CC                 assume cs:_text$mn
.text$mn:000018CC                 ;org 18CCh
.text$mn:000018CC ; COMDAT (pick any)
.text$mn:000018CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018CC
.text$mn:000018CC ; =============== S U B R O U T I N E =======================================
.text$mn:000018CC
.text$mn:000018CC ; Attributes: bp-based frame
.text$mn:000018CC
.text$mn:000018CC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000018CC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000018CC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000018CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000018CC
.text$mn:000018CC var_10          = dword ptr -10h
.text$mn:000018CC var_C           = dword ptr -0Ch
.text$mn:000018CC var_4           = dword ptr -4
.text$mn:000018CC
.text$mn:000018CC                 push    ebp
.text$mn:000018CD                 mov     ebp, esp
.text$mn:000018CF                 push    0FFFFFFFFh
.text$mn:000018D1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000018D6                 mov     eax, large fs:0
.text$mn:000018DC                 push    eax
.text$mn:000018DD                 push    ecx
.text$mn:000018DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018E3                 xor     eax, ebp
.text$mn:000018E5                 push    eax
.text$mn:000018E6                 lea     eax, [ebp+var_C]
.text$mn:000018E9                 mov     large fs:0, eax
.text$mn:000018EF                 mov     [ebp+var_10], ecx
.text$mn:000018F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000018F5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000018FA                 mov     [ebp+var_4], 0
.text$mn:00001901                 mov     eax, [ebp+var_10]
.text$mn:00001904                 mov     dword ptr [eax+14h], 0
.text$mn:0000190B                 mov     ecx, [ebp+var_10]
.text$mn:0000190E                 mov     dword ptr [ecx+18h], 0
.text$mn:00001915                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000191C                 mov     eax, [ebp+var_10]
.text$mn:0000191F                 mov     ecx, [ebp+var_C]
.text$mn:00001922                 mov     large fs:0, ecx
.text$mn:00001929                 pop     ecx
.text$mn:0000192A                 mov     esp, ebp
.text$mn:0000192C                 pop     ebp
.text$mn:0000192D                 retn
.text$mn:0000192D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000192D
.text$mn:0000192D ; ---------------------------------------------------------------------------
.text$mn:0000192E                 align 10h
.text$mn:0000192E _text$mn        ends
.text$mn:0000192E
.text$x:00001930 ; ===========================================================================
.text$x:00001930
.text$x:00001930 ; Segment type: Pure code
.text$x:00001930 ; Segment permissions: Read/Execute
.text$x:00001930 _text$x         segment para public 'CODE' use32
.text$x:00001930                 assume cs:_text$x
.text$x:00001930                 ;org 1930h
.text$x:00001930 ; COMDAT (pick associative to section at 18CC)
.text$x:00001930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001930
.text$x:00001930 ; =============== S U B R O U T I N E =======================================
.text$x:00001930
.text$x:00001930
.text$x:00001930 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001930                                         ; DATA XREF: .xdata$x:00003E58o
.text$x:00001930                 mov     ecx, [ebp-10h]  ; this
.text$x:00001933                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001933 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001933
.text$x:00001938
.text$x:00001938 ; =============== S U B R O U T I N E =======================================
.text$x:00001938
.text$x:00001938
.text$x:00001938 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001938                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001938
.text$x:00001938 arg_4           = dword ptr  8
.text$x:00001938
.text$x:00001938                 mov     edx, [esp+arg_4]
.text$x:0000193C                 lea     eax, [edx+0Ch]
.text$x:0000193F                 mov     ecx, [edx-8]
.text$x:00001942                 xor     ecx, eax
.text$x:00001944                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001949                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000194E                 jmp     ___CxxFrameHandler3
.text$x:0000194E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000194E
.text$x:0000194E ; ---------------------------------------------------------------------------
.text$x:00001953                 align 4
.text$x:00001953 _text$x         ends
.text$x:00001953
.text$mn:00001954 ; ===========================================================================
.text$mn:00001954
.text$mn:00001954 ; Segment type: Pure code
.text$mn:00001954 ; Segment permissions: Read/Execute
.text$mn:00001954 _text$mn        segment para public 'CODE' use32
.text$mn:00001954                 assume cs:_text$mn
.text$mn:00001954                 ;org 1954h
.text$mn:00001954 ; COMDAT (pick any)
.text$mn:00001954                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001954
.text$mn:00001954 ; =============== S U B R O U T I N E =======================================
.text$mn:00001954
.text$mn:00001954 ; Attributes: bp-based frame
.text$mn:00001954
.text$mn:00001954 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00001954                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001954 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00001954                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00001954
.text$mn:00001954 var_10          = dword ptr -10h
.text$mn:00001954 var_C           = dword ptr -0Ch
.text$mn:00001954 var_4           = dword ptr -4
.text$mn:00001954
.text$mn:00001954                 push    ebp
.text$mn:00001955                 mov     ebp, esp
.text$mn:00001957                 push    0FFFFFFFFh
.text$mn:00001959                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000195E                 mov     eax, large fs:0
.text$mn:00001964                 push    eax
.text$mn:00001965                 push    ecx
.text$mn:00001966                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000196B                 xor     eax, ebp
.text$mn:0000196D                 push    eax
.text$mn:0000196E                 lea     eax, [ebp+var_C]
.text$mn:00001971                 mov     large fs:0, eax
.text$mn:00001977                 mov     [ebp+var_10], ecx
.text$mn:0000197A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000197D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00001982                 mov     [ebp+var_4], 0
.text$mn:00001989                 mov     eax, [ebp+var_10]
.text$mn:0000198C                 mov     dword ptr [eax+14h], 0
.text$mn:00001993                 mov     ecx, [ebp+var_10]
.text$mn:00001996                 mov     dword ptr [ecx+18h], 0
.text$mn:0000199D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019A4                 mov     eax, [ebp+var_10]
.text$mn:000019A7                 mov     ecx, [ebp+var_C]
.text$mn:000019AA                 mov     large fs:0, ecx
.text$mn:000019B1                 pop     ecx
.text$mn:000019B2                 mov     esp, ebp
.text$mn:000019B4                 pop     ebp
.text$mn:000019B5                 retn
.text$mn:000019B5 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000019B5
.text$mn:000019B5 ; ---------------------------------------------------------------------------
.text$mn:000019B6                 align 4
.text$mn:000019B6 _text$mn        ends
.text$mn:000019B6
.text$x:000019B8 ; ===========================================================================
.text$x:000019B8
.text$x:000019B8 ; Segment type: Pure code
.text$x:000019B8 ; Segment permissions: Read/Execute
.text$x:000019B8 _text$x         segment para public 'CODE' use32
.text$x:000019B8                 assume cs:_text$x
.text$x:000019B8                 ;org 19B8h
.text$x:000019B8 ; COMDAT (pick associative to section at 1954)
.text$x:000019B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000019B8
.text$x:000019B8 ; =============== S U B R O U T I N E =======================================
.text$x:000019B8
.text$x:000019B8
.text$x:000019B8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000019B8                                         ; DATA XREF: .xdata$x:00004178o
.text$x:000019B8                 mov     ecx, [ebp-10h]  ; this
.text$x:000019BB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000019BB __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000019BB
.text$x:000019C0
.text$x:000019C0 ; =============== S U B R O U T I N E =======================================
.text$x:000019C0
.text$x:000019C0
.text$x:000019C0 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:000019C0                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:000019C0
.text$x:000019C0 arg_4           = dword ptr  8
.text$x:000019C0
.text$x:000019C0                 mov     edx, [esp+arg_4]
.text$x:000019C4                 lea     eax, [edx+0Ch]
.text$x:000019C7                 mov     ecx, [edx-8]
.text$x:000019CA                 xor     ecx, eax
.text$x:000019CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019D1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000019D6                 jmp     ___CxxFrameHandler3
.text$x:000019D6 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000019D6
.text$x:000019D6 ; ---------------------------------------------------------------------------
.text$x:000019DB                 align 4
.text$x:000019DB _text$x         ends
.text$x:000019DB
.text$mn:000019DC ; ===========================================================================
.text$mn:000019DC
.text$mn:000019DC ; Segment type: Pure code
.text$mn:000019DC ; Segment permissions: Read/Execute
.text$mn:000019DC _text$mn        segment para public 'CODE' use32
.text$mn:000019DC                 assume cs:_text$mn
.text$mn:000019DC                 ;org 19DCh
.text$mn:000019DC ; COMDAT (pick any)
.text$mn:000019DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019DC
.text$mn:000019DC ; =============== S U B R O U T I N E =======================================
.text$mn:000019DC
.text$mn:000019DC ; Attributes: bp-based frame
.text$mn:000019DC
.text$mn:000019DC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000019DC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000019DC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000019DC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000019DC
.text$mn:000019DC var_4           = dword ptr -4
.text$mn:000019DC
.text$mn:000019DC                 push    ebp
.text$mn:000019DD                 mov     ebp, esp
.text$mn:000019DF                 push    ecx
.text$mn:000019E0                 mov     [ebp+var_4], ecx
.text$mn:000019E3                 mov     ecx, [ebp+var_4]
.text$mn:000019E6                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000019EB                 mov     eax, [ebp+var_4]
.text$mn:000019EE                 mov     esp, ebp
.text$mn:000019F0                 pop     ebp
.text$mn:000019F1                 retn
.text$mn:000019F1 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000019F1
.text$mn:000019F1 ; ---------------------------------------------------------------------------
.text$mn:000019F2                 align 4
.text$mn:000019F2 _text$mn        ends
.text$mn:000019F2
.text$mn:000019F4 ; ===========================================================================
.text$mn:000019F4
.text$mn:000019F4 ; Segment type: Pure code
.text$mn:000019F4 ; Segment permissions: Read/Execute
.text$mn:000019F4 _text$mn        segment para public 'CODE' use32
.text$mn:000019F4                 assume cs:_text$mn
.text$mn:000019F4                 ;org 19F4h
.text$mn:000019F4 ; COMDAT (pick any)
.text$mn:000019F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019F4
.text$mn:000019F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019F4
.text$mn:000019F4 ; Attributes: bp-based frame
.text$mn:000019F4
.text$mn:000019F4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:000019F4                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:000019F4 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:000019F4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:000019F4
.text$mn:000019F4 var_4           = dword ptr -4
.text$mn:000019F4
.text$mn:000019F4                 push    ebp
.text$mn:000019F5                 mov     ebp, esp
.text$mn:000019F7                 push    ecx
.text$mn:000019F8                 mov     [ebp+var_4], ecx
.text$mn:000019FB                 mov     ecx, [ebp+var_4]
.text$mn:000019FE                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00001A03                 mov     eax, [ebp+var_4]
.text$mn:00001A06                 mov     esp, ebp
.text$mn:00001A08                 pop     ebp
.text$mn:00001A09                 retn
.text$mn:00001A09 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00001A09
.text$mn:00001A09 ; ---------------------------------------------------------------------------
.text$mn:00001A0A                 align 4
.text$mn:00001A0A _text$mn        ends
.text$mn:00001A0A
.text$mn:00001A0C ; ===========================================================================
.text$mn:00001A0C
.text$mn:00001A0C ; Segment type: Pure code
.text$mn:00001A0C ; Segment permissions: Read/Execute
.text$mn:00001A0C _text$mn        segment para public 'CODE' use32
.text$mn:00001A0C                 assume cs:_text$mn
.text$mn:00001A0C                 ;org 1A0Ch
.text$mn:00001A0C ; COMDAT (pick any)
.text$mn:00001A0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A0C
.text$mn:00001A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A0C
.text$mn:00001A0C ; Attributes: bp-based frame
.text$mn:00001A0C
.text$mn:00001A0C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00001A0C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00001A0C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00001A0C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00001A0C
.text$mn:00001A0C var_4           = dword ptr -4
.text$mn:00001A0C
.text$mn:00001A0C                 push    ebp
.text$mn:00001A0D                 mov     ebp, esp
.text$mn:00001A0F                 push    ecx
.text$mn:00001A10                 mov     [ebp+var_4], ecx
.text$mn:00001A13                 mov     eax, [ebp+var_4]
.text$mn:00001A16                 mov     esp, ebp
.text$mn:00001A18                 pop     ebp
.text$mn:00001A19                 retn
.text$mn:00001A19 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00001A19
.text$mn:00001A19 ; ---------------------------------------------------------------------------
.text$mn:00001A1A                 align 4
.text$mn:00001A1A _text$mn        ends
.text$mn:00001A1A
.text$mn:00001A1C ; ===========================================================================
.text$mn:00001A1C
.text$mn:00001A1C ; Segment type: Pure code
.text$mn:00001A1C ; Segment permissions: Read/Execute
.text$mn:00001A1C _text$mn        segment para public 'CODE' use32
.text$mn:00001A1C                 assume cs:_text$mn
.text$mn:00001A1C                 ;org 1A1Ch
.text$mn:00001A1C ; COMDAT (pick any)
.text$mn:00001A1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A1C
.text$mn:00001A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A1C
.text$mn:00001A1C ; Attributes: bp-based frame
.text$mn:00001A1C
.text$mn:00001A1C ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00001A1C                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00001A1C ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00001A1C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00001A1C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00001A1C
.text$mn:00001A1C var_4           = dword ptr -4
.text$mn:00001A1C
.text$mn:00001A1C                 push    ebp
.text$mn:00001A1D                 mov     ebp, esp
.text$mn:00001A1F                 push    ecx
.text$mn:00001A20                 mov     [ebp+var_4], ecx
.text$mn:00001A23                 mov     eax, [ebp+var_4]
.text$mn:00001A26                 mov     esp, ebp
.text$mn:00001A28                 pop     ebp
.text$mn:00001A29                 retn
.text$mn:00001A29 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00001A29
.text$mn:00001A29 ; ---------------------------------------------------------------------------
.text$mn:00001A2A                 align 4
.text$mn:00001A2A _text$mn        ends
.text$mn:00001A2A
.text$mn:00001A2C ; ===========================================================================
.text$mn:00001A2C
.text$mn:00001A2C ; Segment type: Pure code
.text$mn:00001A2C ; Segment permissions: Read/Execute
.text$mn:00001A2C _text$mn        segment para public 'CODE' use32
.text$mn:00001A2C                 assume cs:_text$mn
.text$mn:00001A2C                 ;org 1A2Ch
.text$mn:00001A2C ; COMDAT (pick any)
.text$mn:00001A2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A2C
.text$mn:00001A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A2C
.text$mn:00001A2C ; Attributes: bp-based frame
.text$mn:00001A2C
.text$mn:00001A2C ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00001A2C                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00001A2C ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00001A2C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:00001A2C
.text$mn:00001A2C var_4           = dword ptr -4
.text$mn:00001A2C
.text$mn:00001A2C                 push    ebp
.text$mn:00001A2D                 mov     ebp, esp
.text$mn:00001A2F                 push    ecx
.text$mn:00001A30                 mov     [ebp+var_4], ecx
.text$mn:00001A33                 mov     eax, [ebp+var_4]
.text$mn:00001A36                 mov     esp, ebp
.text$mn:00001A38                 pop     ebp
.text$mn:00001A39                 retn
.text$mn:00001A39 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00001A39
.text$mn:00001A39 ; ---------------------------------------------------------------------------
.text$mn:00001A3A                 align 4
.text$mn:00001A3A _text$mn        ends
.text$mn:00001A3A
.text$mn:00001A3C ; ===========================================================================
.text$mn:00001A3C
.text$mn:00001A3C ; Segment type: Pure code
.text$mn:00001A3C ; Segment permissions: Read/Execute
.text$mn:00001A3C _text$mn        segment para public 'CODE' use32
.text$mn:00001A3C                 assume cs:_text$mn
.text$mn:00001A3C                 ;org 1A3Ch
.text$mn:00001A3C ; COMDAT (pick any)
.text$mn:00001A3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A3C
.text$mn:00001A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A3C
.text$mn:00001A3C ; Attributes: bp-based frame
.text$mn:00001A3C
.text$mn:00001A3C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00001A3C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001A3C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00001A3C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00001A3C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00001A3C
.text$mn:00001A3C var_14          = dword ptr -14h
.text$mn:00001A3C var_D           = byte ptr -0Dh
.text$mn:00001A3C var_C           = dword ptr -0Ch
.text$mn:00001A3C var_4           = dword ptr -4
.text$mn:00001A3C Str             = dword ptr  8
.text$mn:00001A3C
.text$mn:00001A3C                 push    ebp
.text$mn:00001A3D                 mov     ebp, esp
.text$mn:00001A3F                 push    0FFFFFFFFh
.text$mn:00001A41                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001A46                 mov     eax, large fs:0
.text$mn:00001A4C                 push    eax
.text$mn:00001A4D                 sub     esp, 8
.text$mn:00001A50                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A55                 xor     eax, ebp
.text$mn:00001A57                 push    eax
.text$mn:00001A58                 lea     eax, [ebp+var_C]
.text$mn:00001A5B                 mov     large fs:0, eax
.text$mn:00001A61                 mov     [ebp+var_14], ecx
.text$mn:00001A64                 lea     ecx, [ebp+var_D]
.text$mn:00001A67                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001A6C                 push    eax
.text$mn:00001A6D                 mov     ecx, [ebp+var_14]
.text$mn:00001A70                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00001A75                 mov     [ebp+var_4], 0
.text$mn:00001A7C                 push    0               ; Size
.text$mn:00001A7E                 push    0               ; char
.text$mn:00001A80                 mov     ecx, [ebp+var_14]
.text$mn:00001A83                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001A88                 mov     eax, [ebp+Str]
.text$mn:00001A8B                 push    eax             ; Str
.text$mn:00001A8C                 mov     ecx, [ebp+var_14]
.text$mn:00001A8F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00001A94                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A9B                 mov     eax, [ebp+var_14]
.text$mn:00001A9E                 mov     ecx, [ebp+var_C]
.text$mn:00001AA1                 mov     large fs:0, ecx
.text$mn:00001AA8                 pop     ecx
.text$mn:00001AA9                 mov     esp, ebp
.text$mn:00001AAB                 pop     ebp
.text$mn:00001AAC                 retn    4
.text$mn:00001AAC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00001AAC
.text$mn:00001AAC ; ---------------------------------------------------------------------------
.text$mn:00001AAF                 align 10h
.text$mn:00001AAF _text$mn        ends
.text$mn:00001AAF
.text$x:00001AB0 ; ===========================================================================
.text$x:00001AB0
.text$x:00001AB0 ; Segment type: Pure code
.text$x:00001AB0 ; Segment permissions: Read/Execute
.text$x:00001AB0 _text$x         segment para public 'CODE' use32
.text$x:00001AB0                 assume cs:_text$x
.text$x:00001AB0                 ;org 1AB0h
.text$x:00001AB0 ; COMDAT (pick associative to section at 1A3C)
.text$x:00001AB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001AB0
.text$x:00001AB0 ; =============== S U B R O U T I N E =======================================
.text$x:00001AB0
.text$x:00001AB0
.text$x:00001AB0 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001AB0                                         ; DATA XREF: .xdata$x:00003F08o
.text$x:00001AB0                 mov     ecx, [ebp-14h]
.text$x:00001AB3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001AB3 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00001AB3
.text$x:00001AB8
.text$x:00001AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00001AB8
.text$x:00001AB8
.text$x:00001AB8 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00001AB8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00001AB8
.text$x:00001AB8 arg_4           = dword ptr  8
.text$x:00001AB8
.text$x:00001AB8                 mov     edx, [esp+arg_4]
.text$x:00001ABC                 lea     eax, [edx+0Ch]
.text$x:00001ABF                 mov     ecx, [edx-0Ch]
.text$x:00001AC2                 xor     ecx, eax
.text$x:00001AC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AC9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00001ACE                 jmp     ___CxxFrameHandler3
.text$x:00001ACE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00001ACE
.text$x:00001ACE ; ---------------------------------------------------------------------------
.text$x:00001AD3                 align 4
.text$x:00001AD3 _text$x         ends
.text$x:00001AD3
.text$mn:00001AD4 ; ===========================================================================
.text$mn:00001AD4
.text$mn:00001AD4 ; Segment type: Pure code
.text$mn:00001AD4 ; Segment permissions: Read/Execute
.text$mn:00001AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AD4                 assume cs:_text$mn
.text$mn:00001AD4                 ;org 1AD4h
.text$mn:00001AD4 ; COMDAT (pick any)
.text$mn:00001AD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AD4
.text$mn:00001AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AD4
.text$mn:00001AD4 ; Attributes: bp-based frame
.text$mn:00001AD4
.text$mn:00001AD4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:00001AD4                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00001AD4 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:00001AD4                                         ; CODE XREF: FindOption::FindOption(void)+96p
.text$mn:00001AD4                                         ; FindOption::FindOption(void)+AAp
.text$mn:00001AD4
.text$mn:00001AD4 var_14          = dword ptr -14h
.text$mn:00001AD4 var_D           = byte ptr -0Dh
.text$mn:00001AD4 var_C           = dword ptr -0Ch
.text$mn:00001AD4 var_4           = dword ptr -4
.text$mn:00001AD4 Str             = dword ptr  8
.text$mn:00001AD4
.text$mn:00001AD4                 push    ebp
.text$mn:00001AD5                 mov     ebp, esp
.text$mn:00001AD7                 push    0FFFFFFFFh
.text$mn:00001AD9                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00001ADE                 mov     eax, large fs:0
.text$mn:00001AE4                 push    eax
.text$mn:00001AE5                 sub     esp, 8
.text$mn:00001AE8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AED                 xor     eax, ebp
.text$mn:00001AEF                 push    eax
.text$mn:00001AF0                 lea     eax, [ebp+var_C]
.text$mn:00001AF3                 mov     large fs:0, eax
.text$mn:00001AF9                 mov     [ebp+var_14], ecx
.text$mn:00001AFC                 lea     ecx, [ebp+var_D]
.text$mn:00001AFF                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00001B04                 push    eax
.text$mn:00001B05                 mov     ecx, [ebp+var_14]
.text$mn:00001B08                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00001B0D                 mov     [ebp+var_4], 0
.text$mn:00001B14                 push    0
.text$mn:00001B16                 push    0
.text$mn:00001B18                 mov     ecx, [ebp+var_14]
.text$mn:00001B1B                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001B20                 mov     eax, [ebp+Str]
.text$mn:00001B23                 push    eax             ; Str
.text$mn:00001B24                 mov     ecx, [ebp+var_14]
.text$mn:00001B27                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00001B2C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B33                 mov     eax, [ebp+var_14]
.text$mn:00001B36                 mov     ecx, [ebp+var_C]
.text$mn:00001B39                 mov     large fs:0, ecx
.text$mn:00001B40                 pop     ecx
.text$mn:00001B41                 mov     esp, ebp
.text$mn:00001B43                 pop     ebp
.text$mn:00001B44                 retn    4
.text$mn:00001B44 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00001B44
.text$mn:00001B44 ; ---------------------------------------------------------------------------
.text$mn:00001B47                 align 4
.text$mn:00001B47 _text$mn        ends
.text$mn:00001B47
.text$x:00001B48 ; ===========================================================================
.text$x:00001B48
.text$x:00001B48 ; Segment type: Pure code
.text$x:00001B48 ; Segment permissions: Read/Execute
.text$x:00001B48 _text$x         segment para public 'CODE' use32
.text$x:00001B48                 assume cs:_text$x
.text$x:00001B48                 ;org 1B48h
.text$x:00001B48 ; COMDAT (pick associative to section at 1AD4)
.text$x:00001B48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001B48
.text$x:00001B48 ; =============== S U B R O U T I N E =======================================
.text$x:00001B48
.text$x:00001B48
.text$x:00001B48 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00001B48                                         ; DATA XREF: .xdata$x:00004254o
.text$x:00001B48                 mov     ecx, [ebp-14h]
.text$x:00001B4B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00001B4B __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00001B4B
.text$x:00001B50
.text$x:00001B50 ; =============== S U B R O U T I N E =======================================
.text$x:00001B50
.text$x:00001B50
.text$x:00001B50 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00001B50                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00001B50
.text$x:00001B50 arg_4           = dword ptr  8
.text$x:00001B50
.text$x:00001B50                 mov     edx, [esp+arg_4]
.text$x:00001B54                 lea     eax, [edx+0Ch]
.text$x:00001B57                 mov     ecx, [edx-0Ch]
.text$x:00001B5A                 xor     ecx, eax
.text$x:00001B5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B61                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00001B66                 jmp     ___CxxFrameHandler3
.text$x:00001B66 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00001B66
.text$x:00001B66 ; ---------------------------------------------------------------------------
.text$x:00001B6B                 align 4
.text$x:00001B6B _text$x         ends
.text$x:00001B6B
.text$mn:00001B6C ; ===========================================================================
.text$mn:00001B6C
.text$mn:00001B6C ; Segment type: Pure code
.text$mn:00001B6C ; Segment permissions: Read/Execute
.text$mn:00001B6C _text$mn        segment para public 'CODE' use32
.text$mn:00001B6C                 assume cs:_text$mn
.text$mn:00001B6C                 ;org 1B6Ch
.text$mn:00001B6C ; COMDAT (pick any)
.text$mn:00001B6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B6C
.text$mn:00001B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B6C
.text$mn:00001B6C ; Attributes: bp-based frame
.text$mn:00001B6C
.text$mn:00001B6C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00001B6C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001B6C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00001B6C                                         ; CODE XREF: FindOption::FindOption(void)+70p
.text$mn:00001B6C                                         ; FindOption::FindOption(void)+82p
.text$mn:00001B6C
.text$mn:00001B6C var_14          = dword ptr -14h
.text$mn:00001B6C var_D           = byte ptr -0Dh
.text$mn:00001B6C var_C           = dword ptr -0Ch
.text$mn:00001B6C var_4           = dword ptr -4
.text$mn:00001B6C
.text$mn:00001B6C                 push    ebp
.text$mn:00001B6D                 mov     ebp, esp
.text$mn:00001B6F                 push    0FFFFFFFFh
.text$mn:00001B71                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001B76                 mov     eax, large fs:0
.text$mn:00001B7C                 push    eax
.text$mn:00001B7D                 sub     esp, 8
.text$mn:00001B80                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B85                 xor     eax, ebp
.text$mn:00001B87                 push    eax
.text$mn:00001B88                 lea     eax, [ebp+var_C]
.text$mn:00001B8B                 mov     large fs:0, eax
.text$mn:00001B91                 mov     [ebp+var_14], ecx
.text$mn:00001B94                 lea     ecx, [ebp+var_D]
.text$mn:00001B97                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00001B9C                 push    eax
.text$mn:00001B9D                 mov     ecx, [ebp+var_14]
.text$mn:00001BA0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00001BA5                 mov     [ebp+var_4], 0
.text$mn:00001BAC                 push    0
.text$mn:00001BAE                 push    0
.text$mn:00001BB0                 mov     ecx, [ebp+var_14]
.text$mn:00001BB3                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001BB8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BBF                 mov     eax, [ebp+var_14]
.text$mn:00001BC2                 mov     ecx, [ebp+var_C]
.text$mn:00001BC5                 mov     large fs:0, ecx
.text$mn:00001BCC                 pop     ecx
.text$mn:00001BCD                 mov     esp, ebp
.text$mn:00001BCF                 pop     ebp
.text$mn:00001BD0                 retn
.text$mn:00001BD0 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00001BD0
.text$mn:00001BD0 ; ---------------------------------------------------------------------------
.text$mn:00001BD1                 align 4
.text$mn:00001BD1 _text$mn        ends
.text$mn:00001BD1
.text$x:00001BD4 ; ===========================================================================
.text$x:00001BD4
.text$x:00001BD4 ; Segment type: Pure code
.text$x:00001BD4 ; Segment permissions: Read/Execute
.text$x:00001BD4 _text$x         segment para public 'CODE' use32
.text$x:00001BD4                 assume cs:_text$x
.text$x:00001BD4                 ;org 1BD4h
.text$x:00001BD4 ; COMDAT (pick associative to section at 1B6C)
.text$x:00001BD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001BD4
.text$x:00001BD4 ; =============== S U B R O U T I N E =======================================
.text$x:00001BD4
.text$x:00001BD4
.text$x:00001BD4 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00001BD4                                         ; DATA XREF: .xdata$x:00004228o
.text$x:00001BD4                 mov     ecx, [ebp-14h]
.text$x:00001BD7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00001BD7 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00001BD7
.text$x:00001BDC
.text$x:00001BDC ; =============== S U B R O U T I N E =======================================
.text$x:00001BDC
.text$x:00001BDC
.text$x:00001BDC __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00001BDC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00001BDC
.text$x:00001BDC arg_4           = dword ptr  8
.text$x:00001BDC
.text$x:00001BDC                 mov     edx, [esp+arg_4]
.text$x:00001BE0                 lea     eax, [edx+0Ch]
.text$x:00001BE3                 mov     ecx, [edx-0Ch]
.text$x:00001BE6                 xor     ecx, eax
.text$x:00001BE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BED                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00001BF2                 jmp     ___CxxFrameHandler3
.text$x:00001BF2 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00001BF2
.text$x:00001BF2 ; ---------------------------------------------------------------------------
.text$x:00001BF7                 align 4
.text$x:00001BF7 _text$x         ends
.text$x:00001BF7
.text$mn:00001BF8 ; ===========================================================================
.text$mn:00001BF8
.text$mn:00001BF8 ; Segment type: Pure code
.text$mn:00001BF8 ; Segment permissions: Read/Execute
.text$mn:00001BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BF8                 assume cs:_text$mn
.text$mn:00001BF8                 ;org 1BF8h
.text$mn:00001BF8 ; COMDAT (pick any)
.text$mn:00001BF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BF8
.text$mn:00001BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BF8
.text$mn:00001BF8 ; Attributes: bp-based frame
.text$mn:00001BF8
.text$mn:00001BF8 ; public: __thiscall FindOption::FindOption(void)
.text$mn:00001BF8                 public ??0FindOption@@QAE@XZ
.text$mn:00001BF8 ??0FindOption@@QAE@XZ proc near         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+278p
.text$mn:00001BF8
.text$mn:00001BF8 var_10          = dword ptr -10h
.text$mn:00001BF8 var_C           = dword ptr -0Ch
.text$mn:00001BF8 var_4           = dword ptr -4
.text$mn:00001BF8
.text$mn:00001BF8                 push    ebp
.text$mn:00001BF9                 mov     ebp, esp
.text$mn:00001BFB                 push    0FFFFFFFFh
.text$mn:00001BFD                 push    offset __ehhandler$??0FindOption@@QAE@XZ
.text$mn:00001C02                 mov     eax, large fs:0
.text$mn:00001C08                 push    eax
.text$mn:00001C09                 push    ecx
.text$mn:00001C0A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C0F                 xor     eax, ebp
.text$mn:00001C11                 push    eax
.text$mn:00001C12                 lea     eax, [ebp+var_C]
.text$mn:00001C15                 mov     large fs:0, eax
.text$mn:00001C1B                 mov     [ebp+var_10], ecx
.text$mn:00001C1E                 mov     eax, [ebp+var_10]
.text$mn:00001C21                 mov     byte ptr [eax], 1
.text$mn:00001C24                 mov     ecx, [ebp+var_10]
.text$mn:00001C27                 mov     byte ptr [ecx+1], 1
.text$mn:00001C2B                 mov     edx, [ebp+var_10]
.text$mn:00001C2E                 mov     byte ptr [edx+2], 1
.text$mn:00001C32                 mov     eax, [ebp+var_10]
.text$mn:00001C35                 mov     byte ptr [eax+3], 1
.text$mn:00001C39                 mov     ecx, [ebp+var_10]
.text$mn:00001C3C                 mov     dword ptr [ecx+4], 0
.text$mn:00001C43                 mov     edx, [ebp+var_10]
.text$mn:00001C46                 mov     dword ptr [edx+8], 0
.text$mn:00001C4D                 mov     eax, [ebp+var_10]
.text$mn:00001C50                 mov     byte ptr [eax+0Ch], 0
.text$mn:00001C54                 mov     ecx, [ebp+var_10]
.text$mn:00001C57                 mov     byte ptr [ecx+0Dh], 0
.text$mn:00001C5B                 mov     edx, [ebp+var_10]
.text$mn:00001C5E                 mov     byte ptr [edx+0Eh], 0
.text$mn:00001C62                 mov     ecx, [ebp+var_10]
.text$mn:00001C65                 add     ecx, 10h
.text$mn:00001C68                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001C6D                 mov     [ebp+var_4], 0
.text$mn:00001C74                 mov     ecx, [ebp+var_10]
.text$mn:00001C77                 add     ecx, 2Ch ; ','
.text$mn:00001C7A                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001C7F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001C83                 push    offset ??_C@_11LOCGONAA@?$AA?$AA@ ; Str
.text$mn:00001C88                 mov     ecx, [ebp+var_10]
.text$mn:00001C8B                 add     ecx, 48h ; 'H'
.text$mn:00001C8E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001C93                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001C97                 push    offset ??_C@_11LOCGONAA@?$AA?$AA@ ; Str
.text$mn:00001C9C                 mov     ecx, [ebp+var_10]
.text$mn:00001C9F                 add     ecx, 64h ; 'd'
.text$mn:00001CA2                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001CA7                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001CAB                 mov     eax, [ebp+var_10]
.text$mn:00001CAE                 mov     byte ptr [eax+80h], 1
.text$mn:00001CB5                 mov     ecx, [ebp+var_10]
.text$mn:00001CB8                 mov     byte ptr [ecx+81h], 0
.text$mn:00001CBF                 mov     edx, [ebp+var_10]
.text$mn:00001CC2                 mov     byte ptr [edx+82h], 0
.text$mn:00001CC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CD0                 mov     eax, [ebp+var_10]
.text$mn:00001CD3                 mov     ecx, [ebp+var_C]
.text$mn:00001CD6                 mov     large fs:0, ecx
.text$mn:00001CDD                 pop     ecx
.text$mn:00001CDE                 mov     esp, ebp
.text$mn:00001CE0                 pop     ebp
.text$mn:00001CE1                 retn
.text$mn:00001CE1 ??0FindOption@@QAE@XZ endp
.text$mn:00001CE1
.text$mn:00001CE1 ; ---------------------------------------------------------------------------
.text$mn:00001CE2                 align 4
.text$mn:00001CE2 _text$mn        ends
.text$mn:00001CE2
.text$x:00001CE4 ; ===========================================================================
.text$x:00001CE4
.text$x:00001CE4 ; Segment type: Pure code
.text$x:00001CE4 ; Segment permissions: Read/Execute
.text$x:00001CE4 _text$x         segment para public 'CODE' use32
.text$x:00001CE4                 assume cs:_text$x
.text$x:00001CE4                 ;org 1CE4h
.text$x:00001CE4 ; COMDAT (pick associative to section at 1BF8)
.text$x:00001CE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001CE4
.text$x:00001CE4 ; =============== S U B R O U T I N E =======================================
.text$x:00001CE4
.text$x:00001CE4
.text$x:00001CE4 __unwindfunclet$??0FindOption@@QAE@XZ$0 proc near
.text$x:00001CE4                                         ; DATA XREF: .xdata$x:00004338o
.text$x:00001CE4                 mov     ecx, [ebp-10h]
.text$x:00001CE7                 add     ecx, 10h
.text$x:00001CEA                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001CEA __unwindfunclet$??0FindOption@@QAE@XZ$0 endp
.text$x:00001CEA
.text$x:00001CEF
.text$x:00001CEF ; =============== S U B R O U T I N E =======================================
.text$x:00001CEF
.text$x:00001CEF
.text$x:00001CEF __unwindfunclet$??0FindOption@@QAE@XZ$1 proc near
.text$x:00001CEF                                         ; DATA XREF: .xdata$x:00004340o
.text$x:00001CEF                 mov     ecx, [ebp-10h]
.text$x:00001CF2                 add     ecx, 2Ch ; ','
.text$x:00001CF5                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001CF5 __unwindfunclet$??0FindOption@@QAE@XZ$1 endp
.text$x:00001CF5
.text$x:00001CFA
.text$x:00001CFA ; =============== S U B R O U T I N E =======================================
.text$x:00001CFA
.text$x:00001CFA
.text$x:00001CFA __unwindfunclet$??0FindOption@@QAE@XZ$2 proc near
.text$x:00001CFA                                         ; DATA XREF: .xdata$x:00004348o
.text$x:00001CFA                 mov     ecx, [ebp-10h]
.text$x:00001CFD                 add     ecx, 48h ; 'H'
.text$x:00001D00                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001D00 __unwindfunclet$??0FindOption@@QAE@XZ$2 endp
.text$x:00001D00
.text$x:00001D05
.text$x:00001D05 ; =============== S U B R O U T I N E =======================================
.text$x:00001D05
.text$x:00001D05
.text$x:00001D05 __unwindfunclet$??0FindOption@@QAE@XZ$3 proc near
.text$x:00001D05                                         ; DATA XREF: .xdata$x:00004350o
.text$x:00001D05                 mov     ecx, [ebp-10h]
.text$x:00001D08                 add     ecx, 64h ; 'd'
.text$x:00001D0B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001D0B __unwindfunclet$??0FindOption@@QAE@XZ$3 endp
.text$x:00001D0B
.text$x:00001D10
.text$x:00001D10 ; =============== S U B R O U T I N E =======================================
.text$x:00001D10
.text$x:00001D10
.text$x:00001D10 __ehhandler$??0FindOption@@QAE@XZ proc near
.text$x:00001D10                                         ; DATA XREF: FindOption::FindOption(void)+5o
.text$x:00001D10
.text$x:00001D10 arg_4           = dword ptr  8
.text$x:00001D10
.text$x:00001D10                 mov     edx, [esp+arg_4]
.text$x:00001D14                 lea     eax, [edx+0Ch]
.text$x:00001D17                 mov     ecx, [edx-8]
.text$x:00001D1A                 xor     ecx, eax
.text$x:00001D1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D21                 mov     eax, offset __ehfuncinfo$??0FindOption@@QAE@XZ
.text$x:00001D26                 jmp     ___CxxFrameHandler3
.text$x:00001D26 __ehhandler$??0FindOption@@QAE@XZ endp
.text$x:00001D26
.text$x:00001D26 ; ---------------------------------------------------------------------------
.text$x:00001D2B                 align 4
.text$x:00001D2B _text$x         ends
.text$x:00001D2B
.text$mn:00001D2C ; ===========================================================================
.text$mn:00001D2C
.text$mn:00001D2C ; Segment type: Pure code
.text$mn:00001D2C ; Segment permissions: Read/Execute
.text$mn:00001D2C _text$mn        segment para public 'CODE' use32
.text$mn:00001D2C                 assume cs:_text$mn
.text$mn:00001D2C                 ;org 1D2Ch
.text$mn:00001D2C ; COMDAT (pick any)
.text$mn:00001D2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D2C
.text$mn:00001D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D2C
.text$mn:00001D2C ; Attributes: bp-based frame
.text$mn:00001D2C
.text$mn:00001D2C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001D2C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001D2C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001D2C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001D2C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p
.text$mn:00001D2C
.text$mn:00001D2C var_4           = dword ptr -4
.text$mn:00001D2C
.text$mn:00001D2C                 push    ebp
.text$mn:00001D2D                 mov     ebp, esp
.text$mn:00001D2F                 push    ecx
.text$mn:00001D30                 mov     [ebp+var_4], ecx
.text$mn:00001D33                 mov     eax, [ebp+var_4]
.text$mn:00001D36                 mov     dword ptr [eax], 0
.text$mn:00001D3C                 mov     eax, [ebp+var_4]
.text$mn:00001D3F                 mov     esp, ebp
.text$mn:00001D41                 pop     ebp
.text$mn:00001D42                 retn
.text$mn:00001D42 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00001D42
.text$mn:00001D42 ; ---------------------------------------------------------------------------
.text$mn:00001D43                 align 4
.text$mn:00001D43 _text$mn        ends
.text$mn:00001D43
.text$mn:00001D44 ; ===========================================================================
.text$mn:00001D44
.text$mn:00001D44 ; Segment type: Pure code
.text$mn:00001D44 ; Segment permissions: Read/Execute
.text$mn:00001D44 _text$mn        segment para public 'CODE' use32
.text$mn:00001D44                 assume cs:_text$mn
.text$mn:00001D44                 ;org 1D44h
.text$mn:00001D44 ; COMDAT (pick any)
.text$mn:00001D44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D44
.text$mn:00001D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D44
.text$mn:00001D44 ; Attributes: bp-based frame
.text$mn:00001D44
.text$mn:00001D44 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00001D44                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00001D44 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00001D44                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00001D44                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p
.text$mn:00001D44
.text$mn:00001D44 var_4           = dword ptr -4
.text$mn:00001D44
.text$mn:00001D44                 push    ebp
.text$mn:00001D45                 mov     ebp, esp
.text$mn:00001D47                 push    ecx
.text$mn:00001D48                 mov     [ebp+var_4], ecx
.text$mn:00001D4B                 mov     eax, [ebp+var_4]
.text$mn:00001D4E                 mov     dword ptr [eax], 0
.text$mn:00001D54                 mov     ecx, [ebp+var_4]
.text$mn:00001D57                 mov     dword ptr [ecx+4], 0
.text$mn:00001D5E                 mov     eax, [ebp+var_4]
.text$mn:00001D61                 mov     esp, ebp
.text$mn:00001D63                 pop     ebp
.text$mn:00001D64                 retn
.text$mn:00001D64 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00001D64
.text$mn:00001D64 ; ---------------------------------------------------------------------------
.text$mn:00001D65                 align 4
.text$mn:00001D65 _text$mn        ends
.text$mn:00001D65
.text$mn:00001D68 ; ===========================================================================
.text$mn:00001D68
.text$mn:00001D68 ; Segment type: Pure code
.text$mn:00001D68 ; Segment permissions: Read/Execute
.text$mn:00001D68 _text$mn        segment para public 'CODE' use32
.text$mn:00001D68                 assume cs:_text$mn
.text$mn:00001D68                 ;org 1D68h
.text$mn:00001D68 ; COMDAT (pick any)
.text$mn:00001D68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D68
.text$mn:00001D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D68
.text$mn:00001D68 ; Attributes: bp-based frame
.text$mn:00001D68
.text$mn:00001D68 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001D68                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001D68 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001D68                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001D68                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001D68
.text$mn:00001D68 var_10          = dword ptr -10h
.text$mn:00001D68 var_C           = dword ptr -0Ch
.text$mn:00001D68 var_4           = dword ptr -4
.text$mn:00001D68
.text$mn:00001D68                 push    ebp
.text$mn:00001D69                 mov     ebp, esp
.text$mn:00001D6B                 push    0FFFFFFFFh
.text$mn:00001D6D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001D72                 mov     eax, large fs:0
.text$mn:00001D78                 push    eax
.text$mn:00001D79                 push    ecx
.text$mn:00001D7A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D7F                 xor     eax, ebp
.text$mn:00001D81                 push    eax
.text$mn:00001D82                 lea     eax, [ebp+var_C]
.text$mn:00001D85                 mov     large fs:0, eax
.text$mn:00001D8B                 mov     [ebp+var_10], ecx
.text$mn:00001D8E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001D91                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00001D96                 mov     [ebp+var_4], 0
.text$mn:00001D9D                 mov     eax, [ebp+var_10]
.text$mn:00001DA0                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00001DA6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001DAD                 mov     eax, [ebp+var_10]
.text$mn:00001DB0                 mov     ecx, [ebp+var_C]
.text$mn:00001DB3                 mov     large fs:0, ecx
.text$mn:00001DBA                 pop     ecx
.text$mn:00001DBB                 mov     esp, ebp
.text$mn:00001DBD                 pop     ebp
.text$mn:00001DBE                 retn
.text$mn:00001DBE ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00001DBE
.text$mn:00001DBE ; ---------------------------------------------------------------------------
.text$mn:00001DBF                 align 10h
.text$mn:00001DBF _text$mn        ends
.text$mn:00001DBF
.text$x:00001DC0 ; ===========================================================================
.text$x:00001DC0
.text$x:00001DC0 ; Segment type: Pure code
.text$x:00001DC0 ; Segment permissions: Read/Execute
.text$x:00001DC0 _text$x         segment para public 'CODE' use32
.text$x:00001DC0                 assume cs:_text$x
.text$x:00001DC0                 ;org 1DC0h
.text$x:00001DC0 ; COMDAT (pick associative to section at 1D68)
.text$x:00001DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001DC0
.text$x:00001DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00001DC0
.text$x:00001DC0
.text$x:00001DC0 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00001DC0                                         ; DATA XREF: .xdata$x:00003FECo
.text$x:00001DC0                 mov     ecx, [ebp-10h]  ; this
.text$x:00001DC3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001DC3 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00001DC3
.text$x:00001DC8
.text$x:00001DC8 ; =============== S U B R O U T I N E =======================================
.text$x:00001DC8
.text$x:00001DC8
.text$x:00001DC8 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00001DC8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00001DC8
.text$x:00001DC8 arg_4           = dword ptr  8
.text$x:00001DC8
.text$x:00001DC8                 mov     edx, [esp+arg_4]
.text$x:00001DCC                 lea     eax, [edx+0Ch]
.text$x:00001DCF                 mov     ecx, [edx-8]
.text$x:00001DD2                 xor     ecx, eax
.text$x:00001DD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001DD9                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00001DDE                 jmp     ___CxxFrameHandler3
.text$x:00001DDE __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00001DDE
.text$x:00001DDE ; ---------------------------------------------------------------------------
.text$x:00001DE3                 align 4
.text$x:00001DE3 _text$x         ends
.text$x:00001DE3
.text$mn:00001DE4 ; ===========================================================================
.text$mn:00001DE4
.text$mn:00001DE4 ; Segment type: Pure code
.text$mn:00001DE4 ; Segment permissions: Read/Execute
.text$mn:00001DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE4                 assume cs:_text$mn
.text$mn:00001DE4                 ;org 1DE4h
.text$mn:00001DE4 ; COMDAT (pick any)
.text$mn:00001DE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DE4
.text$mn:00001DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE4
.text$mn:00001DE4 ; Attributes: bp-based frame
.text$mn:00001DE4
.text$mn:00001DE4 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00001DE4                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00001DE4 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00001DE4
.text$mn:00001DE4 var_4           = dword ptr -4
.text$mn:00001DE4
.text$mn:00001DE4                 push    ebp
.text$mn:00001DE5                 mov     ebp, esp
.text$mn:00001DE7                 push    ecx
.text$mn:00001DE8                 mov     [ebp+var_4], ecx
.text$mn:00001DEB                 mov     eax, [ebp+var_4]
.text$mn:00001DEE                 mov     esp, ebp
.text$mn:00001DF0                 pop     ebp
.text$mn:00001DF1                 retn
.text$mn:00001DF1 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00001DF1
.text$mn:00001DF1 ; ---------------------------------------------------------------------------
.text$mn:00001DF2                 align 4
.text$mn:00001DF2 _text$mn        ends
.text$mn:00001DF2
.text$mn:00001DF4 ; ===========================================================================
.text$mn:00001DF4
.text$mn:00001DF4 ; Segment type: Pure code
.text$mn:00001DF4 ; Segment permissions: Read/Execute
.text$mn:00001DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF4                 assume cs:_text$mn
.text$mn:00001DF4                 ;org 1DF4h
.text$mn:00001DF4 ; COMDAT (pick any)
.text$mn:00001DF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DF4
.text$mn:00001DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF4
.text$mn:00001DF4 ; Attributes: bp-based frame
.text$mn:00001DF4
.text$mn:00001DF4 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001DF4                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001DF4 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00001DF4                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001DF4
.text$mn:00001DF4 var_10          = dword ptr -10h
.text$mn:00001DF4 var_C           = dword ptr -0Ch
.text$mn:00001DF4 var_4           = dword ptr -4
.text$mn:00001DF4
.text$mn:00001DF4                 push    ebp
.text$mn:00001DF5                 mov     ebp, esp
.text$mn:00001DF7                 push    0FFFFFFFFh
.text$mn:00001DF9                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001DFE                 mov     eax, large fs:0
.text$mn:00001E04                 push    eax
.text$mn:00001E05                 push    ecx
.text$mn:00001E06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E0B                 xor     eax, ebp
.text$mn:00001E0D                 push    eax
.text$mn:00001E0E                 lea     eax, [ebp+var_C]
.text$mn:00001E11                 mov     large fs:0, eax
.text$mn:00001E17                 mov     [ebp+var_10], ecx
.text$mn:00001E1A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001E1D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001E22                 mov     [ebp+var_4], 0
.text$mn:00001E29                 mov     eax, [ebp+var_10]
.text$mn:00001E2C                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00001E32                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001E39                 mov     eax, [ebp+var_10]
.text$mn:00001E3C                 mov     ecx, [ebp+var_C]
.text$mn:00001E3F                 mov     large fs:0, ecx
.text$mn:00001E46                 pop     ecx
.text$mn:00001E47                 mov     esp, ebp
.text$mn:00001E49                 pop     ebp
.text$mn:00001E4A                 retn
.text$mn:00001E4A ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001E4A
.text$mn:00001E4A ; ---------------------------------------------------------------------------
.text$mn:00001E4B                 align 4
.text$mn:00001E4B _text$mn        ends
.text$mn:00001E4B
.text$x:00001E4C ; ===========================================================================
.text$x:00001E4C
.text$x:00001E4C ; Segment type: Pure code
.text$x:00001E4C ; Segment permissions: Read/Execute
.text$x:00001E4C _text$x         segment para public 'CODE' use32
.text$x:00001E4C                 assume cs:_text$x
.text$x:00001E4C                 ;org 1E4Ch
.text$x:00001E4C ; COMDAT (pick associative to section at 1DF4)
.text$x:00001E4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001E4C
.text$x:00001E4C ; =============== S U B R O U T I N E =======================================
.text$x:00001E4C
.text$x:00001E4C
.text$x:00001E4C __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001E4C                                         ; DATA XREF: .xdata$x:00004070o
.text$x:00001E4C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001E4F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001E4F __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001E4F
.text$x:00001E54
.text$x:00001E54 ; =============== S U B R O U T I N E =======================================
.text$x:00001E54
.text$x:00001E54
.text$x:00001E54 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00001E54                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00001E54
.text$x:00001E54 arg_4           = dword ptr  8
.text$x:00001E54
.text$x:00001E54                 mov     edx, [esp+arg_4]
.text$x:00001E58                 lea     eax, [edx+0Ch]
.text$x:00001E5B                 mov     ecx, [edx-8]
.text$x:00001E5E                 xor     ecx, eax
.text$x:00001E60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E65                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001E6A                 jmp     ___CxxFrameHandler3
.text$x:00001E6A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001E6A
.text$x:00001E6A ; ---------------------------------------------------------------------------
.text$x:00001E6F                 align 10h
.text$x:00001E6F _text$x         ends
.text$x:00001E6F
.text$mn:00001E70 ; ===========================================================================
.text$mn:00001E70
.text$mn:00001E70 ; Segment type: Pure code
.text$mn:00001E70 ; Segment permissions: Read/Execute
.text$mn:00001E70 _text$mn        segment para public 'CODE' use32
.text$mn:00001E70                 assume cs:_text$mn
.text$mn:00001E70                 ;org 1E70h
.text$mn:00001E70 ; COMDAT (pick any)
.text$mn:00001E70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E70
.text$mn:00001E70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E70
.text$mn:00001E70 ; Attributes: bp-based frame
.text$mn:00001E70
.text$mn:00001E70 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001E70                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001E70 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001E70                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001E70
.text$mn:00001E70 var_10          = dword ptr -10h
.text$mn:00001E70 var_C           = dword ptr -0Ch
.text$mn:00001E70 var_4           = dword ptr -4
.text$mn:00001E70
.text$mn:00001E70                 push    ebp
.text$mn:00001E71                 mov     ebp, esp
.text$mn:00001E73                 push    0FFFFFFFFh
.text$mn:00001E75                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001E7A                 mov     eax, large fs:0
.text$mn:00001E80                 push    eax
.text$mn:00001E81                 push    ecx
.text$mn:00001E82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E87                 xor     eax, ebp
.text$mn:00001E89                 push    eax
.text$mn:00001E8A                 lea     eax, [ebp+var_C]
.text$mn:00001E8D                 mov     large fs:0, eax
.text$mn:00001E93                 mov     [ebp+var_10], ecx
.text$mn:00001E96                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001E99                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001E9E                 mov     [ebp+var_4], 0
.text$mn:00001EA5                 mov     eax, [ebp+var_10]
.text$mn:00001EA8                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00001EAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001EB5                 mov     eax, [ebp+var_10]
.text$mn:00001EB8                 mov     ecx, [ebp+var_C]
.text$mn:00001EBB                 mov     large fs:0, ecx
.text$mn:00001EC2                 pop     ecx
.text$mn:00001EC3                 mov     esp, ebp
.text$mn:00001EC5                 pop     ebp
.text$mn:00001EC6                 retn
.text$mn:00001EC6 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00001EC6
.text$mn:00001EC6 ; ---------------------------------------------------------------------------
.text$mn:00001EC7                 align 4
.text$mn:00001EC7 _text$mn        ends
.text$mn:00001EC7
.text$x:00001EC8 ; ===========================================================================
.text$x:00001EC8
.text$x:00001EC8 ; Segment type: Pure code
.text$x:00001EC8 ; Segment permissions: Read/Execute
.text$x:00001EC8 _text$x         segment para public 'CODE' use32
.text$x:00001EC8                 assume cs:_text$x
.text$x:00001EC8                 ;org 1EC8h
.text$x:00001EC8 ; COMDAT (pick associative to section at 1E70)
.text$x:00001EC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001EC8
.text$x:00001EC8 ; =============== S U B R O U T I N E =======================================
.text$x:00001EC8
.text$x:00001EC8
.text$x:00001EC8 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00001EC8                                         ; DATA XREF: .xdata$x:000040F4o
.text$x:00001EC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00001ECB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001ECB __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00001ECB
.text$x:00001ED0
.text$x:00001ED0 ; =============== S U B R O U T I N E =======================================
.text$x:00001ED0
.text$x:00001ED0
.text$x:00001ED0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00001ED0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00001ED0
.text$x:00001ED0 arg_4           = dword ptr  8
.text$x:00001ED0
.text$x:00001ED0                 mov     edx, [esp+arg_4]
.text$x:00001ED4                 lea     eax, [edx+0Ch]
.text$x:00001ED7                 mov     ecx, [edx-8]
.text$x:00001EDA                 xor     ecx, eax
.text$x:00001EDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001EE1                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00001EE6                 jmp     ___CxxFrameHandler3
.text$x:00001EE6 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00001EE6
.text$x:00001EE6 ; ---------------------------------------------------------------------------
.text$x:00001EEB                 align 4
.text$x:00001EEB _text$x         ends
.text$x:00001EEB
.text$mn:00001EEC ; ===========================================================================
.text$mn:00001EEC
.text$mn:00001EEC ; Segment type: Pure code
.text$mn:00001EEC ; Segment permissions: Read/Execute
.text$mn:00001EEC _text$mn        segment para public 'CODE' use32
.text$mn:00001EEC                 assume cs:_text$mn
.text$mn:00001EEC                 ;org 1EECh
.text$mn:00001EEC ; COMDAT (pick any)
.text$mn:00001EEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001EEC
.text$mn:00001EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EEC
.text$mn:00001EEC ; Attributes: bp-based frame
.text$mn:00001EEC
.text$mn:00001EEC ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00001EEC                 public ??0error_category@std@@QAE@XZ
.text$mn:00001EEC ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00001EEC
.text$mn:00001EEC var_4           = dword ptr -4
.text$mn:00001EEC
.text$mn:00001EEC                 push    ebp
.text$mn:00001EED                 mov     ebp, esp
.text$mn:00001EEF                 push    ecx
.text$mn:00001EF0                 mov     [ebp+var_4], ecx
.text$mn:00001EF3                 mov     eax, [ebp+var_4]
.text$mn:00001EF6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001EFC                 mov     eax, [ebp+var_4]
.text$mn:00001EFF                 mov     esp, ebp
.text$mn:00001F01                 pop     ebp
.text$mn:00001F02                 retn
.text$mn:00001F02 ??0error_category@std@@QAE@XZ endp
.text$mn:00001F02
.text$mn:00001F02 ; ---------------------------------------------------------------------------
.text$mn:00001F03                 align 4
.text$mn:00001F03 _text$mn        ends
.text$mn:00001F03
.text$mn:00001F04 ; ===========================================================================
.text$mn:00001F04
.text$mn:00001F04 ; Segment type: Pure code
.text$mn:00001F04 ; Segment permissions: Read/Execute
.text$mn:00001F04 _text$mn        segment para public 'CODE' use32
.text$mn:00001F04                 assume cs:_text$mn
.text$mn:00001F04                 ;org 1F04h
.text$mn:00001F04 ; COMDAT (pick any)
.text$mn:00001F04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F04
.text$mn:00001F04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F04
.text$mn:00001F04 ; Attributes: bp-based frame
.text$mn:00001F04
.text$mn:00001F04 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00001F04                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00001F04 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00001F04                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00001F04                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00001F04
.text$mn:00001F04 var_4           = dword ptr -4
.text$mn:00001F04 arg_0           = dword ptr  8
.text$mn:00001F04 arg_4           = dword ptr  0Ch
.text$mn:00001F04
.text$mn:00001F04                 push    ebp
.text$mn:00001F05                 mov     ebp, esp
.text$mn:00001F07                 push    ecx
.text$mn:00001F08                 mov     [ebp+var_4], ecx
.text$mn:00001F0B                 mov     eax, [ebp+var_4]
.text$mn:00001F0E                 mov     ecx, [ebp+arg_0]
.text$mn:00001F11                 mov     [eax], ecx
.text$mn:00001F13                 mov     edx, [ebp+var_4]
.text$mn:00001F16                 mov     eax, [ebp+arg_4]
.text$mn:00001F19                 mov     [edx+4], eax
.text$mn:00001F1C                 mov     eax, [ebp+var_4]
.text$mn:00001F1F                 mov     esp, ebp
.text$mn:00001F21                 pop     ebp
.text$mn:00001F22                 retn    8
.text$mn:00001F22 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00001F22
.text$mn:00001F22 ; ---------------------------------------------------------------------------
.text$mn:00001F25                 align 4
.text$mn:00001F25 _text$mn        ends
.text$mn:00001F25
.text$mn:00001F28 ; ===========================================================================
.text$mn:00001F28
.text$mn:00001F28 ; Segment type: Pure code
.text$mn:00001F28 ; Segment permissions: Read/Execute
.text$mn:00001F28 _text$mn        segment para public 'CODE' use32
.text$mn:00001F28                 assume cs:_text$mn
.text$mn:00001F28                 ;org 1F28h
.text$mn:00001F28 ; COMDAT (pick any)
.text$mn:00001F28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F28
.text$mn:00001F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F28
.text$mn:00001F28 ; Attributes: bp-based frame
.text$mn:00001F28
.text$mn:00001F28 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001F28                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001F28 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001F28                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001F28
.text$mn:00001F28 var_4           = dword ptr -4
.text$mn:00001F28 arg_0           = dword ptr  8
.text$mn:00001F28
.text$mn:00001F28                 push    ebp
.text$mn:00001F29                 mov     ebp, esp
.text$mn:00001F2B                 push    ecx
.text$mn:00001F2C                 mov     [ebp+var_4], ecx
.text$mn:00001F2F                 mov     eax, [ebp+var_4]
.text$mn:00001F32                 mov     ecx, [ebp+arg_0]
.text$mn:00001F35                 mov     [eax], ecx
.text$mn:00001F37                 mov     eax, [ebp+var_4]
.text$mn:00001F3A                 mov     esp, ebp
.text$mn:00001F3C                 pop     ebp
.text$mn:00001F3D                 retn    4
.text$mn:00001F3D ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001F3D
.text$mn:00001F3D _text$mn        ends
.text$mn:00001F3D
.text$mn:00001F40 ; ===========================================================================
.text$mn:00001F40
.text$mn:00001F40 ; Segment type: Pure code
.text$mn:00001F40 ; Segment permissions: Read/Execute
.text$mn:00001F40 _text$mn        segment para public 'CODE' use32
.text$mn:00001F40                 assume cs:_text$mn
.text$mn:00001F40                 ;org 1F40h
.text$mn:00001F40 ; COMDAT (pick any)
.text$mn:00001F40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F40
.text$mn:00001F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F40
.text$mn:00001F40 ; Attributes: bp-based frame
.text$mn:00001F40
.text$mn:00001F40 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001F40                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001F40 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001F40                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001F40                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001F40
.text$mn:00001F40 var_10          = dword ptr -10h
.text$mn:00001F40 var_C           = dword ptr -0Ch
.text$mn:00001F40 var_4           = dword ptr -4
.text$mn:00001F40
.text$mn:00001F40                 push    ebp
.text$mn:00001F41                 mov     ebp, esp
.text$mn:00001F43                 push    0FFFFFFFFh
.text$mn:00001F45                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001F4A                 mov     eax, large fs:0
.text$mn:00001F50                 push    eax
.text$mn:00001F51                 push    ecx
.text$mn:00001F52                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F57                 xor     eax, ebp
.text$mn:00001F59                 push    eax
.text$mn:00001F5A                 lea     eax, [ebp+var_C]
.text$mn:00001F5D                 mov     large fs:0, eax
.text$mn:00001F63                 mov     [ebp+var_10], ecx
.text$mn:00001F66                 mov     [ebp+var_4], 0
.text$mn:00001F6D                 mov     ecx, [ebp+var_10]
.text$mn:00001F70                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001F75                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F7C                 mov     ecx, [ebp+var_10]
.text$mn:00001F7F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001F84                 mov     ecx, [ebp+var_C]
.text$mn:00001F87                 mov     large fs:0, ecx
.text$mn:00001F8E                 pop     ecx
.text$mn:00001F8F                 mov     esp, ebp
.text$mn:00001F91                 pop     ebp
.text$mn:00001F92                 retn
.text$mn:00001F92 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001F92
.text$mn:00001F92 ; ---------------------------------------------------------------------------
.text$mn:00001F93                 align 4
.text$mn:00001F93 _text$mn        ends
.text$mn:00001F93
.text$x:00001F94 ; ===========================================================================
.text$x:00001F94
.text$x:00001F94 ; Segment type: Pure code
.text$x:00001F94 ; Segment permissions: Read/Execute
.text$x:00001F94 _text$x         segment para public 'CODE' use32
.text$x:00001F94                 assume cs:_text$x
.text$x:00001F94                 ;org 1F94h
.text$x:00001F94 ; COMDAT (pick associative to section at 1F40)
.text$x:00001F94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001F94
.text$x:00001F94 ; =============== S U B R O U T I N E =======================================
.text$x:00001F94
.text$x:00001F94
.text$x:00001F94 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001F94                                         ; DATA XREF: .xdata$x:00003EDCo
.text$x:00001F94                 mov     ecx, [ebp-10h]
.text$x:00001F97                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001F97 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001F97
.text$x:00001F9C
.text$x:00001F9C ; =============== S U B R O U T I N E =======================================
.text$x:00001F9C
.text$x:00001F9C
.text$x:00001F9C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001F9C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001F9C
.text$x:00001F9C arg_4           = dword ptr  8
.text$x:00001F9C
.text$x:00001F9C                 mov     edx, [esp+arg_4]
.text$x:00001FA0                 lea     eax, [edx+0Ch]
.text$x:00001FA3                 mov     ecx, [edx-8]
.text$x:00001FA6                 xor     ecx, eax
.text$x:00001FA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001FAD                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00001FB2                 jmp     ___CxxFrameHandler3
.text$x:00001FB2 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00001FB2
.text$x:00001FB2 ; ---------------------------------------------------------------------------
.text$x:00001FB7                 align 4
.text$x:00001FB7 _text$x         ends
.text$x:00001FB7
.text$mn:00001FB8 ; ===========================================================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Segment type: Pure code
.text$mn:00001FB8 ; Segment permissions: Read/Execute
.text$mn:00001FB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB8                 assume cs:_text$mn
.text$mn:00001FB8                 ;org 1FB8h
.text$mn:00001FB8 ; COMDAT (pick any)
.text$mn:00001FB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FB8
.text$mn:00001FB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Attributes: bp-based frame
.text$mn:00001FB8
.text$mn:00001FB8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00001FB8                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00001FB8 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001FB8                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j
.text$mn:00001FB8                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0+3j ...
.text$mn:00001FB8
.text$mn:00001FB8 var_10          = dword ptr -10h
.text$mn:00001FB8 var_C           = dword ptr -0Ch
.text$mn:00001FB8 var_4           = dword ptr -4
.text$mn:00001FB8
.text$mn:00001FB8                 push    ebp
.text$mn:00001FB9                 mov     ebp, esp
.text$mn:00001FBB                 push    0FFFFFFFFh
.text$mn:00001FBD                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00001FC2                 mov     eax, large fs:0
.text$mn:00001FC8                 push    eax
.text$mn:00001FC9                 push    ecx
.text$mn:00001FCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FCF                 xor     eax, ebp
.text$mn:00001FD1                 push    eax
.text$mn:00001FD2                 lea     eax, [ebp+var_C]
.text$mn:00001FD5                 mov     large fs:0, eax
.text$mn:00001FDB                 mov     [ebp+var_10], ecx
.text$mn:00001FDE                 mov     [ebp+var_4], 0
.text$mn:00001FE5                 mov     ecx, [ebp+var_10]
.text$mn:00001FE8                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00001FED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001FF4                 mov     ecx, [ebp+var_10]
.text$mn:00001FF7                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00001FFC                 mov     ecx, [ebp+var_C]
.text$mn:00001FFF                 mov     large fs:0, ecx
.text$mn:00002006                 pop     ecx
.text$mn:00002007                 mov     esp, ebp
.text$mn:00002009                 pop     ebp
.text$mn:0000200A                 retn
.text$mn:0000200A ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000200A
.text$mn:0000200A ; ---------------------------------------------------------------------------
.text$mn:0000200B                 align 4
.text$mn:0000200B _text$mn        ends
.text$mn:0000200B
.text$x:0000200C ; ===========================================================================
.text$x:0000200C
.text$x:0000200C ; Segment type: Pure code
.text$x:0000200C ; Segment permissions: Read/Execute
.text$x:0000200C _text$x         segment para public 'CODE' use32
.text$x:0000200C                 assume cs:_text$x
.text$x:0000200C                 ;org 200Ch
.text$x:0000200C ; COMDAT (pick associative to section at 1FB8)
.text$x:0000200C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000200C
.text$x:0000200C ; =============== S U B R O U T I N E =======================================
.text$x:0000200C
.text$x:0000200C
.text$x:0000200C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000200C                                         ; DATA XREF: .xdata$x:000041FCo
.text$x:0000200C                 mov     ecx, [ebp-10h]
.text$x:0000200F                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000200F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000200F
.text$x:00002014
.text$x:00002014 ; =============== S U B R O U T I N E =======================================
.text$x:00002014
.text$x:00002014
.text$x:00002014 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002014                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00002014
.text$x:00002014 arg_4           = dword ptr  8
.text$x:00002014
.text$x:00002014                 mov     edx, [esp+arg_4]
.text$x:00002018                 lea     eax, [edx+0Ch]
.text$x:0000201B                 mov     ecx, [edx-8]
.text$x:0000201E                 xor     ecx, eax
.text$x:00002020                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002025                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:0000202A                 jmp     ___CxxFrameHandler3
.text$x:0000202A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:0000202A
.text$x:0000202A ; ---------------------------------------------------------------------------
.text$x:0000202F                 align 10h
.text$x:0000202F _text$x         ends
.text$x:0000202F
.text$mn:00002030 ; ===========================================================================
.text$mn:00002030
.text$mn:00002030 ; Segment type: Pure code
.text$mn:00002030 ; Segment permissions: Read/Execute
.text$mn:00002030 _text$mn        segment para public 'CODE' use32
.text$mn:00002030                 assume cs:_text$mn
.text$mn:00002030                 ;org 2030h
.text$mn:00002030 ; COMDAT (pick any)
.text$mn:00002030                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002030
.text$mn:00002030 ; =============== S U B R O U T I N E =======================================
.text$mn:00002030
.text$mn:00002030 ; Attributes: bp-based frame
.text$mn:00002030
.text$mn:00002030 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002030                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002030 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002030                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00002030                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00002030
.text$mn:00002030 var_10          = dword ptr -10h
.text$mn:00002030 var_C           = dword ptr -0Ch
.text$mn:00002030 var_4           = dword ptr -4
.text$mn:00002030
.text$mn:00002030                 push    ebp
.text$mn:00002031                 mov     ebp, esp
.text$mn:00002033                 push    0FFFFFFFFh
.text$mn:00002035                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000203A                 mov     eax, large fs:0
.text$mn:00002040                 push    eax
.text$mn:00002041                 push    ecx
.text$mn:00002042                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002047                 xor     eax, ebp
.text$mn:00002049                 push    eax
.text$mn:0000204A                 lea     eax, [ebp+var_C]
.text$mn:0000204D                 mov     large fs:0, eax
.text$mn:00002053                 mov     [ebp+var_10], ecx
.text$mn:00002056                 mov     [ebp+var_4], 0
.text$mn:0000205D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002064                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002067                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000206C                 mov     ecx, [ebp+var_C]
.text$mn:0000206F                 mov     large fs:0, ecx
.text$mn:00002076                 pop     ecx
.text$mn:00002077                 mov     esp, ebp
.text$mn:00002079                 pop     ebp
.text$mn:0000207A                 retn
.text$mn:0000207A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000207A
.text$mn:0000207A ; ---------------------------------------------------------------------------
.text$mn:0000207B                 align 4
.text$mn:0000207B _text$mn        ends
.text$mn:0000207B
.text$x:0000207C ; ===========================================================================
.text$x:0000207C
.text$x:0000207C ; Segment type: Pure code
.text$x:0000207C ; Segment permissions: Read/Execute
.text$x:0000207C _text$x         segment para public 'CODE' use32
.text$x:0000207C                 assume cs:_text$x
.text$x:0000207C                 ;org 207Ch
.text$x:0000207C ; COMDAT (pick associative to section at 2030)
.text$x:0000207C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000207C
.text$x:0000207C ; =============== S U B R O U T I N E =======================================
.text$x:0000207C
.text$x:0000207C
.text$x:0000207C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000207C                                         ; DATA XREF: .xdata$x:00003E84o
.text$x:0000207C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000207F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000207F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000207F
.text$x:00002084
.text$x:00002084 ; =============== S U B R O U T I N E =======================================
.text$x:00002084
.text$x:00002084
.text$x:00002084 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002084                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002084
.text$x:00002084 arg_4           = dword ptr  8
.text$x:00002084
.text$x:00002084                 mov     edx, [esp+arg_4]
.text$x:00002088                 lea     eax, [edx+0Ch]
.text$x:0000208B                 mov     ecx, [edx-8]
.text$x:0000208E                 xor     ecx, eax
.text$x:00002090                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002095                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000209A                 jmp     ___CxxFrameHandler3
.text$x:0000209A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000209A
.text$x:0000209A ; ---------------------------------------------------------------------------
.text$x:0000209F                 align 10h
.text$x:0000209F _text$x         ends
.text$x:0000209F
.text$mn:000020A0 ; ===========================================================================
.text$mn:000020A0
.text$mn:000020A0 ; Segment type: Pure code
.text$mn:000020A0 ; Segment permissions: Read/Execute
.text$mn:000020A0 _text$mn        segment para public 'CODE' use32
.text$mn:000020A0                 assume cs:_text$mn
.text$mn:000020A0                 ;org 20A0h
.text$mn:000020A0 ; COMDAT (pick any)
.text$mn:000020A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020A0
.text$mn:000020A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020A0
.text$mn:000020A0 ; Attributes: bp-based frame
.text$mn:000020A0
.text$mn:000020A0 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000020A0                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000020A0 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000020A0                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:000020A0                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:000020A0
.text$mn:000020A0 var_10          = dword ptr -10h
.text$mn:000020A0 var_C           = dword ptr -0Ch
.text$mn:000020A0 var_4           = dword ptr -4
.text$mn:000020A0
.text$mn:000020A0                 push    ebp
.text$mn:000020A1                 mov     ebp, esp
.text$mn:000020A3                 push    0FFFFFFFFh
.text$mn:000020A5                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000020AA                 mov     eax, large fs:0
.text$mn:000020B0                 push    eax
.text$mn:000020B1                 push    ecx
.text$mn:000020B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000020B7                 xor     eax, ebp
.text$mn:000020B9                 push    eax
.text$mn:000020BA                 lea     eax, [ebp+var_C]
.text$mn:000020BD                 mov     large fs:0, eax
.text$mn:000020C3                 mov     [ebp+var_10], ecx
.text$mn:000020C6                 mov     [ebp+var_4], 0
.text$mn:000020CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000020D4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000020D7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000020DC                 mov     ecx, [ebp+var_C]
.text$mn:000020DF                 mov     large fs:0, ecx
.text$mn:000020E6                 pop     ecx
.text$mn:000020E7                 mov     esp, ebp
.text$mn:000020E9                 pop     ebp
.text$mn:000020EA                 retn
.text$mn:000020EA ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000020EA
.text$mn:000020EA ; ---------------------------------------------------------------------------
.text$mn:000020EB                 align 4
.text$mn:000020EB _text$mn        ends
.text$mn:000020EB
.text$x:000020EC ; ===========================================================================
.text$x:000020EC
.text$x:000020EC ; Segment type: Pure code
.text$x:000020EC ; Segment permissions: Read/Execute
.text$x:000020EC _text$x         segment para public 'CODE' use32
.text$x:000020EC                 assume cs:_text$x
.text$x:000020EC                 ;org 20ECh
.text$x:000020EC ; COMDAT (pick associative to section at 20A0)
.text$x:000020EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000020EC
.text$x:000020EC ; =============== S U B R O U T I N E =======================================
.text$x:000020EC
.text$x:000020EC
.text$x:000020EC __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000020EC                                         ; DATA XREF: .xdata$x:000041A4o
.text$x:000020EC                 mov     ecx, [ebp-10h]  ; this
.text$x:000020EF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000020EF __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000020EF
.text$x:000020F4
.text$x:000020F4 ; =============== S U B R O U T I N E =======================================
.text$x:000020F4
.text$x:000020F4
.text$x:000020F4 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:000020F4                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:000020F4
.text$x:000020F4 arg_4           = dword ptr  8
.text$x:000020F4
.text$x:000020F4                 mov     edx, [esp+arg_4]
.text$x:000020F8                 lea     eax, [edx+0Ch]
.text$x:000020FB                 mov     ecx, [edx-8]
.text$x:000020FE                 xor     ecx, eax
.text$x:00002100                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002105                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000210A                 jmp     ___CxxFrameHandler3
.text$x:0000210A __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000210A
.text$x:0000210A ; ---------------------------------------------------------------------------
.text$x:0000210F                 align 10h
.text$x:0000210F _text$x         ends
.text$x:0000210F
.text$mn:00002110 ; ===========================================================================
.text$mn:00002110
.text$mn:00002110 ; Segment type: Pure code
.text$mn:00002110 ; Segment permissions: Read/Execute
.text$mn:00002110 _text$mn        segment para public 'CODE' use32
.text$mn:00002110                 assume cs:_text$mn
.text$mn:00002110                 ;org 2110h
.text$mn:00002110 ; COMDAT (pick any)
.text$mn:00002110                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002110
.text$mn:00002110 ; =============== S U B R O U T I N E =======================================
.text$mn:00002110
.text$mn:00002110 ; Attributes: bp-based frame
.text$mn:00002110
.text$mn:00002110 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00002110                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002110 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00002110                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00002110                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00002110
.text$mn:00002110 var_10          = dword ptr -10h
.text$mn:00002110 var_C           = dword ptr -0Ch
.text$mn:00002110 var_4           = dword ptr -4
.text$mn:00002110
.text$mn:00002110                 push    ebp
.text$mn:00002111                 mov     ebp, esp
.text$mn:00002113                 push    0FFFFFFFFh
.text$mn:00002115                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000211A                 mov     eax, large fs:0
.text$mn:00002120                 push    eax
.text$mn:00002121                 push    ecx
.text$mn:00002122                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002127                 xor     eax, ebp
.text$mn:00002129                 push    eax
.text$mn:0000212A                 lea     eax, [ebp+var_C]
.text$mn:0000212D                 mov     large fs:0, eax
.text$mn:00002133                 mov     [ebp+var_10], ecx
.text$mn:00002136                 mov     [ebp+var_4], 0
.text$mn:0000213D                 push    0               ; Size
.text$mn:0000213F                 push    1               ; char
.text$mn:00002141                 mov     ecx, [ebp+var_10]
.text$mn:00002144                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002149                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002150                 mov     ecx, [ebp+var_10]
.text$mn:00002153                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00002158                 mov     ecx, [ebp+var_C]
.text$mn:0000215B                 mov     large fs:0, ecx
.text$mn:00002162                 pop     ecx
.text$mn:00002163                 mov     esp, ebp
.text$mn:00002165                 pop     ebp
.text$mn:00002166                 retn
.text$mn:00002166 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00002166
.text$mn:00002166 ; ---------------------------------------------------------------------------
.text$mn:00002167                 align 4
.text$mn:00002167 _text$mn        ends
.text$mn:00002167
.text$x:00002168 ; ===========================================================================
.text$x:00002168
.text$x:00002168 ; Segment type: Pure code
.text$x:00002168 ; Segment permissions: Read/Execute
.text$x:00002168 _text$x         segment para public 'CODE' use32
.text$x:00002168                 assume cs:_text$x
.text$x:00002168                 ;org 2168h
.text$x:00002168 ; COMDAT (pick associative to section at 2110)
.text$x:00002168                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002168
.text$x:00002168 ; =============== S U B R O U T I N E =======================================
.text$x:00002168
.text$x:00002168
.text$x:00002168 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00002168                                         ; DATA XREF: .xdata$x:00003F34o
.text$x:00002168                 mov     ecx, [ebp-10h]
.text$x:0000216B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000216B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000216B
.text$x:00002170
.text$x:00002170 ; =============== S U B R O U T I N E =======================================
.text$x:00002170
.text$x:00002170
.text$x:00002170 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00002170                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00002170
.text$x:00002170 arg_4           = dword ptr  8
.text$x:00002170
.text$x:00002170                 mov     edx, [esp+arg_4]
.text$x:00002174                 lea     eax, [edx+0Ch]
.text$x:00002177                 mov     ecx, [edx-8]
.text$x:0000217A                 xor     ecx, eax
.text$x:0000217C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002181                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00002186                 jmp     ___CxxFrameHandler3
.text$x:00002186 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00002186
.text$x:00002186 ; ---------------------------------------------------------------------------
.text$x:0000218B                 align 4
.text$x:0000218B _text$x         ends
.text$x:0000218B
.text$mn:0000218C ; ===========================================================================
.text$mn:0000218C
.text$mn:0000218C ; Segment type: Pure code
.text$mn:0000218C ; Segment permissions: Read/Execute
.text$mn:0000218C _text$mn        segment para public 'CODE' use32
.text$mn:0000218C                 assume cs:_text$mn
.text$mn:0000218C                 ;org 218Ch
.text$mn:0000218C ; COMDAT (pick any)
.text$mn:0000218C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000218C
.text$mn:0000218C ; =============== S U B R O U T I N E =======================================
.text$mn:0000218C
.text$mn:0000218C ; Attributes: bp-based frame
.text$mn:0000218C
.text$mn:0000218C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:0000218C                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000218C ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:0000218C                                         ; CODE XREF: __unwindfunclet$??0FindOption@@QAE@XZ$0+6j
.text$mn:0000218C                                         ; __unwindfunclet$??0FindOption@@QAE@XZ$1+6j ...
.text$mn:0000218C
.text$mn:0000218C var_10          = dword ptr -10h
.text$mn:0000218C var_C           = dword ptr -0Ch
.text$mn:0000218C var_4           = dword ptr -4
.text$mn:0000218C
.text$mn:0000218C                 push    ebp
.text$mn:0000218D                 mov     ebp, esp
.text$mn:0000218F                 push    0FFFFFFFFh
.text$mn:00002191                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00002196                 mov     eax, large fs:0
.text$mn:0000219C                 push    eax
.text$mn:0000219D                 push    ecx
.text$mn:0000219E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000021A3                 xor     eax, ebp
.text$mn:000021A5                 push    eax
.text$mn:000021A6                 lea     eax, [ebp+var_C]
.text$mn:000021A9                 mov     large fs:0, eax
.text$mn:000021AF                 mov     [ebp+var_10], ecx
.text$mn:000021B2                 mov     [ebp+var_4], 0
.text$mn:000021B9                 push    0
.text$mn:000021BB                 push    1
.text$mn:000021BD                 mov     ecx, [ebp+var_10]
.text$mn:000021C0                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000021C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000021CC                 mov     ecx, [ebp+var_10]
.text$mn:000021CF                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:000021D4                 mov     ecx, [ebp+var_C]
.text$mn:000021D7                 mov     large fs:0, ecx
.text$mn:000021DE                 pop     ecx
.text$mn:000021DF                 mov     esp, ebp
.text$mn:000021E1                 pop     ebp
.text$mn:000021E2                 retn
.text$mn:000021E2 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000021E2
.text$mn:000021E2 ; ---------------------------------------------------------------------------
.text$mn:000021E3                 align 4
.text$mn:000021E3 _text$mn        ends
.text$mn:000021E3
.text$x:000021E4 ; ===========================================================================
.text$x:000021E4
.text$x:000021E4 ; Segment type: Pure code
.text$x:000021E4 ; Segment permissions: Read/Execute
.text$x:000021E4 _text$x         segment para public 'CODE' use32
.text$x:000021E4                 assume cs:_text$x
.text$x:000021E4                 ;org 21E4h
.text$x:000021E4 ; COMDAT (pick associative to section at 218C)
.text$x:000021E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000021E4
.text$x:000021E4 ; =============== S U B R O U T I N E =======================================
.text$x:000021E4
.text$x:000021E4
.text$x:000021E4 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000021E4                                         ; DATA XREF: .xdata$x:00004280o
.text$x:000021E4                 mov     ecx, [ebp-10h]
.text$x:000021E7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000021E7 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000021E7
.text$x:000021EC
.text$x:000021EC ; =============== S U B R O U T I N E =======================================
.text$x:000021EC
.text$x:000021EC
.text$x:000021EC __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000021EC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000021EC
.text$x:000021EC arg_4           = dword ptr  8
.text$x:000021EC
.text$x:000021EC                 mov     edx, [esp+arg_4]
.text$x:000021F0                 lea     eax, [edx+0Ch]
.text$x:000021F3                 mov     ecx, [edx-8]
.text$x:000021F6                 xor     ecx, eax
.text$x:000021F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000021FD                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00002202                 jmp     ___CxxFrameHandler3
.text$x:00002202 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00002202
.text$x:00002202 ; ---------------------------------------------------------------------------
.text$x:00002207                 align 4
.text$x:00002207 _text$x         ends
.text$x:00002207
.text$mn:00002208 ; ===========================================================================
.text$mn:00002208
.text$mn:00002208 ; Segment type: Pure code
.text$mn:00002208 ; Segment permissions: Read/Execute
.text$mn:00002208 _text$mn        segment para public 'CODE' use32
.text$mn:00002208                 assume cs:_text$mn
.text$mn:00002208                 ;org 2208h
.text$mn:00002208 ; COMDAT (pick any)
.text$mn:00002208                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002208
.text$mn:00002208 ; =============== S U B R O U T I N E =======================================
.text$mn:00002208
.text$mn:00002208 ; Attributes: bp-based frame
.text$mn:00002208
.text$mn:00002208 ; _DWORD __thiscall FindOption::~FindOption(FindOption *__hidden this)
.text$mn:00002208                 public ??1FindOption@@QAE@XZ
.text$mn:00002208 ??1FindOption@@QAE@XZ proc near         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+44Bp
.text$mn:00002208                                         ; __unwindfunclet$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z$0+6j
.text$mn:00002208
.text$mn:00002208 var_10          = dword ptr -10h
.text$mn:00002208 var_C           = dword ptr -0Ch
.text$mn:00002208 var_4           = dword ptr -4
.text$mn:00002208
.text$mn:00002208                 push    ebp
.text$mn:00002209                 mov     ebp, esp
.text$mn:0000220B                 push    0FFFFFFFFh
.text$mn:0000220D                 push    offset __ehhandler$??1FindOption@@QAE@XZ
.text$mn:00002212                 mov     eax, large fs:0
.text$mn:00002218                 push    eax
.text$mn:00002219                 push    ecx
.text$mn:0000221A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000221F                 xor     eax, ebp
.text$mn:00002221                 push    eax
.text$mn:00002222                 lea     eax, [ebp+var_C]
.text$mn:00002225                 mov     large fs:0, eax
.text$mn:0000222B                 mov     [ebp+var_10], ecx
.text$mn:0000222E                 mov     [ebp+var_4], 3
.text$mn:00002235                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002239                 mov     ecx, [ebp+var_10]
.text$mn:0000223C                 add     ecx, 64h ; 'd'
.text$mn:0000223F                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002244                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002248                 mov     ecx, [ebp+var_10]
.text$mn:0000224B                 add     ecx, 48h ; 'H'
.text$mn:0000224E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002253                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002257                 mov     ecx, [ebp+var_10]
.text$mn:0000225A                 add     ecx, 2Ch ; ','
.text$mn:0000225D                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002262                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002269                 mov     ecx, [ebp+var_10]
.text$mn:0000226C                 add     ecx, 10h
.text$mn:0000226F                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002274                 mov     ecx, [ebp+var_C]
.text$mn:00002277                 mov     large fs:0, ecx
.text$mn:0000227E                 pop     ecx
.text$mn:0000227F                 mov     esp, ebp
.text$mn:00002281                 pop     ebp
.text$mn:00002282                 retn
.text$mn:00002282 ??1FindOption@@QAE@XZ endp
.text$mn:00002282
.text$mn:00002282 ; ---------------------------------------------------------------------------
.text$mn:00002283                 align 4
.text$mn:00002283 _text$mn        ends
.text$mn:00002283
.text$x:00002284 ; ===========================================================================
.text$x:00002284
.text$x:00002284 ; Segment type: Pure code
.text$x:00002284 ; Segment permissions: Read/Execute
.text$x:00002284 _text$x         segment para public 'CODE' use32
.text$x:00002284                 assume cs:_text$x
.text$x:00002284                 ;org 2284h
.text$x:00002284 ; COMDAT (pick associative to section at 2208)
.text$x:00002284                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002284
.text$x:00002284 ; =============== S U B R O U T I N E =======================================
.text$x:00002284
.text$x:00002284
.text$x:00002284 __unwindfunclet$??1FindOption@@QAE@XZ$0 proc near
.text$x:00002284                                         ; DATA XREF: .xdata$x:0000437Co
.text$x:00002284                 mov     ecx, [ebp-10h]
.text$x:00002287                 add     ecx, 10h
.text$x:0000228A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000228A __unwindfunclet$??1FindOption@@QAE@XZ$0 endp
.text$x:0000228A
.text$x:0000228F
.text$x:0000228F ; =============== S U B R O U T I N E =======================================
.text$x:0000228F
.text$x:0000228F
.text$x:0000228F __unwindfunclet$??1FindOption@@QAE@XZ$1 proc near
.text$x:0000228F                                         ; DATA XREF: .xdata$x:00004384o
.text$x:0000228F                 mov     ecx, [ebp-10h]
.text$x:00002292                 add     ecx, 2Ch ; ','
.text$x:00002295                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002295 __unwindfunclet$??1FindOption@@QAE@XZ$1 endp
.text$x:00002295
.text$x:0000229A
.text$x:0000229A ; =============== S U B R O U T I N E =======================================
.text$x:0000229A
.text$x:0000229A
.text$x:0000229A __unwindfunclet$??1FindOption@@QAE@XZ$2 proc near
.text$x:0000229A                                         ; DATA XREF: .xdata$x:0000438Co
.text$x:0000229A                 mov     ecx, [ebp-10h]
.text$x:0000229D                 add     ecx, 48h ; 'H'
.text$x:000022A0                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000022A0 __unwindfunclet$??1FindOption@@QAE@XZ$2 endp
.text$x:000022A0
.text$x:000022A5
.text$x:000022A5 ; =============== S U B R O U T I N E =======================================
.text$x:000022A5
.text$x:000022A5
.text$x:000022A5 __unwindfunclet$??1FindOption@@QAE@XZ$3 proc near
.text$x:000022A5                                         ; DATA XREF: .xdata$x:00004394o
.text$x:000022A5                 mov     ecx, [ebp-10h]
.text$x:000022A8                 add     ecx, 64h ; 'd'
.text$x:000022AB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000022AB __unwindfunclet$??1FindOption@@QAE@XZ$3 endp
.text$x:000022AB
.text$x:000022B0
.text$x:000022B0 ; =============== S U B R O U T I N E =======================================
.text$x:000022B0
.text$x:000022B0
.text$x:000022B0 __ehhandler$??1FindOption@@QAE@XZ proc near
.text$x:000022B0                                         ; DATA XREF: FindOption::~FindOption(void)+5o
.text$x:000022B0
.text$x:000022B0 arg_4           = dword ptr  8
.text$x:000022B0
.text$x:000022B0                 mov     edx, [esp+arg_4]
.text$x:000022B4                 lea     eax, [edx+0Ch]
.text$x:000022B7                 mov     ecx, [edx-8]
.text$x:000022BA                 xor     ecx, eax
.text$x:000022BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022C1                 mov     eax, offset __ehfuncinfo$??1FindOption@@QAE@XZ
.text$x:000022C6                 jmp     ___CxxFrameHandler3
.text$x:000022C6 __ehhandler$??1FindOption@@QAE@XZ endp
.text$x:000022C6
.text$x:000022C6 ; ---------------------------------------------------------------------------
.text$x:000022CB                 align 4
.text$x:000022CB _text$x         ends
.text$x:000022CB
.text$mn:000022CC ; ===========================================================================
.text$mn:000022CC
.text$mn:000022CC ; Segment type: Pure code
.text$mn:000022CC ; Segment permissions: Read/Execute
.text$mn:000022CC _text$mn        segment para public 'CODE' use32
.text$mn:000022CC                 assume cs:_text$mn
.text$mn:000022CC                 ;org 22CCh
.text$mn:000022CC ; COMDAT (pick any)
.text$mn:000022CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022CC
.text$mn:000022CC ; =============== S U B R O U T I N E =======================================
.text$mn:000022CC
.text$mn:000022CC ; Attributes: bp-based frame
.text$mn:000022CC
.text$mn:000022CC ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000022CC                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000022CC ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000022CC                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000022CC                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:000022CC
.text$mn:000022CC var_4           = dword ptr -4
.text$mn:000022CC
.text$mn:000022CC                 push    ebp
.text$mn:000022CD                 mov     ebp, esp
.text$mn:000022CF                 push    ecx
.text$mn:000022D0                 mov     [ebp+var_4], ecx
.text$mn:000022D3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000022D6                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000022DB                 mov     esp, ebp
.text$mn:000022DD                 pop     ebp
.text$mn:000022DE                 retn
.text$mn:000022DE ??1_Container_base12@std@@QAE@XZ endp
.text$mn:000022DE
.text$mn:000022DE ; ---------------------------------------------------------------------------
.text$mn:000022DF                 align 10h
.text$mn:000022DF _text$mn        ends
.text$mn:000022DF
.text$mn:000022E0 ; ===========================================================================
.text$mn:000022E0
.text$mn:000022E0 ; Segment type: Pure code
.text$mn:000022E0 ; Segment permissions: Read/Execute
.text$mn:000022E0 _text$mn        segment para public 'CODE' use32
.text$mn:000022E0                 assume cs:_text$mn
.text$mn:000022E0                 ;org 22E0h
.text$mn:000022E0 ; COMDAT (pick any)
.text$mn:000022E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022E0
.text$mn:000022E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022E0
.text$mn:000022E0 ; Attributes: bp-based frame
.text$mn:000022E0
.text$mn:000022E0 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000022E0                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:000022E0 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:000022E0                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:000022E0                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:000022E0
.text$mn:000022E0 var_10          = dword ptr -10h
.text$mn:000022E0 var_C           = dword ptr -0Ch
.text$mn:000022E0 var_4           = dword ptr -4
.text$mn:000022E0
.text$mn:000022E0                 push    ebp
.text$mn:000022E1                 mov     ebp, esp
.text$mn:000022E3                 push    0FFFFFFFFh
.text$mn:000022E5                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000022EA                 mov     eax, large fs:0
.text$mn:000022F0                 push    eax
.text$mn:000022F1                 push    ecx
.text$mn:000022F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022F7                 xor     eax, ebp
.text$mn:000022F9                 push    eax
.text$mn:000022FA                 lea     eax, [ebp+var_C]
.text$mn:000022FD                 mov     large fs:0, eax
.text$mn:00002303                 mov     [ebp+var_10], ecx
.text$mn:00002306                 mov     [ebp+var_4], 0
.text$mn:0000230D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002314                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002317                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000231C                 mov     ecx, [ebp+var_C]
.text$mn:0000231F                 mov     large fs:0, ecx
.text$mn:00002326                 pop     ecx
.text$mn:00002327                 mov     esp, ebp
.text$mn:00002329                 pop     ebp
.text$mn:0000232A                 retn
.text$mn:0000232A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000232A
.text$mn:0000232A ; ---------------------------------------------------------------------------
.text$mn:0000232B                 align 4
.text$mn:0000232B _text$mn        ends
.text$mn:0000232B
.text$x:0000232C ; ===========================================================================
.text$x:0000232C
.text$x:0000232C ; Segment type: Pure code
.text$x:0000232C ; Segment permissions: Read/Execute
.text$x:0000232C _text$x         segment para public 'CODE' use32
.text$x:0000232C                 assume cs:_text$x
.text$x:0000232C                 ;org 232Ch
.text$x:0000232C ; COMDAT (pick associative to section at 22E0)
.text$x:0000232C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000232C
.text$x:0000232C ; =============== S U B R O U T I N E =======================================
.text$x:0000232C
.text$x:0000232C
.text$x:0000232C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000232C                                         ; DATA XREF: .xdata$x:00004044o
.text$x:0000232C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000232F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000232F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000232F
.text$x:00002334
.text$x:00002334 ; =============== S U B R O U T I N E =======================================
.text$x:00002334
.text$x:00002334
.text$x:00002334 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00002334                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00002334
.text$x:00002334 arg_4           = dword ptr  8
.text$x:00002334
.text$x:00002334                 mov     edx, [esp+arg_4]
.text$x:00002338                 lea     eax, [edx+0Ch]
.text$x:0000233B                 mov     ecx, [edx-8]
.text$x:0000233E                 xor     ecx, eax
.text$x:00002340                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002345                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000234A                 jmp     ___CxxFrameHandler3
.text$x:0000234A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000234A
.text$x:0000234A ; ---------------------------------------------------------------------------
.text$x:0000234F                 align 10h
.text$x:0000234F _text$x         ends
.text$x:0000234F
.text$mn:00002350 ; ===========================================================================
.text$mn:00002350
.text$mn:00002350 ; Segment type: Pure code
.text$mn:00002350 ; Segment permissions: Read/Execute
.text$mn:00002350 _text$mn        segment para public 'CODE' use32
.text$mn:00002350                 assume cs:_text$mn
.text$mn:00002350                 ;org 2350h
.text$mn:00002350 ; COMDAT (pick any)
.text$mn:00002350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002350
.text$mn:00002350 ; =============== S U B R O U T I N E =======================================
.text$mn:00002350
.text$mn:00002350 ; Attributes: bp-based frame
.text$mn:00002350
.text$mn:00002350 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002350                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00002350 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00002350                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00002350                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002350
.text$mn:00002350 var_10          = dword ptr -10h
.text$mn:00002350 var_C           = dword ptr -0Ch
.text$mn:00002350 var_4           = dword ptr -4
.text$mn:00002350
.text$mn:00002350                 push    ebp
.text$mn:00002351                 mov     ebp, esp
.text$mn:00002353                 push    0FFFFFFFFh
.text$mn:00002355                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000235A                 mov     eax, large fs:0
.text$mn:00002360                 push    eax
.text$mn:00002361                 push    ecx
.text$mn:00002362                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002367                 xor     eax, ebp
.text$mn:00002369                 push    eax
.text$mn:0000236A                 lea     eax, [ebp+var_C]
.text$mn:0000236D                 mov     large fs:0, eax
.text$mn:00002373                 mov     [ebp+var_10], ecx
.text$mn:00002376                 mov     [ebp+var_4], 0
.text$mn:0000237D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002384                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002387                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000238C                 mov     ecx, [ebp+var_C]
.text$mn:0000238F                 mov     large fs:0, ecx
.text$mn:00002396                 pop     ecx
.text$mn:00002397                 mov     esp, ebp
.text$mn:00002399                 pop     ebp
.text$mn:0000239A                 retn
.text$mn:0000239A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000239A
.text$mn:0000239A ; ---------------------------------------------------------------------------
.text$mn:0000239B                 align 4
.text$mn:0000239B _text$mn        ends
.text$mn:0000239B
.text$x:0000239C ; ===========================================================================
.text$x:0000239C
.text$x:0000239C ; Segment type: Pure code
.text$x:0000239C ; Segment permissions: Read/Execute
.text$x:0000239C _text$x         segment para public 'CODE' use32
.text$x:0000239C                 assume cs:_text$x
.text$x:0000239C                 ;org 239Ch
.text$x:0000239C ; COMDAT (pick associative to section at 2350)
.text$x:0000239C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000239C
.text$x:0000239C ; =============== S U B R O U T I N E =======================================
.text$x:0000239C
.text$x:0000239C
.text$x:0000239C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:0000239C                                         ; DATA XREF: .xdata$x:000040C8o
.text$x:0000239C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000239F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000239F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:0000239F
.text$x:000023A4
.text$x:000023A4 ; =============== S U B R O U T I N E =======================================
.text$x:000023A4
.text$x:000023A4
.text$x:000023A4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000023A4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000023A4
.text$x:000023A4 arg_4           = dword ptr  8
.text$x:000023A4
.text$x:000023A4                 mov     edx, [esp+arg_4]
.text$x:000023A8                 lea     eax, [edx+0Ch]
.text$x:000023AB                 mov     ecx, [edx-8]
.text$x:000023AE                 xor     ecx, eax
.text$x:000023B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000023B5                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000023BA                 jmp     ___CxxFrameHandler3
.text$x:000023BA __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000023BA
.text$x:000023BA ; ---------------------------------------------------------------------------
.text$x:000023BF                 align 10h
.text$x:000023BF _text$x         ends
.text$x:000023BF
.text$mn:000023C0 ; ===========================================================================
.text$mn:000023C0
.text$mn:000023C0 ; Segment type: Pure code
.text$mn:000023C0 ; Segment permissions: Read/Execute
.text$mn:000023C0 _text$mn        segment para public 'CODE' use32
.text$mn:000023C0                 assume cs:_text$mn
.text$mn:000023C0                 ;org 23C0h
.text$mn:000023C0 ; COMDAT (pick any)
.text$mn:000023C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023C0
.text$mn:000023C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C0
.text$mn:000023C0 ; Attributes: bp-based frame
.text$mn:000023C0
.text$mn:000023C0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000023C0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000023C0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000023C0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000023C0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000023C0
.text$mn:000023C0 var_10          = dword ptr -10h
.text$mn:000023C0 var_C           = dword ptr -0Ch
.text$mn:000023C0 var_4           = dword ptr -4
.text$mn:000023C0
.text$mn:000023C0                 push    ebp
.text$mn:000023C1                 mov     ebp, esp
.text$mn:000023C3                 push    0FFFFFFFFh
.text$mn:000023C5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000023CA                 mov     eax, large fs:0
.text$mn:000023D0                 push    eax
.text$mn:000023D1                 push    ecx
.text$mn:000023D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000023D7                 xor     eax, ebp
.text$mn:000023D9                 push    eax
.text$mn:000023DA                 lea     eax, [ebp+var_C]
.text$mn:000023DD                 mov     large fs:0, eax
.text$mn:000023E3                 mov     [ebp+var_10], ecx
.text$mn:000023E6                 mov     [ebp+var_4], 0
.text$mn:000023ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000023F4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000023F7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000023FC                 mov     ecx, [ebp+var_C]
.text$mn:000023FF                 mov     large fs:0, ecx
.text$mn:00002406                 pop     ecx
.text$mn:00002407                 mov     esp, ebp
.text$mn:00002409                 pop     ebp
.text$mn:0000240A                 retn
.text$mn:0000240A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000240A
.text$mn:0000240A ; ---------------------------------------------------------------------------
.text$mn:0000240B                 align 4
.text$mn:0000240B _text$mn        ends
.text$mn:0000240B
.text$x:0000240C ; ===========================================================================
.text$x:0000240C
.text$x:0000240C ; Segment type: Pure code
.text$x:0000240C ; Segment permissions: Read/Execute
.text$x:0000240C _text$x         segment para public 'CODE' use32
.text$x:0000240C                 assume cs:_text$x
.text$x:0000240C                 ;org 240Ch
.text$x:0000240C ; COMDAT (pick associative to section at 23C0)
.text$x:0000240C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000240C
.text$x:0000240C ; =============== S U B R O U T I N E =======================================
.text$x:0000240C
.text$x:0000240C
.text$x:0000240C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000240C                                         ; DATA XREF: .xdata$x:0000414Co
.text$x:0000240C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000240F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000240F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000240F
.text$x:00002414
.text$x:00002414 ; =============== S U B R O U T I N E =======================================
.text$x:00002414
.text$x:00002414
.text$x:00002414 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00002414                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00002414
.text$x:00002414 arg_4           = dword ptr  8
.text$x:00002414
.text$x:00002414                 mov     edx, [esp+arg_4]
.text$x:00002418                 lea     eax, [edx+0Ch]
.text$x:0000241B                 mov     ecx, [edx-8]
.text$x:0000241E                 xor     ecx, eax
.text$x:00002420                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002425                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000242A                 jmp     ___CxxFrameHandler3
.text$x:0000242A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000242A
.text$x:0000242A ; ---------------------------------------------------------------------------
.text$x:0000242F                 align 10h
.text$x:0000242F _text$x         ends
.text$x:0000242F
.text$mn:00002430 ; ===========================================================================
.text$mn:00002430
.text$mn:00002430 ; Segment type: Pure code
.text$mn:00002430 ; Segment permissions: Read/Execute
.text$mn:00002430 _text$mn        segment para public 'CODE' use32
.text$mn:00002430                 assume cs:_text$mn
.text$mn:00002430                 ;org 2430h
.text$mn:00002430 ; COMDAT (pick any)
.text$mn:00002430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002430
.text$mn:00002430 ; =============== S U B R O U T I N E =======================================
.text$mn:00002430
.text$mn:00002430 ; Attributes: bp-based frame
.text$mn:00002430
.text$mn:00002430 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00002430                 public ??1error_category@std@@UAE@XZ
.text$mn:00002430 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00002430                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00002430
.text$mn:00002430 var_4           = dword ptr -4
.text$mn:00002430
.text$mn:00002430                 push    ebp
.text$mn:00002431                 mov     ebp, esp
.text$mn:00002433                 push    ecx
.text$mn:00002434                 mov     [ebp+var_4], ecx
.text$mn:00002437                 mov     eax, [ebp+var_4]
.text$mn:0000243A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00002440                 mov     esp, ebp
.text$mn:00002442                 pop     ebp
.text$mn:00002443                 retn
.text$mn:00002443 ??1error_category@std@@UAE@XZ endp
.text$mn:00002443
.text$mn:00002443 _text$mn        ends
.text$mn:00002443
.text$mn:00002444 ; ===========================================================================
.text$mn:00002444
.text$mn:00002444 ; Segment type: Pure code
.text$mn:00002444 ; Segment permissions: Read/Execute
.text$mn:00002444 _text$mn        segment para public 'CODE' use32
.text$mn:00002444                 assume cs:_text$mn
.text$mn:00002444                 ;org 2444h
.text$mn:00002444 ; COMDAT (pick any)
.text$mn:00002444                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002444
.text$mn:00002444 ; =============== S U B R O U T I N E =======================================
.text$mn:00002444
.text$mn:00002444 ; Attributes: bp-based frame
.text$mn:00002444
.text$mn:00002444 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00002444                 public ??2@YAPAXIPAX@Z
.text$mn:00002444 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00002444                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00002444
.text$mn:00002444 arg_4           = dword ptr  0Ch
.text$mn:00002444
.text$mn:00002444                 push    ebp
.text$mn:00002445                 mov     ebp, esp
.text$mn:00002447                 mov     eax, [ebp+arg_4]
.text$mn:0000244A                 pop     ebp
.text$mn:0000244B                 retn
.text$mn:0000244B ??2@YAPAXIPAX@Z endp
.text$mn:0000244B
.text$mn:0000244B _text$mn        ends
.text$mn:0000244B
.text$mn:0000244C ; ===========================================================================
.text$mn:0000244C
.text$mn:0000244C ; Segment type: Pure code
.text$mn:0000244C ; Segment permissions: Read/Execute
.text$mn:0000244C _text$mn        segment para public 'CODE' use32
.text$mn:0000244C                 assume cs:_text$mn
.text$mn:0000244C                 ;org 244Ch
.text$mn:0000244C ; COMDAT (pick any)
.text$mn:0000244C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000244C
.text$mn:0000244C ; =============== S U B R O U T I N E =======================================
.text$mn:0000244C
.text$mn:0000244C ; Attributes: bp-based frame
.text$mn:0000244C
.text$mn:0000244C ; void __cdecl operator delete(void *)
.text$mn:0000244C                 public ??3@YAXPAX0@Z
.text$mn:0000244C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:0000244C                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:0000244C                 push    ebp
.text$mn:0000244D                 mov     ebp, esp
.text$mn:0000244F                 pop     ebp
.text$mn:00002450                 retn
.text$mn:00002450 ??3@YAXPAX0@Z   endp
.text$mn:00002450
.text$mn:00002450 ; ---------------------------------------------------------------------------
.text$mn:00002451                 align 4
.text$mn:00002451 _text$mn        ends
.text$mn:00002451
.text$mn:00002454 ; ===========================================================================
.text$mn:00002454
.text$mn:00002454 ; Segment type: Pure code
.text$mn:00002454 ; Segment permissions: Read/Execute
.text$mn:00002454 _text$mn        segment para public 'CODE' use32
.text$mn:00002454                 assume cs:_text$mn
.text$mn:00002454                 ;org 2454h
.text$mn:00002454 ; COMDAT (pick any)
.text$mn:00002454                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002454
.text$mn:00002454 ; =============== S U B R O U T I N E =======================================
.text$mn:00002454
.text$mn:00002454 ; Attributes: bp-based frame
.text$mn:00002454
.text$mn:00002454 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00002454                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00002454 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00002454                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00002454                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00002454
.text$mn:00002454 var_8           = dword ptr -8
.text$mn:00002454 var_4           = dword ptr -4
.text$mn:00002454 arg_0           = dword ptr  8
.text$mn:00002454
.text$mn:00002454                 push    ebp
.text$mn:00002455                 mov     ebp, esp
.text$mn:00002457                 sub     esp, 8
.text$mn:0000245A                 mov     [ebp+var_8], ecx
.text$mn:0000245D                 mov     eax, [ebp+var_8]
.text$mn:00002460                 cmp     eax, [ebp+arg_0]
.text$mn:00002463                 jnz     short loc_246E
.text$mn:00002465                 mov     [ebp+var_4], 1
.text$mn:0000246C                 jmp     short loc_2475
.text$mn:0000246E ; ---------------------------------------------------------------------------
.text$mn:0000246E
.text$mn:0000246E loc_246E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000246E                 mov     [ebp+var_4], 0
.text$mn:00002475
.text$mn:00002475 loc_2475:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00002475                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002478                 mov     esp, ebp
.text$mn:0000247A                 pop     ebp
.text$mn:0000247B                 retn    4
.text$mn:0000247B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000247B
.text$mn:0000247B ; ---------------------------------------------------------------------------
.text$mn:0000247E                 align 10h
.text$mn:0000247E _text$mn        ends
.text$mn:0000247E
.text$mn:00002480 ; ===========================================================================
.text$mn:00002480
.text$mn:00002480 ; Segment type: Pure code
.text$mn:00002480 ; Segment permissions: Read/Execute
.text$mn:00002480 _text$mn        segment para public 'CODE' use32
.text$mn:00002480                 assume cs:_text$mn
.text$mn:00002480                 ;org 2480h
.text$mn:00002480 ; COMDAT (pick any)
.text$mn:00002480                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002480
.text$mn:00002480 ; =============== S U B R O U T I N E =======================================
.text$mn:00002480
.text$mn:00002480 ; Attributes: bp-based frame
.text$mn:00002480
.text$mn:00002480 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00002480                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00002480 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00002480                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00002480
.text$mn:00002480 var_8           = dword ptr -8
.text$mn:00002480 var_4           = dword ptr -4
.text$mn:00002480 arg_0           = dword ptr  8
.text$mn:00002480
.text$mn:00002480                 push    ebp
.text$mn:00002481                 mov     ebp, esp
.text$mn:00002483                 sub     esp, 8
.text$mn:00002486                 push    esi
.text$mn:00002487                 mov     [ebp+var_4], ecx
.text$mn:0000248A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000248D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00002492                 push    eax
.text$mn:00002493                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002496                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000249B                 mov     ecx, eax
.text$mn:0000249D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000024A2                 movzx   eax, al
.text$mn:000024A5                 test    eax, eax
.text$mn:000024A7                 jz      short loc_24C8
.text$mn:000024A9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000024AC                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000024B1                 mov     esi, eax
.text$mn:000024B3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000024B6                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000024BB                 cmp     esi, eax
.text$mn:000024BD                 jnz     short loc_24C8
.text$mn:000024BF                 mov     [ebp+var_8], 1
.text$mn:000024C6                 jmp     short loc_24CF
.text$mn:000024C8 ; ---------------------------------------------------------------------------
.text$mn:000024C8
.text$mn:000024C8 loc_24C8:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000024C8                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000024C8                 mov     [ebp+var_8], 0
.text$mn:000024CF
.text$mn:000024CF loc_24CF:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000024CF                 mov     al, byte ptr [ebp+var_8]
.text$mn:000024D2                 pop     esi
.text$mn:000024D3                 mov     esp, ebp
.text$mn:000024D5                 pop     ebp
.text$mn:000024D6                 retn    4
.text$mn:000024D6 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000024D6
.text$mn:000024D6 ; ---------------------------------------------------------------------------
.text$mn:000024D9                 align 4
.text$mn:000024D9 _text$mn        ends
.text$mn:000024D9
.text$mn:000024DC ; ===========================================================================
.text$mn:000024DC
.text$mn:000024DC ; Segment type: Pure code
.text$mn:000024DC ; Segment permissions: Read/Execute
.text$mn:000024DC _text$mn        segment para public 'CODE' use32
.text$mn:000024DC                 assume cs:_text$mn
.text$mn:000024DC                 ;org 24DCh
.text$mn:000024DC ; COMDAT (pick any)
.text$mn:000024DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024DC
.text$mn:000024DC ; =============== S U B R O U T I N E =======================================
.text$mn:000024DC
.text$mn:000024DC ; Attributes: bp-based frame
.text$mn:000024DC
.text$mn:000024DC ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000024DC                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000024DC ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000024DC
.text$mn:000024DC var_4           = dword ptr -4
.text$mn:000024DC arg_0           = dword ptr  8
.text$mn:000024DC
.text$mn:000024DC                 push    ebp
.text$mn:000024DD                 mov     ebp, esp
.text$mn:000024DF                 push    ecx
.text$mn:000024E0                 mov     [ebp+var_4], ecx
.text$mn:000024E3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000024E6                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000024EB                 mov     eax, [ebp+arg_0]
.text$mn:000024EE                 and     eax, 1
.text$mn:000024F1                 jz      short loc_24FF
.text$mn:000024F3                 mov     ecx, [ebp+var_4]
.text$mn:000024F6                 push    ecx             ; void *
.text$mn:000024F7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000024FC                 add     esp, 4
.text$mn:000024FF
.text$mn:000024FF loc_24FF:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000024FF                 mov     eax, [ebp+var_4]
.text$mn:00002502                 mov     esp, ebp
.text$mn:00002504                 pop     ebp
.text$mn:00002505                 retn    4
.text$mn:00002505 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00002505
.text$mn:00002505 _text$mn        ends
.text$mn:00002505
.text$mn:00002508 ; ===========================================================================
.text$mn:00002508
.text$mn:00002508 ; Segment type: Pure code
.text$mn:00002508 ; Segment permissions: Read/Execute
.text$mn:00002508 _text$mn        segment para public 'CODE' use32
.text$mn:00002508                 assume cs:_text$mn
.text$mn:00002508                 ;org 2508h
.text$mn:00002508 ; COMDAT (pick any)
.text$mn:00002508                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002508
.text$mn:00002508 ; =============== S U B R O U T I N E =======================================
.text$mn:00002508
.text$mn:00002508 ; Attributes: bp-based frame
.text$mn:00002508
.text$mn:00002508 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002508                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00002508 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00002508
.text$mn:00002508 var_4           = dword ptr -4
.text$mn:00002508 arg_0           = dword ptr  8
.text$mn:00002508
.text$mn:00002508                 push    ebp
.text$mn:00002509                 mov     ebp, esp
.text$mn:0000250B                 push    ecx
.text$mn:0000250C                 mov     [ebp+var_4], ecx
.text$mn:0000250F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002512                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00002517                 mov     eax, [ebp+arg_0]
.text$mn:0000251A                 and     eax, 1
.text$mn:0000251D                 jz      short loc_252B
.text$mn:0000251F                 mov     ecx, [ebp+var_4]
.text$mn:00002522                 push    ecx             ; void *
.text$mn:00002523                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002528                 add     esp, 4
.text$mn:0000252B
.text$mn:0000252B loc_252B:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000252B                 mov     eax, [ebp+var_4]
.text$mn:0000252E                 mov     esp, ebp
.text$mn:00002530                 pop     ebp
.text$mn:00002531                 retn    4
.text$mn:00002531 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00002531
.text$mn:00002531 _text$mn        ends
.text$mn:00002531
.text$mn:00002534 ; ===========================================================================
.text$mn:00002534
.text$mn:00002534 ; Segment type: Pure code
.text$mn:00002534 ; Segment permissions: Read/Execute
.text$mn:00002534 _text$mn        segment para public 'CODE' use32
.text$mn:00002534                 assume cs:_text$mn
.text$mn:00002534                 ;org 2534h
.text$mn:00002534 ; COMDAT (pick any)
.text$mn:00002534                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002534
.text$mn:00002534 ; =============== S U B R O U T I N E =======================================
.text$mn:00002534
.text$mn:00002534 ; Attributes: bp-based frame
.text$mn:00002534
.text$mn:00002534 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002534                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00002534 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00002534
.text$mn:00002534 var_4           = dword ptr -4
.text$mn:00002534 arg_0           = dword ptr  8
.text$mn:00002534
.text$mn:00002534                 push    ebp
.text$mn:00002535                 mov     ebp, esp
.text$mn:00002537                 push    ecx
.text$mn:00002538                 mov     [ebp+var_4], ecx
.text$mn:0000253B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000253E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00002543                 mov     eax, [ebp+arg_0]
.text$mn:00002546                 and     eax, 1
.text$mn:00002549                 jz      short loc_2557
.text$mn:0000254B                 mov     ecx, [ebp+var_4]
.text$mn:0000254E                 push    ecx             ; void *
.text$mn:0000254F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002554                 add     esp, 4
.text$mn:00002557
.text$mn:00002557 loc_2557:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002557                 mov     eax, [ebp+var_4]
.text$mn:0000255A                 mov     esp, ebp
.text$mn:0000255C                 pop     ebp
.text$mn:0000255D                 retn    4
.text$mn:0000255D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:0000255D
.text$mn:0000255D _text$mn        ends
.text$mn:0000255D
.text$mn:00002560 ; ===========================================================================
.text$mn:00002560
.text$mn:00002560 ; Segment type: Pure code
.text$mn:00002560 ; Segment permissions: Read/Execute
.text$mn:00002560 _text$mn        segment para public 'CODE' use32
.text$mn:00002560                 assume cs:_text$mn
.text$mn:00002560                 ;org 2560h
.text$mn:00002560 ; COMDAT (pick any)
.text$mn:00002560                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002560
.text$mn:00002560 ; =============== S U B R O U T I N E =======================================
.text$mn:00002560
.text$mn:00002560 ; Attributes: bp-based frame
.text$mn:00002560
.text$mn:00002560 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002560                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00002560 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00002560
.text$mn:00002560 var_4           = dword ptr -4
.text$mn:00002560 arg_0           = dword ptr  8
.text$mn:00002560
.text$mn:00002560                 push    ebp
.text$mn:00002561                 mov     ebp, esp
.text$mn:00002563                 push    ecx
.text$mn:00002564                 mov     [ebp+var_4], ecx
.text$mn:00002567                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000256A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000256F                 mov     eax, [ebp+arg_0]
.text$mn:00002572                 and     eax, 1
.text$mn:00002575                 jz      short loc_2583
.text$mn:00002577                 mov     ecx, [ebp+var_4]
.text$mn:0000257A                 push    ecx             ; void *
.text$mn:0000257B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002580                 add     esp, 4
.text$mn:00002583
.text$mn:00002583 loc_2583:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002583                 mov     eax, [ebp+var_4]
.text$mn:00002586                 mov     esp, ebp
.text$mn:00002588                 pop     ebp
.text$mn:00002589                 retn    4
.text$mn:00002589 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00002589
.text$mn:00002589 _text$mn        ends
.text$mn:00002589
.text$di:0000258C ; ===========================================================================
.text$di:0000258C
.text$di:0000258C ; Segment type: Pure code
.text$di:0000258C ; Segment permissions: Read/Execute
.text$di:0000258C _text$di        segment para public 'CODE' use32
.text$di:0000258C                 assume cs:_text$di
.text$di:0000258C                 ;org 258Ch
.text$di:0000258C ; COMDAT (pick any)
.text$di:0000258C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:0000258C
.text$di:0000258C ; =============== S U B R O U T I N E =======================================
.text$di:0000258C
.text$di:0000258C ; Attributes: bp-based frame
.text$di:0000258C
.text$di:0000258C ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:0000258C ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:0000258C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:0000258C                 push    ebp
.text$di:0000258D                 mov     ebp, esp
.text$di:0000258F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00002594                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00002599                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000259E                 call    _atexit
.text$di:000025A3                 add     esp, 4
.text$di:000025A6                 pop     ebp
.text$di:000025A7                 retn
.text$di:000025A7 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000025A7
.text$di:000025A7 _text$di        ends
.text$di:000025A7
.text$di:000025A8 ; ===========================================================================
.text$di:000025A8
.text$di:000025A8 ; Segment type: Pure code
.text$di:000025A8 ; Segment permissions: Read/Execute
.text$di:000025A8 _text$di        segment para public 'CODE' use32
.text$di:000025A8                 assume cs:_text$di
.text$di:000025A8                 ;org 25A8h
.text$di:000025A8 ; COMDAT (pick any)
.text$di:000025A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000025A8
.text$di:000025A8 ; =============== S U B R O U T I N E =======================================
.text$di:000025A8
.text$di:000025A8 ; Attributes: bp-based frame
.text$di:000025A8
.text$di:000025A8 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000025A8 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000025A8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000025A8                 push    ebp
.text$di:000025A9                 mov     ebp, esp
.text$di:000025AB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000025B0                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000025B5                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000025BA                 call    _atexit
.text$di:000025BF                 add     esp, 4
.text$di:000025C2                 pop     ebp
.text$di:000025C3                 retn
.text$di:000025C3 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000025C3
.text$di:000025C3 _text$di        ends
.text$di:000025C3
.text$di:000025C4 ; ===========================================================================
.text$di:000025C4
.text$di:000025C4 ; Segment type: Pure code
.text$di:000025C4 ; Segment permissions: Read/Execute
.text$di:000025C4 _text$di        segment para public 'CODE' use32
.text$di:000025C4                 assume cs:_text$di
.text$di:000025C4                 ;org 25C4h
.text$di:000025C4 ; COMDAT (pick any)
.text$di:000025C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000025C4
.text$di:000025C4 ; =============== S U B R O U T I N E =======================================
.text$di:000025C4
.text$di:000025C4 ; Attributes: bp-based frame
.text$di:000025C4
.text$di:000025C4 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000025C4 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000025C4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000025C4                 push    ebp
.text$di:000025C5                 mov     ebp, esp
.text$di:000025C7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000025CC                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000025D1                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000025D6                 call    _atexit
.text$di:000025DB                 add     esp, 4
.text$di:000025DE                 pop     ebp
.text$di:000025DF                 retn
.text$di:000025DF ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000025DF
.text$di:000025DF _text$di        ends
.text$di:000025DF
.text$di:000025E0 ; ===========================================================================
.text$di:000025E0
.text$di:000025E0 ; Segment type: Pure code
.text$di:000025E0 ; Segment permissions: Read/Execute
.text$di:000025E0 _text$di        segment para public 'CODE' use32
.text$di:000025E0                 assume cs:_text$di
.text$di:000025E0                 ;org 25E0h
.text$di:000025E0 ; COMDAT (pick any)
.text$di:000025E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000025E0
.text$di:000025E0 ; =============== S U B R O U T I N E =======================================
.text$di:000025E0
.text$di:000025E0 ; Attributes: bp-based frame
.text$di:000025E0
.text$di:000025E0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:000025E0 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000025E0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:000025E0                 push    ebp
.text$di:000025E1                 mov     ebp, esp
.text$di:000025E3                 push    0               ; unsigned int
.text$di:000025E5                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000025EA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000025EF                 pop     ebp
.text$di:000025F0                 retn
.text$di:000025F0 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000025F0
.text$di:000025F0 ; ---------------------------------------------------------------------------
.text$di:000025F1                 align 4
.text$di:000025F1 _text$di        ends
.text$di:000025F1
.text$di:000025F4 ; ===========================================================================
.text$di:000025F4
.text$di:000025F4 ; Segment type: Pure code
.text$di:000025F4 ; Segment permissions: Read/Execute
.text$di:000025F4 _text$di        segment para public 'CODE' use32
.text$di:000025F4                 assume cs:_text$di
.text$di:000025F4                 ;org 25F4h
.text$di:000025F4 ; COMDAT (pick any)
.text$di:000025F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000025F4
.text$di:000025F4 ; =============== S U B R O U T I N E =======================================
.text$di:000025F4
.text$di:000025F4 ; Attributes: bp-based frame
.text$di:000025F4
.text$di:000025F4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000025F4 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000025F4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000025F4                 push    ebp
.text$di:000025F5                 mov     ebp, esp
.text$di:000025F7                 push    0               ; unsigned int
.text$di:000025F9                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000025FE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00002603                 pop     ebp
.text$di:00002604                 retn
.text$di:00002604 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00002604
.text$di:00002604 ; ---------------------------------------------------------------------------
.text$di:00002605                 align 4
.text$di:00002605 _text$di        ends
.text$di:00002605
.text$di:00002608 ; ===========================================================================
.text$di:00002608
.text$di:00002608 ; Segment type: Pure code
.text$di:00002608 ; Segment permissions: Read/Execute
.text$di:00002608 _text$di        segment para public 'CODE' use32
.text$di:00002608                 assume cs:_text$di
.text$di:00002608                 ;org 2608h
.text$di:00002608 ; COMDAT (pick any)
.text$di:00002608                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002608
.text$di:00002608 ; =============== S U B R O U T I N E =======================================
.text$di:00002608
.text$di:00002608 ; Attributes: bp-based frame
.text$di:00002608
.text$di:00002608 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00002608 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00002608                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00002608                 push    ebp
.text$di:00002609                 mov     ebp, esp
.text$di:0000260B                 push    0               ; unsigned int
.text$di:0000260D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00002612                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00002617                 pop     ebp
.text$di:00002618                 retn
.text$di:00002618 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00002618
.text$di:00002618 ; ---------------------------------------------------------------------------
.text$di:00002619                 align 4
.text$di:00002619 _text$di        ends
.text$di:00002619
.text$di:0000261C ; ===========================================================================
.text$di:0000261C
.text$di:0000261C ; Segment type: Pure code
.text$di:0000261C ; Segment permissions: Read/Execute
.text$di:0000261C _text$di        segment para public 'CODE' use32
.text$di:0000261C                 assume cs:_text$di
.text$di:0000261C                 ;org 261Ch
.text$di:0000261C ; COMDAT (pick any)
.text$di:0000261C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:0000261C
.text$di:0000261C ; =============== S U B R O U T I N E =======================================
.text$di:0000261C
.text$di:0000261C ; Attributes: bp-based frame
.text$di:0000261C
.text$di:0000261C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:0000261C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000261C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:0000261C                 push    ebp
.text$di:0000261D                 mov     ebp, esp
.text$di:0000261F                 push    0               ; unsigned int
.text$di:00002621                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00002626                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000262B                 pop     ebp
.text$di:0000262C                 retn
.text$di:0000262C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000262C
.text$di:0000262C ; ---------------------------------------------------------------------------
.text$di:0000262D                 align 10h
.text$di:0000262D _text$di        ends
.text$di:0000262D
.text$di:00002630 ; ===========================================================================
.text$di:00002630
.text$di:00002630 ; Segment type: Pure code
.text$di:00002630 ; Segment permissions: Read/Execute
.text$di:00002630 _text$di        segment para public 'CODE' use32
.text$di:00002630                 assume cs:_text$di
.text$di:00002630                 ;org 2630h
.text$di:00002630 ; COMDAT (pick any)
.text$di:00002630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002630
.text$di:00002630 ; =============== S U B R O U T I N E =======================================
.text$di:00002630
.text$di:00002630 ; Attributes: bp-based frame
.text$di:00002630
.text$di:00002630 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00002630 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00002630
.text$di:00002630 var_1           = byte ptr -1
.text$di:00002630
.text$di:00002630                 push    ebp
.text$di:00002631                 mov     ebp, esp
.text$di:00002633                 push    ecx
.text$di:00002634                 xor     eax, eax
.text$di:00002636                 mov     [ebp+var_1], al
.text$di:00002639                 mov     esp, ebp
.text$di:0000263B                 pop     ebp
.text$di:0000263C                 retn
.text$di:0000263C ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:0000263C
.text$di:0000263C ; ---------------------------------------------------------------------------
.text$di:0000263D                 align 10h
.text$di:0000263D _text$di        ends
.text$di:0000263D
.text$di:00002640 ; ===========================================================================
.text$di:00002640
.text$di:00002640 ; Segment type: Pure code
.text$di:00002640 ; Segment permissions: Read/Execute
.text$di:00002640 _text$di        segment para public 'CODE' use32
.text$di:00002640                 assume cs:_text$di
.text$di:00002640                 ;org 2640h
.text$di:00002640 ; COMDAT (pick any)
.text$di:00002640                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002640
.text$di:00002640 ; =============== S U B R O U T I N E =======================================
.text$di:00002640
.text$di:00002640 ; Attributes: bp-based frame
.text$di:00002640
.text$di:00002640 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00002640 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00002640
.text$di:00002640 var_1           = byte ptr -1
.text$di:00002640
.text$di:00002640                 push    ebp
.text$di:00002641                 mov     ebp, esp
.text$di:00002643                 push    ecx
.text$di:00002644                 xor     eax, eax
.text$di:00002646                 mov     [ebp+var_1], al
.text$di:00002649                 mov     esp, ebp
.text$di:0000264B                 pop     ebp
.text$di:0000264C                 retn
.text$di:0000264C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:0000264C
.text$di:0000264C ; ---------------------------------------------------------------------------
.text$di:0000264D                 align 10h
.text$di:0000264D _text$di        ends
.text$di:0000264D
.text$di:00002650 ; ===========================================================================
.text$di:00002650
.text$di:00002650 ; Segment type: Pure code
.text$di:00002650 ; Segment permissions: Read/Execute
.text$di:00002650 _text$di        segment para public 'CODE' use32
.text$di:00002650                 assume cs:_text$di
.text$di:00002650                 ;org 2650h
.text$di:00002650 ; COMDAT (pick any)
.text$di:00002650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002650
.text$di:00002650 ; =============== S U B R O U T I N E =======================================
.text$di:00002650
.text$di:00002650 ; Attributes: bp-based frame
.text$di:00002650
.text$di:00002650 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00002650 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00002650                 push    ebp
.text$di:00002651                 mov     ebp, esp
.text$di:00002653                 mov     ecx, offset _ignore ; this
.text$di:00002658                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:0000265D                 pop     ebp
.text$di:0000265E                 retn
.text$di:0000265E ??__Eignore@std@@YAXXZ endp
.text$di:0000265E
.text$di:0000265E ; ---------------------------------------------------------------------------
.text$di:0000265F                 align 10h
.text$di:0000265F _text$di        ends
.text$di:0000265F
.text$di:00002660 ; ===========================================================================
.text$di:00002660
.text$di:00002660 ; Segment type: Pure code
.text$di:00002660 ; Segment permissions: Read/Execute
.text$di:00002660 _text$di        segment para public 'CODE' use32
.text$di:00002660                 assume cs:_text$di
.text$di:00002660                 ;org 2660h
.text$di:00002660 ; COMDAT (pick any)
.text$di:00002660                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00002660
.text$di:00002660 ; =============== S U B R O U T I N E =======================================
.text$di:00002660
.text$di:00002660 ; Attributes: bp-based frame
.text$di:00002660
.text$di:00002660 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00002660 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00002660                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00002660
.text$di:00002660 var_1           = byte ptr -1
.text$di:00002660
.text$di:00002660                 push    ebp
.text$di:00002661                 mov     ebp, esp
.text$di:00002663                 push    ecx
.text$di:00002664                 xor     eax, eax
.text$di:00002666                 mov     [ebp+var_1], al
.text$di:00002669                 mov     esp, ebp
.text$di:0000266B                 pop     ebp
.text$di:0000266C                 retn
.text$di:0000266C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:0000266C
.text$di:0000266C ; ---------------------------------------------------------------------------
.text$di:0000266D                 align 10h
.text$di:0000266D _text$di        ends
.text$di:0000266D
.text$yd:00002670 ; ===========================================================================
.text$yd:00002670
.text$yd:00002670 ; Segment type: Pure code
.text$yd:00002670 ; Segment permissions: Read/Execute
.text$yd:00002670 _text$yd        segment para public 'CODE' use32
.text$yd:00002670                 assume cs:_text$yd
.text$yd:00002670                 ;org 2670h
.text$yd:00002670 ; COMDAT (pick any)
.text$yd:00002670                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00002670
.text$yd:00002670 ; =============== S U B R O U T I N E =======================================
.text$yd:00002670
.text$yd:00002670 ; Attributes: bp-based frame
.text$yd:00002670
.text$yd:00002670 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00002670 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00002670                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00002670                 push    ebp
.text$yd:00002671                 mov     ebp, esp
.text$yd:00002673                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00002678                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:0000267D                 pop     ebp
.text$yd:0000267E                 retn
.text$yd:0000267E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000267E
.text$yd:0000267E ; ---------------------------------------------------------------------------
.text$yd:0000267F                 align 10h
.text$yd:0000267F _text$yd        ends
.text$yd:0000267F
.text$yd:00002680 ; ===========================================================================
.text$yd:00002680
.text$yd:00002680 ; Segment type: Pure code
.text$yd:00002680 ; Segment permissions: Read/Execute
.text$yd:00002680 _text$yd        segment para public 'CODE' use32
.text$yd:00002680                 assume cs:_text$yd
.text$yd:00002680                 ;org 2680h
.text$yd:00002680 ; COMDAT (pick any)
.text$yd:00002680                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00002680
.text$yd:00002680 ; =============== S U B R O U T I N E =======================================
.text$yd:00002680
.text$yd:00002680 ; Attributes: bp-based frame
.text$yd:00002680
.text$yd:00002680 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00002680 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00002680                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00002680                 push    ebp
.text$yd:00002681                 mov     ebp, esp
.text$yd:00002683                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00002688                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:0000268D                 pop     ebp
.text$yd:0000268E                 retn
.text$yd:0000268E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000268E
.text$yd:0000268E ; ---------------------------------------------------------------------------
.text$yd:0000268F                 align 10h
.text$yd:0000268F _text$yd        ends
.text$yd:0000268F
.text$yd:00002690 ; ===========================================================================
.text$yd:00002690
.text$yd:00002690 ; Segment type: Pure code
.text$yd:00002690 ; Segment permissions: Read/Execute
.text$yd:00002690 _text$yd        segment para public 'CODE' use32
.text$yd:00002690                 assume cs:_text$yd
.text$yd:00002690                 ;org 2690h
.text$yd:00002690 ; COMDAT (pick any)
.text$yd:00002690                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00002690
.text$yd:00002690 ; =============== S U B R O U T I N E =======================================
.text$yd:00002690
.text$yd:00002690 ; Attributes: bp-based frame
.text$yd:00002690
.text$yd:00002690 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00002690 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00002690                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00002690                 push    ebp
.text$yd:00002691                 mov     ebp, esp
.text$yd:00002693                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00002698                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:0000269D                 pop     ebp
.text$yd:0000269E                 retn
.text$yd:0000269E ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:0000269E
.text$yd:0000269E ; ---------------------------------------------------------------------------
.text$yd:0000269F                 align 10h
.text$yd:0000269F _text$yd        ends
.text$yd:0000269F
.text$mn:000026A0 ; ===========================================================================
.text$mn:000026A0
.text$mn:000026A0 ; Segment type: Pure code
.text$mn:000026A0 ; Segment permissions: Read/Execute
.text$mn:000026A0 _text$mn        segment para public 'CODE' use32
.text$mn:000026A0                 assume cs:_text$mn
.text$mn:000026A0                 ;org 26A0h
.text$mn:000026A0 ; COMDAT (pick any)
.text$mn:000026A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026A0
.text$mn:000026A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026A0
.text$mn:000026A0 ; Attributes: bp-based frame
.text$mn:000026A0
.text$mn:000026A0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000026A0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000026A0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000026A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000026A0
.text$mn:000026A0 var_10          = byte ptr -10h
.text$mn:000026A0 var_8           = dword ptr -8
.text$mn:000026A0 var_1           = byte ptr -1
.text$mn:000026A0
.text$mn:000026A0                 push    ebp
.text$mn:000026A1                 mov     ebp, esp
.text$mn:000026A3                 sub     esp, 10h
.text$mn:000026A6                 mov     [ebp+var_8], ecx
.text$mn:000026A9                 lea     ecx, [ebp+var_1]
.text$mn:000026AC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000026B1                 push    1
.text$mn:000026B3                 lea     ecx, [ebp+var_1]
.text$mn:000026B6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000026BB                 mov     ecx, [ebp+var_8]
.text$mn:000026BE                 mov     [ecx], eax
.text$mn:000026C0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000026C3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000026C8                 push    eax             ; int
.text$mn:000026C9                 mov     edx, [ebp+var_8]
.text$mn:000026CC                 mov     eax, [edx]
.text$mn:000026CE                 push    eax             ; void *
.text$mn:000026CF                 lea     ecx, [ebp+var_1]
.text$mn:000026D2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000026D7                 mov     ecx, [ebp+var_8]
.text$mn:000026DA                 mov     edx, [ecx]
.text$mn:000026DC                 mov     eax, [ebp+var_8]
.text$mn:000026DF                 mov     [edx], eax
.text$mn:000026E1                 mov     esp, ebp
.text$mn:000026E3                 pop     ebp
.text$mn:000026E4                 retn
.text$mn:000026E4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000026E4
.text$mn:000026E4 ; ---------------------------------------------------------------------------
.text$mn:000026E5                 align 4
.text$mn:000026E5 _text$mn        ends
.text$mn:000026E5
.text$mn:000026E8 ; ===========================================================================
.text$mn:000026E8
.text$mn:000026E8 ; Segment type: Pure code
.text$mn:000026E8 ; Segment permissions: Read/Execute
.text$mn:000026E8 _text$mn        segment para public 'CODE' use32
.text$mn:000026E8                 assume cs:_text$mn
.text$mn:000026E8                 ;org 26E8h
.text$mn:000026E8 ; COMDAT (pick any)
.text$mn:000026E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026E8
.text$mn:000026E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026E8
.text$mn:000026E8 ; Attributes: bp-based frame
.text$mn:000026E8
.text$mn:000026E8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000026E8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000026E8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000026E8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:000026E8
.text$mn:000026E8 var_10          = byte ptr -10h
.text$mn:000026E8 var_8           = dword ptr -8
.text$mn:000026E8 var_1           = byte ptr -1
.text$mn:000026E8
.text$mn:000026E8                 push    ebp
.text$mn:000026E9                 mov     ebp, esp
.text$mn:000026EB                 sub     esp, 10h
.text$mn:000026EE                 mov     [ebp+var_8], ecx
.text$mn:000026F1                 lea     ecx, [ebp+var_1]
.text$mn:000026F4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000026F9                 push    1
.text$mn:000026FB                 lea     ecx, [ebp+var_1]
.text$mn:000026FE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00002703                 mov     ecx, [ebp+var_8]
.text$mn:00002706                 mov     [ecx], eax
.text$mn:00002708                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000270B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00002710                 push    eax             ; int
.text$mn:00002711                 mov     edx, [ebp+var_8]
.text$mn:00002714                 mov     eax, [edx]
.text$mn:00002716                 push    eax             ; void *
.text$mn:00002717                 lea     ecx, [ebp+var_1]
.text$mn:0000271A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000271F                 mov     ecx, [ebp+var_8]
.text$mn:00002722                 mov     edx, [ecx]
.text$mn:00002724                 mov     eax, [ebp+var_8]
.text$mn:00002727                 mov     [edx], eax
.text$mn:00002729                 mov     esp, ebp
.text$mn:0000272B                 pop     ebp
.text$mn:0000272C                 retn
.text$mn:0000272C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000272C
.text$mn:0000272C ; ---------------------------------------------------------------------------
.text$mn:0000272D                 align 10h
.text$mn:0000272D _text$mn        ends
.text$mn:0000272D
.text$mn:00002730 ; ===========================================================================
.text$mn:00002730
.text$mn:00002730 ; Segment type: Pure code
.text$mn:00002730 ; Segment permissions: Read/Execute
.text$mn:00002730 _text$mn        segment para public 'CODE' use32
.text$mn:00002730                 assume cs:_text$mn
.text$mn:00002730                 ;org 2730h
.text$mn:00002730 ; COMDAT (pick any)
.text$mn:00002730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002730
.text$mn:00002730 ; =============== S U B R O U T I N E =======================================
.text$mn:00002730
.text$mn:00002730 ; Attributes: bp-based frame
.text$mn:00002730
.text$mn:00002730 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00002730                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00002730 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00002730                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00002730
.text$mn:00002730 var_20          = dword ptr -20h
.text$mn:00002730 var_1C          = dword ptr -1Ch
.text$mn:00002730 var_18          = dword ptr -18h
.text$mn:00002730 var_11          = byte ptr -11h
.text$mn:00002730 var_10          = dword ptr -10h
.text$mn:00002730 var_C           = byte ptr -0Ch
.text$mn:00002730 var_4           = dword ptr -4
.text$mn:00002730 arg_0           = dword ptr  8
.text$mn:00002730
.text$mn:00002730 ; FUNCTION CHUNK AT .text$mn:00002852 SIZE 00000009 BYTES
.text$mn:00002730
.text$mn:00002730                 push    ebp
.text$mn:00002731                 mov     ebp, esp
.text$mn:00002733                 push    0FFFFFFFFh
.text$mn:00002735                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000273A                 mov     eax, large fs:0
.text$mn:00002740                 push    eax
.text$mn:00002741                 push    ecx
.text$mn:00002742                 sub     esp, 10h
.text$mn:00002745                 push    ebx
.text$mn:00002746                 push    esi
.text$mn:00002747                 push    edi
.text$mn:00002748                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000274D                 xor     eax, ebp
.text$mn:0000274F                 push    eax
.text$mn:00002750                 lea     eax, [ebp+var_C]
.text$mn:00002753                 mov     large fs:0, eax
.text$mn:00002759                 mov     [ebp+var_10], esp
.text$mn:0000275C                 mov     [ebp+var_18], ecx
.text$mn:0000275F                 mov     eax, [ebp+arg_0]
.text$mn:00002762                 or      eax, 0Fh
.text$mn:00002765                 mov     [ebp+var_1C], eax
.text$mn:00002768                 mov     ecx, [ebp+var_18]
.text$mn:0000276B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002770                 cmp     eax, [ebp+var_1C]
.text$mn:00002773                 jnb     short loc_277D
.text$mn:00002775                 mov     ecx, [ebp+arg_0]
.text$mn:00002778                 mov     [ebp+var_1C], ecx
.text$mn:0000277B                 jmp     short loc_27CF
.text$mn:0000277D ; ---------------------------------------------------------------------------
.text$mn:0000277D
.text$mn:0000277D loc_277D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:0000277D                 mov     edx, [ebp+var_18]
.text$mn:00002780                 mov     ecx, [edx+18h]
.text$mn:00002783                 shr     ecx, 1
.text$mn:00002785                 mov     eax, [ebp+var_1C]
.text$mn:00002788                 xor     edx, edx
.text$mn:0000278A                 mov     esi, 3
.text$mn:0000278F                 div     esi
.text$mn:00002791                 cmp     ecx, eax
.text$mn:00002793                 ja      short loc_2797
.text$mn:00002795                 jmp     short loc_27CF
.text$mn:00002797 ; ---------------------------------------------------------------------------
.text$mn:00002797
.text$mn:00002797 loc_2797:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00002797                 mov     ecx, [ebp+var_18]
.text$mn:0000279A                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000279F                 mov     edx, [ebp+var_18]
.text$mn:000027A2                 mov     ecx, [edx+18h]
.text$mn:000027A5                 shr     ecx, 1
.text$mn:000027A7                 sub     eax, ecx
.text$mn:000027A9                 mov     edx, [ebp+var_18]
.text$mn:000027AC                 cmp     [edx+18h], eax
.text$mn:000027AF                 ja      short loc_27C4
.text$mn:000027B1                 mov     eax, [ebp+var_18]
.text$mn:000027B4                 mov     ecx, [eax+18h]
.text$mn:000027B7                 shr     ecx, 1
.text$mn:000027B9                 mov     edx, [ebp+var_18]
.text$mn:000027BC                 add     ecx, [edx+18h]
.text$mn:000027BF                 mov     [ebp+var_1C], ecx
.text$mn:000027C2                 jmp     short loc_27CF
.text$mn:000027C4 ; ---------------------------------------------------------------------------
.text$mn:000027C4
.text$mn:000027C4 loc_27C4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000027C4                 mov     ecx, [ebp+var_18]
.text$mn:000027C7                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000027CC                 mov     [ebp+var_1C], eax
.text$mn:000027CF
.text$mn:000027CF loc_27CF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000027CF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000027CF                 mov     [ebp+var_4], 0
.text$mn:000027D6                 mov     eax, [ebp+var_1C]
.text$mn:000027D9                 add     eax, 1
.text$mn:000027DC                 push    eax
.text$mn:000027DD                 lea     ecx, [ebp+var_11]
.text$mn:000027E0                 push    ecx
.text$mn:000027E1                 mov     ecx, [ebp+var_18]
.text$mn:000027E4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000027E9                 mov     ecx, eax
.text$mn:000027EB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000027F0                 mov     [ebp+var_20], eax
.text$mn:000027F3                 jmp     short loc_2852
.text$mn:000027F3 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000027F3
.text$mn:000027F5
.text$mn:000027F5 ; =============== S U B R O U T I N E =======================================
.text$mn:000027F5
.text$mn:000027F5
.text$mn:000027F5 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000027F5                                         ; DATA XREF: .xdata$x:00003F68o
.text$mn:000027F5
.text$mn:000027F5 ; FUNCTION CHUNK AT .text$mn:0000283C SIZE 00000009 BYTES
.text$mn:000027F5 ; FUNCTION CHUNK AT .text$mn:0000284C SIZE 00000006 BYTES
.text$mn:000027F5
.text$mn:000027F5                 mov     [ebp-10h], esp
.text$mn:000027F8                 mov     edx, [ebp+8]
.text$mn:000027FB                 mov     [ebp-1Ch], edx
.text$mn:000027FE                 mov     byte ptr [ebp-4], 2
.text$mn:00002802                 mov     eax, [ebp-1Ch]
.text$mn:00002805                 add     eax, 1
.text$mn:00002808                 push    eax
.text$mn:00002809                 lea     ecx, [ebp-12h]
.text$mn:0000280C                 push    ecx
.text$mn:0000280D                 mov     ecx, [ebp-18h]
.text$mn:00002810                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002815                 mov     ecx, eax
.text$mn:00002817                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000281C                 mov     [ebp-20h], eax
.text$mn:0000281F                 jmp     short loc_283C
.text$mn:0000281F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000281F
.text$mn:00002821
.text$mn:00002821 ; =============== S U B R O U T I N E =======================================
.text$mn:00002821
.text$mn:00002821 ; Attributes: noreturn
.text$mn:00002821
.text$mn:00002821 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00002821                                         ; DATA XREF: .xdata$x:00003F78o
.text$mn:00002821                 push    0               ; Size
.text$mn:00002823                 push    1               ; char
.text$mn:00002825                 mov     ecx, [ebp-18h]
.text$mn:00002828                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000282D                 push    0
.text$mn:0000282F                 push    0
.text$mn:00002831                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002831 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00002831
.text$mn:00002836 ; ---------------------------------------------------------------------------
.text$mn:00002836                 mov     eax, offset $LN17
.text$mn:0000283B                 retn
.text$mn:0000283C ; ---------------------------------------------------------------------------
.text$mn:0000283C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000283C
.text$mn:0000283C loc_283C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000283C                 mov     dword ptr [ebp-4], 1
.text$mn:00002843                 jmp     short loc_284C
.text$mn:00002843 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002845
.text$mn:00002845 ; =============== S U B R O U T I N E =======================================
.text$mn:00002845
.text$mn:00002845
.text$mn:00002845 $LN17           proc near               ; DATA XREF: .text$mn:00002836o
.text$mn:00002845                 mov     dword ptr [ebp-4], 1
.text$mn:00002845 $LN17           endp ; sp-analysis failed
.text$mn:00002845
.text$mn:0000284C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000284C
.text$mn:0000284C loc_284C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000284C                 mov     eax, offset $LN19
.text$mn:00002851                 retn
.text$mn:00002851 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002852 ; ---------------------------------------------------------------------------
.text$mn:00002852 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00002852
.text$mn:00002852 loc_2852:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00002852                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002859                 jmp     short loc_2862
.text$mn:00002859 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000285B
.text$mn:0000285B ; =============== S U B R O U T I N E =======================================
.text$mn:0000285B
.text$mn:0000285B
.text$mn:0000285B $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_284Co
.text$mn:0000285B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002862
.text$mn:00002862 loc_2862:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00002862                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00002866                 jbe     short loc_2881
.text$mn:00002868                 mov     edx, [ebp+0Ch]
.text$mn:0000286B                 push    edx             ; Size
.text$mn:0000286C                 mov     ecx, [ebp-18h]
.text$mn:0000286F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002874                 push    eax             ; Src
.text$mn:00002875                 mov     eax, [ebp-20h]
.text$mn:00002878                 push    eax             ; Dst
.text$mn:00002879                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000287E                 add     esp, 0Ch
.text$mn:00002881
.text$mn:00002881 loc_2881:                               ; CODE XREF: $LN19+Bj
.text$mn:00002881                 push    0               ; Size
.text$mn:00002883                 push    1               ; char
.text$mn:00002885                 mov     ecx, [ebp-18h]
.text$mn:00002888                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000288D                 lea     ecx, [ebp-20h]
.text$mn:00002890                 push    ecx             ; int
.text$mn:00002891                 mov     edx, [ebp-18h]
.text$mn:00002894                 add     edx, 4
.text$mn:00002897                 push    edx             ; void *
.text$mn:00002898                 lea     eax, [ebp-13h]
.text$mn:0000289B                 push    eax
.text$mn:0000289C                 mov     ecx, [ebp-18h]
.text$mn:0000289F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000028A4                 mov     ecx, eax
.text$mn:000028A6                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000028AB                 mov     ecx, [ebp-18h]
.text$mn:000028AE                 mov     edx, [ebp-1Ch]
.text$mn:000028B1                 mov     [ecx+18h], edx
.text$mn:000028B4                 mov     eax, [ebp+0Ch]
.text$mn:000028B7                 push    eax
.text$mn:000028B8                 mov     ecx, [ebp-18h]
.text$mn:000028BB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000028C0                 mov     ecx, [ebp-0Ch]
.text$mn:000028C3                 mov     large fs:0, ecx
.text$mn:000028CA                 pop     ecx
.text$mn:000028CB                 pop     edi
.text$mn:000028CC                 pop     esi
.text$mn:000028CD                 pop     ebx
.text$mn:000028CE                 mov     esp, ebp
.text$mn:000028D0                 pop     ebp
.text$mn:000028D1                 retn    8
.text$mn:000028D1 $LN19           endp ; sp-analysis failed
.text$mn:000028D1
.text$mn:000028D1 _text$mn        ends
.text$mn:000028D1
.text$x:000028D4 ; ===========================================================================
.text$x:000028D4
.text$x:000028D4 ; Segment type: Pure code
.text$x:000028D4 ; Segment permissions: Read/Execute
.text$x:000028D4 _text$x         segment para public 'CODE' use32
.text$x:000028D4                 assume cs:_text$x
.text$x:000028D4                 ;org 28D4h
.text$x:000028D4 ; COMDAT (pick associative to section at 2730)
.text$x:000028D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000028D4
.text$x:000028D4 ; =============== S U B R O U T I N E =======================================
.text$x:000028D4
.text$x:000028D4
.text$x:000028D4 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000028D4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000028D4
.text$x:000028D4 arg_4           = dword ptr  8
.text$x:000028D4
.text$x:000028D4                 mov     edx, [esp+arg_4]
.text$x:000028D8                 lea     eax, [edx+0Ch]
.text$x:000028DB                 mov     ecx, [edx-24h]
.text$x:000028DE                 xor     ecx, eax
.text$x:000028E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028E5                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000028EA                 jmp     ___CxxFrameHandler3
.text$x:000028EA __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000028EA
.text$x:000028EA ; ---------------------------------------------------------------------------
.text$x:000028EF                 align 10h
.text$x:000028EF _text$x         ends
.text$x:000028EF
.text$mn:000028F0 ; ===========================================================================
.text$mn:000028F0
.text$mn:000028F0 ; Segment type: Pure code
.text$mn:000028F0 ; Segment permissions: Read/Execute
.text$mn:000028F0 _text$mn        segment para public 'CODE' use32
.text$mn:000028F0                 assume cs:_text$mn
.text$mn:000028F0                 ;org 28F0h
.text$mn:000028F0 ; COMDAT (pick any)
.text$mn:000028F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028F0
.text$mn:000028F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000028F0
.text$mn:000028F0 ; Attributes: bp-based frame
.text$mn:000028F0
.text$mn:000028F0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:000028F0                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000028F0 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:000028F0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:000028F0
.text$mn:000028F0 var_20          = dword ptr -20h
.text$mn:000028F0 var_1C          = dword ptr -1Ch
.text$mn:000028F0 var_18          = dword ptr -18h
.text$mn:000028F0 var_11          = byte ptr -11h
.text$mn:000028F0 var_10          = dword ptr -10h
.text$mn:000028F0 var_C           = byte ptr -0Ch
.text$mn:000028F0 var_4           = dword ptr -4
.text$mn:000028F0 arg_0           = dword ptr  8
.text$mn:000028F0
.text$mn:000028F0 ; FUNCTION CHUNK AT .text$mn:00002A12 SIZE 00000009 BYTES
.text$mn:000028F0
.text$mn:000028F0                 push    ebp
.text$mn:000028F1                 mov     ebp, esp
.text$mn:000028F3                 push    0FFFFFFFFh
.text$mn:000028F5                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000028FA                 mov     eax, large fs:0
.text$mn:00002900                 push    eax
.text$mn:00002901                 push    ecx
.text$mn:00002902                 sub     esp, 10h
.text$mn:00002905                 push    ebx
.text$mn:00002906                 push    esi
.text$mn:00002907                 push    edi
.text$mn:00002908                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000290D                 xor     eax, ebp
.text$mn:0000290F                 push    eax
.text$mn:00002910                 lea     eax, [ebp+var_C]
.text$mn:00002913                 mov     large fs:0, eax
.text$mn:00002919                 mov     [ebp+var_10], esp
.text$mn:0000291C                 mov     [ebp+var_18], ecx
.text$mn:0000291F                 mov     eax, [ebp+arg_0]
.text$mn:00002922                 or      eax, 7
.text$mn:00002925                 mov     [ebp+var_1C], eax
.text$mn:00002928                 mov     ecx, [ebp+var_18]
.text$mn:0000292B                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00002930                 cmp     eax, [ebp+var_1C]
.text$mn:00002933                 jnb     short loc_293D
.text$mn:00002935                 mov     ecx, [ebp+arg_0]
.text$mn:00002938                 mov     [ebp+var_1C], ecx
.text$mn:0000293B                 jmp     short loc_298F
.text$mn:0000293D ; ---------------------------------------------------------------------------
.text$mn:0000293D
.text$mn:0000293D loc_293D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:0000293D                 mov     edx, [ebp+var_18]
.text$mn:00002940                 mov     ecx, [edx+18h]
.text$mn:00002943                 shr     ecx, 1
.text$mn:00002945                 mov     eax, [ebp+var_1C]
.text$mn:00002948                 xor     edx, edx
.text$mn:0000294A                 mov     esi, 3
.text$mn:0000294F                 div     esi
.text$mn:00002951                 cmp     ecx, eax
.text$mn:00002953                 ja      short loc_2957
.text$mn:00002955                 jmp     short loc_298F
.text$mn:00002957 ; ---------------------------------------------------------------------------
.text$mn:00002957
.text$mn:00002957 loc_2957:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00002957                 mov     ecx, [ebp+var_18]
.text$mn:0000295A                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000295F                 mov     edx, [ebp+var_18]
.text$mn:00002962                 mov     ecx, [edx+18h]
.text$mn:00002965                 shr     ecx, 1
.text$mn:00002967                 sub     eax, ecx
.text$mn:00002969                 mov     edx, [ebp+var_18]
.text$mn:0000296C                 cmp     [edx+18h], eax
.text$mn:0000296F                 ja      short loc_2984
.text$mn:00002971                 mov     eax, [ebp+var_18]
.text$mn:00002974                 mov     ecx, [eax+18h]
.text$mn:00002977                 shr     ecx, 1
.text$mn:00002979                 mov     edx, [ebp+var_18]
.text$mn:0000297C                 add     ecx, [edx+18h]
.text$mn:0000297F                 mov     [ebp+var_1C], ecx
.text$mn:00002982                 jmp     short loc_298F
.text$mn:00002984 ; ---------------------------------------------------------------------------
.text$mn:00002984
.text$mn:00002984 loc_2984:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00002984                 mov     ecx, [ebp+var_18]
.text$mn:00002987                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000298C                 mov     [ebp+var_1C], eax
.text$mn:0000298F
.text$mn:0000298F loc_298F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:0000298F                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:0000298F                 mov     [ebp+var_4], 0
.text$mn:00002996                 mov     eax, [ebp+var_1C]
.text$mn:00002999                 add     eax, 1
.text$mn:0000299C                 push    eax
.text$mn:0000299D                 lea     ecx, [ebp+var_11]
.text$mn:000029A0                 push    ecx
.text$mn:000029A1                 mov     ecx, [ebp+var_18]
.text$mn:000029A4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000029A9                 mov     ecx, eax
.text$mn:000029AB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000029B0                 mov     [ebp+var_20], eax
.text$mn:000029B3                 jmp     short loc_2A12
.text$mn:000029B3 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:000029B3
.text$mn:000029B5
.text$mn:000029B5 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B5
.text$mn:000029B5
.text$mn:000029B5 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:000029B5                                         ; DATA XREF: .xdata$x:000042B4o
.text$mn:000029B5
.text$mn:000029B5 ; FUNCTION CHUNK AT .text$mn:000029FC SIZE 00000009 BYTES
.text$mn:000029B5 ; FUNCTION CHUNK AT .text$mn:00002A0C SIZE 00000006 BYTES
.text$mn:000029B5
.text$mn:000029B5                 mov     [ebp-10h], esp
.text$mn:000029B8                 mov     edx, [ebp+8]
.text$mn:000029BB                 mov     [ebp-1Ch], edx
.text$mn:000029BE                 mov     byte ptr [ebp-4], 2
.text$mn:000029C2                 mov     eax, [ebp-1Ch]
.text$mn:000029C5                 add     eax, 1
.text$mn:000029C8                 push    eax
.text$mn:000029C9                 lea     ecx, [ebp-12h]
.text$mn:000029CC                 push    ecx
.text$mn:000029CD                 mov     ecx, [ebp-18h]
.text$mn:000029D0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000029D5                 mov     ecx, eax
.text$mn:000029D7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:000029DC                 mov     [ebp-20h], eax
.text$mn:000029DF                 jmp     short loc_29FC
.text$mn:000029DF __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:000029DF
.text$mn:000029E1
.text$mn:000029E1 ; =============== S U B R O U T I N E =======================================
.text$mn:000029E1
.text$mn:000029E1 ; Attributes: noreturn
.text$mn:000029E1
.text$mn:000029E1 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:000029E1                                         ; DATA XREF: .xdata$x:000042C4o
.text$mn:000029E1                 push    0
.text$mn:000029E3                 push    1
.text$mn:000029E5                 mov     ecx, [ebp-18h]
.text$mn:000029E8                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000029ED                 push    0
.text$mn:000029EF                 push    0
.text$mn:000029F1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000029F1 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:000029F1
.text$mn:000029F6 ; ---------------------------------------------------------------------------
.text$mn:000029F6                 mov     eax, offset $LN17_0
.text$mn:000029FB                 retn
.text$mn:000029FC ; ---------------------------------------------------------------------------
.text$mn:000029FC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000029FC
.text$mn:000029FC loc_29FC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000029FC                 mov     dword ptr [ebp-4], 1
.text$mn:00002A03                 jmp     short loc_2A0C
.text$mn:00002A03 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00002A05
.text$mn:00002A05 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A05
.text$mn:00002A05
.text$mn:00002A05 $LN17_0         proc near               ; DATA XREF: .text$mn:000029F6o
.text$mn:00002A05                 mov     dword ptr [ebp-4], 1
.text$mn:00002A05 $LN17_0         endp ; sp-analysis failed
.text$mn:00002A05
.text$mn:00002A0C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00002A0C
.text$mn:00002A0C loc_2A0C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00002A0C                 mov     eax, offset $LN19_0
.text$mn:00002A11                 retn
.text$mn:00002A11 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00002A12 ; ---------------------------------------------------------------------------
.text$mn:00002A12 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00002A12
.text$mn:00002A12 loc_2A12:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00002A12                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A19                 jmp     short loc_2A22
.text$mn:00002A19 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00002A1B
.text$mn:00002A1B ; =============== S U B R O U T I N E =======================================
.text$mn:00002A1B
.text$mn:00002A1B
.text$mn:00002A1B $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_2A0Co
.text$mn:00002A1B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002A22
.text$mn:00002A22 loc_2A22:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00002A22                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00002A26                 jbe     short loc_2A41
.text$mn:00002A28                 mov     edx, [ebp+0Ch]
.text$mn:00002A2B                 push    edx             ; int
.text$mn:00002A2C                 mov     ecx, [ebp-18h]
.text$mn:00002A2F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002A34                 push    eax             ; Src
.text$mn:00002A35                 mov     eax, [ebp-20h]
.text$mn:00002A38                 push    eax             ; Dst
.text$mn:00002A39                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002A3E                 add     esp, 0Ch
.text$mn:00002A41
.text$mn:00002A41 loc_2A41:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00002A41                 push    0
.text$mn:00002A43                 push    1
.text$mn:00002A45                 mov     ecx, [ebp-18h]
.text$mn:00002A48                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002A4D                 lea     ecx, [ebp-20h]
.text$mn:00002A50                 push    ecx             ; int
.text$mn:00002A51                 mov     edx, [ebp-18h]
.text$mn:00002A54                 add     edx, 4
.text$mn:00002A57                 push    edx             ; void *
.text$mn:00002A58                 lea     eax, [ebp-13h]
.text$mn:00002A5B                 push    eax
.text$mn:00002A5C                 mov     ecx, [ebp-18h]
.text$mn:00002A5F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002A64                 mov     ecx, eax
.text$mn:00002A66                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00002A6B                 mov     ecx, [ebp-18h]
.text$mn:00002A6E                 mov     edx, [ebp-1Ch]
.text$mn:00002A71                 mov     [ecx+18h], edx
.text$mn:00002A74                 mov     eax, [ebp+0Ch]
.text$mn:00002A77                 push    eax
.text$mn:00002A78                 mov     ecx, [ebp-18h]
.text$mn:00002A7B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002A80                 mov     ecx, [ebp-0Ch]
.text$mn:00002A83                 mov     large fs:0, ecx
.text$mn:00002A8A                 pop     ecx
.text$mn:00002A8B                 pop     edi
.text$mn:00002A8C                 pop     esi
.text$mn:00002A8D                 pop     ebx
.text$mn:00002A8E                 mov     esp, ebp
.text$mn:00002A90                 pop     ebp
.text$mn:00002A91                 retn    8
.text$mn:00002A91 $LN19_0         endp ; sp-analysis failed
.text$mn:00002A91
.text$mn:00002A91 _text$mn        ends
.text$mn:00002A91
.text$x:00002A94 ; ===========================================================================
.text$x:00002A94
.text$x:00002A94 ; Segment type: Pure code
.text$x:00002A94 ; Segment permissions: Read/Execute
.text$x:00002A94 _text$x         segment para public 'CODE' use32
.text$x:00002A94                 assume cs:_text$x
.text$x:00002A94                 ;org 2A94h
.text$x:00002A94 ; COMDAT (pick associative to section at 28F0)
.text$x:00002A94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002A94
.text$x:00002A94 ; =============== S U B R O U T I N E =======================================
.text$x:00002A94
.text$x:00002A94
.text$x:00002A94 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00002A94                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00002A94
.text$x:00002A94 arg_4           = dword ptr  8
.text$x:00002A94
.text$x:00002A94                 mov     edx, [esp+arg_4]
.text$x:00002A98                 lea     eax, [edx+0Ch]
.text$x:00002A9B                 mov     ecx, [edx-24h]
.text$x:00002A9E                 xor     ecx, eax
.text$x:00002AA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AA5                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00002AAA                 jmp     ___CxxFrameHandler3
.text$x:00002AAA __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00002AAA
.text$x:00002AAA ; ---------------------------------------------------------------------------
.text$x:00002AAF                 align 10h
.text$x:00002AAF _text$x         ends
.text$x:00002AAF
.text$mn:00002AB0 ; ===========================================================================
.text$mn:00002AB0
.text$mn:00002AB0 ; Segment type: Pure code
.text$mn:00002AB0 ; Segment permissions: Read/Execute
.text$mn:00002AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB0                 assume cs:_text$mn
.text$mn:00002AB0                 ;org 2AB0h
.text$mn:00002AB0 ; COMDAT (pick any)
.text$mn:00002AB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AB0
.text$mn:00002AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB0
.text$mn:00002AB0 ; Attributes: bp-based frame
.text$mn:00002AB0
.text$mn:00002AB0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00002AB0                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00002AB0 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00002AB0                                         ; CODE XREF: $LN19+60p
.text$mn:00002AB0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00002AB0
.text$mn:00002AB0 var_8           = dword ptr -8
.text$mn:00002AB0 var_1           = byte ptr -1
.text$mn:00002AB0 arg_0           = dword ptr  8
.text$mn:00002AB0
.text$mn:00002AB0                 push    ebp
.text$mn:00002AB1                 mov     ebp, esp
.text$mn:00002AB3                 sub     esp, 8
.text$mn:00002AB6                 mov     [ebp+var_8], ecx
.text$mn:00002AB9                 mov     [ebp+var_1], 0
.text$mn:00002ABD                 mov     eax, [ebp+var_8]
.text$mn:00002AC0                 mov     ecx, [ebp+arg_0]
.text$mn:00002AC3                 mov     [eax+14h], ecx
.text$mn:00002AC6                 lea     edx, [ebp+var_1]
.text$mn:00002AC9                 push    edx
.text$mn:00002ACA                 mov     ecx, [ebp+var_8]
.text$mn:00002ACD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002AD2                 add     eax, [ebp+arg_0]
.text$mn:00002AD5                 push    eax
.text$mn:00002AD6                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00002ADB                 add     esp, 8
.text$mn:00002ADE                 mov     esp, ebp
.text$mn:00002AE0                 pop     ebp
.text$mn:00002AE1                 retn    4
.text$mn:00002AE1 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00002AE1
.text$mn:00002AE1 _text$mn        ends
.text$mn:00002AE1
.text$mn:00002AE4 ; ===========================================================================
.text$mn:00002AE4
.text$mn:00002AE4 ; Segment type: Pure code
.text$mn:00002AE4 ; Segment permissions: Read/Execute
.text$mn:00002AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AE4                 assume cs:_text$mn
.text$mn:00002AE4                 ;org 2AE4h
.text$mn:00002AE4 ; COMDAT (pick any)
.text$mn:00002AE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AE4
.text$mn:00002AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AE4
.text$mn:00002AE4 ; Attributes: bp-based frame
.text$mn:00002AE4
.text$mn:00002AE4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00002AE4                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00002AE4 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00002AE4                                         ; CODE XREF: $LN19_0+60p
.text$mn:00002AE4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00002AE4
.text$mn:00002AE4 var_8           = dword ptr -8
.text$mn:00002AE4 var_2           = word ptr -2
.text$mn:00002AE4 arg_0           = dword ptr  8
.text$mn:00002AE4
.text$mn:00002AE4                 push    ebp
.text$mn:00002AE5                 mov     ebp, esp
.text$mn:00002AE7                 sub     esp, 8
.text$mn:00002AEA                 mov     [ebp+var_8], ecx
.text$mn:00002AED                 xor     eax, eax
.text$mn:00002AEF                 mov     [ebp+var_2], ax
.text$mn:00002AF3                 mov     ecx, [ebp+var_8]
.text$mn:00002AF6                 mov     edx, [ebp+arg_0]
.text$mn:00002AF9                 mov     [ecx+14h], edx
.text$mn:00002AFC                 lea     eax, [ebp+var_2]
.text$mn:00002AFF                 push    eax
.text$mn:00002B00                 mov     ecx, [ebp+var_8]
.text$mn:00002B03                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002B08                 mov     ecx, [ebp+arg_0]
.text$mn:00002B0B                 lea     edx, [eax+ecx*2]
.text$mn:00002B0E                 push    edx
.text$mn:00002B0F                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00002B14                 add     esp, 8
.text$mn:00002B17                 mov     esp, ebp
.text$mn:00002B19                 pop     ebp
.text$mn:00002B1A                 retn    4
.text$mn:00002B1A ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00002B1A
.text$mn:00002B1A ; ---------------------------------------------------------------------------
.text$mn:00002B1D                 align 10h
.text$mn:00002B1D _text$mn        ends
.text$mn:00002B1D
.text$mn:00002B20 ; ===========================================================================
.text$mn:00002B20
.text$mn:00002B20 ; Segment type: Pure code
.text$mn:00002B20 ; Segment permissions: Read/Execute
.text$mn:00002B20 _text$mn        segment para public 'CODE' use32
.text$mn:00002B20                 assume cs:_text$mn
.text$mn:00002B20                 ;org 2B20h
.text$mn:00002B20 ; COMDAT (pick any)
.text$mn:00002B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B20
.text$mn:00002B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B20
.text$mn:00002B20 ; Attributes: bp-based frame
.text$mn:00002B20
.text$mn:00002B20 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00002B20                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00002B20 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00002B20                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00002B20
.text$mn:00002B20 var_8           = dword ptr -8
.text$mn:00002B20 var_1           = byte ptr -1
.text$mn:00002B20
.text$mn:00002B20                 push    ebp
.text$mn:00002B21                 mov     ebp, esp
.text$mn:00002B23                 sub     esp, 8
.text$mn:00002B26                 mov     [ebp+var_8], ecx
.text$mn:00002B29                 lea     ecx, [ebp+var_1]
.text$mn:00002B2C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002B31                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002B34                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002B39                 mov     eax, [ebp+var_8]
.text$mn:00002B3C                 mov     ecx, [eax]
.text$mn:00002B3E                 push    ecx
.text$mn:00002B3F                 lea     ecx, [ebp+var_1]
.text$mn:00002B42                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002B47                 push    1               ; int
.text$mn:00002B49                 mov     edx, [ebp+var_8]
.text$mn:00002B4C                 mov     eax, [edx]
.text$mn:00002B4E                 push    eax             ; void *
.text$mn:00002B4F                 lea     ecx, [ebp+var_1]
.text$mn:00002B52                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00002B57                 mov     ecx, [ebp+var_8]
.text$mn:00002B5A                 mov     dword ptr [ecx], 0
.text$mn:00002B60                 mov     esp, ebp
.text$mn:00002B62                 pop     ebp
.text$mn:00002B63                 retn
.text$mn:00002B63 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00002B63
.text$mn:00002B63 _text$mn        ends
.text$mn:00002B63
.text$mn:00002B64 ; ===========================================================================
.text$mn:00002B64
.text$mn:00002B64 ; Segment type: Pure code
.text$mn:00002B64 ; Segment permissions: Read/Execute
.text$mn:00002B64 _text$mn        segment para public 'CODE' use32
.text$mn:00002B64                 assume cs:_text$mn
.text$mn:00002B64                 ;org 2B64h
.text$mn:00002B64 ; COMDAT (pick any)
.text$mn:00002B64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B64
.text$mn:00002B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B64
.text$mn:00002B64 ; Attributes: bp-based frame
.text$mn:00002B64
.text$mn:00002B64 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00002B64                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00002B64 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00002B64                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00002B64
.text$mn:00002B64 var_8           = dword ptr -8
.text$mn:00002B64 var_1           = byte ptr -1
.text$mn:00002B64
.text$mn:00002B64                 push    ebp
.text$mn:00002B65                 mov     ebp, esp
.text$mn:00002B67                 sub     esp, 8
.text$mn:00002B6A                 mov     [ebp+var_8], ecx
.text$mn:00002B6D                 lea     ecx, [ebp+var_1]
.text$mn:00002B70                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002B75                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002B78                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002B7D                 mov     eax, [ebp+var_8]
.text$mn:00002B80                 mov     ecx, [eax]
.text$mn:00002B82                 push    ecx
.text$mn:00002B83                 lea     ecx, [ebp+var_1]
.text$mn:00002B86                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002B8B                 push    1               ; int
.text$mn:00002B8D                 mov     edx, [ebp+var_8]
.text$mn:00002B90                 mov     eax, [edx]
.text$mn:00002B92                 push    eax             ; void *
.text$mn:00002B93                 lea     ecx, [ebp+var_1]
.text$mn:00002B96                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00002B9B                 mov     ecx, [ebp+var_8]
.text$mn:00002B9E                 mov     dword ptr [ecx], 0
.text$mn:00002BA4                 mov     esp, ebp
.text$mn:00002BA6                 pop     ebp
.text$mn:00002BA7                 retn
.text$mn:00002BA7 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00002BA7
.text$mn:00002BA7 _text$mn        ends
.text$mn:00002BA7
.text$mn:00002BA8 ; ===========================================================================
.text$mn:00002BA8
.text$mn:00002BA8 ; Segment type: Pure code
.text$mn:00002BA8 ; Segment permissions: Read/Execute
.text$mn:00002BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BA8                 assume cs:_text$mn
.text$mn:00002BA8                 ;org 2BA8h
.text$mn:00002BA8 ; COMDAT (pick any)
.text$mn:00002BA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BA8
.text$mn:00002BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BA8
.text$mn:00002BA8 ; Attributes: bp-based frame
.text$mn:00002BA8
.text$mn:00002BA8 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00002BA8                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00002BA8 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00002BA8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00002BA8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00002BA8
.text$mn:00002BA8 var_4           = dword ptr -4
.text$mn:00002BA8 arg_0           = dword ptr  8
.text$mn:00002BA8
.text$mn:00002BA8                 push    ebp
.text$mn:00002BA9                 mov     ebp, esp
.text$mn:00002BAB                 push    ecx
.text$mn:00002BAC                 mov     [ebp+var_4], ecx
.text$mn:00002BAF                 mov     ecx, [ebp+arg_0]
.text$mn:00002BB2                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00002BB7                 mov     eax, [ebp+arg_0]
.text$mn:00002BBA                 mov     esp, ebp
.text$mn:00002BBC                 pop     ebp
.text$mn:00002BBD                 retn    4
.text$mn:00002BBD ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00002BBD
.text$mn:00002BBD _text$mn        ends
.text$mn:00002BBD
.text$mn:00002BC0 ; ===========================================================================
.text$mn:00002BC0
.text$mn:00002BC0 ; Segment type: Pure code
.text$mn:00002BC0 ; Segment permissions: Read/Execute
.text$mn:00002BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BC0                 assume cs:_text$mn
.text$mn:00002BC0                 ;org 2BC0h
.text$mn:00002BC0 ; COMDAT (pick any)
.text$mn:00002BC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BC0
.text$mn:00002BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BC0
.text$mn:00002BC0 ; Attributes: bp-based frame
.text$mn:00002BC0
.text$mn:00002BC0 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00002BC0                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00002BC0 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00002BC0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:00002BC0                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00002BC0
.text$mn:00002BC0 var_4           = dword ptr -4
.text$mn:00002BC0 arg_0           = dword ptr  8
.text$mn:00002BC0
.text$mn:00002BC0                 push    ebp
.text$mn:00002BC1                 mov     ebp, esp
.text$mn:00002BC3                 push    ecx
.text$mn:00002BC4                 mov     [ebp+var_4], ecx
.text$mn:00002BC7                 mov     ecx, [ebp+arg_0]
.text$mn:00002BCA                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00002BCF                 mov     eax, [ebp+arg_0]
.text$mn:00002BD2                 mov     esp, ebp
.text$mn:00002BD4                 pop     ebp
.text$mn:00002BD5                 retn    4
.text$mn:00002BD5 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00002BD5
.text$mn:00002BD5 _text$mn        ends
.text$mn:00002BD5
.text$mn:00002BD8 ; ===========================================================================
.text$mn:00002BD8
.text$mn:00002BD8 ; Segment type: Pure code
.text$mn:00002BD8 ; Segment permissions: Read/Execute
.text$mn:00002BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BD8                 assume cs:_text$mn
.text$mn:00002BD8                 ;org 2BD8h
.text$mn:00002BD8 ; COMDAT (pick any)
.text$mn:00002BD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BD8
.text$mn:00002BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BD8
.text$mn:00002BD8 ; Attributes: bp-based frame
.text$mn:00002BD8
.text$mn:00002BD8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00002BD8                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00002BD8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00002BD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00002BD8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00002BD8
.text$mn:00002BD8 var_C           = dword ptr -0Ch
.text$mn:00002BD8 Size            = dword ptr -8
.text$mn:00002BD8 var_4           = dword ptr -4
.text$mn:00002BD8 arg_0           = dword ptr  8
.text$mn:00002BD8 arg_4           = byte ptr  0Ch
.text$mn:00002BD8
.text$mn:00002BD8                 push    ebp
.text$mn:00002BD9                 mov     ebp, esp
.text$mn:00002BDB                 sub     esp, 0Ch
.text$mn:00002BDE                 mov     [ebp+var_4], ecx
.text$mn:00002BE1                 mov     ecx, [ebp+var_4]
.text$mn:00002BE4                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002BE9                 cmp     eax, [ebp+arg_0]
.text$mn:00002BEC                 jnb     short loc_2BF6
.text$mn:00002BEE                 mov     ecx, [ebp+var_4]
.text$mn:00002BF1                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00002BF6
.text$mn:00002BF6 loc_2BF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00002BF6                 mov     eax, [ebp+var_4]
.text$mn:00002BF9                 mov     ecx, [eax+18h]
.text$mn:00002BFC                 cmp     ecx, [ebp+arg_0]
.text$mn:00002BFF                 jnb     short loc_2C16
.text$mn:00002C01                 mov     edx, [ebp+var_4]
.text$mn:00002C04                 mov     eax, [edx+14h]
.text$mn:00002C07                 push    eax
.text$mn:00002C08                 mov     ecx, [ebp+arg_0]
.text$mn:00002C0B                 push    ecx
.text$mn:00002C0C                 mov     ecx, [ebp+var_4]
.text$mn:00002C0F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00002C14                 jmp     short loc_2C60
.text$mn:00002C16 ; ---------------------------------------------------------------------------
.text$mn:00002C16
.text$mn:00002C16 loc_2C16:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00002C16                 movzx   edx, [ebp+arg_4]
.text$mn:00002C1A                 test    edx, edx
.text$mn:00002C1C                 jz      short loc_2C50
.text$mn:00002C1E                 cmp     [ebp+arg_0], 10h
.text$mn:00002C22                 jnb     short loc_2C50
.text$mn:00002C24                 mov     eax, [ebp+var_4]
.text$mn:00002C27                 mov     ecx, [ebp+arg_0]
.text$mn:00002C2A                 cmp     ecx, [eax+14h]
.text$mn:00002C2D                 jnb     short loc_2C37
.text$mn:00002C2F                 mov     edx, [ebp+arg_0]
.text$mn:00002C32                 mov     [ebp+Size], edx
.text$mn:00002C35                 jmp     short loc_2C40
.text$mn:00002C37 ; ---------------------------------------------------------------------------
.text$mn:00002C37
.text$mn:00002C37 loc_2C37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00002C37                 mov     eax, [ebp+var_4]
.text$mn:00002C3A                 mov     ecx, [eax+14h]
.text$mn:00002C3D                 mov     [ebp+Size], ecx
.text$mn:00002C40
.text$mn:00002C40 loc_2C40:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00002C40                 mov     edx, [ebp+Size]
.text$mn:00002C43                 push    edx             ; Size
.text$mn:00002C44                 push    1               ; char
.text$mn:00002C46                 mov     ecx, [ebp+var_4]
.text$mn:00002C49                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002C4E                 jmp     short loc_2C60
.text$mn:00002C50 ; ---------------------------------------------------------------------------
.text$mn:00002C50
.text$mn:00002C50 loc_2C50:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00002C50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00002C50                 cmp     [ebp+arg_0], 0
.text$mn:00002C54                 jnz     short loc_2C60
.text$mn:00002C56                 push    0
.text$mn:00002C58                 mov     ecx, [ebp+var_4]
.text$mn:00002C5B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002C60
.text$mn:00002C60 loc_2C60:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00002C60                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00002C60                 cmp     [ebp+arg_0], 0
.text$mn:00002C64                 jbe     short loc_2C6F
.text$mn:00002C66                 mov     [ebp+var_C], 1
.text$mn:00002C6D                 jmp     short loc_2C76
.text$mn:00002C6F ; ---------------------------------------------------------------------------
.text$mn:00002C6F
.text$mn:00002C6F loc_2C6F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00002C6F                 mov     [ebp+var_C], 0
.text$mn:00002C76
.text$mn:00002C76 loc_2C76:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00002C76                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002C79                 mov     esp, ebp
.text$mn:00002C7B                 pop     ebp
.text$mn:00002C7C                 retn    8
.text$mn:00002C7C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00002C7C
.text$mn:00002C7C ; ---------------------------------------------------------------------------
.text$mn:00002C7F                 align 10h
.text$mn:00002C7F _text$mn        ends
.text$mn:00002C7F
.text$mn:00002C80 ; ===========================================================================
.text$mn:00002C80
.text$mn:00002C80 ; Segment type: Pure code
.text$mn:00002C80 ; Segment permissions: Read/Execute
.text$mn:00002C80 _text$mn        segment para public 'CODE' use32
.text$mn:00002C80                 assume cs:_text$mn
.text$mn:00002C80                 ;org 2C80h
.text$mn:00002C80 ; COMDAT (pick any)
.text$mn:00002C80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C80
.text$mn:00002C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C80
.text$mn:00002C80 ; Attributes: bp-based frame
.text$mn:00002C80
.text$mn:00002C80 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00002C80                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00002C80 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00002C80                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00002C80                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:00002C80
.text$mn:00002C80 var_C           = dword ptr -0Ch
.text$mn:00002C80 var_8           = dword ptr -8
.text$mn:00002C80 var_4           = dword ptr -4
.text$mn:00002C80 arg_0           = dword ptr  8
.text$mn:00002C80 arg_4           = byte ptr  0Ch
.text$mn:00002C80
.text$mn:00002C80                 push    ebp
.text$mn:00002C81                 mov     ebp, esp
.text$mn:00002C83                 sub     esp, 0Ch
.text$mn:00002C86                 mov     [ebp+var_4], ecx
.text$mn:00002C89                 mov     ecx, [ebp+var_4]
.text$mn:00002C8C                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00002C91                 cmp     eax, [ebp+arg_0]
.text$mn:00002C94                 jnb     short loc_2C9E
.text$mn:00002C96                 mov     ecx, [ebp+var_4]
.text$mn:00002C99                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00002C9E
.text$mn:00002C9E loc_2C9E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00002C9E                 mov     eax, [ebp+var_4]
.text$mn:00002CA1                 mov     ecx, [eax+18h]
.text$mn:00002CA4                 cmp     ecx, [ebp+arg_0]
.text$mn:00002CA7                 jnb     short loc_2CBE
.text$mn:00002CA9                 mov     edx, [ebp+var_4]
.text$mn:00002CAC                 mov     eax, [edx+14h]
.text$mn:00002CAF                 push    eax
.text$mn:00002CB0                 mov     ecx, [ebp+arg_0]
.text$mn:00002CB3                 push    ecx
.text$mn:00002CB4                 mov     ecx, [ebp+var_4]
.text$mn:00002CB7                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00002CBC                 jmp     short loc_2D08
.text$mn:00002CBE ; ---------------------------------------------------------------------------
.text$mn:00002CBE
.text$mn:00002CBE loc_2CBE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00002CBE                 movzx   edx, [ebp+arg_4]
.text$mn:00002CC2                 test    edx, edx
.text$mn:00002CC4                 jz      short loc_2CF8
.text$mn:00002CC6                 cmp     [ebp+arg_0], 8
.text$mn:00002CCA                 jnb     short loc_2CF8
.text$mn:00002CCC                 mov     eax, [ebp+var_4]
.text$mn:00002CCF                 mov     ecx, [ebp+arg_0]
.text$mn:00002CD2                 cmp     ecx, [eax+14h]
.text$mn:00002CD5                 jnb     short loc_2CDF
.text$mn:00002CD7                 mov     edx, [ebp+arg_0]
.text$mn:00002CDA                 mov     [ebp+var_8], edx
.text$mn:00002CDD                 jmp     short loc_2CE8
.text$mn:00002CDF ; ---------------------------------------------------------------------------
.text$mn:00002CDF
.text$mn:00002CDF loc_2CDF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00002CDF                 mov     eax, [ebp+var_4]
.text$mn:00002CE2                 mov     ecx, [eax+14h]
.text$mn:00002CE5                 mov     [ebp+var_8], ecx
.text$mn:00002CE8
.text$mn:00002CE8 loc_2CE8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00002CE8                 mov     edx, [ebp+var_8]
.text$mn:00002CEB                 push    edx
.text$mn:00002CEC                 push    1
.text$mn:00002CEE                 mov     ecx, [ebp+var_4]
.text$mn:00002CF1                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002CF6                 jmp     short loc_2D08
.text$mn:00002CF8 ; ---------------------------------------------------------------------------
.text$mn:00002CF8
.text$mn:00002CF8 loc_2CF8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00002CF8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00002CF8                 cmp     [ebp+arg_0], 0
.text$mn:00002CFC                 jnz     short loc_2D08
.text$mn:00002CFE                 push    0
.text$mn:00002D00                 mov     ecx, [ebp+var_4]
.text$mn:00002D03                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002D08
.text$mn:00002D08 loc_2D08:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00002D08                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00002D08                 cmp     [ebp+arg_0], 0
.text$mn:00002D0C                 jbe     short loc_2D17
.text$mn:00002D0E                 mov     [ebp+var_C], 1
.text$mn:00002D15                 jmp     short loc_2D1E
.text$mn:00002D17 ; ---------------------------------------------------------------------------
.text$mn:00002D17
.text$mn:00002D17 loc_2D17:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00002D17                 mov     [ebp+var_C], 0
.text$mn:00002D1E
.text$mn:00002D1E loc_2D1E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00002D1E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002D21                 mov     esp, ebp
.text$mn:00002D23                 pop     ebp
.text$mn:00002D24                 retn    8
.text$mn:00002D24 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00002D24
.text$mn:00002D24 ; ---------------------------------------------------------------------------
.text$mn:00002D27                 align 4
.text$mn:00002D27 _text$mn        ends
.text$mn:00002D27
.text$mn:00002D28 ; ===========================================================================
.text$mn:00002D28
.text$mn:00002D28 ; Segment type: Pure code
.text$mn:00002D28 ; Segment permissions: Read/Execute
.text$mn:00002D28 _text$mn        segment para public 'CODE' use32
.text$mn:00002D28                 assume cs:_text$mn
.text$mn:00002D28                 ;org 2D28h
.text$mn:00002D28 ; COMDAT (pick any)
.text$mn:00002D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D28
.text$mn:00002D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D28
.text$mn:00002D28 ; Attributes: bp-based frame
.text$mn:00002D28
.text$mn:00002D28 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00002D28                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00002D28 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00002D28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00002D28
.text$mn:00002D28 var_4           = dword ptr -4
.text$mn:00002D28 arg_0           = dword ptr  8
.text$mn:00002D28
.text$mn:00002D28                 push    ebp
.text$mn:00002D29                 mov     ebp, esp
.text$mn:00002D2B                 push    ecx
.text$mn:00002D2C                 mov     [ebp+var_4], ecx
.text$mn:00002D2F                 cmp     [ebp+arg_0], 0
.text$mn:00002D33                 jz      short loc_2D55
.text$mn:00002D35                 mov     ecx, [ebp+var_4]
.text$mn:00002D38                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002D3D                 cmp     [ebp+arg_0], eax
.text$mn:00002D40                 jb      short loc_2D55
.text$mn:00002D42                 mov     ecx, [ebp+var_4]
.text$mn:00002D45                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002D4A                 mov     ecx, [ebp+var_4]
.text$mn:00002D4D                 add     eax, [ecx+14h]
.text$mn:00002D50                 cmp     eax, [ebp+arg_0]
.text$mn:00002D53                 ja      short loc_2D5B
.text$mn:00002D55
.text$mn:00002D55 loc_2D55:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00002D55                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00002D55                 xor     al, al
.text$mn:00002D57                 jmp     short loc_2D5D
.text$mn:00002D59 ; ---------------------------------------------------------------------------
.text$mn:00002D59                 jmp     short loc_2D5D
.text$mn:00002D5B ; ---------------------------------------------------------------------------
.text$mn:00002D5B
.text$mn:00002D5B loc_2D5B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00002D5B                 mov     al, 1
.text$mn:00002D5D
.text$mn:00002D5D loc_2D5D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00002D5D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00002D5D                 mov     esp, ebp
.text$mn:00002D5F                 pop     ebp
.text$mn:00002D60                 retn    4
.text$mn:00002D60 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00002D60
.text$mn:00002D60 ; ---------------------------------------------------------------------------
.text$mn:00002D63                 align 4
.text$mn:00002D63 _text$mn        ends
.text$mn:00002D63
.text$mn:00002D64 ; ===========================================================================
.text$mn:00002D64
.text$mn:00002D64 ; Segment type: Pure code
.text$mn:00002D64 ; Segment permissions: Read/Execute
.text$mn:00002D64 _text$mn        segment para public 'CODE' use32
.text$mn:00002D64                 assume cs:_text$mn
.text$mn:00002D64                 ;org 2D64h
.text$mn:00002D64 ; COMDAT (pick any)
.text$mn:00002D64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D64
.text$mn:00002D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D64
.text$mn:00002D64 ; Attributes: bp-based frame
.text$mn:00002D64
.text$mn:00002D64 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00002D64                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00002D64 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00002D64                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00002D64
.text$mn:00002D64 var_4           = dword ptr -4
.text$mn:00002D64 arg_0           = dword ptr  8
.text$mn:00002D64
.text$mn:00002D64                 push    ebp
.text$mn:00002D65                 mov     ebp, esp
.text$mn:00002D67                 push    ecx
.text$mn:00002D68                 mov     [ebp+var_4], ecx
.text$mn:00002D6B                 cmp     [ebp+arg_0], 0
.text$mn:00002D6F                 jz      short loc_2D94
.text$mn:00002D71                 mov     ecx, [ebp+var_4]
.text$mn:00002D74                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002D79                 cmp     [ebp+arg_0], eax
.text$mn:00002D7C                 jb      short loc_2D94
.text$mn:00002D7E                 mov     ecx, [ebp+var_4]
.text$mn:00002D81                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002D86                 mov     ecx, [ebp+var_4]
.text$mn:00002D89                 mov     edx, [ecx+14h]
.text$mn:00002D8C                 lea     eax, [eax+edx*2]
.text$mn:00002D8F                 cmp     eax, [ebp+arg_0]
.text$mn:00002D92                 ja      short loc_2D9A
.text$mn:00002D94
.text$mn:00002D94 loc_2D94:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00002D94                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00002D94                 xor     al, al
.text$mn:00002D96                 jmp     short loc_2D9C
.text$mn:00002D98 ; ---------------------------------------------------------------------------
.text$mn:00002D98                 jmp     short loc_2D9C
.text$mn:00002D9A ; ---------------------------------------------------------------------------
.text$mn:00002D9A
.text$mn:00002D9A loc_2D9A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00002D9A                 mov     al, 1
.text$mn:00002D9C
.text$mn:00002D9C loc_2D9C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00002D9C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00002D9C                 mov     esp, ebp
.text$mn:00002D9E                 pop     ebp
.text$mn:00002D9F                 retn    4
.text$mn:00002D9F ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00002D9F
.text$mn:00002D9F ; ---------------------------------------------------------------------------
.text$mn:00002DA2                 align 4
.text$mn:00002DA2 _text$mn        ends
.text$mn:00002DA2
.text$mn:00002DA4 ; ===========================================================================
.text$mn:00002DA4
.text$mn:00002DA4 ; Segment type: Pure code
.text$mn:00002DA4 ; Segment permissions: Read/Execute
.text$mn:00002DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA4                 assume cs:_text$mn
.text$mn:00002DA4                 ;org 2DA4h
.text$mn:00002DA4 ; COMDAT (pick any)
.text$mn:00002DA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DA4
.text$mn:00002DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA4
.text$mn:00002DA4 ; Attributes: bp-based frame
.text$mn:00002DA4
.text$mn:00002DA4 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002DA4                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00002DA4 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00002DA4                                         ; CODE XREF: $LN19+14p
.text$mn:00002DA4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00002DA4
.text$mn:00002DA4 var_8           = dword ptr -8
.text$mn:00002DA4 var_4           = dword ptr -4
.text$mn:00002DA4
.text$mn:00002DA4                 push    ebp
.text$mn:00002DA5                 mov     ebp, esp
.text$mn:00002DA7                 sub     esp, 8
.text$mn:00002DAA                 mov     [ebp+var_4], ecx
.text$mn:00002DAD                 mov     eax, [ebp+var_4]
.text$mn:00002DB0                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002DB4                 jb      short loc_2DCA
.text$mn:00002DB6                 mov     ecx, [ebp+var_4]
.text$mn:00002DB9                 mov     edx, [ecx+4]
.text$mn:00002DBC                 push    edx
.text$mn:00002DBD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002DC2                 add     esp, 4
.text$mn:00002DC5                 mov     [ebp+var_8], eax
.text$mn:00002DC8                 jmp     short loc_2DD3
.text$mn:00002DCA ; ---------------------------------------------------------------------------
.text$mn:00002DCA
.text$mn:00002DCA loc_2DCA:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002DCA                 mov     eax, [ebp+var_4]
.text$mn:00002DCD                 add     eax, 4
.text$mn:00002DD0                 mov     [ebp+var_8], eax
.text$mn:00002DD3
.text$mn:00002DD3 loc_2DD3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002DD3                 mov     eax, [ebp+var_8]
.text$mn:00002DD6                 mov     esp, ebp
.text$mn:00002DD8                 pop     ebp
.text$mn:00002DD9                 retn
.text$mn:00002DD9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00002DD9
.text$mn:00002DD9 ; ---------------------------------------------------------------------------
.text$mn:00002DDA                 align 4
.text$mn:00002DDA _text$mn        ends
.text$mn:00002DDA
.text$mn:00002DDC ; ===========================================================================
.text$mn:00002DDC
.text$mn:00002DDC ; Segment type: Pure code
.text$mn:00002DDC ; Segment permissions: Read/Execute
.text$mn:00002DDC _text$mn        segment para public 'CODE' use32
.text$mn:00002DDC                 assume cs:_text$mn
.text$mn:00002DDC                 ;org 2DDCh
.text$mn:00002DDC ; COMDAT (pick any)
.text$mn:00002DDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DDC
.text$mn:00002DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002DDC
.text$mn:00002DDC ; Attributes: bp-based frame
.text$mn:00002DDC
.text$mn:00002DDC ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00002DDC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00002DDC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00002DDC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00002DDC
.text$mn:00002DDC var_8           = dword ptr -8
.text$mn:00002DDC var_4           = dword ptr -4
.text$mn:00002DDC
.text$mn:00002DDC                 push    ebp
.text$mn:00002DDD                 mov     ebp, esp
.text$mn:00002DDF                 sub     esp, 8
.text$mn:00002DE2                 mov     [ebp+var_4], ecx
.text$mn:00002DE5                 mov     eax, [ebp+var_4]
.text$mn:00002DE8                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002DEC                 jb      short loc_2E02
.text$mn:00002DEE                 mov     ecx, [ebp+var_4]
.text$mn:00002DF1                 mov     edx, [ecx+4]
.text$mn:00002DF4                 push    edx
.text$mn:00002DF5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002DFA                 add     esp, 4
.text$mn:00002DFD                 mov     [ebp+var_8], eax
.text$mn:00002E00                 jmp     short loc_2E0B
.text$mn:00002E02 ; ---------------------------------------------------------------------------
.text$mn:00002E02
.text$mn:00002E02 loc_2E02:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002E02                 mov     eax, [ebp+var_4]
.text$mn:00002E05                 add     eax, 4
.text$mn:00002E08                 mov     [ebp+var_8], eax
.text$mn:00002E0B
.text$mn:00002E0B loc_2E0B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002E0B                 mov     eax, [ebp+var_8]
.text$mn:00002E0E                 mov     esp, ebp
.text$mn:00002E10                 pop     ebp
.text$mn:00002E11                 retn
.text$mn:00002E11 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00002E11
.text$mn:00002E11 ; ---------------------------------------------------------------------------
.text$mn:00002E12                 align 4
.text$mn:00002E12 _text$mn        ends
.text$mn:00002E12
.text$mn:00002E14 ; ===========================================================================
.text$mn:00002E14
.text$mn:00002E14 ; Segment type: Pure code
.text$mn:00002E14 ; Segment permissions: Read/Execute
.text$mn:00002E14 _text$mn        segment para public 'CODE' use32
.text$mn:00002E14                 assume cs:_text$mn
.text$mn:00002E14                 ;org 2E14h
.text$mn:00002E14 ; COMDAT (pick any)
.text$mn:00002E14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E14
.text$mn:00002E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E14
.text$mn:00002E14 ; Attributes: bp-based frame
.text$mn:00002E14
.text$mn:00002E14 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002E14                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00002E14 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00002E14                                         ; CODE XREF: $LN19_0+14p
.text$mn:00002E14                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00002E14
.text$mn:00002E14 var_8           = dword ptr -8
.text$mn:00002E14 var_4           = dword ptr -4
.text$mn:00002E14
.text$mn:00002E14                 push    ebp
.text$mn:00002E15                 mov     ebp, esp
.text$mn:00002E17                 sub     esp, 8
.text$mn:00002E1A                 mov     [ebp+var_4], ecx
.text$mn:00002E1D                 mov     eax, [ebp+var_4]
.text$mn:00002E20                 cmp     dword ptr [eax+18h], 8
.text$mn:00002E24                 jb      short loc_2E3A
.text$mn:00002E26                 mov     ecx, [ebp+var_4]
.text$mn:00002E29                 mov     edx, [ecx+4]
.text$mn:00002E2C                 push    edx
.text$mn:00002E2D                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00002E32                 add     esp, 4
.text$mn:00002E35                 mov     [ebp+var_8], eax
.text$mn:00002E38                 jmp     short loc_2E43
.text$mn:00002E3A ; ---------------------------------------------------------------------------
.text$mn:00002E3A
.text$mn:00002E3A loc_2E3A:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00002E3A                 mov     eax, [ebp+var_4]
.text$mn:00002E3D                 add     eax, 4
.text$mn:00002E40                 mov     [ebp+var_8], eax
.text$mn:00002E43
.text$mn:00002E43 loc_2E43:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00002E43                 mov     eax, [ebp+var_8]
.text$mn:00002E46                 mov     esp, ebp
.text$mn:00002E48                 pop     ebp
.text$mn:00002E49                 retn
.text$mn:00002E49 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00002E49
.text$mn:00002E49 ; ---------------------------------------------------------------------------
.text$mn:00002E4A                 align 4
.text$mn:00002E4A _text$mn        ends
.text$mn:00002E4A
.text$mn:00002E4C ; ===========================================================================
.text$mn:00002E4C
.text$mn:00002E4C ; Segment type: Pure code
.text$mn:00002E4C ; Segment permissions: Read/Execute
.text$mn:00002E4C _text$mn        segment para public 'CODE' use32
.text$mn:00002E4C                 assume cs:_text$mn
.text$mn:00002E4C                 ;org 2E4Ch
.text$mn:00002E4C ; COMDAT (pick any)
.text$mn:00002E4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E4C
.text$mn:00002E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E4C
.text$mn:00002E4C ; Attributes: bp-based frame
.text$mn:00002E4C
.text$mn:00002E4C ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00002E4C                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00002E4C ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00002E4C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:00002E4C
.text$mn:00002E4C var_8           = dword ptr -8
.text$mn:00002E4C var_4           = dword ptr -4
.text$mn:00002E4C
.text$mn:00002E4C                 push    ebp
.text$mn:00002E4D                 mov     ebp, esp
.text$mn:00002E4F                 sub     esp, 8
.text$mn:00002E52                 mov     [ebp+var_4], ecx
.text$mn:00002E55                 mov     eax, [ebp+var_4]
.text$mn:00002E58                 cmp     dword ptr [eax+18h], 8
.text$mn:00002E5C                 jb      short loc_2E72
.text$mn:00002E5E                 mov     ecx, [ebp+var_4]
.text$mn:00002E61                 mov     edx, [ecx+4]
.text$mn:00002E64                 push    edx
.text$mn:00002E65                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00002E6A                 add     esp, 4
.text$mn:00002E6D                 mov     [ebp+var_8], eax
.text$mn:00002E70                 jmp     short loc_2E7B
.text$mn:00002E72 ; ---------------------------------------------------------------------------
.text$mn:00002E72
.text$mn:00002E72 loc_2E72:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00002E72                 mov     eax, [ebp+var_4]
.text$mn:00002E75                 add     eax, 4
.text$mn:00002E78                 mov     [ebp+var_8], eax
.text$mn:00002E7B
.text$mn:00002E7B loc_2E7B:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00002E7B                 mov     eax, [ebp+var_8]
.text$mn:00002E7E                 mov     esp, ebp
.text$mn:00002E80                 pop     ebp
.text$mn:00002E81                 retn
.text$mn:00002E81 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00002E81
.text$mn:00002E81 ; ---------------------------------------------------------------------------
.text$mn:00002E82                 align 4
.text$mn:00002E82 _text$mn        ends
.text$mn:00002E82
.text$mn:00002E84 ; ===========================================================================
.text$mn:00002E84
.text$mn:00002E84 ; Segment type: Pure code
.text$mn:00002E84 ; Segment permissions: Read/Execute
.text$mn:00002E84 _text$mn        segment para public 'CODE' use32
.text$mn:00002E84                 assume cs:_text$mn
.text$mn:00002E84                 ;org 2E84h
.text$mn:00002E84 ; COMDAT (pick any)
.text$mn:00002E84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E84
.text$mn:00002E84 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E84
.text$mn:00002E84 ; Attributes: bp-based frame
.text$mn:00002E84
.text$mn:00002E84 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00002E84                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002E84 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00002E84                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00002E84                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00002E84
.text$mn:00002E84 var_18          = byte ptr -18h
.text$mn:00002E84 var_14          = dword ptr -14h
.text$mn:00002E84 var_10          = dword ptr -10h
.text$mn:00002E84 var_C           = dword ptr -0Ch
.text$mn:00002E84 var_4           = dword ptr -4
.text$mn:00002E84
.text$mn:00002E84                 push    ebp
.text$mn:00002E85                 mov     ebp, esp
.text$mn:00002E87                 push    0FFFFFFFFh
.text$mn:00002E89                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002E8E                 mov     eax, large fs:0
.text$mn:00002E94                 push    eax
.text$mn:00002E95                 sub     esp, 0Ch
.text$mn:00002E98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E9D                 xor     eax, ebp
.text$mn:00002E9F                 push    eax
.text$mn:00002EA0                 lea     eax, [ebp+var_C]
.text$mn:00002EA3                 mov     large fs:0, eax
.text$mn:00002EA9                 mov     [ebp+var_14], ecx
.text$mn:00002EAC                 mov     eax, [ebp+var_14]
.text$mn:00002EAF                 cmp     dword ptr [eax], 0
.text$mn:00002EB2                 jz      short loc_2F0F
.text$mn:00002EB4                 push    3               ; int
.text$mn:00002EB6                 lea     ecx, [ebp+var_18] ; this
.text$mn:00002EB9                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00002EBE                 mov     [ebp+var_4], 0
.text$mn:00002EC5                 mov     ecx, [ebp+var_14]
.text$mn:00002EC8                 mov     edx, [ecx]
.text$mn:00002ECA                 add     edx, 4
.text$mn:00002ECD                 mov     [ebp+var_10], edx
.text$mn:00002ED0                 jmp     short loc_2EDF
.text$mn:00002ED2 ; ---------------------------------------------------------------------------
.text$mn:00002ED2
.text$mn:00002ED2 loc_2ED2:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00002ED2                 mov     eax, [ebp+var_10]
.text$mn:00002ED5                 mov     ecx, [eax]
.text$mn:00002ED7                 mov     edx, [ebp+var_10]
.text$mn:00002EDA                 mov     eax, [ecx+4]
.text$mn:00002EDD                 mov     [edx], eax
.text$mn:00002EDF
.text$mn:00002EDF loc_2EDF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00002EDF                 mov     ecx, [ebp+var_10]
.text$mn:00002EE2                 cmp     dword ptr [ecx], 0
.text$mn:00002EE5                 jz      short loc_2EF4
.text$mn:00002EE7                 mov     edx, [ebp+var_10]
.text$mn:00002EEA                 mov     eax, [edx]
.text$mn:00002EEC                 mov     dword ptr [eax], 0
.text$mn:00002EF2                 jmp     short loc_2ED2
.text$mn:00002EF4 ; ---------------------------------------------------------------------------
.text$mn:00002EF4
.text$mn:00002EF4 loc_2EF4:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00002EF4                 mov     ecx, [ebp+var_14]
.text$mn:00002EF7                 mov     edx, [ecx]
.text$mn:00002EF9                 mov     dword ptr [edx+4], 0
.text$mn:00002F00                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F07                 lea     ecx, [ebp+var_18] ; this
.text$mn:00002F0A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00002F0F
.text$mn:00002F0F loc_2F0F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00002F0F                 mov     ecx, [ebp+var_C]
.text$mn:00002F12                 mov     large fs:0, ecx
.text$mn:00002F19                 pop     ecx
.text$mn:00002F1A                 mov     esp, ebp
.text$mn:00002F1C                 pop     ebp
.text$mn:00002F1D                 retn
.text$mn:00002F1D ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00002F1D
.text$mn:00002F1D ; ---------------------------------------------------------------------------
.text$mn:00002F1E                 align 10h
.text$mn:00002F1E _text$mn        ends
.text$mn:00002F1E
.text$x:00002F20 ; ===========================================================================
.text$x:00002F20
.text$x:00002F20 ; Segment type: Pure code
.text$x:00002F20 ; Segment permissions: Read/Execute
.text$x:00002F20 _text$x         segment para public 'CODE' use32
.text$x:00002F20                 assume cs:_text$x
.text$x:00002F20                 ;org 2F20h
.text$x:00002F20 ; COMDAT (pick associative to section at 2E84)
.text$x:00002F20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002F20
.text$x:00002F20 ; =============== S U B R O U T I N E =======================================
.text$x:00002F20
.text$x:00002F20
.text$x:00002F20 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00002F20                                         ; DATA XREF: .xdata$x:00003E2Co
.text$x:00002F20                 lea     ecx, [ebp-18h]  ; this
.text$x:00002F23                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00002F23 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00002F23
.text$x:00002F28
.text$x:00002F28 ; =============== S U B R O U T I N E =======================================
.text$x:00002F28
.text$x:00002F28
.text$x:00002F28 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00002F28                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00002F28
.text$x:00002F28 arg_4           = dword ptr  8
.text$x:00002F28
.text$x:00002F28                 mov     edx, [esp+arg_4]
.text$x:00002F2C                 lea     eax, [edx+0Ch]
.text$x:00002F2F                 mov     ecx, [edx-10h]
.text$x:00002F32                 xor     ecx, eax
.text$x:00002F34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F39                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00002F3E                 jmp     ___CxxFrameHandler3
.text$x:00002F3E __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00002F3E
.text$x:00002F3E ; ---------------------------------------------------------------------------
.text$x:00002F43                 align 4
.text$x:00002F43 _text$x         ends
.text$x:00002F43
.text$mn:00002F44 ; ===========================================================================
.text$mn:00002F44
.text$mn:00002F44 ; Segment type: Pure code
.text$mn:00002F44 ; Segment permissions: Read/Execute
.text$mn:00002F44 _text$mn        segment para public 'CODE' use32
.text$mn:00002F44                 assume cs:_text$mn
.text$mn:00002F44                 ;org 2F44h
.text$mn:00002F44 ; COMDAT (pick any)
.text$mn:00002F44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F44
.text$mn:00002F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F44
.text$mn:00002F44 ; Attributes: bp-based frame
.text$mn:00002F44
.text$mn:00002F44 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00002F44                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00002F44 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00002F44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00002F44                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00002F44
.text$mn:00002F44 var_C           = dword ptr -0Ch
.text$mn:00002F44 var_8           = dword ptr -8
.text$mn:00002F44 var_2           = byte ptr -2
.text$mn:00002F44 var_1           = byte ptr -1
.text$mn:00002F44 arg_0           = byte ptr  8
.text$mn:00002F44 Size            = dword ptr  0Ch
.text$mn:00002F44
.text$mn:00002F44                 push    ebp
.text$mn:00002F45                 mov     ebp, esp
.text$mn:00002F47                 sub     esp, 0Ch
.text$mn:00002F4A                 mov     [ebp+var_8], ecx
.text$mn:00002F4D                 movzx   eax, [ebp+arg_0]
.text$mn:00002F51                 test    eax, eax
.text$mn:00002F53                 jnz     short loc_2F57
.text$mn:00002F55                 jmp     short loc_2FCA
.text$mn:00002F57 ; ---------------------------------------------------------------------------
.text$mn:00002F57
.text$mn:00002F57 loc_2F57:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00002F57                 mov     ecx, [ebp+var_8]
.text$mn:00002F5A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00002F5E                 jb      short loc_2FCA
.text$mn:00002F60                 mov     edx, [ebp+var_8]
.text$mn:00002F63                 mov     eax, [edx+4]
.text$mn:00002F66                 mov     [ebp+var_C], eax
.text$mn:00002F69                 mov     ecx, [ebp+var_8]
.text$mn:00002F6C                 add     ecx, 4
.text$mn:00002F6F                 push    ecx
.text$mn:00002F70                 lea     edx, [ebp+var_1]
.text$mn:00002F73                 push    edx
.text$mn:00002F74                 mov     ecx, [ebp+var_8]
.text$mn:00002F77                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002F7C                 mov     ecx, eax
.text$mn:00002F7E                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002F83                 cmp     [ebp+Size], 0
.text$mn:00002F87                 jbe     short loc_2FA9
.text$mn:00002F89                 mov     eax, [ebp+Size]
.text$mn:00002F8C                 push    eax             ; Size
.text$mn:00002F8D                 mov     ecx, [ebp+var_C]
.text$mn:00002F90                 push    ecx
.text$mn:00002F91                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002F96                 add     esp, 4
.text$mn:00002F99                 push    eax             ; Src
.text$mn:00002F9A                 mov     edx, [ebp+var_8]
.text$mn:00002F9D                 add     edx, 4
.text$mn:00002FA0                 push    edx             ; Dst
.text$mn:00002FA1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002FA6                 add     esp, 0Ch
.text$mn:00002FA9
.text$mn:00002FA9 loc_2FA9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002FA9                 mov     eax, [ebp+var_8]
.text$mn:00002FAC                 mov     ecx, [eax+18h]
.text$mn:00002FAF                 add     ecx, 1
.text$mn:00002FB2                 push    ecx             ; int
.text$mn:00002FB3                 mov     edx, [ebp+var_C]
.text$mn:00002FB6                 push    edx             ; void *
.text$mn:00002FB7                 lea     eax, [ebp+var_2]
.text$mn:00002FBA                 push    eax
.text$mn:00002FBB                 mov     ecx, [ebp+var_8]
.text$mn:00002FBE                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002FC3                 mov     ecx, eax
.text$mn:00002FC5                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00002FCA
.text$mn:00002FCA loc_2FCA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00002FCA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00002FCA                 mov     ecx, [ebp+var_8]
.text$mn:00002FCD                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00002FD4                 mov     edx, [ebp+Size]
.text$mn:00002FD7                 push    edx
.text$mn:00002FD8                 mov     ecx, [ebp+var_8]
.text$mn:00002FDB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002FE0                 mov     esp, ebp
.text$mn:00002FE2                 pop     ebp
.text$mn:00002FE3                 retn    8
.text$mn:00002FE3 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00002FE3
.text$mn:00002FE3 ; ---------------------------------------------------------------------------
.text$mn:00002FE6                 align 4
.text$mn:00002FE6 _text$mn        ends
.text$mn:00002FE6
.text$mn:00002FE8 ; ===========================================================================
.text$mn:00002FE8
.text$mn:00002FE8 ; Segment type: Pure code
.text$mn:00002FE8 ; Segment permissions: Read/Execute
.text$mn:00002FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002FE8                 assume cs:_text$mn
.text$mn:00002FE8                 ;org 2FE8h
.text$mn:00002FE8 ; COMDAT (pick any)
.text$mn:00002FE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002FE8
.text$mn:00002FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FE8
.text$mn:00002FE8 ; Attributes: bp-based frame
.text$mn:00002FE8
.text$mn:00002FE8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00002FE8                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00002FE8 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00002FE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p
.text$mn:00002FE8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+47p ...
.text$mn:00002FE8
.text$mn:00002FE8 var_C           = dword ptr -0Ch
.text$mn:00002FE8 var_8           = dword ptr -8
.text$mn:00002FE8 var_2           = byte ptr -2
.text$mn:00002FE8 var_1           = byte ptr -1
.text$mn:00002FE8 arg_0           = byte ptr  8
.text$mn:00002FE8 arg_4           = dword ptr  0Ch
.text$mn:00002FE8
.text$mn:00002FE8                 push    ebp
.text$mn:00002FE9                 mov     ebp, esp
.text$mn:00002FEB                 sub     esp, 0Ch
.text$mn:00002FEE                 mov     [ebp+var_8], ecx
.text$mn:00002FF1                 movzx   eax, [ebp+arg_0]
.text$mn:00002FF5                 test    eax, eax
.text$mn:00002FF7                 jnz     short loc_2FFB
.text$mn:00002FF9                 jmp     short loc_306E
.text$mn:00002FFB ; ---------------------------------------------------------------------------
.text$mn:00002FFB
.text$mn:00002FFB loc_2FFB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00002FFB                 mov     ecx, [ebp+var_8]
.text$mn:00002FFE                 cmp     dword ptr [ecx+18h], 8
.text$mn:00003002                 jb      short loc_306E
.text$mn:00003004                 mov     edx, [ebp+var_8]
.text$mn:00003007                 mov     eax, [edx+4]
.text$mn:0000300A                 mov     [ebp+var_C], eax
.text$mn:0000300D                 mov     ecx, [ebp+var_8]
.text$mn:00003010                 add     ecx, 4
.text$mn:00003013                 push    ecx
.text$mn:00003014                 lea     edx, [ebp+var_1]
.text$mn:00003017                 push    edx
.text$mn:00003018                 mov     ecx, [ebp+var_8]
.text$mn:0000301B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003020                 mov     ecx, eax
.text$mn:00003022                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00003027                 cmp     [ebp+arg_4], 0
.text$mn:0000302B                 jbe     short loc_304D
.text$mn:0000302D                 mov     eax, [ebp+arg_4]
.text$mn:00003030                 push    eax             ; int
.text$mn:00003031                 mov     ecx, [ebp+var_C]
.text$mn:00003034                 push    ecx
.text$mn:00003035                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000303A                 add     esp, 4
.text$mn:0000303D                 push    eax             ; Src
.text$mn:0000303E                 mov     edx, [ebp+var_8]
.text$mn:00003041                 add     edx, 4
.text$mn:00003044                 push    edx             ; Dst
.text$mn:00003045                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000304A                 add     esp, 0Ch
.text$mn:0000304D
.text$mn:0000304D loc_304D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000304D                 mov     eax, [ebp+var_8]
.text$mn:00003050                 mov     ecx, [eax+18h]
.text$mn:00003053                 add     ecx, 1
.text$mn:00003056                 push    ecx             ; int
.text$mn:00003057                 mov     edx, [ebp+var_C]
.text$mn:0000305A                 push    edx             ; void *
.text$mn:0000305B                 lea     eax, [ebp+var_2]
.text$mn:0000305E                 push    eax
.text$mn:0000305F                 mov     ecx, [ebp+var_8]
.text$mn:00003062                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003067                 mov     ecx, eax
.text$mn:00003069                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:0000306E
.text$mn:0000306E loc_306E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:0000306E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:0000306E                 mov     ecx, [ebp+var_8]
.text$mn:00003071                 mov     dword ptr [ecx+18h], 7
.text$mn:00003078                 mov     edx, [ebp+arg_4]
.text$mn:0000307B                 push    edx
.text$mn:0000307C                 mov     ecx, [ebp+var_8]
.text$mn:0000307F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003084                 mov     esp, ebp
.text$mn:00003086                 pop     ebp
.text$mn:00003087                 retn    8
.text$mn:00003087 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00003087
.text$mn:00003087 ; ---------------------------------------------------------------------------
.text$mn:0000308A                 align 4
.text$mn:0000308A _text$mn        ends
.text$mn:0000308A
.text$mn:0000308C ; ===========================================================================
.text$mn:0000308C
.text$mn:0000308C ; Segment type: Pure code
.text$mn:0000308C ; Segment permissions: Read/Execute
.text$mn:0000308C _text$mn        segment para public 'CODE' use32
.text$mn:0000308C                 assume cs:_text$mn
.text$mn:0000308C                 ;org 308Ch
.text$mn:0000308C ; COMDAT (pick any)
.text$mn:0000308C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000308C
.text$mn:0000308C ; =============== S U B R O U T I N E =======================================
.text$mn:0000308C
.text$mn:0000308C ; Attributes: bp-based frame
.text$mn:0000308C
.text$mn:0000308C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000308C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000308C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000308C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000308C
.text$mn:0000308C var_4           = dword ptr -4
.text$mn:0000308C
.text$mn:0000308C                 push    ebp
.text$mn:0000308D                 mov     ebp, esp
.text$mn:0000308F                 push    ecx
.text$mn:00003090                 mov     [ebp+var_4], ecx
.text$mn:00003093                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00003098                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000309D                 mov     esp, ebp
.text$mn:0000309F                 pop     ebp
.text$mn:000030A0                 retn
.text$mn:000030A0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000030A0
.text$mn:000030A0 ; ---------------------------------------------------------------------------
.text$mn:000030A1                 align 4
.text$mn:000030A1 _text$mn        ends
.text$mn:000030A1
.text$mn:000030A4 ; ===========================================================================
.text$mn:000030A4
.text$mn:000030A4 ; Segment type: Pure code
.text$mn:000030A4 ; Segment permissions: Read/Execute
.text$mn:000030A4 _text$mn        segment para public 'CODE' use32
.text$mn:000030A4                 assume cs:_text$mn
.text$mn:000030A4                 ;org 30A4h
.text$mn:000030A4 ; COMDAT (pick any)
.text$mn:000030A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030A4
.text$mn:000030A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000030A4
.text$mn:000030A4 ; Attributes: bp-based frame
.text$mn:000030A4
.text$mn:000030A4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:000030A4                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000030A4 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000030A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:000030A4
.text$mn:000030A4 var_4           = dword ptr -4
.text$mn:000030A4
.text$mn:000030A4                 push    ebp
.text$mn:000030A5                 mov     ebp, esp
.text$mn:000030A7                 push    ecx
.text$mn:000030A8                 mov     [ebp+var_4], ecx
.text$mn:000030AB                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000030B0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000030B5                 mov     esp, ebp
.text$mn:000030B7                 pop     ebp
.text$mn:000030B8                 retn
.text$mn:000030B8 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:000030B8
.text$mn:000030B8 ; ---------------------------------------------------------------------------
.text$mn:000030B9                 align 4
.text$mn:000030B9 _text$mn        ends
.text$mn:000030B9
.text$mn:000030BC ; ===========================================================================
.text$mn:000030BC
.text$mn:000030BC ; Segment type: Pure code
.text$mn:000030BC ; Segment permissions: Read/Execute
.text$mn:000030BC _text$mn        segment para public 'CODE' use32
.text$mn:000030BC                 assume cs:_text$mn
.text$mn:000030BC                 ;org 30BCh
.text$mn:000030BC ; COMDAT (pick any)
.text$mn:000030BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030BC
.text$mn:000030BC ; =============== S U B R O U T I N E =======================================
.text$mn:000030BC
.text$mn:000030BC ; Attributes: bp-based frame
.text$mn:000030BC
.text$mn:000030BC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000030BC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000030BC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000030BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000030BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000030BC
.text$mn:000030BC var_4           = dword ptr -4
.text$mn:000030BC
.text$mn:000030BC                 push    ebp
.text$mn:000030BD                 mov     ebp, esp
.text$mn:000030BF                 push    ecx
.text$mn:000030C0                 mov     [ebp+var_4], ecx
.text$mn:000030C3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000030C8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000030CD                 mov     esp, ebp
.text$mn:000030CF                 pop     ebp
.text$mn:000030D0                 retn
.text$mn:000030D0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000030D0
.text$mn:000030D0 ; ---------------------------------------------------------------------------
.text$mn:000030D1                 align 4
.text$mn:000030D1 _text$mn        ends
.text$mn:000030D1
.text$mn:000030D4 ; ===========================================================================
.text$mn:000030D4
.text$mn:000030D4 ; Segment type: Pure code
.text$mn:000030D4 ; Segment permissions: Read/Execute
.text$mn:000030D4 _text$mn        segment para public 'CODE' use32
.text$mn:000030D4                 assume cs:_text$mn
.text$mn:000030D4                 ;org 30D4h
.text$mn:000030D4 ; COMDAT (pick any)
.text$mn:000030D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030D4
.text$mn:000030D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000030D4
.text$mn:000030D4 ; Attributes: bp-based frame
.text$mn:000030D4
.text$mn:000030D4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:000030D4                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000030D4 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000030D4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:000030D4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+15p ...
.text$mn:000030D4
.text$mn:000030D4 var_4           = dword ptr -4
.text$mn:000030D4
.text$mn:000030D4                 push    ebp
.text$mn:000030D5                 mov     ebp, esp
.text$mn:000030D7                 push    ecx
.text$mn:000030D8                 mov     [ebp+var_4], ecx
.text$mn:000030DB                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000030E0                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000030E5                 mov     esp, ebp
.text$mn:000030E7                 pop     ebp
.text$mn:000030E8                 retn
.text$mn:000030E8 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:000030E8
.text$mn:000030E8 ; ---------------------------------------------------------------------------
.text$mn:000030E9                 align 4
.text$mn:000030E9 _text$mn        ends
.text$mn:000030E9
.text$mn:000030EC ; ===========================================================================
.text$mn:000030EC
.text$mn:000030EC ; Segment type: Pure code
.text$mn:000030EC ; Segment permissions: Read/Execute
.text$mn:000030EC _text$mn        segment para public 'CODE' use32
.text$mn:000030EC                 assume cs:_text$mn
.text$mn:000030EC                 ;org 30ECh
.text$mn:000030EC ; COMDAT (pick any)
.text$mn:000030EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030EC
.text$mn:000030EC ; =============== S U B R O U T I N E =======================================
.text$mn:000030EC
.text$mn:000030EC ; Attributes: bp-based frame
.text$mn:000030EC
.text$mn:000030EC ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000030EC                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000030EC ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000030EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000030EC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000030EC
.text$mn:000030EC var_4           = dword ptr -4
.text$mn:000030EC arg_0           = dword ptr  8
.text$mn:000030EC
.text$mn:000030EC                 push    ebp
.text$mn:000030ED                 mov     ebp, esp
.text$mn:000030EF                 push    ecx
.text$mn:000030F0                 mov     [ebp+var_4], ecx
.text$mn:000030F3                 mov     eax, [ebp+arg_0]
.text$mn:000030F6                 push    eax
.text$mn:000030F7                 mov     ecx, [ebp+var_4]
.text$mn:000030FA                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000030FF                 mov     esp, ebp
.text$mn:00003101                 pop     ebp
.text$mn:00003102                 retn    4
.text$mn:00003102 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00003102
.text$mn:00003102 ; ---------------------------------------------------------------------------
.text$mn:00003105                 align 4
.text$mn:00003105 _text$mn        ends
.text$mn:00003105
.text$mn:00003108 ; ===========================================================================
.text$mn:00003108
.text$mn:00003108 ; Segment type: Pure code
.text$mn:00003108 ; Segment permissions: Read/Execute
.text$mn:00003108 _text$mn        segment para public 'CODE' use32
.text$mn:00003108                 assume cs:_text$mn
.text$mn:00003108                 ;org 3108h
.text$mn:00003108 ; COMDAT (pick any)
.text$mn:00003108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003108
.text$mn:00003108 ; =============== S U B R O U T I N E =======================================
.text$mn:00003108
.text$mn:00003108 ; Attributes: bp-based frame
.text$mn:00003108
.text$mn:00003108 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00003108                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00003108 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00003108                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00003108                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00003108
.text$mn:00003108 var_4           = dword ptr -4
.text$mn:00003108 arg_0           = dword ptr  8
.text$mn:00003108
.text$mn:00003108                 push    ebp
.text$mn:00003109                 mov     ebp, esp
.text$mn:0000310B                 push    ecx
.text$mn:0000310C                 mov     [ebp+var_4], ecx
.text$mn:0000310F                 mov     eax, [ebp+arg_0]
.text$mn:00003112                 push    eax
.text$mn:00003113                 mov     ecx, [ebp+var_4]
.text$mn:00003116                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000311B                 mov     esp, ebp
.text$mn:0000311D                 pop     ebp
.text$mn:0000311E                 retn    4
.text$mn:0000311E ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000311E
.text$mn:0000311E ; ---------------------------------------------------------------------------
.text$mn:00003121                 align 4
.text$mn:00003121 _text$mn        ends
.text$mn:00003121
.text$mn:00003124 ; ===========================================================================
.text$mn:00003124
.text$mn:00003124 ; Segment type: Pure code
.text$mn:00003124 ; Segment permissions: Read/Execute
.text$mn:00003124 _text$mn        segment para public 'CODE' use32
.text$mn:00003124                 assume cs:_text$mn
.text$mn:00003124                 ;org 3124h
.text$mn:00003124 ; COMDAT (pick any)
.text$mn:00003124                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003124
.text$mn:00003124 ; =============== S U B R O U T I N E =======================================
.text$mn:00003124
.text$mn:00003124 ; Attributes: bp-based frame
.text$mn:00003124
.text$mn:00003124 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00003124                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00003124 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00003124                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00003124
.text$mn:00003124 var_4           = dword ptr -4
.text$mn:00003124 arg_0           = dword ptr  8
.text$mn:00003124
.text$mn:00003124                 push    ebp
.text$mn:00003125                 mov     ebp, esp
.text$mn:00003127                 push    ecx
.text$mn:00003128                 mov     [ebp+var_4], ecx
.text$mn:0000312B                 push    0
.text$mn:0000312D                 mov     eax, [ebp+arg_0]
.text$mn:00003130                 push    eax
.text$mn:00003131                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00003136                 add     esp, 8
.text$mn:00003139                 mov     esp, ebp
.text$mn:0000313B                 pop     ebp
.text$mn:0000313C                 retn    4
.text$mn:0000313C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000313C
.text$mn:0000313C ; ---------------------------------------------------------------------------
.text$mn:0000313F                 align 10h
.text$mn:0000313F _text$mn        ends
.text$mn:0000313F
.text$mn:00003140 ; ===========================================================================
.text$mn:00003140
.text$mn:00003140 ; Segment type: Pure code
.text$mn:00003140 ; Segment permissions: Read/Execute
.text$mn:00003140 _text$mn        segment para public 'CODE' use32
.text$mn:00003140                 assume cs:_text$mn
.text$mn:00003140                 ;org 3140h
.text$mn:00003140 ; COMDAT (pick any)
.text$mn:00003140                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003140
.text$mn:00003140 ; =============== S U B R O U T I N E =======================================
.text$mn:00003140
.text$mn:00003140 ; Attributes: bp-based frame
.text$mn:00003140
.text$mn:00003140 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00003140                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00003140 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00003140                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00003140                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:00003140
.text$mn:00003140 var_4           = dword ptr -4
.text$mn:00003140 arg_0           = dword ptr  8
.text$mn:00003140
.text$mn:00003140                 push    ebp
.text$mn:00003141                 mov     ebp, esp
.text$mn:00003143                 push    ecx
.text$mn:00003144                 mov     [ebp+var_4], ecx
.text$mn:00003147                 push    0
.text$mn:00003149                 mov     eax, [ebp+arg_0]
.text$mn:0000314C                 push    eax
.text$mn:0000314D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00003152                 add     esp, 8
.text$mn:00003155                 mov     esp, ebp
.text$mn:00003157                 pop     ebp
.text$mn:00003158                 retn    4
.text$mn:00003158 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00003158
.text$mn:00003158 ; ---------------------------------------------------------------------------
.text$mn:0000315B                 align 4
.text$mn:0000315B _text$mn        ends
.text$mn:0000315B
.text$mn:0000315C ; ===========================================================================
.text$mn:0000315C
.text$mn:0000315C ; Segment type: Pure code
.text$mn:0000315C ; Segment permissions: Read/Execute
.text$mn:0000315C _text$mn        segment para public 'CODE' use32
.text$mn:0000315C                 assume cs:_text$mn
.text$mn:0000315C                 ;org 315Ch
.text$mn:0000315C ; COMDAT (pick any)
.text$mn:0000315C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000315C
.text$mn:0000315C ; =============== S U B R O U T I N E =======================================
.text$mn:0000315C
.text$mn:0000315C ; Attributes: bp-based frame
.text$mn:0000315C
.text$mn:0000315C ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:0000315C                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:0000315C ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:0000315C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:0000315C
.text$mn:0000315C var_4           = dword ptr -4
.text$mn:0000315C arg_0           = dword ptr  8
.text$mn:0000315C
.text$mn:0000315C                 push    ebp
.text$mn:0000315D                 mov     ebp, esp
.text$mn:0000315F                 push    ecx
.text$mn:00003160                 mov     [ebp+var_4], ecx
.text$mn:00003163                 push    0
.text$mn:00003165                 mov     eax, [ebp+arg_0]
.text$mn:00003168                 push    eax
.text$mn:00003169                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000316E                 add     esp, 8
.text$mn:00003171                 mov     esp, ebp
.text$mn:00003173                 pop     ebp
.text$mn:00003174                 retn    4
.text$mn:00003174 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00003174
.text$mn:00003174 ; ---------------------------------------------------------------------------
.text$mn:00003177                 align 4
.text$mn:00003177 _text$mn        ends
.text$mn:00003177
.text$mn:00003178 ; ===========================================================================
.text$mn:00003178
.text$mn:00003178 ; Segment type: Pure code
.text$mn:00003178 ; Segment permissions: Read/Execute
.text$mn:00003178 _text$mn        segment para public 'CODE' use32
.text$mn:00003178                 assume cs:_text$mn
.text$mn:00003178                 ;org 3178h
.text$mn:00003178 ; COMDAT (pick any)
.text$mn:00003178                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003178
.text$mn:00003178 ; =============== S U B R O U T I N E =======================================
.text$mn:00003178
.text$mn:00003178 ; Attributes: bp-based frame
.text$mn:00003178
.text$mn:00003178 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00003178                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00003178 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00003178                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00003178
.text$mn:00003178 Size            = dword ptr -8
.text$mn:00003178 var_4           = dword ptr -4
.text$mn:00003178 arg_0           = dword ptr  8
.text$mn:00003178 arg_4           = dword ptr  0Ch
.text$mn:00003178 arg_8           = dword ptr  10h
.text$mn:00003178
.text$mn:00003178                 push    ebp
.text$mn:00003179                 mov     ebp, esp
.text$mn:0000317B                 sub     esp, 8
.text$mn:0000317E                 mov     [ebp+var_4], ecx
.text$mn:00003181                 mov     ecx, [ebp+arg_0]
.text$mn:00003184                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00003189                 cmp     eax, [ebp+arg_4]
.text$mn:0000318C                 jnb     short loc_3196
.text$mn:0000318E                 mov     ecx, [ebp+var_4]
.text$mn:00003191                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003196
.text$mn:00003196 loc_3196:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00003196                 mov     ecx, [ebp+arg_0]
.text$mn:00003199                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000319E                 sub     eax, [ebp+arg_4]
.text$mn:000031A1                 mov     [ebp+Size], eax
.text$mn:000031A4                 mov     eax, [ebp+arg_8]
.text$mn:000031A7                 cmp     eax, [ebp+Size]
.text$mn:000031AA                 jnb     short loc_31B2
.text$mn:000031AC                 mov     ecx, [ebp+arg_8]
.text$mn:000031AF                 mov     [ebp+Size], ecx
.text$mn:000031B2
.text$mn:000031B2 loc_31B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000031B2                 mov     edx, [ebp+var_4]
.text$mn:000031B5                 cmp     edx, [ebp+arg_0]
.text$mn:000031B8                 jnz     short loc_31D9
.text$mn:000031BA                 mov     eax, [ebp+arg_4]
.text$mn:000031BD                 add     eax, [ebp+Size]
.text$mn:000031C0                 push    eax
.text$mn:000031C1                 mov     ecx, [ebp+var_4]
.text$mn:000031C4                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000031C9                 mov     ecx, [ebp+arg_4]
.text$mn:000031CC                 push    ecx
.text$mn:000031CD                 push    0
.text$mn:000031CF                 mov     ecx, [ebp+var_4]
.text$mn:000031D2                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000031D7                 jmp     short loc_321B
.text$mn:000031D9 ; ---------------------------------------------------------------------------
.text$mn:000031D9
.text$mn:000031D9 loc_31D9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000031D9                 push    0
.text$mn:000031DB                 mov     edx, [ebp+Size]
.text$mn:000031DE                 push    edx
.text$mn:000031DF                 mov     ecx, [ebp+var_4]
.text$mn:000031E2                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000031E7                 movzx   eax, al
.text$mn:000031EA                 test    eax, eax
.text$mn:000031EC                 jz      short loc_321B
.text$mn:000031EE                 mov     ecx, [ebp+Size]
.text$mn:000031F1                 push    ecx             ; Size
.text$mn:000031F2                 mov     ecx, [ebp+arg_0]
.text$mn:000031F5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000031FA                 add     eax, [ebp+arg_4]
.text$mn:000031FD                 push    eax             ; Src
.text$mn:000031FE                 mov     ecx, [ebp+var_4]
.text$mn:00003201                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003206                 push    eax             ; Dst
.text$mn:00003207                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000320C                 add     esp, 0Ch
.text$mn:0000320F                 mov     edx, [ebp+Size]
.text$mn:00003212                 push    edx
.text$mn:00003213                 mov     ecx, [ebp+var_4]
.text$mn:00003216                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000321B
.text$mn:0000321B loc_321B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000321B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000321B                 mov     eax, [ebp+var_4]
.text$mn:0000321E                 mov     esp, ebp
.text$mn:00003220                 pop     ebp
.text$mn:00003221                 retn    0Ch
.text$mn:00003221 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00003221
.text$mn:00003221 _text$mn        ends
.text$mn:00003221
.text$mn:00003224 ; ===========================================================================
.text$mn:00003224
.text$mn:00003224 ; Segment type: Pure code
.text$mn:00003224 ; Segment permissions: Read/Execute
.text$mn:00003224 _text$mn        segment para public 'CODE' use32
.text$mn:00003224                 assume cs:_text$mn
.text$mn:00003224                 ;org 3224h
.text$mn:00003224 ; COMDAT (pick any)
.text$mn:00003224                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003224
.text$mn:00003224 ; =============== S U B R O U T I N E =======================================
.text$mn:00003224
.text$mn:00003224 ; Attributes: bp-based frame
.text$mn:00003224
.text$mn:00003224 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00003224                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00003224 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00003224                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00003224
.text$mn:00003224 var_4           = dword ptr -4
.text$mn:00003224 Str             = dword ptr  8
.text$mn:00003224
.text$mn:00003224                 push    ebp
.text$mn:00003225                 mov     ebp, esp
.text$mn:00003227                 push    ecx
.text$mn:00003228                 mov     [ebp+var_4], ecx
.text$mn:0000322B                 push    490h            ; unsigned int
.text$mn:00003230                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003235                 mov     eax, [ebp+Str]
.text$mn:00003238                 push    eax             ; int
.text$mn:00003239                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000323E                 add     esp, 0Ch
.text$mn:00003241                 mov     ecx, [ebp+Str]
.text$mn:00003244                 push    ecx             ; Str
.text$mn:00003245                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000324A                 add     esp, 4
.text$mn:0000324D                 push    eax             ; Size
.text$mn:0000324E                 mov     edx, [ebp+Str]
.text$mn:00003251                 push    edx             ; Src
.text$mn:00003252                 mov     ecx, [ebp+var_4]
.text$mn:00003255                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000325A                 mov     esp, ebp
.text$mn:0000325C                 pop     ebp
.text$mn:0000325D                 retn    4
.text$mn:0000325D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000325D
.text$mn:0000325D _text$mn        ends
.text$mn:0000325D
.text$mn:00003260 ; ===========================================================================
.text$mn:00003260
.text$mn:00003260 ; Segment type: Pure code
.text$mn:00003260 ; Segment permissions: Read/Execute
.text$mn:00003260 _text$mn        segment para public 'CODE' use32
.text$mn:00003260                 assume cs:_text$mn
.text$mn:00003260                 ;org 3260h
.text$mn:00003260 ; COMDAT (pick any)
.text$mn:00003260                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003260
.text$mn:00003260 ; =============== S U B R O U T I N E =======================================
.text$mn:00003260
.text$mn:00003260 ; Attributes: bp-based frame
.text$mn:00003260
.text$mn:00003260 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00003260                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00003260 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00003260                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00003260
.text$mn:00003260 var_4           = dword ptr -4
.text$mn:00003260 Src             = dword ptr  8
.text$mn:00003260 Size            = dword ptr  0Ch
.text$mn:00003260
.text$mn:00003260                 push    ebp
.text$mn:00003261                 mov     ebp, esp
.text$mn:00003263                 push    ecx
.text$mn:00003264                 mov     [ebp+var_4], ecx
.text$mn:00003267                 cmp     [ebp+Size], 0
.text$mn:0000326B                 jz      short loc_3283
.text$mn:0000326D                 push    47Fh            ; unsigned int
.text$mn:00003272                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003277                 mov     eax, [ebp+Src]
.text$mn:0000327A                 push    eax             ; int
.text$mn:0000327B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00003280                 add     esp, 0Ch
.text$mn:00003283
.text$mn:00003283 loc_3283:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00003283                 mov     ecx, [ebp+Src]
.text$mn:00003286                 push    ecx
.text$mn:00003287                 mov     ecx, [ebp+var_4]
.text$mn:0000328A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000328F                 movzx   edx, al
.text$mn:00003292                 test    edx, edx
.text$mn:00003294                 jz      short loc_32B6
.text$mn:00003296                 mov     eax, [ebp+Size]
.text$mn:00003299                 push    eax
.text$mn:0000329A                 mov     ecx, [ebp+var_4]
.text$mn:0000329D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000032A2                 mov     ecx, [ebp+Src]
.text$mn:000032A5                 sub     ecx, eax
.text$mn:000032A7                 push    ecx
.text$mn:000032A8                 mov     edx, [ebp+var_4]
.text$mn:000032AB                 push    edx
.text$mn:000032AC                 mov     ecx, [ebp+var_4]
.text$mn:000032AF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000032B4                 jmp     short loc_32F3
.text$mn:000032B6 ; ---------------------------------------------------------------------------
.text$mn:000032B6
.text$mn:000032B6 loc_32B6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000032B6                 push    0
.text$mn:000032B8                 mov     eax, [ebp+Size]
.text$mn:000032BB                 push    eax
.text$mn:000032BC                 mov     ecx, [ebp+var_4]
.text$mn:000032BF                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000032C4                 movzx   ecx, al
.text$mn:000032C7                 test    ecx, ecx
.text$mn:000032C9                 jz      short loc_32F0
.text$mn:000032CB                 mov     edx, [ebp+Size]
.text$mn:000032CE                 push    edx             ; Size
.text$mn:000032CF                 mov     eax, [ebp+Src]
.text$mn:000032D2                 push    eax             ; Src
.text$mn:000032D3                 mov     ecx, [ebp+var_4]
.text$mn:000032D6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000032DB                 push    eax             ; Dst
.text$mn:000032DC                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000032E1                 add     esp, 0Ch
.text$mn:000032E4                 mov     ecx, [ebp+Size]
.text$mn:000032E7                 push    ecx
.text$mn:000032E8                 mov     ecx, [ebp+var_4]
.text$mn:000032EB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000032F0
.text$mn:000032F0 loc_32F0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000032F0                 mov     eax, [ebp+var_4]
.text$mn:000032F3
.text$mn:000032F3 loc_32F3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000032F3                 mov     esp, ebp
.text$mn:000032F5                 pop     ebp
.text$mn:000032F6                 retn    8
.text$mn:000032F6 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000032F6
.text$mn:000032F6 ; ---------------------------------------------------------------------------
.text$mn:000032F9                 align 4
.text$mn:000032F9 _text$mn        ends
.text$mn:000032F9
.text$mn:000032FC ; ===========================================================================
.text$mn:000032FC
.text$mn:000032FC ; Segment type: Pure code
.text$mn:000032FC ; Segment permissions: Read/Execute
.text$mn:000032FC _text$mn        segment para public 'CODE' use32
.text$mn:000032FC                 assume cs:_text$mn
.text$mn:000032FC                 ;org 32FCh
.text$mn:000032FC ; COMDAT (pick any)
.text$mn:000032FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032FC
.text$mn:000032FC ; =============== S U B R O U T I N E =======================================
.text$mn:000032FC
.text$mn:000032FC ; Attributes: bp-based frame
.text$mn:000032FC
.text$mn:000032FC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:000032FC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000032FC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000032FC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:000032FC
.text$mn:000032FC var_8           = dword ptr -8
.text$mn:000032FC var_4           = dword ptr -4
.text$mn:000032FC arg_0           = dword ptr  8
.text$mn:000032FC arg_4           = dword ptr  0Ch
.text$mn:000032FC arg_8           = dword ptr  10h
.text$mn:000032FC
.text$mn:000032FC                 push    ebp
.text$mn:000032FD                 mov     ebp, esp
.text$mn:000032FF                 sub     esp, 8
.text$mn:00003302                 mov     [ebp+var_4], ecx
.text$mn:00003305                 mov     ecx, [ebp+arg_0]
.text$mn:00003308                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000330D                 cmp     eax, [ebp+arg_4]
.text$mn:00003310                 jnb     short loc_331A
.text$mn:00003312                 mov     ecx, [ebp+var_4]
.text$mn:00003315                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000331A
.text$mn:0000331A loc_331A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000331A                 mov     ecx, [ebp+arg_0]
.text$mn:0000331D                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00003322                 sub     eax, [ebp+arg_4]
.text$mn:00003325                 mov     [ebp+var_8], eax
.text$mn:00003328                 mov     eax, [ebp+arg_8]
.text$mn:0000332B                 cmp     eax, [ebp+var_8]
.text$mn:0000332E                 jnb     short loc_3336
.text$mn:00003330                 mov     ecx, [ebp+arg_8]
.text$mn:00003333                 mov     [ebp+var_8], ecx
.text$mn:00003336
.text$mn:00003336 loc_3336:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00003336                 mov     edx, [ebp+var_4]
.text$mn:00003339                 cmp     edx, [ebp+arg_0]
.text$mn:0000333C                 jnz     short loc_335D
.text$mn:0000333E                 mov     eax, [ebp+arg_4]
.text$mn:00003341                 add     eax, [ebp+var_8]
.text$mn:00003344                 push    eax
.text$mn:00003345                 mov     ecx, [ebp+var_4]
.text$mn:00003348                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:0000334D                 mov     ecx, [ebp+arg_4]
.text$mn:00003350                 push    ecx
.text$mn:00003351                 push    0
.text$mn:00003353                 mov     ecx, [ebp+var_4]
.text$mn:00003356                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000335B                 jmp     short loc_33A2
.text$mn:0000335D ; ---------------------------------------------------------------------------
.text$mn:0000335D
.text$mn:0000335D loc_335D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000335D                 push    0
.text$mn:0000335F                 mov     edx, [ebp+var_8]
.text$mn:00003362                 push    edx
.text$mn:00003363                 mov     ecx, [ebp+var_4]
.text$mn:00003366                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000336B                 movzx   eax, al
.text$mn:0000336E                 test    eax, eax
.text$mn:00003370                 jz      short loc_33A2
.text$mn:00003372                 mov     ecx, [ebp+var_8]
.text$mn:00003375                 push    ecx             ; int
.text$mn:00003376                 mov     ecx, [ebp+arg_0]
.text$mn:00003379                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000337E                 mov     edx, [ebp+arg_4]
.text$mn:00003381                 lea     eax, [eax+edx*2]
.text$mn:00003384                 push    eax             ; Src
.text$mn:00003385                 mov     ecx, [ebp+var_4]
.text$mn:00003388                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000338D                 push    eax             ; Dst
.text$mn:0000338E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00003393                 add     esp, 0Ch
.text$mn:00003396                 mov     ecx, [ebp+var_8]
.text$mn:00003399                 push    ecx
.text$mn:0000339A                 mov     ecx, [ebp+var_4]
.text$mn:0000339D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000033A2
.text$mn:000033A2 loc_33A2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:000033A2                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:000033A2                 mov     eax, [ebp+var_4]
.text$mn:000033A5                 mov     esp, ebp
.text$mn:000033A7                 pop     ebp
.text$mn:000033A8                 retn    0Ch
.text$mn:000033A8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000033A8
.text$mn:000033A8 ; ---------------------------------------------------------------------------
.text$mn:000033AB                 align 4
.text$mn:000033AB _text$mn        ends
.text$mn:000033AB
.text$mn:000033AC ; ===========================================================================
.text$mn:000033AC
.text$mn:000033AC ; Segment type: Pure code
.text$mn:000033AC ; Segment permissions: Read/Execute
.text$mn:000033AC _text$mn        segment para public 'CODE' use32
.text$mn:000033AC                 assume cs:_text$mn
.text$mn:000033AC                 ;org 33ACh
.text$mn:000033AC ; COMDAT (pick any)
.text$mn:000033AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000033AC
.text$mn:000033AC ; =============== S U B R O U T I N E =======================================
.text$mn:000033AC
.text$mn:000033AC ; Attributes: bp-based frame
.text$mn:000033AC
.text$mn:000033AC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:000033AC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:000033AC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:000033AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:000033AC
.text$mn:000033AC var_4           = dword ptr -4
.text$mn:000033AC Str             = dword ptr  8
.text$mn:000033AC
.text$mn:000033AC                 push    ebp
.text$mn:000033AD                 mov     ebp, esp
.text$mn:000033AF                 push    ecx
.text$mn:000033B0                 mov     [ebp+var_4], ecx
.text$mn:000033B3                 push    490h            ; unsigned int
.text$mn:000033B8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000033BD                 mov     eax, [ebp+Str]
.text$mn:000033C0                 push    eax             ; int
.text$mn:000033C1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000033C6                 add     esp, 0Ch
.text$mn:000033C9                 mov     ecx, [ebp+Str]
.text$mn:000033CC                 push    ecx             ; Str
.text$mn:000033CD                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000033D2                 add     esp, 4
.text$mn:000033D5                 push    eax             ; int
.text$mn:000033D6                 mov     edx, [ebp+Str]
.text$mn:000033D9                 push    edx             ; Src
.text$mn:000033DA                 mov     ecx, [ebp+var_4]
.text$mn:000033DD                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:000033E2                 mov     esp, ebp
.text$mn:000033E4                 pop     ebp
.text$mn:000033E5                 retn    4
.text$mn:000033E5 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:000033E5
.text$mn:000033E5 _text$mn        ends
.text$mn:000033E5
.text$mn:000033E8 ; ===========================================================================
.text$mn:000033E8
.text$mn:000033E8 ; Segment type: Pure code
.text$mn:000033E8 ; Segment permissions: Read/Execute
.text$mn:000033E8 _text$mn        segment para public 'CODE' use32
.text$mn:000033E8                 assume cs:_text$mn
.text$mn:000033E8                 ;org 33E8h
.text$mn:000033E8 ; COMDAT (pick any)
.text$mn:000033E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000033E8
.text$mn:000033E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000033E8
.text$mn:000033E8 ; Attributes: bp-based frame
.text$mn:000033E8
.text$mn:000033E8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:000033E8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:000033E8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:000033E8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:000033E8
.text$mn:000033E8 var_4           = dword ptr -4
.text$mn:000033E8 Src             = dword ptr  8
.text$mn:000033E8 arg_4           = dword ptr  0Ch
.text$mn:000033E8
.text$mn:000033E8                 push    ebp
.text$mn:000033E9                 mov     ebp, esp
.text$mn:000033EB                 push    ecx
.text$mn:000033EC                 mov     [ebp+var_4], ecx
.text$mn:000033EF                 cmp     [ebp+arg_4], 0
.text$mn:000033F3                 jz      short loc_340B
.text$mn:000033F5                 push    47Fh            ; unsigned int
.text$mn:000033FA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000033FF                 mov     eax, [ebp+Src]
.text$mn:00003402                 push    eax             ; int
.text$mn:00003403                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00003408                 add     esp, 0Ch
.text$mn:0000340B
.text$mn:0000340B loc_340B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:0000340B                 mov     ecx, [ebp+Src]
.text$mn:0000340E                 push    ecx
.text$mn:0000340F                 mov     ecx, [ebp+var_4]
.text$mn:00003412                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00003417                 movzx   edx, al
.text$mn:0000341A                 test    edx, edx
.text$mn:0000341C                 jz      short loc_3440
.text$mn:0000341E                 mov     eax, [ebp+arg_4]
.text$mn:00003421                 push    eax
.text$mn:00003422                 mov     ecx, [ebp+var_4]
.text$mn:00003425                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000342A                 mov     ecx, [ebp+Src]
.text$mn:0000342D                 sub     ecx, eax
.text$mn:0000342F                 sar     ecx, 1
.text$mn:00003431                 push    ecx
.text$mn:00003432                 mov     edx, [ebp+var_4]
.text$mn:00003435                 push    edx
.text$mn:00003436                 mov     ecx, [ebp+var_4]
.text$mn:00003439                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000343E                 jmp     short loc_347D
.text$mn:00003440 ; ---------------------------------------------------------------------------
.text$mn:00003440
.text$mn:00003440 loc_3440:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00003440                 push    0
.text$mn:00003442                 mov     eax, [ebp+arg_4]
.text$mn:00003445                 push    eax
.text$mn:00003446                 mov     ecx, [ebp+var_4]
.text$mn:00003449                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000344E                 movzx   ecx, al
.text$mn:00003451                 test    ecx, ecx
.text$mn:00003453                 jz      short loc_347A
.text$mn:00003455                 mov     edx, [ebp+arg_4]
.text$mn:00003458                 push    edx             ; int
.text$mn:00003459                 mov     eax, [ebp+Src]
.text$mn:0000345C                 push    eax             ; Src
.text$mn:0000345D                 mov     ecx, [ebp+var_4]
.text$mn:00003460                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003465                 push    eax             ; Dst
.text$mn:00003466                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000346B                 add     esp, 0Ch
.text$mn:0000346E                 mov     ecx, [ebp+arg_4]
.text$mn:00003471                 push    ecx
.text$mn:00003472                 mov     ecx, [ebp+var_4]
.text$mn:00003475                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000347A
.text$mn:0000347A loc_347A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000347A                 mov     eax, [ebp+var_4]
.text$mn:0000347D
.text$mn:0000347D loc_347D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:0000347D                 mov     esp, ebp
.text$mn:0000347F                 pop     ebp
.text$mn:00003480                 retn    8
.text$mn:00003480 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00003480
.text$mn:00003480 ; ---------------------------------------------------------------------------
.text$mn:00003483                 align 4
.text$mn:00003483 _text$mn        ends
.text$mn:00003483
.text$mn:00003484 ; ===========================================================================
.text$mn:00003484
.text$mn:00003484 ; Segment type: Pure code
.text$mn:00003484 ; Segment permissions: Read/Execute
.text$mn:00003484 _text$mn        segment para public 'CODE' use32
.text$mn:00003484                 assume cs:_text$mn
.text$mn:00003484                 ;org 3484h
.text$mn:00003484 ; COMDAT (pick any)
.text$mn:00003484                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003484
.text$mn:00003484 ; =============== S U B R O U T I N E =======================================
.text$mn:00003484
.text$mn:00003484 ; Attributes: bp-based frame
.text$mn:00003484
.text$mn:00003484 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00003484                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00003484 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00003484                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00003484
.text$mn:00003484 arg_0           = dword ptr  8
.text$mn:00003484 arg_4           = dword ptr  0Ch
.text$mn:00003484
.text$mn:00003484                 push    ebp
.text$mn:00003485                 mov     ebp, esp
.text$mn:00003487                 mov     eax, [ebp+arg_0]
.text$mn:0000348A                 mov     ecx, [ebp+arg_4]
.text$mn:0000348D                 mov     dl, [ecx]
.text$mn:0000348F                 mov     [eax], dl
.text$mn:00003491                 pop     ebp
.text$mn:00003492                 retn
.text$mn:00003492 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00003492
.text$mn:00003492 ; ---------------------------------------------------------------------------
.text$mn:00003493                 align 4
.text$mn:00003493 _text$mn        ends
.text$mn:00003493
.text$mn:00003494 ; ===========================================================================
.text$mn:00003494
.text$mn:00003494 ; Segment type: Pure code
.text$mn:00003494 ; Segment permissions: Read/Execute
.text$mn:00003494 _text$mn        segment para public 'CODE' use32
.text$mn:00003494                 assume cs:_text$mn
.text$mn:00003494                 ;org 3494h
.text$mn:00003494 ; COMDAT (pick any)
.text$mn:00003494                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003494
.text$mn:00003494 ; =============== S U B R O U T I N E =======================================
.text$mn:00003494
.text$mn:00003494 ; Attributes: bp-based frame
.text$mn:00003494
.text$mn:00003494 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00003494                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00003494 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00003494                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00003494
.text$mn:00003494 arg_0           = dword ptr  8
.text$mn:00003494 arg_4           = dword ptr  0Ch
.text$mn:00003494
.text$mn:00003494                 push    ebp
.text$mn:00003495                 mov     ebp, esp
.text$mn:00003497                 mov     eax, [ebp+arg_0]
.text$mn:0000349A                 mov     ecx, [ebp+arg_4]
.text$mn:0000349D                 mov     dx, [ecx]
.text$mn:000034A0                 mov     [eax], dx
.text$mn:000034A3                 pop     ebp
.text$mn:000034A4                 retn
.text$mn:000034A4 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:000034A4
.text$mn:000034A4 ; ---------------------------------------------------------------------------
.text$mn:000034A5                 align 4
.text$mn:000034A5 _text$mn        ends
.text$mn:000034A5
.text$mn:000034A8 ; ===========================================================================
.text$mn:000034A8
.text$mn:000034A8 ; Segment type: Pure code
.text$mn:000034A8 ; Segment permissions: Read/Execute
.text$mn:000034A8 _text$mn        segment para public 'CODE' use32
.text$mn:000034A8                 assume cs:_text$mn
.text$mn:000034A8                 ;org 34A8h
.text$mn:000034A8 ; COMDAT (pick any)
.text$mn:000034A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034A8
.text$mn:000034A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000034A8
.text$mn:000034A8 ; Attributes: bp-based frame
.text$mn:000034A8
.text$mn:000034A8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000034A8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000034A8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000034A8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000034A8
.text$mn:000034A8 var_4           = dword ptr -4
.text$mn:000034A8
.text$mn:000034A8                 push    ebp
.text$mn:000034A9                 mov     ebp, esp
.text$mn:000034AB                 push    ecx
.text$mn:000034AC                 mov     [ebp+var_4], ecx
.text$mn:000034AF                 mov     eax, [ebp+var_4]
.text$mn:000034B2                 mov     eax, [eax+4]
.text$mn:000034B5                 mov     esp, ebp
.text$mn:000034B7                 pop     ebp
.text$mn:000034B8                 retn
.text$mn:000034B8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000034B8
.text$mn:000034B8 ; ---------------------------------------------------------------------------
.text$mn:000034B9                 align 4
.text$mn:000034B9 _text$mn        ends
.text$mn:000034B9
.text$mn:000034BC ; ===========================================================================
.text$mn:000034BC
.text$mn:000034BC ; Segment type: Pure code
.text$mn:000034BC ; Segment permissions: Read/Execute
.text$mn:000034BC _text$mn        segment para public 'CODE' use32
.text$mn:000034BC                 assume cs:_text$mn
.text$mn:000034BC                 ;org 34BCh
.text$mn:000034BC ; COMDAT (pick any)
.text$mn:000034BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034BC
.text$mn:000034BC ; =============== S U B R O U T I N E =======================================
.text$mn:000034BC
.text$mn:000034BC ; Attributes: bp-based frame
.text$mn:000034BC
.text$mn:000034BC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000034BC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000034BC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000034BC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000034BC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000034BC
.text$mn:000034BC var_4           = dword ptr -4
.text$mn:000034BC
.text$mn:000034BC                 push    ebp
.text$mn:000034BD                 mov     ebp, esp
.text$mn:000034BF                 push    ecx
.text$mn:000034C0                 mov     [ebp+var_4], ecx
.text$mn:000034C3                 mov     eax, [ebp+var_4]
.text$mn:000034C6                 mov     eax, [eax+4]
.text$mn:000034C9                 mov     esp, ebp
.text$mn:000034CB                 pop     ebp
.text$mn:000034CC                 retn
.text$mn:000034CC ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000034CC
.text$mn:000034CC ; ---------------------------------------------------------------------------
.text$mn:000034CD                 align 10h
.text$mn:000034CD _text$mn        ends
.text$mn:000034CD
.text$mn:000034D0 ; ===========================================================================
.text$mn:000034D0
.text$mn:000034D0 ; Segment type: Pure code
.text$mn:000034D0 ; Segment permissions: Read/Execute
.text$mn:000034D0 _text$mn        segment para public 'CODE' use32
.text$mn:000034D0                 assume cs:_text$mn
.text$mn:000034D0                 ;org 34D0h
.text$mn:000034D0 ; COMDAT (pick any)
.text$mn:000034D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034D0
.text$mn:000034D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000034D0
.text$mn:000034D0 ; Attributes: bp-based frame
.text$mn:000034D0
.text$mn:000034D0 ; void __thiscall ScintillaEditView::clearIndicator(ScintillaEditView *this, int)
.text$mn:000034D0                 public ?clearIndicator@ScintillaEditView@@QAEXH@Z
.text$mn:000034D0 ?clearIndicator@ScintillaEditView@@QAEXH@Z proc near
.text$mn:000034D0                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+45p
.text$mn:000034D0
.text$mn:000034D0 var_C           = dword ptr -0Ch
.text$mn:000034D0 var_8           = dword ptr -8
.text$mn:000034D0 var_4           = dword ptr -4
.text$mn:000034D0 arg_0           = dword ptr  8
.text$mn:000034D0
.text$mn:000034D0                 push    ebp
.text$mn:000034D1                 mov     ebp, esp
.text$mn:000034D3                 sub     esp, 0Ch
.text$mn:000034D6                 mov     [ebp+var_4], ecx
.text$mn:000034D9                 mov     [ebp+var_8], 0
.text$mn:000034E0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000034E3                 call    ?getCurrentDocLen@ScintillaEditView@@QBEHXZ ; ScintillaEditView::getCurrentDocLen(void)
.text$mn:000034E8                 mov     [ebp+var_C], eax
.text$mn:000034EB                 push    0               ; __int32
.text$mn:000034ED                 mov     eax, [ebp+arg_0]
.text$mn:000034F0                 push    eax             ; unsigned int
.text$mn:000034F1                 push    9C4h            ; unsigned int
.text$mn:000034F6                 mov     ecx, [ebp+var_4] ; this
.text$mn:000034F9                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000034FE                 mov     ecx, [ebp+var_C]
.text$mn:00003501                 sub     ecx, [ebp+var_8]
.text$mn:00003504                 push    ecx             ; __int32
.text$mn:00003505                 mov     edx, [ebp+var_8]
.text$mn:00003508                 push    edx             ; unsigned int
.text$mn:00003509                 push    9C9h            ; unsigned int
.text$mn:0000350E                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003511                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003516                 mov     esp, ebp
.text$mn:00003518                 pop     ebp
.text$mn:00003519                 retn    4
.text$mn:00003519 ?clearIndicator@ScintillaEditView@@QAEXH@Z endp
.text$mn:00003519
.text$mn:00003519 _text$mn        ends
.text$mn:00003519
.text$mn:0000351C ; ===========================================================================
.text$mn:0000351C
.text$mn:0000351C ; Segment type: Pure code
.text$mn:0000351C ; Segment permissions: Read/Execute
.text$mn:0000351C _text$mn        segment para public 'CODE' use32
.text$mn:0000351C                 assume cs:_text$mn
.text$mn:0000351C                 ;org 351Ch
.text$mn:0000351C ; COMDAT (pick any)
.text$mn:0000351C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000351C
.text$mn:0000351C ; =============== S U B R O U T I N E =======================================
.text$mn:0000351C
.text$mn:0000351C ; Attributes: bp-based frame
.text$mn:0000351C
.text$mn:0000351C ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:0000351C                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000351C ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:0000351C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000351C
.text$mn:0000351C var_4           = dword ptr -4
.text$mn:0000351C Dst             = dword ptr  8
.text$mn:0000351C Src             = dword ptr  0Ch
.text$mn:0000351C Size            = dword ptr  10h
.text$mn:0000351C
.text$mn:0000351C                 push    ebp
.text$mn:0000351D                 mov     ebp, esp
.text$mn:0000351F                 push    ecx
.text$mn:00003520                 cmp     [ebp+Size], 0
.text$mn:00003524                 jnz     short loc_352E
.text$mn:00003526                 mov     eax, [ebp+Dst]
.text$mn:00003529                 mov     [ebp+var_4], eax
.text$mn:0000352C                 jmp     short loc_3545
.text$mn:0000352E ; ---------------------------------------------------------------------------
.text$mn:0000352E
.text$mn:0000352E loc_352E:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000352E                 mov     ecx, [ebp+Size]
.text$mn:00003531                 push    ecx             ; Size
.text$mn:00003532                 mov     edx, [ebp+Src]
.text$mn:00003535                 push    edx             ; Src
.text$mn:00003536                 mov     eax, [ebp+Dst]
.text$mn:00003539                 push    eax             ; Dst
.text$mn:0000353A                 call    _memcpy
.text$mn:0000353F                 add     esp, 0Ch
.text$mn:00003542                 mov     [ebp+var_4], eax
.text$mn:00003545
.text$mn:00003545 loc_3545:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00003545                 mov     eax, [ebp+var_4]
.text$mn:00003548                 mov     esp, ebp
.text$mn:0000354A                 pop     ebp
.text$mn:0000354B                 retn
.text$mn:0000354B ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000354B
.text$mn:0000354B _text$mn        ends
.text$mn:0000354B
.text$mn:0000354C ; ===========================================================================
.text$mn:0000354C
.text$mn:0000354C ; Segment type: Pure code
.text$mn:0000354C ; Segment permissions: Read/Execute
.text$mn:0000354C _text$mn        segment para public 'CODE' use32
.text$mn:0000354C                 assume cs:_text$mn
.text$mn:0000354C                 ;org 354Ch
.text$mn:0000354C ; COMDAT (pick any)
.text$mn:0000354C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000354C
.text$mn:0000354C ; =============== S U B R O U T I N E =======================================
.text$mn:0000354C
.text$mn:0000354C ; Attributes: bp-based frame
.text$mn:0000354C
.text$mn:0000354C ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:0000354C                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000354C ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000354C                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:0000354C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000354C
.text$mn:0000354C var_4           = dword ptr -4
.text$mn:0000354C Dst             = dword ptr  8
.text$mn:0000354C Src             = dword ptr  0Ch
.text$mn:0000354C arg_8           = dword ptr  10h
.text$mn:0000354C
.text$mn:0000354C                 push    ebp
.text$mn:0000354D                 mov     ebp, esp
.text$mn:0000354F                 push    ecx
.text$mn:00003550                 cmp     [ebp+arg_8], 0
.text$mn:00003554                 jnz     short loc_355E
.text$mn:00003556                 mov     eax, [ebp+Dst]
.text$mn:00003559                 mov     [ebp+var_4], eax
.text$mn:0000355C                 jmp     short loc_3575
.text$mn:0000355E ; ---------------------------------------------------------------------------
.text$mn:0000355E
.text$mn:0000355E loc_355E:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000355E                 mov     ecx, [ebp+arg_8]
.text$mn:00003561                 push    ecx             ; int
.text$mn:00003562                 mov     edx, [ebp+Src]
.text$mn:00003565                 push    edx             ; Src
.text$mn:00003566                 mov     eax, [ebp+Dst]
.text$mn:00003569                 push    eax             ; Dst
.text$mn:0000356A                 call    _wmemcpy
.text$mn:0000356F                 add     esp, 0Ch
.text$mn:00003572                 mov     [ebp+var_4], eax
.text$mn:00003575
.text$mn:00003575 loc_3575:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00003575                 mov     eax, [ebp+var_4]
.text$mn:00003578                 mov     esp, ebp
.text$mn:0000357A                 pop     ebp
.text$mn:0000357B                 retn
.text$mn:0000357B ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000357B
.text$mn:0000357B _text$mn        ends
.text$mn:0000357B
.text$mn:0000357C ; ===========================================================================
.text$mn:0000357C
.text$mn:0000357C ; Segment type: Pure code
.text$mn:0000357C ; Segment permissions: Read/Execute
.text$mn:0000357C _text$mn        segment para public 'CODE' use32
.text$mn:0000357C                 assume cs:_text$mn
.text$mn:0000357C                 ;org 357Ch
.text$mn:0000357C ; COMDAT (pick any)
.text$mn:0000357C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000357C
.text$mn:0000357C ; =============== S U B R O U T I N E =======================================
.text$mn:0000357C
.text$mn:0000357C ; Attributes: bp-based frame
.text$mn:0000357C
.text$mn:0000357C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:0000357C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:0000357C ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:0000357C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:0000357C
.text$mn:0000357C var_4           = dword ptr -4
.text$mn:0000357C arg_0           = dword ptr  8
.text$mn:0000357C arg_4           = dword ptr  0Ch
.text$mn:0000357C
.text$mn:0000357C                 push    ebp
.text$mn:0000357D                 mov     ebp, esp
.text$mn:0000357F                 push    ecx
.text$mn:00003580                 mov     [ebp+var_4], ecx
.text$mn:00003583                 mov     eax, [ebp+arg_4]
.text$mn:00003586                 push    eax             ; int
.text$mn:00003587                 mov     ecx, [ebp+arg_0]
.text$mn:0000358A                 push    ecx             ; void *
.text$mn:0000358B                 mov     ecx, [ebp+var_4]
.text$mn:0000358E                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00003593                 mov     esp, ebp
.text$mn:00003595                 pop     ebp
.text$mn:00003596                 retn    8
.text$mn:00003596 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00003596
.text$mn:00003596 ; ---------------------------------------------------------------------------
.text$mn:00003599                 align 4
.text$mn:00003599 _text$mn        ends
.text$mn:00003599
.text$mn:0000359C ; ===========================================================================
.text$mn:0000359C
.text$mn:0000359C ; Segment type: Pure code
.text$mn:0000359C ; Segment permissions: Read/Execute
.text$mn:0000359C _text$mn        segment para public 'CODE' use32
.text$mn:0000359C                 assume cs:_text$mn
.text$mn:0000359C                 ;org 359Ch
.text$mn:0000359C ; COMDAT (pick any)
.text$mn:0000359C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000359C
.text$mn:0000359C ; =============== S U B R O U T I N E =======================================
.text$mn:0000359C
.text$mn:0000359C ; Attributes: bp-based frame
.text$mn:0000359C
.text$mn:0000359C ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:0000359C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:0000359C ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:0000359C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:0000359C
.text$mn:0000359C var_4           = dword ptr -4
.text$mn:0000359C arg_0           = dword ptr  8
.text$mn:0000359C arg_4           = dword ptr  0Ch
.text$mn:0000359C
.text$mn:0000359C                 push    ebp
.text$mn:0000359D                 mov     ebp, esp
.text$mn:0000359F                 push    ecx
.text$mn:000035A0                 mov     [ebp+var_4], ecx
.text$mn:000035A3                 mov     eax, [ebp+arg_4]
.text$mn:000035A6                 push    eax             ; int
.text$mn:000035A7                 mov     ecx, [ebp+arg_0]
.text$mn:000035AA                 push    ecx             ; void *
.text$mn:000035AB                 mov     ecx, [ebp+var_4]
.text$mn:000035AE                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:000035B3                 mov     esp, ebp
.text$mn:000035B5                 pop     ebp
.text$mn:000035B6                 retn    8
.text$mn:000035B6 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:000035B6
.text$mn:000035B6 ; ---------------------------------------------------------------------------
.text$mn:000035B9                 align 4
.text$mn:000035B9 _text$mn        ends
.text$mn:000035B9
.text$mn:000035BC ; ===========================================================================
.text$mn:000035BC
.text$mn:000035BC ; Segment type: Pure code
.text$mn:000035BC ; Segment permissions: Read/Execute
.text$mn:000035BC _text$mn        segment para public 'CODE' use32
.text$mn:000035BC                 assume cs:_text$mn
.text$mn:000035BC                 ;org 35BCh
.text$mn:000035BC ; COMDAT (pick any)
.text$mn:000035BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035BC
.text$mn:000035BC ; =============== S U B R O U T I N E =======================================
.text$mn:000035BC
.text$mn:000035BC ; Attributes: bp-based frame
.text$mn:000035BC
.text$mn:000035BC ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000035BC                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000035BC ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000035BC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000035BC
.text$mn:000035BC var_4           = dword ptr -4
.text$mn:000035BC arg_0           = dword ptr  8
.text$mn:000035BC
.text$mn:000035BC                 push    ebp
.text$mn:000035BD                 mov     ebp, esp
.text$mn:000035BF                 push    ecx
.text$mn:000035C0                 mov     [ebp+var_4], ecx
.text$mn:000035C3                 mov     eax, [ebp+arg_0]
.text$mn:000035C6                 push    eax             ; void *
.text$mn:000035C7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000035CC                 add     esp, 4
.text$mn:000035CF                 mov     esp, ebp
.text$mn:000035D1                 pop     ebp
.text$mn:000035D2                 retn    8
.text$mn:000035D2 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000035D2
.text$mn:000035D2 ; ---------------------------------------------------------------------------
.text$mn:000035D5                 align 4
.text$mn:000035D5 _text$mn        ends
.text$mn:000035D5
.text$mn:000035D8 ; ===========================================================================
.text$mn:000035D8
.text$mn:000035D8 ; Segment type: Pure code
.text$mn:000035D8 ; Segment permissions: Read/Execute
.text$mn:000035D8 _text$mn        segment para public 'CODE' use32
.text$mn:000035D8                 assume cs:_text$mn
.text$mn:000035D8                 ;org 35D8h
.text$mn:000035D8 ; COMDAT (pick any)
.text$mn:000035D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035D8
.text$mn:000035D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000035D8
.text$mn:000035D8 ; Attributes: bp-based frame
.text$mn:000035D8
.text$mn:000035D8 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000035D8                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000035D8 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000035D8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000035D8                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:000035D8
.text$mn:000035D8 var_4           = dword ptr -4
.text$mn:000035D8 arg_0           = dword ptr  8
.text$mn:000035D8
.text$mn:000035D8                 push    ebp
.text$mn:000035D9                 mov     ebp, esp
.text$mn:000035DB                 push    ecx
.text$mn:000035DC                 mov     [ebp+var_4], ecx
.text$mn:000035DF                 mov     eax, [ebp+arg_0]
.text$mn:000035E2                 push    eax             ; void *
.text$mn:000035E3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000035E8                 add     esp, 4
.text$mn:000035EB                 mov     esp, ebp
.text$mn:000035ED                 pop     ebp
.text$mn:000035EE                 retn    8
.text$mn:000035EE ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000035EE
.text$mn:000035EE ; ---------------------------------------------------------------------------
.text$mn:000035F1                 align 4
.text$mn:000035F1 _text$mn        ends
.text$mn:000035F1
.text$mn:000035F4 ; ===========================================================================
.text$mn:000035F4
.text$mn:000035F4 ; Segment type: Pure code
.text$mn:000035F4 ; Segment permissions: Read/Execute
.text$mn:000035F4 _text$mn        segment para public 'CODE' use32
.text$mn:000035F4                 assume cs:_text$mn
.text$mn:000035F4                 ;org 35F4h
.text$mn:000035F4 ; COMDAT (pick any)
.text$mn:000035F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035F4
.text$mn:000035F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000035F4
.text$mn:000035F4 ; Attributes: bp-based frame
.text$mn:000035F4
.text$mn:000035F4 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:000035F4                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:000035F4 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:000035F4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:000035F4
.text$mn:000035F4 var_4           = dword ptr -4
.text$mn:000035F4 arg_0           = dword ptr  8
.text$mn:000035F4
.text$mn:000035F4                 push    ebp
.text$mn:000035F5                 mov     ebp, esp
.text$mn:000035F7                 push    ecx
.text$mn:000035F8                 mov     [ebp+var_4], ecx
.text$mn:000035FB                 mov     eax, [ebp+arg_0]
.text$mn:000035FE                 push    eax             ; void *
.text$mn:000035FF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003604                 add     esp, 4
.text$mn:00003607                 mov     esp, ebp
.text$mn:00003609                 pop     ebp
.text$mn:0000360A                 retn    8
.text$mn:0000360A ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000360A
.text$mn:0000360A ; ---------------------------------------------------------------------------
.text$mn:0000360D                 align 10h
.text$mn:0000360D _text$mn        ends
.text$mn:0000360D
.text$mn:00003610 ; ===========================================================================
.text$mn:00003610
.text$mn:00003610 ; Segment type: Pure code
.text$mn:00003610 ; Segment permissions: Read/Execute
.text$mn:00003610 _text$mn        segment para public 'CODE' use32
.text$mn:00003610                 assume cs:_text$mn
.text$mn:00003610                 ;org 3610h
.text$mn:00003610 ; COMDAT (pick any)
.text$mn:00003610                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003610
.text$mn:00003610 ; =============== S U B R O U T I N E =======================================
.text$mn:00003610
.text$mn:00003610 ; Attributes: bp-based frame
.text$mn:00003610
.text$mn:00003610 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00003610                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00003610 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00003610                                         ; DATA XREF: .rdata:000044E4o
.text$mn:00003610
.text$mn:00003610 var_4           = dword ptr -4
.text$mn:00003610 arg_0           = dword ptr  8
.text$mn:00003610 arg_4           = dword ptr  0Ch
.text$mn:00003610
.text$mn:00003610                 push    ebp
.text$mn:00003611                 mov     ebp, esp
.text$mn:00003613                 push    ecx
.text$mn:00003614                 mov     [ebp+var_4], ecx
.text$mn:00003617                 mov     eax, [ebp+arg_4]
.text$mn:0000361A                 push    eax             ; int
.text$mn:0000361B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003620                 add     esp, 4
.text$mn:00003623                 test    eax, eax
.text$mn:00003625                 jz      short loc_3640
.text$mn:00003627                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000362C                 push    eax             ; struct std::error_category *
.text$mn:0000362D                 mov     ecx, [ebp+arg_4]
.text$mn:00003630                 push    ecx             ; int
.text$mn:00003631                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003634                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003639                 mov     eax, [ebp+arg_0]
.text$mn:0000363C                 jmp     short loc_3655
.text$mn:0000363E ; ---------------------------------------------------------------------------
.text$mn:0000363E                 jmp     short loc_3655
.text$mn:00003640 ; ---------------------------------------------------------------------------
.text$mn:00003640
.text$mn:00003640 loc_3640:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00003640                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00003645                 push    eax             ; struct std::error_category *
.text$mn:00003646                 mov     edx, [ebp+arg_4]
.text$mn:00003649                 push    edx             ; int
.text$mn:0000364A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000364D                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003652                 mov     eax, [ebp+arg_0]
.text$mn:00003655
.text$mn:00003655 loc_3655:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00003655                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00003655                 mov     esp, ebp
.text$mn:00003657                 pop     ebp
.text$mn:00003658                 retn    8
.text$mn:00003658 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00003658
.text$mn:00003658 ; ---------------------------------------------------------------------------
.text$mn:0000365B                 align 4
.text$mn:0000365B _text$mn        ends
.text$mn:0000365B
.text$mn:0000365C ; ===========================================================================
.text$mn:0000365C
.text$mn:0000365C ; Segment type: Pure code
.text$mn:0000365C ; Segment permissions: Read/Execute
.text$mn:0000365C _text$mn        segment para public 'CODE' use32
.text$mn:0000365C                 assume cs:_text$mn
.text$mn:0000365C                 ;org 365Ch
.text$mn:0000365C ; COMDAT (pick any)
.text$mn:0000365C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000365C
.text$mn:0000365C ; =============== S U B R O U T I N E =======================================
.text$mn:0000365C
.text$mn:0000365C ; Attributes: bp-based frame
.text$mn:0000365C
.text$mn:0000365C ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000365C                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000365C ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000365C                                         ; DATA XREF: .rdata:00004454o
.text$mn:0000365C                                         ; .rdata:00004470o ...
.text$mn:0000365C
.text$mn:0000365C var_4           = dword ptr -4
.text$mn:0000365C arg_0           = dword ptr  8
.text$mn:0000365C arg_4           = dword ptr  0Ch
.text$mn:0000365C
.text$mn:0000365C                 push    ebp
.text$mn:0000365D                 mov     ebp, esp
.text$mn:0000365F                 push    ecx
.text$mn:00003660                 mov     [ebp+var_4], ecx
.text$mn:00003663                 mov     eax, [ebp+var_4]
.text$mn:00003666                 push    eax             ; struct std::error_category *
.text$mn:00003667                 mov     ecx, [ebp+arg_4]
.text$mn:0000366A                 push    ecx             ; int
.text$mn:0000366B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000366E                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003673                 mov     eax, [ebp+arg_0]
.text$mn:00003676                 mov     esp, ebp
.text$mn:00003678                 pop     ebp
.text$mn:00003679                 retn    8
.text$mn:00003679 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00003679
.text$mn:00003679 _text$mn        ends
.text$mn:00003679
.text$mn:0000367C ; ===========================================================================
.text$mn:0000367C
.text$mn:0000367C ; Segment type: Pure code
.text$mn:0000367C ; Segment permissions: Read/Execute
.text$mn:0000367C _text$mn        segment para public 'CODE' use32
.text$mn:0000367C                 assume cs:_text$mn
.text$mn:0000367C                 ;org 367Ch
.text$mn:0000367C ; COMDAT (pick any)
.text$mn:0000367C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000367C
.text$mn:0000367C ; =============== S U B R O U T I N E =======================================
.text$mn:0000367C
.text$mn:0000367C ; Attributes: bp-based frame
.text$mn:0000367C
.text$mn:0000367C ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000367C                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000367C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000367C                                         ; DATA XREF: .rdata:00004458o
.text$mn:0000367C                                         ; .rdata:00004474o ...
.text$mn:0000367C
.text$mn:0000367C var_8           = dword ptr -8
.text$mn:0000367C var_4           = dword ptr -4
.text$mn:0000367C arg_0           = dword ptr  8
.text$mn:0000367C arg_4           = dword ptr  0Ch
.text$mn:0000367C
.text$mn:0000367C                 push    ebp
.text$mn:0000367D                 mov     ebp, esp
.text$mn:0000367F                 sub     esp, 8
.text$mn:00003682                 mov     [ebp+var_8], ecx
.text$mn:00003685                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003688                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000368D                 push    eax
.text$mn:0000368E                 mov     ecx, [ebp+var_8]
.text$mn:00003691                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00003696                 movzx   eax, al
.text$mn:00003699                 test    eax, eax
.text$mn:0000369B                 jz      short loc_36B3
.text$mn:0000369D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000036A0                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000036A5                 cmp     eax, [ebp+arg_4]
.text$mn:000036A8                 jnz     short loc_36B3
.text$mn:000036AA                 mov     [ebp+var_4], 1
.text$mn:000036B1                 jmp     short loc_36BA
.text$mn:000036B3 ; ---------------------------------------------------------------------------
.text$mn:000036B3
.text$mn:000036B3 loc_36B3:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000036B3                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000036B3                 mov     [ebp+var_4], 0
.text$mn:000036BA
.text$mn:000036BA loc_36BA:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000036BA                 mov     al, byte ptr [ebp+var_4]
.text$mn:000036BD                 mov     esp, ebp
.text$mn:000036BF                 pop     ebp
.text$mn:000036C0                 retn    8
.text$mn:000036C0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000036C0
.text$mn:000036C0 ; ---------------------------------------------------------------------------
.text$mn:000036C3                 align 4
.text$mn:000036C3 _text$mn        ends
.text$mn:000036C3
.text$mn:000036C4 ; ===========================================================================
.text$mn:000036C4
.text$mn:000036C4 ; Segment type: Pure code
.text$mn:000036C4 ; Segment permissions: Read/Execute
.text$mn:000036C4 _text$mn        segment para public 'CODE' use32
.text$mn:000036C4                 assume cs:_text$mn
.text$mn:000036C4                 ;org 36C4h
.text$mn:000036C4 ; COMDAT (pick any)
.text$mn:000036C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036C4
.text$mn:000036C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036C4
.text$mn:000036C4 ; Attributes: bp-based frame
.text$mn:000036C4
.text$mn:000036C4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000036C4                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000036C4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000036C4                                         ; DATA XREF: .rdata:0000445Co
.text$mn:000036C4                                         ; .rdata:00004478o ...
.text$mn:000036C4
.text$mn:000036C4 var_C           = byte ptr -0Ch
.text$mn:000036C4 var_4           = dword ptr -4
.text$mn:000036C4 arg_0           = dword ptr  8
.text$mn:000036C4 arg_4           = dword ptr  0Ch
.text$mn:000036C4
.text$mn:000036C4                 push    ebp
.text$mn:000036C5                 mov     ebp, esp
.text$mn:000036C7                 sub     esp, 0Ch
.text$mn:000036CA                 mov     [ebp+var_4], ecx
.text$mn:000036CD                 mov     eax, [ebp+arg_4]
.text$mn:000036D0                 push    eax             ; std::error_condition *
.text$mn:000036D1                 mov     ecx, [ebp+arg_0]
.text$mn:000036D4                 push    ecx
.text$mn:000036D5                 lea     edx, [ebp+var_C]
.text$mn:000036D8                 push    edx
.text$mn:000036D9                 mov     eax, [ebp+var_4]
.text$mn:000036DC                 mov     edx, [eax]
.text$mn:000036DE                 mov     ecx, [ebp+var_4]
.text$mn:000036E1                 mov     eax, [edx+0Ch]
.text$mn:000036E4                 call    eax
.text$mn:000036E6                 mov     ecx, eax
.text$mn:000036E8                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000036ED                 mov     esp, ebp
.text$mn:000036EF                 pop     ebp
.text$mn:000036F0                 retn    8
.text$mn:000036F0 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000036F0
.text$mn:000036F0 ; ---------------------------------------------------------------------------
.text$mn:000036F3                 align 4
.text$mn:000036F3 _text$mn        ends
.text$mn:000036F3
.text$mn:000036F4 ; ===========================================================================
.text$mn:000036F4
.text$mn:000036F4 ; Segment type: Pure code
.text$mn:000036F4 ; Segment permissions: Read/Execute
.text$mn:000036F4 _text$mn        segment para public 'CODE' use32
.text$mn:000036F4                 assume cs:_text$mn
.text$mn:000036F4                 ;org 36F4h
.text$mn:000036F4 ; COMDAT (pick any)
.text$mn:000036F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036F4
.text$mn:000036F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036F4
.text$mn:000036F4 ; Attributes: bp-based frame
.text$mn:000036F4
.text$mn:000036F4 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000036F4                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000036F4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000036F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000036F4
.text$mn:000036F4 var_4           = dword ptr -4
.text$mn:000036F4 arg_0           = dword ptr  8
.text$mn:000036F4
.text$mn:000036F4                 push    ebp
.text$mn:000036F5                 mov     ebp, esp
.text$mn:000036F7                 push    ecx
.text$mn:000036F8                 mov     [ebp+var_4], ecx
.text$mn:000036FB                 mov     eax, [ebp+var_4]
.text$mn:000036FE                 mov     ecx, [eax+14h]
.text$mn:00003701                 cmp     ecx, [ebp+arg_0]
.text$mn:00003704                 jnb     short loc_370E
.text$mn:00003706                 mov     ecx, [ebp+var_4]
.text$mn:00003709                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000370E
.text$mn:0000370E loc_370E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000370E                 mov     edx, [ebp+arg_0]
.text$mn:00003711                 push    edx
.text$mn:00003712                 mov     ecx, [ebp+var_4]
.text$mn:00003715                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000371A                 mov     eax, [ebp+var_4]
.text$mn:0000371D                 mov     esp, ebp
.text$mn:0000371F                 pop     ebp
.text$mn:00003720                 retn    4
.text$mn:00003720 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00003720
.text$mn:00003720 ; ---------------------------------------------------------------------------
.text$mn:00003723                 align 4
.text$mn:00003723 _text$mn        ends
.text$mn:00003723
.text$mn:00003724 ; ===========================================================================
.text$mn:00003724
.text$mn:00003724 ; Segment type: Pure code
.text$mn:00003724 ; Segment permissions: Read/Execute
.text$mn:00003724 _text$mn        segment para public 'CODE' use32
.text$mn:00003724                 assume cs:_text$mn
.text$mn:00003724                 ;org 3724h
.text$mn:00003724 ; COMDAT (pick any)
.text$mn:00003724                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003724
.text$mn:00003724 ; =============== S U B R O U T I N E =======================================
.text$mn:00003724
.text$mn:00003724 ; Attributes: bp-based frame
.text$mn:00003724
.text$mn:00003724 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00003724                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00003724 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00003724                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00003724
.text$mn:00003724 var_C           = dword ptr -0Ch
.text$mn:00003724 Dst             = dword ptr -8
.text$mn:00003724 var_4           = dword ptr -4
.text$mn:00003724 arg_0           = dword ptr  8
.text$mn:00003724 arg_4           = dword ptr  0Ch
.text$mn:00003724
.text$mn:00003724                 push    ebp
.text$mn:00003725                 mov     ebp, esp
.text$mn:00003727                 sub     esp, 0Ch
.text$mn:0000372A                 mov     [ebp+var_4], ecx
.text$mn:0000372D                 mov     eax, [ebp+var_4]
.text$mn:00003730                 mov     ecx, [eax+14h]
.text$mn:00003733                 cmp     ecx, [ebp+arg_0]
.text$mn:00003736                 jnb     short loc_3740
.text$mn:00003738                 mov     ecx, [ebp+var_4]
.text$mn:0000373B                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003740
.text$mn:00003740 loc_3740:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00003740                 mov     edx, [ebp+var_4]
.text$mn:00003743                 mov     eax, [edx+14h]
.text$mn:00003746                 sub     eax, [ebp+arg_0]
.text$mn:00003749                 cmp     eax, [ebp+arg_4]
.text$mn:0000374C                 ja      short loc_375C
.text$mn:0000374E                 mov     ecx, [ebp+arg_0]
.text$mn:00003751                 push    ecx
.text$mn:00003752                 mov     ecx, [ebp+var_4]
.text$mn:00003755                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000375A                 jmp     short loc_37A2
.text$mn:0000375C ; ---------------------------------------------------------------------------
.text$mn:0000375C
.text$mn:0000375C loc_375C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000375C                 cmp     [ebp+arg_4], 0
.text$mn:00003760                 jbe     short loc_37A2
.text$mn:00003762                 mov     ecx, [ebp+var_4]
.text$mn:00003765                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000376A                 add     eax, [ebp+arg_0]
.text$mn:0000376D                 mov     [ebp+Dst], eax
.text$mn:00003770                 mov     edx, [ebp+var_4]
.text$mn:00003773                 mov     eax, [edx+14h]
.text$mn:00003776                 sub     eax, [ebp+arg_4]
.text$mn:00003779                 mov     [ebp+var_C], eax
.text$mn:0000377C                 mov     ecx, [ebp+var_C]
.text$mn:0000377F                 sub     ecx, [ebp+arg_0]
.text$mn:00003782                 push    ecx             ; Size
.text$mn:00003783                 mov     edx, [ebp+Dst]
.text$mn:00003786                 add     edx, [ebp+arg_4]
.text$mn:00003789                 push    edx             ; Src
.text$mn:0000378A                 mov     eax, [ebp+Dst]
.text$mn:0000378D                 push    eax             ; Dst
.text$mn:0000378E                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00003793                 add     esp, 0Ch
.text$mn:00003796                 mov     ecx, [ebp+var_C]
.text$mn:00003799                 push    ecx
.text$mn:0000379A                 mov     ecx, [ebp+var_4]
.text$mn:0000379D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000037A2
.text$mn:000037A2 loc_37A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000037A2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000037A2                 mov     eax, [ebp+var_4]
.text$mn:000037A5                 mov     esp, ebp
.text$mn:000037A7                 pop     ebp
.text$mn:000037A8                 retn    8
.text$mn:000037A8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000037A8
.text$mn:000037A8 ; ---------------------------------------------------------------------------
.text$mn:000037AB                 align 4
.text$mn:000037AB _text$mn        ends
.text$mn:000037AB
.text$mn:000037AC ; ===========================================================================
.text$mn:000037AC
.text$mn:000037AC ; Segment type: Pure code
.text$mn:000037AC ; Segment permissions: Read/Execute
.text$mn:000037AC _text$mn        segment para public 'CODE' use32
.text$mn:000037AC                 assume cs:_text$mn
.text$mn:000037AC                 ;org 37ACh
.text$mn:000037AC ; COMDAT (pick any)
.text$mn:000037AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037AC
.text$mn:000037AC ; =============== S U B R O U T I N E =======================================
.text$mn:000037AC
.text$mn:000037AC ; Attributes: bp-based frame
.text$mn:000037AC
.text$mn:000037AC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:000037AC                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:000037AC ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000037AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:000037AC
.text$mn:000037AC var_4           = dword ptr -4
.text$mn:000037AC arg_0           = dword ptr  8
.text$mn:000037AC
.text$mn:000037AC                 push    ebp
.text$mn:000037AD                 mov     ebp, esp
.text$mn:000037AF                 push    ecx
.text$mn:000037B0                 mov     [ebp+var_4], ecx
.text$mn:000037B3                 mov     eax, [ebp+var_4]
.text$mn:000037B6                 mov     ecx, [eax+14h]
.text$mn:000037B9                 cmp     ecx, [ebp+arg_0]
.text$mn:000037BC                 jnb     short loc_37C6
.text$mn:000037BE                 mov     ecx, [ebp+var_4]
.text$mn:000037C1                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000037C6
.text$mn:000037C6 loc_37C6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:000037C6                 mov     edx, [ebp+arg_0]
.text$mn:000037C9                 push    edx
.text$mn:000037CA                 mov     ecx, [ebp+var_4]
.text$mn:000037CD                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000037D2                 mov     eax, [ebp+var_4]
.text$mn:000037D5                 mov     esp, ebp
.text$mn:000037D7                 pop     ebp
.text$mn:000037D8                 retn    4
.text$mn:000037D8 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:000037D8
.text$mn:000037D8 ; ---------------------------------------------------------------------------
.text$mn:000037DB                 align 4
.text$mn:000037DB _text$mn        ends
.text$mn:000037DB
.text$mn:000037DC ; ===========================================================================
.text$mn:000037DC
.text$mn:000037DC ; Segment type: Pure code
.text$mn:000037DC ; Segment permissions: Read/Execute
.text$mn:000037DC _text$mn        segment para public 'CODE' use32
.text$mn:000037DC                 assume cs:_text$mn
.text$mn:000037DC                 ;org 37DCh
.text$mn:000037DC ; COMDAT (pick any)
.text$mn:000037DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037DC
.text$mn:000037DC ; =============== S U B R O U T I N E =======================================
.text$mn:000037DC
.text$mn:000037DC ; Attributes: bp-based frame
.text$mn:000037DC
.text$mn:000037DC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:000037DC                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:000037DC ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000037DC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:000037DC
.text$mn:000037DC var_C           = dword ptr -0Ch
.text$mn:000037DC Dst             = dword ptr -8
.text$mn:000037DC var_4           = dword ptr -4
.text$mn:000037DC arg_0           = dword ptr  8
.text$mn:000037DC arg_4           = dword ptr  0Ch
.text$mn:000037DC
.text$mn:000037DC                 push    ebp
.text$mn:000037DD                 mov     ebp, esp
.text$mn:000037DF                 sub     esp, 0Ch
.text$mn:000037E2                 mov     [ebp+var_4], ecx
.text$mn:000037E5                 mov     eax, [ebp+var_4]
.text$mn:000037E8                 mov     ecx, [eax+14h]
.text$mn:000037EB                 cmp     ecx, [ebp+arg_0]
.text$mn:000037EE                 jnb     short loc_37F8
.text$mn:000037F0                 mov     ecx, [ebp+var_4]
.text$mn:000037F3                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000037F8
.text$mn:000037F8 loc_37F8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:000037F8                 mov     edx, [ebp+var_4]
.text$mn:000037FB                 mov     eax, [edx+14h]
.text$mn:000037FE                 sub     eax, [ebp+arg_0]
.text$mn:00003801                 cmp     eax, [ebp+arg_4]
.text$mn:00003804                 ja      short loc_3814
.text$mn:00003806                 mov     ecx, [ebp+arg_0]
.text$mn:00003809                 push    ecx
.text$mn:0000380A                 mov     ecx, [ebp+var_4]
.text$mn:0000380D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003812                 jmp     short loc_3860
.text$mn:00003814 ; ---------------------------------------------------------------------------
.text$mn:00003814
.text$mn:00003814 loc_3814:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00003814                 cmp     [ebp+arg_4], 0
.text$mn:00003818                 jbe     short loc_3860
.text$mn:0000381A                 mov     ecx, [ebp+var_4]
.text$mn:0000381D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003822                 mov     edx, [ebp+arg_0]
.text$mn:00003825                 lea     eax, [eax+edx*2]
.text$mn:00003828                 mov     [ebp+Dst], eax
.text$mn:0000382B                 mov     ecx, [ebp+var_4]
.text$mn:0000382E                 mov     edx, [ecx+14h]
.text$mn:00003831                 sub     edx, [ebp+arg_4]
.text$mn:00003834                 mov     [ebp+var_C], edx
.text$mn:00003837                 mov     eax, [ebp+var_C]
.text$mn:0000383A                 sub     eax, [ebp+arg_0]
.text$mn:0000383D                 push    eax             ; int
.text$mn:0000383E                 mov     ecx, [ebp+arg_4]
.text$mn:00003841                 mov     edx, [ebp+Dst]
.text$mn:00003844                 lea     eax, [edx+ecx*2]
.text$mn:00003847                 push    eax             ; Src
.text$mn:00003848                 mov     ecx, [ebp+Dst]
.text$mn:0000384B                 push    ecx             ; Dst
.text$mn:0000384C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00003851                 add     esp, 0Ch
.text$mn:00003854                 mov     edx, [ebp+var_C]
.text$mn:00003857                 push    edx
.text$mn:00003858                 mov     ecx, [ebp+var_4]
.text$mn:0000385B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003860
.text$mn:00003860 loc_3860:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00003860                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00003860                 mov     eax, [ebp+var_4]
.text$mn:00003863                 mov     esp, ebp
.text$mn:00003865                 pop     ebp
.text$mn:00003866                 retn    8
.text$mn:00003866 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:00003866
.text$mn:00003866 ; ---------------------------------------------------------------------------
.text$mn:00003869                 align 4
.text$mn:00003869 _text$mn        ends
.text$mn:00003869
.text$mn:0000386C ; ===========================================================================
.text$mn:0000386C
.text$mn:0000386C ; Segment type: Pure code
.text$mn:0000386C ; Segment permissions: Read/Execute
.text$mn:0000386C _text$mn        segment para public 'CODE' use32
.text$mn:0000386C                 assume cs:_text$mn
.text$mn:0000386C                 ;org 386Ch
.text$mn:0000386C ; COMDAT (pick any)
.text$mn:0000386C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000386C
.text$mn:0000386C ; =============== S U B R O U T I N E =======================================
.text$mn:0000386C
.text$mn:0000386C ; Attributes: bp-based frame
.text$mn:0000386C
.text$mn:0000386C ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:0000386C                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:0000386C ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:0000386C                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+E8p
.text$mn:0000386C                                         ; SmartHighlighter::highlightView(ScintillaEditView *)+133p ...
.text$mn:0000386C
.text$mn:0000386C var_4           = dword ptr -4
.text$mn:0000386C arg_0           = dword ptr  8
.text$mn:0000386C arg_4           = dword ptr  0Ch
.text$mn:0000386C arg_8           = dword ptr  10h
.text$mn:0000386C
.text$mn:0000386C                 push    ebp
.text$mn:0000386D                 mov     ebp, esp
.text$mn:0000386F                 push    ecx
.text$mn:00003870                 mov     [ebp+var_4], ecx
.text$mn:00003873                 mov     eax, [ebp+arg_8]
.text$mn:00003876                 push    eax
.text$mn:00003877                 mov     ecx, [ebp+arg_4]
.text$mn:0000387A                 push    ecx
.text$mn:0000387B                 mov     edx, [ebp+arg_0]
.text$mn:0000387E                 push    edx
.text$mn:0000387F                 mov     eax, [ebp+var_4]
.text$mn:00003882                 mov     ecx, [eax+14h]
.text$mn:00003885                 push    ecx
.text$mn:00003886                 mov     edx, [ebp+var_4]
.text$mn:00003889                 mov     eax, [edx+10h]
.text$mn:0000388C                 call    eax
.text$mn:0000388E                 add     esp, 10h
.text$mn:00003891                 mov     esp, ebp
.text$mn:00003893                 pop     ebp
.text$mn:00003894                 retn    0Ch
.text$mn:00003894 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:00003894
.text$mn:00003894 ; ---------------------------------------------------------------------------
.text$mn:00003897                 align 4
.text$mn:00003897 _text$mn        ends
.text$mn:00003897
.text$mn:00003898 ; ===========================================================================
.text$mn:00003898
.text$mn:00003898 ; Segment type: Pure code
.text$mn:00003898 ; Segment permissions: Read/Execute
.text$mn:00003898 _text$mn        segment para public 'CODE' use32
.text$mn:00003898                 assume cs:_text$mn
.text$mn:00003898                 ;org 3898h
.text$mn:00003898 ; COMDAT (pick any)
.text$mn:00003898                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003898
.text$mn:00003898 ; =============== S U B R O U T I N E =======================================
.text$mn:00003898
.text$mn:00003898 ; Attributes: bp-based frame
.text$mn:00003898
.text$mn:00003898 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00003898                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00003898 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00003898                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00003898                 push    ebp
.text$mn:00003899                 mov     ebp, esp
.text$mn:0000389B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000038A0                 pop     ebp
.text$mn:000038A1                 retn
.text$mn:000038A1 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000038A1
.text$mn:000038A1 ; ---------------------------------------------------------------------------
.text$mn:000038A2                 align 4
.text$mn:000038A2 _text$mn        ends
.text$mn:000038A2
.text$mn:000038A4 ; ===========================================================================
.text$mn:000038A4
.text$mn:000038A4 ; Segment type: Pure code
.text$mn:000038A4 ; Segment permissions: Read/Execute
.text$mn:000038A4 _text$mn        segment para public 'CODE' use32
.text$mn:000038A4                 assume cs:_text$mn
.text$mn:000038A4                 ;org 38A4h
.text$mn:000038A4 ; COMDAT (pick any)
.text$mn:000038A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038A4
.text$mn:000038A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038A4
.text$mn:000038A4 ; Attributes: bp-based frame
.text$mn:000038A4
.text$mn:000038A4 ; int __thiscall ScintillaEditView::getCurrentDocLen(ScintillaEditView *__hidden this)
.text$mn:000038A4                 public ?getCurrentDocLen@ScintillaEditView@@QBEHXZ
.text$mn:000038A4 ?getCurrentDocLen@ScintillaEditView@@QBEHXZ proc near
.text$mn:000038A4                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+399p
.text$mn:000038A4                                         ; ScintillaEditView::clearIndicator(int)+13p
.text$mn:000038A4
.text$mn:000038A4 var_4           = dword ptr -4
.text$mn:000038A4
.text$mn:000038A4                 push    ebp
.text$mn:000038A5                 mov     ebp, esp
.text$mn:000038A7                 push    ecx
.text$mn:000038A8                 mov     [ebp+var_4], ecx
.text$mn:000038AB                 push    0               ; __int32
.text$mn:000038AD                 push    0               ; unsigned int
.text$mn:000038AF                 push    7D6h            ; unsigned int
.text$mn:000038B4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000038B7                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000038BC                 mov     esp, ebp
.text$mn:000038BE                 pop     ebp
.text$mn:000038BF                 retn
.text$mn:000038BF ?getCurrentDocLen@ScintillaEditView@@QBEHXZ endp
.text$mn:000038BF
.text$mn:000038BF _text$mn        ends
.text$mn:000038BF
.text$mn:000038C0 ; ===========================================================================
.text$mn:000038C0
.text$mn:000038C0 ; Segment type: Pure code
.text$mn:000038C0 ; Segment permissions: Read/Execute
.text$mn:000038C0 _text$mn        segment para public 'CODE' use32
.text$mn:000038C0                 assume cs:_text$mn
.text$mn:000038C0                 ;org 38C0h
.text$mn:000038C0 ; COMDAT (pick any)
.text$mn:000038C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038C0
.text$mn:000038C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000038C0
.text$mn:000038C0 ; Attributes: bp-based frame
.text$mn:000038C0
.text$mn:000038C0 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:000038C0                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:000038C0 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:000038C0                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+260p
.text$mn:000038C0                 push    ebp
.text$mn:000038C1                 mov     ebp, esp
.text$mn:000038C3                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:000038C8                 pop     ebp
.text$mn:000038C9                 retn
.text$mn:000038C9 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:000038C9
.text$mn:000038C9 ; ---------------------------------------------------------------------------
.text$mn:000038CA                 align 4
.text$mn:000038CA _text$mn        ends
.text$mn:000038CA
.text$mn:000038CC ; ===========================================================================
.text$mn:000038CC
.text$mn:000038CC ; Segment type: Pure code
.text$mn:000038CC ; Segment permissions: Read/Execute
.text$mn:000038CC _text$mn        segment para public 'CODE' use32
.text$mn:000038CC                 assume cs:_text$mn
.text$mn:000038CC                 ;org 38CCh
.text$mn:000038CC ; COMDAT (pick any)
.text$mn:000038CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038CC
.text$mn:000038CC ; =============== S U B R O U T I N E =======================================
.text$mn:000038CC
.text$mn:000038CC ; Attributes: bp-based frame
.text$mn:000038CC
.text$mn:000038CC ; struct WcharMbcsConvertor *__cdecl WcharMbcsConvertor::getInstance()
.text$mn:000038CC                 public ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ
.text$mn:000038CC ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ proc near
.text$mn:000038CC                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+2A4p
.text$mn:000038CC                 push    ebp
.text$mn:000038CD                 mov     ebp, esp
.text$mn:000038CF                 mov     eax, dword ptr ds:?_pSelf@WcharMbcsConvertor@@1PAV1@A ; WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
.text$mn:000038D4                 pop     ebp
.text$mn:000038D5                 retn
.text$mn:000038D5 ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ endp
.text$mn:000038D5
.text$mn:000038D5 ; ---------------------------------------------------------------------------
.text$mn:000038D6                 align 4
.text$mn:000038D6 _text$mn        ends
.text$mn:000038D6
.text$mn:000038D8 ; ===========================================================================
.text$mn:000038D8
.text$mn:000038D8 ; Segment type: Pure code
.text$mn:000038D8 ; Segment permissions: Read/Execute
.text$mn:000038D8 _text$mn        segment para public 'CODE' use32
.text$mn:000038D8                 assume cs:_text$mn
.text$mn:000038D8                 ;org 38D8h
.text$mn:000038D8 ; COMDAT (pick any)
.text$mn:000038D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038D8
.text$mn:000038D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038D8
.text$mn:000038D8 ; Attributes: bp-based frame
.text$mn:000038D8
.text$mn:000038D8 ; const struct NppGUI *__thiscall NppParameters::getNppGUI(NppParameters *__hidden this)
.text$mn:000038D8                 public ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ
.text$mn:000038D8 ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ proc near
.text$mn:000038D8                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+267p
.text$mn:000038D8
.text$mn:000038D8 var_4           = dword ptr -4
.text$mn:000038D8
.text$mn:000038D8                 push    ebp
.text$mn:000038D9                 mov     ebp, esp
.text$mn:000038DB                 push    ecx
.text$mn:000038DC                 mov     [ebp+var_4], ecx
.text$mn:000038DF                 mov     eax, [ebp+var_4]
.text$mn:000038E2                 add     eax, 118h
.text$mn:000038E7                 mov     esp, ebp
.text$mn:000038E9                 pop     ebp
.text$mn:000038EA                 retn
.text$mn:000038EA ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ endp
.text$mn:000038EA
.text$mn:000038EA ; ---------------------------------------------------------------------------
.text$mn:000038EB                 align 4
.text$mn:000038EB _text$mn        ends
.text$mn:000038EB
.text$mn:000038EC ; ===========================================================================
.text$mn:000038EC
.text$mn:000038EC ; Segment type: Pure code
.text$mn:000038EC ; Segment permissions: Read/Execute
.text$mn:000038EC _text$mn        segment para public 'CODE' use32
.text$mn:000038EC                 assume cs:_text$mn
.text$mn:000038EC                 ;org 38ECh
.text$mn:000038EC ; COMDAT (pick any)
.text$mn:000038EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038EC
.text$mn:000038EC ; =============== S U B R O U T I N E =======================================
.text$mn:000038EC
.text$mn:000038EC ; Attributes: bp-based frame
.text$mn:000038EC
.text$mn:000038EC ; public: struct Sci_CharacterRange __thiscall ScintillaEditView::getSelection(void)const
.text$mn:000038EC                 public ?getSelection@ScintillaEditView@@QBE?AUSci_CharacterRange@@XZ
.text$mn:000038EC ?getSelection@ScintillaEditView@@QBE?AUSci_CharacterRange@@XZ proc near
.text$mn:000038EC                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+3Bp
.text$mn:000038EC
.text$mn:000038EC var_C           = dword ptr -0Ch
.text$mn:000038EC var_8           = dword ptr -8
.text$mn:000038EC var_4           = dword ptr -4
.text$mn:000038EC arg_0           = dword ptr  8
.text$mn:000038EC
.text$mn:000038EC                 push    ebp
.text$mn:000038ED                 mov     ebp, esp
.text$mn:000038EF                 sub     esp, 0Ch
.text$mn:000038F2                 mov     [ebp+var_4], ecx
.text$mn:000038F5                 push    0               ; __int32
.text$mn:000038F7                 push    0               ; unsigned int
.text$mn:000038F9                 push    85Fh            ; unsigned int
.text$mn:000038FE                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003901                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003906                 mov     [ebp+var_C], eax
.text$mn:00003909                 push    0               ; __int32
.text$mn:0000390B                 push    0               ; unsigned int
.text$mn:0000390D                 push    861h            ; unsigned int
.text$mn:00003912                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003915                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000391A                 mov     [ebp+var_8], eax
.text$mn:0000391D                 mov     eax, [ebp+arg_0]
.text$mn:00003920                 mov     ecx, [ebp+var_C]
.text$mn:00003923                 mov     [eax], ecx
.text$mn:00003925                 mov     edx, [ebp+var_8]
.text$mn:00003928                 mov     [eax+4], edx
.text$mn:0000392B                 mov     eax, [ebp+arg_0]
.text$mn:0000392E                 mov     esp, ebp
.text$mn:00003930                 pop     ebp
.text$mn:00003931                 retn    4
.text$mn:00003931 ?getSelection@ScintillaEditView@@QBE?AUSci_CharacterRange@@XZ endp
.text$mn:00003931
.text$mn:00003931 _text$mn        ends
.text$mn:00003931
.text$mn:00003934 ; ===========================================================================
.text$mn:00003934
.text$mn:00003934 ; Segment type: Pure code
.text$mn:00003934 ; Segment permissions: Read/Execute
.text$mn:00003934 _text$mn        segment para public 'CODE' use32
.text$mn:00003934                 assume cs:_text$mn
.text$mn:00003934                 ;org 3934h
.text$mn:00003934 ; COMDAT (pick any)
.text$mn:00003934                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003934
.text$mn:00003934 ; =============== S U B R O U T I N E =======================================
.text$mn:00003934
.text$mn:00003934 ; Attributes: bp-based frame
.text$mn:00003934
.text$mn:00003934 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00003934                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00003934 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00003934                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00003934
.text$mn:00003934 var_4           = dword ptr -4
.text$mn:00003934 Str             = dword ptr  8
.text$mn:00003934
.text$mn:00003934                 push    ebp
.text$mn:00003935                 mov     ebp, esp
.text$mn:00003937                 push    ecx
.text$mn:00003938                 mov     eax, [ebp+Str]
.text$mn:0000393B                 movsx   ecx, byte ptr [eax]
.text$mn:0000393E                 test    ecx, ecx
.text$mn:00003940                 jnz     short loc_394B
.text$mn:00003942                 mov     [ebp+var_4], 0
.text$mn:00003949                 jmp     short loc_395A
.text$mn:0000394B ; ---------------------------------------------------------------------------
.text$mn:0000394B
.text$mn:0000394B loc_394B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000394B                 mov     edx, [ebp+Str]
.text$mn:0000394E                 push    edx             ; Str
.text$mn:0000394F                 call    _strlen
.text$mn:00003954                 add     esp, 4
.text$mn:00003957                 mov     [ebp+var_4], eax
.text$mn:0000395A
.text$mn:0000395A loc_395A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000395A                 mov     eax, [ebp+var_4]
.text$mn:0000395D                 mov     esp, ebp
.text$mn:0000395F                 pop     ebp
.text$mn:00003960                 retn
.text$mn:00003960 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00003960
.text$mn:00003960 ; ---------------------------------------------------------------------------
.text$mn:00003961                 align 4
.text$mn:00003961 _text$mn        ends
.text$mn:00003961
.text$mn:00003964 ; ===========================================================================
.text$mn:00003964
.text$mn:00003964 ; Segment type: Pure code
.text$mn:00003964 ; Segment permissions: Read/Execute
.text$mn:00003964 _text$mn        segment para public 'CODE' use32
.text$mn:00003964                 assume cs:_text$mn
.text$mn:00003964                 ;org 3964h
.text$mn:00003964 ; COMDAT (pick any)
.text$mn:00003964                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003964
.text$mn:00003964 ; =============== S U B R O U T I N E =======================================
.text$mn:00003964
.text$mn:00003964 ; Attributes: bp-based frame
.text$mn:00003964
.text$mn:00003964 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00003964                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00003964 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00003964                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:00003964
.text$mn:00003964 var_4           = dword ptr -4
.text$mn:00003964 Str             = dword ptr  8
.text$mn:00003964
.text$mn:00003964                 push    ebp
.text$mn:00003965                 mov     ebp, esp
.text$mn:00003967                 push    ecx
.text$mn:00003968                 mov     eax, [ebp+Str]
.text$mn:0000396B                 movzx   ecx, word ptr [eax]
.text$mn:0000396E                 test    ecx, ecx
.text$mn:00003970                 jnz     short loc_397B
.text$mn:00003972                 mov     [ebp+var_4], 0
.text$mn:00003979                 jmp     short loc_398A
.text$mn:0000397B ; ---------------------------------------------------------------------------
.text$mn:0000397B
.text$mn:0000397B loc_397B:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:0000397B                 mov     edx, [ebp+Str]
.text$mn:0000397E                 push    edx             ; Str
.text$mn:0000397F                 call    _wcslen
.text$mn:00003984                 add     esp, 4
.text$mn:00003987                 mov     [ebp+var_4], eax
.text$mn:0000398A
.text$mn:0000398A loc_398A:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:0000398A                 mov     eax, [ebp+var_4]
.text$mn:0000398D                 mov     esp, ebp
.text$mn:0000398F                 pop     ebp
.text$mn:00003990                 retn
.text$mn:00003990 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00003990
.text$mn:00003990 ; ---------------------------------------------------------------------------
.text$mn:00003991                 align 4
.text$mn:00003991 _text$mn        ends
.text$mn:00003991
.text$mn:00003994 ; ===========================================================================
.text$mn:00003994
.text$mn:00003994 ; Segment type: Pure code
.text$mn:00003994 ; Segment permissions: Read/Execute
.text$mn:00003994 _text$mn        segment para public 'CODE' use32
.text$mn:00003994                 assume cs:_text$mn
.text$mn:00003994                 ;org 3994h
.text$mn:00003994 ; COMDAT (pick any)
.text$mn:00003994                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003994
.text$mn:00003994 ; =============== S U B R O U T I N E =======================================
.text$mn:00003994
.text$mn:00003994 ; Attributes: bp-based frame
.text$mn:00003994
.text$mn:00003994 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00003994                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00003994 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00003994                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00003994
.text$mn:00003994 var_4           = dword ptr -4
.text$mn:00003994
.text$mn:00003994                 push    ebp
.text$mn:00003995                 mov     ebp, esp
.text$mn:00003997                 push    ecx
.text$mn:00003998                 mov     [ebp+var_4], ecx
.text$mn:0000399B                 mov     eax, [ebp+var_4]
.text$mn:0000399E                 push    eax
.text$mn:0000399F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000039A4                 add     esp, 4
.text$mn:000039A7                 mov     esp, ebp
.text$mn:000039A9                 pop     ebp
.text$mn:000039AA                 retn
.text$mn:000039AA ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000039AA
.text$mn:000039AA ; ---------------------------------------------------------------------------
.text$mn:000039AB                 align 4
.text$mn:000039AB _text$mn        ends
.text$mn:000039AB
.text$mn:000039AC ; ===========================================================================
.text$mn:000039AC
.text$mn:000039AC ; Segment type: Pure code
.text$mn:000039AC ; Segment permissions: Read/Execute
.text$mn:000039AC _text$mn        segment para public 'CODE' use32
.text$mn:000039AC                 assume cs:_text$mn
.text$mn:000039AC                 ;org 39ACh
.text$mn:000039AC ; COMDAT (pick any)
.text$mn:000039AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039AC
.text$mn:000039AC ; =============== S U B R O U T I N E =======================================
.text$mn:000039AC
.text$mn:000039AC ; Attributes: bp-based frame
.text$mn:000039AC
.text$mn:000039AC ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:000039AC                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:000039AC ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:000039AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:000039AC
.text$mn:000039AC var_4           = dword ptr -4
.text$mn:000039AC
.text$mn:000039AC                 push    ebp
.text$mn:000039AD                 mov     ebp, esp
.text$mn:000039AF                 push    ecx
.text$mn:000039B0                 mov     [ebp+var_4], ecx
.text$mn:000039B3                 mov     eax, [ebp+var_4]
.text$mn:000039B6                 push    eax
.text$mn:000039B7                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:000039BC                 add     esp, 4
.text$mn:000039BF                 mov     esp, ebp
.text$mn:000039C1                 pop     ebp
.text$mn:000039C2                 retn
.text$mn:000039C2 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:000039C2
.text$mn:000039C2 ; ---------------------------------------------------------------------------
.text$mn:000039C3                 align 4
.text$mn:000039C3 _text$mn        ends
.text$mn:000039C3
.text$mn:000039C4 ; ===========================================================================
.text$mn:000039C4
.text$mn:000039C4 ; Segment type: Pure code
.text$mn:000039C4 ; Segment permissions: Read/Execute
.text$mn:000039C4 _text$mn        segment para public 'CODE' use32
.text$mn:000039C4                 assume cs:_text$mn
.text$mn:000039C4                 ;org 39C4h
.text$mn:000039C4 ; COMDAT (pick any)
.text$mn:000039C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039C4
.text$mn:000039C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039C4
.text$mn:000039C4 ; Attributes: bp-based frame
.text$mn:000039C4
.text$mn:000039C4 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000039C4                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000039C4 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000039C4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000039C4
.text$mn:000039C4 var_4           = dword ptr -4
.text$mn:000039C4
.text$mn:000039C4                 push    ebp
.text$mn:000039C5                 mov     ebp, esp
.text$mn:000039C7                 push    ecx
.text$mn:000039C8                 mov     [ebp+var_4], ecx
.text$mn:000039CB                 or      eax, 0FFFFFFFFh
.text$mn:000039CE                 mov     esp, ebp
.text$mn:000039D0                 pop     ebp
.text$mn:000039D1                 retn
.text$mn:000039D1 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000039D1
.text$mn:000039D1 ; ---------------------------------------------------------------------------
.text$mn:000039D2                 align 4
.text$mn:000039D2 _text$mn        ends
.text$mn:000039D2
.text$mn:000039D4 ; ===========================================================================
.text$mn:000039D4
.text$mn:000039D4 ; Segment type: Pure code
.text$mn:000039D4 ; Segment permissions: Read/Execute
.text$mn:000039D4 _text$mn        segment para public 'CODE' use32
.text$mn:000039D4                 assume cs:_text$mn
.text$mn:000039D4                 ;org 39D4h
.text$mn:000039D4 ; COMDAT (pick any)
.text$mn:000039D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039D4
.text$mn:000039D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039D4
.text$mn:000039D4 ; Attributes: bp-based frame
.text$mn:000039D4
.text$mn:000039D4 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:000039D4                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:000039D4 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:000039D4                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:000039D4
.text$mn:000039D4 var_4           = dword ptr -4
.text$mn:000039D4
.text$mn:000039D4                 push    ebp
.text$mn:000039D5                 mov     ebp, esp
.text$mn:000039D7                 push    ecx
.text$mn:000039D8                 mov     [ebp+var_4], ecx
.text$mn:000039DB                 mov     eax, 7FFFFFFFh
.text$mn:000039E0                 mov     esp, ebp
.text$mn:000039E2                 pop     ebp
.text$mn:000039E3                 retn
.text$mn:000039E3 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:000039E3
.text$mn:000039E3 _text$mn        ends
.text$mn:000039E3
.text$mn:000039E4 ; ===========================================================================
.text$mn:000039E4
.text$mn:000039E4 ; Segment type: Pure code
.text$mn:000039E4 ; Segment permissions: Read/Execute
.text$mn:000039E4 _text$mn        segment para public 'CODE' use32
.text$mn:000039E4                 assume cs:_text$mn
.text$mn:000039E4                 ;org 39E4h
.text$mn:000039E4 ; COMDAT (pick any)
.text$mn:000039E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039E4
.text$mn:000039E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039E4
.text$mn:000039E4 ; Attributes: bp-based frame
.text$mn:000039E4
.text$mn:000039E4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000039E4                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000039E4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000039E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000039E4
.text$mn:000039E4 arg_0           = dword ptr  8
.text$mn:000039E4
.text$mn:000039E4                 push    ebp
.text$mn:000039E5                 mov     ebp, esp
.text$mn:000039E7                 mov     ecx, [ebp+arg_0]
.text$mn:000039EA                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000039EF                 pop     ebp
.text$mn:000039F0                 retn
.text$mn:000039F0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000039F0
.text$mn:000039F0 ; ---------------------------------------------------------------------------
.text$mn:000039F1                 align 4
.text$mn:000039F1 _text$mn        ends
.text$mn:000039F1
.text$mn:000039F4 ; ===========================================================================
.text$mn:000039F4
.text$mn:000039F4 ; Segment type: Pure code
.text$mn:000039F4 ; Segment permissions: Read/Execute
.text$mn:000039F4 _text$mn        segment para public 'CODE' use32
.text$mn:000039F4                 assume cs:_text$mn
.text$mn:000039F4                 ;org 39F4h
.text$mn:000039F4 ; COMDAT (pick any)
.text$mn:000039F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039F4
.text$mn:000039F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039F4
.text$mn:000039F4 ; Attributes: bp-based frame
.text$mn:000039F4
.text$mn:000039F4 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:000039F4                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:000039F4 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:000039F4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:000039F4
.text$mn:000039F4 arg_0           = dword ptr  8
.text$mn:000039F4
.text$mn:000039F4                 push    ebp
.text$mn:000039F5                 mov     ebp, esp
.text$mn:000039F7                 mov     ecx, [ebp+arg_0]
.text$mn:000039FA                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:000039FF                 pop     ebp
.text$mn:00003A00                 retn
.text$mn:00003A00 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:00003A00
.text$mn:00003A00 ; ---------------------------------------------------------------------------
.text$mn:00003A01                 align 4
.text$mn:00003A01 _text$mn        ends
.text$mn:00003A01
.text$mn:00003A04 ; ===========================================================================
.text$mn:00003A04
.text$mn:00003A04 ; Segment type: Pure code
.text$mn:00003A04 ; Segment permissions: Read/Execute
.text$mn:00003A04 _text$mn        segment para public 'CODE' use32
.text$mn:00003A04                 assume cs:_text$mn
.text$mn:00003A04                 ;org 3A04h
.text$mn:00003A04 ; COMDAT (pick any)
.text$mn:00003A04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A04
.text$mn:00003A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A04
.text$mn:00003A04 ; Attributes: bp-based frame
.text$mn:00003A04
.text$mn:00003A04 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00003A04                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00003A04 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00003A04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00003A04                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00003A04
.text$mn:00003A04 var_10          = dword ptr -10h
.text$mn:00003A04 var_C           = dword ptr -0Ch
.text$mn:00003A04 var_8           = dword ptr -8
.text$mn:00003A04 var_1           = byte ptr -1
.text$mn:00003A04
.text$mn:00003A04                 push    ebp
.text$mn:00003A05                 mov     ebp, esp
.text$mn:00003A07                 sub     esp, 10h
.text$mn:00003A0A                 mov     [ebp+var_10], ecx
.text$mn:00003A0D                 lea     eax, [ebp+var_1]
.text$mn:00003A10                 push    eax
.text$mn:00003A11                 mov     ecx, [ebp+var_10]
.text$mn:00003A14                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003A19                 mov     ecx, eax
.text$mn:00003A1B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00003A20                 mov     [ebp+var_8], eax
.text$mn:00003A23                 cmp     [ebp+var_8], 1
.text$mn:00003A27                 ja      short loc_3A32
.text$mn:00003A29                 mov     [ebp+var_C], 1
.text$mn:00003A30                 jmp     short loc_3A3B
.text$mn:00003A32 ; ---------------------------------------------------------------------------
.text$mn:00003A32
.text$mn:00003A32 loc_3A32:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00003A32                 mov     ecx, [ebp+var_8]
.text$mn:00003A35                 sub     ecx, 1
.text$mn:00003A38                 mov     [ebp+var_C], ecx
.text$mn:00003A3B
.text$mn:00003A3B loc_3A3B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00003A3B                 mov     eax, [ebp+var_C]
.text$mn:00003A3E                 mov     esp, ebp
.text$mn:00003A40                 pop     ebp
.text$mn:00003A41                 retn
.text$mn:00003A41 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003A41
.text$mn:00003A41 ; ---------------------------------------------------------------------------
.text$mn:00003A42                 align 4
.text$mn:00003A42 _text$mn        ends
.text$mn:00003A42
.text$mn:00003A44 ; ===========================================================================
.text$mn:00003A44
.text$mn:00003A44 ; Segment type: Pure code
.text$mn:00003A44 ; Segment permissions: Read/Execute
.text$mn:00003A44 _text$mn        segment para public 'CODE' use32
.text$mn:00003A44                 assume cs:_text$mn
.text$mn:00003A44                 ;org 3A44h
.text$mn:00003A44 ; COMDAT (pick any)
.text$mn:00003A44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A44
.text$mn:00003A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A44
.text$mn:00003A44 ; Attributes: bp-based frame
.text$mn:00003A44
.text$mn:00003A44 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00003A44                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00003A44 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00003A44                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:00003A44                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:00003A44
.text$mn:00003A44 var_10          = dword ptr -10h
.text$mn:00003A44 var_C           = dword ptr -0Ch
.text$mn:00003A44 var_8           = dword ptr -8
.text$mn:00003A44 var_1           = byte ptr -1
.text$mn:00003A44
.text$mn:00003A44                 push    ebp
.text$mn:00003A45                 mov     ebp, esp
.text$mn:00003A47                 sub     esp, 10h
.text$mn:00003A4A                 mov     [ebp+var_10], ecx
.text$mn:00003A4D                 lea     eax, [ebp+var_1]
.text$mn:00003A50                 push    eax
.text$mn:00003A51                 mov     ecx, [ebp+var_10]
.text$mn:00003A54                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003A59                 mov     ecx, eax
.text$mn:00003A5B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00003A60                 mov     [ebp+var_8], eax
.text$mn:00003A63                 cmp     [ebp+var_8], 1
.text$mn:00003A67                 ja      short loc_3A72
.text$mn:00003A69                 mov     [ebp+var_C], 1
.text$mn:00003A70                 jmp     short loc_3A7B
.text$mn:00003A72 ; ---------------------------------------------------------------------------
.text$mn:00003A72
.text$mn:00003A72 loc_3A72:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:00003A72                 mov     ecx, [ebp+var_8]
.text$mn:00003A75                 sub     ecx, 1
.text$mn:00003A78                 mov     [ebp+var_C], ecx
.text$mn:00003A7B
.text$mn:00003A7B loc_3A7B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00003A7B                 mov     eax, [ebp+var_C]
.text$mn:00003A7E                 mov     esp, ebp
.text$mn:00003A80                 pop     ebp
.text$mn:00003A81                 retn
.text$mn:00003A81 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00003A81
.text$mn:00003A81 ; ---------------------------------------------------------------------------
.text$mn:00003A82                 align 4
.text$mn:00003A82 _text$mn        ends
.text$mn:00003A82
.text$mn:00003A84 ; ===========================================================================
.text$mn:00003A84
.text$mn:00003A84 ; Segment type: Pure code
.text$mn:00003A84 ; Segment permissions: Read/Execute
.text$mn:00003A84 _text$mn        segment para public 'CODE' use32
.text$mn:00003A84                 assume cs:_text$mn
.text$mn:00003A84                 ;org 3A84h
.text$mn:00003A84 ; COMDAT (pick any)
.text$mn:00003A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A84
.text$mn:00003A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A84
.text$mn:00003A84 ; Attributes: bp-based frame
.text$mn:00003A84
.text$mn:00003A84 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00003A84                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003A84 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003A84                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00003A84                                         ; DATA XREF: .rdata:0000446Co
.text$mn:00003A84
.text$mn:00003A84 var_1C          = dword ptr -1Ch
.text$mn:00003A84 var_18          = dword ptr -18h
.text$mn:00003A84 Str             = dword ptr -14h
.text$mn:00003A84 var_10          = dword ptr -10h
.text$mn:00003A84 var_C           = dword ptr -0Ch
.text$mn:00003A84 var_4           = dword ptr -4
.text$mn:00003A84 arg_0           = dword ptr  8
.text$mn:00003A84 arg_4           = dword ptr  0Ch
.text$mn:00003A84
.text$mn:00003A84                 push    ebp
.text$mn:00003A85                 mov     ebp, esp
.text$mn:00003A87                 push    0FFFFFFFFh
.text$mn:00003A89                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003A8E                 mov     eax, large fs:0
.text$mn:00003A94                 push    eax
.text$mn:00003A95                 sub     esp, 10h
.text$mn:00003A98                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A9D                 xor     eax, ebp
.text$mn:00003A9F                 push    eax
.text$mn:00003AA0                 lea     eax, [ebp+var_C]
.text$mn:00003AA3                 mov     large fs:0, eax
.text$mn:00003AA9                 mov     [ebp+var_1C], ecx
.text$mn:00003AAC                 mov     [ebp+var_18], 0
.text$mn:00003AB3                 mov     eax, [ebp+arg_4]
.text$mn:00003AB6                 push    eax             ; int
.text$mn:00003AB7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003ABC                 add     esp, 4
.text$mn:00003ABF                 mov     [ebp+var_10], eax
.text$mn:00003AC2                 cmp     [ebp+var_10], 0
.text$mn:00003AC6                 jz      short loc_3AD0
.text$mn:00003AC8                 mov     ecx, [ebp+var_10]
.text$mn:00003ACB                 mov     [ebp+Str], ecx
.text$mn:00003ACE                 jmp     short loc_3AD7
.text$mn:00003AD0 ; ---------------------------------------------------------------------------
.text$mn:00003AD0
.text$mn:00003AD0 loc_3AD0:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00003AD0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00003AD7
.text$mn:00003AD7 loc_3AD7:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00003AD7                 mov     edx, [ebp+Str]
.text$mn:00003ADA                 push    edx             ; Str
.text$mn:00003ADB                 mov     ecx, [ebp+arg_0]
.text$mn:00003ADE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003AE3                 mov     [ebp+var_4], 0
.text$mn:00003AEA                 mov     eax, [ebp+var_18]
.text$mn:00003AED                 or      eax, 1
.text$mn:00003AF0                 mov     [ebp+var_18], eax
.text$mn:00003AF3                 mov     eax, [ebp+arg_0]
.text$mn:00003AF6                 mov     ecx, [ebp+var_C]
.text$mn:00003AF9                 mov     large fs:0, ecx
.text$mn:00003B00                 pop     ecx
.text$mn:00003B01                 mov     esp, ebp
.text$mn:00003B03                 pop     ebp
.text$mn:00003B04                 retn    8
.text$mn:00003B04 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003B04
.text$mn:00003B04 ; ---------------------------------------------------------------------------
.text$mn:00003B07                 align 4
.text$mn:00003B07 _text$mn        ends
.text$mn:00003B07
.text$x:00003B08 ; ===========================================================================
.text$x:00003B08
.text$x:00003B08 ; Segment type: Pure code
.text$x:00003B08 ; Segment permissions: Read/Execute
.text$x:00003B08 _text$x         segment para public 'CODE' use32
.text$x:00003B08                 assume cs:_text$x
.text$x:00003B08                 ;org 3B08h
.text$x:00003B08 ; COMDAT (pick associative to section at 3A84)
.text$x:00003B08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003B08
.text$x:00003B08 ; =============== S U B R O U T I N E =======================================
.text$x:00003B08
.text$x:00003B08
.text$x:00003B08 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003B08                                         ; DATA XREF: .xdata$x:00004018o
.text$x:00003B08                 mov     eax, [ebp-18h]
.text$x:00003B0B                 and     eax, 1
.text$x:00003B0E                 jz      $LN6
.text$x:00003B14                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00003B18                 mov     ecx, [ebp+8]
.text$x:00003B1B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003B20 ; ---------------------------------------------------------------------------
.text$x:00003B20
.text$x:00003B20 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003B20                 retn
.text$x:00003B20 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003B20
.text$x:00003B21
.text$x:00003B21 ; =============== S U B R O U T I N E =======================================
.text$x:00003B21
.text$x:00003B21
.text$x:00003B21 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003B21                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00003B21
.text$x:00003B21 arg_4           = dword ptr  8
.text$x:00003B21
.text$x:00003B21                 mov     edx, [esp+arg_4]
.text$x:00003B25                 lea     eax, [edx+0Ch]
.text$x:00003B28                 mov     ecx, [edx-14h]
.text$x:00003B2B                 xor     ecx, eax
.text$x:00003B2D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003B32                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003B37                 jmp     ___CxxFrameHandler3
.text$x:00003B37 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003B37
.text$x:00003B37 _text$x         ends
.text$x:00003B37
.text$mn:00003B3C ; ===========================================================================
.text$mn:00003B3C
.text$mn:00003B3C ; Segment type: Pure code
.text$mn:00003B3C ; Segment permissions: Read/Execute
.text$mn:00003B3C _text$mn        segment para public 'CODE' use32
.text$mn:00003B3C                 assume cs:_text$mn
.text$mn:00003B3C                 ;org 3B3Ch
.text$mn:00003B3C ; COMDAT (pick any)
.text$mn:00003B3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B3C
.text$mn:00003B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B3C
.text$mn:00003B3C ; Attributes: bp-based frame
.text$mn:00003B3C
.text$mn:00003B3C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00003B3C                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003B3C ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003B3C                                         ; DATA XREF: .rdata:000044A0o
.text$mn:00003B3C
.text$mn:00003B3C var_14          = dword ptr -14h
.text$mn:00003B3C var_10          = dword ptr -10h
.text$mn:00003B3C var_C           = dword ptr -0Ch
.text$mn:00003B3C var_4           = dword ptr -4
.text$mn:00003B3C arg_0           = dword ptr  8
.text$mn:00003B3C arg_4           = dword ptr  0Ch
.text$mn:00003B3C
.text$mn:00003B3C                 push    ebp
.text$mn:00003B3D                 mov     ebp, esp
.text$mn:00003B3F                 push    0FFFFFFFFh
.text$mn:00003B41                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003B46                 mov     eax, large fs:0
.text$mn:00003B4C                 push    eax
.text$mn:00003B4D                 sub     esp, 8
.text$mn:00003B50                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B55                 xor     eax, ebp
.text$mn:00003B57                 push    eax
.text$mn:00003B58                 lea     eax, [ebp+var_C]
.text$mn:00003B5B                 mov     large fs:0, eax
.text$mn:00003B61                 mov     [ebp+var_14], ecx
.text$mn:00003B64                 mov     [ebp+var_10], 0
.text$mn:00003B6B                 cmp     [ebp+arg_4], 1
.text$mn:00003B6F                 jnz     short loc_3B95
.text$mn:00003B71                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00003B76                 mov     ecx, [ebp+arg_0]
.text$mn:00003B79                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003B7E                 mov     [ebp+var_4], 0
.text$mn:00003B85                 mov     eax, [ebp+var_10]
.text$mn:00003B88                 or      eax, 1
.text$mn:00003B8B                 mov     [ebp+var_10], eax
.text$mn:00003B8E                 mov     eax, [ebp+arg_0]
.text$mn:00003B91                 jmp     short loc_3BB8
.text$mn:00003B93 ; ---------------------------------------------------------------------------
.text$mn:00003B93                 jmp     short loc_3BB8
.text$mn:00003B95 ; ---------------------------------------------------------------------------
.text$mn:00003B95
.text$mn:00003B95 loc_3B95:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00003B95                 mov     ecx, [ebp+arg_4]
.text$mn:00003B98                 push    ecx
.text$mn:00003B99                 mov     edx, [ebp+arg_0]
.text$mn:00003B9C                 push    edx
.text$mn:00003B9D                 mov     ecx, [ebp+var_14]
.text$mn:00003BA0                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00003BA5                 mov     [ebp+var_4], 0
.text$mn:00003BAC                 mov     eax, [ebp+var_10]
.text$mn:00003BAF                 or      eax, 1
.text$mn:00003BB2                 mov     [ebp+var_10], eax
.text$mn:00003BB5                 mov     eax, [ebp+arg_0]
.text$mn:00003BB8
.text$mn:00003BB8 loc_3BB8:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00003BB8                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00003BB8                 mov     ecx, [ebp+var_C]
.text$mn:00003BBB                 mov     large fs:0, ecx
.text$mn:00003BC2                 pop     ecx
.text$mn:00003BC3                 mov     esp, ebp
.text$mn:00003BC5                 pop     ebp
.text$mn:00003BC6                 retn    8
.text$mn:00003BC6 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003BC6
.text$mn:00003BC6 ; ---------------------------------------------------------------------------
.text$mn:00003BC9                 align 4
.text$mn:00003BC9 _text$mn        ends
.text$mn:00003BC9
.text$x:00003BCC ; ===========================================================================
.text$x:00003BCC
.text$x:00003BCC ; Segment type: Pure code
.text$x:00003BCC ; Segment permissions: Read/Execute
.text$x:00003BCC _text$x         segment para public 'CODE' use32
.text$x:00003BCC                 assume cs:_text$x
.text$x:00003BCC                 ;org 3BCCh
.text$x:00003BCC ; COMDAT (pick associative to section at 3B3C)
.text$x:00003BCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003BCC
.text$x:00003BCC ; =============== S U B R O U T I N E =======================================
.text$x:00003BCC
.text$x:00003BCC
.text$x:00003BCC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003BCC                                         ; DATA XREF: .xdata$x:0000409Co
.text$x:00003BCC                 mov     eax, [ebp-10h]
.text$x:00003BCF                 and     eax, 1
.text$x:00003BD2                 jz      $LN6_0
.text$x:00003BD8                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003BDC                 mov     ecx, [ebp+8]
.text$x:00003BDF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003BE4 ; ---------------------------------------------------------------------------
.text$x:00003BE4
.text$x:00003BE4 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003BE4                 retn
.text$x:00003BE4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003BE4
.text$x:00003BE5
.text$x:00003BE5 ; =============== S U B R O U T I N E =======================================
.text$x:00003BE5
.text$x:00003BE5
.text$x:00003BE5 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003BE5                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00003BE5
.text$x:00003BE5 arg_4           = dword ptr  8
.text$x:00003BE5
.text$x:00003BE5                 mov     edx, [esp+arg_4]
.text$x:00003BE9                 lea     eax, [edx+0Ch]
.text$x:00003BEC                 mov     ecx, [edx-0Ch]
.text$x:00003BEF                 xor     ecx, eax
.text$x:00003BF1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BF6                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003BFB                 jmp     ___CxxFrameHandler3
.text$x:00003BFB __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003BFB
.text$x:00003BFB _text$x         ends
.text$x:00003BFB
.text$mn:00003C00 ; ===========================================================================
.text$mn:00003C00
.text$mn:00003C00 ; Segment type: Pure code
.text$mn:00003C00 ; Segment permissions: Read/Execute
.text$mn:00003C00 _text$mn        segment para public 'CODE' use32
.text$mn:00003C00                 assume cs:_text$mn
.text$mn:00003C00                 ;org 3C00h
.text$mn:00003C00 ; COMDAT (pick any)
.text$mn:00003C00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C00
.text$mn:00003C00 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C00
.text$mn:00003C00 ; Attributes: bp-based frame
.text$mn:00003C00
.text$mn:00003C00 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00003C00                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003C00 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003C00                                         ; DATA XREF: .rdata:000044E0o
.text$mn:00003C00
.text$mn:00003C00 var_1C          = dword ptr -1Ch
.text$mn:00003C00 var_18          = dword ptr -18h
.text$mn:00003C00 Str             = dword ptr -14h
.text$mn:00003C00 var_10          = dword ptr -10h
.text$mn:00003C00 var_C           = dword ptr -0Ch
.text$mn:00003C00 var_4           = dword ptr -4
.text$mn:00003C00 arg_0           = dword ptr  8
.text$mn:00003C00 arg_4           = dword ptr  0Ch
.text$mn:00003C00
.text$mn:00003C00                 push    ebp
.text$mn:00003C01                 mov     ebp, esp
.text$mn:00003C03                 push    0FFFFFFFFh
.text$mn:00003C05                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003C0A                 mov     eax, large fs:0
.text$mn:00003C10                 push    eax
.text$mn:00003C11                 sub     esp, 10h
.text$mn:00003C14                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C19                 xor     eax, ebp
.text$mn:00003C1B                 push    eax
.text$mn:00003C1C                 lea     eax, [ebp+var_C]
.text$mn:00003C1F                 mov     large fs:0, eax
.text$mn:00003C25                 mov     [ebp+var_1C], ecx
.text$mn:00003C28                 mov     [ebp+var_18], 0
.text$mn:00003C2F                 mov     eax, [ebp+arg_4]
.text$mn:00003C32                 push    eax             ; int
.text$mn:00003C33                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00003C38                 add     esp, 4
.text$mn:00003C3B                 mov     [ebp+var_10], eax
.text$mn:00003C3E                 cmp     [ebp+var_10], 0
.text$mn:00003C42                 jz      short loc_3C4C
.text$mn:00003C44                 mov     ecx, [ebp+var_10]
.text$mn:00003C47                 mov     [ebp+Str], ecx
.text$mn:00003C4A                 jmp     short loc_3C53
.text$mn:00003C4C ; ---------------------------------------------------------------------------
.text$mn:00003C4C
.text$mn:00003C4C loc_3C4C:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00003C4C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00003C53
.text$mn:00003C53 loc_3C53:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00003C53                 mov     edx, [ebp+Str]
.text$mn:00003C56                 push    edx             ; Str
.text$mn:00003C57                 mov     ecx, [ebp+arg_0]
.text$mn:00003C5A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003C5F                 mov     [ebp+var_4], 0
.text$mn:00003C66                 mov     eax, [ebp+var_18]
.text$mn:00003C69                 or      eax, 1
.text$mn:00003C6C                 mov     [ebp+var_18], eax
.text$mn:00003C6F                 mov     eax, [ebp+arg_0]
.text$mn:00003C72                 mov     ecx, [ebp+var_C]
.text$mn:00003C75                 mov     large fs:0, ecx
.text$mn:00003C7C                 pop     ecx
.text$mn:00003C7D                 mov     esp, ebp
.text$mn:00003C7F                 pop     ebp
.text$mn:00003C80                 retn    8
.text$mn:00003C80 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003C80
.text$mn:00003C80 ; ---------------------------------------------------------------------------
.text$mn:00003C83                 align 4
.text$mn:00003C83 _text$mn        ends
.text$mn:00003C83
.text$x:00003C84 ; ===========================================================================
.text$x:00003C84
.text$x:00003C84 ; Segment type: Pure code
.text$x:00003C84 ; Segment permissions: Read/Execute
.text$x:00003C84 _text$x         segment para public 'CODE' use32
.text$x:00003C84                 assume cs:_text$x
.text$x:00003C84                 ;org 3C84h
.text$x:00003C84 ; COMDAT (pick associative to section at 3C00)
.text$x:00003C84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003C84
.text$x:00003C84 ; =============== S U B R O U T I N E =======================================
.text$x:00003C84
.text$x:00003C84
.text$x:00003C84 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003C84                                         ; DATA XREF: .xdata$x:00004120o
.text$x:00003C84                 mov     eax, [ebp-18h]
.text$x:00003C87                 and     eax, 1
.text$x:00003C8A                 jz      $LN6_1
.text$x:00003C90                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00003C94                 mov     ecx, [ebp+8]
.text$x:00003C97                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003C9C ; ---------------------------------------------------------------------------
.text$x:00003C9C
.text$x:00003C9C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003C9C                 retn
.text$x:00003C9C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003C9C
.text$x:00003C9D
.text$x:00003C9D ; =============== S U B R O U T I N E =======================================
.text$x:00003C9D
.text$x:00003C9D
.text$x:00003C9D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003C9D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00003C9D
.text$x:00003C9D arg_4           = dword ptr  8
.text$x:00003C9D
.text$x:00003C9D                 mov     edx, [esp+arg_4]
.text$x:00003CA1                 lea     eax, [edx+0Ch]
.text$x:00003CA4                 mov     ecx, [edx-14h]
.text$x:00003CA7                 xor     ecx, eax
.text$x:00003CA9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003CAE                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003CB3                 jmp     ___CxxFrameHandler3
.text$x:00003CB3 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003CB3
.text$x:00003CB3 _text$x         ends
.text$x:00003CB3
.text$mn:00003CB8 ; ===========================================================================
.text$mn:00003CB8
.text$mn:00003CB8 ; Segment type: Pure code
.text$mn:00003CB8 ; Segment permissions: Read/Execute
.text$mn:00003CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CB8                 assume cs:_text$mn
.text$mn:00003CB8                 ;org 3CB8h
.text$mn:00003CB8 ; COMDAT (pick any)
.text$mn:00003CB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CB8
.text$mn:00003CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CB8
.text$mn:00003CB8 ; Attributes: bp-based frame
.text$mn:00003CB8
.text$mn:00003CB8 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00003CB8                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00003CB8 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00003CB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00003CB8
.text$mn:00003CB8 var_4           = dword ptr -4
.text$mn:00003CB8 Dst             = dword ptr  8
.text$mn:00003CB8 Src             = dword ptr  0Ch
.text$mn:00003CB8 Size            = dword ptr  10h
.text$mn:00003CB8
.text$mn:00003CB8                 push    ebp
.text$mn:00003CB9                 mov     ebp, esp
.text$mn:00003CBB                 push    ecx
.text$mn:00003CBC                 cmp     [ebp+Size], 0
.text$mn:00003CC0                 jnz     short loc_3CCA
.text$mn:00003CC2                 mov     eax, [ebp+Dst]
.text$mn:00003CC5                 mov     [ebp+var_4], eax
.text$mn:00003CC8                 jmp     short loc_3CE1
.text$mn:00003CCA ; ---------------------------------------------------------------------------
.text$mn:00003CCA
.text$mn:00003CCA loc_3CCA:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00003CCA                 mov     ecx, [ebp+Size]
.text$mn:00003CCD                 push    ecx             ; Size
.text$mn:00003CCE                 mov     edx, [ebp+Src]
.text$mn:00003CD1                 push    edx             ; Src
.text$mn:00003CD2                 mov     eax, [ebp+Dst]
.text$mn:00003CD5                 push    eax             ; Dst
.text$mn:00003CD6                 call    _memmove
.text$mn:00003CDB                 add     esp, 0Ch
.text$mn:00003CDE                 mov     [ebp+var_4], eax
.text$mn:00003CE1
.text$mn:00003CE1 loc_3CE1:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00003CE1                 mov     eax, [ebp+var_4]
.text$mn:00003CE4                 mov     esp, ebp
.text$mn:00003CE6                 pop     ebp
.text$mn:00003CE7                 retn
.text$mn:00003CE7 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00003CE7
.text$mn:00003CE7 _text$mn        ends
.text$mn:00003CE7
.text$mn:00003CE8 ; ===========================================================================
.text$mn:00003CE8
.text$mn:00003CE8 ; Segment type: Pure code
.text$mn:00003CE8 ; Segment permissions: Read/Execute
.text$mn:00003CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CE8                 assume cs:_text$mn
.text$mn:00003CE8                 ;org 3CE8h
.text$mn:00003CE8 ; COMDAT (pick any)
.text$mn:00003CE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CE8
.text$mn:00003CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CE8
.text$mn:00003CE8 ; Attributes: bp-based frame
.text$mn:00003CE8
.text$mn:00003CE8 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00003CE8                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00003CE8 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00003CE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:00003CE8
.text$mn:00003CE8 var_4           = dword ptr -4
.text$mn:00003CE8 Dst             = dword ptr  8
.text$mn:00003CE8 Src             = dword ptr  0Ch
.text$mn:00003CE8 arg_8           = dword ptr  10h
.text$mn:00003CE8
.text$mn:00003CE8                 push    ebp
.text$mn:00003CE9                 mov     ebp, esp
.text$mn:00003CEB                 push    ecx
.text$mn:00003CEC                 cmp     [ebp+arg_8], 0
.text$mn:00003CF0                 jnz     short loc_3CFA
.text$mn:00003CF2                 mov     eax, [ebp+Dst]
.text$mn:00003CF5                 mov     [ebp+var_4], eax
.text$mn:00003CF8                 jmp     short loc_3D11
.text$mn:00003CFA ; ---------------------------------------------------------------------------
.text$mn:00003CFA
.text$mn:00003CFA loc_3CFA:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00003CFA                 mov     ecx, [ebp+arg_8]
.text$mn:00003CFD                 push    ecx             ; int
.text$mn:00003CFE                 mov     edx, [ebp+Src]
.text$mn:00003D01                 push    edx             ; Src
.text$mn:00003D02                 mov     eax, [ebp+Dst]
.text$mn:00003D05                 push    eax             ; Dst
.text$mn:00003D06                 call    _wmemmove
.text$mn:00003D0B                 add     esp, 0Ch
.text$mn:00003D0E                 mov     [ebp+var_4], eax
.text$mn:00003D11
.text$mn:00003D11 loc_3D11:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00003D11                 mov     eax, [ebp+var_4]
.text$mn:00003D14                 mov     esp, ebp
.text$mn:00003D16                 pop     ebp
.text$mn:00003D17                 retn
.text$mn:00003D17 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00003D17
.text$mn:00003D17 _text$mn        ends
.text$mn:00003D17
.text$mn:00003D18 ; ===========================================================================
.text$mn:00003D18
.text$mn:00003D18 ; Segment type: Pure code
.text$mn:00003D18 ; Segment permissions: Read/Execute
.text$mn:00003D18 _text$mn        segment para public 'CODE' use32
.text$mn:00003D18                 assume cs:_text$mn
.text$mn:00003D18                 ;org 3D18h
.text$mn:00003D18 ; COMDAT (pick any)
.text$mn:00003D18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D18
.text$mn:00003D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D18
.text$mn:00003D18 ; Attributes: bp-based frame
.text$mn:00003D18
.text$mn:00003D18 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00003D18                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00003D18 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00003D18                                         ; DATA XREF: .rdata:00004468o
.text$mn:00003D18
.text$mn:00003D18 var_4           = dword ptr -4
.text$mn:00003D18
.text$mn:00003D18                 push    ebp
.text$mn:00003D19                 mov     ebp, esp
.text$mn:00003D1B                 push    ecx
.text$mn:00003D1C                 mov     [ebp+var_4], ecx
.text$mn:00003D1F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00003D24                 mov     esp, ebp
.text$mn:00003D26                 pop     ebp
.text$mn:00003D27                 retn
.text$mn:00003D27 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00003D27
.text$mn:00003D27 _text$mn        ends
.text$mn:00003D27
.text$mn:00003D28 ; ===========================================================================
.text$mn:00003D28
.text$mn:00003D28 ; Segment type: Pure code
.text$mn:00003D28 ; Segment permissions: Read/Execute
.text$mn:00003D28 _text$mn        segment para public 'CODE' use32
.text$mn:00003D28                 assume cs:_text$mn
.text$mn:00003D28                 ;org 3D28h
.text$mn:00003D28 ; COMDAT (pick any)
.text$mn:00003D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D28
.text$mn:00003D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D28
.text$mn:00003D28 ; Attributes: bp-based frame
.text$mn:00003D28
.text$mn:00003D28 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00003D28                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00003D28 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00003D28                                         ; DATA XREF: .rdata:0000449Co
.text$mn:00003D28
.text$mn:00003D28 var_4           = dword ptr -4
.text$mn:00003D28
.text$mn:00003D28                 push    ebp
.text$mn:00003D29                 mov     ebp, esp
.text$mn:00003D2B                 push    ecx
.text$mn:00003D2C                 mov     [ebp+var_4], ecx
.text$mn:00003D2F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00003D34                 mov     esp, ebp
.text$mn:00003D36                 pop     ebp
.text$mn:00003D37                 retn
.text$mn:00003D37 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00003D37
.text$mn:00003D37 _text$mn        ends
.text$mn:00003D37
.text$mn:00003D38 ; ===========================================================================
.text$mn:00003D38
.text$mn:00003D38 ; Segment type: Pure code
.text$mn:00003D38 ; Segment permissions: Read/Execute
.text$mn:00003D38 _text$mn        segment para public 'CODE' use32
.text$mn:00003D38                 assume cs:_text$mn
.text$mn:00003D38                 ;org 3D38h
.text$mn:00003D38 ; COMDAT (pick any)
.text$mn:00003D38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D38
.text$mn:00003D38 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D38
.text$mn:00003D38 ; Attributes: bp-based frame
.text$mn:00003D38
.text$mn:00003D38 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00003D38                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00003D38 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00003D38                                         ; DATA XREF: .rdata:000044DCo
.text$mn:00003D38
.text$mn:00003D38 var_4           = dword ptr -4
.text$mn:00003D38
.text$mn:00003D38                 push    ebp
.text$mn:00003D39                 mov     ebp, esp
.text$mn:00003D3B                 push    ecx
.text$mn:00003D3C                 mov     [ebp+var_4], ecx
.text$mn:00003D3F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00003D44                 mov     esp, ebp
.text$mn:00003D46                 pop     ebp
.text$mn:00003D47                 retn
.text$mn:00003D47 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00003D47
.text$mn:00003D47 _text$mn        ends
.text$mn:00003D47
.text$mn:00003D48 ; ===========================================================================
.text$mn:00003D48
.text$mn:00003D48 ; Segment type: Pure code
.text$mn:00003D48 ; Segment permissions: Read/Execute
.text$mn:00003D48 _text$mn        segment para public 'CODE' use32
.text$mn:00003D48                 assume cs:_text$mn
.text$mn:00003D48                 ;org 3D48h
.text$mn:00003D48 ; COMDAT (pick any)
.text$mn:00003D48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D48
.text$mn:00003D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D48
.text$mn:00003D48 ; Attributes: bp-based frame
.text$mn:00003D48
.text$mn:00003D48 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00003D48                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00003D48 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00003D48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00003D48                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00003D48
.text$mn:00003D48 var_4           = dword ptr -4
.text$mn:00003D48
.text$mn:00003D48                 push    ebp
.text$mn:00003D49                 mov     ebp, esp
.text$mn:00003D4B                 push    ecx
.text$mn:00003D4C                 mov     [ebp+var_4], ecx
.text$mn:00003D4F                 mov     eax, [ebp+var_4]
.text$mn:00003D52                 mov     eax, [eax+14h]
.text$mn:00003D55                 mov     esp, ebp
.text$mn:00003D57                 pop     ebp
.text$mn:00003D58                 retn
.text$mn:00003D58 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003D58
.text$mn:00003D58 ; ---------------------------------------------------------------------------
.text$mn:00003D59                 align 4
.text$mn:00003D59 _text$mn        ends
.text$mn:00003D59
.text$mn:00003D5C ; ===========================================================================
.text$mn:00003D5C
.text$mn:00003D5C ; Segment type: Pure code
.text$mn:00003D5C ; Segment permissions: Read/Execute
.text$mn:00003D5C _text$mn        segment para public 'CODE' use32
.text$mn:00003D5C                 assume cs:_text$mn
.text$mn:00003D5C                 ;org 3D5Ch
.text$mn:00003D5C ; COMDAT (pick any)
.text$mn:00003D5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D5C
.text$mn:00003D5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D5C
.text$mn:00003D5C ; Attributes: bp-based frame
.text$mn:00003D5C
.text$mn:00003D5C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00003D5C                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00003D5C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00003D5C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00003D5C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:00003D5C
.text$mn:00003D5C var_4           = dword ptr -4
.text$mn:00003D5C
.text$mn:00003D5C                 push    ebp
.text$mn:00003D5D                 mov     ebp, esp
.text$mn:00003D5F                 push    ecx
.text$mn:00003D60                 mov     [ebp+var_4], ecx
.text$mn:00003D63                 mov     eax, [ebp+var_4]
.text$mn:00003D66                 mov     eax, [eax+14h]
.text$mn:00003D69                 mov     esp, ebp
.text$mn:00003D6B                 pop     ebp
.text$mn:00003D6C                 retn
.text$mn:00003D6C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00003D6C
.text$mn:00003D6C ; ---------------------------------------------------------------------------
.text$mn:00003D6D                 align 10h
.text$mn:00003D6D _text$mn        ends
.text$mn:00003D6D
.text$mn:00003D70 ; ===========================================================================
.text$mn:00003D70
.text$mn:00003D70 ; Segment type: Pure code
.text$mn:00003D70 ; Segment permissions: Read/Execute
.text$mn:00003D70 _text$mn        segment para public 'CODE' use32
.text$mn:00003D70                 assume cs:_text$mn
.text$mn:00003D70                 ;org 3D70h
.text$mn:00003D70 ; COMDAT (pick any)
.text$mn:00003D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D70
.text$mn:00003D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D70
.text$mn:00003D70 ; Attributes: bp-based frame
.text$mn:00003D70
.text$mn:00003D70 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00003D70                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00003D70 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00003D70                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_3640p
.text$mn:00003D70                 push    ebp
.text$mn:00003D71                 mov     ebp, esp
.text$mn:00003D73                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00003D78                 pop     ebp
.text$mn:00003D79                 retn
.text$mn:00003D79 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00003D79
.text$mn:00003D79 ; ---------------------------------------------------------------------------
.text$mn:00003D7A                 align 4
.text$mn:00003D7A _text$mn        ends
.text$mn:00003D7A
.text$mn:00003D7C ; ===========================================================================
.text$mn:00003D7C
.text$mn:00003D7C ; Segment type: Pure code
.text$mn:00003D7C ; Segment permissions: Read/Execute
.text$mn:00003D7C _text$mn        segment para public 'CODE' use32
.text$mn:00003D7C                 assume cs:_text$mn
.text$mn:00003D7C                 ;org 3D7Ch
.text$mn:00003D7C ; COMDAT (pick any)
.text$mn:00003D7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D7C
.text$mn:00003D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D7C
.text$mn:00003D7C ; Attributes: bp-based frame
.text$mn:00003D7C
.text$mn:00003D7C ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00003D7C                 public ?value@error_code@std@@QBEHXZ
.text$mn:00003D7C ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00003D7C
.text$mn:00003D7C var_4           = dword ptr -4
.text$mn:00003D7C
.text$mn:00003D7C                 push    ebp
.text$mn:00003D7D                 mov     ebp, esp
.text$mn:00003D7F                 push    ecx
.text$mn:00003D80                 mov     [ebp+var_4], ecx
.text$mn:00003D83                 mov     eax, [ebp+var_4]
.text$mn:00003D86                 mov     eax, [eax]
.text$mn:00003D88                 mov     esp, ebp
.text$mn:00003D8A                 pop     ebp
.text$mn:00003D8B                 retn
.text$mn:00003D8B ?value@error_code@std@@QBEHXZ endp
.text$mn:00003D8B
.text$mn:00003D8B _text$mn        ends
.text$mn:00003D8B
.text$mn:00003D8C ; ===========================================================================
.text$mn:00003D8C
.text$mn:00003D8C ; Segment type: Pure code
.text$mn:00003D8C ; Segment permissions: Read/Execute
.text$mn:00003D8C _text$mn        segment para public 'CODE' use32
.text$mn:00003D8C                 assume cs:_text$mn
.text$mn:00003D8C                 ;org 3D8Ch
.text$mn:00003D8C ; COMDAT (pick any)
.text$mn:00003D8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D8C
.text$mn:00003D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D8C
.text$mn:00003D8C ; Attributes: bp-based frame
.text$mn:00003D8C
.text$mn:00003D8C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00003D8C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00003D8C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00003D8C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00003D8C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00003D8C
.text$mn:00003D8C var_4           = dword ptr -4
.text$mn:00003D8C
.text$mn:00003D8C                 push    ebp
.text$mn:00003D8D                 mov     ebp, esp
.text$mn:00003D8F                 push    ecx
.text$mn:00003D90                 mov     [ebp+var_4], ecx
.text$mn:00003D93                 mov     eax, [ebp+var_4]
.text$mn:00003D96                 mov     eax, [eax]
.text$mn:00003D98                 mov     esp, ebp
.text$mn:00003D9A                 pop     ebp
.text$mn:00003D9B                 retn
.text$mn:00003D9B ?value@error_condition@std@@QBEHXZ endp
.text$mn:00003D9B
.text$mn:00003D9B _text$mn        ends
.text$mn:00003D9B
.text$mn:00003D9C ; ===========================================================================
.text$mn:00003D9C
.text$mn:00003D9C ; Segment type: Pure code
.text$mn:00003D9C ; Segment permissions: Read/Execute
.text$mn:00003D9C _text$mn        segment para public 'CODE' use32
.text$mn:00003D9C                 assume cs:_text$mn
.text$mn:00003D9C                 ;org 3D9Ch
.text$mn:00003D9C ; COMDAT (pick any)
.text$mn:00003D9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D9C
.text$mn:00003D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D9C
.text$mn:00003D9C ; Attributes: bp-based frame
.text$mn:00003D9C
.text$mn:00003D9C                 public _hypot
.text$mn:00003D9C _hypot          proc near
.text$mn:00003D9C
.text$mn:00003D9C var_10          = qword ptr -10h
.text$mn:00003D9C var_8           = qword ptr -8
.text$mn:00003D9C arg_0           = qword ptr  8
.text$mn:00003D9C arg_8           = qword ptr  10h
.text$mn:00003D9C
.text$mn:00003D9C                 push    ebp
.text$mn:00003D9D                 mov     ebp, esp
.text$mn:00003D9F                 sub     esp, 8
.text$mn:00003DA2                 movsd   xmm0, [ebp+arg_8]
.text$mn:00003DA7                 movsd   [esp+8+var_8], xmm0
.text$mn:00003DAC                 sub     esp, 8
.text$mn:00003DAF                 movsd   xmm0, [ebp+arg_0]
.text$mn:00003DB4                 movsd   [esp+10h+var_10], xmm0
.text$mn:00003DB9                 call    __hypot
.text$mn:00003DBE                 add     esp, 10h
.text$mn:00003DC1                 pop     ebp
.text$mn:00003DC2                 retn
.text$mn:00003DC2 _hypot          endp
.text$mn:00003DC2
.text$mn:00003DC2 ; ---------------------------------------------------------------------------
.text$mn:00003DC3                 align 4
.text$mn:00003DC3 _text$mn        ends
.text$mn:00003DC3
.text$mn:00003DC4 ; ===========================================================================
.text$mn:00003DC4
.text$mn:00003DC4 ; Segment type: Pure code
.text$mn:00003DC4 ; Segment permissions: Read/Execute
.text$mn:00003DC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DC4                 assume cs:_text$mn
.text$mn:00003DC4                 ;org 3DC4h
.text$mn:00003DC4 ; COMDAT (pick any)
.text$mn:00003DC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DC4
.text$mn:00003DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DC4
.text$mn:00003DC4 ; Attributes: bp-based frame
.text$mn:00003DC4
.text$mn:00003DC4 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00003DC4                 public _wmemcpy
.text$mn:00003DC4 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00003DC4
.text$mn:00003DC4 Dst             = dword ptr  8
.text$mn:00003DC4 Src             = dword ptr  0Ch
.text$mn:00003DC4 arg_8           = dword ptr  10h
.text$mn:00003DC4
.text$mn:00003DC4                 push    ebp
.text$mn:00003DC5                 mov     ebp, esp
.text$mn:00003DC7                 mov     eax, [ebp+arg_8]
.text$mn:00003DCA                 shl     eax, 1
.text$mn:00003DCC                 push    eax             ; Size
.text$mn:00003DCD                 mov     ecx, [ebp+Src]
.text$mn:00003DD0                 push    ecx             ; Src
.text$mn:00003DD1                 mov     edx, [ebp+Dst]
.text$mn:00003DD4                 push    edx             ; Dst
.text$mn:00003DD5                 call    _memcpy
.text$mn:00003DDA                 add     esp, 0Ch
.text$mn:00003DDD                 pop     ebp
.text$mn:00003DDE                 retn
.text$mn:00003DDE _wmemcpy        endp
.text$mn:00003DDE
.text$mn:00003DDE ; ---------------------------------------------------------------------------
.text$mn:00003DDF                 align 10h
.text$mn:00003DDF _text$mn        ends
.text$mn:00003DDF
.text$mn:00003DE0 ; ===========================================================================
.text$mn:00003DE0
.text$mn:00003DE0 ; Segment type: Pure code
.text$mn:00003DE0 ; Segment permissions: Read/Execute
.text$mn:00003DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DE0                 assume cs:_text$mn
.text$mn:00003DE0                 ;org 3DE0h
.text$mn:00003DE0 ; COMDAT (pick any)
.text$mn:00003DE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DE0
.text$mn:00003DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DE0
.text$mn:00003DE0 ; Attributes: bp-based frame
.text$mn:00003DE0
.text$mn:00003DE0 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00003DE0                 public _wmemmove
.text$mn:00003DE0 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00003DE0
.text$mn:00003DE0 Dst             = dword ptr  8
.text$mn:00003DE0 Src             = dword ptr  0Ch
.text$mn:00003DE0 arg_8           = dword ptr  10h
.text$mn:00003DE0
.text$mn:00003DE0                 push    ebp
.text$mn:00003DE1                 mov     ebp, esp
.text$mn:00003DE3                 mov     eax, [ebp+arg_8]
.text$mn:00003DE6                 shl     eax, 1
.text$mn:00003DE8                 push    eax             ; Size
.text$mn:00003DE9                 mov     ecx, [ebp+Src]
.text$mn:00003DEC                 push    ecx             ; Src
.text$mn:00003DED                 mov     edx, [ebp+Dst]
.text$mn:00003DF0                 push    edx             ; Dst
.text$mn:00003DF1                 call    _memmove
.text$mn:00003DF6                 add     esp, 0Ch
.text$mn:00003DF9                 pop     ebp
.text$mn:00003DFA                 retn
.text$mn:00003DFA _wmemmove       endp
.text$mn:00003DFA
.text$mn:00003DFA ; ---------------------------------------------------------------------------
.text$mn:00003DFB                 align 4
.text$mn:00003DFB _text$mn        ends
.text$mn:00003DFB
.xdata$x:00003DFC ; ===========================================================================
.xdata$x:00003DFC
.xdata$x:00003DFC ; Segment type: Pure data
.xdata$x:00003DFC ; Segment permissions: Read
.xdata$x:00003DFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003DFC                 assume cs:_xdata$x
.xdata$x:00003DFC                 ;org 3DFCh
.xdata$x:00003DFC __unwindtable$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z db 0FFh
.xdata$x:00003DFC                                         ; DATA XREF: .xdata$x:00003E0Co
.xdata$x:00003DFD                 db 0FFh
.xdata$x:00003DFE                 db 0FFh
.xdata$x:00003DFF                 db 0FFh
.xdata$x:00003E00                 dd offset __unwindfunclet$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z$0
.xdata$x:00003E04 __ehfuncinfo$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z db  22h ; "
.xdata$x:00003E04                                         ; DATA XREF: __ehhandler$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z+1Eo
.xdata$x:00003E05                 db    5
.xdata$x:00003E06                 db  93h ; ô
.xdata$x:00003E07                 db  19h
.xdata$x:00003E08                 db    1
.xdata$x:00003E09                 db    0
.xdata$x:00003E0A                 db    0
.xdata$x:00003E0B                 db    0
.xdata$x:00003E0C                 dd offset __unwindtable$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z
.xdata$x:00003E10                 db    0
.xdata$x:00003E11                 db    0
.xdata$x:00003E12                 db    0
.xdata$x:00003E13                 db    0
.xdata$x:00003E14                 db    0
.xdata$x:00003E15                 db    0
.xdata$x:00003E16                 db    0
.xdata$x:00003E17                 db    0
.xdata$x:00003E18                 db    0
.xdata$x:00003E19                 db    0
.xdata$x:00003E1A                 db    0
.xdata$x:00003E1B                 db    0
.xdata$x:00003E1C                 db    0
.xdata$x:00003E1D                 db    0
.xdata$x:00003E1E                 db    0
.xdata$x:00003E1F                 db    0
.xdata$x:00003E20                 db    0
.xdata$x:00003E21                 db    0
.xdata$x:00003E22                 db    0
.xdata$x:00003E23                 db    0
.xdata$x:00003E24                 db    0
.xdata$x:00003E25                 db    0
.xdata$x:00003E26                 db    0
.xdata$x:00003E27                 db    0
.xdata$x:00003E27 _xdata$x        ends
.xdata$x:00003E27
.xdata$x:00003E28 ; ===========================================================================
.xdata$x:00003E28
.xdata$x:00003E28 ; Segment type: Pure data
.xdata$x:00003E28 ; Segment permissions: Read
.xdata$x:00003E28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003E28                 assume cs:_xdata$x
.xdata$x:00003E28                 ;org 3E28h
.xdata$x:00003E28 ; COMDAT (pick associative to section at 2E84)
.xdata$x:00003E28 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00003E28                                         ; DATA XREF: .xdata$x:00003E38o
.xdata$x:00003E29                 db 0FFh
.xdata$x:00003E2A                 db 0FFh
.xdata$x:00003E2B                 db 0FFh
.xdata$x:00003E2C                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00003E30 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00003E30                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00003E31                 db    5
.xdata$x:00003E32                 db  93h ; ô
.xdata$x:00003E33                 db  19h
.xdata$x:00003E34                 db    1
.xdata$x:00003E35                 db    0
.xdata$x:00003E36                 db    0
.xdata$x:00003E37                 db    0
.xdata$x:00003E38                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00003E3C                 db    0
.xdata$x:00003E3D                 db    0
.xdata$x:00003E3E                 db    0
.xdata$x:00003E3F                 db    0
.xdata$x:00003E40                 db    0
.xdata$x:00003E41                 db    0
.xdata$x:00003E42                 db    0
.xdata$x:00003E43                 db    0
.xdata$x:00003E44                 db    0
.xdata$x:00003E45                 db    0
.xdata$x:00003E46                 db    0
.xdata$x:00003E47                 db    0
.xdata$x:00003E48                 db    0
.xdata$x:00003E49                 db    0
.xdata$x:00003E4A                 db    0
.xdata$x:00003E4B                 db    0
.xdata$x:00003E4C                 db    0
.xdata$x:00003E4D                 db    0
.xdata$x:00003E4E                 db    0
.xdata$x:00003E4F                 db    0
.xdata$x:00003E50                 db    0
.xdata$x:00003E51                 db    0
.xdata$x:00003E52                 db    0
.xdata$x:00003E53                 db    0
.xdata$x:00003E53 _xdata$x        ends
.xdata$x:00003E53
.xdata$x:00003E54 ; ===========================================================================
.xdata$x:00003E54
.xdata$x:00003E54 ; Segment type: Pure data
.xdata$x:00003E54 ; Segment permissions: Read
.xdata$x:00003E54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003E54                 assume cs:_xdata$x
.xdata$x:00003E54                 ;org 3E54h
.xdata$x:00003E54 ; COMDAT (pick associative to section at 18CC)
.xdata$x:00003E54 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003E54                                         ; DATA XREF: .xdata$x:00003E64o
.xdata$x:00003E55                 db 0FFh
.xdata$x:00003E56                 db 0FFh
.xdata$x:00003E57                 db 0FFh
.xdata$x:00003E58                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00003E5C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003E5C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00003E5D                 db    5
.xdata$x:00003E5E                 db  93h ; ô
.xdata$x:00003E5F                 db  19h
.xdata$x:00003E60                 db    1
.xdata$x:00003E61                 db    0
.xdata$x:00003E62                 db    0
.xdata$x:00003E63                 db    0
.xdata$x:00003E64                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003E68                 align 20h
.xdata$x:00003E68 _xdata$x        ends
.xdata$x:00003E68
.xdata$x:00003E80 ; ===========================================================================
.xdata$x:00003E80
.xdata$x:00003E80 ; Segment type: Pure data
.xdata$x:00003E80 ; Segment permissions: Read
.xdata$x:00003E80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003E80                 assume cs:_xdata$x
.xdata$x:00003E80                 ;org 3E80h
.xdata$x:00003E80 ; COMDAT (pick associative to section at 2030)
.xdata$x:00003E80 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003E80                                         ; DATA XREF: .xdata$x:00003E90o
.xdata$x:00003E81                 db 0FFh
.xdata$x:00003E82                 db 0FFh
.xdata$x:00003E83                 db 0FFh
.xdata$x:00003E84                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00003E88 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003E88                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00003E89                 db    5
.xdata$x:00003E8A                 db  93h ; ô
.xdata$x:00003E8B                 db  19h
.xdata$x:00003E8C                 db    1
.xdata$x:00003E8D                 db    0
.xdata$x:00003E8E                 db    0
.xdata$x:00003E8F                 db    0
.xdata$x:00003E90                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003E94                 db    0
.xdata$x:00003E95                 db    0
.xdata$x:00003E96                 db    0
.xdata$x:00003E97                 db    0
.xdata$x:00003E98                 db    0
.xdata$x:00003E99                 db    0
.xdata$x:00003E9A                 db    0
.xdata$x:00003E9B                 db    0
.xdata$x:00003E9C                 db    0
.xdata$x:00003E9D                 db    0
.xdata$x:00003E9E                 db    0
.xdata$x:00003E9F                 db    0
.xdata$x:00003EA0                 db    0
.xdata$x:00003EA1                 db    0
.xdata$x:00003EA2                 db    0
.xdata$x:00003EA3                 db    0
.xdata$x:00003EA4                 db    0
.xdata$x:00003EA5                 db    0
.xdata$x:00003EA6                 db    0
.xdata$x:00003EA7                 db    0
.xdata$x:00003EA8                 db    0
.xdata$x:00003EA9                 db    0
.xdata$x:00003EAA                 db    0
.xdata$x:00003EAB                 db    0
.xdata$x:00003EAB _xdata$x        ends
.xdata$x:00003EAB
.xdata$x:00003EAC ; ===========================================================================
.xdata$x:00003EAC
.xdata$x:00003EAC ; Segment type: Pure data
.xdata$x:00003EAC ; Segment permissions: Read
.xdata$x:00003EAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003EAC                 assume cs:_xdata$x
.xdata$x:00003EAC                 ;org 3EACh
.xdata$x:00003EAC ; COMDAT (pick associative to section at 17D4)
.xdata$x:00003EAC __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00003EAC                                         ; DATA XREF: .xdata$x:00003EBCo
.xdata$x:00003EAD                 db 0FFh
.xdata$x:00003EAE                 db 0FFh
.xdata$x:00003EAF                 db 0FFh
.xdata$x:00003EB0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00003EB4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00003EB4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00003EB5                 db    5
.xdata$x:00003EB6                 db  93h ; ô
.xdata$x:00003EB7                 db  19h
.xdata$x:00003EB8                 db    1
.xdata$x:00003EB9                 db    0
.xdata$x:00003EBA                 db    0
.xdata$x:00003EBB                 db    0
.xdata$x:00003EBC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00003EC0                 db    0
.xdata$x:00003EC1                 db    0
.xdata$x:00003EC2                 db    0
.xdata$x:00003EC3                 db    0
.xdata$x:00003EC4                 db    0
.xdata$x:00003EC5                 db    0
.xdata$x:00003EC6                 db    0
.xdata$x:00003EC7                 db    0
.xdata$x:00003EC8                 db    0
.xdata$x:00003EC9                 db    0
.xdata$x:00003ECA                 db    0
.xdata$x:00003ECB                 db    0
.xdata$x:00003ECC                 db    0
.xdata$x:00003ECD                 db    0
.xdata$x:00003ECE                 db    0
.xdata$x:00003ECF                 db    0
.xdata$x:00003ED0                 db    0
.xdata$x:00003ED1                 db    0
.xdata$x:00003ED2                 db    0
.xdata$x:00003ED3                 db    0
.xdata$x:00003ED4                 db    0
.xdata$x:00003ED5                 db    0
.xdata$x:00003ED6                 db    0
.xdata$x:00003ED7                 db    0
.xdata$x:00003ED7 _xdata$x        ends
.xdata$x:00003ED7
.xdata$x:00003ED8 ; ===========================================================================
.xdata$x:00003ED8
.xdata$x:00003ED8 ; Segment type: Pure data
.xdata$x:00003ED8 ; Segment permissions: Read
.xdata$x:00003ED8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003ED8                 assume cs:_xdata$x
.xdata$x:00003ED8                 ;org 3ED8h
.xdata$x:00003ED8 ; COMDAT (pick associative to section at 1F40)
.xdata$x:00003ED8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003ED8                                         ; DATA XREF: .xdata$x:00003EE8o
.xdata$x:00003ED9                 db 0FFh
.xdata$x:00003EDA                 db 0FFh
.xdata$x:00003EDB                 db 0FFh
.xdata$x:00003EDC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00003EE0 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003EE0                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00003EE1                 db    5
.xdata$x:00003EE2                 db  93h ; ô
.xdata$x:00003EE3                 db  19h
.xdata$x:00003EE4                 db    1
.xdata$x:00003EE5                 db    0
.xdata$x:00003EE6                 db    0
.xdata$x:00003EE7                 db    0
.xdata$x:00003EE8                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00003EEC                 db    0
.xdata$x:00003EED                 db    0
.xdata$x:00003EEE                 db    0
.xdata$x:00003EEF                 db    0
.xdata$x:00003EF0                 db    0
.xdata$x:00003EF1                 db    0
.xdata$x:00003EF2                 db    0
.xdata$x:00003EF3                 db    0
.xdata$x:00003EF4                 db    0
.xdata$x:00003EF5                 db    0
.xdata$x:00003EF6                 db    0
.xdata$x:00003EF7                 db    0
.xdata$x:00003EF8                 db    0
.xdata$x:00003EF9                 db    0
.xdata$x:00003EFA                 db    0
.xdata$x:00003EFB                 db    0
.xdata$x:00003EFC                 db    0
.xdata$x:00003EFD                 db    0
.xdata$x:00003EFE                 db    0
.xdata$x:00003EFF                 db    0
.xdata$x:00003F00                 db    0
.xdata$x:00003F01                 db    0
.xdata$x:00003F02                 db    0
.xdata$x:00003F03                 db    0
.xdata$x:00003F03 _xdata$x        ends
.xdata$x:00003F03
.xdata$x:00003F04 ; ===========================================================================
.xdata$x:00003F04
.xdata$x:00003F04 ; Segment type: Pure data
.xdata$x:00003F04 ; Segment permissions: Read
.xdata$x:00003F04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003F04                 assume cs:_xdata$x
.xdata$x:00003F04                 ;org 3F04h
.xdata$x:00003F04 ; COMDAT (pick associative to section at 1A3C)
.xdata$x:00003F04 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00003F04                                         ; DATA XREF: .xdata$x:00003F14o
.xdata$x:00003F05                 db 0FFh
.xdata$x:00003F06                 db 0FFh
.xdata$x:00003F07                 db 0FFh
.xdata$x:00003F08                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00003F0C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00003F0C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00003F0D                 db    5
.xdata$x:00003F0E                 db  93h ; ô
.xdata$x:00003F0F                 db  19h
.xdata$x:00003F10                 db    1
.xdata$x:00003F11                 db    0
.xdata$x:00003F12                 db    0
.xdata$x:00003F13                 db    0
.xdata$x:00003F14                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00003F18                 db    0
.xdata$x:00003F19                 db    0
.xdata$x:00003F1A                 db    0
.xdata$x:00003F1B                 db    0
.xdata$x:00003F1C                 db    0
.xdata$x:00003F1D                 db    0
.xdata$x:00003F1E                 db    0
.xdata$x:00003F1F                 db    0
.xdata$x:00003F20                 db    0
.xdata$x:00003F21                 db    0
.xdata$x:00003F22                 db    0
.xdata$x:00003F23                 db    0
.xdata$x:00003F24                 db    0
.xdata$x:00003F25                 db    0
.xdata$x:00003F26                 db    0
.xdata$x:00003F27                 db    0
.xdata$x:00003F28                 db    0
.xdata$x:00003F29                 db    0
.xdata$x:00003F2A                 db    0
.xdata$x:00003F2B                 db    0
.xdata$x:00003F2C                 db    0
.xdata$x:00003F2D                 db    0
.xdata$x:00003F2E                 db    0
.xdata$x:00003F2F                 db    0
.xdata$x:00003F2F _xdata$x        ends
.xdata$x:00003F2F
.xdata$x:00003F30 ; ===========================================================================
.xdata$x:00003F30
.xdata$x:00003F30 ; Segment type: Pure data
.xdata$x:00003F30 ; Segment permissions: Read
.xdata$x:00003F30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003F30                 assume cs:_xdata$x
.xdata$x:00003F30                 ;org 3F30h
.xdata$x:00003F30 ; COMDAT (pick associative to section at 2110)
.xdata$x:00003F30 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00003F30                                         ; DATA XREF: .xdata$x:00003F40o
.xdata$x:00003F31                 db 0FFh
.xdata$x:00003F32                 db 0FFh
.xdata$x:00003F33                 db 0FFh
.xdata$x:00003F34                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00003F38 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00003F38                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00003F39                 db    5
.xdata$x:00003F3A                 db  93h ; ô
.xdata$x:00003F3B                 db  19h
.xdata$x:00003F3C                 db    1
.xdata$x:00003F3D                 db    0
.xdata$x:00003F3E                 db    0
.xdata$x:00003F3F                 db    0
.xdata$x:00003F40                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00003F44                 db    0
.xdata$x:00003F45                 db    0
.xdata$x:00003F46                 db    0
.xdata$x:00003F47                 db    0
.xdata$x:00003F48                 db    0
.xdata$x:00003F49                 db    0
.xdata$x:00003F4A                 db    0
.xdata$x:00003F4B                 db    0
.xdata$x:00003F4C                 db    0
.xdata$x:00003F4D                 db    0
.xdata$x:00003F4E                 db    0
.xdata$x:00003F4F                 db    0
.xdata$x:00003F50                 db    0
.xdata$x:00003F51                 db    0
.xdata$x:00003F52                 db    0
.xdata$x:00003F53                 db    0
.xdata$x:00003F54                 db    0
.xdata$x:00003F55                 db    0
.xdata$x:00003F56                 db    0
.xdata$x:00003F57                 db    0
.xdata$x:00003F58                 db    0
.xdata$x:00003F59                 db    0
.xdata$x:00003F5A                 db    0
.xdata$x:00003F5B                 db    0
.xdata$x:00003F5B _xdata$x        ends
.xdata$x:00003F5B
.xdata$x:00003F5C ; ===========================================================================
.xdata$x:00003F5C
.xdata$x:00003F5C ; Segment type: Pure data
.xdata$x:00003F5C ; Segment permissions: Read
.xdata$x:00003F5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003F5C                 assume cs:_xdata$x
.xdata$x:00003F5C                 ;org 3F5Ch
.xdata$x:00003F5C ; COMDAT (pick associative to section at 2730)
.xdata$x:00003F5C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00003F5C                                         ; DATA XREF: .xdata$x:00003FE4o
.xdata$x:00003F5D                 db    0
.xdata$x:00003F5E                 db    0
.xdata$x:00003F5F                 db    0
.xdata$x:00003F60                 db    0
.xdata$x:00003F61                 db    0
.xdata$x:00003F62                 db    0
.xdata$x:00003F63                 db    0
.xdata$x:00003F64                 db    0
.xdata$x:00003F65                 db    0
.xdata$x:00003F66                 db    0
.xdata$x:00003F67                 db    0
.xdata$x:00003F68                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00003F6C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00003F6C                                         ; DATA XREF: .xdata$x:00003FD0o
.xdata$x:00003F6D                 db    0
.xdata$x:00003F6E                 db    0
.xdata$x:00003F6F                 db    0
.xdata$x:00003F70                 db    0
.xdata$x:00003F71                 db    0
.xdata$x:00003F72                 db    0
.xdata$x:00003F73                 db    0
.xdata$x:00003F74                 db    0
.xdata$x:00003F75                 db    0
.xdata$x:00003F76                 db    0
.xdata$x:00003F77                 db    0
.xdata$x:00003F78                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00003F7C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00003F7C                                         ; DATA XREF: .xdata$x:00003FA4o
.xdata$x:00003F7D                 db 0FFh
.xdata$x:00003F7E                 db 0FFh
.xdata$x:00003F7F                 db 0FFh
.xdata$x:00003F80                 db    0
.xdata$x:00003F81                 db    0
.xdata$x:00003F82                 db    0
.xdata$x:00003F83                 db    0
.xdata$x:00003F84                 db 0FFh
.xdata$x:00003F85                 db 0FFh
.xdata$x:00003F86                 db 0FFh
.xdata$x:00003F87                 db 0FFh
.xdata$x:00003F88                 db    0
.xdata$x:00003F89                 db    0
.xdata$x:00003F8A                 db    0
.xdata$x:00003F8B                 db    0
.xdata$x:00003F8C                 db    1
.xdata$x:00003F8D                 db    0
.xdata$x:00003F8E                 db    0
.xdata$x:00003F8F                 db    0
.xdata$x:00003F90                 db    0
.xdata$x:00003F91                 db    0
.xdata$x:00003F92                 db    0
.xdata$x:00003F93                 db    0
.xdata$x:00003F94                 db    1
.xdata$x:00003F95                 db    0
.xdata$x:00003F96                 db    0
.xdata$x:00003F97                 db    0
.xdata$x:00003F98                 db    0
.xdata$x:00003F99                 db    0
.xdata$x:00003F9A                 db    0
.xdata$x:00003F9B                 db    0
.xdata$x:00003F9C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00003F9C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00003F9D                 db    5
.xdata$x:00003F9E                 db  93h ; ô
.xdata$x:00003F9F                 db  19h
.xdata$x:00003FA0                 db    4
.xdata$x:00003FA1                 db    0
.xdata$x:00003FA2                 db    0
.xdata$x:00003FA3                 db    0
.xdata$x:00003FA4                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00003FA8                 db    2
.xdata$x:00003FA9                 db    0
.xdata$x:00003FAA                 db    0
.xdata$x:00003FAB                 db    0
.xdata$x:00003FAC                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00003FB0                 align 20h
.xdata$x:00003FC0 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00003FC0                                         ; DATA XREF: .xdata$x:00003FACo
.xdata$x:00003FC1                 db    0
.xdata$x:00003FC2                 db    0
.xdata$x:00003FC3                 db    0
.xdata$x:00003FC4                 db    2
.xdata$x:00003FC5                 db    0
.xdata$x:00003FC6                 db    0
.xdata$x:00003FC7                 db    0
.xdata$x:00003FC8                 db    3
.xdata$x:00003FC9                 db    0
.xdata$x:00003FCA                 db    0
.xdata$x:00003FCB                 db    0
.xdata$x:00003FCC                 db    1
.xdata$x:00003FCD                 db    0
.xdata$x:00003FCE                 db    0
.xdata$x:00003FCF                 db    0
.xdata$x:00003FD0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00003FD4                 db    0
.xdata$x:00003FD5                 db    0
.xdata$x:00003FD6                 db    0
.xdata$x:00003FD7                 db    0
.xdata$x:00003FD8                 db    0
.xdata$x:00003FD9                 db    0
.xdata$x:00003FDA                 db    0
.xdata$x:00003FDB                 db    0
.xdata$x:00003FDC                 db    3
.xdata$x:00003FDD                 db    0
.xdata$x:00003FDE                 db    0
.xdata$x:00003FDF                 db    0
.xdata$x:00003FE0                 db    1
.xdata$x:00003FE1                 db    0
.xdata$x:00003FE2                 db    0
.xdata$x:00003FE3                 db    0
.xdata$x:00003FE4                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00003FE4 _xdata$x        ends
.xdata$x:00003FE4
.xdata$x:00003FE8 ; ===========================================================================
.xdata$x:00003FE8
.xdata$x:00003FE8 ; Segment type: Pure data
.xdata$x:00003FE8 ; Segment permissions: Read
.xdata$x:00003FE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003FE8                 assume cs:_xdata$x
.xdata$x:00003FE8                 ;org 3FE8h
.xdata$x:00003FE8 ; COMDAT (pick associative to section at 1D68)
.xdata$x:00003FE8 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003FE8                                         ; DATA XREF: .xdata$x:00003FF8o
.xdata$x:00003FE9                 db 0FFh
.xdata$x:00003FEA                 db 0FFh
.xdata$x:00003FEB                 db 0FFh
.xdata$x:00003FEC                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00003FF0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003FF0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00003FF1                 db    5
.xdata$x:00003FF2                 db  93h ; ô
.xdata$x:00003FF3                 db  19h
.xdata$x:00003FF4                 db    1
.xdata$x:00003FF5                 db    0
.xdata$x:00003FF6                 db    0
.xdata$x:00003FF7                 db    0
.xdata$x:00003FF8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00003FFC                 db    0
.xdata$x:00003FFD                 db    0
.xdata$x:00003FFE                 db    0
.xdata$x:00003FFF                 db    0
.xdata$x:00004000                 db    0
.xdata$x:00004001                 db    0
.xdata$x:00004002                 db    0
.xdata$x:00004003                 db    0
.xdata$x:00004004                 db    0
.xdata$x:00004005                 db    0
.xdata$x:00004006                 db    0
.xdata$x:00004007                 db    0
.xdata$x:00004008                 db    0
.xdata$x:00004009                 db    0
.xdata$x:0000400A                 db    0
.xdata$x:0000400B                 db    0
.xdata$x:0000400C                 db    0
.xdata$x:0000400D                 db    0
.xdata$x:0000400E                 db    0
.xdata$x:0000400F                 db    0
.xdata$x:00004010                 db    0
.xdata$x:00004011                 db    0
.xdata$x:00004012                 db    0
.xdata$x:00004013                 db    0
.xdata$x:00004013 _xdata$x        ends
.xdata$x:00004013
.xdata$x:00004014 ; ===========================================================================
.xdata$x:00004014
.xdata$x:00004014 ; Segment type: Pure data
.xdata$x:00004014 ; Segment permissions: Read
.xdata$x:00004014 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004014                 assume cs:_xdata$x
.xdata$x:00004014                 ;org 4014h
.xdata$x:00004014 ; COMDAT (pick associative to section at 3A84)
.xdata$x:00004014 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004014                                         ; DATA XREF: .xdata$x:00004024o
.xdata$x:00004015                 db 0FFh
.xdata$x:00004016                 db 0FFh
.xdata$x:00004017                 db 0FFh
.xdata$x:00004018                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000401C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000401C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000401D                 db    5
.xdata$x:0000401E                 db  93h ; ô
.xdata$x:0000401F                 db  19h
.xdata$x:00004020                 db    1
.xdata$x:00004021                 db    0
.xdata$x:00004022                 db    0
.xdata$x:00004023                 db    0
.xdata$x:00004024                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004028                 align 20h
.xdata$x:00004028 _xdata$x        ends
.xdata$x:00004028
.xdata$x:00004040 ; ===========================================================================
.xdata$x:00004040
.xdata$x:00004040 ; Segment type: Pure data
.xdata$x:00004040 ; Segment permissions: Read
.xdata$x:00004040 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004040                 assume cs:_xdata$x
.xdata$x:00004040                 ;org 4040h
.xdata$x:00004040 ; COMDAT (pick associative to section at 22E0)
.xdata$x:00004040 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00004040                                         ; DATA XREF: .xdata$x:00004050o
.xdata$x:00004041                 db 0FFh
.xdata$x:00004042                 db 0FFh
.xdata$x:00004043                 db 0FFh
.xdata$x:00004044                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00004048 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00004048                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00004049                 db    5
.xdata$x:0000404A                 db  93h ; ô
.xdata$x:0000404B                 db  19h
.xdata$x:0000404C                 db    1
.xdata$x:0000404D                 db    0
.xdata$x:0000404E                 db    0
.xdata$x:0000404F                 db    0
.xdata$x:00004050                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00004054                 db    0
.xdata$x:00004055                 db    0
.xdata$x:00004056                 db    0
.xdata$x:00004057                 db    0
.xdata$x:00004058                 db    0
.xdata$x:00004059                 db    0
.xdata$x:0000405A                 db    0
.xdata$x:0000405B                 db    0
.xdata$x:0000405C                 db    0
.xdata$x:0000405D                 db    0
.xdata$x:0000405E                 db    0
.xdata$x:0000405F                 db    0
.xdata$x:00004060                 db    0
.xdata$x:00004061                 db    0
.xdata$x:00004062                 db    0
.xdata$x:00004063                 db    0
.xdata$x:00004064                 db    0
.xdata$x:00004065                 db    0
.xdata$x:00004066                 db    0
.xdata$x:00004067                 db    0
.xdata$x:00004068                 db    0
.xdata$x:00004069                 db    0
.xdata$x:0000406A                 db    0
.xdata$x:0000406B                 db    0
.xdata$x:0000406B _xdata$x        ends
.xdata$x:0000406B
.xdata$x:0000406C ; ===========================================================================
.xdata$x:0000406C
.xdata$x:0000406C ; Segment type: Pure data
.xdata$x:0000406C ; Segment permissions: Read
.xdata$x:0000406C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000406C                 assume cs:_xdata$x
.xdata$x:0000406C                 ;org 406Ch
.xdata$x:0000406C ; COMDAT (pick associative to section at 1DF4)
.xdata$x:0000406C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000406C                                         ; DATA XREF: .xdata$x:0000407Co
.xdata$x:0000406D                 db 0FFh
.xdata$x:0000406E                 db 0FFh
.xdata$x:0000406F                 db 0FFh
.xdata$x:00004070                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00004074 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00004074                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00004075                 db    5
.xdata$x:00004076                 db  93h ; ô
.xdata$x:00004077                 db  19h
.xdata$x:00004078                 db    1
.xdata$x:00004079                 db    0
.xdata$x:0000407A                 db    0
.xdata$x:0000407B                 db    0
.xdata$x:0000407C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00004080                 db    0
.xdata$x:00004081                 db    0
.xdata$x:00004082                 db    0
.xdata$x:00004083                 db    0
.xdata$x:00004084                 db    0
.xdata$x:00004085                 db    0
.xdata$x:00004086                 db    0
.xdata$x:00004087                 db    0
.xdata$x:00004088                 db    0
.xdata$x:00004089                 db    0
.xdata$x:0000408A                 db    0
.xdata$x:0000408B                 db    0
.xdata$x:0000408C                 db    0
.xdata$x:0000408D                 db    0
.xdata$x:0000408E                 db    0
.xdata$x:0000408F                 db    0
.xdata$x:00004090                 db    0
.xdata$x:00004091                 db    0
.xdata$x:00004092                 db    0
.xdata$x:00004093                 db    0
.xdata$x:00004094                 db    0
.xdata$x:00004095                 db    0
.xdata$x:00004096                 db    0
.xdata$x:00004097                 db    0
.xdata$x:00004097 _xdata$x        ends
.xdata$x:00004097
.xdata$x:00004098 ; ===========================================================================
.xdata$x:00004098
.xdata$x:00004098 ; Segment type: Pure data
.xdata$x:00004098 ; Segment permissions: Read
.xdata$x:00004098 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004098                 assume cs:_xdata$x
.xdata$x:00004098                 ;org 4098h
.xdata$x:00004098 ; COMDAT (pick associative to section at 3B3C)
.xdata$x:00004098 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004098                                         ; DATA XREF: .xdata$x:000040A8o
.xdata$x:00004099                 db 0FFh
.xdata$x:0000409A                 db 0FFh
.xdata$x:0000409B                 db 0FFh
.xdata$x:0000409C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000040A0 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000040A0                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000040A1                 db    5
.xdata$x:000040A2                 db  93h ; ô
.xdata$x:000040A3                 db  19h
.xdata$x:000040A4                 db    1
.xdata$x:000040A5                 db    0
.xdata$x:000040A6                 db    0
.xdata$x:000040A7                 db    0
.xdata$x:000040A8                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000040AC                 db    0
.xdata$x:000040AD                 db    0
.xdata$x:000040AE                 db    0
.xdata$x:000040AF                 db    0
.xdata$x:000040B0                 db    0
.xdata$x:000040B1                 db    0
.xdata$x:000040B2                 db    0
.xdata$x:000040B3                 db    0
.xdata$x:000040B4                 db    0
.xdata$x:000040B5                 db    0
.xdata$x:000040B6                 db    0
.xdata$x:000040B7                 db    0
.xdata$x:000040B8                 db    0
.xdata$x:000040B9                 db    0
.xdata$x:000040BA                 db    0
.xdata$x:000040BB                 db    0
.xdata$x:000040BC                 db    0
.xdata$x:000040BD                 db    0
.xdata$x:000040BE                 db    0
.xdata$x:000040BF                 db    0
.xdata$x:000040C0                 db    0
.xdata$x:000040C1                 db    0
.xdata$x:000040C2                 db    0
.xdata$x:000040C3                 db    0
.xdata$x:000040C3 _xdata$x        ends
.xdata$x:000040C3
.xdata$x:000040C4 ; ===========================================================================
.xdata$x:000040C4
.xdata$x:000040C4 ; Segment type: Pure data
.xdata$x:000040C4 ; Segment permissions: Read
.xdata$x:000040C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000040C4                 assume cs:_xdata$x
.xdata$x:000040C4                 ;org 40C4h
.xdata$x:000040C4 ; COMDAT (pick associative to section at 2350)
.xdata$x:000040C4 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000040C4                                         ; DATA XREF: .xdata$x:000040D4o
.xdata$x:000040C5                 db 0FFh
.xdata$x:000040C6                 db 0FFh
.xdata$x:000040C7                 db 0FFh
.xdata$x:000040C8                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000040CC __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000040CC                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000040CD                 db    5
.xdata$x:000040CE                 db  93h ; ô
.xdata$x:000040CF                 db  19h
.xdata$x:000040D0                 db    1
.xdata$x:000040D1                 db    0
.xdata$x:000040D2                 db    0
.xdata$x:000040D3                 db    0
.xdata$x:000040D4                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000040D8                 db    0
.xdata$x:000040D9                 db    0
.xdata$x:000040DA                 db    0
.xdata$x:000040DB                 db    0
.xdata$x:000040DC                 db    0
.xdata$x:000040DD                 db    0
.xdata$x:000040DE                 db    0
.xdata$x:000040DF                 db    0
.xdata$x:000040E0                 db    0
.xdata$x:000040E1                 db    0
.xdata$x:000040E2                 db    0
.xdata$x:000040E3                 db    0
.xdata$x:000040E4                 db    0
.xdata$x:000040E5                 db    0
.xdata$x:000040E6                 db    0
.xdata$x:000040E7                 db    0
.xdata$x:000040E8                 db    0
.xdata$x:000040E9                 db    0
.xdata$x:000040EA                 db    0
.xdata$x:000040EB                 db    0
.xdata$x:000040EC                 db    0
.xdata$x:000040ED                 db    0
.xdata$x:000040EE                 db    0
.xdata$x:000040EF                 db    0
.xdata$x:000040EF _xdata$x        ends
.xdata$x:000040EF
.xdata$x:000040F0 ; ===========================================================================
.xdata$x:000040F0
.xdata$x:000040F0 ; Segment type: Pure data
.xdata$x:000040F0 ; Segment permissions: Read
.xdata$x:000040F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000040F0                 assume cs:_xdata$x
.xdata$x:000040F0                 ;org 40F0h
.xdata$x:000040F0 ; COMDAT (pick associative to section at 1E70)
.xdata$x:000040F0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000040F0                                         ; DATA XREF: .xdata$x:00004100o
.xdata$x:000040F1                 db 0FFh
.xdata$x:000040F2                 db 0FFh
.xdata$x:000040F3                 db 0FFh
.xdata$x:000040F4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000040F8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000040F8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000040F9                 db    5
.xdata$x:000040FA                 db  93h ; ô
.xdata$x:000040FB                 db  19h
.xdata$x:000040FC                 db    1
.xdata$x:000040FD                 db    0
.xdata$x:000040FE                 db    0
.xdata$x:000040FF                 db    0
.xdata$x:00004100                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00004104                 db    0
.xdata$x:00004105                 db    0
.xdata$x:00004106                 db    0
.xdata$x:00004107                 db    0
.xdata$x:00004108                 db    0
.xdata$x:00004109                 db    0
.xdata$x:0000410A                 db    0
.xdata$x:0000410B                 db    0
.xdata$x:0000410C                 db    0
.xdata$x:0000410D                 db    0
.xdata$x:0000410E                 db    0
.xdata$x:0000410F                 db    0
.xdata$x:00004110                 db    0
.xdata$x:00004111                 db    0
.xdata$x:00004112                 db    0
.xdata$x:00004113                 db    0
.xdata$x:00004114                 db    0
.xdata$x:00004115                 db    0
.xdata$x:00004116                 db    0
.xdata$x:00004117                 db    0
.xdata$x:00004118                 db    0
.xdata$x:00004119                 db    0
.xdata$x:0000411A                 db    0
.xdata$x:0000411B                 db    0
.xdata$x:0000411B _xdata$x        ends
.xdata$x:0000411B
.xdata$x:0000411C ; ===========================================================================
.xdata$x:0000411C
.xdata$x:0000411C ; Segment type: Pure data
.xdata$x:0000411C ; Segment permissions: Read
.xdata$x:0000411C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000411C                 assume cs:_xdata$x
.xdata$x:0000411C                 ;org 411Ch
.xdata$x:0000411C ; COMDAT (pick associative to section at 3C00)
.xdata$x:0000411C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000411C                                         ; DATA XREF: .xdata$x:0000412Co
.xdata$x:0000411D                 db 0FFh
.xdata$x:0000411E                 db 0FFh
.xdata$x:0000411F                 db 0FFh
.xdata$x:00004120                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00004124 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00004124                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00004125                 db    5
.xdata$x:00004126                 db  93h ; ô
.xdata$x:00004127                 db  19h
.xdata$x:00004128                 db    1
.xdata$x:00004129                 db    0
.xdata$x:0000412A                 db    0
.xdata$x:0000412B                 db    0
.xdata$x:0000412C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004130                 db    0
.xdata$x:00004131                 db    0
.xdata$x:00004132                 db    0
.xdata$x:00004133                 db    0
.xdata$x:00004134                 db    0
.xdata$x:00004135                 db    0
.xdata$x:00004136                 db    0
.xdata$x:00004137                 db    0
.xdata$x:00004138                 db    0
.xdata$x:00004139                 db    0
.xdata$x:0000413A                 db    0
.xdata$x:0000413B                 db    0
.xdata$x:0000413C                 db    0
.xdata$x:0000413D                 db    0
.xdata$x:0000413E                 db    0
.xdata$x:0000413F                 db    0
.xdata$x:00004140                 db    0
.xdata$x:00004141                 db    0
.xdata$x:00004142                 db    0
.xdata$x:00004143                 db    0
.xdata$x:00004144                 db    0
.xdata$x:00004145                 db    0
.xdata$x:00004146                 db    0
.xdata$x:00004147                 db    0
.xdata$x:00004147 _xdata$x        ends
.xdata$x:00004147
.xdata$x:00004148 ; ===========================================================================
.xdata$x:00004148
.xdata$x:00004148 ; Segment type: Pure data
.xdata$x:00004148 ; Segment permissions: Read
.xdata$x:00004148 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004148                 assume cs:_xdata$x
.xdata$x:00004148                 ;org 4148h
.xdata$x:00004148 ; COMDAT (pick associative to section at 23C0)
.xdata$x:00004148 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00004148                                         ; DATA XREF: .xdata$x:00004158o
.xdata$x:00004149                 db 0FFh
.xdata$x:0000414A                 db 0FFh
.xdata$x:0000414B                 db 0FFh
.xdata$x:0000414C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00004150 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00004150                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00004151                 db    5
.xdata$x:00004152                 db  93h ; ô
.xdata$x:00004153                 db  19h
.xdata$x:00004154                 db    1
.xdata$x:00004155                 db    0
.xdata$x:00004156                 db    0
.xdata$x:00004157                 db    0
.xdata$x:00004158                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000415C                 db    0
.xdata$x:0000415D                 db    0
.xdata$x:0000415E                 db    0
.xdata$x:0000415F                 db    0
.xdata$x:00004160                 db    0
.xdata$x:00004161                 db    0
.xdata$x:00004162                 db    0
.xdata$x:00004163                 db    0
.xdata$x:00004164                 db    0
.xdata$x:00004165                 db    0
.xdata$x:00004166                 db    0
.xdata$x:00004167                 db    0
.xdata$x:00004168                 db    0
.xdata$x:00004169                 db    0
.xdata$x:0000416A                 db    0
.xdata$x:0000416B                 db    0
.xdata$x:0000416C                 db    0
.xdata$x:0000416D                 db    0
.xdata$x:0000416E                 db    0
.xdata$x:0000416F                 db    0
.xdata$x:00004170                 db    0
.xdata$x:00004171                 db    0
.xdata$x:00004172                 db    0
.xdata$x:00004173                 db    0
.xdata$x:00004173 _xdata$x        ends
.xdata$x:00004173
.xdata$x:00004174 ; ===========================================================================
.xdata$x:00004174
.xdata$x:00004174 ; Segment type: Pure data
.xdata$x:00004174 ; Segment permissions: Read
.xdata$x:00004174 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004174                 assume cs:_xdata$x
.xdata$x:00004174                 ;org 4174h
.xdata$x:00004174 ; COMDAT (pick associative to section at 1954)
.xdata$x:00004174 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004174                                         ; DATA XREF: .xdata$x:00004184o
.xdata$x:00004175                 db 0FFh
.xdata$x:00004176                 db 0FFh
.xdata$x:00004177                 db 0FFh
.xdata$x:00004178                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000417C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000417C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000417D                 db    5
.xdata$x:0000417E                 db  93h ; ô
.xdata$x:0000417F                 db  19h
.xdata$x:00004180                 db    1
.xdata$x:00004181                 db    0
.xdata$x:00004182                 db    0
.xdata$x:00004183                 db    0
.xdata$x:00004184                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00004188                 align 20h
.xdata$x:00004188 _xdata$x        ends
.xdata$x:00004188
.xdata$x:000041A0 ; ===========================================================================
.xdata$x:000041A0
.xdata$x:000041A0 ; Segment type: Pure data
.xdata$x:000041A0 ; Segment permissions: Read
.xdata$x:000041A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000041A0                 assume cs:_xdata$x
.xdata$x:000041A0                 ;org 41A0h
.xdata$x:000041A0 ; COMDAT (pick associative to section at 20A0)
.xdata$x:000041A0 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000041A0                                         ; DATA XREF: .xdata$x:000041B0o
.xdata$x:000041A1                 db 0FFh
.xdata$x:000041A2                 db 0FFh
.xdata$x:000041A3                 db 0FFh
.xdata$x:000041A4                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:000041A8 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000041A8                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:000041A9                 db    5
.xdata$x:000041AA                 db  93h ; ô
.xdata$x:000041AB                 db  19h
.xdata$x:000041AC                 db    1
.xdata$x:000041AD                 db    0
.xdata$x:000041AE                 db    0
.xdata$x:000041AF                 db    0
.xdata$x:000041B0                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:000041B4                 db    0
.xdata$x:000041B5                 db    0
.xdata$x:000041B6                 db    0
.xdata$x:000041B7                 db    0
.xdata$x:000041B8                 db    0
.xdata$x:000041B9                 db    0
.xdata$x:000041BA                 db    0
.xdata$x:000041BB                 db    0
.xdata$x:000041BC                 db    0
.xdata$x:000041BD                 db    0
.xdata$x:000041BE                 db    0
.xdata$x:000041BF                 db    0
.xdata$x:000041C0                 db    0
.xdata$x:000041C1                 db    0
.xdata$x:000041C2                 db    0
.xdata$x:000041C3                 db    0
.xdata$x:000041C4                 db    0
.xdata$x:000041C5                 db    0
.xdata$x:000041C6                 db    0
.xdata$x:000041C7                 db    0
.xdata$x:000041C8                 db    0
.xdata$x:000041C9                 db    0
.xdata$x:000041CA                 db    0
.xdata$x:000041CB                 db    0
.xdata$x:000041CB _xdata$x        ends
.xdata$x:000041CB
.xdata$x:000041CC ; ===========================================================================
.xdata$x:000041CC
.xdata$x:000041CC ; Segment type: Pure data
.xdata$x:000041CC ; Segment permissions: Read
.xdata$x:000041CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000041CC                 assume cs:_xdata$x
.xdata$x:000041CC                 ;org 41CCh
.xdata$x:000041CC ; COMDAT (pick associative to section at 1850)
.xdata$x:000041CC __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:000041CC                                         ; DATA XREF: .xdata$x:000041DCo
.xdata$x:000041CD                 db 0FFh
.xdata$x:000041CE                 db 0FFh
.xdata$x:000041CF                 db 0FFh
.xdata$x:000041D0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:000041D4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:000041D4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:000041D5                 db    5
.xdata$x:000041D6                 db  93h ; ô
.xdata$x:000041D7                 db  19h
.xdata$x:000041D8                 db    1
.xdata$x:000041D9                 db    0
.xdata$x:000041DA                 db    0
.xdata$x:000041DB                 db    0
.xdata$x:000041DC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:000041E0                 db    0
.xdata$x:000041E1                 db    0
.xdata$x:000041E2                 db    0
.xdata$x:000041E3                 db    0
.xdata$x:000041E4                 db    0
.xdata$x:000041E5                 db    0
.xdata$x:000041E6                 db    0
.xdata$x:000041E7                 db    0
.xdata$x:000041E8                 db    0
.xdata$x:000041E9                 db    0
.xdata$x:000041EA                 db    0
.xdata$x:000041EB                 db    0
.xdata$x:000041EC                 db    0
.xdata$x:000041ED                 db    0
.xdata$x:000041EE                 db    0
.xdata$x:000041EF                 db    0
.xdata$x:000041F0                 db    0
.xdata$x:000041F1                 db    0
.xdata$x:000041F2                 db    0
.xdata$x:000041F3                 db    0
.xdata$x:000041F4                 db    0
.xdata$x:000041F5                 db    0
.xdata$x:000041F6                 db    0
.xdata$x:000041F7                 db    0
.xdata$x:000041F7 _xdata$x        ends
.xdata$x:000041F7
.xdata$x:000041F8 ; ===========================================================================
.xdata$x:000041F8
.xdata$x:000041F8 ; Segment type: Pure data
.xdata$x:000041F8 ; Segment permissions: Read
.xdata$x:000041F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000041F8                 assume cs:_xdata$x
.xdata$x:000041F8                 ;org 41F8h
.xdata$x:000041F8 ; COMDAT (pick associative to section at 1FB8)
.xdata$x:000041F8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000041F8                                         ; DATA XREF: .xdata$x:00004208o
.xdata$x:000041F9                 db 0FFh
.xdata$x:000041FA                 db 0FFh
.xdata$x:000041FB                 db 0FFh
.xdata$x:000041FC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00004200 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004200                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00004201                 db    5
.xdata$x:00004202                 db  93h ; ô
.xdata$x:00004203                 db  19h
.xdata$x:00004204                 db    1
.xdata$x:00004205                 db    0
.xdata$x:00004206                 db    0
.xdata$x:00004207                 db    0
.xdata$x:00004208                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000420C                 db    0
.xdata$x:0000420D                 db    0
.xdata$x:0000420E                 db    0
.xdata$x:0000420F                 db    0
.xdata$x:00004210                 db    0
.xdata$x:00004211                 db    0
.xdata$x:00004212                 db    0
.xdata$x:00004213                 db    0
.xdata$x:00004214                 db    0
.xdata$x:00004215                 db    0
.xdata$x:00004216                 db    0
.xdata$x:00004217                 db    0
.xdata$x:00004218                 db    0
.xdata$x:00004219                 db    0
.xdata$x:0000421A                 db    0
.xdata$x:0000421B                 db    0
.xdata$x:0000421C                 db    0
.xdata$x:0000421D                 db    0
.xdata$x:0000421E                 db    0
.xdata$x:0000421F                 db    0
.xdata$x:00004220                 db    0
.xdata$x:00004221                 db    0
.xdata$x:00004222                 db    0
.xdata$x:00004223                 db    0
.xdata$x:00004223 _xdata$x        ends
.xdata$x:00004223
.xdata$x:00004224 ; ===========================================================================
.xdata$x:00004224
.xdata$x:00004224 ; Segment type: Pure data
.xdata$x:00004224 ; Segment permissions: Read
.xdata$x:00004224 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004224                 assume cs:_xdata$x
.xdata$x:00004224                 ;org 4224h
.xdata$x:00004224 ; COMDAT (pick associative to section at 1B6C)
.xdata$x:00004224 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00004224                                         ; DATA XREF: .xdata$x:00004234o
.xdata$x:00004225                 db 0FFh
.xdata$x:00004226                 db 0FFh
.xdata$x:00004227                 db 0FFh
.xdata$x:00004228                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000422C __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000422C                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000422D                 db    5
.xdata$x:0000422E                 db  93h ; ô
.xdata$x:0000422F                 db  19h
.xdata$x:00004230                 db    1
.xdata$x:00004231                 db    0
.xdata$x:00004232                 db    0
.xdata$x:00004233                 db    0
.xdata$x:00004234                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00004238                 db    0
.xdata$x:00004239                 db    0
.xdata$x:0000423A                 db    0
.xdata$x:0000423B                 db    0
.xdata$x:0000423C                 db    0
.xdata$x:0000423D                 db    0
.xdata$x:0000423E                 db    0
.xdata$x:0000423F                 db    0
.xdata$x:00004240                 db    0
.xdata$x:00004241                 db    0
.xdata$x:00004242                 db    0
.xdata$x:00004243                 db    0
.xdata$x:00004244                 db    0
.xdata$x:00004245                 db    0
.xdata$x:00004246                 db    0
.xdata$x:00004247                 db    0
.xdata$x:00004248                 db    0
.xdata$x:00004249                 db    0
.xdata$x:0000424A                 db    0
.xdata$x:0000424B                 db    0
.xdata$x:0000424C                 db    0
.xdata$x:0000424D                 db    0
.xdata$x:0000424E                 db    0
.xdata$x:0000424F                 db    0
.xdata$x:0000424F _xdata$x        ends
.xdata$x:0000424F
.xdata$x:00004250 ; ===========================================================================
.xdata$x:00004250
.xdata$x:00004250 ; Segment type: Pure data
.xdata$x:00004250 ; Segment permissions: Read
.xdata$x:00004250 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004250                 assume cs:_xdata$x
.xdata$x:00004250                 ;org 4250h
.xdata$x:00004250 ; COMDAT (pick associative to section at 1AD4)
.xdata$x:00004250 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:00004250                                         ; DATA XREF: .xdata$x:00004260o
.xdata$x:00004251                 db 0FFh
.xdata$x:00004252                 db 0FFh
.xdata$x:00004253                 db 0FFh
.xdata$x:00004254                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00004258 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00004258                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00004259                 db    5
.xdata$x:0000425A                 db  93h ; ô
.xdata$x:0000425B                 db  19h
.xdata$x:0000425C                 db    1
.xdata$x:0000425D                 db    0
.xdata$x:0000425E                 db    0
.xdata$x:0000425F                 db    0
.xdata$x:00004260                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:00004264                 db    0
.xdata$x:00004265                 db    0
.xdata$x:00004266                 db    0
.xdata$x:00004267                 db    0
.xdata$x:00004268                 db    0
.xdata$x:00004269                 db    0
.xdata$x:0000426A                 db    0
.xdata$x:0000426B                 db    0
.xdata$x:0000426C                 db    0
.xdata$x:0000426D                 db    0
.xdata$x:0000426E                 db    0
.xdata$x:0000426F                 db    0
.xdata$x:00004270                 db    0
.xdata$x:00004271                 db    0
.xdata$x:00004272                 db    0
.xdata$x:00004273                 db    0
.xdata$x:00004274                 db    0
.xdata$x:00004275                 db    0
.xdata$x:00004276                 db    0
.xdata$x:00004277                 db    0
.xdata$x:00004278                 db    0
.xdata$x:00004279                 db    0
.xdata$x:0000427A                 db    0
.xdata$x:0000427B                 db    0
.xdata$x:0000427B _xdata$x        ends
.xdata$x:0000427B
.xdata$x:0000427C ; ===========================================================================
.xdata$x:0000427C
.xdata$x:0000427C ; Segment type: Pure data
.xdata$x:0000427C ; Segment permissions: Read
.xdata$x:0000427C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000427C                 assume cs:_xdata$x
.xdata$x:0000427C                 ;org 427Ch
.xdata$x:0000427C ; COMDAT (pick associative to section at 218C)
.xdata$x:0000427C __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000427C                                         ; DATA XREF: .xdata$x:0000428Co
.xdata$x:0000427D                 db 0FFh
.xdata$x:0000427E                 db 0FFh
.xdata$x:0000427F                 db 0FFh
.xdata$x:00004280                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00004284 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00004284                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00004285                 db    5
.xdata$x:00004286                 db  93h ; ô
.xdata$x:00004287                 db  19h
.xdata$x:00004288                 db    1
.xdata$x:00004289                 db    0
.xdata$x:0000428A                 db    0
.xdata$x:0000428B                 db    0
.xdata$x:0000428C                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00004290                 db    0
.xdata$x:00004291                 db    0
.xdata$x:00004292                 db    0
.xdata$x:00004293                 db    0
.xdata$x:00004294                 db    0
.xdata$x:00004295                 db    0
.xdata$x:00004296                 db    0
.xdata$x:00004297                 db    0
.xdata$x:00004298                 db    0
.xdata$x:00004299                 db    0
.xdata$x:0000429A                 db    0
.xdata$x:0000429B                 db    0
.xdata$x:0000429C                 db    0
.xdata$x:0000429D                 db    0
.xdata$x:0000429E                 db    0
.xdata$x:0000429F                 db    0
.xdata$x:000042A0                 db    0
.xdata$x:000042A1                 db    0
.xdata$x:000042A2                 db    0
.xdata$x:000042A3                 db    0
.xdata$x:000042A4                 db    0
.xdata$x:000042A5                 db    0
.xdata$x:000042A6                 db    0
.xdata$x:000042A7                 db    0
.xdata$x:000042A7 _xdata$x        ends
.xdata$x:000042A7
.xdata$x:000042A8 ; ===========================================================================
.xdata$x:000042A8
.xdata$x:000042A8 ; Segment type: Pure data
.xdata$x:000042A8 ; Segment permissions: Read
.xdata$x:000042A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000042A8                 assume cs:_xdata$x
.xdata$x:000042A8                 ;org 42A8h
.xdata$x:000042A8 ; COMDAT (pick associative to section at 28F0)
.xdata$x:000042A8 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000042A8                                         ; DATA XREF: .xdata$x:00004330o
.xdata$x:000042A9                 db    0
.xdata$x:000042AA                 db    0
.xdata$x:000042AB                 db    0
.xdata$x:000042AC                 db    0
.xdata$x:000042AD                 db    0
.xdata$x:000042AE                 db    0
.xdata$x:000042AF                 db    0
.xdata$x:000042B0                 db    0
.xdata$x:000042B1                 db    0
.xdata$x:000042B2                 db    0
.xdata$x:000042B3                 db    0
.xdata$x:000042B4                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:000042B8 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000042B8                                         ; DATA XREF: .xdata$x:0000431Co
.xdata$x:000042B9                 db    0
.xdata$x:000042BA                 db    0
.xdata$x:000042BB                 db    0
.xdata$x:000042BC                 db    0
.xdata$x:000042BD                 db    0
.xdata$x:000042BE                 db    0
.xdata$x:000042BF                 db    0
.xdata$x:000042C0                 db    0
.xdata$x:000042C1                 db    0
.xdata$x:000042C2                 db    0
.xdata$x:000042C3                 db    0
.xdata$x:000042C4                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:000042C8 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000042C8                                         ; DATA XREF: .xdata$x:000042F0o
.xdata$x:000042C9                 db 0FFh
.xdata$x:000042CA                 db 0FFh
.xdata$x:000042CB                 db 0FFh
.xdata$x:000042CC                 db    0
.xdata$x:000042CD                 db    0
.xdata$x:000042CE                 db    0
.xdata$x:000042CF                 db    0
.xdata$x:000042D0                 db 0FFh
.xdata$x:000042D1                 db 0FFh
.xdata$x:000042D2                 db 0FFh
.xdata$x:000042D3                 db 0FFh
.xdata$x:000042D4                 db    0
.xdata$x:000042D5                 db    0
.xdata$x:000042D6                 db    0
.xdata$x:000042D7                 db    0
.xdata$x:000042D8                 db    1
.xdata$x:000042D9                 db    0
.xdata$x:000042DA                 db    0
.xdata$x:000042DB                 db    0
.xdata$x:000042DC                 db    0
.xdata$x:000042DD                 db    0
.xdata$x:000042DE                 db    0
.xdata$x:000042DF                 db    0
.xdata$x:000042E0                 db    1
.xdata$x:000042E1                 db    0
.xdata$x:000042E2                 db    0
.xdata$x:000042E3                 db    0
.xdata$x:000042E4                 db    0
.xdata$x:000042E5                 db    0
.xdata$x:000042E6                 db    0
.xdata$x:000042E7                 db    0
.xdata$x:000042E8 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000042E8                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:000042E9                 db    5
.xdata$x:000042EA                 db  93h ; ô
.xdata$x:000042EB                 db  19h
.xdata$x:000042EC                 db    4
.xdata$x:000042ED                 db    0
.xdata$x:000042EE                 db    0
.xdata$x:000042EF                 db    0
.xdata$x:000042F0                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:000042F4                 db    2
.xdata$x:000042F5                 db    0
.xdata$x:000042F6                 db    0
.xdata$x:000042F7                 db    0
.xdata$x:000042F8                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:000042FC                 db    0
.xdata$x:000042FD                 db    0
.xdata$x:000042FE                 db    0
.xdata$x:000042FF                 db    0
.xdata$x:00004300                 db    0
.xdata$x:00004301                 db    0
.xdata$x:00004302                 db    0
.xdata$x:00004303                 db    0
.xdata$x:00004304                 db    0
.xdata$x:00004305                 db    0
.xdata$x:00004306                 db    0
.xdata$x:00004307                 db    0
.xdata$x:00004308                 db    0
.xdata$x:00004309                 db    0
.xdata$x:0000430A                 db    0
.xdata$x:0000430B                 db    0
.xdata$x:0000430C __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000430C                                         ; DATA XREF: .xdata$x:000042F8o
.xdata$x:0000430D                 db    0
.xdata$x:0000430E                 db    0
.xdata$x:0000430F                 db    0
.xdata$x:00004310                 db    2
.xdata$x:00004311                 db    0
.xdata$x:00004312                 db    0
.xdata$x:00004313                 db    0
.xdata$x:00004314                 db    3
.xdata$x:00004315                 db    0
.xdata$x:00004316                 db    0
.xdata$x:00004317                 db    0
.xdata$x:00004318                 db    1
.xdata$x:00004319                 db    0
.xdata$x:0000431A                 db    0
.xdata$x:0000431B                 db    0
.xdata$x:0000431C                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00004320                 db    0
.xdata$x:00004321                 db    0
.xdata$x:00004322                 db    0
.xdata$x:00004323                 db    0
.xdata$x:00004324                 db    0
.xdata$x:00004325                 db    0
.xdata$x:00004326                 db    0
.xdata$x:00004327                 db    0
.xdata$x:00004328                 db    3
.xdata$x:00004329                 db    0
.xdata$x:0000432A                 db    0
.xdata$x:0000432B                 db    0
.xdata$x:0000432C                 db    1
.xdata$x:0000432D                 db    0
.xdata$x:0000432E                 db    0
.xdata$x:0000432F                 db    0
.xdata$x:00004330                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00004330 _xdata$x        ends
.xdata$x:00004330
.xdata$x:00004334 ; ===========================================================================
.xdata$x:00004334
.xdata$x:00004334 ; Segment type: Pure data
.xdata$x:00004334 ; Segment permissions: Read
.xdata$x:00004334 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004334                 assume cs:_xdata$x
.xdata$x:00004334                 ;org 4334h
.xdata$x:00004334 ; COMDAT (pick associative to section at 1BF8)
.xdata$x:00004334 __unwindtable$??0FindOption@@QAE@XZ db 0FFh
.xdata$x:00004334                                         ; DATA XREF: .xdata$x:0000435Co
.xdata$x:00004335                 db 0FFh
.xdata$x:00004336                 db 0FFh
.xdata$x:00004337                 db 0FFh
.xdata$x:00004338                 dd offset __unwindfunclet$??0FindOption@@QAE@XZ$0
.xdata$x:0000433C                 align 10h
.xdata$x:00004340                 dd offset __unwindfunclet$??0FindOption@@QAE@XZ$1
.xdata$x:00004344                 db    1
.xdata$x:00004345                 db    0
.xdata$x:00004346                 db    0
.xdata$x:00004347                 db    0
.xdata$x:00004348                 dd offset __unwindfunclet$??0FindOption@@QAE@XZ$2
.xdata$x:0000434C                 db    2
.xdata$x:0000434D                 db    0
.xdata$x:0000434E                 db    0
.xdata$x:0000434F                 db    0
.xdata$x:00004350                 dd offset __unwindfunclet$??0FindOption@@QAE@XZ$3
.xdata$x:00004354 __ehfuncinfo$??0FindOption@@QAE@XZ db  22h ; "
.xdata$x:00004354                                         ; DATA XREF: __ehhandler$??0FindOption@@QAE@XZ+11o
.xdata$x:00004355                 db    5
.xdata$x:00004356                 db  93h ; ô
.xdata$x:00004357                 db  19h
.xdata$x:00004358                 db    4
.xdata$x:00004359                 db    0
.xdata$x:0000435A                 db    0
.xdata$x:0000435B                 db    0
.xdata$x:0000435C                 dd offset __unwindtable$??0FindOption@@QAE@XZ
.xdata$x:00004360                 db    0
.xdata$x:00004361                 db    0
.xdata$x:00004362                 db    0
.xdata$x:00004363                 db    0
.xdata$x:00004364                 db    0
.xdata$x:00004365                 db    0
.xdata$x:00004366                 db    0
.xdata$x:00004367                 db    0
.xdata$x:00004368                 db    0
.xdata$x:00004369                 db    0
.xdata$x:0000436A                 db    0
.xdata$x:0000436B                 db    0
.xdata$x:0000436C                 db    0
.xdata$x:0000436D                 db    0
.xdata$x:0000436E                 db    0
.xdata$x:0000436F                 db    0
.xdata$x:00004370                 db    0
.xdata$x:00004371                 db    0
.xdata$x:00004372                 db    0
.xdata$x:00004373                 db    0
.xdata$x:00004374                 db    0
.xdata$x:00004375                 db    0
.xdata$x:00004376                 db    0
.xdata$x:00004377                 db    0
.xdata$x:00004377 _xdata$x        ends
.xdata$x:00004377
.xdata$x:00004378 ; ===========================================================================
.xdata$x:00004378
.xdata$x:00004378 ; Segment type: Pure data
.xdata$x:00004378 ; Segment permissions: Read
.xdata$x:00004378 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004378                 assume cs:_xdata$x
.xdata$x:00004378                 ;org 4378h
.xdata$x:00004378 ; COMDAT (pick associative to section at 2208)
.xdata$x:00004378 __unwindtable$??1FindOption@@QAE@XZ db 0FFh
.xdata$x:00004378                                         ; DATA XREF: .xdata$x:000043A0o
.xdata$x:00004379                 db 0FFh
.xdata$x:0000437A                 db 0FFh
.xdata$x:0000437B                 db 0FFh
.xdata$x:0000437C                 dd offset __unwindfunclet$??1FindOption@@QAE@XZ$0
.xdata$x:00004380                 db    0
.xdata$x:00004381                 db    0
.xdata$x:00004382                 db    0
.xdata$x:00004383                 db    0
.xdata$x:00004384                 dd offset __unwindfunclet$??1FindOption@@QAE@XZ$1
.xdata$x:00004388                 db    1
.xdata$x:00004389                 db    0
.xdata$x:0000438A                 db    0
.xdata$x:0000438B                 db    0
.xdata$x:0000438C                 dd offset __unwindfunclet$??1FindOption@@QAE@XZ$2
.xdata$x:00004390                 db    2
.xdata$x:00004391                 db    0
.xdata$x:00004392                 db    0
.xdata$x:00004393                 db    0
.xdata$x:00004394                 dd offset __unwindfunclet$??1FindOption@@QAE@XZ$3
.xdata$x:00004398 __ehfuncinfo$??1FindOption@@QAE@XZ db  22h ; "
.xdata$x:00004398                                         ; DATA XREF: __ehhandler$??1FindOption@@QAE@XZ+11o
.xdata$x:00004399                 db    5
.xdata$x:0000439A                 db  93h ; ô
.xdata$x:0000439B                 db  19h
.xdata$x:0000439C                 db    4
.xdata$x:0000439D                 db    0
.xdata$x:0000439E                 db    0
.xdata$x:0000439F                 db    0
.xdata$x:000043A0                 dd offset __unwindtable$??1FindOption@@QAE@XZ
.xdata$x:000043A4                 db    0
.xdata$x:000043A5                 db    0
.xdata$x:000043A6                 db    0
.xdata$x:000043A7                 db    0
.xdata$x:000043A8                 db    0
.xdata$x:000043A9                 db    0
.xdata$x:000043AA                 db    0
.xdata$x:000043AB                 db    0
.xdata$x:000043AC                 db    0
.xdata$x:000043AD                 db    0
.xdata$x:000043AE                 db    0
.xdata$x:000043AF                 db    0
.xdata$x:000043B0                 db    0
.xdata$x:000043B1                 db    0
.xdata$x:000043B2                 db    0
.xdata$x:000043B3                 db    0
.xdata$x:000043B4                 db    0
.xdata$x:000043B5                 db    0
.xdata$x:000043B6                 db    0
.xdata$x:000043B7                 db    0
.xdata$x:000043B8                 db    0
.xdata$x:000043B9                 db    0
.xdata$x:000043BA                 db    0
.xdata$x:000043BB                 db    0
.xdata$x:000043BB _xdata$x        ends
.xdata$x:000043BB
.xdata$x:000043BC ; ===========================================================================
.xdata$x:000043BC
.xdata$x:000043BC ; Segment type: Pure data
.xdata$x:000043BC ; Segment permissions: Read
.xdata$x:000043BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000043BC                 assume cs:_xdata$x
.xdata$x:000043BC                 ;org 43BCh
.xdata$x:000043BC ; COMDAT (pick associative to section at 166C)
.xdata$x:000043BC __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000043BC                                         ; DATA XREF: .xdata$x:000043CCo
.xdata$x:000043BD                 db 0FFh
.xdata$x:000043BE                 db 0FFh
.xdata$x:000043BF                 db 0FFh
.xdata$x:000043C0                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000043C4 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000043C4                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000043C5                 db    5
.xdata$x:000043C6                 db  93h ; ô
.xdata$x:000043C7                 db  19h
.xdata$x:000043C8                 db    1
.xdata$x:000043C9                 db    0
.xdata$x:000043CA                 db    0
.xdata$x:000043CB                 db    0
.xdata$x:000043CC                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000043D0                 db    0
.xdata$x:000043D1                 db    0
.xdata$x:000043D2                 db    0
.xdata$x:000043D3                 db    0
.xdata$x:000043D4                 db    0
.xdata$x:000043D5                 db    0
.xdata$x:000043D6                 db    0
.xdata$x:000043D7                 db    0
.xdata$x:000043D8                 db    0
.xdata$x:000043D9                 db    0
.xdata$x:000043DA                 db    0
.xdata$x:000043DB                 db    0
.xdata$x:000043DC                 db    0
.xdata$x:000043DD                 db    0
.xdata$x:000043DE                 db    0
.xdata$x:000043DF                 db    0
.xdata$x:000043E0                 db    0
.xdata$x:000043E1                 db    0
.xdata$x:000043E2                 db    0
.xdata$x:000043E3                 db    0
.xdata$x:000043E4                 db    0
.xdata$x:000043E5                 db    0
.xdata$x:000043E6                 db    0
.xdata$x:000043E7                 db    0
.xdata$x:000043E7 _xdata$x        ends
.xdata$x:000043E7
.xdata$x:000043E8 ; ===========================================================================
.xdata$x:000043E8
.xdata$x:000043E8 ; Segment type: Pure data
.xdata$x:000043E8 ; Segment permissions: Read
.xdata$x:000043E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000043E8                 assume cs:_xdata$x
.xdata$x:000043E8                 ;org 43E8h
.xdata$x:000043E8 ; COMDAT (pick associative to section at 1498)
.xdata$x:000043E8 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000043E8                                         ; DATA XREF: .xdata$x:000043F8o
.xdata$x:000043E9                 db 0FFh
.xdata$x:000043EA                 db 0FFh
.xdata$x:000043EB                 db 0FFh
.xdata$x:000043EC                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000043F0 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000043F0                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000043F1                 db    5
.xdata$x:000043F2                 db  93h ; ô
.xdata$x:000043F3                 db  19h
.xdata$x:000043F4                 db    1
.xdata$x:000043F5                 db    0
.xdata$x:000043F6                 db    0
.xdata$x:000043F7                 db    0
.xdata$x:000043F8                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000043FC                 db    0
.xdata$x:000043FD                 db    0
.xdata$x:000043FE                 db    0
.xdata$x:000043FF                 db    0
.xdata$x:00004400                 db    0
.xdata$x:00004401                 db    0
.xdata$x:00004402                 db    0
.xdata$x:00004403                 db    0
.xdata$x:00004404                 db    0
.xdata$x:00004405                 db    0
.xdata$x:00004406                 db    0
.xdata$x:00004407                 db    0
.xdata$x:00004408                 db    0
.xdata$x:00004409                 db    0
.xdata$x:0000440A                 db    0
.xdata$x:0000440B                 db    0
.xdata$x:0000440C                 db    0
.xdata$x:0000440D                 db    0
.xdata$x:0000440E                 db    0
.xdata$x:0000440F                 db    0
.xdata$x:00004410                 db    0
.xdata$x:00004411                 db    0
.xdata$x:00004412                 db    0
.xdata$x:00004413                 db    0
.xdata$x:00004413 _xdata$x        ends
.xdata$x:00004413
.xdata$x:00004414 ; ===========================================================================
.xdata$x:00004414
.xdata$x:00004414 ; Segment type: Pure data
.xdata$x:00004414 ; Segment permissions: Read
.xdata$x:00004414 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004414                 assume cs:_xdata$x
.xdata$x:00004414                 ;org 4414h
.xdata$x:00004414 ; COMDAT (pick associative to section at 1598)
.xdata$x:00004414 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00004414                                         ; DATA XREF: .xdata$x:00004424o
.xdata$x:00004415                 db 0FFh
.xdata$x:00004416                 db 0FFh
.xdata$x:00004417                 db 0FFh
.xdata$x:00004418                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000441C __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000441C                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000441D                 db    5
.xdata$x:0000441E                 db  93h ; ô
.xdata$x:0000441F                 db  19h
.xdata$x:00004420                 db    1
.xdata$x:00004421                 db    0
.xdata$x:00004422                 db    0
.xdata$x:00004423                 db    0
.xdata$x:00004424                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00004428                 align 20h
.xdata$x:00004428 _xdata$x        ends
.xdata$x:00004428
.bss:00004440 ; ===========================================================================
.bss:00004440
.bss:00004440 ; Segment type: Uninitialized
.bss:00004440 ; Segment permissions: Read/Write
.bss:00004440 _bss            segment byte public 'BSS' use32
.bss:00004440                 assume cs:_bss
.bss:00004440                 ;org 4440h
.bss:00004440                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00004440 __Tuple_alloc   db    ? ;
.bss:00004441 ; std::_Ignore ignore
.bss:00004441 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00004442 _allocator_arg  db    ? ;
.bss:00004443 _piecewise_construct db    ? ;
.bss:00004443 _bss            ends
.bss:00004443
.rdata:00004444 ; ===========================================================================
.rdata:00004444
.rdata:00004444 ; Segment type: Pure data
.rdata:00004444 ; Segment permissions: Read
.rdata:00004444 _rdata          segment dword public 'DATA' use32
.rdata:00004444                 assume cs:_rdata
.rdata:00004444                 ;org 4444h
.rdata:00004444 ; COMDAT (pick largest)
.rdata:00004444                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00004448                 public ??_7error_category@std@@6B@
.rdata:00004448 ; const std::error_category::`vftable'
.rdata:00004448 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00004448                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00004448                                         ; std::error_category::~error_category(void)+Ao
.rdata:00004448                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000444C                 dd offset __purecall
.rdata:00004450                 dd offset __purecall
.rdata:00004454                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004458                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000445C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000445C _rdata          ends
.rdata:0000445C
.rdata:00004460 ; ===========================================================================
.rdata:00004460
.rdata:00004460 ; Segment type: Pure data
.rdata:00004460 ; Segment permissions: Read
.rdata:00004460 _rdata          segment dword public 'DATA' use32
.rdata:00004460                 assume cs:_rdata
.rdata:00004460                 ;org 4460h
.rdata:00004460 ; COMDAT (pick largest)
.rdata:00004460                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00004464                 public ??_7_Generic_error_category@std@@6B@
.rdata:00004464 ; const std::_Generic_error_category::`vftable'
.rdata:00004464 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00004464                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00004464                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00004468                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000446C                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00004470                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004474                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004478                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004478 _rdata          ends
.rdata:00004478
.rdata:0000447C ; ===========================================================================
.rdata:0000447C
.rdata:0000447C ; Segment type: Pure data
.rdata:0000447C ; Segment permissions: Read
.rdata:0000447C _rdata          segment dword public 'DATA' use32
.rdata:0000447C                 assume cs:_rdata
.rdata:0000447C                 ;org 447Ch
.rdata:0000447C ; COMDAT (pick any)
.rdata:0000447C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000447C ; `string'
.rdata:0000447C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000447C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000447C _rdata          ends
.rdata:0000447C
.rdata:00004484 ; ===========================================================================
.rdata:00004484
.rdata:00004484 ; Segment type: Pure data
.rdata:00004484 ; Segment permissions: Read
.rdata:00004484 _rdata          segment dword public 'DATA' use32
.rdata:00004484                 assume cs:_rdata
.rdata:00004484                 ;org 4484h
.rdata:00004484 ; COMDAT (pick any)
.rdata:00004484                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00004484 ; `string'
.rdata:00004484 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00004484                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_3AD0o
.rdata:00004484                                         ; std::_System_error_category::message(int):loc_3C4Co
.rdata:00004492                 align 4
.rdata:00004492 _rdata          ends
.rdata:00004492
.rdata:00004494 ; ===========================================================================
.rdata:00004494
.rdata:00004494 ; Segment type: Pure data
.rdata:00004494 ; Segment permissions: Read
.rdata:00004494 _rdata          segment dword public 'DATA' use32
.rdata:00004494                 assume cs:_rdata
.rdata:00004494                 ;org 4494h
.rdata:00004494 ; COMDAT (pick largest)
.rdata:00004494                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00004498                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00004498 ; const std::_Iostream_error_category::`vftable'
.rdata:00004498 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00004498                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00004498                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000449C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000044A0                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000044A4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000044A8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000044AC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000044AC _rdata          ends
.rdata:000044AC
.rdata:000044B0 ; ===========================================================================
.rdata:000044B0
.rdata:000044B0 ; Segment type: Pure data
.rdata:000044B0 ; Segment permissions: Read
.rdata:000044B0 _rdata          segment dword public 'DATA' use32
.rdata:000044B0                 assume cs:_rdata
.rdata:000044B0                 ;org 44B0h
.rdata:000044B0 ; COMDAT (pick any)
.rdata:000044B0                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000044B0 ; `string'
.rdata:000044B0 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000044B0                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000044B9                 align 4
.rdata:000044B9 _rdata          ends
.rdata:000044B9
.rdata:000044BC ; ===========================================================================
.rdata:000044BC
.rdata:000044BC ; Segment type: Pure data
.rdata:000044BC ; Segment permissions: Read
.rdata:000044BC _rdata          segment dword public 'DATA' use32
.rdata:000044BC                 assume cs:_rdata
.rdata:000044BC                 ;org 44BCh
.rdata:000044BC ; COMDAT (pick any)
.rdata:000044BC                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000044BC ; char `string'[]
.rdata:000044BC ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000044BC                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:000044D2                 align 4
.rdata:000044D2 _rdata          ends
.rdata:000044D2
.rdata:000044D4 ; ===========================================================================
.rdata:000044D4
.rdata:000044D4 ; Segment type: Pure data
.rdata:000044D4 ; Segment permissions: Read
.rdata:000044D4 _rdata          segment dword public 'DATA' use32
.rdata:000044D4                 assume cs:_rdata
.rdata:000044D4                 ;org 44D4h
.rdata:000044D4 ; COMDAT (pick largest)
.rdata:000044D4                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:000044D8                 public ??_7_System_error_category@std@@6B@
.rdata:000044D8 ; const std::_System_error_category::`vftable'
.rdata:000044D8 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:000044D8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:000044D8                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000044DC                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000044E0                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000044E4                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000044E8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000044EC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000044EC _rdata          ends
.rdata:000044EC
.rdata:000044F0 ; ===========================================================================
.rdata:000044F0
.rdata:000044F0 ; Segment type: Pure data
.rdata:000044F0 ; Segment permissions: Read
.rdata:000044F0 _rdata          segment dword public 'DATA' use32
.rdata:000044F0                 assume cs:_rdata
.rdata:000044F0                 ;org 44F0h
.rdata:000044F0 ; COMDAT (pick any)
.rdata:000044F0                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000044F0 ; `string'
.rdata:000044F0 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000044F0                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000044F7                 align 4
.rdata:000044F7 _rdata          ends
.rdata:000044F7
.bss:000044F8 ; ===========================================================================
.bss:000044F8
.bss:000044F8 ; Segment type: Uninitialized
.bss:000044F8 ; Segment permissions: Read/Write
.bss:000044F8 _bss            segment dword public 'BSS' use32
.bss:000044F8                 assume cs:_bss
.bss:000044F8                 ;org 44F8h
.bss:000044F8 ; COMDAT (pick any)
.bss:000044F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000044F8                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000044F8 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000044F8 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000044F8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000044F8                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000044F9                 db    ? ;
.bss:000044FA                 db    ? ;
.bss:000044FB                 db    ? ;
.bss:000044FB _bss            ends
.bss:000044FB
.bss:000044FC ; ===========================================================================
.bss:000044FC
.bss:000044FC ; Segment type: Uninitialized
.bss:000044FC ; Segment permissions: Read/Write
.bss:000044FC _bss            segment dword public 'BSS' use32
.bss:000044FC                 assume cs:_bss
.bss:000044FC                 ;org 44FCh
.bss:000044FC ; COMDAT (pick any)
.bss:000044FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000044FC                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000044FC ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000044FC ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000044FC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000044FC                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000044FD                 db    ? ;
.bss:000044FE                 db    ? ;
.bss:000044FF                 db    ? ;
.bss:000044FF _bss            ends
.bss:000044FF
.bss:00004500 ; ===========================================================================
.bss:00004500
.bss:00004500 ; Segment type: Uninitialized
.bss:00004500 ; Segment permissions: Read/Write
.bss:00004500 _bss            segment dword public 'BSS' use32
.bss:00004500                 assume cs:_bss
.bss:00004500                 ;org 4500h
.bss:00004500 ; COMDAT (pick any)
.bss:00004500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00004500                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00004500 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00004500 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00004500                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00004500                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00004501                 db    ? ;
.bss:00004502                 db    ? ;
.bss:00004503                 db    ? ;
.bss:00004503 _bss            ends
.bss:00004503
.bss:00004504 ; ===========================================================================
.bss:00004504
.bss:00004504 ; Segment type: Uninitialized
.bss:00004504 ; Segment permissions: Read/Write
.bss:00004504 _bss            segment dword public 'BSS' use32
.bss:00004504                 assume cs:_bss
.bss:00004504                 ;org 4504h
.bss:00004504 ; COMDAT (pick any)
.bss:00004504                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00004504                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00004504 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00004504 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00004504                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00004505                 db    ? ;
.bss:00004506                 db    ? ;
.bss:00004507                 db    ? ;
.bss:00004507 _bss            ends
.bss:00004507
.bss:00004508 ; ===========================================================================
.bss:00004508
.bss:00004508 ; Segment type: Uninitialized
.bss:00004508 ; Segment permissions: Read/Write
.bss:00004508 _bss            segment dword public 'BSS' use32
.bss:00004508                 assume cs:_bss
.bss:00004508                 ;org 4508h
.bss:00004508 ; COMDAT (pick any)
.bss:00004508                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00004508                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00004508 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00004508 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00004508                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00004509                 db    ? ;
.bss:0000450A                 db    ? ;
.bss:0000450B                 db    ? ;
.bss:0000450B _bss            ends
.bss:0000450B
.rdata:0000450C ; ===========================================================================
.rdata:0000450C
.rdata:0000450C ; Segment type: Pure data
.rdata:0000450C ; Segment permissions: Read
.rdata:0000450C _rdata          segment dword public 'DATA' use32
.rdata:0000450C                 assume cs:_rdata
.rdata:0000450C                 ;org 450Ch
.rdata:0000450C ; COMDAT (pick any)
.rdata:0000450C                 public ??_C@_11LOCGONAA@?$AA?$AA@
.rdata:0000450C ; wchar_t `string'
.rdata:0000450C ??_C@_11LOCGONAA@?$AA?$AA@ dw 0         ; DATA XREF: FindOption::FindOption(void)+8Bo
.rdata:0000450C                                         ; FindOption::FindOption(void)+9Fo
.rdata:0000450E                 align 10h
.rdata:0000450E _rdata          ends
.rdata:0000450E
.rdata:00004510 ; ===========================================================================
.rdata:00004510
.rdata:00004510 ; Segment type: Pure data
.rdata:00004510 ; Segment permissions: Read
.rdata:00004510 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00004510 _rdata          segment para public 'DATA' use32
.rdata:00004510                 assume cs:_rdata
.rdata:00004510                 ;org 4510h
.rdata:00004510 ; COMDAT (pick any)
.rdata:00004510                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00004510 ; wchar_t `string'
.rdata:00004510 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00004510                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00004510                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00004510                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00004510                 unicode 0, <clude\xstring>,0
.rdata:0000459E                 align 10h
.rdata:0000459E _rdata          ends
.rdata:0000459E
.bss:000045A0 ; ===========================================================================
.bss:000045A0
.bss:000045A0 ; Segment type: Uninitialized
.bss:000045A0 ; Segment permissions: Read/Write
.bss:000045A0 _bss            segment dword public 'BSS' use32
.bss:000045A0                 assume cs:_bss
.bss:000045A0                 ;org 45A0h
.bss:000045A0 ; COMDAT (pick any)
.bss:000045A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000045A0                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000045A0 ; std::locale::id std::numpunct<char>::id
.bss:000045A0 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000045A0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000045A1                 db    ? ;
.bss:000045A2                 db    ? ;
.bss:000045A3                 db    ? ;
.bss:000045A3 _bss            ends
.bss:000045A3
.bss:000045A4 ; ===========================================================================
.bss:000045A4
.bss:000045A4 ; Segment type: Uninitialized
.bss:000045A4 ; Segment permissions: Read/Write
.bss:000045A4 _bss            segment dword public 'BSS' use32
.bss:000045A4                 assume cs:_bss
.bss:000045A4                 ;org 45A4h
.bss:000045A4 ; COMDAT (pick any)
.bss:000045A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000045A4                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000045A4 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000045A4 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000045A4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000045A5                 db    ? ;
.bss:000045A6                 db    ? ;
.bss:000045A7                 db    ? ;
.bss:000045A7 _bss            ends
.bss:000045A7
.rdata:000045A8 ; ===========================================================================
.rdata:000045A8
.rdata:000045A8 ; Segment type: Pure data
.rdata:000045A8 ; Segment permissions: Read
.rdata:000045A8 _rdata          segment dword public 'DATA' use32
.rdata:000045A8                 assume cs:_rdata
.rdata:000045A8                 ;org 45A8h
.rdata:000045A8 ; COMDAT (pick any)
.rdata:000045A8                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000045A8 ; char `string'[]
.rdata:000045A8 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000045A8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000045A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:000045A8 _rdata          ends
.rdata:000045A8
.rdata:000045B8 ; ===========================================================================
.rdata:000045B8
.rdata:000045B8 ; Segment type: Pure data
.rdata:000045B8 ; Segment permissions: Read
.rdata:000045B8 _rdata          segment dword public 'DATA' use32
.rdata:000045B8                 assume cs:_rdata
.rdata:000045B8                 ;org 45B8h
.rdata:000045B8 ; COMDAT (pick any)
.rdata:000045B8                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000045B8 ; char `string'[]
.rdata:000045B8 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000045B8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000045B8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:000045B8 _rdata          ends
.rdata:000045B8
.rdata:000045D0 ; ===========================================================================
.rdata:000045D0
.rdata:000045D0 ; Segment type: Pure data
.rdata:000045D0 ; Segment permissions: Read
.rdata:000045D0 _rdata          segment dword public 'DATA' use32
.rdata:000045D0                 assume cs:_rdata
.rdata:000045D0                 ;org 45D0h
.rdata:000045D0 ; COMDAT (pick any)
.rdata:000045D0                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:000045D0 ; wchar_t `string'
.rdata:000045D0 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:000045D0                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:000045D0                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+11o
.rdata:000045D0                 unicode 0, <invalid null pointer>,0
.rdata:000045FA                 align 4
.rdata:000045FA _rdata          ends
.rdata:000045FA
.rdata$r:000045FC ; ===========================================================================
.rdata$r:000045FC
.rdata$r:000045FC ; Segment type: Pure data
.rdata$r:000045FC ; Segment permissions: Read
.rdata$r:000045FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000045FC                 assume cs:_rdata$r
.rdata$r:000045FC                 ;org 45FCh
.rdata$r:000045FC ; COMDAT (pick any)
.rdata$r:000045FC                 public ??_R4error_category@std@@6B@
.rdata$r:000045FC ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000045FC ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00004444o
.rdata$r:000045FD                 db    0
.rdata$r:000045FE                 db    0
.rdata$r:000045FF                 db    0
.rdata$r:00004600                 db    0
.rdata$r:00004601                 db    0
.rdata$r:00004602                 db    0
.rdata$r:00004603                 db    0
.rdata$r:00004604                 db    0
.rdata$r:00004605                 db    0
.rdata$r:00004606                 db    0
.rdata$r:00004607                 db    0
.rdata$r:00004608                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000460C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000460C _rdata$r        ends
.rdata$r:0000460C
.data$r:00004610 ; ===========================================================================
.data$r:00004610
.data$r:00004610 ; Segment type: Pure data
.data$r:00004610 ; Segment permissions: Read/Write
.data$r:00004610 _data$r         segment dword public 'DATA' use32
.data$r:00004610                 assume cs:_data$r
.data$r:00004610                 ;org 4610h
.data$r:00004610 ; COMDAT (pick any)
.data$r:00004610                 public ??_R0?AVerror_category@std@@@8
.data$r:00004610 ; class std::error_category `RTTI Type Descriptor'
.data$r:00004610 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004610                                         ; DATA XREF: .rdata$r:00004608o
.data$r:00004610                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004610                                         ; const type_info::`vftable'
.data$r:00004614                 align 8
.data$r:00004618 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00004631                 align 4
.data$r:00004631 _data$r         ends
.data$r:00004631
.rdata$r:00004634 ; ===========================================================================
.rdata$r:00004634
.rdata$r:00004634 ; Segment type: Pure data
.rdata$r:00004634 ; Segment permissions: Read
.rdata$r:00004634 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004634                 assume cs:_rdata$r
.rdata$r:00004634                 ;org 4634h
.rdata$r:00004634 ; COMDAT (pick any)
.rdata$r:00004634                 public ??_R3error_category@std@@8
.rdata$r:00004634 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004634 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000460Co
.rdata$r:00004634                                         ; .rdata$r:00004664o
.rdata$r:00004635                 db    0
.rdata$r:00004636                 db    0
.rdata$r:00004637                 db    0
.rdata$r:00004638                 db    0
.rdata$r:00004639                 db    0
.rdata$r:0000463A                 db    0
.rdata$r:0000463B                 db    0
.rdata$r:0000463C                 db    1
.rdata$r:0000463D                 db    0
.rdata$r:0000463E                 db    0
.rdata$r:0000463F                 db    0
.rdata$r:00004640                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00004640 _rdata$r        ends
.rdata$r:00004640
.rdata$r:00004644 ; ===========================================================================
.rdata$r:00004644
.rdata$r:00004644 ; Segment type: Pure data
.rdata$r:00004644 ; Segment permissions: Read
.rdata$r:00004644 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004644                 assume cs:_rdata$r
.rdata$r:00004644                 ;org 4644h
.rdata$r:00004644 ; COMDAT (pick any)
.rdata$r:00004644                 public ??_R2error_category@std@@8
.rdata$r:00004644 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00004644 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00004644                                         ; DATA XREF: .rdata$r:00004640o
.rdata$r:00004644                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004648                 db    0
.rdata$r:00004649                 align 4
.rdata$r:00004649 _rdata$r        ends
.rdata$r:00004649
.rdata$r:0000464C ; ===========================================================================
.rdata$r:0000464C
.rdata$r:0000464C ; Segment type: Pure data
.rdata$r:0000464C ; Segment permissions: Read
.rdata$r:0000464C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000464C                 assume cs:_rdata$r
.rdata$r:0000464C                 ;org 464Ch
.rdata$r:0000464C ; COMDAT (pick any)
.rdata$r:0000464C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000464C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000464C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000464C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000464C                                         ; .rdata$r:000046BCo ...
.rdata$r:0000464C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00004650                 db    0
.rdata$r:00004651                 db    0
.rdata$r:00004652                 db    0
.rdata$r:00004653                 db    0
.rdata$r:00004654                 db    0
.rdata$r:00004655                 db    0
.rdata$r:00004656                 db    0
.rdata$r:00004657                 db    0
.rdata$r:00004658                 db 0FFh
.rdata$r:00004659                 db 0FFh
.rdata$r:0000465A                 db 0FFh
.rdata$r:0000465B                 db 0FFh
.rdata$r:0000465C                 db    0
.rdata$r:0000465D                 db    0
.rdata$r:0000465E                 db    0
.rdata$r:0000465F                 db    0
.rdata$r:00004660                 db  40h ; @
.rdata$r:00004661                 db    0
.rdata$r:00004662                 db    0
.rdata$r:00004663                 db    0
.rdata$r:00004664                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004664 _rdata$r        ends
.rdata$r:00004664
.rdata$r:00004668 ; ===========================================================================
.rdata$r:00004668
.rdata$r:00004668 ; Segment type: Pure data
.rdata$r:00004668 ; Segment permissions: Read
.rdata$r:00004668 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004668                 assume cs:_rdata$r
.rdata$r:00004668                 ;org 4668h
.rdata$r:00004668 ; COMDAT (pick any)
.rdata$r:00004668                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00004668 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00004668 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00004668                                         ; DATA XREF: .rdata:00004460o
.rdata$r:00004669                 db    0
.rdata$r:0000466A                 db    0
.rdata$r:0000466B                 db    0
.rdata$r:0000466C                 db    0
.rdata$r:0000466D                 db    0
.rdata$r:0000466E                 db    0
.rdata$r:0000466F                 db    0
.rdata$r:00004670                 db    0
.rdata$r:00004671                 db    0
.rdata$r:00004672                 db    0
.rdata$r:00004673                 db    0
.rdata$r:00004674                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004678                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004678 _rdata$r        ends
.rdata$r:00004678
.data$r:0000467C ; ===========================================================================
.data$r:0000467C
.data$r:0000467C ; Segment type: Pure data
.data$r:0000467C ; Segment permissions: Read/Write
.data$r:0000467C _data$r         segment dword public 'DATA' use32
.data$r:0000467C                 assume cs:_data$r
.data$r:0000467C                 ;org 467Ch
.data$r:0000467C ; COMDAT (pick any)
.data$r:0000467C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000467C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000467C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000467C                                         ; DATA XREF: .rdata$r:00004674o
.data$r:0000467C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000467C                                         ; const type_info::`vftable'
.data$r:00004680                 db    0
.data$r:00004681                 db    0
.data$r:00004682                 db    0
.data$r:00004683                 db    0
.data$r:00004684                 db  2Eh ; .
.data$r:00004685                 db  3Fh ; ?
.data$r:00004686                 db  41h ; A
.data$r:00004687                 db  56h ; V
.data$r:00004688                 db  5Fh ; _
.data$r:00004689                 db  47h ; G
.data$r:0000468A                 db  65h ; e
.data$r:0000468B                 db  6Eh ; n
.data$r:0000468C                 db  65h ; e
.data$r:0000468D                 db  72h ; r
.data$r:0000468E                 db  69h ; i
.data$r:0000468F                 db  63h ; c
.data$r:00004690                 db  5Fh ; _
.data$r:00004691                 db  65h ; e
.data$r:00004692                 db  72h ; r
.data$r:00004693                 db  72h ; r
.data$r:00004694                 db  6Fh ; o
.data$r:00004695                 db  72h ; r
.data$r:00004696                 db  5Fh ; _
.data$r:00004697                 db  63h ; c
.data$r:00004698                 db  61h ; a
.data$r:00004699                 db  74h ; t
.data$r:0000469A                 db  65h ; e
.data$r:0000469B                 db  67h ; g
.data$r:0000469C                 db  6Fh ; o
.data$r:0000469D                 db  72h ; r
.data$r:0000469E                 db  79h ; y
.data$r:0000469F                 db  40h ; @
.data$r:000046A0                 db  73h ; s
.data$r:000046A1                 db  74h ; t
.data$r:000046A2                 db  64h ; d
.data$r:000046A3                 db  40h ; @
.data$r:000046A4                 db  40h ; @
.data$r:000046A5                 db    0
.data$r:000046A6                 align 4
.data$r:000046A6 _data$r         ends
.data$r:000046A6
.rdata$r:000046A8 ; ===========================================================================
.rdata$r:000046A8
.rdata$r:000046A8 ; Segment type: Pure data
.rdata$r:000046A8 ; Segment permissions: Read
.rdata$r:000046A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000046A8                 assume cs:_rdata$r
.rdata$r:000046A8                 ;org 46A8h
.rdata$r:000046A8 ; COMDAT (pick any)
.rdata$r:000046A8                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000046A8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000046A8 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000046A8                                         ; DATA XREF: .rdata$r:00004678o
.rdata$r:000046A8                                         ; .rdata$r:000046DCo
.rdata$r:000046A9                 db    0
.rdata$r:000046AA                 db    0
.rdata$r:000046AB                 db    0
.rdata$r:000046AC                 db    0
.rdata$r:000046AD                 db    0
.rdata$r:000046AE                 db    0
.rdata$r:000046AF                 db    0
.rdata$r:000046B0                 db    2
.rdata$r:000046B1                 db    0
.rdata$r:000046B2                 db    0
.rdata$r:000046B3                 db    0
.rdata$r:000046B4                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000046B4 _rdata$r        ends
.rdata$r:000046B4
.rdata$r:000046B8 ; ===========================================================================
.rdata$r:000046B8
.rdata$r:000046B8 ; Segment type: Pure data
.rdata$r:000046B8 ; Segment permissions: Read
.rdata$r:000046B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000046B8                 assume cs:_rdata$r
.rdata$r:000046B8                 ;org 46B8h
.rdata$r:000046B8 ; COMDAT (pick any)
.rdata$r:000046B8                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000046B8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000046B8 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000046B8                                         ; DATA XREF: .rdata$r:000046B4o
.rdata$r:000046B8                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000046BC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000046C0                 db    0
.rdata$r:000046C1                 align 4
.rdata$r:000046C1 _rdata$r        ends
.rdata$r:000046C1
.rdata$r:000046C4 ; ===========================================================================
.rdata$r:000046C4
.rdata$r:000046C4 ; Segment type: Pure data
.rdata$r:000046C4 ; Segment permissions: Read
.rdata$r:000046C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000046C4                 assume cs:_rdata$r
.rdata$r:000046C4                 ;org 46C4h
.rdata$r:000046C4 ; COMDAT (pick any)
.rdata$r:000046C4                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000046C4 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000046C4 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000046C4                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000046C4                                         ; .rdata$r:00004734o ...
.rdata$r:000046C4                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000046C8                 db    1
.rdata$r:000046C9                 db    0
.rdata$r:000046CA                 db    0
.rdata$r:000046CB                 db    0
.rdata$r:000046CC                 db    0
.rdata$r:000046CD                 db    0
.rdata$r:000046CE                 db    0
.rdata$r:000046CF                 db    0
.rdata$r:000046D0                 db 0FFh
.rdata$r:000046D1                 db 0FFh
.rdata$r:000046D2                 db 0FFh
.rdata$r:000046D3                 db 0FFh
.rdata$r:000046D4                 db    0
.rdata$r:000046D5                 db    0
.rdata$r:000046D6                 db    0
.rdata$r:000046D7                 db    0
.rdata$r:000046D8                 db  40h ; @
.rdata$r:000046D9                 db    0
.rdata$r:000046DA                 db    0
.rdata$r:000046DB                 db    0
.rdata$r:000046DC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000046DC _rdata$r        ends
.rdata$r:000046DC
.rdata$r:000046E0 ; ===========================================================================
.rdata$r:000046E0
.rdata$r:000046E0 ; Segment type: Pure data
.rdata$r:000046E0 ; Segment permissions: Read
.rdata$r:000046E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000046E0                 assume cs:_rdata$r
.rdata$r:000046E0                 ;org 46E0h
.rdata$r:000046E0 ; COMDAT (pick any)
.rdata$r:000046E0                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000046E0 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000046E0 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000046E0                                         ; DATA XREF: .rdata:00004494o
.rdata$r:000046E1                 db    0
.rdata$r:000046E2                 db    0
.rdata$r:000046E3                 db    0
.rdata$r:000046E4                 db    0
.rdata$r:000046E5                 db    0
.rdata$r:000046E6                 db    0
.rdata$r:000046E7                 db    0
.rdata$r:000046E8                 db    0
.rdata$r:000046E9                 db    0
.rdata$r:000046EA                 db    0
.rdata$r:000046EB                 db    0
.rdata$r:000046EC                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000046F0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000046F0 _rdata$r        ends
.rdata$r:000046F0
.data$r:000046F4 ; ===========================================================================
.data$r:000046F4
.data$r:000046F4 ; Segment type: Pure data
.data$r:000046F4 ; Segment permissions: Read/Write
.data$r:000046F4 _data$r         segment dword public 'DATA' use32
.data$r:000046F4                 assume cs:_data$r
.data$r:000046F4                 ;org 46F4h
.data$r:000046F4 ; COMDAT (pick any)
.data$r:000046F4                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000046F4 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000046F4 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000046F4                                         ; DATA XREF: .rdata$r:000046ECo
.data$r:000046F4                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000046F4                                         ; const type_info::`vftable'
.data$r:000046F8                 db    0
.data$r:000046F9                 db    0
.data$r:000046FA                 db    0
.data$r:000046FB                 db    0
.data$r:000046FC                 db  2Eh ; .
.data$r:000046FD                 db  3Fh ; ?
.data$r:000046FE                 db  41h ; A
.data$r:000046FF                 db  56h ; V
.data$r:00004700                 db  5Fh ; _
.data$r:00004701                 db  49h ; I
.data$r:00004702                 db  6Fh ; o
.data$r:00004703                 db  73h ; s
.data$r:00004704                 db  74h ; t
.data$r:00004705                 db  72h ; r
.data$r:00004706                 db  65h ; e
.data$r:00004707                 db  61h ; a
.data$r:00004708                 db  6Dh ; m
.data$r:00004709                 db  5Fh ; _
.data$r:0000470A                 db  65h ; e
.data$r:0000470B                 db  72h ; r
.data$r:0000470C                 db  72h ; r
.data$r:0000470D                 db  6Fh ; o
.data$r:0000470E                 db  72h ; r
.data$r:0000470F                 db  5Fh ; _
.data$r:00004710                 db  63h ; c
.data$r:00004711                 db  61h ; a
.data$r:00004712                 db  74h ; t
.data$r:00004713                 db  65h ; e
.data$r:00004714                 db  67h ; g
.data$r:00004715                 db  6Fh ; o
.data$r:00004716                 db  72h ; r
.data$r:00004717                 db  79h ; y
.data$r:00004718                 db  40h ; @
.data$r:00004719                 db  73h ; s
.data$r:0000471A                 db  74h ; t
.data$r:0000471B                 db  64h ; d
.data$r:0000471C                 db  40h ; @
.data$r:0000471D                 db  40h ; @
.data$r:0000471E                 db    0
.data$r:0000471F                 align 10h
.data$r:0000471F _data$r         ends
.data$r:0000471F
.rdata$r:00004720 ; ===========================================================================
.rdata$r:00004720
.rdata$r:00004720 ; Segment type: Pure data
.rdata$r:00004720 ; Segment permissions: Read
.rdata$r:00004720 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004720                 assume cs:_rdata$r
.rdata$r:00004720                 ;org 4720h
.rdata$r:00004720 ; COMDAT (pick any)
.rdata$r:00004720                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00004720 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004720 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00004720                                         ; DATA XREF: .rdata$r:000046F0o
.rdata$r:00004720                                         ; .rdata$r:00004758o
.rdata$r:00004721                 db    0
.rdata$r:00004722                 db    0
.rdata$r:00004723                 db    0
.rdata$r:00004724                 db    0
.rdata$r:00004725                 db    0
.rdata$r:00004726                 db    0
.rdata$r:00004727                 db    0
.rdata$r:00004728                 db    3
.rdata$r:00004729                 db    0
.rdata$r:0000472A                 db    0
.rdata$r:0000472B                 db    0
.rdata$r:0000472C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000472C _rdata$r        ends
.rdata$r:0000472C
.rdata$r:00004730 ; ===========================================================================
.rdata$r:00004730
.rdata$r:00004730 ; Segment type: Pure data
.rdata$r:00004730 ; Segment permissions: Read
.rdata$r:00004730 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004730                 assume cs:_rdata$r
.rdata$r:00004730                 ;org 4730h
.rdata$r:00004730 ; COMDAT (pick any)
.rdata$r:00004730                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00004730 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00004730 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004730                                         ; DATA XREF: .rdata$r:0000472Co
.rdata$r:00004730                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004734                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004738                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000473C                 db    0
.rdata$r:0000473D                 align 10h
.rdata$r:0000473D _rdata$r        ends
.rdata$r:0000473D
.rdata$r:00004740 ; ===========================================================================
.rdata$r:00004740
.rdata$r:00004740 ; Segment type: Pure data
.rdata$r:00004740 ; Segment permissions: Read
.rdata$r:00004740 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004740                 assume cs:_rdata$r
.rdata$r:00004740                 ;org 4740h
.rdata$r:00004740 ; COMDAT (pick any)
.rdata$r:00004740                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004740 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004740 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00004740                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00004740                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004744                 db    2
.rdata$r:00004745                 db    0
.rdata$r:00004746                 db    0
.rdata$r:00004747                 db    0
.rdata$r:00004748                 db    0
.rdata$r:00004749                 db    0
.rdata$r:0000474A                 db    0
.rdata$r:0000474B                 db    0
.rdata$r:0000474C                 db 0FFh
.rdata$r:0000474D                 db 0FFh
.rdata$r:0000474E                 db 0FFh
.rdata$r:0000474F                 db 0FFh
.rdata$r:00004750                 db    0
.rdata$r:00004751                 db    0
.rdata$r:00004752                 db    0
.rdata$r:00004753                 db    0
.rdata$r:00004754                 db  40h ; @
.rdata$r:00004755                 db    0
.rdata$r:00004756                 db    0
.rdata$r:00004757                 db    0
.rdata$r:00004758                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004758 _rdata$r        ends
.rdata$r:00004758
.rdata$r:0000475C ; ===========================================================================
.rdata$r:0000475C
.rdata$r:0000475C ; Segment type: Pure data
.rdata$r:0000475C ; Segment permissions: Read
.rdata$r:0000475C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000475C                 assume cs:_rdata$r
.rdata$r:0000475C                 ;org 475Ch
.rdata$r:0000475C ; COMDAT (pick any)
.rdata$r:0000475C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000475C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000475C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:000044D4o
.rdata$r:0000475D                 db    0
.rdata$r:0000475E                 db    0
.rdata$r:0000475F                 db    0
.rdata$r:00004760                 db    0
.rdata$r:00004761                 db    0
.rdata$r:00004762                 db    0
.rdata$r:00004763                 db    0
.rdata$r:00004764                 db    0
.rdata$r:00004765                 db    0
.rdata$r:00004766                 db    0
.rdata$r:00004767                 db    0
.rdata$r:00004768                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000476C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000476C _rdata$r        ends
.rdata$r:0000476C
.data$r:00004770 ; ===========================================================================
.data$r:00004770
.data$r:00004770 ; Segment type: Pure data
.data$r:00004770 ; Segment permissions: Read/Write
.data$r:00004770 _data$r         segment dword public 'DATA' use32
.data$r:00004770                 assume cs:_data$r
.data$r:00004770                 ;org 4770h
.data$r:00004770 ; COMDAT (pick any)
.data$r:00004770                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00004770 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00004770 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004770                                         ; DATA XREF: .rdata$r:00004768o
.data$r:00004770                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004770                                         ; const type_info::`vftable'
.data$r:00004774                 align 8
.data$r:00004778 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00004799                 align 4
.data$r:00004799 _data$r         ends
.data$r:00004799
.rdata$r:0000479C ; ===========================================================================
.rdata$r:0000479C
.rdata$r:0000479C ; Segment type: Pure data
.rdata$r:0000479C ; Segment permissions: Read
.rdata$r:0000479C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000479C                 assume cs:_rdata$r
.rdata$r:0000479C                 ;org 479Ch
.rdata$r:0000479C ; COMDAT (pick any)
.rdata$r:0000479C                 public ??_R3_System_error_category@std@@8
.rdata$r:0000479C ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000479C ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000476Co
.rdata$r:0000479C                                         ; .rdata$r:000047D4o
.rdata$r:0000479D                 db    0
.rdata$r:0000479E                 db    0
.rdata$r:0000479F                 db    0
.rdata$r:000047A0                 db    0
.rdata$r:000047A1                 db    0
.rdata$r:000047A2                 db    0
.rdata$r:000047A3                 db    0
.rdata$r:000047A4                 db    3
.rdata$r:000047A5                 db    0
.rdata$r:000047A6                 db    0
.rdata$r:000047A7                 db    0
.rdata$r:000047A8                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000047A8 _rdata$r        ends
.rdata$r:000047A8
.rdata$r:000047AC ; ===========================================================================
.rdata$r:000047AC
.rdata$r:000047AC ; Segment type: Pure data
.rdata$r:000047AC ; Segment permissions: Read
.rdata$r:000047AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000047AC                 assume cs:_rdata$r
.rdata$r:000047AC                 ;org 47ACh
.rdata$r:000047AC ; COMDAT (pick any)
.rdata$r:000047AC                 public ??_R2_System_error_category@std@@8
.rdata$r:000047AC ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000047AC ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000047AC                                         ; DATA XREF: .rdata$r:000047A8o
.rdata$r:000047AC                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000047B0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000047B4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000047B8                 db    0
.rdata$r:000047B9                 align 4
.rdata$r:000047B9 _rdata$r        ends
.rdata$r:000047B9
.rdata$r:000047BC ; ===========================================================================
.rdata$r:000047BC
.rdata$r:000047BC ; Segment type: Pure data
.rdata$r:000047BC ; Segment permissions: Read
.rdata$r:000047BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000047BC                 assume cs:_rdata$r
.rdata$r:000047BC                 ;org 47BCh
.rdata$r:000047BC ; COMDAT (pick any)
.rdata$r:000047BC                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000047BC ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000047BC ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000047BC                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000047BC                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000047C0                 db    2
.rdata$r:000047C1                 db    0
.rdata$r:000047C2                 db    0
.rdata$r:000047C3                 db    0
.rdata$r:000047C4                 db    0
.rdata$r:000047C5                 db    0
.rdata$r:000047C6                 db    0
.rdata$r:000047C7                 db    0
.rdata$r:000047C8                 db 0FFh
.rdata$r:000047C9                 db 0FFh
.rdata$r:000047CA                 db 0FFh
.rdata$r:000047CB                 db 0FFh
.rdata$r:000047CC                 db    0
.rdata$r:000047CD                 db    0
.rdata$r:000047CE                 db    0
.rdata$r:000047CF                 db    0
.rdata$r:000047D0                 db  40h ; @
.rdata$r:000047D1                 db    0
.rdata$r:000047D2                 db    0
.rdata$r:000047D3                 db    0
.rdata$r:000047D4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000047D4 _rdata$r        ends
.rdata$r:000047D4
.CRT$XCU:000047D8 ; ===========================================================================
.CRT$XCU:000047D8
.CRT$XCU:000047D8 ; Segment type: Pure data
.CRT$XCU:000047D8 ; Segment permissions: Read
.CRT$XCU:000047D8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000047D8                 assume cs:_CRT$XCU
.CRT$XCU:000047D8                 ;org 47D8h
.CRT$XCU:000047D8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000047DC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000047E0 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:000047E4 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:000047E4 _CRT$XCU        ends
.CRT$XCU:000047E4
.CRT$XCU:000047E8 ; ===========================================================================
.CRT$XCU:000047E8
.CRT$XCU:000047E8 ; Segment type: Pure data
.CRT$XCU:000047E8 ; Segment permissions: Read
.CRT$XCU:000047E8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000047E8                 assume cs:_CRT$XCU
.CRT$XCU:000047E8                 ;org 47E8h
.CRT$XCU:000047E8 ; COMDAT (pick associative to section at 44F8)
.CRT$XCU:000047E8 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000047E8 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000047E8 _CRT$XCU        ends
.CRT$XCU:000047E8
.CRT$XCU:000047EC ; ===========================================================================
.CRT$XCU:000047EC
.CRT$XCU:000047EC ; Segment type: Pure data
.CRT$XCU:000047EC ; Segment permissions: Read
.CRT$XCU:000047EC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000047EC                 assume cs:_CRT$XCU
.CRT$XCU:000047EC                 ;org 47ECh
.CRT$XCU:000047EC ; COMDAT (pick associative to section at 44FC)
.CRT$XCU:000047EC ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000047EC ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000047EC _CRT$XCU        ends
.CRT$XCU:000047EC
.CRT$XCU:000047F0 ; ===========================================================================
.CRT$XCU:000047F0
.CRT$XCU:000047F0 ; Segment type: Pure data
.CRT$XCU:000047F0 ; Segment permissions: Read
.CRT$XCU:000047F0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000047F0                 assume cs:_CRT$XCU
.CRT$XCU:000047F0                 ;org 47F0h
.CRT$XCU:000047F0 ; COMDAT (pick associative to section at 4500)
.CRT$XCU:000047F0 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000047F0 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000047F0 _CRT$XCU        ends
.CRT$XCU:000047F0
.CRT$XCU:000047F4 ; ===========================================================================
.CRT$XCU:000047F4
.CRT$XCU:000047F4 ; Segment type: Pure data
.CRT$XCU:000047F4 ; Segment permissions: Read
.CRT$XCU:000047F4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000047F4                 assume cs:_CRT$XCU
.CRT$XCU:000047F4                 ;org 47F4h
.CRT$XCU:000047F4 ; COMDAT (pick associative to section at 4504)
.CRT$XCU:000047F4 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000047F4 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000047F4 _CRT$XCU        ends
.CRT$XCU:000047F4
.CRT$XCU:000047F8 ; ===========================================================================
.CRT$XCU:000047F8
.CRT$XCU:000047F8 ; Segment type: Pure data
.CRT$XCU:000047F8 ; Segment permissions: Read
.CRT$XCU:000047F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000047F8                 assume cs:_CRT$XCU
.CRT$XCU:000047F8                 ;org 47F8h
.CRT$XCU:000047F8 ; COMDAT (pick associative to section at 4508)
.CRT$XCU:000047F8 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000047F8 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000047F8 _CRT$XCU        ends
.CRT$XCU:000047F8
.CRT$XCU:000047FC ; ===========================================================================
.CRT$XCU:000047FC
.CRT$XCU:000047FC ; Segment type: Pure data
.CRT$XCU:000047FC ; Segment permissions: Read
.CRT$XCU:000047FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000047FC                 assume cs:_CRT$XCU
.CRT$XCU:000047FC                 ;org 47FCh
.CRT$XCU:000047FC ; COMDAT (pick associative to section at 45A0)
.CRT$XCU:000047FC ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000047FC ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000047FC _CRT$XCU        ends
.CRT$XCU:000047FC
.CRT$XCU:00004800 ; ===========================================================================
.CRT$XCU:00004800
.CRT$XCU:00004800 ; Segment type: Pure data
.CRT$XCU:00004800 ; Segment permissions: Read
.CRT$XCU:00004800 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004800                 assume cs:_CRT$XCU
.CRT$XCU:00004800                 ;org 4800h
.CRT$XCU:00004800 ; COMDAT (pick associative to section at 45A4)
.CRT$XCU:00004800 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00004800 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00004800 _CRT$XCU        ends
.CRT$XCU:00004800
UNDEF:00004810 ; ===========================================================================
UNDEF:00004810
UNDEF:00004810 ; Segment type: Externs
UNDEF:00004810 ; UNDEF
UNDEF:00004810                 extrn __purecall:near   ; DATA XREF: .rdata:0000444Co
UNDEF:00004810                                         ; .rdata:00004450o
UNDEF:00004814 ; void *__cdecl operator new(unsigned int)
UNDEF:00004814                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00004814                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p ...
UNDEF:00004818 ; void __cdecl operator delete(void *)
UNDEF:00004818                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00004818                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000481C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000481C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000481C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00004820 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00004820                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00004820                                         ; _wmemcpy+11p
UNDEF:00004824 ; size_t __cdecl strlen(const char *Str)
UNDEF:00004824                 extrn _strlen:near      ; CODE XREF: SmartHighlighter::isQualifiedWord(char const *)+14p
UNDEF:00004824                                         ; std::char_traits<char>::length(char const *)+1Bp
UNDEF:00004828 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00004828                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00004828                                         ; _wmemmove+11p
UNDEF:0000482C ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000482C                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00004830 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00004830                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00004830                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00004834 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00004834                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00004834                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00004834                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00004838                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000483C ; void __cdecl operator delete[](void *)
UNDEF:0000483C                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000483C                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+188p
UNDEF:00004840 ; void *__cdecl operator new[](unsigned int)
UNDEF:00004840                 extrn ??_U@YAPAXI@Z:near
UNDEF:00004840                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+79p
UNDEF:00004844 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00004844                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00004844                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00004844                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+16p
UNDEF:00004848 ; void __cdecl std::_Xbad_alloc()
UNDEF:00004848                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00004848                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_138Ep
UNDEF:00004848                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_13D0p ...
UNDEF:0000484C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000484C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000484C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000484C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp
UNDEF:00004850 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00004850                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00004850                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00004850                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00004854 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004854                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004854                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00004858 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00004858                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00004858                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00004858                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000485C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000485C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000485C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00004860 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004860                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004860                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00004864 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004864                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004864                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00004868 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004868                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004868                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000486C ; const wchar_t *__thiscall WcharMbcsConvertor::char2wchar(WcharMbcsConvertor *__hidden this, const char *, unsigned int, int, int *, int *)
UNDEF:0000486C                 extrn ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z:near
UNDEF:0000486C                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+2E0p
UNDEF:00004870 ; char *__thiscall ScintillaEditView::getSelectedText(ScintillaEditView *__hidden this, char *, int, bool)
UNDEF:00004870                 extrn ?getSelectedText@ScintillaEditView@@QAEPADPADH_N@Z:near
UNDEF:00004870                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+A6p
UNDEF:00004874 ; int __thiscall __high FindReplaceDlg::processRange(enum ProcessOperation, const wchar_t *, const wchar_t *, int, int, const wchar_t *, const struct FindOption *, int)
UNDEF:00004874                 extrn ?processRange@FindReplaceDlg@@QAEHW4ProcessOperation@@PB_W1HH1PBUFindOption@@H@Z:near
UNDEF:00004874                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+3D3p
UNDEF:00004874                                         ; SmartHighlighter::highlightView(ScintillaEditView *)+408p
UNDEF:00004878 ; __fastcall __security_check_cookie(x)
UNDEF:00004878                 extrn @__security_check_cookie@4:near
UNDEF:00004878                                         ; CODE XREF: SmartHighlighter::highlightView(ScintillaEditView *)+460p
UNDEF:00004878                                         ; __ehhandler$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z+Fp ...
UNDEF:0000487C ; __stdcall _CxxThrowException(x, x)
UNDEF:0000487C                 extrn __CxxThrowException@8:near
UNDEF:0000487C                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:0000487C                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+10p
UNDEF:00004880                 extrn ___CxxFrameHandler3:near
UNDEF:00004880                                         ; CODE XREF: __ehhandler$?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z+23j
UNDEF:00004880                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j ...
UNDEF:00004884 ; const type_info::`vftable'
UNDEF:00004884                 extrn ??_7type_info@@6B@:near
UNDEF:00004884                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00004884                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00004888 ; protected: static class WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
UNDEF:00004888                 extrn ?_pSelf@WcharMbcsConvertor@@1PAV1@A:near
UNDEF:00004888                                         ; DATA XREF: WcharMbcsConvertor::getInstance(void)+3r
UNDEF:0000488C ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000488C                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000488C                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00004890                 extrn ___security_cookie:near
UNDEF:00004890                                         ; DATA XREF: SmartHighlighter::highlightView(ScintillaEditView *)+17r
UNDEF:00004890                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00004894                 extrn __fltused:near
UNDEF:00004894
UNDEF:00004894
UNDEF:00004894                 end